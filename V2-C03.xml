<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: 
  Formateado DocBook:  

  Documento original: http://arco.inf-cr.uclm.es/~david.villa/pensar_en_C++/TICv2/html/TicV2.html#_Toc53985657
-->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="C3" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Las cadenas a fondo</title>

  <!--
  String processing with character arrays is one of the biggest
  time?wasters in C. Character arrays require the programmer to keep track
  of the difference between static quoted strings and arrays created on
  the stack and the heap, and the fact that sometimes you're passing
  around a char* and sometimes you must copy the whole array.
  -->

  <highlights>
    <para>
      El procesamiento de cadenas de caracteres es una de las mayores
      perdidas de tiempo en C. Las cadenas de caracteres
      requieren que el programador tenga en cuenta las diferencias entre
      cadenas estáticas y las cadenas creadas en la pila y en el montón,
      además del hecho que a veces usamos un <type>char*</type> y a
      veces debemos copiar el arreglo entero.
    </para>
  </highlights>

  <!--
  Especially because string manipulation is so common, character arrays
  are a great source of misunderstandings and bugs. Despite this, creating
  string classes remained a common exercise for beginning C++ programmers
  for many years. The Standard C++ library string class solves the problem
  of character array manipulation once and for all, keeping track of
  memory even during assignments and copy-constructions. You simply don't
  need to think about it.
  -->

  <para>
    Especialmente porque la manipulación de cadenas es tan común, las
    cadenas de caracteres son una gran fuente de confusiones y
    errores. Es por esto que la creación de clases de cadenas sigue
    siendo desde hace años un ejercicio común para programadores
    novatos. La clase <classname>string</classname> de la biblioteca
    estándar de C++ resuelve el problema de la manipulación de
    caracteres de una vez por todas, gestionando la memoria incluso
    durante las asignaciones y las construcciones de copia.  Simplemente
    no necesita pensar en ello.
  </para>

  <!--
  This chapter[31] examines the Standard C++ string class, beginning with
  a look at what constitutes a C++ string and how the C++ version differs
  from a traditional C character array. You'll learn about operations and
  manipulations using string objects, and you'll see how C++ strings
  accommodate variation in character sets and string data conversion.
  -->

  <para>
    Este capítulo examina la clase <classname>string</classname> del
    estándar C++; se empieza observando de qué están compuestas los
    <classname>string</classname> de C++ y como la versión de C++
    difiere del tradicional arreglo de caracteres de C. Aprenderá sobre
    las operaciones y la manipulación usando objetos
    <classname>string</classname>, y verá como estas se acomodan a la
    variación de conjuntos de caracteres y conversión de
    datos.
    <footnote>
      <para>
	Algunos materiales de este capítulo fueron creados originalmente
	por Nancy Nicolaisen
      </para>
    </footnote>
  </para>

  <!--
  Handling text is one of the oldest programming applications, so it's
  not surprising that the C++ string draws heavily on the ideas and
  terminology that have long been used in C and other languages. As you
  begin to acquaint yourself with C++ strings, this fact should be
  reassuring. No matter which programming idiom you choose, there are
  three common things you want to do with a string:
  -->

  <para>
    Manipular texto es una de las aplicaciones más antiguas de la
    programación, luego no es sorprendente que los
    <classname>string</classname> de C++ estén fuertemente inspiradas en
    las ideas y la terminología que ha usado continuamente en C y otros
    lenguajes. Tal como vaya aprendiendo sobre los
    <classname>string</classname> de C++, este hecho se debería ir
    viendo más claramente. Da igual el lenguaje de programación que
    escoja, existen tres cosas comunes que desea hacer con las
    cadenas:
  </para>

  <!-- · Create or modify the sequence of characters stored in the string. -->

  <!-- · Detect the presence or absence of elements within the string. -->

  <!-- · Translate between various schemes for representing string characters. -->

  <para>
    <itemizedlist>
      <listitem>
        <para>Crear o modificar secuencias de caracteres almacenados en una
        cadena</para>
      </listitem>

      <listitem>
        <para>Detectar la presencia o ausencia de elementos dentro de la
        cadena</para>
      </listitem>

      <listitem>
        <para>Traducir entre diversos esquemas para representar cadenas de
        caracteres</para>
      </listitem>
    </itemizedlist>
  </para>

  <!--
  You'll see how each of these jobs is accomplished using C++ string
  objects.
  -->

  <para>
    Verá como cada una de estas tareas se resuelve usando objetos
    <classname>string</classname> en C++.
  </para>

  <sect1>
    <!-- : What's in a string? -->
    <title>¿Qué es un <classname>string</classname>?</title>

    <!--
    In C, a string is simply an array of characters that always includes a
    binary zero (often called the null terminator) as its final array
    element. There are significant differences between C++ strings and their
    C progenitors. First, and most important, C++ strings hide the physical
    representation of the sequence of characters they contain. You don't
    need to be concerned about array dimensions or null terminators. A
    string also contains certain ??housekeeping?? information about the size
    and storage location of its data. Specifically, a C++ string object
    knows its starting location in memory, its content, its length in
    characters, and the length in characters to which it can grow before the
    string object must resize its internal data buffer. C++ strings thus
    greatly reduce the likelihood of making three of the most common and
    destructive C programming errors: overwriting array bounds, trying to
    access arrays through uninitialized or incorrectly valued pointers, and
    leaving pointers ??dangling?? after an array ceases to occupy the
    storage that was once allocated to it.
    -->

    <para>
      En C, una cadena es simplemente un arreglo de caracteres que
      siempre incluye un 0 binario (frecuentemente llamado terminador
      nulo) como elemento final del arreglo. Existen diferencias
      significativas entre los <classname>string</classname> de C++ y
      sus progenitoras en C. Primero, y más importante, los
      <classname>string</classname> de C++ esconden la implementación
      física de la secuencia de caracteres que contiene. No debe
      preocuparse acerca de las dimensiones del arreglo o del terminador
      nulo. Un <classname>string</classname> también contiene cierta
      información para uso interno sobre el tamaño y la localización en
      memoria de los datos.  Específicamente, un objeto
      <classname>string</classname> de C++ conoce su localización en
      memoria, su contenido, su longitud en caracteres, y la longitud en
      caracteres que puede crecer antes de que el objeto
      <classname>string</classname> deba redimensionar su buffer interno
      de datos.  Los <classname>string</classname> de C++, por tanto,
      reducen enormemente las probabilidades de cometer uno de los tres
      errores de programación en C más comunes y destructivos:
      sobrescribir los límites del arreglo, intentar acceder a un
      arreglo no inicializado o con valores de puntero incorrectos, y
      dejar punteros colgando después de que el arreglo deje de ocupar
      el almacenamiento que estaba ocupando.
    </para>

    <!-- 
    The exact implementation of memory layout for the string class
    is not defined by the C++ Standard. This architecture is intended to
    be flexible enough to allow differing implementations by compiler
    vendors, yet guarantee predictable behavior for users. In
    particular, the exact conditions under which storage is allocated to
    hold data for a string object are not defined. String allocation
    rules were formulated to allow but not require a reference-counted
    implementation, but whether or not the implementation uses reference
    counting, the semantics must be the same. To put this a bit
    differently, in C, every char array occupies a unique physical
    region of memory. In C++, individual string objects may or may not
    occupy unique physical regions of memory, but if reference counting
    avoids storing duplicate copies of data, the individual objects must
    look and act as though they exclusively own unique regions of
    storage. For example: --> 

    <para>
      La implementación exacta del esquema en memoria para una clase
      string no esta definida en el estándar C++. Esta arquitectura esta
      pensada para ser suficientemente flexible para permitir diferentes
      implementaciones de los fabricantes de compiladores, garantizando
      igualmente un comportamiento predecible por los usuarios. En
      particular, las condiciones exactas de cómo situar el
      almacenamiento para alojar los datos para un objeto
      <classname>string</classname> no están definidas. FIXME: Las
      reglas de alojamiento de un <classname>string</classname> fueron
      formuladas para permitir, pero no requerir, una implementación con
      referencias múltiples, pero dependiendo de la implementación usar
      referencias múltiples sin variar la semántica. Por decirlo de otra
      manera, en C, todos los arreglos de char ocupan una única región
      física de memoria. En C++, los objetos
      <classname>string</classname> individuales pueden o no ocupar
      regiones físicas únicas de memoria, pero si su conjunto de
      referencias evita almacenar copias duplicadas de datos, los
      objetos individuales deben parecer y actuar como si tuvieran sus
      propias regiones únicas de almacenamiento.
    </para>


//: C03:StringStorage.h


    <!-- We say that an implementation that only makes unique
    copies when a string is modified uses a copy-on-write strategy. This
    approach saves time and space when strings are used only as value
    parameters or in other read-only situations. -->

    <para>
      Decimos que cuando una implementación  solo hace una sola copia al
      modificar el  <classname>string</classname> usa una  estrategia de
      copiar  al escribir.  Esta  aproximación ahorra  tiempo y  espacio
      cuando  usamos <classname>string</classname>  como  parámetros por
      valor o en otras situaciones de solo lectura.
    </para>

    <!-- Whether a library implementation uses reference counting or not
    should be transparent to users of the string class. Unfortunately,
    this is not always the case. In multithreaded programs, it is
    practically impossible to use a reference-counting implementation
    safely.[32] -->

    <para>
      El uso de referencias múltiples en la implementación de una
      librería debería ser transparente al usuario de la clase string.
      Desgraciadamente, esto no es siempre el caso. En programas
      multihilo, es prácticamente imposible usar implementaciones con
      múltiples referencias de forma segura[32].<footnote> <para>Es
      dificil hacer implementaciones con multiples referencias para
      trabajar de manera segura en multihilo. (Ver <citation>More
      Exceptional C++, pp.104-14</citation>). Ver Capitulo 10 para más
      información sobre multiples hilos</para> </footnote>
    </para>
  </sect1>

  <sect1>
    <!-- : Operating on strings -->
    <title>Operaciones con cadenas</title>

    <!--
    If you've programmed in C, you are accustomed to the family of
    functions that write, search, modify, and copy char arrays. There are
    two unfortunate aspects of the Standard C library functions for handling
    char arrays. First, there are two loosely organized families of them:
    the ??plain?? group, and the ones that require you to supply a count of
    the number of characters to be considered in the operation at hand. The
    roster of functions in the C char array library shocks the unsuspecting
    user with a long list of cryptic, mostly unpronounceable names. Although
    the type and number of arguments to the functions are somewhat
    consistent, to use them properly you must be attentive to details of
    function naming and parameter passing.
    -->

    <para>Si ha programado en C, estará acostumbrado a la familia de
    funciones que leen, escriben, modifican y copian cadenas. Existen dos
    aspectos poco afortunados en la funciones de la librería estándar de C
    para manipular cadenas. Primero, hay dos familias pobremente organizadas:
    el grupo plano, y aquellos que requieren que se les suministre el número
    de caracteres para ser consideradas en la operación a mano. La lista de
    funciones en la librería de cadenas de C sorprende al usuario desprevenido
    con una larga lista de nombres crípticos y mayoritariamente
    impronunciables. Aunque el tipo y número de argumentos es algo
    consistente, para usarlas adecuadamente debe estar atento a los detalles
    de nombres de la función y a los parámetros que le pasas.</para>

    <!--
    The second inherent trap of the standard C char array tools is that they
    all rely explicitly on the assumption that the character array includes
    a null terminator. If by oversight or error the null is omitted or
    overwritten, there's little to keep the C char array functions from
    manipulating the memory beyond the limits of the allocated space,
    sometimes with disastrous results.
    -->

    <para>La segunda trampa inherente a las herramientas para cadenas del
    estándar de C es que todas ellas explícitamente confían en la asunción de
    que cada cadena incluye un terminador nulo. Si por confusión o error el
    terminador nulo es omitido o sobrescrito, poco se puede hacer para impedir
    que las funciones de cadena de C manipulen la memoria más allá de los
    límites del espacio de alojamiento, a veces con resultados
    desastrosos.</para>

    <!--
    C++ provides a vast improvement in the convenience and safety of string
    objects. For purposes of actual string handling operations, there are
    about the same number of distinct member function names in the string
    class as there are functions in the C library, but because of
    overloading the functionality is much greater. Coupled with sensible
    naming practices and the judicious use of default arguments, these
    features combine to make the string class much easier to use than the C
    library char array functions.
    -->

    <para>C++ aporta una vasta mejora en cuanto a conveniencia y seguridad de
    los objetos <classname>string</classname>. Para los propósitos de las
    actuales operaciones de manipulación, existe el mismo número de funciones
    que la librería de C, pero gracias a la sobrecarga, la funcionalidad es
    mucho mayor. Además, con una nomenclatura más sensata y un acertado uso de
    los argumentos por defecto, estas características se combinan para hacer
    de la clase <classname>string</classname> mucho más fácil de usar que la biblioteca de funciones
    de cadena de C.</para>

    <sect2>
      <!-- : Appending, inserting, and concatenating strings -->
      <title>Añadiendo, insertando y concatenando cadenas</title> 

      <!--
      One of the most valuable and convenient aspects of C++ strings is that
      they grow as needed, without intervention on the part of the
      programmer. Not only does this make string-handling code inherently more
      trustworthy, it also almost entirely eliminates a tedious ??housekeeping??
      chore?keeping track of the bounds of the storage where your strings
      live. For example, if you create a string object and initialize it with
      a string of 50 copies of ??X', and later store in it 50 copies of
      ??Zowie??, the object itself will reallocate sufficient storage to
      accommodate the growth of the data. Perhaps nowhere is this property
      more appreciated than when the strings manipulated in your code change
      size and you don't know how big the change is. The string member
      functions append( ) and insert( ) transparently reallocate storage when
      a string grows:
      --> 

      <para>
	Uno de los aspectos más valiosos y convenientes de los
	<classname>string</classname> en C++ es que crecen cuando lo
	necesitan, sin intervención por parte del programador. No solo
	hace el código de manejo del <classname>string</classname> sea
	inherentemente mas confiable, además elimina por completo las
	tediosas funciones "caseras" para controlar los limites del
	almacenamiento en donde nuestra cadena reside.  Por ejemplo, si
	crea un objeto <classname>string</classname> e inicializa este
	<classname>string</classname> con 50 copias de "X", y después
	copia en el 50 copias de "Zowie", el objeto, por sí mismo,
	readecua suficiente almacenamiento para acomodar el crecimiento
	de los datos. Quizás en ningún otro lugar es más apreciada esta
	propiedad que cuando las cadenas manipuladas por su	código
	cambian de tamaño y no sabe cuan grande puede ser este
	cambio. La función miembro <function>append()</function> e
	<function>insert()</function> de <classname>string</classname>
	reubican de manera transparente el almacenamiento cuando un
	<classname>string</classname> crece:
      </para>


//: C03:StrSize.cpp 


      <!-- Here is the output from one particular compiler: -->
      <para>
	Aquí la salida desde un compilador cualquiera:
      </para> 

      <!--
      I saw Elvis in a UFO.
      Size = 22
      Capacity = 31
      I thought I saw Elvis in a UFO.
      Size = 32
      Capacity = 47
      I thought I saw Elvis in a UFO. I've been
      working too hard.
      Size = 59
      Capacity = 511
      --> 

<screen>
I saw Elvis in a UFO.
Size = 22
Capacity = 31
I thought I saw Elvis in a UFO.
Size = 32
Capacity = 47
I thought I saw Elvis in a UFO. I've been
working too hard.
Size = 59
Capacity = 511
</screen>



      <!--
      This example demonstrates that even though you can safely relinquish
      much of the responsibility for allocating and managing the memory your
      strings occupy, C++ strings provide you with several tools to monitor
      and manage their size. Notice the ease with which we changed the size of
      the storage allocated to the string. The size( ) function returns the
      number of characters currently stored in the string and is identical to
      the length( ) member function. The capacity( ) function returns the size
      of the current underlying allocation, meaning the number of characters
      the string can hold without requesting more storage. The reserve( )
      function is an optimization mechanism that indicates your intention to
      specify a certain amount of storage for future use; capacity( ) always
      returns a value at least as large as the most recent call to reserve(
      ). A resize( ) function appends spaces if the new size is greater than
      the current string size or truncates the string otherwise. (An overload
      of resize( ) can specify a different character to append.)
      -->
      <para>
		Este ejemplo demuestra que aunque puede ignorar con seguridad
    muchas de las responsabilidades de reserva y gestión de la memoria que tus
    <classname>string</classname> ocupan, C++ provee a los
    <classname>string</classname> con varias herramientas para monitorizar y
    gestionar su tamaño. Nótese la facilidad con la que hemos cambiado el
    tamaño de la memoria reservada para los <classname>string</classname>. La
    función <function>size()</function> retorna el numero de caracteres
    actualmente almacenados en el <classname>string</classname> y es idéntico
    a la función miembro <function>lenght()</function>. La función
    <function>capacity()</function> retorna el tamaño de la memoria subyacente
    actual, es decir, el número de caracteres que el
    <classname>string</classname> puede almacenar sin tener que reservar más
    memoria. La función <function>reserve()</function> es una optimización del
    mecanismo que indica su intención de especificar cierta cantidad de
    memoria para un futuro uso; <function>capacity()</function> siempre
    retorna un valor al menos tan largo como la ultima llamada a
    <function>reserve()</function>. La función <function>resize()</function>
    añade espacio si el nuevo tamaño es mayor que el tamaño actual del
    <classname>string</classname>; sino trunca el
    <classname>string</classname>. (Una sobrecarga de
    <function>resize()</function> puede especificar una adición diferente de
    caracteres).
      </para>

      <!--
      The exact fashion that the string member functions allocate space for
      your data depends on the implementation of the library. When we tested
      one implementation with the previous example, it appeared that
      reallocations occurred on even word (that is, full-integer) boundaries,
      with one byte held back. The architects of the string class have
      endeavored to make it possible to mix the use of C char arrays and C++
      string objects, so it is likely that figures reported by StrSize.cpp for
      capacity reflect that, in this particular implementation, a byte is set
      aside to easily accommodate the insertion of a null terminator.
      -->
      <para>
		La manera exacta en que las funciones miembro de <classname>string</classname> reservan espacio para sus datos 	depende de la implementación de la librería. Cuando testeamos una implementación con el ejemplo anterior, parece que se hacia una reserva de una palabra de memoria (esto es, un entero) dejando un byte en blanco entre cada una de ellas. Los arquitectos de la clase string se esforzaron para poder mezclar el uso de las cadenas de caracteres de C y los objetos <classname>string</classname>, por lo que es probable por lo que se puede observar en <emphasis>StrSize.cpp</emphasis>, en esta implementación en particular, el byte esté añadido para acomodar fácilmente la inserción de un terminador nulo.
      </para>

    </sect2>
    <sect2>
      <!-- : Replacing string characters -->
      <title>Reemplazar caracteres en cadenas </title>

      <!--
      The insert( ) function is particularly nice because it absolves you from
      making sure the insertion of characters in a string won't overrun the
      storage space or overwrite the characters immediately following the
      insertion point. Space grows, and existing characters politely move over
      to accommodate the new elements. Sometimes this might not be what you
      want. If you want the size of the string to remain unchanged, use the
      replace( ) function to overwrite characters. There are a number of
      overloaded versions of replace( ), but the simplest one takes three
      arguments: an integer indicating where to start in the string, an
      integer indicating how many characters to eliminate from the original
      string, and the replacement string (which can be a different number of
      characters than the eliminated quantity). Here's a simple example:
      -->
      <para>
		La función <function>insert()</function> es particularmente útil por que te evita el tener que estar seguro de que la inserción de caracteres en un <classname>string</classname> no sobrepasa el espacio reservado o sobrescribe los caracteres que inmediatamente siguientes al punto de inserción. El espacio crece y los caracteres existentes se mueven graciosamente para acomodar a los nuevos elementos. A veces, puede que no sea esto exactamente lo que quiere. Si quiere que el tamaño del <classname>string</classname> permanezca sin cambios, use la función <function>replace()</function> para sobrescribir los caracteres. Existe un número de versiones sobrecargadas de <function>replace()</function>, pero la más simple toma tres argumentos: un entero indicando donde empezar en el <classname>string</classname>, un entero indicando cuantos caracteres para eliminar del <classname>string</classname> original, y el <classname>string</classname> con el que reemplazaremos (que puede ser diferente en numero de caracteres que la cantidad eliminada). Aquí un ejemplo simple:
      </para>


//: C03:StringReplace.cpp


      <!--
      The tag is first inserted into s (notice that the insert happens before
      the value indicating the insert point and that an extra space was added
      after tag), and then it is found and replaced.
      -->
      <para>
<varname>Tag</varname> es insertada en <varname>s</varname> (notese que la inserción ocurre <emphasis>antes</emphasis> de que el valor indicando el punto de inserción y de que el espacio extra haya sido añadido despues de <varname>Tag</varname>), y entonces es encontrada y reemplazada.
      </para>

      <!--
      You should check to see if you've found anything before you perform a
      replace( ). The previous example replaces with a char*, but there's an
      overloaded version that replaces with a string. Here's a more complete
      demonstration replace( ):
      -->
      <para>
		Debería cerciorarse de que ha encontrado algo antes de realizar el <function>replace()</function>. En los ejemplos anteriores se reemplaza con un <type>char*</type>, pero existe una versión sobrecargada que reemplaza con un <classname>string</classname>. Aqui hay un ejempl más completo de demostración de <function>replace()</function>:
      </para>


//: C03:Replace.cpp


      <!--
      If replace doesn't find the search string, it returns string::npos. The
      npos data member is a static constant member of the string class that
      represents a nonexistent character position.[33]
      -->
      <para>
		Si <function>replace()</function> no encuentra la cadena buscada, retorna un <classname>string::</classname><varname>npos</varname>. El dato miembro <varname>npos</varname> es una constante estatica de la clase <classname>string</classname> que representa una posición de carácter que no existe[33].
<footnote>
<para>
Es una abrviación de <foreignphrase>"no position"</foreignphrase>, y su valor más alto puede ser representado por el ubicador de <classname>string</classname> <varname>size_type</varname> (<varname>std::size_t</varname> por defecto).
</para>
</footnote>
      </para>

      <!--
      Unlike insert( ), replace( ) won't grow the string's storage space if
      you copy new characters into the middle of an existing series of array
      elements. However, it will grow the storage space if needed, for
      example, when you make a ??replacement?? that would expand the original
      string beyond the end of the current allocation. Here's an example:
      -->
      <para>
A diferencia de <function>insert()</function>, <function>replace()</function> no aumentará el espacio de alamcenamiento de <classname>string</classname> si copia nuevos caracteres en el medio de una serie de elementos de array existentes. Sin embargo, sí que cerecerá su espacio si es necesario, por ejemplo, cuando hace un <emphasis>"reemplazamiento"</emphasis> que pueda expandir el <classname>string</classname> más allá del final de la memoria reservada actual. Aquí un ejemplo:
      </para>


//: C03:ReplaceAndGrow.cpp


      <!--
      The call to replace( ) begins ??replacing?? beyond the end of the
      existing array, which is equivalent to an append operation. Notice that
      in this example replace( ) expands the array accordingly.
      -->
      <para>
La llamada a <function>replace()</function> empieza <emphasis>"reemplazando"</emphasis> más allá del final del array existente, que es equivalente a la operación <function>append()</function>. Nótese que en este ejemplo <function>replace()</function> expande el array coherentemente.
      </para>

      <!--
      You may have been hunting through this chapter trying to do something
      relatively simple such as replace all the instances of one character
      with a different character. Upon finding the previous material on
      replacing, you thought you found the answer, but then you started seeing
      groups of characters and counts and other things that looked a bit too
      complex. Doesn't string have a way to just replace one character with
      another everywhere?
      -->
      <para>
Puede que haya estado buscando a través del capítulo; intentando hacer algo relativamente fácil como reemplazar todas las ocurrencias de un carácter con diferentes caracteres. Al buscar el material previo sobre reemplazar, puede que haya encontrado la respuesta, pero entonces ha empezaro viendo grupos de caracteres y contadores y otras cosas que parecen un poco demasiado complejas. ¿No tiene <classname>string</classname> una manera para reemplazar un carácter con otro simplemente?
      </para>

      <!--
      You can easily write such a function using the find( ) and replace( )
      member functions as follows:
      -->
      <para>
Puede escribir fácilmente cada funcin usando las funciones miembro <function>find()</function> y <function>replace()</function> como se muestra acontinuacion.
      </para>

//: C03:ReplaceAll.h


//: C03:ReplaceAll.cpp {O}


      <!--
      The version of find( ) used here takes as a second argument the position
      to start looking in and returns string::npos if it doesn't find it. It
      is important to advance the position held in the variable lookHere past
      the replacement string, in case from is a substring of to. The following
      program tests the replaceAll function:
      -->
      <para>
La versión de <function>find()</function> usada aquí toma como segundo argumento la posición donde empezar a buscar y retorna <classname>string::</classname><varname>npos</varname> si no lo encuentra. Es importante avanzar en la posición contenida por la variable <varname>lookHere</varname> pasada como subcadena, en caso de que <varname>from</varname> es una subcadena de <varname>to</varname>. El siguiente programa comprueba la funcion <function>replaceAll()</function>:
      </para>


//: C03:ReplaceAllTest.cpp


      <!--
      As you can see, the string class by itself doesn't solve all possible
      problems. Many solutions have been left to the algorithms in the
      Standard library[34] because the string class can look just like an STL
      sequence (by virtue of the iterators discussed earlier). All the generic
      algorithms work on a ??range?? of elements within a container. Usually
      that range is just ??from the beginning of the container to the end.?? A
      string object looks like a container of characters: to get the beginning
      of the range you use string::begin( ), and to get the end of the range
      you use string::end( ). The following example shows the use of the
      replace( ) algorithm to replace all the instances of the single
      character ??X' with ??Y':
      -->
      <para>
Como puede comprobar, la clase <classname>string</classname> por ella sola no resuelve todos los posibles problemas. Muchas soluciones se han dejado en los algoritmos de la librería estándar[34] por que la clase <classname>string</classname> puede parece justamente como una secuencia STL(gracias a los iteradores descritos antes). Todos los algoritmos genéricos funcionan en un <emphasis>"rango"</emphasis> de elementos dentro de un contenedor. Generalmente este rango es justamente desde el principio del contenedor hasta el final. Un objeto <classname>string</classname> se parece a un contenedor de caracteres: para obtener el principio de este rango use <classname>string::</classname><function>begin()</function>, y para obtener el final del rango use <classname>string::</classname><function>end()</function>. El siguiente ejemplomuestra el uso del algoritmo <function>replace()</function> para reemplazar todas las instancias de un determinado carácter <emphasis>"X"</emphasis> con <emphasis>"Y"</emphasis>
<footnote>
	<para>
		Descrito en profundidad en el Capítulo 6.
	</para>
</footnote>
      </para>


//: C03:StringCharReplace.cpp


      <!--
      Notice that this replace( ) is not called as a member function of
      string. Also, unlike the string::replace( ) functions that only perform
      one replacement, the replace( ) algorithm replaces all instances of one
      character with another.
      -->
      <para>
		Nótese que esta función <function>replace()</replace> no es llamada como función miembro de <classname>string</classname>. Además, a diferencia de la función <classname>string::</classname><function>replace()</function>, que solo realiza un reemplazo, el algoritmo <function>replace()</function> reemplaza todas las instancias de un carácter con otro.
      </para>

      <!--
      The replace( ) algorithm only works with single objects (in this case,
      char objects) and will not replace quoted char arrays or string
      objects. Since a string behaves like an STL sequence, a number of other
      algorithms can be applied to it, which might solve other problems that
      are not directly addressed by the string member functions.
      -->
      <para>
El algoritmo <function>replace()</replace> solo funciona con objetos individuales (en este caso, objetos <type>char</type>) y no reemplazará arreglos constantes o objetos <classname>string</classname>. Desde que un <classname>string</classname> se copmporta como una secuencia STL, un conjunto de algoritmos pueden serle aplicados, que resolverán otros problemas que las funciones miembro de <classname>string</classname> no resuelven.
      </para>

    </sect2>
    <sect2>
      <!-- : Concatenation using nonmember overloaded operators -->
      <title>Concatenación usando operadores no-miembro sobrecargados</title>

      <!--
      One of the most delightful discoveries awaiting a C programmer learning
      about C++ string handling is how simply strings can be combined and
      appended using operator+ and operator+=. These operators make combining
      strings syntactically similar to adding numeric data:
      -->
      <para>
Uno de los descubrimientos más deliciosos que esperan al programador de C que está aprendiendo sobre el manejo de cadenas en C++, es lo simple que es combinar y añadir <classname>string</classname> usando los operadores <function>operator+</function> y <function>operator+=</function>. Estos operadores hacen combinaciones de cadenas sintacticamente parecidas a la suma de datos numéricos:
      </para>


//: C03:AddStrings.cpp


      <!--
      Using the operator+ and operator+= operators is a flexible and
      convenient way to combine string data. On the right side of the
      statement, you can use almost any type that evaluates to a group of one
      or more characters.
      -->
      <para>
Usar los operadores <function>operator+</function> y <function>operator+=</function> es una manera flexible y conveniente de combinar los datos de las cadenas. En la parte derecha de la sentencia, puede usar casi cualquier tipo que evalúe a un grupo de uno o más caracteres.
      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Searching in strings -->
    <title>Buscar en cadenas</title>

    <!--
    The find family of string member functions locates a character or group
    of characters within a given string. Here are the members of the find
    family and their general usage :
    -->
    <para>
La familia de funciones miembro de <classname>string</classname> <function>find</function> localiza un carácter o grupo de caracteres en una cadena dada. Aquí los miembros de la familia <function>find()</function> y su uso general:
    </para>

    <!-- Esto hay que meterlo en una tabla-->
	<!-- string find member function -->
    <para>
Función miembro de búsqueda en un <classname>string</classname>
    </para>

    <!-- What/how it finds -->
    <para>
¿Qué/Cómo lo encuentra?
    </para>

    <!-- find( ) -->
    <para>
<function>find()</function>
    </para>

	<!--
	TBD: Aqui se mete una tabla???? Parece lo correcto
	-->
    <!--
    Searches a string for a specified character or group of characters and
    returns the starting position of the first occurrence found or npos if
    no match is found.
    -->
    <para>
Busca en un <classname>string</classname> un carácter determinado o un grupo de caracteres y retorna la posición de inicio de la primera ocurrencia o <varname>npos</varname> si ha sido encontrado.
    </para>

    <!-- find_first_of( ) -->
    <para>
<function>find_first_of()</function>
    </para>

    <!--
    Searches a target string and returns the position of the first match of
    any character in a specified group. If no match is found, it returns
    npos.
    -->
    <para>
Busca en un <classname>string<classname> y retorna la posición de la primera ocurrencia de cualquier carácter en un grupo especifico. Si no encuentra ocurrencias, retorna <varname>npos</varname>.
    </para>

    <!-- find_last_of( ) -->
    <para>
<function>find_last_of()</function>
    </para>

    <!--
    Searches a target string and returns the position of the last match of
    any character in a specified group. If no match is found, it returns
    npos.
    -->
    <para>
Busca en un <classname>string<classname> y retorna la posición de la última ocurrencia de cualquier carácter en un grupo específico. Si no encuentra ocurrencias, retorna <varname>npos</varname>.
    </para>

    <!-- find_first_not_of( ) -->
    <para>
<function>find_first_not_of( )</function>
    </para>

    <!--
    Searches a target string and returns the position of the first element
    that doesn't match any character in a specified group. If no such
    element is found, it returns npos.
    -->
    <para>
Busca en un <classname>string<classname> y retorna la posición de la primera ocurrencia que no pertenece a un grupo específico. Si no encontramos ningún elemento, retorna un <varname>npos</varname>
    </para>

    <!-- find_last_not_of( ) -->
    <para>
<function>find_last_not_of( )</function>
    </para>

    <!--
    Searches a target string and returns the position of the element with
    the largest subscript that doesn't match any character in a specified
    group. If no such element is found, it returns npos.
    -->
    <para>
Busca en un <classname>string<classname> y retorna la posición del elemento con el indice mayor que no pertenece a un grupo específico. Si no encontramos ningún elemento, retorna un <varname>npos</varname>
    </para>

    <!-- rfind( ) -->
    <para>
<function>rfind()</function>
    </para>

    <!--
    Searches a string from end to beginning for a specified character or
    group of characters and returns the starting position of the match if
    one is found. If no match is found, it returns npos.
    -->
    <para>
Busca en un <classname>string<classname>, desde el final hasta el origen, un carácter o grupo de caracteres y retorna la posición inicial de la ocurrencia si se ha encontrado alguna. Si no encuentra ocurrencias, retorna <varname>npos</varname>.
    </para>

    <!--
    The simplest use of find( ) searches for one or more characters in a
    string. This overloaded version of find( ) takes a parameter that
    specifies the character(s) for which to search and optionally a
    parameter that tells it where in the string to begin searching for the
    occurrence of a substring. (The default position at which to begin
    searching is 0.) By setting the call to find inside a loop, you can
    easily move through a string, repeating a search to find all the
    occurrences of a given character or group of characters within the
    string.
    -->
    <para>
El uso más simple de <function>find()</function>, busca uno o más caracteres en un <classname>string</classname>. La versión sobrecargada de <function>find()</function> toma un parámetro que especifica el/los carácter(es) que buscar y opcionalmente un parámetro que dice donde empezar a buscar en el <classname>string</classname> la primera ocurrencia. (Por defecto la posición de incio es 0). Insertando la llamada a la función <function>find()</function> dentro de un bucle puede buscar fácilmente todas las ocurrencias de un carácter dado o un grupo de caracteres dentro de un <classname>string</classname>.
    </para>

    <!--
    The following program uses the method of The Sieve of Eratosthenes to
    find prime numbers less than 50. This method starts with the number 2,
    marks all subsequent multiples of 2 as not prime, and repeats the
    process for the next prime candidate. The SieveTest constructor
    initializes sieveChars by setting the initial size of the character
    array and writing the value ??P' to each of its members.
    -->
    <para>
El siguiente programa usa el método del Tamiz de Eratostenes para hallar los números primos menores de 50. Este método empieza con el número 2, marca todos los subsecuentes múltiplos de 2 ya que no son primos, y repite el proceso para el siguiente candidato a primo. El constructor de sieveTest inicializa sieveChars poniendo el tamaño inicial del arreglo de carácter y escribiendo el valor <emphasis>'P'</emphasis> para cada miembro.
    </para>


//: C03:Sieve.h


//: C03:Sieve.cpp


    <!--
    The find( ) function can walk forward through a string, detecting
    multiple occurrences of a character or a group of characters, and
    find_first_not_of( ) finds other characters or substrings.
    -->
    <para>
La función <function>find()</function> puede recorrer el <classname>string</classname>, detectando múltiples ocurrencias de un carácter o un grupo de caracteres, y <function>find_first_not_of()</function> encuentra otros caracteres o subcadenas.
    </para>

    <!--
    There are no functions in the string class to change the case of a
    string, but you can easily create these functions using the Standard C
    library functions toupper( ) and tolower( ), which change the case of
    one character at a time. The following example illustrates a
    case-insensitive search:
    -->
    <para>
No existen funciones en la clase <classname>string</classname> para cambiar entre mayúsculas/minúsculas en una cadena, pero puede crear esa función fácilmente usando la función de la libreria estándar de C <function>toupper()</function> y <function>tolower()</function>, que cambian los caracteres entre mayúsculas/minúsculas de uno en uno. El ejemplo siguiente ilustra una búsqueda sensible a mayúsculas/minúsculas.
    </para>


//: C03:Find.h


//: C03:Find.cpp


    <!--
    Both the upperCase( ) and lowerCase( ) functions follow the same form:
    they make a copy of the argument string and change the case. The
    Find.cpp program isn't the best solution to the case-sensitivity
    problem, so we'll revisit it when we examine string comparisons.
    -->
    <para>
Tanto las funciones <function>upperCase()</function> como <function>lowerCase()</function> siguen la misma forma: hacen una copia de la cadena argumento y cambian entre mayúsculas/minúsculas. El programa Find.cpp no es la mejor solución para el problema para las mayúsculas/minúsculas, por lo que lo revisitaremos cuando examinemos la comparación entre cadenas. 
    </para>

    <sect2>
      <!-- : Finding in reverse -->
      <title>Busqueda inversa</title>

      <!--
      If you need to search through a string from end to beginning (to find
      the data in ??last in / first out?? order), you can use the string
      member function rfind( ):
      -->
      <para>
Si necesita buscar en una cadena desde el final hasta el principio (para encontrar datos en orden <emphasis>"último entra / primero sale"</emphasis>), puede usar la función miembro de <classname>string</classname> <function>rfind()</function>.
      </para>


//: C03:Rparse.h


//: C03:Rparse.cpp


      <!--
      The string member function rfind( ) backs through the string looking for
      tokens and reports the array index of matching characters or
      string::npos if it is unsuccessful.
      -->
      <para>
La función miembro de <classname>string</classname> <function>rfind()</function> vuelve por la cadena buscando elementos y reporta el indice del arreglo de las coincidencias de caracteres o <classname>string::</classname><varname>npos</varname> si no tiene éxito.
      </para>

    </sect2>
    <sect2>
      <!-- : Finding first/last of a set of characters -->
      <title>Encontrar el primero/último de un conjunto de caracteres</title>

      <!--
      The find_first_of( ) and find_last_of( ) member functions can be
      conveniently put to work to create a little utility that will strip
      whitespace characters from both ends of a string. Notice that it doesn'
      t touch the original string, but instead returns a new string:
      -->
      <para>
La función miembro <function>find_first_of( )</function> y <function>find_last_of( )</function> pueden ser convenientemente usadas para crear una pequeña utilidad the ayude a deshechar los espacion en blanco del final e inicio de la cadena. Nótese que no se toca el <classname>string</classname> originar sino que se devuelve una nuevo <classname>string</classname>:
      </para>


//: C03:Trim.h


      <!--
      The first test checks for an empty string; in that case, no tests are
      made, and a copy is returned. Notice that once the end points are found,
      the string constructor builds a new string from the old one, giving the
      starting count and the length.
      -->
      <para>
La primera prueba checkea si el string esta vacío; en ese caso, ya no se realizan más test, y se retorna una copia. Nótese que una vez los puntos del final son encontrados, el constructor de <classname>string</classname> construye un nuevo <classname>string</classname> desde el viejo, dándole  el contador incial y la longitud.
      </para>

      <!-- Testing such a general-purpose tool needs to be thorough: -->
      <para>
Las pruebas de una herramienta tan general den ser cuidadosas
      </para>


//: C03:TrimTest.h


//: C03:TrimTest.cpp {O}


//: C03:TrimTestMain.cpp


      <!--
      In the array of strings, you can see that the character arrays are
      automatically converted to string objects. This array provides cases to
      check the removal of spaces and tabs from both ends, as well as ensuring
      that spaces and tabs are not removed from the middle of a string.
      -->
      <para>
En el arrglo de <classname>string</classname>, puede ver que los arreglos de carácter son automáticamente convertidos a objetos <classname>string</classname>. Este arreglo provee casos para checkear el borrado de espacios en blanco y tabuladores en los extremos, además de asegurar que los espacios y tabuladores no son borrados de la mitad de un <classname>string</classname>.
      </para>

    </sect2>
    <sect2>
      <!-- : Removing characters from strings -->
      <title>Borrar caracteres de cadenas </title>

      <!--
      Removing characters is easy and efficient with the erase( ) member
      function, which takes two arguments: where to start removing characters
      (which defaults to 0), and how many to remove (which defaults to
      string::npos). If you specify more characters than remain in the string,
      the remaining characters are all erased anyway (so calling erase( )
      without any arguments removes all characters from a string). Sometimes
      it's useful to take an HTML file and strip its tags and special
      characters so that you have something approximating the text that would
      be displayed in the Web browser, only as a plain text file. The
      following example uses erase( ) to do the job:
      -->
      <para>
Borrar caracteres es fácil y eficiente con la función miembro <function>erase()</function>, que toma dos argumentos: donde empezar a borrar caracteres (que por defecto es 0), y cuantos caracteres borrar (que por defecto es <classname>string::</classname><varname>npos</varname>). Si especifica más caracteres que los que quedan en el string, los caracteres restantes se borran igualmente (llamando <function>erase()</function> sin argumentos borra todos los caracteres del <classname>string</classname>). A veces es útil abrir un fichero HTML y borrar sus etiquetas y caracteres especiales de manera que tengamos algo aproximadamente igual al texto que obtendríamos en el navegador Web, sólo como un fichero de texto plano. El siguiente ejemplo usa <function>erase()</function> para hacer el trabajo:  
      </para>


//: C03:HTMLStripper.cpp


      <!--
      This example will even strip HTML tags that span multiple lines.[35]
      This is accomplished with the static flag, inTag, which is true whenever
      the start of a tag is found, but the accompanying tag end is not found
      in the same line. All forms of erase( ) appear in the stripHTMLFlags( )
      function.[36] The version of getline( ) we use here is a (global)
      function declared in the <string> header and is handy because it stores
      an arbitrarily long line in its string argument. You don't need to
      worry about the dimension of a character array as you do with
      istream::getline( ). Notice that this program uses the replaceAll( )
      function from earlier in this chapter. In the next chapter, we'll use
      string streams to create a more elegant solution.
      -->
      <para>
Este ejemplo borrará incluso las etiquetas HTML que se extienden a lo largo de varias líneas.[35] Esto se cumple gracias a la bandera estática <varname>inTag</varname>, que evalúa a cierto si el principio de una etiqueta es encontrada, pero la etiqueta de finalización correspondiente no es encontrada en la misma línea. Todas la formas de <function>erase()</function> aparecen en la función <function>stripHTMLFlags()</function>.[36] La versión de <function>getline()</function> que usamos aquí es una función (global) declarada en la cabecera de <classname>string</classname> y es útil porque guarda una linea arbitrariamente larga en su argumento <classname>string</classname>. No necesita preocuparse de las dimensiones de un arreglo cuando trabaja con <classname>istream::</classname><function>getline()</function>. Nótese que este programa usa la función <function>replaceAll()</function> vista antes en este capítulo. En el póximo capitulo, usaremos los flujos de cadena para crear una solución más elegante.
<footnote>
	<para>
		Para mantener la exposición simple, esta version no maneja etiquetas anidadas, como los comentarios.
	</para>
</footnote>
<footnote>
	<para>
		Es tentador usar aquí las matemáticas para evitar algunas llamadas a <function>erase()</function>, pero como en algunos casos uno de los operandos es <classname>string::</classname><varname>npos</varname> (el entero sin signo más grande posible), ocurre un desbordamiento del entero y se cuelga el algoritmo.
	</para>
</footnote>
      </para>

    </sect2>
    <sect2>
      <!-- : Comparing strings -->
      <title>Comparar cadenas </title>

      <!--
      Comparing strings is inherently different from comparing
      numbers. Numbers have constant, universally meaningful values. To
      evaluate the relationship between the magnitudes of two strings, you
      must make a lexical comparison. Lexical comparison means that when you
      test a character to see if it is ??greater than?? or ??less than??
      another character, you are actually comparing the numeric representation
      of those characters as specified in the collating sequence of the
      character set being used. Most often this will be the ASCII collating
      sequence, which assigns the printable characters for the English
      language numbers in the range 32 through 127 decimal. In the ASCII
      collating sequence, the first ??character?? in the list is the space,
      followed by several common punctuation marks, and then uppercase and
      lowercase letters. With respect to the alphabet, this means that the
      letters nearer the front have lower ASCII values than those nearer the
      end. With these details in mind, it becomes easier to remember that when
      a lexical comparison that reports s1 is ??greater than?? s2, it simply
      means that when the two were compared, the first differing character in
      s1 came later in the alphabet than the character in that same position
      in s2.
      -->
      <para>
			Comparar cadenas es inherentemente diferente a comparar enteros. Los nombres tienen un significado universal y constante. Para evaluar la relación entre las magnitudes de dos cadenas, se necesita hacer una comparación léxica. Una comparación léxica significa que cuando se comprueba un carácter para saber si es <emphasis>"mayor que"</emphasis> o <emphasis>"menor que"</emphasis> otro carácter, está en realidad comparando la representación numérica de aquellos caracteres tal como están especificados en el orden del conjunto de caracteres que está siendo usado. La ordenación más habitual suele ser la secuencia ASCII, que asigna a los caracteres imprimibles para el lenguaje inglés números en un rango del 32 al 127 decimal. En la codificación ASCII, el primer <emphasis>"carácter"</emphasis> en la lista es el espacio, seguido de diversas marcas de puntuación común, y después las letras mayúsculas y minúsculas. Respecto al alfabeto, esto significa que las letras cercanas al principio tienen un valor ASCII menor a aquellos más cercanos al final. Con estos detalles en mente, se vuelve más fácil recordar que cuando una comparació léxica reporta que <varname>s1</varname> es <emphasis>"mayor que"</emphasis> <varname>s2</varname>, simplemente significa que cuando fueron comparados, el primer carácter diferente en <varname>s1</varname> estaba atrás en el alfabeto que el carácter en la misma posición en <varname>s2</varname>.
      </para>

      <!--
      C++ provides several ways to compare strings, and each has
      advantages. The simplest to use are the nonmember, overloaded operator
      functions: operator ==, operator != operator >, operator <, operator >=,
      and operator <=.
      -->
      <para>
      FIXME:
			C++ provee varias maneras de comparar cadenas, y cada una tiene ventajas. La más simple de usar son las funciones no-miembro sobrecargadas de operador: operator==, operator!= operator, operator
			<!--Como se insertan los caracteres especiales???? -->
			FIXME
      </para>


//: C03:CompStr.h


//: C03:CompStr.cpp


      <!--
      The overloaded comparison operators are useful for comparing both full
      strings and individual string character elements.
      -->
      <para>
			Los operadores de comaración sobrecargados son útiles para comparar dos cadenas completas y elementos individuales de una cadena de caracteres.
      </para>

      <!--
      Notice in the following example the flexibility of argument types on
      both the left and right side of the comparison operators. For
      efficiency, the string class provides overloaded operators for the
      direct comparison of string objects, quoted literals, and pointers to
      C-style strings without having to create temporary string objects.
      -->
      <para>
			Nótese en el siguiente ejemplo la flexibilidad de los tipos de argumento ambos lados de los operadores de comparación. Por eficiencia, la clase <classname>string</classname> provee operadores sobrecargados para la comparación directa de objetos <classname>string</classname>, literales de cadena, y punteros a cadenas estilo C sin tener que crear objetos <classname>string</classname> temporales.
      </para>


//: C03:Equivalence.cpp


      <!--
      The c_str( ) function returns a const char* that points to a C-style, null-terminated string equivalent to the contents of the string object. This comes in handy when you want to pass a string to a standard C function, such as atoi( ) or any of the functions defined in the <cstring> header. It is an error to use the value returned by c_str( ) as non-const argument to any function.
      -->
      <para>
			La función <function>c_str()</function> retorna un <type>const char*</type> que apunta a una cadena estilo C terminada en nulo, equivalente en contenidos al objeto <classname>string</classname>. Esto se vuelve muy útil cuando se quiere pasar un strin a una función C, como atoi() o cualquiera de las funciones definidas en la cabecera <emphasis>cstring</emphasis>. Es un error usar el valor retornado por <varname>c_str()</varname> como un argumento constante en cualquier función.
      </para>

      <!--
      You won't find the logical not (!) or the logical comparison operators
      (&& and ||) among operators for a string. (Neither will you find
      overloaded versions of the bitwise C operators &, |, ^, or ~.) The
      overloaded nonmember comparison operators for the string class are
      limited to the subset that has clear, unambiguous application to single
      characters or groups of characters.
      -->
      <para>
			FIXME
      </para>

      <!--
      The compare( ) member function offers you a great deal more
      sophisticated and precise comparison than the nonmember operator set. It
      provides overloaded versions to compare:
      -->
      <para>
			La función miembro <function>compare()</function> le ofrece un gran modo de comparación más sofisticado y preciso que el conjunto de operadores nomiembro. Provee versiones sobrecargadas para comparar:
			  <para>
			    <itemizedlist>
			      <listitem>
			        <para>Dos <classname>string</classname> completos</para>
			      </listitem>
			
			      <listitem>
			        <para>Parte de un <classname>string</classname> con un <classname>string</classname> completo</para>
			      </listitem>
			
			      <listitem>
			        <para>Partes de dos <classname>string</classname></para>
			      </listitem>
			    </itemizedlist>
      </para>
     	</para>
      

//: C03:Compare.cpp


      <!--
      The swap( ) function in this example does what its name implies: it
      exchanges the contents of its object and argument. To compare a subset
      of the characters in one or both strings, you add arguments that define
      where to start the comparison and how many characters to consider. For
      example, we can use the following overloaded version of compare( ):
      -->
      <para>
			
      </para>

      <!-- s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos, s2NumberChars); -->
      <para>

      </para>

      <!-- Here's an example: -->
      <para>

      </para>


//: C03:Compare2.cpp


      <!--
      In the examples so far, we have used C-style array indexing syntax to
      refer to an individual character in a string. C++ strings provide an
      alternative to the s[n] notation: the at( ) member. These two indexing
      mechanisms produce the same result in C++ if all goes well: 
      -->
     <para>

      </para>


//: C03:StringIndexing.cpp


      <!--
      There is one important difference, however, between [ ] and at( ). When
      you try to reference an array element that is out of bounds, at( ) will
      do you the kindness of throwing an exception, while ordinary [ ]
      subscripting syntax will leave you to your own devices:
      -->
      <para>

      </para>


//: C03:BadStringIndexing.cpp


      <!--
      Responsible programmers will not use errant indexes, but should you want
      to benefits of automatic index checking, using at( ) in place of [ ]
      will give you a chance to gracefully recover from references to array
      elements that don't exist. Execution of this program on one of our test
      compilers gave the following output: invalid string position
      -->
      <para>

      </para>

      <!--
      The at( ) member throws an object of class out_of_range, which derives
      (ultimately) from std::exception. By catching this object in an
      exception handler, you can take appropriate remedial actions such as
      recalculating the offending subscript or growing the array. Using
      string::operator[ ]( ) gives no such protection and is as dangerous as
      char array processing in C.[37]
      -->
      <para>

      </para>

    </sect2>
    <sect2>
      <!-- : Strings and character traits -->
      <title> </title>

      <!--
      The program Find.cpp earlier in this chapter leads us to ask the obvious
      question: Why isn't case-insensitive comparison part of the standard
      string class? The answer provides interesting background on the true
      nature of C++ string objects.
      -->
      <para>

      </para>

      <!--
      Consider what it means for a character to have ??case.?? Written Hebrew,
      Farsi, and Kanji don't use the concept of upper- and lowercase, so for
      those languages this idea has no meaning. It would seem that if there
      were a way to designate some languages as ??all uppercase?? or ??all
      lowercase,?? we could design a generalized solution. However, some
      languages that employ the concept of ??case?? also change the meaning of
      particular characters with diacritical marks, for example: the cedilla
      in Spanish, the circumflex in French, and the umlaut in German. For this
      reason, any case-sensitive collating scheme that attempts to be
      comprehensive will be nightmarishly complex to use.
      -->
      <para>

      </para>

      <!--
      Although we usually treat the C++ string as a class, this is really not
      the case. The string type is a specialization of a more general
      constituent, the basic_string< > template. Observe how string is
      declared in the Standard C++ header file:[38]
      -->
      <para>

      </para>

      <!-- typedef basic_string<char> string; -->
      <para>

      </para>

      <!--
      To understand the nature of the string class, look at the basic_string<
      > template:
      -->
      <para>

      </para>

      <!--
      template<class charT, class traits = char_traits<charT>,
      class allocator = allocator<charT> > class basic_string;
      -->
      <para>

      </para>

      <!--
      In Chapter 5, we examine templates in great detail (much more than in
      Chapter 16 of Volume 1). For now, just notice that the string type is
      created when the basic_string template is instantiated with char. Inside
      the basic_string< > template declaration, the line:
      -->
      <para>

      </para>

      <!-- class traits = char_traits<charT>, -->
      <para>

      </para>

      <!--
      tells us that the behavior of the class made from the basic_string< >
      template is specified by a class based on the template char_traits<
      >. Thus, the basic_string< > template produces string-oriented classes
      that manipulate types other than char (wide characters, for example). To
      do this, the char_traits< > template controls the content and collating
      behaviors of a variety of character sets using the character comparison
      functions eq( ) (equal), ne( ) (not equal), and lt( ) (less than). The
      basic_string< > string comparison functions rely on these.
      -->
      <para>

      </para>

      <!--
      This is why the string class doesn't include case-insensitive member
      functions: that's not in its job description. To change the way the
      string class treats character comparison, you must supply a different
      char_traits< > template because that defines the behavior of the
      individual character comparison member functions.
      -->
      <para>

      </para>

      <!--
      You can use this information to make a new type of string class that
      ignores case. First, we'll define a new case-insensitive char_traits< >
      template that inherits from the existing template. Next, we'll override
      only the members we need to change to make character-by-character
      comparison case insensitive. (In addition to the three lexical character
      comparison members mentioned earlier, we'll also supply a new
      implementation for the char_traits functions find( ) and compare( ))
      . Finally, we'll typedef a new class based on basic_string, but using
      the case-insensitive ichar_traits template for its second argument:
      -->
      <para>

      </para>


//: C03:ichar_traits.h



      <!--
      We provide a typedef named istring so that our class will act like an
      ordinary string in every way, except that it will make all comparisons
      without respect to case. For convenience, we've also provided an
      overloaded operator<<( ) so that you can print istrings. Here's an
      example:
      -->
      <para>

      </para>


//: C03:ICompare.cpp


      <!--
      This is just a toy example. To make istring fully equivalent to string,
      we'd have to create the other functions necessary to support the new
      istring type.
      -->
      <para>

      </para>

      <!--
      The <string> header provides a wide string class via the following
      typedef:
      -->
      <para>

      </para>

      <!-- typedef basic_string<wchar_t> wstring; -->
      <para>

      </para>

      <!--
      Wide string support also reveals itself in wide streams (wostream in
      place of ostream, also defined in <iostream>) and in the header
      wchar_t specialization of char_traits in the standard library allows us
      to do a wide-character version of ichar_traits:
      -->
      <para>

      </para>


//: C03:iwchar_traits.h


      <!--
      As you can see, this is mostly an exercise in placing a ??w' in the
      appropriate place in the source code. The test program looks like this:
      -->
      <para>

      </para>


//: C03:IWCompare.cpp


      <!--
      Unfortunately, some compilers still do not provide robust support for
      wide characters.
      -->
      <para>

      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : A string application -->
    <title> </title>

    <!--
    If you've looked at the sample code in this book closely, you've
    noticed that certain tokens in the comments surround the code. These are
    used by a Python program that Bruce wrote to extract the code into files
    and set up makefiles for building the code. For example, a double-slash
    followed by a colon at the beginning of a line denotes the first line of
    a source file. The rest of the line contains information describing the
    file's name and location and whether it should be only compiled rather
    than fully built into an executable file. For example, the first line in
    the previous program above contains the string C03:IWCompare.cpp,
    indicating that the file IWCompare.cpp should be extracted into the
    directory C03.
    -->
    <para>

    </para>

    <!--
    The last line of a source file contains a triple-slash followed by a
    colon and a tilde. If the first line has an exclamation point
    immediately after the colon, the first and last lines of the source code
    are not to be output to the file (this is for data-only files). (If you'
    re wondering why we're avoiding showing you these tokens, it's because
    we don't want to break the code extractor when applied to the text of
    the book!)
    -->
    <para>

    </para>

    <!--
    Bruce's Python program does a lot more than just extract code. If the
    token ??{O}?? follows the file name, its makefile entry will only be set
    up to compile the file and not to link it into an executable. (The Test
    Framework in Chapter 2 is built this way.) To link such a file with
    another source example, the target executable's source file will
    contain an ??{L}?? directive, as in:
    -->
    <para>

    </para>

    <!-- //{L} ../TestSuite/Test -->
    <para>

    </para>

    <!--
    This section will present a program to just extract all the code so that
    you can compile and inspect it manually. You can use this program to
    extract all the code in this book by saving the document file as a text
    file[39] (let's call it TICV2.txt) and by executing something like the
    following on a shell command line: C:> extractCode TICV2.txt /TheCode
    -->
    <para>

    </para>

    <!--
    This command reads the text file TICV2.txt and writes all the source
    code files in subdirectories under the top-level directory /TheCode. The
    directory tree will look like the following:
    -->
    <para>

    </para>

    <!--
    TheCode/
    C0B/
    C01/
    C02/
    C03/
    C04/
    C05/
    C06/
    C07/
    C08/
    C09/
    C10/
    C11/
    TestSuite/
    -->
    <para>

    </para>

    <!--
    The source files containing the examples from each chapter will be in
    the corresponding directory.
    -->
    <para>

    </para>

    <!-- Here's the program: -->
    <para>

    </para>


//: C03:ExtractCode.cpp


    <!--
    First, you'll notice some conditional compilation directives. The
    mkdir( ) function, which creates a directory in the file system, is
    defined by the POSIX[40] standard in the header
    (<direct.h>). The respective signatures for mkdir( ) also differ: POSIX
    specifies two arguments, the older versions just one. For this reason,
    there is more conditional compilation later in the program to choose the
    right call to mkdir( ). We normally don't use conditional compilation
    in the examples in this book, but this particular program is too useful
    not to put a little extra work into, since you can use it to extract all
    the code with it.
    -->
    <para>

    </para>

    <!--
    The exists( ) function in ExtractCode.cpp tests whether a directory
    exists by opening a temporary file in it. If the open fails, the
    directory doesn't exist. You remove a file by sending its name as a
    char* to std::remove( ).
    -->
    <para>

    </para>

    <!--
    The main program validates the command-line arguments and then reads the
    input file a line at a time, looking for the special source code
    delimiters. The Boolean flag inCode indicates that the program is in the
    middle of a source file, so lines should be output. The printDelims flag
    will be true if the opening token is not followed by an exclamation
    point; otherwise the first and last lines are not written. It is
    important to check for the closing delimiter first, because the start
    token is a subset, and searching for the start token first would return
    a successful find for both cases. If we encounter the closing token, we
    verify that we are in the middle of processing a source file; otherwise,
    something is wrong with the way the delimiters are laid out in the text
    file. If inCode is true, all is well, and we (optionally) write the last
    line and close the file. When the opening token is found, we parse the
    directory and file name components and open the file. The following
    string-related functions were used in this example: length( ), append(
    ), getline( ), find( ) (two versions), find_first_not_of( ), substr( ),
    find_first_of( ), c_str( ), and, of course, operator<<( ).
    -->
    <para>

    </para>

  </sect1>
  <sect1>
    <!-- : Summary -->
    <title> </title>

    <!--
    C++ string objects provide developers with a number of great advantages
    over their C counterparts. For the most part, the string class makes
    referring to strings with character pointers unnecessary. This
    eliminates an entire class of software defects that arise from the use
    of uninitialized and incorrectly valued pointers.
    -->
    <para>

    </para>

    <!--
    C++ strings dynamically and transparently grow their internal data
    storage space to accommodate increases in the size of the string
    data. When the data in a string grows beyond the limits of the memory
    initially allocated to it, the string object will make the memory
    management calls that take space from and return space to the
    heap. Consistent allocation schemes prevent memory leaks and have the
    potential to be much more efficient than ??roll your own?? memory
    management.
    -->
    <para>

    </para>

    <!--
    The string class member functions provide a fairly comprehensive set of
    tools for creating, modifying, and searching in strings. String
    comparisons are always case sensitive, but you can work around this by
    copying string data to C-style null-terminated strings and using
    case-insensitive string comparison functions, temporarily converting the
    data held in string objects to a single case, or by creating a
    case-insensitive string class that overrides the character traits used
    to create the basic_string object.
    -->
    <para>

    </para>

  </sect1>
  <sect1>
    <!-- : Exercises -->
    <title> </title>

    <!--
    Solutions to selected exercises can be found in the electronic document
    The Thinking in C++ Volume 2 Annotated Solution Guide, available for a
    small fee from www.MindView.net.
    -->
    <para>

    </para>

    <!--
    1.  Write and test a function that reverses the order of the characters
    in a string.
    -->
    <para>

    </para>

    <!--
    2.  A palindrome is a word or group of words that read the same forward
    and backward. For example ??madam?? or ??wow.?? Write a program that
    takes a string argument from the command line and, using the function
    from the previous exercise, prints whether the string was a palindrome
    or not.
    -->
    <para>

    </para>

    <!--
    3.  Make your program from Exercise 2 return true even if symmetric
    letters differ in case. For example, ??Civic?? would still return true
    although the first letter is capitalized.
    -->
    <para>

    </para>

    <!--
    4.  Change your program from Exercise 3 to ignore punctuation and spaces
    as well. For example ??Able was I, ere I saw Elba.?? would report true.
    -->
    <para>

    </para>

    <!--
    5.  Using the following string declarations and only chars (no string
    literals or magic numbers):
    -->
    <para>

    </para>

    <!--
    string one("I walked down the canyon with the moving mountain bikers.");
    string two("The bikers passed by me too close for comfort.");
    string three("I went hiking instead.");
    -->
    <para>

    </para>

    <!-- produce the following sentence: -->
    <para>

    </para>

    <!--
    I moved down the canyon with the mountain bikers. The mountain bikers
    passed by me too close for comfort. So I went hiking instead.
    -->
    <para>

    </para>

    <!--
    6.  Write a program named replace that takes three command-line
    arguments representing an input text file, a string to replace (call it
    from), and a replacement string (call it to). The program should write a
    new file to standard output with all occurrences of from replaced by to.
    -->
    <para>

    </para>

    <!--
    7.  Repeat the previous exercise but replace all instances of from
    regardless of case.
    -->
    <para>

    </para>

    <!--
    8.  Make your program from Exercise 3 take a filename from the
    command-line, and then display all words that are palindromes (ignoring
    case) in the file. Do not display duplicates (even if their case
    differs). Do not try to look for palindromes that are larger than a word
    (unlike in Exercise 4).
    -->
    <para>

    </para>

    <!--
    9.  Modify HTMLStripper.cpp so that when it encounters a tag, it
    displays the tag's name, then displays the file's contents between the
    tag and the file's ending tag. Assume no nesting of tags, and that all
    tags have ending tags (denoted with </TAGNAME>).
    -->
    <para>

    </para>

    <!--
    10.  Write a program that takes three command-line arguments (a filename
    and two strings) and displays to the console all lines in the file that
    have both strings in the line, either string, only one string, or
    neither string, based on user input at the beginning of the program (the
    user will choose which matching mode to use). For all but the ??neither
    string?? option, highlight the input string(s) by placing an asterisk
    (*) at the beginning and end of each string's occurrence when it is
    displayed.
    -->
    <para>

    </para>

    <!--
    11.  Write a program that takes two command-line arguments (a filename
    and a string) and counts the number of times the string occurs in the
    file, even as a substring (but ignoring overlaps). For example, an input
    string of ??ba?? would match twice in the word ??basketball,?? but an
    input string of ??ana?? would match only once in the word ??banana.??
    Display to the console the number of times the string is matched in the
    file, as well as the average length of the words where the string
    occurred. (If the string occurs more than once in a word, only count the
    word once in figuring the average.)
    -->
    <para>

    </para>

    <!--
    12.  Write a program that takes a filename from the command line and
    profiles the character usage, including punctuation and spaces (all
    character values of 0x21 [33] through 0x7E [126], as well as the space
    character). That is, count the number of occurrences of each character
    in the file, then display the results sorted either sequentially (space,
    then !, ", #, etc.) or by ascending or descending frequency based on
    user input at the beginning of the program. For space, display the word
    ??Space?? instead of the character ' '. A sample run might look
    something like this:
    -->
    <para>

    </para>

    <!--
    Format sequentially, ascending, or descending (S/A/D): D
    t: 526
    r: 490
    etc.
    -->
    <para>

    </para>

    <!--
    13.  Using find( ) and rfind( ), write a program that takes two
    command-line arguments (a filename and a string) and displays the first
    and last words (and their indexes) not matching the string, as well as
    the indexes of the first and last instances of the string. Display ??Not
    Found?? if any of the searches fail.
    -->
    <para>

    </para>

    <!--
    14.  Using the find_first_of ??family?? of functions (but not
    exclusively), write a program that will remove all non-alphanumeric
    characters except spaces and periods from a file, then capitalize the
    first letter following a period.
    -->
    <para>

    </para>

    <!--
    15.  Again using the find_first_of ??family?? of functions, write a
    program that accepts a filename as a command-line argument and then
    formats all numbers in the file to currency. Ignore decimal points after
    the first until a non-numeric character is found, and round to the
    nearest hundredth. For example, the string 12.399abc29.00.6a would be
    formatted (in the USA) to $12.40abc$29.01a.
    -->
    <para>

    </para>

    <!--
    16.  Write a program that accepts two command-line arguments (a filename
    and a number) and scrambles each word in the file by randomly switching
    two of its letters the number of times specified in the second
    argument. (That is, if 0 is passed into your program from the
    command-line, the words should not be scrambled; if 1 is passed in, one
    pair of randomly-chosen letters should be swapped, for an input of 2,
    two random pairs should be swapped, etc.).
    -->
    <para>

    </para>

    <!--
    17.  Write a program that accepts a filename from the command line and
    displays the number of sentences (defined as the number of periods in
    the file), average number of characters per sentence, and the total
    number of characters in the file.
    -->
    <para>

    </para>
  </sect1>
</chapter>
