<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Bárbara Teruggi <barby@teruggi.net>
                       David Villa Alises <dvilla@gmx.net>
  Formateado DocBook:  David Villa Alises
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">


<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C9">
  
  <title>Funciones <kw>inline</kw></title>
  

  <!-- 
  One of the important features C++ inherits from C is efficiency. If
  the efficiency of C++ were dramatically less than C, there would be a
  significant contigent of programmers who couldn't justify its use.
  -->
  
  <highlights>
    <para>
      Una de las características más importantes que C++ hereda de C es
      la eficiencia. Si la eficiencia de C++ fuese dramáticamente menor
      que la de C, podría haber un contingente significativo de
      programadores que no podrían justificar su uso.
    </para>
  </highlights>
  
  <!--
   In C, one of the ways to preserve efficiency is trough the use of
  macros, wich allow you to make what looks like a function call without
  the normal function call overhead.  The macro is implementes with the
  preprocessor instead of the compiler proper, and the preprocessor
  replaces all macro calls directly with de macrocode, so there's no
  cost involved from pushing argunments, making an assembly-languaje
  CALL, returning arguments, and performing an assembly-language
  RETURN. All the work is performed by the preprocessor, so you have the
  convenience and readability of a function call but it doesn't cost you
  anything.
  -->

  <para>
    En C, una de las maneras de preservar la eficiencia es mediante el
    uso de macros, lo que permite hacer lo que parece una llamada a
    una función sin la cabecera de llamada a la función normal.  La
    macro está implementada con el preprocesador en vez del propio
    compilador, y el preprocesador reemplaza todas las llamadas a
    macros directamente con el código de la macro, de manera que no
    hay que complicarse pasando argumentos, escribiendo código de
    ensamblador para <kw>CALL</kw>, retornando argumentos ni
    implementando código ensamblador para el
    <kw>RETURN</kw>. Todo el trabajo está implementado por
    el preprocesador, de manera que se tiene la coherencia y
    legibilidad de una llamada a una función pero sin ningún coste por
    ello.
  </para>

  <!-- 
  There are two problems with the use of preproccessor macros in
  C++. The first is also true with C: a macro looks like a function call,
  but doesn't always act like one. This can bury difficult-to-find
  bugs. The second problem is specific to C++: the preproccesor has no
  permission to access class member data. This means preprocessor macros
  cannot be used as class member functions.  
  -->
    
  <para>
    Hay dos problemas respecto del uso del preprocesador con macros en
    C++. La primera también existe en C: una macro parece una llamada a
    función, pero no siempre actúa como tal. Esto puede acarrear
    dificultades para encontrar errores.  El segundo problema es
    específico de C++: el preprocesador no tiene permisos para acceder a
    la información de los miembros de una clase. Esto significa que las
    macros de preprocesador no pueden usarse como métodos de una clase.
  </para>
  
  <!-- 
  To retain the efficiency of the preprocessor macro, but to add the
  safety and class scoping of true functions. C++ has the inline
  function. In this chapter, we'll look at the problems or preprocessor
  macros in C++, how these problems are solved with de inline functions,
  and guidelines an insights on the way inlines work.  
  -->

  <para>
    Para mantener la eficiencia del uso del preprocesador con macros pero
    añadiendo la seguridad y la semántica de ámbito de verdaderas funciones en
    las clases. C++ tiene las funciones inline. En este capítulo,
    veremos los problemas del uso de las maros de preprocesador en C++,
    como se resuelven estos problemas con funciones inline, y las
    directrices e incursiones en la forma en que trabajan las
    funciones inline.
  </para>


  <sect1>
    <title>Los peligros del preprocesador</title>

    <!--
    The key to the problems of preprocessor macros is that you can be
    fooled into thinking that the behavior of the preprocessor is the same
    as teh behavior of the computer. Of course it was intended that a macro
    look and act like a function call, so it's quite easy to fall into this
    fiction. The difficulties begin when the subtle differences appear.
    -->
    
    <para>
      La clave de los problemas con las macros de preprocesador radica
      en que puedes caer en el error de pensar que el comportamiento del
      preprocesador el igual que el del compilador. Por supuesto, la
      intención era que una macro se viera y actuara como una llamada a una
      función, de modo que es muy fácil caer en este error. Las
      dificultades comienzan cuando las diferencias subyacentes
      aparecen.
    </para>

    <!--
    As a simple example, consider the following:
    #define F (x) (x + 1)
    --> 
    
    <para>
      Consideremos un sencillo ejemplo:
    </para>
 
<programlisting>
#define F (x) (x + 1)
</programlisting>

    <!--
    Now, if a call is made to F like this
    F(1)
    --> 
    
    <para>
      Ahora, si hacemos una llamada a <function>F</function> de esta
      manera:
    </para>
 
<programlisting>
F(1)
</programlisting>

      <!--
      The preprocessor expands it, somewhat unexpectedly, to the following:
      (x) (x + 1) (1)
      --> 
    
    <para>
      El preprocesador la expande de manera inexperada esto:
    </para>
 
<programlisting>
(x) (x + 1) (1)
</programlisting>

    <!--
    The problem occurs because of the gap between F and its opening
    parenthseis in the macro definition.  When this gap is removed, you can
    actually call the macro with the gap.  F (1)
    -->
    
    <para>
      El problema ocurre a causa del espacio entre F y su paréntesis de
      apertura en la definición de la macro.  Cuando el espacio es
      eliminado en el código de la macro, de hecho puedes llamar a la
      función con el espacio incluido.
    </para>
 
<programlisting>
F (1)
</programlisting>

    <!--
    And it will still expand properly to:
    (1 + 1)
    --> 
    
    <para>
      Y se expanderá de manera correcta a lo siguiente:
    </para>
 
    <programlisting>
      (1 + 1)
    </programlisting>
    
    <!--
    The example avobe is fairly trivial and the problem will make itself
    evident right away. The real difficulties occur when ussing expressions
    as arguments in macro calls.
    --> 
    
    <para>
      El ejemplo anterior es un poco trivial y el problema es demasiado
      evidente. Las dificultades reales ocurren cuando se usan
      expresiones como argumentos en llamadas a macros.
    </para>

    <!--
    There are two problems. The first is that expressios may expand
    inside the macro so that their evaluation precedence is different from
    what you expect. For example: #define FLOOR(x,b) x> b?0:1 
    -->
    
    <para>
     Hay dos problemas. El primero es que las expresiones se expandirían
     dentro de la macro de modo que la evaluación resultante es
     diferente a lo que se espera. Por ejemplo:
    </para>

    <programlisting>
      #define FLOOR(x,b) x> b?0:1
    </programlisting>

    <!--
    Now, if expressions are used for the arguments:
    if(FLOOR(a&0x0f,0x07)) // ...
    --> 
    
    <para>
      Ahora, si usamos expresiones como argumentos:
    </para>    

    <programlisting>
      if (FLOOR(a &amp; 0x0f, 0x07)) // ...
    </programlisting>


    <!--
    The macro will expand to:
    if(a&0x0f>=0x07?0:1)
    --> 
    
    <para>
     La macro se expandiría a:
    </para>    

    <programlisting>
      if (a &amp; 0x0f >= 0x07 ? 0 : 1)
    </programlisting>

    <!--
    The precedence of & is lower than that of >=, so the macro evaluation
    will surprise you. Once you discover the problem, you can solve it by
    putting parentheses around everything in the macro definition. (This is
    a good practice to use when creating preprocessor macros.)Thus.
    #define FLOOR(x,b) ((x)>=(b)?0:1)
    --> 
    
    <para>
      La precedencia del &amp; es menor que la del >=, de modo que la
      evaluación de la macro te sorprenderá. Una vez hayas descubierto
      el problema, puedes solucionarlo insertando paréntesis a todo lo
      que hay dentro de la definición de la macro.  (Este es un buen
      metodo a seguir cuando definimos macros de preprocesador),
      entonces:
    </para>

    <programlisting>
      #define FLOOR(x,b) ((x) >= (b) ? 0 : 1)
    </programlisting>

    <!-- 
    Discovering the problem may be difficult, however, and you may not
    find it until after you've taken the proper macro behavior for
    granted. In the un-parenthezised version of the preceding macro,
    most expressions will work correctly beacause the precedence of >=
    is lower than most of the operators like +, /, -_- and even the
    bitwise shift operators. So you can easily begin to think that it
    works with all expressions, including those using bitwise logical
    operators.
    --> 
    
    <para>
      De cualquier manera, descubrir el problema puede ser difícil, y no
      lo darás con él hasta después de haber dado por sentado el
      comportamiento de la macro en si misma. En la versión sin
      paréntesis de la macro anterior, la mayoría de las expresiones van
      a actuar de manera correcta a causa de la precedencia de >=, la
      cual es menor que la mayoría de los operadores como +, /, --, e
      incluso los operadores de desplazamiento. Por lo que puedes pensar
      facilmente que funciona con todas las expresiones, incluyendo
      aquellas que empleen operadores logicos a nivel de bit.
    </para>

    <!--
    The preceding problem can be solved with careful programming
    practice: parenthesize everything in a macro. However, the second
    difficulty is subtler. Unlike a normal function, every time you use an
    argument in a macro, that argument is evaluated. As long as the macro
    is called only with ordinary variables, this evaluation is benign, but
    if t he evaluation of an argument has side effects, then the results
    can be surprising and will definitely not mimic function behavior.  
    -->
    
    <para>
      El problema anterior puede solucionarse programando
      cuidadosamente: poner entre paréntesis todo lo que esté definido
      dentro de una macro. De todos modos el segundo problema es más
      sutil. Al contrario de una función normal, cada vez que usas
      argumentos en una macro, dicho argumento es evaluado. Mientras la
      macro sea llamada solo con variables corrientes, esta evaluacón es
      benigna, pero si la evaluación de un argumento tiene efectos
      secundarios, entonces los resultados pueden ser inesperados y
      definitivamente no imitaran el comportamiento de una función.
    </para>

    <!--
    For example, this macro determines whether its argument falls within
    a certain range:
    #define BAND(x) (((x)>5 && (x)>10) ? (x) : 0)
    -->

    <para>
      Por ejemplo, esta macro determina si un argumento entra dentro de
      cierto rango:
    </para>

    <programlisting>
      #define BAND(x) (((x)>5 &amp;&amp; (x)>10) ? (x) : 0)
    </programlisting>

    <!-- 
    As long as you use an "ordinary" argument, the macro works very
    much like a real function. But as soon as you relax and start believing
    it is a real function, the problems start. Thus: 
    -->

    <para>
      Mientras uses un argumento "ordinario", la macro trabajará de
      manera bastante similar a una función real. Pero en cuanto te
      relajes y comiences a creer que realmente es una función,
      comenzarán los problemas. Entonces:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/MacroSideEffects.cpp"/>
</programlisting>

   
    <!-- 
    Notice the use of all upper-case characters in the name of the
    macro. This is a helpful practice because it tells the reader this is a
    macro and not a function, so if there are problems, it acts as a little
    reminder.  
    -->
    
    <para>
      Observa el uso de carácteres en mayúscula en el nombre de la
      macro. Este es un buen recurso ya que le advierte al lector que
      esto es una macro y no una función, entonces si hay algún
      problema, esto actúa como recordatorio.
    </para>

<!--
 Here's the output produced by t he program, which is not at all what
 you would have expected from a true function:

  a = 4
    BAND(++a)=0
     a - 5
  a - 5
    BAND(++a)=8
     a - 8
  a = 6
    BAND(++a)-9
     a = 9
  a = /
    BAND(++a)=10
     a = 10
  a = 8
    BAND(++a)-0
     a = 10
  a - 9
    BAND(++a)=0
     a = 11
  a = 10
    BAND(++a)=0
     a = 12
 
-->  

    <para>
      A continuación se muestra la salida producida por el programa, que
      no es para nada lo que se esperaría de una auténtica función:
    </para>

    <programlisting>
      a = 4
        BAND(++a)=0
         a - 5
      a - 5
        BAND(++a)=8
         a - 8
      a = 6
        BAND(++a)-9
         a = 9
      a = /
        BAND(++a)=10
         a = 10
      a = 8
        BAND(++a)-0
         a = 10
      a - 9
        BAND(++a)=0
         a = 11
      a = 10
        BAND(++a)=0
         a = 12
    </programlisting>

    <!-- 
    When a is four, only the first part of the conditional occurs, so
    the expression is evaluated only once, and the side effect of the macro
    call is that a becomes 5, which is what you would expect from a normal
    function call in the same situation. However, when the number is within
    the band, both conditionals are tested, which results in a third
    increment. Once the number gets out of the band, both conditionals are
    still tested so you get two increments. The side effects are different,
    depending on the argument.
    -->
    
    <para>
      Cuando <varname>a</varname> es cuatro, sólo ocurre la primera
      parte de la condición, de modo que la expresión es evaluada sólo
      una vez, y el efecto resultante de la llamada a la macro es que
      <varname>a</varname> será 5, que es lo que se esperaría de una
      llamada a función normal en la misma situación. De todos modos,
      cuando el numero está dentro del rango, se evalúan ambas
      condiciones, lo que da como resultado un tercer incremento. Una
      vez que el número se sale del rango, ambas condiciones siguen
      siendo evaluadas de manera que se obtienen dos incrementos.  Los
      efectos colaterales son distintos, dependiendo del argumento.
    </para>

    <!--
    This is clearly not the kind of behavior you want from a macro that
    looks like a function call. In this case, the obvious solution is to
    make it a true function, which of course adds the extra overhead and
    may reduce efficiency if you call that function a lot. Unfortunately,
    the problem may not always be so obvious, and you can unknowingly get a
    library that contains functions and macros mixed together, so a problem
    like this can hide some very difficult-to-find bugs. For example, the
    putc() macro in cstdio may evaluate its second argument twice. This is
    specified in Standard C. Also, careless implementations of toupper() as
    a macro may evaluate the argument more than once, which will give you
    unexpected results with toupper(*p++). [45]
    --> 
    
    <para>
      Este no es desde luego el comportamiento que se quiere de una
      macro que se parece a una llamada a función.  En este caso, la
      solución obviamente es hacer una autentica función, lo que de
      hecho implica la cabecera extra y puede reducir la eficiencia si
      se llama demasiado a esa función. Desafortunadamente, el problema
      no siempre será tan obvio, y sin saberlo. puedes estar utilizando
      una librería que contiene funciones y macros juntas, de modo que
      un problema como este puede esconder errores difíciles de
      encontrar. Por ejemplo, la macro <function>putc()</function> en
      <filename>cstdio</filename> puede llegar a evaluar dos veces su
      segundo argumento. Esto está especificado en el Estándar
      C. Además, la implementación descuidada de
      <function>toupper()</function> como una macro puede llegar a
      evaluar el argumento más de una vez, lo que dará resultados
      inesperados con
      <programlisting>toupper(*p++)</programlisting>. [45]
    </para>


    <sect2>
      <title>Macros y acceso</title>
      
      <!-- 
      Of course, careful coding and use of preprocessor macros is
      required with C, and we could certainly get away with the same
      thing in C++ if it weren't for one problem: a macro has no concept
      of the scoping required with member functions. The preprocessor
      simply performs text substitution, so you cannot say something
      like:
      
      class X{
      int i;
      public:
      #define VAL(X::i) // Error
      -->

      <para>
        Por supuesto, una programación limpia y el uso de macros de
        preprocesador es requerido con C, y podríamos hacer lo mismo en
        C++ si no fuese por un problema: una macro no posee el concepto
        del alcance requerido con funciones miembro. El preprocesador
        simplemente hace substitución de texto, de modo que no puedes
        hacer algo como:
      </para>

      <programlisting>
        class X{
          int i;
        public:
        #define VAL(X::i) // Error
      </programlisting> 
      
      <!--
      or anything even close. In adicction, there would be no indication of
      which object you were referring to. There is simply no way to express
      class scope in a macro. Without some alternative to preprocessor
      macros, programmers will be tempted to make some data members public
      for the sake of efficiency, thus exposing the underlying implementation
      and preventing changes in that implementation, as well as eliminating
      the guarding that private provides.
      -->
      
      <para>
        ni nada que se le acerce. En adición, no habrá ninguna
        indicación del objeto al que te estes refiriendo.  Simplemente
        no hay ninguna forma de expresar el alcance a una clase en una
        macro. No habiendo ninguna alternativa diferente a macros de
        preprocesador, los programadores se sentirán tentados de hacer
        alguno miembros de datos públicos por el bien de la eficiencia,
        así exponiendo la implementación subyacente y previniendo
        cambios en esa implementación, tanto como eliminando la
        protección que provee el tipo private.
      </para>

    </sect2>
  </sect1>


  <sect1>
    <title>Funciones <kw>inline</kw></title>

    <!--
    In solving the C++ problem of a macro with acces to private class
    members, all the problems associated with preprocessor macros were
    eliminated. This was done by bringing the concept of macros under the
    control of the compiler where they belong. C++ implements the macro as
    inline function, which is a true function in every sense. Any behavior
    you expect from an ordinary function, you get from an inline
    function. The only difference is that an inline function is expanded in
    place, like a preprocessor macro, so the overhead of the function call
    is eliminated. Thus, you should (almost) never use macros, only inline
    functions.
    -->

    <para>
      Al resolver el problema que había en C++ con las macros cuando
      acceden a miembros de clases privada, todos los problemas
      asociados con las macros de preprocesador fueron eliminados. Esto
      se ha hecho aplicando el concepto de macros bajo el control del
      compilador al cual pertenecen. C++ implementa la macro como una
      función inline, lo que es una función real en todo sentido. Todo
      comportamiento esperado de una función ordinaria, es obtenido de
      una función inline. La única diferencia es que una función inline
      se expande en el mismo sitio, como una macro de preprocesador, de
      modo que la cabecera de una llamada a función es eliminada. Así no
      deberías usar macros (casi) nunca, solo funciones inline.
    </para>

    <!--
    Any function defined within a class body is automatically inline, but
    you can also make a non-class function inline by preceding it with with
    the inline keyword. However, for it to have any effect, you must
    include the function body with the declaration, otherwise the compiler
    will treat it as an ordinary function declaration. Thus: inline int
    plusOne(int x);
    -->
    
    <para>
      Cualquier función definida en el cuerpo de una clase es
      automaticamente inline, pero tambien puedes hacer una funcion
      inline que no esté dentro del cuerpo de una clase, precediéndola
      con la palabra clave inline. De todos modos, para que esto tenga
      algun efecto, debes incluir el cuerpo de la función con la
      declaración, de otro modo el compilador tratará esta función como
      una declaración de una función ordinaria. Así:
    </para>

    <programlisting>
      inline int plusOne(int x);
    </programlisting>

    <!--
    has no effect at all other than declaring the function (which may or
    may not get an inline definition sometime later).  The successful
    approach provides the function body: inline int plusOne(int x) { return
    ++x; }
    -->

    <para>
      no tiene ningun otro efecto que declarar la función (que puede o
      no tomar una definición inline en algún momento).  El mejor
      aproximamiento se da cuando se provee el cuerpo de la función
      inmediatamente después de declararla:
    </para>

    <programlisting>
      inline int plusOne(int x) { return ++x; }
    </programlisting>

    <!--
    Notice that the compiler will check (as it always does) for the proper
    use of the function argument list and return value (performing any
    necessary conversions), something the preprocessor is incapable
    of. Also, if you try to write the above as preprocessor macro, you get
    an unwanted side effect.
    -->

    <para>
      Observe que el compilador revisará (como siempre lo hace), el uso
      apropiado de la lista de argumentos de la función y del retorno de
      valor (haciendo cualquier conversión necesaria), algo que el
      preprocesador es incapaz de hacer. Además, si intentas escribir lo
      anterior como una macro de preprocesador, obtendrás un efecto no
      deseado.
    </para>

    <!--
    HASTA AQUÍ TRADUJO BÁRBARA
    -->
    
    <!--
    You'll almost always want to put inline definitions in a header
    file. When the compiler sees such a definition, it puts the function
    type (the signature combined with the return value) and the function
    body in its symbol table. When you use the function, the compiler
    checks to ensure the call is correct and the return value is being
    used correctly, and then substitutes the function body for the
    function call, thus eliminating the overhead. The inline code does
    occupy space, but if the function is small, this can actually take
    less space than the code generated to do an ordinary function call
    (pushing arguments on the stack and doing the CALL).
    -->

    <para>
      Casi siempre querrá poner las funciones inline en un fichero de
      cabecera. Cuando el compilado ve una definción como esa pone el
      tipo de la función (la firma combinada con el valor de retorno) y
      el cuerpo de la función en su tabla de símbolos. Cuando use la
      función, el compilador se asegura de que la llamada es correcta y
      el valor de retorno se está usando correctamente, y entonces
      sustituye el cuerpo de la función por la llamada a la función, y
      de ese modo elemina la sobrecarga. El código inline ocupa espacio,
      pero si la función es pequeña, realmente ocupará menos espacio que
      el código generado para una llamada a una función ordinaria
      (colocando los argumentos en la pila y haciendo el CALL)
    </para>

    <!--
    An inline function in a header file has a special status, since you
    must include the header file containing the function and its
    definition in every file where the function is used, but you
    don't end up with multiple definition errors (however, the
    definition must be identical in all places where the inline function
    is included).
    -->

    <para>
      Una función inline en un fichero de cabecera tiene un estado
      especial, dado que debe incluir el fichero de cabecera que
      contiene la función y su definición en cada fichero en donde se
      use la función, pero eso no provoca un error de definición
      múltiple (sin embargo, la definición debe ser idéntica en todos
      los sitios en los que se incluya la función inline).
    </para>


    <sect2>
      <title>inline dentro de clases</title>

      <!--
      To define an inline function, you must ordinarily precede the
      function definition with the inline keyword. However, this is not
      necessary inside a class definition. Any function you define
      inside a class definition is automatically an inline. For example:
      -->

     <para>
       Para definir una función inline, debe anteponer la palabra clave
       <kw>inline</kw> al nombre de la función en el momento
       de definirla. Sin embargo, eso no es necesario dentro cuando se
       define dentro de una clase. Cualquier función que defina dentro
       de una clase es inline automáticamente. Por ejemplo:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Inline.cpp"/>
</programlisting>

      <!-- 
      Here, the two constructors and the print( ) function are all
      inlines by default. Notice in main( ) that the fact you are using inline
      functions is transparent, as it should be. The logical behavior of a
      function must be identical regardless of whether it's an inline
      (otherwise your compiler is broken). The only difference you'll see
      is in performance.  
      -->

      <para>
	Aquí, los dos constructores y la función
	<function>print()</function> son inline por defecto. Notar el
	hecho de usar funciones inline es transparente en
	<function>main()</function>, y así debe ser. El comportamiento
	lógico de una función debe ser idéntico aunque sea inline (de
	otro modo su compilador no funciona). La única diferencia
	visible es el rendimiento.
      </para>

      <!--
      Of course, the temptation is to use inlines everywhere inside
      class declarations because they save you the extra step of making
      the external member function definition. Keep in mind, however,
      that the idea of an inline is to provide improved opportunities
      for optimization by the compiler. But inlining a big function will
      cause that code to be duplicated everywhere the function is
      called, producing code bloat that may mitigate the speed benefit
      (the only reliable course of action is to experiment to discover
      the effects of inlining on your program with your compiler).  
      -->
      
      <para>
	Por supuesto, la tentación es usar declaraciones
	<kw>inline</kw> en cualquier parte dentro de la case
	porque ahorran el paso extra de hacer una definición de método
	externa. Sin embargo, debe tener presente, que la idea de una
	inline es dar al compilador mejores oportunidades de
	optimización. Pero si declara inline una función grande
	provocará que el código se duplique allí donde se llame la
	función, produciendo código [FIXME:bloat] que anulará el
	beneficio de velocidad obtenido (la única manera de descubrir
	los efectos del uso de inline en su programa con su compilador
	es experimentar).
      </para>

    </sect2>

    <sect2>
      <title>Funciones de acceso</title>

      <!--
      One of the most important uses of inlines inside classes is the access
      function. This is a small function that allows you to read or change
      part of the state of an object \u2013 that is, an internal variable or
      variables. The reason inlines are so important for access functions can
      be seen in the following example:
      -->
      
      <para>
	Uno de los usos más importantes de inline dentro de clases son
	las funciones de acceso. Se trata de pequeñas funciones que le
	permiten leer o cambiar parte del estado de un objeto, es decir,
	un o varias variables interanas. La razón por la que la inline
	es tan importante para las funciones de acceso se puede ver en
	el siguente ejemplo:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Access.cpp"/>
</programlisting>

<!--
Here, the class user never has direct contact with the state variables
inside the class, and they can be kept private, under the control of the
class designer. All the access to the private data members can be
controlled through the member function interface. In addition, access is
remarkably efficient. Consider the read( ), for example. Without
inlines, the code generated for the call to read( ) would typically
include pushing this on the stack and making an assembly language
CALL. With most machines, the size of this code would be larger than the
code created by the inline, and the execution time would certainly be
longer.  -->

      <para>
	Aquí, el usuario de la clase nunca tiene contacto directo con
	las variables de estado internas a la clase, y pueden mantenerse
	como privadas, bajo el control del diseñador de la clase. Todo
	el acceso a los atributos se puede controlar a través de los
	métodos de la interfaz. Además, el acceso es notablemente
	eficiente. Considere <function>read()</function>, por
	ejemplo. Sin inline, el código generado para la llamada a
	<function>read()</function> podría incluir colocarla en la pila
	y ejecutar la llamada CALL de ensamblador. En la mayoría de las
	arquitecturas, el tamaño de ese código sería mayor que el código
	creado para la variante inline, y el tiempo de ejecución sería
	más largo con toda certeza.
      </para>

<!--
Without inline functions, an efficiency-conscious class designer will be
tempted to simply make i a public member, eliminating the overhead by
allowing the user to directly access i. From a design standpoint, this
is disastrous because i then becomes part of the public interface, which
means the class designer can never change it. You're stuck with an
int called i. This is a problem because you may learn sometime later
that it would be much more useful to represent the state information as
a float rather than an int, but because int i is part of the public
interface, you can't change it. Or you may want to perform some
additional calculation as part of reading or setting i, which you
can't do if it's public. If, on the other hand, you've
always used member functions to read and change the state information of
an object, you can modify the underlying representation of the object to
your heart's content.
-->

      <para>
	Sin las funciones inline, un diseñador de clases preocupado por
	la eficiencia estaría tentado de hacer que <varname>i</varname>
	fuese un atributo público, eliminado la sobrecarga y permitiendo
	al usuario acceder directamente a <varname>i</varname>. Desde el
	punto de vista de un diseñador, eso resulta desastroso
	<varname>i</varname> sería parte de la interfaz pública, lo cual
	significa que el diseñador de la clase no podrá cambiar esto en
	el futuro. Tendrá que cargar con un entero llamado
	<varname>i</varname>. Esto es un problema porque después puede
	que considere mejor usar un <type>float</type> en lugar de un
	<type>int</type> para representar el estado, pero como
	<varname>i</varname> es parte de la interfaz pública, no podrá
	cambiarlo. O puede que necesite realizar algún cálculo adicional
	como parte de la lectura o escritura de <varname>i</varname>,
	que no podrá hacer si es público. Si, en el otro extremo,
	siempre usa métodos para leer y cambiar la información de estado
	de un objeto, podrá modificar la representación subyacente del
	objeto [FIXME: to your heart's content]
      </para>

<!--
In addition, the use of member functions to control data members allows
you to add code to the member function to detect when that data is being
changed, which can be very useful during debugging. If a data member is
public, anyone can change it anytime without you knowing about it.  
-->

      <para>
	Además, el uso de métodos para controlar atributos le permite
	añadir código al método para detectar cuando cambia el valor,
	algo que puede ser muy útil durante la depuración. Si un
	atributo es público, cualquiera puede cambiarlo en cualquier
	momento sin que el programador lo sepa.
      </para>

      <sect3>
	<title>Accesores y mutadores</title>

<!--
Some people further divide the concept of access functions into
accessors (to read state information from an object) and mutators (to
change the state of an object). In addition, function overloading may be
used to provide the same function name for both the accessor and
mutator; how you call the function determines whether you're
reading or modifying state information. Thus, 
-->

	<para>
	  Hay gente que divide el concepto de funciones de acceso en
	  dos accesores (para leer la informaión de estado de un
	  objeto) y mutadores (para cambiar el estado de un
	  objeto). Además, se puede utilizar la sobrecarga de
	  funciones para tener métodos accesores y mutadores con el
	  mismo nombre; el modo en que se invoque el método determina
	  si se lee o modifica la información de estado. Así,
	</para>

<programlisting>
<xi:include parse="text" href="./code/C09/Rectangle.cpp"/>
</programlisting>

<!--
The constructor uses the constructor initializer list (briefly
introduced in Chapter 8 and covered fully in Chapter 14) to initialize
the values of wide and high (using the pseudoconstructor form for
built-in types).
-->

	<para>
	  El constructor usa la lista de inicialización (brevemente
	  introducida en el capítulo 8 y ampliamente cubierta en el
	  capitulo 14) para inicializar los valores de
	  <varname>wide</varname> y <varname>high</varname> (usando el
	  formato de pseudoconstructor para los tipos de datos básicos).
	</para>

<!--
You cannot have member function names using the same identifiers as data
members, so you might be tempted to distinguish the data members with a
leading underscore. However, identifiers with leading underscores are
reserved so you should not use them.
-->

	<para>
	  No puede definir métodos que tengan el mismo nombre que los
	  atributos, de modo que puede que se sienta tentado de
	  distinguirlos con un guión bajo al final. Sin embargo, los
	  identificadores con guiones bajos finales están reservados y
	  el programador no debería usarlos.
	</para>

<!--
You may choose instead to use \u201cget\u201d and \u201cset\u201d to
indicate accessors and mutators: 
-->

	<para>
	  En su lugar, debería usar <quote>set</quote> y
	  <quote>get</quote> para indicar que los métodos son accesores
	  y mutadores.
	</para>

<programlisting>
<xi:include parse="text" href="./code/C09/Rectangle2.cpp"/>
</programlisting>

<!--
Of course, accessors and mutators don't have to be simple pipelines
to an internal variable. Sometimes they can perform more sophisticated
calculations. The following example uses the Standard C library time
functions to produce a simple Time class:
-->

	<para>
	  Por supuesto, los accesores y mutadores no tienen que ser
	  simples tuberías hacias las variables internas. A veces,
	  puedes efectuar cálculos más sofísticados. El siguiente
	  ejemplo usa las funciones de tiempo de la librería C
	  estándar para crear una clase <classname>Time</classname>:
	</para>

<programlisting>
<xi:include parse="text" href="./code/C09/Cpptime.h"/>
</programlisting>

<!--
The Standard C library functions have multiple representations for time,
and these are all part of the Time class. However, it isn't
necessary to update all of them, so instead the time_t t is used as the
base representation, and the tm local and ASCII character representation
asciiRep each have flags to indicate if they've been updated to the
current time_t. The two private functions updateLocal( ) and
updateAscii( ) check the flags and conditionally perform the update.
-->

	<para>
	  Las funciones de la librería C estándar tienen múltiples
	  representaciones para el tiempo, y todas ellas son parte de
	  la clase <classname>Time</classname>. Sin embargo, no es
	  necesario actualizar todos ellos, así
	  que <type>time_t</type> se usa para la representación base,
	  y tm local y la representación ASCII asciiRep tienen
	  banderas para indicar si han sido actualizadas para
	  el <type>time_t</type> actual. Las dos funciones
	  privadas <function>updateLocal()</function>
	  y <function>updateAscii()</function> comprueban las banderas
	  y condicionalmente hacen la actualización.
 	</para>

<!--
The constructor calls the mark( ) function (which the user can also call
to force the object to represent the current time), and this clears the
two flags to indicate that the local time and ASCII representation are
now invalid. The ascii( ) function calls updateAscii( ), which copies
the result of the Standard C library function asctime( ) into a local
buffer because asctime( ) uses a static data area that is overwritten if
the function is called elsewhere. The ascii( ) function return value is
the address of this local buffer.  -->

	<para>
	  El constructor llama a la
	  función <function>mark()</function> (que el usuario puede
	  llamar también para forzar al objeto a representar el tiempo
	  actual), y esto limpia las dos banderaas para indicar que el
	  tiempo local y la representación ASCII son ahora
	  inválidas. La función <function>ascii()</function> llama
	  a <function>updateAscii()</function>, que copia el resultado
	  de la función de la librería estándar de
	  C <function>asctime()</function> en un buffer local
	  porque <function>asctime()</function> usa una área de datos
	  estática que se sobreescribe si la función se llama en otra
	  parte. El valor de retorno de la
	  función <function>ascii()</function> es la dirección de este
	  buffer local.
	</para>

<!--
All the functions starting with daylightSavings( ) use the updateLocal(
) function, which causes the resulting composite inlines to be fairly
large. This doesn't seem worthwhile, especially considering you
probably won't call the functions very much. However, this
doesn't mean all the functions should be made non-inline. If you
make other functions non-inline, at least keep updateLocal( ) inline so
that its code will be duplicated in the non-inline functions,
eliminating extra function-call overhead.
-->

	<para>
	  Todas las funciones que empiezan
	  con <function>daylightSavings()</function> usan la
	  función <function>updateLocal()</function>, que causa que la
	  composción resultante de inlines sea bastante larga. No
	  parece que eso valga la pena, especialmente considerando que
	  probablemente no quiera llamar mucho las funciones. Sin
	  embargo, esto no significa que todas las funciones deban ser
	  no-inline. Is hace otras funciones no-inline, al menos
	  mantenga <function>updateLocal()</function>
	  como <kw>inline</kw> de modo que su código se
	  duplique en las funciones no-inline, eliminando la
	  sobrecarga extra de invocación de funciones.
	</para>

<!--
Here's a small test program:
-->

	<para>
	  Este es un pequeño programa de prueba:
	</para>

<programlisting>
<xi:include parse="text" href="./code/C09/Cpptime.cpp"/>
</programlisting>

<!--
A Time object is created, then some time-consuming activity is
performed, then a second Time object is created to mark the ending
time. These are used to show starting, ending, and elapsed times.
-->

	<para>
	  Se crea un objeto <classname>Time</classname>, se hace alguna
	  actividad que consuma tiempo, después se crea un segundo objeto
	  <classname>Time</classname> para marcar el tiempo de
	  finalización. Se usan para mostrar los tiempos de inicio, fin
	  y los intervalos.
	</para>



      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Stash y Stack con inlines</title>

    <!--
    Armed with inlines, we can now convert the Stash and Stack classes to be
    more efficient:
    -->
    <para>
      Armados con inlines, podemos modificar las clases
      <classname>Stash</classname> y <classname>Stack</classname> para
      hacerlas más eficientes.
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Stash4.h"/>
</programlisting>

    <!--
    The small functions obviously work well as inlines, but notice that
    the two largest functions are still left as non-inlines, since
    inlining them probably wouldn??t cause any performance gains:
    -->

    <para>
      Obviamente las funciones pequeñas funcionan bien como inlines,
      pero note que las dos funciones más largas siguen siendo
      no-inline, dado que convertirlas a inline no representaría ninguna
      ganancia de rendimiento.
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Stash4.cpp"/>
</programlisting>

    <!--
    Once again, the test program verifies that everything is working
    correctly:
    -->

    <para>
      Una vez más, el programa de prueba que verifica que todo funciona
      correctamente.
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Stash4Test.cpp"/>
</programlisting>

    <!--
    This is the same test program that was used before, so the output should
    be basically the same.
    -->

    <para>
      Este es el mismo programa de prueba que se usó antes, de modo que
      la salida debería ser básicamente la misma.
    </para>

    <!--
    The Stack class makes even better use of inlines: 
    -->

    <para>
      La clase <classname>Stack</classname> incluso hace mejor uso de inlines.
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Stack4.h"/>
</programlisting>

    <!--
    Notice that the Link destructor that was present but empty in the
    previous version of Stack has been removed. In pop( ), the
    expression delete oldHead simply releases the memory used by that
    Link (it does not destroy the data object pointed to by the Link).
    -->

    <para>
      Notar que el destructor <classname>Link</classname>, que se
      presentó pero vacio en la versión anterior de
      <classname>Stack</classname>, ha sido eliminado. En
      <function>pop()</function>, la expresión <literal
      role="code">delete oldHead</literal> simplemente libera la memoria
      usada por <classname>Link</classname> (no destruye el objeto
      <varname>data</varname> apuntado por el <classname>Link</classname>.
    </para>

    <!--
    Most of the functions inline quite nicely and obviously, especially
    for Link. Even pop( ) seems legitimate, although anytime you have
    conditionals or local variables it??s not clear that inlines will be
    that beneficial. Here, the function is small enough that it probably
    won??t hurt anything.
    -->

    <para>
      La mayoría de las funciones inline quedan bastante bien y
      obviamente, especialmente para
      <classname>Link</classname>. Incluso
      <methodname>pop()</methodname> parece justificado, aunque siempre
      que haya sentencias condicionales o variables locales no está
      claro que las inlines sean beneficiosas. Aquí, la función es lo
      suficientemente pequeña así que es probable que no haga ningún
      daño.
    </para>

    <!--
    If all your functions are inlined, using the library becomes quite
    simple because there's no linking necessary, as you can see in the
    test example (notice that there's no Stack4.cpp):
    -->

    <para>
      Si todas sus funciones son inline, usar la librería se convierte
      en algo bastante simple porque el enlazado es innecesario, como
      puede ver in el ejemplo de prueba (fíjese en que no hay
      <filename>Stack4.cpp</filename>.
    </para>


<programlisting>
<xi:include parse="text" href="./code/C09/Stack4Test.cpp"/>
</programlisting>

    <!--
    People will sometimes write classes with all inline functions so
    that the whole class will be in the header file (you'll see in this
    book that I step over the line myself). During program development
    this is probably harmless, although sometimes it can make for longer
    compilations. Once the program stabilizes a bit, you'll probably
    want to go back and make functions non-inline where appropriate.
    -->

    <para>
      La gente escribe veces clases con todas sus funciones inline,
      así que la clase completa está en el fichero de cabecera (verá
      en este libro que yo mismo lo hago). Durante el desarrollo de un
      programa probablemente esto es inofensivo, aunque a veces puede
      hacer que las compilaciones sean más lentas. Cuando el programa se
      estabiliza un poco, probablemente querrá volver a hacer las
      funciones no-inline donde sea conveniente. 
    </para>

  </sect1>

  <sect1>
    <!-- Inlines & the compiler -->
    <title>Funciones inline y el compilador</title>

    <!--
    To understand when inlining is effective, it's helpful to know what
    the compiler does when it encounters an inline. As with any
    function, the compiler holds the function type (that is, the
    function prototype including the name and argument types, in
    combination with the function return value) in its symbol table. In
    addition, when the compiler sees that the inline's function type
    and the function body parses without error, the code for the
    function body is also brought into the symbol table. Whether the
    code is stored in source form, compiled assembly instructions, or
    some other representation is up to the compiler.
    -->

    <para>
      Para comprender cuando utilizar inlines resulta eficiente, es útil
      saber lo que hace el compilador cuando encuentra una función
      inline. Como con cualquier función, el compilador apunta el
      <emphasis>tipo</emphasis> de la función es su tabla de símbolos
      (es decir, el prototipo de la función incluyendo el nombre y los
      tipos de los argumentos, en combinación con valor de
      retorno). Además cuando el compilador ve que la función es inline
      <emphasis>y</emphasis> el cuerpo no contiene errores, el código se
      coloca también en la tabla de símbolos. El código se almacena en
      su forma fuente, como instrucciones ensamblador compiladas, o
      alguna otra representación propia del compilador.
    </para>

    <!--
    When you make a call to an inline function, the compiler first
    ensures that the call can be correctly made. That is, all the
    argument types must either be the exact types in the function's
    argument list, or the compiler must be able to make a type
    conversion to the proper types and the return value must be the
    correct type (or convertible to the correct type) in the destination
    expression. This, of course, is exactly what the compiler does for
    any function and is markedly different from what the preprocessor
    does because the preprocessor cannot check types or make
    conversions.
    -->

    <para>
      Cuando hace una llamada a una función inline, el compilador se
      asegura primero de que la llamada se puede hacer correctamente. Es
      decir, los tipos de todos los argumentos corresponden exactamente con los
      tipos de la lista de argumentos de la función ( o el compilador el
      capaz de hacer una conversión de tipo apropiada) y el valor de
      retorno tiene el tipo correcto (o es convertible al tipo correcto)
      in la expresión destino. Esto, por supuesto, es exactamente lo
      mismo que hace el compilador para cualquier función y hay una
      diferencia considerable respecto de lo que hace el preprocesador
      porque el preprocesador no comprueba tipos ni hace conversiones.
    </para>

    <!--
    If all the function type information fits the context of the call,
    then the inline code is substituted directly for the function call,
    eliminating the call overhead and allowing for further optimizations
    by the compiler. Also, if the inline is a member function, the
    address of the object (this) is put in the appropriate place(s),
    which of course is another action the preprocessor is unable to
    perform.
    -->

    <para>
      Si toda la información del tipo de la función encaja en el
      contexto de la llamada, entonces la llamada a la función se
      sustituye directamente por el código inline, eliminando la sobrecarga
      y permitiendo que el compilador pueda hacer más
      optimizaciones. Además, si el inline es un método, la dirección
      del objeto(<varname>this</varname>) se pone en el lugar apropiado,
      que es, por supuesto, otra acción que el preprocesador es incapaz
      de hacer.
    </para>

    <sect2>
      <title>Limitaciones</title>

      <!--
      There are two situations in which the compiler cannot perform
      inlining. In these cases, it simply reverts to the ordinary form
      of a function by taking the inline definition and creating storage
      for the function just as it does for a non-inline. If it must do
      this in multiple translation units (which would normally cause a
      multiple definition error), the linker is told to ignore the
      multiple definitions.
      -->

      <para>
	Hay dos situaciones en que el compilador no puede efectuar la
	sustitución de inline. En estos casos, simplemente convierte la
	función a la forma ordinaria tomando la definción y pidiendo
	espacio para la función como hace con una función no-inline. Si
	debe hacerlo in varias unidades de traducción (lo que
	normalmente causaría un error de definición múltiple), se informa
	al enlazador que ignore esas definiciones múltiples.
      </para>

      <!--
      The compiler cannot perform inlining if the function is too
      complicated. This depends upon the particular compiler, but at the
      point most compilers give up, the inline probably wouldn't gain
      you any efficiency. In general, any sort of looping is considered
      too complicated to expand as an inline, and if you think about it,
      looping probably entails much more time inside the function than
      what is required for the function call overhead. If the function
      is just a collection of simple statements, the compiler probably
      won't have any trouble inlining it, but if there are a lot of
      statements, the overhead of the function call will be much less
      than the cost of executing the body. And remember, every time you
      call a big inline function, the entire function body is inserted
      in place of each call, so you can easily get code bloat without
      any noticeable performance improvement. (Note that some of the
      examples in this book may exceed reasonable inline sizes in favor
      of conserving screen real estate.)
      -->

      <para>
	En compilador no puede efectuar la sustitución de inline si la
	función es demasiado complicada. Esto depende de cada compilador
	particular, [FIXME:pero aunque muchos compiladores lo hagan], no
	habrá ninguna mejora de eficiencia. En general, se considera
	cualquier tipo de bucle demasiado complicado para expandir como
	una inline, y si lo piensa, el bucle tomará mucho más tiempo
	dentro de la función que el que conlleva la sobrecarga de la
	invocación de la función. Si la función es simplemente una
	colección se sentencias simples, probablemente el compilador no
	tendrá ningún problema para utilizar inline, pero si hay muchas
	sentencias, la sobrecarga de llamada será mucho menor que el
	coste de ejecutar el cuerpo. Y recuerde, cada vez que llame a
	una función inline grande, el cuerpo completo se inserta en el
	lugar de la llamada, de modo que el tamaño del código se inflará
	fácilmente sin que se perciba ninguna mejora de
	rendimiento. (Note que algunos de los ejemplos de este libro
	pueden exceder el tamaño razonable para una inline a cambio de
	mejorar la estética de los listados.
      </para>

      <!--
      The compiler also cannot perform inlining if the address of the
      function is taken implicitly or explicitly. If the compiler must
      produce an address, then it will allocate storage for the function
      code and use the resulting address. However, where an address is
      not required, the compiler will probably still inline the code.
      -->

      <para>
	El compilador tampoco efectua sustituciones inline si la
	dirección de la función se toma implícita o explícitamente. Si
	el compilador debe producir una dirección, entonces tendrá que
	alojar el código de la función y usar la dirección
	resultante. Sin embargo, cuando no se requiere una dirección,
	probablemente el compilador hará la sustitución inline.
      </para>

      <!--
      It is important to understand that an inline is just a suggestion
      to the compiler; the compiler is not forced to inline anything at
      all. A good compiler will inline small, simple functions while
      intelligently ignoring inlines that are too complicated. This will
      give you the results you want - the true semantics of a function
      call with the efficiency of a macro.
      -->

      <para>
	Es importante comprender que una declaración inline es sólo una
	sugerencia al compilador; el compilador no está forzado a hacer
	nada. Un buen compilador hará sustituciones inline para
	funciones pequeñas y simples mientras que ignorará las que sean
	demasiado complicadas. Eso le dará lo que espera - la auténtica
	semática de una llamada a función con la eficiencia de una
	macro.
      </para>
    </sect2>

    <sect2>
      <title>Referencias adelantadas</title>

      <!--
      If you're imagining what the compiler is doing to implement
      inlines, you can confuse yourself into thinking there are more
      limitations than actually exist. In particular, if an inline makes
      a forward reference to a function that has't yet been declared
      in the class (whether that function is inline or not), it can seem
      like the compiler won't be able to handle it:
      -->

      <para>
	Si está imaginando que el compilador [FIXME: is doing to
	implement inlines], puede confundirse pensando que hay más
	limitaciones que las que existen realmente. En concreto, si una
	inline hace una referencia adelanta a una función que no ha sido
	declarada aún en la clase (sea esa función inline o no), puede
	parecer que el compilador no sabrá tratarla.
      </para>


<programlisting>
<xi:include parse="text" href="./code/C09/EvaluationOrder.cpp"/>
</programlisting>

      <!--
      In f( ), a call is made to g( ), although g( ) has not yet been
      declared. This works because the language definition states that
      no inline functions in a class shall be evaluated until the
      closing brace of the class declaration.
      -->

      <para>
	En <function>f()</function>, se realiza una llamada a
	<function>g()</function>, aunque <function>g()</function> aún no
	ha sido declarada. Esto funciona porque la definición del
	lenguaje dice que las funciones inline en una clase no serán
	evaluadas hasta la llave de cierre de la declaración de clase.
      </para>


      <!--
      Of course, if g( ) in turn called f( ), you'd end up with a set
      of recursive calls, which are too complicated for the compiler to
      inline. (Also, you'd have to perform some test in f( ) or g( ) to
      force one of them to "bottom out," or the recursion would be
      infinite.)
      -->

      <para>
	Por supuesto, si <function>g()</function> a su vez llama a
	<function>f()</function>, tendrá un conjunto de llamadas
	recursivas, que son demasiado complicadas para el compilador
	pueda hacer inline. (También, tendrá que efectuar alguna
	comprobación en <function>f()</function> o
	<function>g()</function> para forzar en alguna de ellas un case
	base, o la recursión será infinita.)
      </para>

    </sect2>


    <sect2>
      <title>Actividades ocultas en contructores y destructores</title>


      <!--
      Constructors and destructors are two places where you can be
      fooled into thinking that an inline is more efficient than it
      actually is. Constructors and destructors may have hidden
      activities, because the class can contain subobjects whose
      constructors and destructors must be called. These subobjects
      may be member objects, or they may exist because of inheritance
      (covered in Chapter 14). As an example of a class with member
      objects:
      -->

      <para>
	Constructores y destructores son dos lugares dónde puede
	engañarse al pensar que una inline es más eficiente de lo que
	realmente es. Contstructores y destructores pueden tener
	actividades ocultas, porque la clase puede contener subobjetos
	cuyos constructores y destructores deben invocarse. Estos
	subobjetos pueden ser objetos miembro (atributos), o pueden
	existir por herencia (tratado en el Capítulo 14). Como un
	ejemplo de clase con un objeto miembro:
      </para>


<programlisting>
<xi:include parse="text" href="./code/C09/Hidden.cpp"/>
</programlisting>

      <!--
      The constructor for Member is simple enough to inline, since there'
      s nothing special going on -  no inheritance or member objects are
      causing extra hidden activities. But in class WithMembers there's
      more going on than meets the eye. The constructors and destructors
      for the member objects q, r, and s are being called automatically,

      and those constructors and destructors are also inline, so the
      difference is significant from normal member functions. This doesn'
      t necessarily mean that you should always make constructor and
      destructor definitions non-inline; there are cases in which it
      makes sense. Also, when you're making an initial "sketch" of a
      program by quickly writing code, it's often more convenient to
      use inlines. But if you're concerned about efficiency, it's a
      place to look.
      -->

      <para>
	El constructor para <classname>Member</classname> es
	suficientemente simple para ser inline, dado que no hay nada
	especial en él - ninguna herencia u objeto miembro está
	provocando actividades ocultas adicionales. Pero en la clase
	<classname>WithMembers</classname> hay más de lo que se ve a
	simple vista. Los constructores y destructores para los
	atributos <varname>q</varname>, <varname>r</varname> y
	<varname>s</varname> se llaman automáticamente, y esos
	constructores y destructores también son inline, así que la
	diferencia es significativa respecto a métodos normales. Esto no
	significa necesariamente que los constructores y destructores
	deban ser no-inline; hay casos en que tiene sentido. También,
	cuando se está haciendo un prototipo inicial de un programa
	escribiendo código rápidamente, es conveniente a menudo usar
	inlines. Pero si está preocupado por la eficiencia, es un sitio
	donde mirar.
      </para>


    </sect2>
  </sect1>

  <sect1>
    <title>Reducir el desorden</title>

    <!--
    In a book like this, the simplicity and terseness of putting inline
    definitions inside classes is very useful because more fits on a
    page or screen (in a seminar). However, Dan SaksFIXME:[46] has pointed out
    that in a real project this has the effect of needlessly cluttering
    the class interface and thereby making the class harder to use. He
    refers to member functions defined within classes using the Latin in
    situ (in place) and maintains that all definitions should be placed
    outside the class to keep the interface clean. Optimization, he
    argues, is a separate issue. If you want to optimize, use the inline
    keyword. Using this approach, the earlier Rectangle.cpp example
    becomes:
    -->

    <para>
      En un libro como éste, la simplicidad y brevedad de poner
      definiciones inline dentro de las clases es muy útil porque
      permite meter más en una página o pantalla (en un seminario). Sin
      embargo, Dan Saks [FIXME:46] ha apuntado que en un proyecto real
      esto tiene como efecto desordenar la interfaz de la clase y de ese
      modo hace que la clase sea más incomoda de usar. Él se refiere a
      los métodos definidos dentre de las clases usando el latín
      <emphasis>in situ</emphasis> (en el lugar) y manteniendo que todas
      las definiciones deberían colocarse fuera de la clase manteniendo
      la interfaz limplia. La optimización, argumenta él, es una asunto
      distinto. Si se requiere optimizar, use la palabra reservada
      <kw>inline</kw>. Usando este enfoque, el ejemplo
      anterior <filename>Rectangle.cpp</filename> quedaría:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/Noinsitu.cpp"/>
</programlisting>

    <!--
    Now if you want to compare the effect of inline functions to
    non-inline functions, you can simply remove the inline
    keyword. (Inline functions should normally be put in header files,
    however, while non-inline functions must reside in their own
    translation unit.) If you want to put the functions into
    documentation, it's a simple cut-and-paste operation. In situ
    functions require more work and have greater potential for
    errors. Another argument for this approach is that you can always
    produce a consistent formatting style for function definitions,
    something that doesn't always occur with in situ functions.
    -->

    <para>
      Ahora si quiere comparar el efecto de la funciones inline con la
      versión convencional, simplemente borre la palabra
      <kw>inline</kw>. (Las funciones inline normalmente
      deberían aparecen en los ficheros de cabecera, no obstante, las
      funciones no-inline deberían residir en un propia unidad de
      traducción.) Si quiere poner las funciones en la documentación, es
      tan simple como un <quote>copiar y pegar</quote>. Las funciones in
      situ requiere más trabajo y tiene más posibilidades de provocar
      errores. Otro argumento para esta propuesta es que siempre
      puede producir un estilo de formato consistente para las
      definiciones de función, algo que no siempre ocurre con las
      funciones <emphasis>in situ</emphasis>.
    </para>

  </sect1>

  <sect1>
    <title>Más características del preprocesador</title>

    <!--
    Earlier, I said that you almost always want to use inline functions
    instead of preprocessor macros. The exceptions are when you need to
    use three special features in the C preprocessor (which is also the
    C++ preprocessor): stringizing, string concatenation, and token
    pasting. Stringizing, introduced earlier in the book, is performed
    with the # directive and allows you to take an identifier and turn
    it into a character array. String concatenation takes place when two
    adjacent character arrays have no intervening punctuation, in which
    case they are combined. These two features are especially useful
    when writing debug code. Thus,
    -->

    <para>
      Antes, se dijo que <emphasis>casi</emphasis> siempre se prefiere
      usar funciones inline en lugar de macros del preprocesador. Las
      excepciones son cuando necesita usar tres propiedades especiales
      del preprocesador de C (que es también el preprocesador de C++):
      [FIXME(hay más):cadenización?]
      (<emphasis>stringizing</emphasis>), concatenación de cadenas, y
      encolado de símbolos (<emphasis>token
      pasting</emphasis>). <emphasis>Stringizing</emphasis>, ya
      comentado anteriormente en el libro, se efectua con la directiva
      <literal>#</literal> y permite tomar un identificador y
      convertirlo en una cadena de caracteres. La concatenación de
      cadenas tiene lugar cuando dos cadenas adyacentes no tienen
      puntuación, en cuyo caso se combinan. Estas dos propiedades son
      especialmente útiles cuando se escribe código de depuración. Así,
    </para>

<programlisting>
    #define DEBUG(x) cout &lt;&lt; #x " = " &lt;&lt; x &lt;&lt; endl
</programlisting>

    <!--
    This prints the value of any variable. You can also get a trace that
    prints out the statements as they execute:
    -->

    <para>
      Esto imprime el valor de cualquier variable. Puede conseguir
      también una traza que imprima las sentencias tal como se ejecutan:
    </para>

<programlisting>
    #define TRACE(s) cerr &lt;&lt; #s &lt;&lt; endl; s
</programlisting>

    <!--
    The #s stringizes the statement for output, and the second s
    reiterates the statement so it is executed. Of course, this kind of
    thing can cause problems, especially in one-line for loops:
    -->

    <para>
      El <literal>#s</literal> <quote>cadeniza</quote> la sentencia para
      la salida, y la segunda <literal>s</literal> hace que la sentencia
      se ejecute. Por supuesto, este tipo de cosas puede causar
      problemas, especialmente bucles <kw>for</kw> de una
      única línea.
    </para>

<programlisting>
    for(int i = 0; i &lt; 100; i++)
     TRACE(f(i));
</programlisting>

    <!--
    Because there are actually two statements in the TRACE( ) macro, the
    one-line for loop executes only the first one. The solution is to
    replace the semicolon with a
    -->

    <para>
      Como realmente hay dos sentencia en la macro
      <function>TRACE()</function>, el bucle <kw>for</kw> de
      una única línea ejecuta solo la primera. La solución es reemplazar
      el punto y coma por una coma en la macro.
    </para>

    <sect2>
      <!-- Token pasting -->
      <title>Encolado de símbolos</title>

      <!--
      Token pasting, implemented with the ## directive, is very useful
      when you are manufacturing code. It allows you to take two
      identifiers and paste them together to automatically create a new
      identifier. For example,
      -->
      
      <para>
	El emcolado de símbolos, implementado con la directiva ##, es
	muy útil cuando se genera código. Permite coger dos
	identificadores y pegarlos juntos para crear un nuevo
	identificador automáticamente. Por ejemplo,
      </para>

<programlisting>
    #define FIELD(a) char* a##_string; int a##_size
    class Record {
      FIELD(one);
      FIELD(two);
      FIELD(three);
      // ...
    }; 
</programlisting>

      <!--
      Each call to the FIELD( ) macro creates an identifier to hold a
      character array and another to hold the length of that array. Not
      only is it easier to read, it can eliminate coding errors and make
      maintenance easier. 
      -->

      <para>
	Cada llamada a la macro <function>FIELD()</function> crea un
	identificador para una cadena de caracteres y otro para la
	longitud de dicha cadena. No solo es fácil de leer, también
	puede eleminar errores de codificación y facilitar el
	mantenimiento.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Comprobación de errores mejorada</title>

    <!--
    The require.h functions have been used up to this point without
    defining them (although assert( ) has also been used to help detect
    programmer errors where it's appropriate). Now it's time to define
    this header file. Inline functions are convenient here because they
    allow everything to be placed in a header file, which simplifies the
    process of using the package. You just include the header file and
    you don't need to worry about linking an implementation file.
    -->

    <para>
      Las funciones de <filename>require.h</filename> se han usado antes
      de este punto sin haberlas definido (aunque
      <function>assert()</function> se ha usado también para ayudar a
      detectar errores del programador donde es apropiado). Ahora es el
      momento de definir este fichero de cabecera. Las funciones inline
      son convenientes aquí porque permiten colocar todo en el fichero
      de cabecera, lo que simplifica el proceso para usar el
      paquete. Simplemente, incluya el fichero de cabecera y no tiene
      que preocuparse por enlazar un fichero de implementeación.
    </para>

    <!--
    You should note that exceptions (presented in detail in Volume 2 of
    this book) provide a much more effective way of handling many kinds
    of errors - especially those that you'd like to recover from -
    instead of just halting the program. The conditions that require.h
    handles, however, are ones which prevent the continuation of the
    program, such as if the user doesn't provide enough command-line
    arguments or if a file cannot be opened. Thus, it's acceptable that
    they call the Standard C Library function exit( ).
    -->

    <para>
      Debería fijarse que las exceptciones (presentadas en detalle en el
      Volumen 2 de este libro) proveen una forma mucho más efectiva de
      manejar muchos tipos de errores - especialmente aquellos que de lo
      que debería recuperarse - en lugar de simplemente abortar el
      programa. Las condiciones que maneja
      <filename>require.h</filename>, sin embargo, son algunas que
      impiden que el programa continue, como por ejemplo que el usuario
      no introdujo suficiente argumentos en la línea de comandos o que
      un fichero no se puede abrir. De modo que es aceptable que usen la
      función <function>exit()</function> de la librería C estándar.
    </para>

    <!--
    The following header file is placed in the book's root directory so
    it's easily accessed from all chapters.
    -->

    <para>
      El siguiente fichero de cabecera está en el directorio raíz del
      libro, así que es fácilmente accesible desde todos los capítulos.
    </para>


<programlisting>
<xi:include parse="text" href="./code/require.h"/>
</programlisting>


    <!--
    The default values provide reasonable messages that can be changed
    if necessary.
    -->

    <para>
      Los valores por defecto proporcionan mensajes razonables que se
      pueden cambiar si es necesario.
    </para>

    <!--
    You'll notice that instead of using char* arguments, const string&
    arguments are used. This allows both char* and strings as arguments
    to these functions, and thus is more generally useful (you may want
    to follow this form in your own coding).
    -->

    <para>
      Fíjese en que en lugar de usar argumentos
      <type>char*</type> se utiliza <type>const string&amp;</type>. Esto
      permite tanto <type>char*</type> y cadenas
      <classname>string</classname> como argumentos para estas
      funciones, y así es más general (quizá quiera utilizar esta forma
      en su propio código).
    </para>

    <!--
    In the definitions for requireArgs( ) and requireMinArgs( ), one is
    added to the number of arguments you need on the command line
    because argc always includes the name of the program being executed
    as argument zero, and so always has a value that is one more than
    the number of actual arguments on the command line.
    -->
    
    <para>
      En las definiciones para <function>requireMinArgs()</function> y
      <function>requireMinArgs()</function>, se añade uno al número de
      argumentos que necesita en la línea de comandos porque
      <varname>argc</varname> siempre incluye el nombre del programa que
      está siendo ejecutado como argumento cero, y así siempre tiene un
      valor que excede en uno al número real de argumentos de la línea
      de comandos.
    </para>


    <!--
    Note the use of local "using namespace std" declarations within
    each function. This is because some compilers at the time of this
    writing incorrectly did not include the C standard library functions
    in namespace std, so explicit qualification would cause a
    compile-time error. The local declaration allows require.h to work
    with both correct and incorrect libraries without opening up the
    namespace std for anyone who includes this header file.
    -->

    <para>
      Fíjese en el uso de declaraciones locales <literal>using namespace
      std</literal> con cada función. Esto es porque algunos
      compiladores en el momento de escribir este libro incluyen
      incorrectamente las funciones de la librería C estándar en el
      espacio de nombres <classname>std</classname>, así que la
      cualificación explícita podría causar un error en tiempo de
      compilación. Las declaraciones locales permiten que
      <filename>require.h</filename> funcione tanto con librerías
      correctas como con incorrectas sin abrir el espacio de nombres
      <classname>std</classname> para cualquiera que incluya este
      fichero de cabecera.
    </para>

    <!--
    Here's a simple program to test require.h:
    -->

    <para>
      Aquí hay un programa simple para probar
      <filename>requite.h</filename>:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C09/ErrTest.cpp"/>
</programlisting>

    <!--
    You might be tempted to go one step further for opening files and
    add a macro to require.h:
    -->

    <para>
      Podría estar tentado a ir un paso más allá para manejar la
      apertura de ficheros e añadir una macro a
      <function>require.h</function>.
    </para>

<programlisting>
    #define IFOPEN(VAR, NAME) \
      ifstream VAR(NAME); \
      assure(VAR, NAME);
</programlisting>

    <!--
    Which could then be used like this:
      -->
    
    <para>
      Que podría usarse entoces con esto:
    </para>

<programlisting>
    IFOPEN(in, argv[1])
</programlisting>

    <!--
    At first, this might seem appealing since it means there's less to
    type. It's not terribly unsafe, but it's a road best avoided. Note
    that, once again, a macro looks like a function but behaves
    differently; it's actually creating an object (in) whose scope
    persists beyond the macro. You may understand this, but for new
    programmers and code maintainers it's just one more thing they have
    to puzzle out. C++ is complicated enough without adding to the
    confusion, so try to FIXME:talk yourself out of using preprocessor macros
    whenever you can.
    -->

    <para>
      Lo primero, esto podría parecer atractivo porque significa que hay
      que escribir menos. No es terriblemente inseguro, pero es un
      camino que es mejor evitar. Fíjese que, de nuevo, una macro parece
      una función pero se comparta diferente; realmente se está creando
      un objejo <varname>in</varname> cuyo alcance persiste más allá de
      la macro. Quizá lo entienda, pero para programadores nuevos y
      mantenedores de código sólo es una cosa más que ellos deben
      resolver. C++ es suficientemente complicado sin añadir confusión,
      así que intente no abusar de las macros del preprocesador siempre
      que pueda.
    </para>
  </sect1>
  
  <sect1>
    <title>Resumen</title>

    <!--
    It's critical that you be able to hide the underlying
    implementation of a class because you may want to change that
    implementation sometime later. You'll make these changes for
    efficiency, or because you get a better understanding of the
    problem, or because some new class becomes available that you want
    to use in the implementation. Anything that jeopardizes the privacy
    of the underlying implementation reduces the flexibility of the
    language. Thus, the inline function is very important because it
    virtually eliminates the need for preprocessor macros and their
    attendant problems. With inlines, member functions can be as
    efficient as preprocessor macros.
    -->

    <para>
      Es crítico que sea capaz de ocultar la implementación subyacente
      de una clase porque puede querer cambiarla después. Hará estos
      cambios por eficiencia, o para mejorar la legibilidad del
      problema, o porque hay alguna clase nueva disponible para usar en
      la implementación. Cualquier cosa que haga peligrar la privacidad
      de la implementación subyacente reduce la flexibilidad del
      lenguaje. Por eso, la función inline es muy importante porque
      prácticamente elimina la necesidad de macros de preprocesador y
      sus problemas asociados. Con inlines, los métodos pueden ser tan
      eficientes como las macros.
    </para>


    <!--
    The inline function can be overused in class definitions, of
    course. The programmer is tempted to do so because it's easier, so
    it will happen. However, it's not that big of an issue because
    later, when looking for size reductions, you can always change the
    functions to non-inlines with no effect on their functionality. The
    development guideline should be "First make it work, then optimize
    it."
    -->

    <para>
      Las funciones se puede usar con exceso en las definiciones de
      clase, por supuesto. El programador está tentado de hacerlo porque
      es fácil, así que ocurre. Sin embargo, no es un problema grave
      porque después, cuando se busquen reducciones de tamaño, siempre
      puede cambiar las inline a funciones convencionales dado que no
      afecta a su funcionalidad. La pauta debería ser <quote>Primero haz
      el trabajo, después optimízalo</quote>.
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>
    
    <orderedlist>
      <listitem>
	<!--
	1. Write a program that uses the F( ) macro shown at the beginning
	of the chapter and demonstrates that it does not expand properly,
	as described in the text. Repair the macro and show that it works
	correctly.
	-->
	<para>
	  Escriba un programa que use la macro <function>F()</function>
	  mostrada al principio del capítulo y demuestre que no se
	  expande apropiadamente, tal como describe el texto. Arregle la
	  macho y demuestre que funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!--
	2. Write a program that uses the FLOOR( ) macro shown at the
	beginning of the chapter. Show the conditions under which it does
	not work properly.
	-->
	<para>
	  Escriba un programa que use la macro
	  <function>FLOOR()</function> mostrada al pincipio del
	  capítulo. Muestre las condiciones en que no funciona
	  apropiadamente.
	</para>
      </listitem>
      <listitem>
	<!--
	3. Modify MacroSideEffects.cpp so that BAND( ) works properly.
	-->
	<para>
	  Modifique <filename>MacroSideEffects.cpp</filename> de modo
	  que <function>BAND()</function> funcione adecuadamente.
	</para>
      </listitem>
      <listitem>
	<!--
	4. Create two identical functions, f1( ) and f2( ). Inline f1( ) and
	leave f2( ) as an non-inline function. Use the Standard C Library
	function clock( ) that is found in &lt;ctime> to mark the starting
	point and ending points and compare the two functions to see
	which one is faster. You may need to make repeated calls to the
	functions inside your timing loop in order to get useful numbers.
	-->
	<para>
	  Cree dos funciones idénticas, <function>f1()</function> y
	  <function>f2()</function>. Haga inline a
	  <function>f1()</function> y deje <function>f2()</function>
	  como no-inline. Use la función <function>clock()</function> de
	  la librería C estándar que se encuentra en
	  <filename>&lt;ctime></filename> para marcar los puntos de
	  comienzo y fin y compare las dos funciones para ver cuál es
	  más rápida. Puede que necesite hacer un bucle de llamadas
	  repetidas para conseguir números útiles.
	</para>
      </listitem>
      <listitem>
	<!--
	5. Experiment with the size and complexity of the code inside the
	functions in Exercise 4 to see if you can find a break-even point
	where the inline function and the non-inline function take the
	same amount of time. If you have them available, try this with
	different compilers and note the differences.
	-->
	<para>
	  Experimente con el tamaño y complejidad del código de las
	  funciones del ejercicio 4 para ver si puede encontrar el punto
	  donde la función inline y la convencional tardan lo mismo. Si
	  dispone de ellos, inténtelo con compiladores distintos y
	  fíjese en las diferencias.
	</para>
      </listitem>
      <listitem>
	<!--
	6. Prove that inline functions default to internal linkage.
	-->
	<para>
	  Pruebe que las funciones inline hacer enlazado interno por
	  defecto.
	</para>
      </listitem>
      <listitem>
	<!--
	7. Create a class that contains an array of char. Add an inline
	constructor that uses the Standard C library function memset( )
	to initialize the array to the constructor argument (default this
	to ' '), and an inline member function called print( ) to print
	out all the characters in the array.
	-->
	<para>
	  Cree una clase que contenga un array de caracteres. Añada un
	  constructuor inline que use la función
	  <function>memset()</function> de la librería C estándar para
	  inicializar el array al valor dado como argumento del
	  constructor (por defecto será ' '), y un método inline llamado
	  <function>print()</function> que imprima todos los caracteres
	  del array.
	</para>
      </listitem>
      <listitem>
	<!--
	8. Take the NestFriend.cpp example from Chapter 5 and replace all
	the member functions with inlines. Make them non-in situ inline
	functions. Also change the initialize( ) functions to
	constructors.
	-->
	<para>
	  Coja el ejemplo <filename>NestFriend.cpp</filename> del
	  Capítulo 5 y reemplace todos los métodos con inlines. No haga
	  métodos inline <emphasis>in situ</emphasis>. También cambie
	  las funciones <function>initialize()</function> por
	  constructores.
	</para>
      </listitem>
      <listitem>
	<!--
	9. Modify StringStack.cpp from Chapter 8 to use inline functions.
	-->
	<para>
	  modifique <filename>StringStack.cpp</filename> del Capítulo 8
	  para usar funciones inline.
	</para>
      </listitem>
      <listitem>
	<!--
	10. Create an enum called Hue containing red, blue, and yellow. Now
        create a class called Color containing a data member of type Hue
        and a constructor that sets the Hue from its argument. Add
        access functions to "get" and "set" the Hue. Make all of the
        functions inlines.
	-->
	<para>
	  Cree un enumerado llamado <type>Hue</type> que contenga
	  <symbol>red</symbol>, <symbol>blue</symbol> y
	  <symbol>yellow</symbol>. Ahora cree una clase llamada
	  <classname>Color</classname> que contenga un atributo de tipo
	  <type>Hue</type> y un constructor que de valor al
	  <type>Hue</type> con su argumento. Añada métodos de acceso al
	  <type>Hue</type> <function>get()</function> y
	  <function>set()</function>. Haga inline todos los métodos.
	</para>
      </listitem>
      <listitem>
	<!--
	11. Modify Exercise 10 to use the "accessor" and "mutator"
        approach.
	-->
	<para>
	  Modifique el ejercicio 10 para usar el enfoque
	  <quote>accesor</quote> y <quote>mutador</quote>.
	</para>
      </listitem>
      <listitem>
	<!--
	12. Modify Cpptime.cpp so that it measures the time from the time
        that the program begins running to the time when the user
        presses the "Enter" or "Return" key.
	-->
	<para>
	  Modifique <filename>Cpptime.cpp</filename> de modo que mida el
	  tiempo desde que comienza el programa hasta que el usuario
	  pulsa la tecla <quote>Intro</quote> o <quote>Retorno</quote>.
	</para>
      </listitem>
      <listitem>
	<!--
	13. Create a class with two inline member functions, such that the
        first function that's defined in the class calls the second
        function, without the need for a forward declaration. Write a
        main that creates an object of the class and calls the first
        function.
	-->
	<para>
	  Cree una clase con dos métodos inline, el primero que está
	  definido en la clasee llama al segundo, sin necesitar una
	  declaración adelantada. Escriba un <function>main()</function>
	  que cree un objeto de esa clase y llame al primer método.
	</para>
      </listitem>
      <listitem>
	<!--
	14. Create a class A with an inline default constructor that
        announces itself. Now make a new class B and put an object of A
        as a member of B, and give B an inline constructor. Create an
        array of B objects and see what happens.
	-->
	<para>
	  Cree una clase <classname>A</classname> con un constructor por
	  defecto inline que se auncie a si mismo. Ahora cree una nueva
	  <classname>B</classname> y ponga un objeto de
	  <classname>A</classname> como miembro de
	  <classname>B</classname>, y dele a <classname>B</classname> un
	  contructor inline. cree un array de objetos B y vea que
	  sucede.
	</para>
      </listitem>
      <listitem>
	<!--
    15. Create a large quantity of the objects from the previous
        Exercise, and use the Time class to time the difference between
        non-inline constructors and inline constructors. (If you have a
        profiler, also try using that.)
	-->
	<para>
	  Cree una gran cantidad de objetos del ejercicio anterior, y
	  use la clase <classname>Time</classname> para medir las
	  diferencias entre los contructores inline y los no-inline. (Si
	  tiene un perfilador, intente usarlo también).
	</para>
      </listitem>
      <listitem>
	<!--
    16. Write a program that takes a string as the command-line
        argument. Write a for loop that removes one character from the
        string with each pass, and use the DEBUG( ) macro from this
        chapter to print the string each time.
	-->
	<para>
	  Escriba un progra que tome una cadena por línea de
	  comandos. Escriba un bucle <kw>for</kw> que elimine
	  un caracter de la cadena en cada pasada, y use la macro
	  <function>DEGUB()</function> de este capítulo para imprimir la
	  cadena cada vez.
	</para>
      </listitem>
      <listitem>
	<!--
    17. Correct the TRACE( ) macro as specified in this chapter, and
        prove that it works correctly.
	-->
	<para>
	  Corrija la macro <function>TRACE()</function> tal como se
	  explica en el capítulo, y pruebe que funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!--
    18. Modify the FIELD( ) macro so that it also contains an index
        number. Create a class whose members are composed of calls to
        the FIELD( ) macro. Add a member function that allows you to
        look up a field using its index number. Write a main( ) to test
        the class.
	-->
	<para>
	  Modifique la macro <function>FIELD()</function> para que
	  también incluya un índice numérico. Cree una clase cuyos
	  miembros están compuestos de llamadas a la macro
	  <function>FIELD()</function>. Añada un método que le permita
	  buscar en un campo usando el índice. Escriba un
	  <function>main()</function> para probar la clase.
	</para>
      </listitem>
      <listitem>
	<!--
    19. Modify the FIELD( ) macro so that it automatically generates
        access functions for each field (the data should still be
        private, however). Create a class whose members are composed of
        calls to the FIELD( ) macro. Write a main( ) to test the class.
	-->
	<para>
	  Modifique la macro <function>FIELD()</function> para que
	  automáticamente genere funciones de acceso para cada campo
	  (<varname>data</varname> debería no obstante ser
	  privado). Cree una clase cuyos miembros estén compuestos de
	  llamadas a la macro <function>FIELD()</function>. Escriba un
	  <function>main()</function> para probar la clase.
	</para>
      </listitem>
      <listitem>
	<!--
    20. Write a program that takes two command-line arguments: the first
        is an int and the second is a file name. Use require.h to ensure
        that you have the right number of arguments, that the int is
        between 5 and 10, and that the file can successfully be opened.
	-->
	<para>
	  Escriba un programa que tome dos argumentos de línea de
	  comandos: el primero es un <type>entero</type> y el segundo es
	  un nombre de fichero. Use <filename>requiere.h</filename> para
	  asegurar que tiene el número correcto de argumentos, que el
	  <type>entero</type> está entre 5 y 10, y que el fichero se
	  puede abrir satisfactorimente.
	</para>
      </listitem>
      <listitem>
	<!--
    21. Write a program that uses the IFOPEN( ) macro to open a file as
        an input stream. Note the creation of the ifstream object and
        its scope.
	-->
	<para>
	  Escriba un program que use la macro
	  <function>IFOPEN()</function> para abrir un fichero como un
	  flujo de entrada. Fíjese en la creación un objeto
	  <classname>ifstream</classname> y su alcance.
	</para>
      </listitem>
      <listitem>
	<!--
    22. (Challenging) Determine how to get your compiler to generate
        assembly code. Create a file containing a very small function
        and a main( ) that calls the function. Generate assembly code
        when the function is inlined and not inlined, and demonstrate
        that the inlined version does not have the function call
        overhead.
	-->
	<para>
	  (Desafio) Averigue cómo conseguir que su compilador genere
	  código ensamblador. Cree un fichero que contenga una función
	  muy pequeña y un <function>main()</function>. Genere el códgio
	  ensamblador cuando la función es inline y cuando no lo es, y
	  demuestre que la versión inline no tiene la sobrecarga por la
	  llamada.
	</para>
      </listitem>
    </orderedlist>
  </sect1>


</chapter>
