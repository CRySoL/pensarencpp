<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Bárbara Teruggi <barby@teruggi.net>
                       David Villa Alises <dvilla@gmx.net>
  Formateado DocBook:  David Villa Alises
  1ª Revisión:         David Villa Alises
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
          "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C09">

  <title>Funciones <kw>inline</kw></title>

  <!--
  One of the important features C++ inherits from C is efficiency. If
  the efficiency of C++ were dramatically less than C, there would be a
  significant contigent of programmers who couldn't justify its use.
  -->

  <highlights>
    <para>
      Una de las características más importantes que C++ hereda de C es
      la eficiencia. Si la eficiencia de C++ fuese dramáticamente menor
      que la de C, podría haber un contingente significativo de
      programadores que no podrían justificar su uso.
    </para>
  </highlights>

  <!--
   In C, one of the ways to preserve efficiency is trough the use of
  macros, wich allow you to make what looks like a function call without
  the normal function call overhead.  The macro is implementes with the
  preprocessor instead of the compiler proper, and the preprocessor
  replaces all macro calls directly with de macrocode, so there's no
  cost involved from pushing argunments, making an assembly-languaje
  CALL, returning arguments, and performing an assembly-language
  RETURN. All the work is performed by the preprocessor, so you have the
  convenience and readability of a function call but it doesn't cost you
  anything.
  -->

  <para>
    En C, una de las maneras de preservar la eficiencia es mediante el
    uso de macros, lo que permite hacer lo que parece una llamada a
    una función sin la sobrecarga habitual de la llamada a función.
    La macro está implementada con el preprocesador en vez del propio
    compilador, y el preprocesador reemplaza todas las llamadas a
    macros directamente con el código de la macro, de manera que no
    hay que complicarse pasando argumentos, escribiendo código de
    ensamblador para <kw>CALL</kw>, retornando argumentos ni
    implementando código ensamblador para el <kw>RETURN</kw>. Todo el
    trabajo lo realizar el preprocesador, de manera que se tiene la
    coherencia y legibilidad de una llamada a una función pero sin
    ningún coste.
  </para>

  <!--
  There are two problems with the use of preproccessor macros in
  C++. The first is also true with C: a macro looks like a function call,
  but doesn't always act like one. This can bury difficult-to-find
  bugs. The second problem is specific to C++: the preproccesor has no
  permission to access class member data. This means preprocessor macros
  cannot be used as class member functions.
  -->

  <para>
    Hay dos problemas respecto al uso del preprocesador con macros en
    C++. La primera también existe en C: una macro parece una llamada a
    función, pero no siempre actúa como tal. Esto puede acarrear
    dificultades para encontrar errores.  El segundo problema es
    específico de C++: el preprocesador no tiene permisos para acceder a
    la información de los miembros de una clase. Esto significa que las
    macros de preprocesador no pueden usarse como métodos de una clase.
  </para>

  <!--
  To retain the efficiency of the preprocessor macro, but to add the
  safety and class scoping of true functions. C++ has the inline
  function. In this chapter, we'll look at the problems or preprocessor
  macros in C++, how these problems are solved with de inline functions,
  and guidelines an insights on the way inlines work.
  -->

  <para>
    Para mantener la eficiencia del uso del preprocesador con macros
    pero añadiendo la seguridad y la semántica de ámbito de verdaderas
    funciones en las clases. C++ tiene las funciones
    <kw>inline</kw>. En este capítulo veremos los problemas del uso de
    las maros de preprocesador en C++, cómo se resuelven estos
    problemas con funciones <kw>inline</kw>, y las directrices e
    incursiones en la forma en que trabajan las
    <emphasis></emphasis>funciones inline.
  </para>


  <sect1>
    <title>Los peligros del preprocesador</title>

    <!--
    The key to the problems of preprocessor macros is that you can be
    fooled into thinking that the behavior of the preprocessor is the same
    as teh behavior of the computer. Of course it was intended that a macro
    look and act like a function call, so it's quite easy to fall into this
    fiction. The difficulties begin when the subtle differences appear.
    -->

    <para>
      La clave de los problemas con las macros de preprocesador radica
      en que puedes caer en el error de pensar que el comportamiento
      del preprocesador es igual que el del compilador. Por supuesto,
      la intención era que una macro se parezca y actúe como una
      llamada a una función, por eso es bastante fácil caer en este
      error. Las dificultades comienzan cuando las diferencias
      aparecen subyacentes.
    </para>

    <!--
    As a simple example, consider the following:
    #define F (x) (x + 1)
    -->

    <para>
      Consideremos un ejemplo sencillo:
    </para>

<programlisting>
#define F (x) (x + 1)
</programlisting>

    <!--
    Now, if a call is made to F like this
    F(1)
    -->

    <para>
      Ahora, si hacemos una llamada a <function>F</function> de esta
      manera:
    </para>

<programlisting>
F(1)
</programlisting>

      <!--
      The preprocessor expands it, somewhat unexpectedly, to the following:
      (x) (x + 1) (1)
      -->

    <para>
      El preprocesador la expande de manera inesperada:
    </para>

<programlisting>
(x) (x + 1)(1)
</programlisting>

    <!--
    The problem occurs because of the gap between F and its opening
    parenthseis in the macro definition.  When this gap is removed, you can
    actually call the macro with the gap.  F (1)
    -->

    <para>
      El problema se debe al espacio entre `F` y su paréntesis de
      apertura en la definición de la macro.  Cuando el espacio es
      eliminado en el código de la macro, puedes llamar a la función
      incluso incluyendo el espacio.
    </para>

<programlisting>
F (1)
</programlisting>

    <!--
    And it will still expand properly to:
    (1 + 1)
    -->

    <para>
      Y se expandirá de manera correcta a lo siguiente:
    </para>

    <programlisting>
      (1 + 1)
    </programlisting>

    <!--
    The example avobe is fairly trivial and the problem will make itself
    evident right away. The real difficulties occur when ussing expressions
    as arguments in macro calls.
    -->

    <para>
      El ejemplo anterior es un poco trivial y el problema es demasiado
      evidente. Las dificultades reales ocurren cuando se usan
      expresiones como argumentos en llamadas a macros.
    </para>

    <!--
    There are two problems. The first is that expressios may expand
    inside the macro so that their evaluation precedence is different from
    what you expect. For example: #define FLOOR(x,b) x> b?0:1
    -->

    <para>
     Hay dos problemas. El primero es que las expresiones pueden
     expandirse dentro de la macro de modo que la precedencia de la
     evaluación es diferente a lo que cabría esperar. Por ejemplo:
    </para>

    <programlisting>
      #define FLOOR(x,b) x>=b?0:1
    </programlisting>

    <!--
    Now, if expressions are used for the arguments:
    if(FLOOR(a&0x0f,0x07)) // ...
    -->

    <para>
      Ahora, si usamos expresiones como argumentos:
    </para>

    <programlisting>
      if (FLOOR(a&amp;0x0f,0x07)) // ...
    </programlisting>


    <!--
    The macro will expand to:
    if(a&0x0f>=0x07?0:1)
    -->

    <para>
     La macro se expandiría a:
    </para>

    <programlisting>
      if (a&amp;0x0f>=0x07?0:1)
    </programlisting>

    <!--
    The precedence of & is lower than that of >=, so the macro evaluation
    will surprise you. Once you discover the problem, you can solve it by
    putting parentheses around everything in the macro definition. (This is
    a good practice to use when creating preprocessor macros.)Thus.
    #define FLOOR(x,b) ((x)>=(b)?0:1)
    -->

    <para>
      La precedencia del &amp; es menor que la del >=, de modo que la
      evaluación de la macro te sorprenderá. Una vez hayas descubierto
      el problema, puedes solucionarlo insertando paréntesis a todo lo
      que hay dentro de la definición de la macro.  (Este es un buen
      método a seguir cuando defina macros de preprocesador), algo
      como:
    </para>

    <programlisting>
      #define FLOOR(x,b) ((x)>=(b)?0:1)
    </programlisting>

    <!--
    Discovering the problem may be difficult, however, and you may not
    find it until after you've taken the proper macro behavior for
    granted. In the un-parenthezised version of the preceding macro,
    most expressions will work correctly beacause the precedence of >=
    is lower than most of the operators like +, /, -_- and even the
    bitwise shift operators. So you can easily begin to think that it
    works with all expressions, including those using bitwise logical
    operators.
    -->

    <para>
      De cualquier manera, descubrir el problema puede ser difícil, y
      no dará con él hasta después de haber dado por sentado el
      comportamiento de la macro en sí misma. En la versión sin
      paréntesis de la macro anterior, la mayoría de las expresiones
      van a actuar de manera correcta a causa de la precedencia de >=,
      que es menor que la mayoría de los operadores como +, /, --, e
      incluso los operadores de desplazamiento. Por lo que puede
      pensar que funciona con todas las expresiones, incluyendo
      aquellas que empleen operadores lógicos a nivel de bit.
    </para>

    <!--
    The preceding problem can be solved with careful programming
    practice: parenthesize everything in a macro. However, the second
    difficulty is subtler. Unlike a normal function, every time you use an
    argument in a macro, that argument is evaluated. As long as the macro
    is called only with ordinary variables, this evaluation is benign, but
    if t he evaluation of an argument has side effects, then the results
    can be surprising and will definitely not mimic function behavior.
    -->

    <para>
      El problema anterior puede solucionarse programando
      cuidadosamente: poner entre paréntesis todo lo que esté definido
      dentro de una macro. De todos modos el segundo problema es más
      sutil. Al contrario de una función normal, cada vez que usa
      argumentos en una macro, dicho argumento es evaluado. Mientras la
      macro sea llamada solo con variables corrientes, esta evaluación es
      benigna, pero si la evaluación de un argumento tiene efectos
      secundarios, entonces los resultados pueden ser inesperados y
      definitivamente no imitaran el comportamiento de una función.
    </para>

    <!--
    For example, this macro determines whether its argument falls within
    a certain range:
    #define BAND(x) (((x)>5 && (x)>10) ? (x) : 0)
    -->

    <para>
      Por ejemplo, esta macro determina si un argumento entra dentro de
      cierto rango:
    </para>

    <programlisting>
      #define BAND(x) (((x)>5 &amp;&amp; (x)&lt;10) ? (x) : 0)
    </programlisting>

    <!--
    As long as you use an "ordinary" argument, the macro works very
    much like a real function. But as soon as you relax and start believing
    it is a real function, the problems start. Thus:
    -->

    <para>
      Mientras use un argumento <quote>ordinario</quote> la macro
      trabajará de manera bastante similar a una función real. Pero en
      cuanto se relaje y comience a creer que realmente es una
      función, comenzarán los problemas. Así:
    </para>


//: V1C09:MacroSideEffects.cpp


    <!--
    Notice the use of all upper-case characters in the name of the
    macro. This is a helpful practice because it tells the reader this is a
    macro and not a function, so if there are problems, it acts as a little
    reminder.
    -->

    <para>
      Observe el uso de caracteres en mayúscula en el nombre de la
      macro. Este es un buen recurso ya que advierte al lector que
      esto es una macro y no una función, entonces si hay algún
      problema, actúa como recordatorio.
    </para>

<!--
 Here's the output produced by t he program, which is not at all what
 you would have expected from a true function:
-->

    <para>
      A continuación se muestra la salida producida por el programa, que
      no es para nada lo que se esperaría de una auténtica función:
    </para>

    <screen>
a = 4
  BAND(++a)=0
   a = 5
a = 5
  BAND(++a)=8
   a = 8
a = 6
  BAND(++a)=9
   a = 9
a = 7
  BAND(++a)=10
   a = 10
a = 8
  BAND(++a)=0
   a = 10
a = 9
  BAND(++a)=0
   a = 11
a = 10
  BAND(++a)=0
   a = 12
    </screen>

    <!--
    When a is four, only the first part of the conditional occurs, so
    the expression is evaluated only once, and the side effect of the macro
    call is that a becomes 5, which is what you would expect from a normal
    function call in the same situation. However, when the number is within
    the band, both conditionals are tested, which results in a third
    increment. Once the number gets out of the band, both conditionals are
    still tested so you get two increments. The side effects are different,
    depending on the argument.
    -->

    <para>
      Cuando <varname>a</varname> es cuatro, sólo ocurre la primera
      parte de la condición, de modo que la expresión es evaluada sólo
      una vez, y el efecto resultante de la llamada a la macro es que
      <varname>a</varname> será 5, que es lo que se esperaría de una
      llamada a función normal en la misma situación. De todos modos,
      cuando el número está dentro del rango, se evalúan ambas
      condiciones, lo que da como resultado un tercer incremento. Una
      vez que el número se sale del rango, ambas condiciones siguen
      siendo evaluadas de manera que se obtienen dos incrementos.  Los
      efectos colaterales son distintos, dependiendo del argumento.
    </para>

    <!--
    This is clearly not the kind of behavior you want from a macro that
    looks like a function call. In this case, the obvious solution is to
    make it a true function, which of course adds the extra overhead and
    may reduce efficiency if you call that function a lot. Unfortunately,
    the problem may not always be so obvious, and you can unknowingly get a
    library that contains functions and macros mixed together, so a problem
    like this can hide some very difficult-to-find bugs. For example, the
    putc() macro in cstdio may evaluate its second argument twice. This is
    specified in Standard C. Also, careless implementations of toupper() as
    a macro may evaluate the argument more than once, which will give you
    unexpected results with toupper(*p++). [45]
    -->

    <para>
      Este no es desde luego el comportamiento que se quiere de una
      macro que se parece a una llamada a función.  En este caso, la
      solución obviamente es hacer una autentica función, lo que de
      hecho implica la cabecera extra y puede reducir la eficiencia si
      se llama demasiado a esa función. Desafortunadamente, el
      problema no siempre será tan obvio, y sin saberlo. puede estar
      utilizando una librería que contiene funciones y macros juntas,
      de modo que un problema como éste puede esconder errores
      difíciles de encontrar. Por ejemplo, la macro
      <function>putc()</function> de <filename>cstdio</filename> puede
      llegar a evaluar dos veces su segundo argumento. Esto está
      especificado en el Estándar C. Además, la implementación
      descuidada de <function>toupper()</function> como una macro
      puede llegar a evaluar el argumento más de una vez, lo que dará
      resultados inesperados con
      <code>toupper(*p++)</code><footnote>
      <para><author><firstname>Andrew</firstname><surname>Koenig</surname></author>
      entra en más detalles en su libro <citetitle>C Traps &amp;
      Pitfalls</citetitle> (Addison-Wesley, 1989).</para></footnote>.
    </para>


    <sect2>
      <title>Macros y acceso</title>

      <!--
      Of course, careful coding and use of preprocessor macros is
      required with C, and we could certainly get away with the same
      thing in C++ if it weren't for one problem: a macro has no concept
      of the scoping required with member functions. The preprocessor
      simply performs text substitution, so you cannot say something
      like:
      -->

      <para>
        Por supuesto, C requiere codificación cuidadosa y el uso de
        macros de preprocesador, y se podría hacer lo mismo en C++ si
        no fuese por un problema: las macros no poseen el concepto de
        ámbito requerido con los métodos. El preprocesador simplemente
        hace substitución de texto, de modo que no puede hacer algo
        como:
      </para>

      <programlisting>
        class X{
          int i;
        public:
        #define VAL(X::i) // Error
      </programlisting>

      <!--
      or anything even close. In adicction, there would be no indication of
      which object you were referring to. There is simply no way to express
      class scope in a macro. Without some alternative to preprocessor
      macros, programmers will be tempted to make some data members public
      for the sake of efficiency, thus exposing the underlying implementation
      and preventing changes in that implementation, as well as eliminating
      the guarding that private provides.
      -->

      <para>
        ni nada parecido. Además, no habría ninguna indicación del
        objeto al que se está refiriendo.  Simplemente no hay ninguna
        forma de expresar el ámbito de clase en una macro. No habiendo
        ninguna alternativa diferente a macros de preprocesador, los
        programadores se sentirán tentados de crear algunos atributos
        públicos por el bien de la eficiencia, exponiendo así la
        implementación subyacente e impidiendo cambios en esa
        implementación, así como eliminando la protección que
        proporciona <kw>private</kw>.
      </para>

    </sect2>
  </sect1>

  <sect1>
    <!-- Inline functions -->
    <title>Funciones <kw>inline</kw></title>

    <!--
    In solving the C++ problem of a macro with acces to private class
    members, all the problems associated with preprocessor macros were
    eliminated. This was done by bringing the concept of macros under the
    control of the compiler where they belong. C++ implements the macro as
    inline function, which is a true function in every sense. Any behavior
    you expect from an ordinary function, you get from an inline
    function. The only difference is that an inline function is expanded in
    place, like a preprocessor macro, so the overhead of the function call
    is eliminated. Thus, you should (almost) never use macros, only inline
    functions.
    -->

    <para>
      Al resolver el problema que había en C++ con las macros cuando
      acceden a miembros de clases privada, todos los problemas
      asociados con las macros de preprocesador fueron
      eliminados. Esto se ha hecho aplicando el concepto de macros
      bajo el control del compilador al cual pertenecen. C++
      implementa la macro como una función inline, lo que es una
      función real en todo sentido. Todo comportamiento esperado de
      una función ordinaria se obtiene con una función inline. La
      única diferencia es que una función inline se expande en el
      mismo sitio, como una macro de preprocesador, de modo que la
      cabecera de una llamada a función es eliminada. Por ello no
      debería usar macros (casi) nunca, solo funciones inline.
    </para>

    <!--
    Any function defined within a class body is automatically inline, but
    you can also make a non-class function inline by preceding it with with
    the inline keyword. However, for it to have any effect, you must
    include the function body with the declaration, otherwise the compiler
    will treat it as an ordinary function declaration. Thus: inline int
    plusOne(int x);
    -->

    <para>
      Cualquier función definida en el cuerpo de una clase es
      automáticamente inline, pero también puede hacer una función
      inline que no esté dentro del cuerpo de una clase, precediéndola
      con la palabra clave inline. De todos modos, para que esto tenga
      algún efecto, debe incluir el cuerpo de la función con la
      declaración, de otro modo el compilador tratará esa función como
      una declaración de una función ordinaria. Así:
    </para>

    <programlisting>
      inline int plusOne(int x);
    </programlisting>

    <!--
    has no effect at all other than declaring the function (which may or
    may not get an inline definition sometime later).  The successful
    approach provides the function body: inline int plusOne(int x) { return
    ++x; }
    -->

    <para>
      no tiene ningún otro efecto que declarar la función (que puede o
      no obtener una definición inline después).  La aproximación
      correcta proporciona el cuerpo de la función:
    </para>

    <programlisting>
      inline int plusOne(int x) { return ++x; }
    </programlisting>

    <!--
    Notice that the compiler will check (as it always does) for the proper
    use of the function argument list and return value (performing any
    necessary conversions), something the preprocessor is incapable
    of. Also, if you try to write the above as preprocessor macro, you get
    an unwanted side effect.
    -->

    <para>
      Observe que el compilador revisará (como siempre lo hace), el
      uso apropiado de la lista de argumentos de la función y del
      valor de retorno (haciendo cualquier conversión necesaria), algo
      que el preprocesador es incapaz de hacer. Además, si intenta
      escribir lo anterior como una macro de preprocesador, obtendrá
      un efecto no deseado.
    </para>


    <!--
    HASTA AQUÍ TRADUJO BÁRBARA
    -->

    <!--
    You'll almost always want to put inline definitions in a header
    file. When the compiler sees such a definition, it puts the function
    type (the signature combined with the return value) and the function
    body in its symbol table. When you use the function, the compiler
    checks to ensure the call is correct and the return value is being
    used correctly, and then substitutes the function body for the
    function call, thus eliminating the overhead. The inline code does
    occupy space, but if the function is small, this can actually take
    less space than the code generated to do an ordinary function call
    (pushing arguments on the stack and doing the CALL).
    -->

    <para>
      Casi siempre querrá poner las funciones inline en un fichero de
      cabecera. Cuando el compilador ve una definición como esa pone el
      tipo de la función (la firma combinada con el valor de retorno) y
      el cuerpo de la función en su tabla de símbolos. Cuando use la
      función, el compilador se asegura de que la llamada es correcta y
      el valor de retorno se está usando correctamente, y entonces
      sustituye el cuerpo de la función por la llamada a la función, y
      de ese modo elimina la sobrecarga. El código inline ocupa espacio,
      pero si la función es pequeña, realmente ocupará menos espacio que
      el código generado para una llamada a función ordinaria
      (colocando los argumentos en la pila y ejecutando el CALL).
    </para>

    <!--
    An inline function in a header file has a special status, since you
    must include the header file containing the function and its
    definition in every file where the function is used, but you
    don't end up with multiple definition errors (however, the
    definition must be identical in all places where the inline function
    is included).
    -->

    <para>
      Una función inline en un fichero de cabecera tiene un estado
      especial, dado que debe incluir el fichero de cabecera que
      contiene la función y su definición en cada fichero en donde se
      use la función, pero eso no provoca un error de definición
      múltiple (sin embargo, la definición debe ser idéntica en todos
      los sitios en los que se incluya la función inline).
    </para>


    <sect2>
      <title>inline dentro de clases</title>

      <!--
      To define an inline function, you must ordinarily precede the
      function definition with the inline keyword. However, this is not
      necessary inside a class definition. Any function you define
      inside a class definition is automatically an inline. For example:
      -->

     <para>
       Para definir una función inline, debe anteponer la palabra clave
       <kw>inline</kw> al nombre de la función en el momento
       de definirla. Sin embargo, eso no es necesario cuando se
       define dentro de una clase. Cualquier función que defina dentro
       de una clase es inline automáticamente. Por ejemplo:
      </para>


//: V1C09:Inline.cpp


      <!--
      Here, the two constructors and the print( ) function are all
      inlines by default. Notice in main( ) that the fact you are using inline
      functions is transparent, as it should be. The logical behavior of a
      function must be identical regardless of whether it's an inline
      (otherwise your compiler is broken). The only difference you'll see
      is in performance.
      -->

      <para>
	Aquí, los dos constructores y la función
	<function>print()</function> son inline por defecto. Dese
	cuenta de que usar funciones inline es transparente en
	<function>main()</function>, y así debe ser. El comportamiento
	lógico de una función debe ser idéntico aunque sea inline (de
	otro modo su compilador no funcionaría). La única diferencia
	visible es el rendimiento.
      </para>

      <!--
      Of course, the temptation is to use inlines everywhere inside
      class declarations because they save you the extra step of making
      the external member function definition. Keep in mind, however,
      that the idea of an inline is to provide improved opportunities
      for optimization by the compiler. But inlining a big function will
      cause that code to be duplicated everywhere the function is
      called, producing code bloat that may mitigate the speed benefit
      (the only reliable course of action is to experiment to discover
      the effects of inlining on your program with your compiler).
      -->

      <para>
	Por supuesto, la tentación es usar declaraciones
	<kw>inline</kw> en cualquier parte dentro de la case porque
	ahorran el paso extra de hacer una definición de método
	externa. Sin embargo, debe tener presente, que la idea de una
	inline es dar al compilador mejores oportunidades de
	optimización. Pero, si declara inline una función grande
	provocará que el código se duplique allí donde se llame,
	produciendo código [FIXME:bloat] que anulará el beneficio de
	velocidad obtenido (la única manera de descubrir los efectos
	del uso de inline en su programa con su compilador es
	experimentar).
      </para>

    </sect2>

    <sect2>
      <title>Funciones de acceso</title>

      <!--
      One of the most important uses of inlines inside classes is the access
      function. This is a small function that allows you to read or change
      part of the state of an object \u2013 that is, an internal variable or
      variables. The reason inlines are so important for access functions can
      be seen in the following example:
      -->

      <para>
	Uno de los usos más importantes de inline dentro de clases son
	las funciones de acceso. Se trata de pequeñas funciones que le
	permiten leer o cambiar parte del estado de un objeto, es decir,
	una o varias variables internas. La razón por la que inline
	es tan importante para las funciones de acceso se puede ver en
	el siguiente ejemplo:
      </para>


//: V1C09:Access.cpp


<!--
Here, the class user never has direct contact with the state variables
inside the class, and they can be kept private, under the control of the
class designer. All the access to the private data members can be
controlled through the member function interface. In addition, access is
remarkably efficient. Consider the read( ), for example. Without
inlines, the code generated for the call to read( ) would typically
include pushing this on the stack and making an assembly language
CALL. With most machines, the size of this code would be larger than the
code created by the inline, and the execution time would certainly be
longer.  -->

      <para>
	Aquí, el usuario de la clase nunca tiene contacto directo con
	las variables de estado internas a la clase, y pueden mantenerse
	como privadas, bajo el control del diseñador de la clase. Todo
	el acceso a los atributos se puede controlar a través de los
	métodos de la interfaz. Además, el acceso es notablemente
	eficiente. Considere <function>read()</function>, por
	ejemplo. Sin inline, el código generado para la llamada a
	<function>read()</function> podría incluir colocarla en la pila
	y ejecutar la llamada CALL de ensamblador. En la mayoría de las
	arquitecturas, el tamaño de ese código sería mayor que el código
	creado para la variante inline, y el tiempo de ejecución sería
	mayor con toda certeza.
      </para>

<!--
Without inline functions, an efficiency-conscious class designer will be
tempted to simply make i a public member, eliminating the overhead by
allowing the user to directly access i. From a design standpoint, this
is disastrous because i then becomes part of the public interface, which
means the class designer can never change it. You're stuck with an
int called i. This is a problem because you may learn sometime later
that it would be much more useful to represent the state information as
a float rather than an int, but because int i is part of the public
interface, you can't change it. Or you may want to perform some
additional calculation as part of reading or setting i, which you
can't do if it's public. If, on the other hand, you've
always used member functions to read and change the state information of
an object, you can modify the underlying representation of the object to
your heart's content.
-->

      <para>
	Sin las funciones inline, un diseñador de clases preocupado
	por la eficiencia estaría tentado de hacer que
	<varname>i</varname> fuese un atributo público, eliminado la
	sobrecarga y permitiendo al usuario acceder directamente a
	<varname>i</varname>. Desde el punto de vista del diseñador,
	eso resulta desastroso, <varname>i</varname> sería parte de la
	interfaz pública, lo cual significa que el diseñador de la
	clase no podrá cambiarlo en el futuro. Tendrá que cargar con
	un entero llamado <varname>i</varname>. Esto es un problema
	porque después puede que considere mejor usar un
	<type>float</type> en lugar de un <type>int</type> para
	representar el estado, pero como <varname>i</varname> es parte
	de la interfaz pública, no podrá cambiarlo. O puede que
	necesite realizar algún cálculo adicional como parte de la
	lectura o escritura de <varname>i</varname>, que no podrá
	hacer si es público. Si, por el contrario, siempre usa
	métodos para leer y cambiar la información de estado del
	objeto, podrá modificar la representación subyacente del
	objeto hasta estar totalmente convencido.
      </para>

<!--
In addition, the use of member functions to control data members allows
you to add code to the member function to detect when that data is being
changed, which can be very useful during debugging. If a data member is
public, anyone can change it anytime without you knowing about it.
-->

      <para>
	Además, el uso de métodos para controlar atributos le permite
	añadir código al método para detectar cuando cambia el valor,
	algo que puede ser muy útil durante la depuración. Si un
	atributo es público, cualquiera puede cambiarlo en cualquier
	momento sin que el programador lo sepa.
      </para>

      <sect3>
	<title>Accesores y mutadores</title>

<!--
Some people further divide the concept of access functions into
accessors (to read state information from an object) and mutators (to
change the state of an object). In addition, function overloading may be
used to provide the same function name for both the accessor and
mutator; how you call the function determines whether you're
reading or modifying state information. Thus,
-->

	<para>
	  Hay gente que divide el concepto de funciones de acceso en
	  dos: accesores (para leer la información de estado de un
	  objeto) y mutadores (para cambiar el estado de un
	  objeto). Además, se puede utilizar la sobrecarga de
	  funciones para tener métodos accesores y mutadores con el
	  mismo nombre; el modo en que se invoque el método determina
	  si se lee o modifica la información de estado. Así,
	</para>


//: V1C09:Rectangle.cpp


<!--
The constructor uses the constructor initializer list (briefly
introduced in Chapter 8 and covered fully in Chapter 14) to initialize
the values of wide and high (using the pseudoconstructor form for
built-in types).
-->

	<para>
	  El constructor usa la lista de inicialización (brevemente
	  introducida en el capítulo 8 y ampliamente cubierta en el
	  capitulo 14) para asignar valores a <varname>wide</varname>
	  y <varname>high</varname> (usando el formato de
	  pseudo-constructor para los tipos de datos básicos).
	</para>

<!--
You cannot have member function names using the same identifiers as data
members, so you might be tempted to distinguish the data members with a
leading underscore. However, identifiers with leading underscores are
reserved so you should not use them.
-->

	<para>
	  No puede definir métodos que tengan el mismo nombre que los
	  atributos, de modo que puede que se sienta tentado de
	  distinguirlos con un guión bajo al final. Sin embargo, los
	  identificadores con guiones bajos finales están reservados y
	  el programador no debería usarlos.
	</para>

<!--
You may choose instead to use \u201cget\u201d and \u201cset\u201d to
indicate accessors and mutators:
-->

	<para>
	  En su lugar, debería usar <quote>set</quote> y
	  <quote>get</quote> para indicar que los métodos son accesores
	  y mutadores.
	</para>


//: V1C09:Rectangle2.cpp


<!--
Of course, accessors and mutators don't have to be simple pipelines
to an internal variable. Sometimes they can perform more sophisticated
calculations. The following example uses the Standard C library time
functions to produce a simple Time class:
-->

	<para>
	  Por supuesto, los accesores y mutadores no tienen porqué ser
	  simples tuberías hacia las variables internas. A veces,
	  pueden efectuar cálculos más sofisticados. El siguiente
	  ejemplo usa las funciones de tiempo de la librería C
	  estándar para crear una clase <classname>Time</classname>:
	</para>


//: V1C09:Cpptime.h


<!--
The Standard C library functions have multiple representations for time,
and these are all part of the Time class. However, it isn't
necessary to update all of them, so instead the time_t t is used as the
base representation, and the tm local and ASCII character representation
asciiRep each have flags to indicate if they've been updated to the
current time_t. The two private functions updateLocal( ) and
updateAscii( ) check the flags and conditionally perform the update.
-->

	<para>
	  Las funciones de la librería C estándar tienen múltiples
	  representaciones para el tiempo, y todas ellas son parte de
	  la clase <classname>Time</classname>. Sin embargo, no es
	  necesario actualizar todos ellos, así que
	  <type>time_t</type> se usa para la representación base, y
	  <type>tm</type> <varname>local</varname> y la representación
	  ASCII <varname>asciiRep</varname> tienen banderas para
	  indicar si han sido actualizadas para el <type>time_t</type>
	  actual. Las dos funciones privadas
	  <function>updateLocal()</function> y
	  <function>updateAscii()</function> comprueban las banderas y
	  condicionalmente hacen la actualización.
 	</para>

<!--
The constructor calls the mark( ) function (which the user can also call
to force the object to represent the current time), and this clears the
two flags to indicate that the local time and ASCII representation are
now invalid. The ascii( ) function calls updateAscii( ), which copies
the result of the Standard C library function asctime( ) into a local
buffer because asctime( ) uses a static data area that is overwritten if
the function is called elsewhere. The ascii( ) function return value is
the address of this local buffer.  -->

	<para>
	  El constructor llama a la función
	  <function>mark()</function> (que el usuario puede llamar
	  también para forzar al objeto a representar el tiempo
	  actual), y eso limpia las dos banderas para indicar que el
	  tiempo local y la representación ASCII ya no son válidas. La
	  función <function>ascii()</function> llama a
	  <function>updateAscii()</function>, que copia el resultado
	  de la función de la librería estándar de C
	  <function>asctime()</function> en un buffer local porque
	  <function>asctime()</function> usa una área de datos
	  estática que se sobreescribe si la función se llama en otra
	  parte. El valor de retorno de la función
	  <function>ascii()</function> es la dirección de ese buffer
	  local.
	</para>

<!--
All the functions starting with daylightSavings( ) use the updateLocal(
) function, which causes the resulting composite inlines to be fairly
large. This doesn't seem worthwhile, especially considering you
probably won't call the functions very much. However, this
doesn't mean all the functions should be made non-inline. If you
make other functions non-inline, at least keep updateLocal( ) inline so
that its code will be duplicated in the non-inline functions,
eliminating extra function-call overhead.
-->

	<para>
	  Todas las funciones que empiezan con
	  <function>daylightSavings()</function> usan la función
	  <function>updateLocal()</function>, que causa que la
	  composición resultante de inlines sea bastante larga. No
	  parece que valga la pena, especialmente considerando que
	  probablemente no quiera llamar mucho a esas funciones. Sin
	  embargo, eso no significa que todas las funciones deban ser
	  no-inline. Si hace otras funciones no-inline, al menos
	  mantenga <function>updateLocal()</function> como
	  <kw>inline</kw> de modo que su código se duplique en las
	  funciones no-inline, eliminando la sobrecarga extra de
	  invocación de funciones.
	</para>

<!--
Here's a small test program:
-->

	<para>
	  Este es un pequeño programa de prueba:
	</para>


//: V1C09:Cpptime.cpp


<!--
A Time object is created, then some time-consuming activity is
performed, then a second Time object is created to mark the ending
time. These are used to show starting, ending, and elapsed times.
-->

	<para>
	  Se crea un objeto <classname>Time</classname>, se hace alguna
	  actividad que consuma tiempo, después se crea un segundo objeto
	  <classname>Time</classname> para marcar el tiempo de
	  finalización. Se usan para mostrar los tiempos de inicio, fin
	  y los intervalos.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Stash y Stack con inlines</title>

    <!--
    Armed with inlines, we can now convert the Stash and Stack classes to be
    more efficient:
    -->
    <para>
      Disponiendo de inlines, podemos modificar las clases
      <classname>Stash</classname> y <classname>Stack</classname> para
      hacerlas más eficientes.
    </para>


//: V1C09:Stash4.h


    <!--
    The small functions obviously work well as inlines, but notice that
    the two largest functions are still left as non-inlines, since
    inlining them probably wouldn??t cause any performance gains:
    -->

    <para>
      Obviamente las funciones pequeñas funcionan bien como inlines,
      pero note que las dos funciones más largas siguen siendo
      no-inline, dado que convertirlas a inline no representaría ninguna
      mejora de rendimiento.
    </para>


//: V1C09:Stash4.cpp


    <!--
    Once again, the test program verifies that everything is working
    correctly:
    -->

    <para>
      Una vez más, el programa de prueba que verifica que todo
      funciona correctamente.
    </para>


//: V1C09:Stash4Test.cpp


    <!--
    This is the same test program that was used before, so the output should
    be basically the same.
    -->

    <para>
      Este es el mismo programa de prueba que se usó antes, de modo que
      la salida debería ser básicamente la misma.
    </para>

    <!--
    The Stack class makes even better use of inlines:
    -->

    <para>
      La clase <classname>Stack</classname> incluso hace mejor uso de inline's.
    </para>


//: V1C09:Stack4.h


    <!--
    Notice that the Link destructor that was present but empty in the
    previous version of Stack has been removed. In pop( ), the
    expression delete oldHead simply releases the memory used by that
    Link (it does not destroy the data object pointed to by the Link).
    -->

    <para>
      Note que el destructor <classname>Link</classname>, que se
      presentó (vacío) en la versión anterior de
      <classname>Stack</classname>, ha sido eliminado. En
      <function>pop()</function>, la expresión <code>delete
      oldHead</code> simplemente libera la memoria usada por
      <classname>Link</classname> (no destruye el objeto
      <varname>data</varname> apuntado por el
      <classname>Link</classname>).
    </para>

    <!--
    Most of the functions inline quite nicely and obviously, especially
    for Link. Even pop( ) seems legitimate, although anytime you have
    conditionals or local variables it??s not clear that inlines will be
    that beneficial. Here, the function is small enough that it probably
    won??t hurt anything.
    -->

    <para>
      La mayoría de las funciones inline quedan bastante bien
      obviamente, en especial para
      <classname>Link</classname>. Incluso
      <methodname>pop()</methodname> parece justificado, aunque
      siempre que haya sentencias condicionales o variables locales no
      está claro que las inlines sean beneficiosas. Aquí, la función
      es lo suficientemente pequeña así que es probable que no haga
      ningún daño.
    </para>

    <!--
    If all your functions are inlined, using the library becomes quite
    simple because there's no linking necessary, as you can see in the
    test example (notice that there's no Stack4.cpp):
    -->

    <para>
      Si todas sus funciones son inline, usar la librería se convierte
      en algo bastante simple porque el enlazado es innecesario, como
      puede ver en el ejemplo de prueba (fíjese en que no hay
      <filename>Stack4.cpp</filename>).
    </para>



//: V1C09:Stack4Test.cpp


    <!--
    People will sometimes write classes with all inline functions so
    that the whole class will be in the header file (you'll see in this
    book that I step over the line myself). During program development
    this is probably harmless, although sometimes it can make for longer
    compilations. Once the program stabilizes a bit, you'll probably
    want to go back and make functions non-inline where appropriate.
    -->

    <para>
      La gente escribe a veces clases con todas sus funciones inline,
      así que la clase completa está en el fichero de cabecera (verá
      en este libro que yo mismo lo hago). Durante el desarrollo de un
      programa probablemente esto es inofensivo, aunque a veces puede
      hacer que las compilaciones sean más lentas. Cuando el programa
      se estabiliza un poco, probablemente querrá volver a hacer las
      funciones no-inline donde sea conveniente.
    </para>

  </sect1>

  <sect1>
    <!-- Inlines & the compiler -->
    <title>Funciones inline y el compilador</title>

    <!--
    To understand when inlining is effective, it's helpful to know what
    the compiler does when it encounters an inline. As with any
    function, the compiler holds the function type (that is, the
    function prototype including the name and argument types, in
    combination with the function return value) in its symbol table. In
    addition, when the compiler sees that the inline's function type
    and the function body parses without error, the code for the
    function body is also brought into the symbol table. Whether the
    code is stored in source form, compiled assembly instructions, or
    some other representation is up to the compiler.
    -->

    <para>
      Para comprender cuando es conveniente utilizar inlines, es útil
      saber lo que hace el compilador cuando encuentra una función
      inline. Como con cualquier función, el compilador apunta el
      <emphasis>tipo</emphasis> de la función es su tabla de símbolos
      (es decir, el prototipo de la función incluyendo el nombre y los
      tipos de los argumentos, en combinación con valor de
      retorno). Además cuando el compilador ve que la función es
      inline <emphasis>y</emphasis> el cuerpo no contiene errores, el
      código se coloca también en la tabla de símbolos. El código se
      almacena en su forma fuente, como instrucciones ensamblador
      compiladas, o alguna otra representación propia del compilador.
    </para>

    <!--
    When you make a call to an inline function, the compiler first
    ensures that the call can be correctly made. That is, all the
    argument types must either be the exact types in the function's
    argument list, or the compiler must be able to make a type
    conversion to the proper types and the return value must be the
    correct type (or convertible to the correct type) in the destination
    expression. This, of course, is exactly what the compiler does for
    any function and is markedly different from what the preprocessor
    does because the preprocessor cannot check types or make
    conversions.
    -->

    <para>
      Cuando hace una llamada a una función inline, el compilador se
      asegura primero de que la llamada se puede hacer
      correctamente. Es decir, los tipos de todos los argumentos
      corresponden exactamente con los tipos de la lista de argumentos
      de la función (o convertible a tipo correcto) y el valor de
      retorno tiene el tipo correcto (o es convertible al tipo
      correcto) en la expresión destino. Esto, por supuesto, es
      exactamente lo mismo que hace el compilador para cualquier
      función y hay una diferencia considerable respecto de lo que
      hace el preprocesador, porque el preprocesador no comprueba
      tipos ni hace conversiones.
    </para>

    <!--
    If all the function type information fits the context of the call,
    then the inline code is substituted directly for the function call,
    eliminating the call overhead and allowing for further optimizations
    by the compiler. Also, if the inline is a member function, the
    address of the object (this) is put in the appropriate place(s),
    which of course is another action the preprocessor is unable to
    perform.
    -->

    <para>
      Si toda la información del tipo de la función encaja en el
      contexto de la llamada, entonces la llamada a la función se
      sustituye directamente por el código inline, eliminando la sobrecarga
      y permitiendo que el compilador pueda hacer más
      optimizaciones. Además, si el inline es un método, la dirección
      del objeto(<varname>this</varname>) se pone en el lugar apropiado,
      que es, por supuesto, otra acción que el preprocesador es incapaz
      de hacer.
    </para>

    <sect2>
      <title>Limitaciones</title>

      <!--
      There are two situations in which the compiler cannot perform
      inlining. In these cases, it simply reverts to the ordinary form
      of a function by taking the inline definition and creating storage
      for the function just as it does for a non-inline. If it must do
      this in multiple translation units (which would normally cause a
      multiple definition error), the linker is told to ignore the
      multiple definitions.
      -->

      <para>
	Hay dos situaciones en que el compilador no puede efectuar la
	sustitución de inline. En estos casos, simplemente convierte la
	función a la forma ordinaria tomando la definición y pidiendo
	espacio para la función como hace con una función no-inline. Si
	debe hacerlo en varias unidades de traducción (lo que
	normalmente causaría un error de definición múltiple), informa
	al enlazador que ignore esas definiciones múltiples.
      </para>

      <!--
      The compiler cannot perform inlining if the function is too
      complicated. This depends upon the particular compiler, but at the
      point most compilers give up, the inline probably wouldn't gain
      you any efficiency. In general, any sort of looping is considered
      too complicated to expand as an inline, and if you think about it,
      looping probably entails much more time inside the function than
      what is required for the function call overhead. If the function
      is just a collection of simple statements, the compiler probably
      won't have any trouble inlining it, but if there are a lot of
      statements, the overhead of the function call will be much less
      than the cost of executing the body. And remember, every time you
      call a big inline function, the entire function body is inserted
      in place of each call, so you can easily get code bloat without
      any noticeable performance improvement. (Note that some of the
      examples in this book may exceed reasonable inline sizes in favor
      of conserving screen real estate.)
      -->

      <para>
	En compilador no puede efectuar la sustitución de inline si la
	función es demasiado complicada. Esto depende de cada
	compilador particular, pero aunque muchos compiladores lo
	hagan, no habrá ninguna mejora de eficiencia. En general, se
	considera que cualquier tipo de bucle es demasiado complicado
	para expandir como una inline, y si lo piensa, el bucle
	implica mucho más tiempo que el que conlleva la sobrecarga de
	la invocación de la función. Si la función es simplemente una
	colección se sentencias simples, probablemente el compilador
	no tendrá ningún problema para utilizar inline, pero si hay
	muchas sentencias, la sobrecarga de llamada será mucho menor
	que el coste de ejecutar el cuerpo. Y recuerde, cada vez que
	llame a una función inline grande, el cuerpo completo se
	inserta en el lugar de la llamada, de modo que el tamaño del
	código se inflará fácilmente sin que se perciba ninguna mejora
	de rendimiento. (Note que algunos de los ejemplos de este
	libro pueden exceder el tamaño razonable para una inline a
	cambio de mejorar la estética de los listados.
      </para>

      <!--
      The compiler also cannot perform inlining if the address of the
      function is taken implicitly or explicitly. If the compiler must
      produce an address, then it will allocate storage for the function
      code and use the resulting address. However, where an address is
      not required, the compiler will probably still inline the code.
      -->

      <para>
	El compilador tampoco efectúa sustituciones inline si la
	dirección de la función se toma implícita o explícitamente. Si
	el compilador debe producir una dirección, entonces tendrá que
	alojar el código de la función y usar la dirección
	resultante. Sin embargo, cuando no se requiere una dirección,
	probablemente el compilador hará la sustitución inline.
      </para>

      <!--
      It is important to understand that an inline is just a suggestion
      to the compiler; the compiler is not forced to inline anything at
      all. A good compiler will inline small, simple functions while
      intelligently ignoring inlines that are too complicated. This will
      give you the results you want - the true semantics of a function
      call with the efficiency of a macro.
      -->

      <para>
	Es importante comprender que una declaración inline es sólo una
	sugerencia al compilador; el compilador no está forzado a hacer
	nada. Un buen compilador hará sustituciones inline para
	funciones pequeñas y simples mientras que ignorará las que sean
	demasiado complicadas. Eso le dará lo que espera - la auténtica
	semántica de una llamada a función con la eficiencia de una
	macro.
      </para>
    </sect2>

    <sect2>
      <title>Referencias adelantadas</title>

      <!--
      If you're imagining what the compiler is doing to implement
      inlines, you can confuse yourself into thinking there are more
      limitations than actually exist. In particular, if an inline makes
      a forward reference to a function that has't yet been declared
      in the class (whether that function is inline or not), it can seem
      like the compiler won't be able to handle it:
      -->

      <para>
	Si está imaginando que el compilador [FIXME: is doing to
	implement inlines], puede confundirse pensando que hay más
	limitaciones que las que existen realmente. En concreto, si
	una inline hace una referencia adelanta a una función que no
	ha sido declarada aún en la clase (sea inline o no), puede
	parecer que el compilador no sabrá tratarla.
      </para>



//: V1C09:EvaluationOrder.cpp


      <!--
      In f( ), a call is made to g( ), although g( ) has not yet been
      declared. This works because the language definition states that
      no inline functions in a class shall be evaluated until the
      closing brace of the class declaration.
      -->

      <para>
	En <function>f()</function>, se realiza una llamada a
	<function>g()</function>, aunque <function>g()</function> aún no
	ha sido declarada. Esto funciona porque la definición del
	lenguaje dice que las funciones inline en una clase no serán
	evaluadas hasta la llave de cierre de la declaración de clase.
      </para>


      <!--
      Of course, if g( ) in turn called f( ), you'd end up with a set
      of recursive calls, which are too complicated for the compiler to
      inline. (Also, you'd have to perform some test in f( ) or g( ) to
      force one of them to "bottom out," or the recursion would be
      infinite.)
      -->

      <para>
	Por supuesto, si <function>g()</function> a su vez llama a
	<function>f()</function>, tendrá un conjunto de llamadas
	recursivas, que son demasiado complicadas para el compilador
	pueda hacer inline. (También, tendrá que efectuar alguna
	comprobación en <function>f()</function> o
	<function>g()</function> para forzar en alguna de ellas un caso
	base, o la recursión será infinita).
      </para>

    </sect2>


    <sect2>
      <title>Actividades ocultas en contructores y destructores</title>


      <!--
      Constructors and destructors are two places where you can be
      fooled into thinking that an inline is more efficient than it
      actually is. Constructors and destructors may have hidden
      activities, because the class can contain subobjects whose
      constructors and destructors must be called. These subobjects
      may be member objects, or they may exist because of inheritance
      (covered in Chapter 14). As an example of a class with member
      objects:
      -->

      <para>
	Constructores y destructores son dos lugares dónde puede
	engañarse al pensar que una inline es más eficiente de lo que
	realmente es. Constructores y destructores pueden tener
	actividades ocultas, porque la clase puede contener subobjetos
	cuyos constructores y destructores deben invocarse. Estos
	subobjetos pueden ser objetos miembro (atributos), o pueden
	existir por herencia (tratado en el Capítulo 14). Como un
	ejemplo de clase con un objeto miembro:
      </para>



//: V1C09:Hidden.cpp


      <!--
      The constructor for Member is simple enough to inline, since there'
      s nothing special going on -  no inheritance or member objects are
      causing extra hidden activities. But in class WithMembers there's
      more going on than meets the eye. The constructors and destructors
      for the member objects q, r, and s are being called automatically,

      and those constructors and destructors are also inline, so the
      difference is significant from normal member functions. This doesn'
      t necessarily mean that you should always make constructor and
      destructor definitions non-inline; there are cases in which it
      makes sense. Also, when you're making an initial "sketch" of a
      program by quickly writing code, it's often more convenient to
      use inlines. But if you're concerned about efficiency, it's a
      place to look.
      -->

      <para>
	El constructor para <classname>Member</classname> es
	suficientemente simple para ser inline, dado que no hay nada
	especial en él - ninguna herencia u objeto miembro está
	provocando actividades ocultas adicionales. Pero en la clase
	<classname>WithMembers</classname> hay más de lo que se ve a
	simple vista. Los constructores y destructores para los
	atributos <varname>q</varname>, <varname>r</varname> y
	<varname>s</varname> se llaman automáticamente, y esos
	constructores y destructores también son inline, así que la
	diferencia es significativa respecto a métodos normales. Esto no
	significa necesariamente que los constructores y destructores
	deban ser no-inline; hay casos en que tiene sentido. También,
	cuando se está haciendo un prototipo inicial de un programa
	escribiendo código rápidamente, es conveniente a menudo usar
	inlines. Pero si está preocupado por la eficiencia, es un sitio
	donde mirar.
      </para>
    </sect2>
  </sect1>



  <sect1>
    <title>Reducir el desorden</title>

    <!--
    In a book like this, the simplicity and terseness of putting inline
    definitions inside classes is very useful because more fits on a
    page or screen (in a seminar). However, Dan SaksFIXME:[46] has pointed out
    that in a real project this has the effect of needlessly cluttering
    the class interface and thereby making the class harder to use. He
    refers to member functions defined within classes using the Latin in
    situ (in place) and maintains that all definitions should be placed
    outside the class to keep the interface clean. Optimization, he
    argues, is a separate issue. If you want to optimize, use the inline
    keyword. Using this approach, the earlier Rectangle.cpp example
    becomes:
    -->

    <para>
      En un libro como éste, la simplicidad y brevedad de poner
      definiciones inline dentro de las clases es muy útil porque
      permite meter más en una página o pantalla (en un
      seminario). Sin embargo, <author><firstname>Dan</firstname>
      <surname>Saks</surname></author> <footnote> <para>Co-autor junto
      a <author><firstname>Tom</firstname> <surname>
      Plum</surname></author> de <citetitle pubwork="book">C++
      Programming Guidelines</citetitle>, Plum Hall, 1991.</para>
      </footnote> ha apuntado que en un proyecto real esto tiene como
      consecuencia el desorden de la interfaz de la clase y eso hace
      que la clase sea más incomoda de usar. Él se refiere a los
      métodos definidos dentro de las clases usando la expresión
      <emphasis>in situ</emphasis> (en el lugar) e indica que todas
      las definiciones deberían colocarse fuera de la clase
      manteniendo la interfaz limpia. La optimización, argumenta él,
      es una asunto distinto. Si se requiere optimizar, use la palabra
      reservada <kw>inline</kw>. Siguiente ese enfoque, el ejemplo
      anterior <filename>Rectangle.cpp</filename> quedaría:
    </para>


//: V1C09:Noinsitu.cpp


    <!--
    Now if you want to compare the effect of inline functions to
    non-inline functions, you can simply remove the inline
    keyword. (Inline functions should normally be put in header files,
    however, while non-inline functions must reside in their own
    translation unit.) If you want to put the functions into
    documentation, it's a simple cut-and-paste operation. In situ
    functions require more work and have greater potential for
    errors. Another argument for this approach is that you can always
    produce a consistent formatting style for function definitions,
    something that doesn't always occur with in situ functions.
    -->

    <para>
      Ahora si quiere comparar el efecto de la funciones inline con la
      versión convencional, simplemente borre la palabra
      <kw>inline</kw>. (Las funciones inline normalmente deberían
      aparecen en los ficheros de cabecera, no obstante, las funciones
      no-inline deberían residir en un propia unidad de
      traducción). Si quiere poner las funciones en la documentación,
      es tan simple como un <quote>copiar y pegar</quote>. Las
      funciones <emphasis>in situ</emphasis> requieren más trabajo y
      tienen más posibilidades de provocar errores. Otro argumento
      para esta propuesta es que siempre puede producir un estilo de
      formato consistente para las definiciones de función, algo que
      no siempre ocurre con las funciones <emphasis>in
      situ</emphasis>.
    </para>

  </sect1>

  <sect1>
    <title>Más características del preprocesador</title>

    <!--
    Earlier, I said that you almost always want to use inline functions
    instead of preprocessor macros. The exceptions are when you need to
    use three special features in the C preprocessor (which is also the
    C++ preprocessor): stringizing, string concatenation, and token
    pasting. Stringizing, introduced earlier in the book, is performed
    with the # directive and allows you to take an identifier and turn
    it into a character array. String concatenation takes place when two
    adjacent character arrays have no intervening punctuation, in which
    case they are combined. These two features are especially useful
    when writing debug code. Thus,
    -->

    <para>
      Antes, se dijo que <emphasis>casi</emphasis> siempre se prefiere
      usar funciones inline en lugar de macros del preprocesador. Las
      excepciones aparecen cuando necesita usar tres propiedades especiales
      del preprocesador de C (que es también el preprocesador de C++):
      [FIXME(hay más):cadenización?]
      (<emphasis>stringizing</emphasis>), concatenación de cadenas, y
      encolado de símbolos (<emphasis>token
      pasting</emphasis>). <emphasis>Stringizing</emphasis>, ya
      comentado anteriormente en el libro, se efectúa con la directiva
      <literal>#</literal> y permite tomar un identificador y
      convertirlo en una cadena de caracteres. La concatenación de
      cadenas tiene lugar cuando dos cadenas adyacentes no tienen
      puntuación, en cuyo caso se combinan. Estas dos propiedades son
      especialmente útiles cuando se escribe código de depuración. Así,
    </para>

<programlisting>
    #define DEBUG(x) cout &lt;&lt; #x " = " &lt;&lt; x &lt;&lt; endl
</programlisting>

    <!--
    This prints the value of any variable. You can also get a trace that
    prints out the statements as they execute:
    -->

    <para>
      Esto imprime el valor de cualquier variable. Puede conseguir
      también una traza que imprima las sentencias tal como se ejecutan:
    </para>

<programlisting>
    #define TRACE(s) cerr &lt;&lt; #s &lt;&lt; endl; s
</programlisting>

    <!--
    The #s stringizes the statement for output, and the second s
    reiterates the statement so it is executed. Of course, this kind of
    thing can cause problems, especially in one-line for loops:
    -->

    <para>
      El <literal>#s</literal> <emphasis>cadeniza</emphasis> la
      sentencia para la salida, y la segunda <literal>s</literal> hace
      que la sentencia se ejecute. Por supuesto, este tipo de cosas
      pueden causar problemas, especialmente bucles <kw>for</kw> de una
      única línea.
    </para>

<programlisting>
    for(int i = 0; i &lt; 100; i++)
     TRACE(f(i));
</programlisting>

    <!--
    Because there are actually two statements in the TRACE( ) macro, the
    one-line for loop executes only the first one. The solution is to
    replace the semicolon with a
    -->

    <para>
      Como realmente hay dos sentencias en la macro
      <function>TRACE()</function>, el bucle <kw>for</kw> de
      una única línea ejecuta solo la primera. La solución es reemplazar
      el punto y coma por una coma en la macro.
    </para>

    <sect2>
      <!-- Token pasting -->
      <title>Encolado de símbolos</title>

      <!--
      Token pasting, implemented with the ## directive, is very useful
      when you are manufacturing code. It allows you to take two
      identifiers and paste them together to automatically create a new
      identifier. For example,
      -->

      <para>
	El encolado de símbolos, implementado con la directiva
	<literal>##</literal>, es muy útil cuando se genera
	código. Permite coger dos identificadores y pegarlos juntos
	para crear un nuevo identificador automáticamente. Por
	ejemplo,
      </para>

<programlisting>
    #define FIELD(a) char* a##_string; int a##_size
    class Record {
      FIELD(one);
      FIELD(two);
      FIELD(three);
      // ...
    };
</programlisting>

      <!--
      Each call to the FIELD( ) macro creates an identifier to hold a
      character array and another to hold the length of that array. Not
      only is it easier to read, it can eliminate coding errors and make
      maintenance easier.
      -->

      <para>
	Cada llamada a la macro <function>FIELD()</function> crea un
	identificador para una cadena de caracteres y otro para la
	longitud de dicha cadena. No solo es fácil de leer, también
	puede eliminar errores de codificación y facilitar el
	mantenimiento.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Comprobación de errores mejorada</title>

    <!--
    The require.h functions have been used up to this point without
    defining them (although assert( ) has also been used to help detect
    programmer errors where it's appropriate). Now it's time to define
    this header file. Inline functions are convenient here because they
    allow everything to be placed in a header file, which simplifies the
    process of using the package. You just include the header file and
    you don't need to worry about linking an implementation file.
    -->

    <para>
      Las funciones de <filename>require.h</filename> se han usado
      antes de este punto sin haberlas definido (aunque
      <function>assert()</function> se ha usado también para ayudar a
      detectar errores del programador donde es apropiado). Ahora es
      el momento de definir este fichero de cabecera. Las funciones
      inline son convenientes aquí porque permiten colocar todo en el
      fichero de cabecera, lo que simplifica el proceso para usar el
      paquete. Simplemente, incluya el fichero de cabecera y se
      preocupe por enlazar un fichero de implementación.
    </para>

    <!--
    You should note that exceptions (presented in detail in Volume 2 of
    this book) provide a much more effective way of handling many kinds
    of errors - especially those that you'd like to recover from -
    instead of just halting the program. The conditions that require.h
    handles, however, are ones which prevent the continuation of the
    program, such as if the user doesn't provide enough command-line
    arguments or if a file cannot be opened. Thus, it's acceptable that
    they call the Standard C Library function exit( ).
    -->

    <para>
      Debería fijarse que las excepciones (presentadas en detalle en
      el Volumen 2 de este libro) proporcionan una forma mucho más
      efectiva de manejar muchos tipos de errores -especialmente
      aquellos de los que debería recuperarse- en lugar de
      simplemente abortar el programa. Las condiciones que maneja
      <filename>require.h</filename>, sin embargo, son algunas que
      impiden que el programa continúe, como por ejemplo que el
      usuario no introdujo suficientes argumentos en la línea de
      comandos o que un fichero no se puede abrir. De modo que es
      aceptable que usen la función <function>exit()</function> de la
      librería C estándar.
    </para>

    <!--
    The following header file is placed in the book's root directory so
    it's easily accessed from all chapters.
    -->

    <para>
      El siguiente fichero de cabecera está en el directorio raíz del
      libro, así que es fácilmente accesible desde todos los capítulos.
    </para>


<programlisting>
<xi:include parse="text" href="./code_v1/require.h"/>
</programlisting>


    <!--
    The default values provide reasonable messages that can be changed
    if necessary.
    -->

    <para>
      Los valores por defecto proporcionan mensajes razonables que se
      pueden cambiar si es necesario.
    </para>

    <!--
    You'll notice that instead of using char* arguments, const string&
    arguments are used. This allows both char* and strings as arguments
    to these functions, and thus is more generally useful (you may want
    to follow this form in your own coding).
    -->

    <para>
      Fíjese en que en lugar de usar argumentos <type>char*</type> se
      utiliza <type>const string&amp;</type>. Esto permite tanto
      <type>char*</type>, cadenas <classname>string</classname> como
      argumentos para estas funciones, y así es más general (quizá
      quiera utilizar esta forma en su propio código).
    </para>

    <!--
    In the definitions for requireArgs( ) and requireMinArgs( ), one is
    added to the number of arguments you need on the command line
    because argc always includes the name of the program being executed
    as argument zero, and so always has a value that is one more than
    the number of actual arguments on the command line.
    -->

    <para>
      En las definiciones para <function>requireArgs()</function> y
      <function>requireMinArgs()</function>, se añade uno al número de
      argumentos que necesita en la línea de comandos porque
      <varname>argc</varname> siempre incluye el nombre del programa
      que está ejecutado como argumento cero, y por eso siempre tiene
      un valor que excede en uno al número real de argumentos de la
      línea de comandos.
    </para>


    <!--
    Note the use of local "using namespace std" declarations within
    each function. This is because some compilers at the time of this
    writing incorrectly did not include the C standard library functions
    in namespace std, so explicit qualification would cause a
    compile-time error. The local declaration allows require.h to work
    with both correct and incorrect libraries without opening up the
    namespace std for anyone who includes this header file.
    -->

    <para>
      Fíjese en el uso de declaraciones locales <code>using namespace
      std</code> con cada función. Esto es porque algunos compiladores
      en el momento de escribir este libro incluyen incorrectamente
      las funciones de la librería C estándar en el espacio de nombres
      <classname>std</classname>, así que la cualificación explícita
      podría causar un error en tiempo de compilación. Las
      declaraciones locales permiten que
      <filename>require.h</filename> funcione tanto con librerías
      correctas como con incorrectas sin abrir el espacio de nombres
      <classname>std</classname> para cualquiera que incluya este
      fichero de cabecera.
    </para>

    <!--
    Here's a simple program to test require.h:
    -->

    <para>
      Aquí hay un programa simple para probar
      <filename>requite.h</filename>:
    </para>


//: V1C09:ErrTest.cpp


    <!--
    You might be tempted to go one step further for opening files and
    add a macro to require.h:
    -->

    <para>
      Podría estar tentado a ir un paso más allá para manejar la
      apertura de ficheros y añadir una macro a
      <function>require.h</function>.
    </para>

<programlisting>
    #define IFOPEN(VAR, NAME) \
      ifstream VAR(NAME); \
      assure(VAR, NAME);
</programlisting>

    <!--
    Which could then be used like this:
      -->

    <para>
      Que podría usarse entonces así:
    </para>

<programlisting>
    IFOPEN(in, argv[1])
</programlisting>

    <!--
    At first, this might seem appealing since it means there's less to
    type. It's not terribly unsafe, but it's a road best avoided. Note
    that, once again, a macro looks like a function but behaves
    differently; it's actually creating an object (in) whose scope
    persists beyond the macro. You may understand this, but for new
    programmers and code maintainers it's just one more thing they have
    to puzzle out. C++ is complicated enough without adding to the
    confusion, so try to FIXME:talk yourself out of using preprocessor macros
    whenever you can.
    -->

    <para>
      En principio, esto podría parecer atractivo porque significa que
      hay que escribir menos. No es terriblemente inseguro, pero es un
      camino que es mejor evitar. Fíjese que, de nuevo, una macro
      parece una función pero se comporta diferente; realmente se está
      creando un objeto <varname>in</varname> cuyo alcance persiste
      más allá de la macro. Quizá lo entienda, pero para programadores
      nuevos y mantenedores de código sólo es una cosa más que ellos
      deben resolver. C++ es suficientemente complicado sin añadir
      confusión, así que intente no abusar de las macros del
      preprocesador siempre que pueda.
    </para>
  </sect1>

  <sect1>
    <title>Resumen</title>

    <!--
    It's critical that you be able to hide the underlying
    implementation of a class because you may want to change that
    implementation sometime later. You'll make these changes for
    efficiency, or because you get a better understanding of the
    problem, or because some new class becomes available that you want
    to use in the implementation. Anything that jeopardizes the privacy
    of the underlying implementation reduces the flexibility of the
    language. Thus, the inline function is very important because it
    virtually eliminates the need for preprocessor macros and their
    attendant problems. With inlines, member functions can be as
    efficient as preprocessor macros.
    -->

    <para>
      Es crítico que sea capaz de ocultar la implementación subyacente
      de una clase porque puede querer cambiarla después. Hará estos
      cambios por eficiencia, o porque haya alcanzado una mejor
      comprensión del problema, o porque hay alguna clase nueva
      disponible para usar en la implementación. Cualquier cosa que
      haga peligrar la privacidad de la implementación subyacente
      reduce la flexibilidad del lenguaje. Por eso, la función inline
      es muy importante porque prácticamente elimina la necesidad de
      macros de preprocesador y sus problemas asociados. Con inline,
      los métodos pueden ser tan eficientes como las macros.
    </para>


    <!--
    The inline function can be overused in class definitions, of
    course. The programmer is tempted to do so because it's easier, so
    it will happen. However, it's not that big of an issue because
    later, when looking for size reductions, you can always change the
    functions to non-inlines with no effect on their functionality. The
    development guideline should be "First make it work, then optimize
    it."
    -->

    <para>
      Por supuesto se puede abusan de las funciones inline en las
      definiciones de clase. El programador está tentado de hacerlo
      porque es fácil, así que lo hace. Sin embargo, no es un problema
      grave porque después, cuando se busquen reducciones de tamaño,
      siempre puede cambiar las inline a funciones convencionales dado
      que no afecta a su funcionalidad. La pauta debería ser
      <quote>Primero haz el trabajo, después optimiza</quote>.
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>
	<!--
	1. Write a program that uses the F( ) macro shown at the beginning
	of the chapter and demonstrates that it does not expand properly,
	as described in the text. Repair the macro and show that it works
	correctly.
	-->
	<para>
	  Escriba un programa que use la macro <function>F()</function>
	  mostrada al principio del capítulo y demuestre que no se
	  expande apropiadamente, tal como describe el texto. Arregle la
	  macro y demuestre que funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!--
	2. Write a program that uses the FLOOR( ) macro shown at the
	beginning of the chapter. Show the conditions under which it does
	not work properly.
	-->
	<para>
	  Escriba un programa que use la macro
	  <function>FLOOR()</function> mostrada al principio del
	  capítulo. Muestre las condiciones en que no funciona
	  apropiadamente.
	</para>
      </listitem>
      <listitem>
	<!--
	3. Modify MacroSideEffects.cpp so that BAND( ) works properly.
	-->
	<para>
	  Modifique <filename>MacroSideEffects.cpp</filename> de modo
	  que <function>BAND()</function> funcione adecuadamente.
	</para>
      </listitem>
      <listitem>
	<!--
	4. Create two identical functions, f1( ) and f2( ). Inline f1( ) and
	leave f2( ) as an non-inline function. Use the Standard C Library
	function clock( ) that is found in &lt;ctime> to mark the starting
	point and ending points and compare the two functions to see
	which one is faster. You may need to make repeated calls to the
	functions inside your timing loop in order to get useful numbers.
	-->
	<para>
	  Cree dos funciones idénticas, <function>f1()</function> y
	  <function>f2()</function>. Haga inline a
	  <function>f1()</function> y deje <function>f2()</function>
	  como no-inline. Use la función <function>clock()</function> de
	  la librería C estándar que se encuentra en
	  <filename>&lt;ctime></filename> para marcar los puntos de
	  comienzo y fin y compare las dos funciones para ver cuál es
	  más rápida. Puede que necesite hacer un bucle de llamadas
	  repetidas para conseguir números representativos.
	</para>
      </listitem>
      <listitem>
	<!--
	5. Experiment with the size and complexity of the code inside the
	functions in Exercise 4 to see if you can find a break-even point
	where the inline function and the non-inline function take the
	same amount of time. If you have them available, try this with
	different compilers and note the differences.
	-->
	<para>
	  Experimente con el tamaño y complejidad del código de las
	  funciones del ejercicio 4 para ver si puede encontrar el punto
	  donde la función inline y la convencional tardan lo mismo. Si
	  dispone de ellos, inténtelo con compiladores distintos y
	  fíjese en las diferencias.
	</para>
      </listitem>
      <listitem>
	<!--
	6. Prove that inline functions default to internal linkage.
	-->
	<para>
	  Pruebe que las funciones inline hacen enlazado interno por
	  defecto.
	</para>
      </listitem>
      <listitem>
	<!--
	7. Create a class that contains an array of char. Add an inline
	constructor that uses the Standard C library function memset( )
	to initialize the array to the constructor argument (default this
	to ' '), and an inline member function called print( ) to print
	out all the characters in the array.
	-->
	<para>
	  Cree una clase que contenga un array de caracteres. Añada un
	  constructor inline que use la función
	  <function>memset()</function> de la librería C estándar para
	  inicializar el array al valor dado como argumento del
	  constructor (por defecto será ' '), y un método inline llamado
	  <function>print()</function> que imprima todos los caracteres
	  del array.
	</para>
      </listitem>
      <listitem>
	<!--
	8. Take the NestFriend.cpp example from Chapter 5 and replace all
	the member functions with inlines. Make them non-in situ inline
	functions. Also change the initialize( ) functions to
	constructors.
	-->
	<para>
	  Coja el ejemplo <filename>NestFriend.cpp</filename> del
	  Capítulo 5 y reemplace todos los métodos con inline. No haga
	  métodos inline <emphasis>in situ</emphasis>. También cambie
	  las funciones <function>initialize()</function> por
	  constructores.
	</para>
      </listitem>
      <listitem>
	<!--
	9. Modify StringStack.cpp from Chapter 8 to use inline functions.
	-->
	<para>
	  Modifique <filename>StringStack.cpp</filename> del Capítulo
	  8 para usar funciones inline.
	</para>
      </listitem>
      <listitem>
	<!--
	10. Create an enum called Hue containing red, blue, and yellow. Now
        create a class called Color containing a data member of type Hue
        and a constructor that sets the Hue from its argument. Add
        access functions to "get" and "set" the Hue. Make all of the
        functions inlines.
	-->
	<para>
	  Cree un enumerado llamado <type>Hue</type> que contenga
	  <symbol>red</symbol>, <symbol>blue</symbol> y
	  <symbol>yellow</symbol>. Ahora cree una clase llamada
	  <classname>Color</classname> que contenga un atributo de tipo
	  <type>Hue</type> y un constructor que dé valor al
	  <type>Hue</type> con su argumento. Añada métodos de acceso al
	  <type>Hue</type> <function>get()</function> y
	  <function>set()</function>. Haga inline todos los métodos.
	</para>
      </listitem>
      <listitem>
	<!--
	11. Modify Exercise 10 to use the "accessor" and "mutator"
        approach.
	-->
	<para>
	  Modifique el ejercicio 10 para usar el enfoque
	  <quote>accesor</quote> y <quote>mutador</quote>.
	</para>
      </listitem>
      <listitem>
	<!--
	12. Modify Cpptime.cpp so that it measures the time from the time
        that the program begins running to the time when the user
        presses the "Enter" or "Return" key.
	-->
	<para>
	  Modifique <filename>Cpptime.cpp</filename> de modo que mida el
	  tiempo desde que comienza el programa hasta que el usuario
	  pulsa la tecla <quote>Intro</quote> o <quote>Retorno</quote>.
	</para>
      </listitem>
      <listitem>
	<!--
	13. Create a class with two inline member functions, such that the
        first function that's defined in the class calls the second
        function, without the need for a forward declaration. Write a
        main that creates an object of the class and calls the first
        function.
	-->
	<para>
	  Cree una clase con dos métodos inline, el primero que está
	  definido en la clase llama al segundo, sin necesitar una
	  declaración adelantada. Escriba un <function>main()</function>
	  que cree un objeto de esa clase y llame al primer método.
	</para>
      </listitem>
      <listitem>
	<!--
	14. Create a class A with an inline default constructor that
        announces itself. Now make a new class B and put an object of A
        as a member of B, and give B an inline constructor. Create an
        array of B objects and see what happens.
	-->
	<para>
	  Cree una clase <classname>A</classname> con un constructor
	  por defecto inline que se anuncie a sí mismo. Ahora cree una
	  nueva clase <classname>B</classname> y ponga un objeto de
	  <classname>A</classname> como miembro de
	  <classname>B</classname>, y dele a <classname>B</classname>
	  un constructor inline. Cree un array de objetos B y vea qué
	  sucede.
	</para>
      </listitem>
      <listitem>
	<!--
    15. Create a large quantity of the objects from the previous
        Exercise, and use the Time class to time the difference between
        non-inline constructors and inline constructors. (If you have a
        profiler, also try using that.)
	-->
	<para>
	  Cree una gran cantidad de objetos del ejercicio anterior, y
	  use la clase <classname>Time</classname> para medir las
	  diferencias entre los contructores inline y los no-inline. (Si
	  tiene un perfilador, intente usarlo también).
	</para>
      </listitem>
      <listitem>
	<!--
    16. Write a program that takes a string as the command-line
        argument. Write a for loop that removes one character from the
        string with each pass, and use the DEBUG( ) macro from this
        chapter to print the string each time.
	-->
	<para>
	  Escriba un programa que tome una cadena por línea de
	  comandos. Escriba un bucle <kw>for</kw> que elimine
	  un carácter de la cadena en cada pasada, y use la macro
	  <function>DEGUB()</function> de este capítulo para imprimir la
	  cadena cada vez.
	</para>
      </listitem>
      <listitem>
	<!--
    17. Correct the TRACE( ) macro as specified in this chapter, and
        prove that it works correctly.
	-->
	<para>
	  Corrija la macro <function>TRACE()</function> tal como se
	  explica en el capítulo, y pruebe que funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!--
    18. Modify the FIELD( ) macro so that it also contains an index
        number. Create a class whose members are composed of calls to
        the FIELD( ) macro. Add a member function that allows you to
        look up a field using its index number. Write a main( ) to test
        the class.
	-->
	<para>
	  Modifique la macro <function>FIELD()</function> para que
	  también incluya un índice numérico. Cree una clase cuyos
	  miembros están compuestos de llamadas a la macro
	  <function>FIELD()</function>. Añada un método que le permita
	  buscar en un campo usando el índice. Escriba un
	  <function>main()</function> para probar la clase.
	</para>
      </listitem>
      <listitem>
	<!--
    19. Modify the FIELD( ) macro so that it automatically generates
        access functions for each field (the data should still be
        private, however). Create a class whose members are composed of
        calls to the FIELD( ) macro. Write a main( ) to test the class.
	-->
	<para>
	  Modifique la macro <function>FIELD()</function> para que
	  automáticamente genere funciones de acceso para cada campo
	  (<varname>data</varname> debería no obstante ser
	  privado). Cree una clase cuyos miembros estén compuestos de
	  llamadas a la macro <function>FIELD()</function>. Escriba un
	  <function>main()</function> para probar la clase.
	</para>
      </listitem>
      <listitem>
	<!--
    20. Write a program that takes two command-line arguments: the first
        is an int and the second is a file name. Use require.h to ensure
        that you have the right number of arguments, that the int is
        between 5 and 10, and that the file can successfully be opened.
	-->
	<para>
	  Escriba un programa que tome dos argumentos de línea de
	  comandos: el primero es un <type>entero</type> y el segundo es
	  un nombre de fichero. Use <filename>requiere.h</filename> para
	  asegurar que tiene el número correcto de argumentos, que el
	  <type>entero</type> está entre 5 y 10, y que el fichero se
	  puede abrir satisfactoriamente.
	</para>
      </listitem>
      <listitem>
	<!--
    21. Write a program that uses the IFOPEN( ) macro to open a file as
        an input stream. Note the creation of the ifstream object and
        its scope.
	-->
	<para>
	  Escriba un programa que use la macro
	  <function>IFOPEN()</function> para abrir un fichero como un
	  flujo de entrada. Fíjese en la creación un objeto
	  <classname>ifstream</classname> y su alcance.
	</para>
      </listitem>
      <listitem>
	<!--
    22. (Challenging) Determine how to get your compiler to generate
        assembly code. Create a file containing a very small function
        and a main( ) that calls the function. Generate assembly code
        when the function is inlined and not inlined, and demonstrate
        that the inlined version does not have the function call
        overhead.
	-->
	<para>
	  (Desafío) Averigüe cómo conseguir que su compilador genere
	  código ensamblador. Cree un fichero que contenga una función
	  muy pequeña y un <function>main()</function>. Genere el código
	  ensamblador cuando la función es inline y cuando no lo es, y
	  demuestre que la versión inline no tiene la sobrecarga por la
	  llamada.
	</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>


<!--
- Local variables:
-   ispell-local-dictionary: "castellano8"
- End:
-->
