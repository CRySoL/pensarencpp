<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: José María Requena (pre-LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<appendix
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="ApendiceC">


  <title>Lecturas recomendadas</title>

  <subtitle>Recursos para profundizar en el estudio</subtitle>

  <sect1>
    <title>Sobre C</title>

    <para>
      <emphasis>Thinking in C: Foundations for Java &amp;
	C++</emphasis>,
      por Chuck Allison (un seminario en CDROM de MindView, Inc. , 2000,
      incluido al final de este libro y disponible también en <ulink
      url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>). Se
      trata de un curso que incluye lecciones y transparencias sobre los
      conceptos básicos del lenguaje C para preparar al lector a
      aprender Java o C++. No es un curso exhaustivo sobre C; sólo
      contiene lo necesario para cambiarse a esos otros lenguajes. Unas
      secciones adicionales sobre esos lenguajes concretos introducen al
      aspirante a programador en C++ o en Java, a sus características.
      Requisitos previos: alguna experiencia con un lenguaje de alto
      nivel, como Pascal, BASIC, Fortran, o LISP (sería posible avanzar
      por el CD sin ese bagaje, pero el curso no está pensado para
      servir de introducción básica a la programación).
    </para>
  </sect1>

  <sect1>
    <title>Sobre C++ en general</title>
    <para>
      <emphasis>The C++ Programming Language, 3ª edición</emphasis>,
      por Bjarne Stroustrup (Addison-Wesley 1997).Hasta cierto punto, el
      objetivo de la obra que tiene en sus manos es permitirle usarel
      libro de Bjarne a modo de referencia. Dado que contiene la
      descripción del lenguaje por su propio autor, es típicamente ahí
      donde se mira para resolver dudas sobre qué se supone que C++ debe
      o no debe hacer. Cuando empiece a dominar el lenguaje y esté
      preparado para pasar a las cosas serias, lo necesitará.
    </para>

    <para>
      <emphasis>C++ Primer, 3ª Edición</emphasis>,
      por Stanley Lippman y Josee Lajoie (Addison-Wesley 1998). Ha
      dejado de ser una introducción; se ha convertido en un voluminoso
      libro muy detallista, y es uno de los que consulto junto con el de
      Stroustrup cuando intento resolver una cuestión.<quote>Pensar En
      C++</quote> debe proporcionar una base para entender <emphasis>C++
      Primer</emphasis> así como el libro de Stroustrup.
    </para>

    <para>
      <emphasis>C &amp; C++ Code Capsules</emphasis>,
      por Chuck Allison (Prentice-Hall, 1998).Ese libro presupone
      unconocimiento de C y C++, y trata cuestiones que ya hayan sido
      quebraderos decabeza, o que no logró zanjar adecuadamente a la
      primera. La obra soluciona lagunas tanto en C como en C++.
    </para>

    <para>
      <emphasis>The C++ Standard</emphasis>.Ese es el
      documento en el que el comité ha trabajado tanto durante
      años. No es gratis, desgraciadamente. Pero por lo menos se puede
      adquirir en formato PDF por sólo $18 en <ulink
	url="http://www.cssinfo.com">www.cssinfo.com</ulink>.
    </para>


    <sect2>
      <title>Mi propia lista de libros</title>

      <para> Aparecen a continuación ordenados por fecha de
	publicación. No todos están a la venta actualmente.
      </para>

      <para>
	<emphasis>Computer Interfacing with Pascal &amp;
	    C</emphasis>(publicado por mí, vía Eisys, en
	1988. Disponible únicamente a través de <ulink
	  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>).
	Es una introducción a la electrónica desde los días en los que
	CP/M era aun el rey y MSDoS sólo un principiante. Utilicé
	lenguajes de alto nivel y a menudo el puerto paralelo del
	ordenador para pilotar varios proyectos electrónicos. Se trata
	de una adaptación de mis columnas en la primera y mejor
	revista para la que trabajé, <emphasis>Micro
	  Cornucopia</emphasis> (retomando las palabras de Larry
	o_Brien, editor durante muchos años de <emphasis>Software
	  Development Magazine</emphasis>: la mejor revista de
	electrónica jamás publicada -¡hasta daban los planos para
	fabricar un robot a partir de una maceta!). Desgraciadamente,
	<emphasis>MicroC</emphasis> dejó de existir mucho antes de que
	apareciese el Internet. Crear ese libro fue una experiencia
	editorial muy gratificante para mí.
      </para>

      <para>
	<emphasis>Using C++</emphasis>
	(osborne/McGraw-Hill 1989).  Fue uno de los primeros libros
	publicados acerca de C++.  Está agotado y ha sido reemplazado
	por su segunda edición, bajo el nuevo título <quote>C++ Inside
	  &amp; out.</quote>
      </para>

      <para>
	<emphasis>C++ Inside &amp; out</emphasis>
	(osborne/McGraw-Hill 1993).Como se indicó antes, es en
	realidad la segunda edición de <quote>Using C++</quote>. El
	lenguaje C++ que describe el libro es bastante correcto, pero
	data de 1992 y <quote>Pensar En C++</quote> está llamado a
	sustituirlo. Puede saber más acerca de ese libro y conseguir
	el código fuente en <ulink
	  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
      </para>

      <para>
	<emphasis> Thinking in C++, 1ª edition</emphasis>
	(Prentice-Hall 1995).
      </para>

      <para>
	 <emphasis>Black Belt C++, the Master's
	    Collection</emphasis>, Bruce Eckel, editor (M&amp;T
	Books 1994).Agotado. Está constituido por una serie de
	capítulos escritos por personas de prestigio sobre la base de
	sus presentaciones en el coloquio sobre C++ durante la
	Conferencia sobre Desarrollo de Software que yo presidí. La
	portada del libro me llevó a ejercer desde entonces más
	control sobre el diseño de las portadas.
      </para>

      <para>
	<emphasis>Thinking in Java</emphasis>, 2ª
	edición (Prentice-Hall, 2000).  La primera edición de ese
	libro ganó el Premio a la Productividad del <emphasis>Software
	  Development Magazine</emphasis> y también el <emphasis>Premio
	  del Editor 1999 </emphasis>del <emphasis>Java Developer_s
	  Journal</emphasis>. Se puede descargar desde <ulink
	  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
      </para>

    </sect2>
  </sect1>

  <sect1>
    <title>Los rincones oscuros</title>

    <para>
      Estos libros profundizan en aspectos del lenguaje, y ayudan a
      evitar los típicos errores inherentes al desarrollo de programas
      en C++.
    </para>

    <para>
      <emphasis>Effective C++</emphasis>(2ª Edición,
      Addison-Wesley 1998) y <quote>More Effective C++</quote>
      (Addison-Wesley 1996), por Scott Meyers.  La obra clásica e
      indispensable para resolver los problemas serios y diseñar mejor
      código en C++. He intentado capturar y plasmar muchos de los
      conceptos de esos libros en <emphasis>Pensar en
	  C++</emphasis>, pero no pretendo haberlo
      logrado. Cualquiera que dedica tiempo a C++ acaba teniendo esos
      libros.  También disponible en CDRoM.
    </para>

    <para>
      <emphasis>Ruminations on C++</emphasis> , por
      Andrew Koenig y Barbara Moo (Addison-Wesley, 1996).Andrew
      trabajó personalmente con Stroustrup en muchos aspectos del
      lenguaje C++ y es por tanto una voz muy autorizada. Me
      encantaron sus incisivos comentarios y he aprendido mucho con
      él, tanto por escrito como en persona, a lo largo de los años.
    </para>

    <para>
      <emphasis>Large-Scale C++ Software
	  Design</emphasis> , por John Lakos(Addison-Wesley,
      1996).Trata temas y contesta a preguntas con las que uno se
      encuentra durante la creación de grandes proyectos, y a menudo
      de pequeños también.
    </para>

    <para>
       <emphasis>C++ Gems</emphasis>
      editor (SIGS Publications, 1996).  Una selección de artículos
      extraídos de <emphasis>The C++ Report</emphasis>.
    </para>

    <para>
      <emphasis> The Design &amp; Evolution of C++</emphasis>
       , por Bjarne Stroustrup (Addison-Wesley
      1994).Aclaraciones del inventor de C++ acerca de por qué tomó
      ciertas decisiones durante su diseño. No es esencial, pero
      resulta interesante.
    </para>
  </sect1>

  <sect1>
    <title>Sobre Análisis y Diseño</title>

    <para>
      <emphasis>Extreme Programming Explained
	</emphasis>por Kent Beck (Addison-Wesley 2000).¡Adoro
      ese libro! Si,sé que tengo tendencia a tomar posturas radicales,
      pero siempre había intuido que podía haber un proceso de
      desarrollo de programas muy diferente, y mucho mejor, y pienso
      que <emphasis>XP</emphasis> se acerca bastante a ello. El único
      libro que me impactó de forma similar, fue
      <emphasis>PeopleWare</emphasis> (descrito a continuación), que
      trata de los entornos y la interacción con la cultura de las
      empresas. <emphasis>Extreme Programming Explained</emphasis>
      habla de programación, y echa abajo la mayoría de las cosas,
      incluso los recientes <quote>hallazgos</quote>. Llega al punto
      de decir que los dibujos están bien mientras que no se les
      dedique demasiado tiempo y se esté dispuesto a tirarlos a la
      basura. (observen que ese libro no lleva el <quote>sello de
	certificación UML</quote> en su portada). Comprendería que
      alguien decidiese si quiere trabajar o no para una compañía,
      basándose sólo en el hecho que usan XP. Es un libro pequeño, con
      capítulos cortos, fácil de leer, y que da mucho que pensar.  Uno
      empieza a imaginarse trabajando en esa atmósfera y vienen a la
      mente visiones de un mundo nuevo.
    </para>

    <para>
      <emphasis>UML Distilled </emphasis> por Martin
      Fowler (2ª edición, Addison-Wesley, 2000).Cuando se descubre UML
      por primera vez, resulta intimidante porque hay tantos diagramas
      y detalles. Según Fowler, la mayoría de esa parafernalia es
      innecesaria, así que se queda sólo con lo esencial. Para la
      mayoría de los proyectos, sólo se necesitan unos pocos
      instrumentos gráficos, y el objetivo de Fowler es llegar a un
      buen diseño en lugar de preocuparse por todos los artefactos que
      permiten alcanzarlo. Es un libro corto, muy legible; el primer
      libro que debería conseguir si necesita entender UML.
    </para>

    <para>
      <emphasis> The Unified Software Development
	  Process</emphasis> por Ivar Jacobsen, Grady Booch, y
      James Rumbaugh (Addison-Wesley 1999).  Estaba mentalizado para
      que no me gustase ese libro. Parecía tener todos los
      ingredientes de un aburrido texto universitario. Me quedé
      gratamente sorprendido - solo unos islotes dentro del libro
      contienen explicaciones que dan la impresión que los conceptos
      no han quedado claros para los propios autores. La mayoría del
      libro es no solamente claro, sino agradable. Y lo mejor de todo,
      es que el proceso tiene realmente sentido. Esto no es
      <emphasis>Extreme Programming</emphasis> (y no tiene su claridad
      acerca de los tests) pero también forma parte del mastodonte UML
      - incluso si usted no consigue hacer adoptar
      <emphasis>XP</emphasis>, la mayoría de la gente se ha subido al
      carro de "UML es bueno" (independientemente de su nivel de
      experiencia real con él) así que podría conseguir que lo
      adopten. Pienso que ese libro debería ser el buque insignia del
      UML, y es el que se debe de leer después del <emphasis>UML
	Distilled</emphasis> de Fowler en cuanto se desee tener más
      nivel de detalle.
    </para>

    <para>
      Antes de elegir método alguno, es útil enriquecer su perspectiva
      través de los que no están intentando vender ninguno. Es fácil
      adoptar un método sin entender realmente lo que se desea
      conseguir con él o lo que puede hacer por uno. otras personas lo
      están usando, lo cual parece una buena razón. Sin embargo, los
      humanos tienen un extraño perfil psicológico: si quieren creer
      que algo va a solucionar sus problemas, lo van a probar. (Eso se
      llama experimentación, que es una cosa buena) Pero si eso no les
      resuelve nada, redoblarán sus esfuerzos y empezarán a anunciar
      por todo lo alto su fabuloso descubrimiento. (Eso es negación de
      la realidad, que no es bueno) La idea parece consistir en que si
      usted consigue meter a más gente en el mismo barco, no se
      sentirá solo, incluso si no va a ninguna parte (o se hunde).  No
      estoy insinuando que todas las metodologías no llevan a ningún
      lado, pero hay que estar armado hasta los dientes con
      herramientas mentales que ayuden a seguir en el modo de
      experimentación (<quote>Esto no funciona, vamos a probar otra
	cosa</quote>) y no en el de negación (<quote>No, no es
	problema. Todo va maravillosamente, no necesitamos
	cambiar</quote>). Creo que los libros siguientes, leídos antes
      de elegir un método, le proporcionarán esas herramientas.
    </para>

    <para>
      <emphasis>Software Creativity</emphasis>, por
      Robert Glass (Prentice-Hall, 1995).Ese es el mejor libro que he
      leído que describa una visión de conjunto sobre el debate de las
      metodologías. Consta de una serie de ensayos cortos y artículos
      que Glass ha escrito o comprado (P.J.  Plauger es uno de los que
      contribuyen al libro), que reflejan sus numerosos años dedicados
      a pensar y estudiar el tema. Son amenos y de la longitud justa
      para decir lo necesario; no divaga ni aburre al lector. Pero
      tampoco vende simplemente aire; hay centenares de referencias a
      otros artículos y estudios.  Todos los programadores y jefes de
      proyecto deberían leer ese libro antes de caer en el espejismo
      de las metodologías.
    </para>

    <para>
      <emphasis>Software Runaways: Monumental Software
	  Disasters</emphasis>, por Robert Glass (Prentice-Hall
      1997).Lo realmente bueno de ese libro es que expone a la luz lo
      que nunca contamos: la cantidad de proyectos que no solo
      fracasan, sino que lo hacen espectacularmente. Veo que la
      mayoría de nosotros aún piensa <quote>Eso no me va a pasar a
	mí</quote> (o <quote>Eso no volverá a pasarme</quote>) y creo
      que eso nos desfavorece. Al tener siempre en mente que las cosas
      pueden salir mal, se está en mejor posición para hacerlas ir
      bien.
    </para>

    <para>
      <emphasis>Object Lessons</emphasis> por Tom Love
      (SIGS Books, 1993).  otro buen libro para tener
      <quote>perspectiva</quote>.
    </para>

    <para>
      <emphasis>Peopleware</emphasis> , por Tom Demarco
      y Timothy Lister (Dorset House, 2ª edición 1999).A pesar de que
      tiene elementos de desarrollo de software, ese libro trata de
      proyectos y equipos de trabajo en general. Pero el énfasis está
      puesto en las personas y sus necesidades, y no en las
      tecnologías. Se habla de crear un entorno en el que la gente
      esté feliz y productiva, en lugar de decidir las reglas que
      deben seguir para convertirse perfectos engranajes de una
      máquina. Esta última actitud, pienso yo, es lo que más
      contribuye a que los programadores sonrían y digan sí con la
      cabeza cuando un método es adoptado y sigan tranquilamente
      haciendo lo mismo que siempre.
    </para>

    <para>
      <emphasis>Complexity</emphasis>, by M. Mitchell
      Waldrop (Simon &amp; Schuster, 1992). Relata el encuentro entre
      un grupo de científicos de diferentes disciplinas en Santa Fe,
      Nuevo Méjico, para discutir sobre problemas reales que como
      especialistas no podían resolver aisladamente (el mercado
      bursátil en economía, la formación inicial de la vida en
      biología, por qué la gente se comporta de cierta manera en
      sociología, etc.). Al reunir la física, la economía, la química,
      las matemáticas, la informática, la sociología, y otras
      ciencias, se está desarrollando un enfoque multidisciplinar a
      esos problemas. Pero más importante aun, una nueva forma de
      pensar en esos problemas extremadamente complejos está
      apareciendo: alejándose del determinismo matemático y de la
      ilusión de poder escribir una fórmula que prediga todos los
      comportamientos, hacia la necesidad de observar primero y buscar
      un patrón para después intentar emularlo por todos los medios
      posibles. (El libro cuenta, por ejemplo, la aparición de los
      algoritmos genéticos). Ese tipo de pensamiento, creo yo, es útil
      a medida que investigamos formas de gestionar proyectos de
      software cada vez más complejos.
    </para>
  </sect1>
</appendix>
