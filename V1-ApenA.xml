<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: David Villa Alises
  Formateado DocBook:  David Villa Alises
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<appendix
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="ApendiceA">
  
  <!-- Coding Style -->

  <title>Estilo de codificación</title>

  <!--
  This appendix is not about indenting and placement of parentheses and
  curly braces, although that will be mentioned. It is about the general
  guidelines used in this book for organizing the code listings.
  -->
  
  <highlights>
    <para>
      Este apéndice no trata sobre indentación o colocación de
      paréntesis y llaves, aunque si que se menciona. Trata sobre las
      directrices generales que se usan en este libro para la
      organización de los listados de código.
    </para>
  </highlights>

  <!-- 
  Although many of these issues have been introduced throughout the
  book, this appendix appears at the end so it can be assumed that every
  topic is fair game, and if you don't understand something you can
  look it up in the appropriate section.
  -->

  <para>
    Aunque muchas de estas cuestiones se han tratado a lo largo del
    libro, este apéndice aparece al final de manera que se puede asumir que
    cada tema es FIXME:juego limpio, y si no entiende algo puede buscar
    en la sección correspondiente.
  </para>


  <!-- 
  All the decisions about coding style in this book have been
  deliberately considered and made, sometimes over a period of years. Of
  course, everyone has their reasons for organizing code the way they
  do, and I'm just trying to tell you how I arrived at mine and the
  constraints and environmental factors that brought me to those
  decisions.
  -->

  <para>
    Todas las decisiones sobre estilo de codificación en este libro han
    sido consideradas y ejectuadas deliberadamente, a veces a lo largo
    de períodos de años. Por supuesto, cada uno tiene sus razones para
    organizar el código en el modo en que lo hace, y yo simplemente
    intento explicarle cómo llegué a tomar mi postura y las
    restricciones y factores del entorno que me llevarón a tomar esas
    decisiones.
  </para>


  <sect1>
     <!--  General -->
    <title>General</title>

    <!-- 
    In the text of this book, identifiers (function, variable, and class
    names) are set in bold. Most keywords will also be set in bold, except
    for those keywords that are used so much that the bolding can become
    tedious, such as "class" and "virtual."
    -->

    <para>
      En el testo de este libro, los identificadores (funciones,
      variables, y nombres de clases) aparecen en negrita. Muchas
      palabras reservadas también son negritas, exceptuando aquellas que
      se usan tan a menudo que escribirlas en negrita puede resultar
      tedioso, como <quote>class</quote> o <quote>virtual</quote>.
    </para>

    
    <!-- 
    I use a particular coding style for the examples in this book. It
    was developed over a number of years, and was partially inspired by
    Bjarne Stroustrup's style in his original The C++ Programming
    Language.[64] The subject of formatting style is good for hours of
    hot debate, so I' ll just say I'm not trying to dictate correct
    style via my examples; I have my own motivation for using the style
    that I do. Because C++ is a free-form programming language, you can
    continue to use whatever style you're comfortable with.
    -->

    <para>
      Utilizo un estilo de codificación particular para los ejemplos de
      este libro. Se desarrolló a lo largo de varios años, y se inspiró
      parcialmente en el estilo de
      <author><firstname>Bjarne</firstname><surname>Stroustrup</surname>
      </author>
      en el <citetitle>The C++ Programming Language</citetitle>
      <footnote>
	<para>
	  FIXME:Ibid.
	</para>
      </footnote>
      origina. El asunto del estilo de formato es perfecto para horas de
      acalorado debate, así que sólo diré que no trato de dictar el
      estilo correcto a través de mis ejemplos; tengo mis propios
      motivos para usar el estilo que uso. Como C++ es un lenguaje de
      FIXME:forma libre, cada uno puede continuar usando aquel estilo
      en que se encuentre más cómodo.
    </para>


    <!--
    That said, I will note that it is important to have a consistent
    formatting style within a project. If you search the Internet, you
    will find a number of tools that can be used to reformat all the
    code in your project to achieve this valuable consistency.
    -->

    <para>
      Dicho esto, si haré hincapié en que es importante tener un estilo
      consistente dentro de un proyecto. Si busca en Internet,
      encontrará un buen número de herramientas que se pueden utilizar
      para reformatear todo el código de un proyecto para conseguir esa
      valiosa consistencia.
    </para>


    <!--   
    The programs in this book are files that are automatically extracted
    from the text of the book, which allows them to be tested to ensure
    that they work correctly. Thus, the code files printed in the book
    should all work without compile-time errors when compiled with an
    implementation that conforms to Standard C++ (note that not all
    compilers support all language features). The errors that should cause
    compile-time error messages are commented out with the comment //! so
    they can be easily discovered and tested using automatic means. Errors
    discovered and reported to the author will appear first in the
    electronic version of the book (at www.BruceEckel.com) and later in
    updates of the book.
    -->

    <para>
      Los programas de este libro son ficheros que has sido extraidos
      automáticamentente del texto del libro, lo que permite que se
      puedan probar para asegurar que funcionan correctamente 
      <footnote>
	<para>
	  (N. de T.) Se refiere al libro original. En esta traducción,
	  los programas son ficheros externos incluidos en el texto.
	</para>
      </footnote>. De ese modo, el código mostrado en el libro debería
      funcionar sin errores cuando se compile con una implementación
      conforme al Estándar C++ (no todos los compiladores soportan todas
      las características del lenguaje). Las sentencias que
      <emphasis>deberían</emphasis> causar errores de compilación están
      comentadas con FIXME://! de modo que se pueden descubrir y probar
      fácilmente de modo automático. Los errores desubiertos por el
      autor aparecerán primero en la versión electrónica del libro
      (<ulink
      url="http://www.BruceEchel.com">www.BruceEckel.com</ulink>) y
      después en las actualizaciones del libro.
    </para>


    <!-- 
    One of the standards in this book is that all programs will compile
    and link without errors (although they will sometimes cause
    warnings). To this end, some of the programs, which demonstrate only a
    coding example and don't represent stand-alone programs, will have
    empty main( ) functions, like this
    -->

    <para>
      Uno de los estándares de este libro es que todos los programas
      compilarán y enlazarán sin errores (aunque a veces causarán
      advertencias). Algunos de los programas, que demuestran sólo un
      ejemplo de codificación y no representan programas completos,
      tendrán funciones <function>main()</function> vacias, como ésta:
    </para>

<programlisting>
    int main() {}
</programlisting>
 

    <!-- 
    This allows the linker to complete without an error.
    -->

    <para>
      Esto permite que se pueda enlazar el programa sin errores.
    </para>

    <!-- 
    The standard for main( ) is to return an int, but Standard C++
    states that if there is no return statement inside main( ), the
    compiler will automatically generate code to return 0. This option
    (no return statement in main( )) will be used in this book (some
    compilers may still generate warnings for this, but those are not
    compliant with Standard C++).  
    -->

    <para>
      El estándar para <function>main()</function> es retornar un
      <type>int</type>, pero C++ Estándar estipula que si no hay una
      sentencia <kw>return</kw> en <function>main()</function>, el
      compilador generará automáticamente código para <code>return
      0</code>. Esta opción (no poner un <kw>return</kw> en
      <function>main()</function>) se usa en el libro (algunos
      compiladores producen advertencias sobre ello, pero es porque no
      son conformes con C++ Estándar).
    </para>
  </sect1>

  <sect1>
   <!--  File names -->
    <title>Nombres de fichero</title>

    <!-- 
    In C, it has been traditional to name header files (containing
    declarations) with an extension of .h and implementation files (that
    cause storage to be allocated and code to be generated) with an
    extension of .c. C++ went through an evolution. It was first developed
    on Unix, where the operating system was aware of upper and lower case
    in file names. The original file names were simply capitalized
    versions of the C extensions: .H and .C. This of course didn't work
    for operating systems that didn't distinguish upper and lower case,
    such as DOS. DOS C++ vendors used extensions of hxx and cxx for header
    files and implementation files, respectively, or hpp and cpp. Later,
    someone figured out that the only reason you needed a different
    extension for a file was so the compiler could determine whether to
    compile it as a C or C++ file. Because the compiler never compiled
    header files directly, only the implementation file extension needed
    to be changed. The custom, across virtually all systems, has now
    become to use cpp for implementation files and h for header
    files. Note that when including Standard C++ header files, the option
    of having no file name extension is used, i.e.: #include &lt;iostream>.
    -->

    <para>
      En C, es tradición nombrar a lo ficheros de cabecera (que
      contienen las declaraciones) con una extensión
      <filename>.h</filename> y a los ficheros de implementación (que
      generan alojamiento en memoria y código) con una extensión
      <filename>.c</filename>. C++ supuso una evolución. Primero fue
      desarrollado en Unix, donde el sistema operativo distingue entre
      mayúsculas y minúsculas para nombres de ficheros. Los nombres
      originales para los ficheros simplemente se pusieron en mayúscula:
      <filename>.H</filename> y <filename>.C</filename>. Esto, por
      supuesto, no funcionaba en sistemas operativos que no distinguen
      entre mayúsculas y minúsculas como DOS. Los vendedores de C++ para
      DOS usaban extenciones <filename>hxx</filename> y
      <filename>cxx</filename>, o <filename>hpp</filename> y
      <filename>cpp</filename>. Después, alguien se dió cuenta que la
      única razón por la que se puede necesitar un extensión diferente
      es que el compilador no puede determinar si debe compilarlo como C
      o C++. Como el compilador nunca compila ficheros de cabecera
      directamente, sólo el fichero de implementación necesita una
      distinción. Ahora, en prácticamente todos los sistemas, la
      costumbre es usar <filename>cpp</filename> para los ficheros de
      implementación y <filename>.h</filename> para los ficheros de
      cabecera. Fíjese que cuando se incluye un fichero de cabecera C++,
      se usa la opción de no poner extensión al nombre del fichero, por
      ejemplo: <code>#include &lt;iostream></code>
    </para>
  </sect1>

  <sect1>
   <!-- Begin and end comment tags -->
    <title>Marcas comentadas de inicio y fin</title>

    
    <!-- 
    A very important issue with this book is that all code that you see in
    the book must be verified to be correct (with at least one
    compiler). This is accomplished by automatically extracting the files
    from the book. To facilitate this, all code listings that are meant to
    be compiled (as opposed to code fragments, of which there are few)
    have comment tags at the beginning and end. These tags are used by the
    code-extraction tool ExtractCode.cpp in Volume 2 of this book (which
    you can find on the Web site www.BruceEckel.com) to pull each code
    listing out of the plain-ASCII text version of this book.
    -->

    <para>
      Un tema muy importante en este libro es que todo el código que
      puede ver en el libro ha sido sido verificado (con al menos un
      compilador). Esto se consigue extrayendo automáticamente los
      listados del libro. Para facilitar esta tarea, todos los listados
      de código susceptibles de ser compilados (al contrario que los
      fragmentos, que hay pocos) tienen unas marcas comentadas al
      principio y al final. Estas marcas las usa la herramienta de
      extracción de código <filename>ExtractCode.cpp</filename> del
      Volumen 2 de este libro (y que se puede encontrar en el sitio web
      (<ulink
      url="http://www.BruceEchel.com">www.BruceEckel.com</ulink>)) para
      extraer cada listado de código a partir de la versión en texto
      plano ASCII de este libro.
    </para>


    <!-- 
    The end-listing tag simply tells ExtractCode.cpp that it's the end of
    the listing, but the begin-listing tag is followed by information
    about what subdirectory the file belongs in (generally organized by
    chapters, so a file that belongs in Chapter 8 would have a tag of
    C08), followed by a colon and the name of the listing file.
    -->

    <para>
      La marca de fin de listado simplemente le indica a
      <filename>ExtractCode.cpp</filename> que ese es el final del
      listado, pero la marca de comienzo incluye información sobre el
      subdirectorio al que corresponde el fichero (normalmente
      organizado por capítulos, así que si corresponde al Capítulo 8
      debería tener una etiqueta como <literal>C08</literal>), seguido
      de dos puntos y el nombre del fichero.
    </para>


    <!-- 
    Because ExtractCode.cpp also creates a makefile for each subdirectory,
    information about how a program is made and the command-line used to
    test it is also incorporated into the listings. If a program is
    stand-alone (it doesn't need to be linked with anything else) it has
    no extra information. This is also true for header files. However, if
    it doesn't contain a main( ) and is meant to be linked with something
    else, then it has an {O} after the file name. If this listing is meant
    to be the main program but needs to be linked with other components,
    there's a separate line that begins with //{L} and continues with all
    the files that need to be linked (without extensions, since those can
    vary from platform to platform).
    -->

    <para>
      Como <filename>ExtractCode.cpp</filename> también crea un
      <filename>makefile</filename> para cada subdirectorio, la
      información de cómo construir el programa y la línea de comando
      que se debe usar para probarlo también se incorpora a los
      listados. Si un programa es autónomo (no necesita ser enlazado con
      nada más) no tiene información extra. Esto también es cierto para
      los ficheros de cabecera. Sin embargo, si no contiene un
      <filename>main()</filename> y necesita enlazarse con algo otro,
      aparece un <literal>{O}</literal> después del nombre del
      fichero. Si ese listado es el programa principal pero necesita ser
      enlazado con otros componentes, hay una línea adicional que
      comienza con <literal>//{L}</literal> y continua con todos los
      ficheros con los que necesita ser enlazado (sin extensiones, dado
      que puede varía entre plataformas).
    </para>


    <!-- 
    You can find examples throughout the book.
    -->

    <para>
      Puede encontrar ejemplos a lo largo de todo el libro.
    </para>


    <!-- 
    If a file should be extracted but the begin- and end-tags should not
    be included in the extracted file (for example, if it's a file of
    test data) then the begin-tag is immediately followed by a '!'.
    -->

    <para>
      Cuando un fichero debe extraerse sin que las marcas de inicio y fin 
      deban incluirse en el fichero extraido (por ejemplo, si es un
      fichero con datos para una prueba) la marca de inicio va seguida
      de un '!'.
    </para>
  </sect1>

  
  <sect1>
   <!-- Parentheses, braces, and indentation -->
    <title>Paréntesis, llaves e indentación</title>


    <!-- 
    You may notice the formatting style in this book is different from
    many traditional C styles. Of course, everyone thinks their own style
    is the most rational. However, the style used here has a simple logic
    behind it, which will be presented here mixed in with ideas on why
    some of the other styles developed.
    -->

    <para>
      Habrá notado que el estilo de este libro es diferente a la mayoría
      de los estilos C tradicionales. Por supuesto, cualquiera puede
      pensar que su propio estilo es más racional. Sin embargo, el
      estilo que se emplea aquí tiene una lógica más simple, que se
      presentará mezclada con las de otros estilos desarrollados.
    </para>


    <!-- 
    The formatting style is motivated by one thing: presentation, both in
    print and in live seminars. You may feel your needs are different
    because you don't make a lot of presentations. However, working code
    is read much more than it is written, and so it should be easy for the
    reader to perceive. My two most important criteria are "scannability"
    (how easy it is for the reader to grasp the meaning of a single line)
    and the number of lines that can fit on a page. This latter may sound
    funny, but when you are giving a live presentation, it's very
    distracting for the audience if the presenter must shuffle back and
    forth between slides, and a few wasted lines can cause this.
    -->

    <para>
      El estilo está motivado por una cosa: la presentación, tanto
      impresa como en un seminario. Quizá sus necesidades sean
      diferentes porque no realiza muchas presentaciones. Sin embargo,
      el código real se lee muchas más veces de las que se escribe, y por
      eso debería ser fácil de leer. Mis dos criterios más importantes
      son la <quote>escaneabilidad</quote> (que se refiere a la facilidad
      con la que el lector puede comprender el significado de una única
      línea) y el número de líneas que caben en una página. Lo segundo
      puede sonar gracioso, pero cuando uno da una charla, distrae mucho
      a la audiencia que el ponente tenga que avanzar y retroceder
      diapositivas, y sólo unas pocas líneas de más puede provocar este
      efecto.
    </para>


    <!-- 
    Everyone seems to agree that code inside braces should be
    indented. What people don't agree on - and the place where there's
    the most inconsistency within formatting styles - is this: Where does
    the opening brace go? This one question, I think, is what causes such
    variations among coding styles (For an enumeration of coding styles,
    see C++ Programming Guidelines, by Tom Plum and Dan Saks, Plum Hall
    1991.) I'll try to convince you that many of today's coding styles
    come from pre-Standard C constraints (before function prototypes) and
    are thus inappropriate now.
    -->
    
    <para>
      Todo el mundo parece estar de acuerdo en el que código que se pone
      dentro de llaves debe estar indentado. En lo que la gente no está
      de acuerdo - y es el sitio donde más inconsistencia tienen los
      estilos - es: ¿Dónde debe ir la llave de apertura? Esta única
      cuestió, creo yo, es la que causa la mayoría de las variaciones en
      los estilos de codificación (Si quiere ver una enumeración de
      estilos de codificación vea <citetitle>C++ Programming
      Guidelines</citetitle>, de Tom Plum y Dan Saks, Plum Hall 1991.)
      Intentaré convencerle de que muchos de los estilos de codificación
      actuales provienen de la restricciones previas al C Estándar
      (antes de los prototipos de función) de manera que no son
      apropiadas actualmente.
    </para>


    <!-- 
    First, my answer to that key question: the opening brace should always
    go on the same line as the "precursor" (by which I mean "whatever
    the body is about: a class, function, object definition, if statement,
    etc."). This is a single, consistent rule I apply to all of the code
    I write, and it makes formatting much simpler. It makes the
    "scannability" easier - when you look at this line:
    -->
    
    <para>
      Lo primero, mi respuesta a esa pregunta clave: la llave de
      apertura debería ir siempre en la misma línea que el
      <quote>precursor</quote> (es decir <quote>cualquier cosa de la que
      sea cuerpo: una clase, función, definición de objeto, sentencia
      <kw>if</kw>, etc</quote>. ES una regla única y
      consistente que aplico a todos el código que escribo, y hace que
      el formateo de código sea mucho más sencillo. Hace más sencilla la
      <quote>escaneabilidad</quote> - cuando se lee esta línea:
    </para>


    <programlisting>
    int func(int a);
</programlisting> 

    <!-- 
    you know, by the semicolon at the end of the line, that this is a
    declaration and it goes no further, but when you see the line:
    -->

    <para>
      Se sabe, por el punto y coma al final de la línea, que esto es una
      declaración y no hay nada más, pero al leer la línea:
    </para>


    <programlisting>
  int func(int a) {
</programlisting>  

    <!-- 
    you immediately know it's a definition because the line finishes with
    an opening brace, not a semicolon. By using this approach, there's no
    difference in where you place the opening parenthesis for a multi-line
    definition:
    -->

    <para>
      inmediatamente se sabe que se una definición porque la línea
      termina con una llave de apertura, no un punto y coma. Usando este
      enfoque, no hay diferencia a la hora de colocar el paréntesis de
      apertura en una definición de múltiples líneas.
    </para>


    <programlisting>
    int func(int a) {
      int b = a + 1;
      return b * 2;
    } 
</programlisting> 


    <!-- 
    and for a single-line definition that is often used for inlines:
    -->
    
    <para>
      y para una definición de una sola línea que a menudo se usa para inlines:
    </para>


    <programlisting>
    int func(int a) { return (a + 1) * 2; }
</programlisting> 


    <!-- 
    Similarly, for a class:
    -->

    <para>
      Igualmente, para una clase:
    </para>


    <programlisting>
    class Thing;
</programlisting> 


    <!-- 
    is a class name declaration, and
    -->

    <para>
      es una declaración del nombre de una clase, y
    </para>


    <programlisting>
    class Thing {
</programlisting> 


    <!-- 
    is a class definition. You can tell by looking at the single line in
    all cases whether it's a declaration or definition. And of course,
    putting the opening brace on the same line, instead of a line by
    itself, allows you to fit more lines on a page.
    -->

    <para>
      es una definición de clase. En todos los casos, se puede saber
      mirando una sola línea si se trata de una declaración o una
      definición. Y por suspuesto, poniendo la llave de apertura en la
      misma línea, en lugar de una línea propia, permite ahorrar espacio
      en la página.
    </para>


    <!-- 
    So why do we have so many other styles? In particular, you'll notice
    that most people create classes following the style above (which
    Stroustrup uses in all editions of his book The C++ Programming
    Language from Addison-Wesley) but create function definitions by
    putting the opening brace on a single line by itself (which also
    engenders many different indentation styles). Stroustrup does this
    except for short inline functions. With the approach I describe here,
    everything is consistent - you name whatever it is (class, function,
    enum, etc.) and on that same line you put the opening brace to
    indicate that the body for this thing is about to follow. Also, the
    opening brace is the same for short inlines and ordinary function
    definitions.
    -->

    <para>
      Así que ¿por qué tenemos tantos otros estilos? En concreto, verá
      que mucha gente crea clases siguiente el estilo anterior (que
      Stroustrup usa en todas las ediciones de su libro <citetitle>The
      C++ Programming Language</citetitle> de Addison-Wesley) pero crean
      definiciones de funciones poniendo la llave de apertura en una
      línea aparte (lo que da lugar a muchos estilos de indentación
      diferentes). Stroustrup lo hace excepto para funciones inline
      cortas. Con el enfoque que yo describo aquí, todo es consistente -
      se nombra lo que sea (<kw>class</kw>, función, <kw>enum</kw>, etc)
      y en la misma línea se pone la llave de apertura para indicar que
      el cuerpo de esa cosa está debajo. Y también, la llave de apertura
      se pone en el mismo sitio para funciones inline que para
      definiciones de funciones ordinarias.
    </para>


    <!-- 
    I assert that the style of function definition used by many folks
    comes from pre-function-prototyping C, in which you didn't declare
    the arguments inside the parentheses, but instead between the closing
    parenthesis and the opening curly brace (this shows C's
    assembly-language roots):
    -->

    <para>
      Creo que el estilo de definición de funciones que utiliza mucha
      gente viene de el antiguo prototipado de funiones de C, en el que
      no se declaraban los argumentos entre los paréntesis, si no entre
      el paréntesis de cierre y la llave de apertura (esto demuestra que
      las raices de C son el lenguaje ensamblador):
    </para>


    <programlisting>
    void bar()
     int x;
     float y;
    {
     /* body here */
    } 
</programlisting> 


    <!-- 
    Here, it would be quite ungainly to put the opening brace on the same
    line, so no one did it. However, they did make various decisions about
    whether the braces should be indented with the body of the code or
    whether they should be at the level of the "precursor." Thus, we got
    many different formatting styles.
    -->

    <para>
      Aquí, quedaría bastante mal poner la llave de apertura en la misma
      línea, así que nadie lo hacía. Sin embargo, tomaban varias sobre
      si las llaves debían indentarse con el cuerpo del código o debían
      dejarse a nivel con el <quote>precursor</quote>. De modo que
      tenemos muchos estilos diferentes.
    </para>


    <!-- 
    There are other arguments for placing the brace on the line
    immediately following the declaration (of a class, struct, function,
    etc.). The following came from a reader, and is presented here so you
    know what the issues are:
    -->

    <para>
      Hay otros argumentos para poner la llave en la línea
      siguiente a la declaración (de una clase, <kw>struct</kw>,
      función, etc). Lo siguiente proviene de un lector, y lo presento
      aquí para que sepa a qué se refiere.
    </para>


    <!-- 
    Experienced 'vi' (vim) users know that typing the ']' key twice
    will take the user to the next occurrence of '{' (or ^L) in column
    0. This feature is extremely useful in navigating code (jumping to the
    next function or class definition). [My comment: when I was initially
    working under Unix, GNU Emacs was just appearing and I became enmeshed
    in that. As a result, 'vi' has never made sense to me, and thus I do
    not think in terms of "column 0 locations." However, there is a fair
    contingent of 'vi' users out there, and they are affected by this
    issue.]
    -->

    <para>
      Los usuarios experimentado de <productname>vi</productname> (vim)
      saben que pulsar la tecla <quote>]</quote> dos veces lleva el
      cursor a la siguiente ocurrencia de <quote>{</quote> (o ^L) en la
      columna 0. Esta característica es extremadamente útil para moverse
      por el código (saltando a la siguiente defición de función o
      clase). [Mi comentario: cuando yo trabajaba en bajo Unix, GNU
      Emacs acababa de aparecer y yo me convertí en un fan suyo. Como
      resultado, <productname>vi</productname> nunca ha tenido sentido
      para mi, y por eso yo no pienso en términos de <quote>situación
      de columna 0</quote>. Sin embargo, hay una buena cantidad de
      usuarios de <productname>vi</productname> ahí fuera, a los que les
      afecta esta característica.]
    </para>


    <!-- 
    Placing the '{' on the next line eliminates some confusing code in
    complex conditionals, aiding in the scannability. Example:
    -->

    <para>
      Poniendo la <quote>{</quote> en la siguiente línea se eliminan
      algunas confusiones en sentencias condicionales complejas,
      ayudando a la escaneabilidad.
    </para>

    <programlisting>
    if(cond1
       &amp;&amp; cond2
       &amp;&amp; cond3) {
       statement;
    } 
</programlisting> 


    <!-- 
    The above [asserts the reader] has poor scannability. However,
    -->

    <para>
      Lo anterior [dice el lector] tiene una escaneabilidad pobre. Sin embargo,
    </para>

    <programlisting>
    if (cond1
    &amp;&amp; cond2
    &amp;&amp; cond3)
    {
    statement;
    } 
</programlisting>  


    <!-- 
    breaks up the 'if' from the body, resulting in better
    readability. [Your opinions on whether this is true will vary
    depending on what you're used to.]
    -->

    <para>
      separa el <kw>if</kw> del cuerpo, mejorando la
      legibilidad. [Sus opiniones sobre si eso es cierto variarán
      dependiendo en que lo haya usado.]
    </para>


    <!-- 
    Finally, it's much easier to visually align braces when they are
    aligned in the same column. They visually "stick out" much
    better. [End of reader comment]
    -->

    <para>
      Finalmente, es mucho más fácil visualizar llaves emparejadas
      si están alineadas en la misma columna. Visualmente destacan mucho
      más. [Fin del comentario del lector]
    </para>


    <!-- 
    The issue of where to put the opening curly brace is probably the most
    discordant issue. I've learned to scan both forms, and in the end it
    comes down to what you've grown comfortable with. However, I note
    that the official Java coding standard (found on Sun's Java Web site)
    is effectively the same as the one I present here - since more folks
    are beginning to program in both languages, the consistency between
    coding styles may be helpful.
    -->

    <para>
      El tema de dónde poner la llave de apertura es probablemente el
      asunto en el que hay menos acuerdo. He aprendido a leer ambas
      formas, y al final cada uno utiliza la que le resulta más
      cómoda. Sin embargo, he visto que el estándar oficial de
      codificación de Java (que se puede encontar en la página de Java
      de Sun) efectivamente es el mismo que yo he presentado aquí - dado
      que más personas están empezando a programar en ambos lenguajes,
      la consistencia entre estilos puede ser útil.
    </para>


    <!-- 
    The approach I use removes all the exceptions and special cases, and
    logically produces a single style of indentation as well. Even within
    a function body, the consistency holds, as in:
    -->

    <para>
      En enfoque que yo uso elimina todas las excepciones y casos
      especiales, y lógicamente produce un único estilo de indentación,
      Incluso con un cuerpo de función, la consistencia se mantiene,
      como en:
    </para>

    <programlisting>
    for(int i = 0; i &lt; 100; i++) {
      cout &lt;&lt; i &lt;&lt; endl;
      cout &lt;&lt; x * i &lt;&lt; endl;
    } 
</programlisting> 


    <!-- 
    The style is easy to teach and to remember - you use a single,
    consistent rule for all your formatting, not one for classes, two for
    functions (one-line inlines vs. multi-line), and possibly others for
    for loops, if statements, etc. The consistency alone, I think, makes
    it worthy of consideration. Above all, C++ is a newer language than C,
    and although we must make many concessions to C, we shouldn't be
    carrying too many artifacts with us that cause problems in the
    future. Small problems multiplied by many lines of code become big
    problems. For a thorough examination of the subject, albeit in C, see
    C Style: Standards and Guidelines, by David Straker (Prentice-Hall
    1992).
    -->

    <para>
      El estilo es fácil de enseñar y recordar - use una regla simple y
      consistente para todo sus formatos, no una para clases, dos para
      funciones (funciones inline de una línea vs. multi-línea), y
      posiblemente otras para bucles, sentencias <kw>if</kw>,
      etc. La consistencia por si sola merece ser tenida en
      cuenta. Sobre todo, C++ es una lenguaje más nuevo que C, y aunque
      hacemos más concesiones a C, no deberíamos acarrear demasiados
      FIXME:artifacts que nos causen problemas en el futuro. Problemas
      pequeños multiplicado por muchas líneas de código se convierten en
      grandes problemas. Para un examen minucioso del asunto, aunque
      sobre C, vea <citetitle>C Style: Standards and
      Guidelines</citetitle>, de David Straker (Prentice-Hall 1992).
    </para>


    <!-- 
    The other constraint I must work under is the line width, since the
    book has a limitation of 50 characters. What happens when something is
    too long to fit on one line? Well, again I strive to have a consistent
    policy for the way lines are broken up, so they can be easily
    viewed. As long as something is part of a single definition, argument
    list, etc., continuation lines should be indented one level in from
    the beginning of that definition, argument list, etc.
    -->

    <para>
      La otra restricción bajo la que debo trabajar en la longitud de la
      línea, dado que el libro tiene una limitación de 50
      caracteres. ¿Qué ocurre si algo es demasiado largo para caber en
      una línea? Bien, otra vez me exfuerzo en tener una política
      consistente para las líneas partidas, de modo que sean fácilmente
      visibles. Siempre que sean parte de una única definición, lista de
      argumentos, etc., las líneas de continuación deberían indentarse
      un nivel respecto al comienzo de la definición, lista de
      argumentos, etc.
    </para>
  </sect1>


  <sect1>
    <!-- Identifier names -->
    <title>Nombres para identificadores</title>

    <!-- 
    Those familiar with Java will notice that I have switched to using the
    standard Java style for all identifier names. However, I cannot be
    completely consistent here because identifiers in the Standard C and
    C++ libraries do not follow this style.
    -->

    <para>
      Aquellos que conozcan Java notarán que yo me he cambiado al estilo
      estándar de Java para todos los identificadores. Sin embargo, no
      puedo ser completamente consistente porque los identificadores en
      C Estándar y en librerías C++ no siguen ese estilo.
    </para>

    <!--
    The style is quite straightforward. The first letter of an identifier
    is only capitalized if that identifier is a class. If it is a function
    or variable, then the first letter is lowercase. The rest of the
    identifier consists of one or more words, run together but
    distinguished by capitalizing each word. So a class looks like this:
    -->
    
    <para>
      El estilo es bastante sencillo. La primera letra de un
      identificador sólo se pone en mayúscula si el identificador es una
      clase. Si es una función o variable, la primera letra siempre va
      en minúscula. El resto del identificador consiste en una o más
      palabras, todas juntas pero se distinguen porque la primera letra
      de cada palabra es mayúscula. De modo que una clase es algo
      parecido a esto:
    </para>

    <programlisting>
    class FrenchVanilla : public IceCream {
</programlisting> 


    <!-- 
    an object identifier looks like this:
    -->

    <para>
      y un objeto es algo como esto:
    </para>

    <programlisting>
    FrenchVanilla myIceCreamCone(3);
</programlisting> 


    <!-- 
    and a function looks like this:
    -->

    <para>
      y una función:
    </para>


    <programlisting>
    void eatIceCreamCone();
</programlisting>  


    <!-- 
    (for either a member function or a regular function).
    -->

    <para>
      (tanto para un método como para un función normal).
    </para>

    
    <!-- 
    The one exception is for compile-time constants (const or #define), in
    which all of the letters in the identifier are uppercase.
    -->

    <para>
      La única excepción son las constantes en tiempo de compilación
      (<kw>const</kw> y <kw>#define</kw>), en las que todas las letras
      del identificador son mayúsculas.
    </para>


    <!-- 
    The value of the style is that capitalization has meaning - you can
    see from the first letter whether you're talking about a class or an
    object/method. This is especially useful when static class members are
    accessed.
    -->

    <para>
      El valor del estilo es que el uso de mayúsculas tiene significado
      - viendo la primera letra se puede saber si es una clase o un
      objeto/método. Esto es especialmente útil cuando se invocan
      miembros estáticos.
    </para>
  </sect1>


  <sect1>
    
    <!-- Order of header inclusion -->
    <title>Orden de los #includes</title>

    <!-- 
    Headers are included in order from "the most specific to the most
    general." That is, any header files in the local directory are
    included first, then any of my own "tool" headers, such as
    require.h, then any third-party library headers, then the Standard C++
    Library headers, and finally the C library headers.
    -->
    
    <para>
      Los ficheros de cabecera se incluyen en orden <quote>del más
      específico al más general</quote>. Es decir, cualquier fichero de
      cabecera es el directorio local se incluye primero, después las
      <quote>herramientas</quote> propias, como
      <filename>require.h</filename>, luego cabeceras de librerías de
      terceros, después cabeceras de la librería estándar C++, y
      finalmente cabeceras de la librería C.
    </para>


    <!-- 
    The justification for this comes from John Lakos in Large-Scale C++
    Software Design (Addison-Wesley, 1996):
    -->

    <para>
      La justificación para esto viene de John Lakos en
      <citetitle>Large-Scale C++ Software Design</citetitle>
      (Addison-Wesley, 1996):
    </para>


    <!-- 
    Latent usage errors can be avoided by ensuring that the .h file of a
    component parses by itself - without externally-provided declarations
    or definitions... Including the .h file as the very first line of the
    .c file ensures that no critical piece of information intrinsic to the
    physical interface of the component is missing from the .h file (or,
    if there is, that you will find out about it as soon as you try to
    compile the .c file).
    -->


    <blockquote>
      <para>
	FIXME
	Los errores de uso latentes se puede evitar asegurando que el
	fichero .h de un componente es coherente en si mismo - sin
	declaraciones o definiciones externas. Incluyendo el fichero .h
	como primera línea del fichero .c asegura que no falta ninguna
	pieza de información de la interface física del componente, en
	el fichero .h (o, si la hay, se encontrará tan pronto como
	intente compilar el fichero .c.
      </para>
    </blockquote>


    <!-- 
    If the order of header inclusion goes "from most specific to most
    general," then it's more likely that if your header doesn't parse
    by itself, you'll find out about it sooner and prevent annoyances
    down the road.
    -->

    <para>
      Si el orden de inclusión fuese <quote>desde el más específico al
      más general</quote>, entonces es más probable que si su fichero de
      cabecera no es coherente por si mismo, lo descubrirá antes y
      prevendrá disgustos en el futuro.
    </para>
  </sect1>

  
  <sect1>
    <!-- Include guards on header files -->
    <title>Guardas de inclusión en ficheros de cabecera</title>

    <!-- 
    Include guards are always used inside header files to prevent multiple
    inclusion of a header file during the compilation of a single .cpp
    file. The include guards are implemented using a preprocessor #define
    and checking to see that a name hasn't already been defined. The name
    used for the guard is based on the name of the header file, with all
    letters of the file name uppercase and replacing the '.' with an
    underscore. For example:
    -->

    <para>
      Los guardas de inclusión se usan siempre en los ficheros de
      cabecera para prevenir inclusiones múltiples durante la
      compilación de un único fichero <filename>.cpp</filename>. Los
      guardas de inclusión se implementan usado
      <kw>#define</kw> y comprobando si el nombre no ha sido
      definido previamente. El nombre que se usa para el guarda está
      basado en el nombre del fichero de cabecera, pero con todos las
      letras en mayúscula y reemplazando el punto por un guión bajo. Por
      ejemplo:
    </para>

<programlisting>
    // IncludeGuard.h
    #ifndef INCLUDEGUARD_H
    #define INCLUDEGUARD_H
    // Body of header file here...
    #endif // INCLUDEGUARD_H
</programlisting>


    <!-- 
    The identifier on the last line is included for clarity. Although some
    preprocessors ignored any characters after an #endif, that isn't
    standard behavior and so the identifier is commented.
    -->

    <para>
      El identificador de la última línea se incluye únicamente por
      claridad. Aunque algunos preprocesadores ignoran cualquier
      caracter que aparezca después de un <kw>#endif</kw>, pero no es el
      comportamiento estándar y por eso se comenta el identificador.
    </para>
  </sect1>


  <sect1>
    <!-- Use of namespaces -->
    <title>Utilidad de los espacios de nombres</title>

    <!-- 
    In header files, any "pollution" of the namespace in which the
    header is included must be scrupulously avoided. That is, if you
    change the namespace outside of a function or class, you will cause
    that change to occur for any file that includes your header, resulting
    in all kinds of problems. No using declarations of any kind are
    allowed outside of function definitions, and no global using
    directives are allowed in header files.
    -->
    
    <para>
      En los ficheros de cabecera, se debe evitar de forma escrupulosa
      cualquier contaminación del espacio de nombres. Es decir, si se
      cambia el espacio de nombres fuera de una función o clase,
      provocará que el cambio ocurra también en cualquier fichero que
      incluya ese fichero de cabecera, lo que resulta en todo tipo de
      problemas. No están permitidas las declaraciones <kw>using</kw> de
      ningún tipo fuera de las definiciones de función, y tampoco deben
      ponerse directivas <kw>using</kw> globales en ficheros de
      cabecera.
    </para>


    <!-- 
    In cpp files, any global using directives will only affect that file,
    and so in this book they are generally used to produce more
    easily-readable code, especially in small programs.
    -->
    
    <para>
      En ficheros <filename>cpp</filename>, cualquier directiva
      <kw>using</kw> global solo afectará a ese fichero, y por eso en
      este libro se usan generalmente para conseguir código más legible,
      especialmente en programas pequeños.
    </para>
  </sect1>


  <sect1>
    <!-- Use of require( ) and assure( ) -->
    <title>
      Utilización de <function>require()</function> y <function>assure()</function>
    </title>

    <!-- 
    The require( ) and assure( ) functions defined in require.h are used
    consistently throughout most of the book, so that they may properly
    report problems. If you are familiar with the concepts of
    preconditions and postconditions (introduced by Bertrand Meyer) you
    will recognize that the use of require( ) and assure( ) more or less
    provide preconditions (usually) and postconditions
    (occasionally). Thus, at the beginning of a function, before any of
    the "core" of the function is executed, the preconditions are
    checked to make sure everything is proper and that all of the
    necessary conditions are correct. Then the "core" of the function is
    executed, and sometimes some postconditions are checked to make sure
    that the new state of the data is within defined parameters. You'll
    notice that the postcondition checks are rare in this book, and
    assure( ) is primarily used to make sure that files were opened
    successfully.
    -->

    <para>
      Las funciones <function>require()</function> y
      <function>assure()</function> definidas en
      <filename>requiere.h</filename> se usan constantemente a lo largo
      de todo el libro, para que informen de problemas. Si se está
      familiarizado con los conceptos de precondiciones y
      postcondiciones (introducidos por <personname> Bertrand
      Meyer</personname>) es fácil reconocer que el uso de
      <function>require()</function> y <function>assure()</function> más
      o menos proporciona precondiciones (normalmente) y postcondiciones
      (ocasionalmente). Por eso, al principio de una función, antes de
      que se ejecute el <quote>núcleo</quote> de la función, se
      comprueban las precondiciones para estar seguro de que todo las
      condiciones necesarias se cumplen. Entonces, se ejecuta el
      <quote>núcleo</quote> de la función, y a veces algunas se
      comprueban algunas postcondiciones para estar seguro que el nuevo
      estado en el que han quedado los datos está dentro de los
      parámetros correspondientes. Notará que las comprobaciones de
      postcondición se usan raramente es este libro, y
      <function>assure()</function> se usa principalmente para estar
      seguro de que los ficheros se abren adecuadamente.
    </para>
  </sect1>

</appendix>
