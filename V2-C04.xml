<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 22/PSGML
  Traducción original: Ferran Ferri
  Formateado DocBook:
-->

<!-- original de referencia en:
http://arco.inf-cr.uclm.es/~david.villa/pensar_en_C++/TICv2/html/TicV2.html#_Toc53985673
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C04">


  <!-- Iostreams -->
  <title>Iostreams</title>

  <!--
  You can do much more with the general I/O problem than just take
  standard I/O and turn it into a class.
  -->
  <highlights>
    <para>
      Puedes hacer mucho más con el problema general de E/S que
      simplemente coger el E/S estándar y convertirlo en una clase.
    </para>
  </highlights>

  <!--
  Wouldn't it be nice if you could make all the usual 'receptacles'
  ?standard I/O, files, and even blocks of memory?look the same so that
  you need to remember only one interface? That's the idea behind
  iostreams. They're much easier, safer, and sometimes even more
  efficient than the assorted functions from the Standard C stdio library.
  -->
  <para>
    ¿No seria genial si pudiera hacer que todos los 'receptáculos' -E/S
    estándar, ficheros, e incluso boques de memoria- parecieran iguales de
    manera que solo tuviera que recordar una interficie? Esta es la idea que hay
    detrás de los <classname>iostreams</classname>. Son mucho más sencillos,
    seguros, y a veces incluso más eficientes que el conjunto de funciones de la
    libreria estándar de C <classname>stdio.</classname>
  </para>

  <!--
  The iostreams classes are usually the first part of the C++ library that
  new C++ programmers learn to use. This chapter discusses how iostreams
  are an improvement over C's stdio facilities and explores the behavior
  of file and string streams in addition to the standard console streams.
  -->
  <para>
    Las clases de <classname>iostream</classname> son generalmente la
    primera parte de la libreria de C++ que los nuevos programadores de C++
    parender a usar. En este capítulo se discute sobre las mejoras que
    representan los <classname>iostream</classname> sobre las funciones de
    <classname>stdio</classname> de C y explora el comprotamiento de los
    ficheros y streams de strings además de los streams de consola.
  </para>

  <sect1>
    <!-- : Why iostreams? -->
    <title>¿Por que <classname>iostream</classname>? </title>

    <!--
    You might wonder what's wrong with the good old C library. Why not
    'wrap' the C library in a class and be done with it? Sometimes this is
    a fine solution. For example, suppose you want to make sure that the
    file represented by a stdio FILE pointer is always safely opened and
    properly closed without having to rely on the user to remember to call
    the close( ) function. The following program is such an attempt:
    -->
    <para>
      Se debe estar preguntando que hay de malo en la buena y vieja
      librería de C. ¿Por que no 'incrustar' la libreria de C en una clase y ya
      está? A veces esta solución es totalmente válida. Por ejemplo, suponga que
      quiere estar seguro que un fichero representado por un puntero de
      <classname>stdio</classname> <varname>FILE</varname> siempre es abierto de
      forma segura y cerrado correctamente sin tener que confiar en que el usuario
      se acuerde de llamar a la función <function>close()</function>. El siguiente
      programa es este intento:
    </para>


//: V2C04:FileClass.h

    <!--
    When you perform file I/O in C, you work with a naked pointer to a FILE
    struct, but this class wraps around the pointer and guarantees it is
    properly initialized and cleaned up using the constructor and
    destructor. The second constructor argument is the file mode, which
    defaults to 'r' for 'read.'
    -->
    <para>
      Cuando trabaja con ficheros E/S en C, usted trabaja con punteros
      desnudos a una <varname>struct</varname> de <varname>FILE</varname>, pero
      esta clase envuelve los punteros y garantiza que es correctamente
      inicializada y destruida usando el constructor y el destructor. El segundo
      parámetro del constructor es el modo del fichero, que por defecto es 'r'
      para 'leer'
    </para>

    <!--
    To fetch the value of the pointer to use in the file I/O functions, you
    use the fp( ) access function. Here are the member function definitions:
    -->
    <para>
      Para pedir el valor del puntero para usarlo en las funciones de
      fichero de E/S, use la función de acceso <function>fp()</function>. Aquí
      están las definiciones de las funciones miembro:
    </para>


//: V2C04:FileClass.cpp {O}


    <!--
    The constructor calls fopen( ), as you would normally do, but it also
    ensures that the result isn't zero, which indicates a failure upon
    opening the file. If the file does not open as expected, an exception is
    thrown.
    -->
    <para>
      El constructor llama a <function>fopen()</function>, tal como se
      haría normalmente, pero además se asegura que el resultado no es cero, que
      indica un error al abrir el fichero. Si el fichero no se abre correctamente,
      se lanza una excepción.
    </para>

    <!--
    The destructor closes the file, and the access function fp( ) returns
    f. Here's a simple example using FileClass:
    -->
    <para>
      El destructor cierra el fichero, y la función de acceso
      <function>fp()</function> retorna <varname>f</varname>. Este es un ejemplo
      de uso de <classname>FileClass</classname>:
    </para>


//: V2C04:FileClassTest.cpp


    <!--
    You create the FileClass object and use it in normal C file I/O function
    calls by calling fp( ). When you're done with it, just forget about it;
    the file is closed by the destructor at the end of its scope.
    -->
    <para>
      Se crea el objeto <classname>FileClass</classname> y se usa en
      llamadas a funciones E/S de fichero normal de C, llamando a
      <function>fp()</function>. Cuando haya acabado con ella, simplemente
      olvídese; el fichero será cerrado por el destructor al final del ámbito de
      la variable.
    </para>

    <!--
    Even though the FILE pointer is private, it isn't particularly safe
    because fp( ) retrieves it. Since the only effect seems to be guaranteed
    initialization and cleanup, why not make it public or use a struct
    instead? Notice that while you can get a copy of f using fp( ), you
    cannot assign to f?that's completely under the control of the
    class. After capturing the pointer returned by fp( ), the client
    programmer can still assign to the structure elements or even close it,
    so the safety is in guaranteeing a valid FILE pointer rather than proper
    contents of the structure.
    -->
    <para>
      Incluso teniendo en cuenta que <varname>FILE</varname> es un
      puntero privado, no es particularmente seguro porque
      <function>fp()</function> lo recupera. Ya que el único efecto que parece
      estar garantizado es la inicialización y la liberación, ¿por que no hacerlo
      público o usar una <code>struct </code>en su lugar? Nótese que mientras se
      puede obtener una copia de <varname>f </varname>usando
      <function>fp()</function>, no se puede asignar a <varname>f</varname> -que
      está completamente bajo el control de la clase. Después de capturar el
      puntero retornado por <function>fp()</function>, el programador cliente
      todavía puede asignar a la estructura elementos o incluso cerrarlo, con lo
      que la seguridad esta en la garantía de un puntero a FILE válido mas que en
      el correcto contenido de la estructura.
    </para>

    <!--
    If you want complete safety, you must prevent the user from directly
    accessing the FILE pointer. Some version of all the normal file I/O
    functions must show up as class members so that everything you can do
    with the C approach is available in the C++ class:
    -->
    <para>
      Si quiere completa seguridad, tiene que evitar que el usuario
      acceda directamente al puntero <code>FILE</code>. Cada una de las versiones
      de las funciones normales de E/S a ficheros deben ser mostradas como
      miembros de clase para que todo lo que se pueda hacer desde el acercamiento
      de C esté disponible en la clase de C++.
    </para>

//: V2C04:Fullwrap.h


    <!--
    This class contains almost all the file I/O functions from
    function.)
    -->
    <para>
      Esta clase contiene casi todas las funciones de E/S de fichero
      de <code>&lt;cstdio&gt;</code>. (<function>vfprintf()</function> no esta; se
      implementa en la función miembro <function>printf()</function> )
    </para>

    <!--
    File has the same constructor as in the previous example, and it also
    has a default constructor. The default constructor is important if you
    want to create an array of File objects or use a File object as a member
    of another class where the initialization doesn't happen in the
    constructor, but some time after the enclosing object is created.
    -->
    <para>
      El fichero tiene el mismo constructor que en el ejemplo
      anterior, y también tiene un constructor por defecto. El constructor por
      defecto es importante si se crea un array de objetos
      <classname>File</classname> o se usa un objeto <classname>File</classname>
      como miembro de otra clase donde la inicialización no se realiza en el
      contructor, sino cierto tiempo después de que el objeto envolvente se
      cree.
    </para>

    <!--
    The default constructor sets the private FILE pointer f to zero. But
    now, before any reference to f, its value must be checked to ensure it
    isn't zero. This is accomplished with F( ), which is private because it
    is intended to be used only by other member functions. (We don't want
    to give the user direct access to the underlying FILE structure in this
    class.)
    -->
    <para>
      El constructor por defecto pone a cero el puntero a
      <varname>FILE</varname> privado <varname>f</varname>. Pero ahora , antes de
      cualquier referencia a <function>f</function>, el valor debe ser comprobado
      para asegurarse que no es cero. Esto se consigue con
      <function>F()</function>, que es privado porque está pensado para ser usado
      solamente por otras funciones miembro. (No queremos dar acceso directo a
      usuarios a la estructura de <varname>FILE</varname> subyacente en esta
      clase).
    </para>

    <!--
    This approach is not a terrible solution by any means. It's quite
    functional, and you could imagine making similar classes for standard
    (console) I/O and for in-core formatting (reading/writing a piece of
    memory rather than a file or the console).
    -->
    <para>
      Este acercamiento no es terrible en ningún sentido. Es bastante
      funcional, y se puede imaginar haciendo clases similares para la E/S
      estándar (consola) y para los formateos en el core (leer/escribir un trozo
      de la memoria en vez de un fichero o la consola).
    </para>

    <!--
    The stumbling block is the runtime interpreter used for the variable
    argument list functions. This is the code that parses your format string
    at runtime and grabs and interprets arguments from the variable argument
    list. It's a problem for four reasons.
    -->
    <para>
      Este bloque de código es el interprete en tiempo de ejecución usado
      para las listas variables de argumentos. Este es el código que analiza el
      formato de su cadena en tiempo de ejecución y recoge e interpreta argumentos
      desde una lista variable de argumentos. Es un problema por cuatro
      razones:
    </para>
    <orderedlist>

    <!--
    1.  Even if you use only a fraction of the functionality of the
    interpreter, the whole thing gets loaded into your executable. So if you
    say printf("%c", 'x');, you'll get the whole package, including the
    parts that print floating-point numbers and strings. There's no
    standard option for reducing the amount of space used by the program.
    -->
	<listitem>
	  <para>
	    Incluso si solo se usa una fracción de la funcionalidad del
	    interprete, se carga todo en el ejecutable. Luego si quiere usar un
	    <code>printf("%c", 'x'); </code>, usted tendrá todo el paquete, incluido las
	    partes que imprimen números en coma flotante y cadenas. No hay una opción
	    estándar para reducir el la cantidad de espacio usado por el
	    programa.
	  </para>
	</listitem>
    <!--
    2.  Because the interpretation happens at runtime, you can't get rid of
    a performance overhead. It's frustrating because all the information is
    there in the format string at compile time, but it's not evaluated
    until runtime. However, if you could parse the arguments in the format
    string at compile time, you could make direct function calls that have
    the potential to be much faster than a runtime interpreter (although the
    printf( ) family of functions is usually quite well optimized).
    -->
	<listitem>
	  <para>
	    Como la interpretación pasa en tiempo de ejecución, no se
	    puede evitar un empeoramiento del rendimiento. Esto es frustrante por que
	    toda la información está allí, en el formato de la cadena, en tiempo de
	    compilación, pero no se evalua hasta la ejecución. Por otro lado, si se
	    pudieran analizar los argumentos en el formateo de la cadena durante la
	    compilación, se podrían hacer llamadas directas a funciones que tuvieran el
	    potencial de ser mucho más rápidas que un interprete en tiempo de ejecución
	    (aunque la familia de funciones de printf() acostumbran a estar bastante
	    bien optimizadas).
	  </para>
	</listitem>
    <!--
    3.  Because the format string is not evaluated until runtime, there can
    be no compile-time error checking. You're probably familiar with this
    problem if you've tried to find bugs that came from using the wrong
    number or type of arguments in a printf( ) statement. C++ makes a big
    deal out of compile-time error checking to find errors early and make
    your life easier. It seems a shame to throw type safety away for an I/O
    library, especially since I/O is used a lot.
    -->
	<listitem>
	  <para>
	    Como el formateo de la cadena no se evalua hasta la
	    ejecución, no se hace una comprobación de errores al compilar.
	    Probalblemente está familiarizado con este problema si ha intentado buscar
	    errores que provienen del uso de un número o tipo de argumentos incorrecto
	    en una sentencia <function>printf()</function>. C++ ayuda mucho a encontrar
	    rápidamente errores durante la compilación y hacerle la vida más fácil.
	    Parece una tonteria desechar la seguridad en los tipos de datos para la
	    libreria de E/S, especialmente cuando usamos intensivamente las E/S.
	  </para>
	</listitem>
    <!--
    4.  For C++, the most crucial problem is that the printf( ) family of
    functions is not particularly extensible. They're really designed to
    handle only the basic data types in C (char, int, float, double,
    wchar_t, char*, wchar_t*, and void*) and their variations. You might
    think that every time you add a new class, you could add overloaded
    printf( ) and scanf( ) functions (and their variants for files and
    strings), but remember, overloaded functions must have different types
    in their argument lists, and the printf( ) family hides its type
    information in the format string and in the variable argument list. For
    a language such as C++, whose goal is to be able to easily add new data
    types, this is an unacceptable restriction.
    -->
	<listitem>
	  <para>
	    Para C++, el más crucial de los problemas es que la familia
	    de funciones de printf() no es particularmente extensible. Esta realmente
	    diseñada para manejar solo los tipos básicos de datos en C (char, int,
	    float, double, wchar_t, char*, wchar_t*, y void*) y sus variaciones. Debe
	    estar pensando que cada vez que añade una nueva clase, puede añadir
	    funciones sobrecargadas printf() y scanf() (y sus variaciones para ficheros
	    y strings), pero recuerde: las funciones sobrecargadas deben tener
	    diferentes tipos de listas de argumentos, y la familia de funciones de
	    printf() esconde esa información en la cadena formateada y su lista variable
	    de argumentos. Para un lenguage como C++, cuya virtud es que se pueden
	    añadir fácilmente nuevos tipos de datos, esta es una restricción
	    inaceptable.
	  </para>
	</listitem>
    </orderedlist>
  </sect1>
  <sect1>
    <!-- : Iostreams to the rescue -->
    <title><classname>Iostreams</classname> al rescate</title>

    <!--
    These issues make it clear that I/O is one of the first priorities for
    the Standard C++ class libraries. Because 'hello, world' is the first
    program just about everyone writes in a new language, and because I/O is
    part of virtually every program, the I/O library in C++ must be
    particularly easy to use. It also has the much greater challenge that it
    must accommodate any new class. Thus, its constraints require that this
    foundation class library be a truly inspired design. In addition to
    gaining a great deal of leverage and clarity in your dealings with I/O
    and formatting, you'll also see in this chapter how a really powerful
    C++ library can work.
    -->
    <para>
      Estos problemas dejan claro que la E/S es una de las principales
      prioridades para la librería de clases estándar de C++. Como 'hello,
      worlod' es el primer programa que cualquiera escribe en un nuevo lenguaje,
      y porque la E/S es parte de virtualmente cualquier programa, la librería
      de E/S en C++ debe ser particularmente fácil de usar. Tembién tiene el
      reto mucho mayor de acomodar cualquier nueva clase. Por tanto, estas
      restricciones requieren que esta librería de clases fundamentales tengan
      un diseño realmente inspirado. Además de ganar en abstracción y claridad
      en su trabajo con las E/S y el formateo, en este capítulo verá lo potente
      que puede llegar a ser esta librería de C++.
    </para>

    <sect2>
      <!-- : Inserters and extractors -->
      <title>Insertadores y extractores </title>

      <!--
      A stream is an object that transports and formats characters of a fixed
      width. You can have an input stream (via descendants of the istream
      class), an output stream (with ostream objects), or a stream that does
      both simultaneously (with objects derived from iostream). The iostreams
      library provides different types of such classes: ifstream, ofstream,
      and fstream for files, and istringstream, ostringstream, and
      stringstream for interfacing with the Standard C++ string class. All
      these stream classes have nearly identical interfaces, so you can use
      streams in a uniform manner, whether you're working with a file,
      standard I/O, a region of memory, or a string object. The single
      interface you learn also works for extensions added to support new
      classes. Some functions implement your formatting commands, and some
      functions read and write characters without formatting.
      -->
      <para>
	Un <classname>stream</classname> es un objeto que transporta y
	formatea carácteres de un ancho fijo. Puede tener un
	<classname>stream</classname> de entrada (por medio de los descendientes
	de la clase <classname>istream</classname>), o un <classname>stream
	</classname>de salida (con objetos derivados de
	<classname>ostream</classname>), o un <classname>stream</classname> que
	hace las dos cosas simultáneamente (con objetos derivados de
	<classname>iostream</classname>). La librería
	<classname>iostream</classname> provee tipos diferentes de estas clases:
	<classname>ifstream</classname>, <classname>ofstream </classname>y
	<classname>fstream </classname>para ficheros, y
	<classname>istringstream</classname>,
	<classname>ostringstream</classname>, y
	<classname>stringstream</classname> para comunicarese con la clase
	<classname>string</classname> del estándar C++. Todas estas clases
	<classname>stream</classname> tiene prácticamente la misma interfaz, por
	lo que usted puede usar streams de manera uniforme, aunque esté trabajando
	con un fichero, la E/S estándar, una región de la memoria, o un objeto
	<classname>string</classname>. La única interfaz que aprenderá también
	funciona para extensiones añadidas para soportar nuevas clases. Algunas
	funciones implementan sus comandos de formateo, y algunas funciones leen y
	escriben caracteres sin formatear.
      </para>

      <!--
      The stream classes mentioned earlier are actually template
      specializations,[41] much like the standard string class is a
      specialization of the basic_string template. The basic classes in the
      iostreams inheritance hierarchy are shown in the following figure:
      -->
      <para>
	Las clases <classname>stream</classname> mencionadas antes son
	actualmente especializaciones de plantillas, muchas como la clase estándar
	<classname>string</classname> son especializaciones de la plantilla
	<classname>basic_string</classname>. Las clases básicas en la jerarquia de
	herencias son mostradas en la siguiente figura:
	<footnote>
          <para>
	    Explicadas en profundidad en el capítulo 5.
	  </para>
	</footnote>
      </para>


<!-- FIXME: figura -->


      <!--
      The ios_base class declares everything that is common to all streams,
      independent of the type of character the stream handles. These
      declarations are mostly constants and functions to manage them, some of
      which you'll see throughout this chapter. The rest of the classes are
      templates that have the underlying character type as a parameter. The
      istream class, for example, is defined as follows:
	-->
      <para>
	La clase <classname>ios_base</classname> declara todo aquello que
	es común a todos los <classname>stream</classname>, independientemente del
	tipo de carácteres que maneja el <classname>stream</classname>. Estas
	declaraciones son principalmente constantes y funciones para manejarlas,
	algunas de ella las verá a durante este capítulo. El resto de clases son
	plantillas que tienen un tipo de caracter subyacente como parámetro. La
	clase <classname>istream</classname>, por ejemplo, está definida a
	continuación:
      </para>


 <programlisting>
typedef basic_istream&lt;char&lt; istream;
</programlisting>


      <!--
      All the classes mentioned earlier are defined via similar type
      definitions. There are also type definitions for all stream classes
      using wchar_t (the wide character type discussed in Chapter 3) instead
      of char. We'll look at these at the end of this chapter. The basic_ios
      template defines functions common to both input and output, but that
      depends on the underlying character type (we won't use these much). The
      template basic_istream defines generic functions for input, and
      basic_ostream does the same for output. The classes for file and string
      streams introduced later add functionality for their specific stream
      types.
      -->
      <para>
	Todas las clases mencionadas antes estan definidas de manera
	similar. También hay definiciones de tipo para todas las clases de
	<classname>stream</classname> usando <type>wchar_t</type> (la anchura de
	este tipo de carácteres se discute en el Capítulo 3) en lugar de
	<type>char</type>. Miraremos esto al final de este capítulo. La plantilla
	<classname>basic_ios</classname> define funciones comunes para la entrada
	y la salida, pero depende del tipo de carácter subyacente (no vamos a
	usarlo mucho). La plantilla <classname>basic_istream</classname> define
	funciones genéricas para la entrada y <classname>basic_ostream</classname>
	hace lo mismo para la salida. Las clases para ficheros y streams de
	<classname>strings</classname> introducidas después añaden funcionalidad
	para sus tipos especificos de <classname>stream</classname>.
      </para>

      <!--
      In the iostreams library, two operators are overloaded to simplify the
      use of iostreams. The operator << is often referred to as an inserter
      for iostreams, and the operator >> is often referred to as an extractor.
      -->
      <para>
	En la librería de <classname>iostream</classname>, se han
	sobrecargado dos operadores para simplificar el uso de
	<classname>iostreams</classname>. El operador &lt;&lt; se denomina
	frecuentemente instertador para <classname>iostreams</classname>, y el
	operador &gt;&gt; se denomina frecuentemente extractor.
      </para>

      <!--
      Extractors parse the information that's expected by the destination
      object according to its type. To see an example of this, you can use the
      cin object, which is the iostream equivalent of stdin in C, that is,
      redirectable standard input. This object is predefined whenever you
      include the <iostream> header.
      -->
      <para>
	Los extractores analizan la información esperada por su objeto
	destino de acuerdo con su tipo. Para ver un ejemplo de esto, puede usar el
	objeto <varname>cin</varname>, que es el equivalente de
	<classname>iostream</classname> de <type>stdin</type> en C, esto es,
	entrada estándar redireccionable. Este objeto viene predefinido cuando
	usted incluye la cabecera <code>&lt;iostream&gt;.</code>
      </para>


<programlisting>
  int i;
  cin >> i;

  float f;
  cin >> f;

  char c;
  cin >> c;

  char buf[100];
  cin >> buf;
</programlisting>


      <!--
      There's an overloaded operator >> for every built-in data type. You can
      also overload your own, as you'll see later.
      -->
      <para>
	Existe un operador sobrecargado &gt;&gt; para cada tipo
	fundamental de dato. Usted también puede sobrecargar los suyos, como verá
	más adelante.
      </para>

      <!--
      To find out what you have in the various variables, you can use the cout
      object (corresponding to standard output; there's also a cerr object
      corresponding to standard error) with the inserter <<:
      -->
      <para>
	Para recuperar el contenido de las variables, puede usar el
	objeto <classname>cout</classname> (correspondiente con la salida
	estándar; también existe un objeto <classname>cerr</classname>
	correspondiente con la salida de error estándar) con el insertador
	&lt;&lt;:
      </para>


<programlisting>
  cout &lt;&lt; "i = ";
  cout &lt;&lt; i;
  cout &lt;&lt; "\n";
  cout &lt;&lt; "f = ";
  cout &lt;&lt; f;
  cout &lt;&lt; "\n";
  cout &lt;&lt; "c = ";
  cout &lt;&lt; c;
  cout &lt;&lt; "\n";
  cout &lt;&lt; "buf = ";
  cout &lt;&lt; buf;
  cout &lt;&lt; "\n";
</programlisting>



      <!--
      This is tedious and doesn't seem like much of an improvement over
      printf( ), despite improved type checking. Fortunately, the overloaded
      inserters and extractors are designed to be chained into a more complex
      expression that is much easier to write (and read):
      -->
      <para>
	Esto es tedioso y no parece ser un gran avance sobre<function>
	printf()</function>, aparte de la mejora en la comprobación de tipos.
	Afortunadamente, los insertadores y extractores sobrecargados están
	diseñados para ser encadenados dentro de expresiones más complejas que son
	mucho más fáciles de escribir (y leer):
      </para>

<programlisting>
  cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;
  cout &lt;&lt; "f = " &lt;&lt; f &lt;&lt; endl;
  cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;
  cout &lt;&lt; "buf = " &lt;&lt; buf &lt;&lt; endl;
</programlisting>


      <!--
      Defining inserters and extractors for your own classes is just a matter
      of overloading the associated operators to do the right things, namely:
      -->
      <para>
	Definir insertadores y extractores para sus propias clases es
	simplemente una cuestion de sobrecargar los operadores asociados para
	hacer el trabajo correcto, de la siguente manera:
      </para>

      <!--
      · Make the first parameter a non-const reference to the stream (istream
      for input, ostream for output).
      -->
      <para>
	Hacer del primer parámetro una referencia no constante al
	<classname>stream</classname> (<classname>istream</classname> para la
	entrada, <classname>ostream</classname> para la salida).
      </para>

      <!--
      · Perform the operation by inserting/extracting data to/from the stream
      (by processing the components of the object).
      -->
      <para>
	Realizar la operación de insertar/extraer datos hacia/desde
	el <classname>stream</classname> (procesando los componentes del
	objeto).
      </para>

      <!-- · Return a reference to the stream. -->
      <para>
	Retornar una referencia al <classname>stream</classname>
      </para>

      <!--
      The stream should be non-const because processing stream data changes
      the state of the stream. By returning the stream, you allow for chaining
      stream operations in a single statement, as shown earlier.
      -->
      <para>
	El <classname>stream</classname> no debe ser constante porque
	el procesado de los datos del <classname>stream</classname> cambian el
	estado del <classname>stream</classname>. Retornando el
	<classname>stream</classname>, usted permite el encadenado de operaciones
	en una sentencia individual, como se mostró antes.
      </para>

      <!--
      As an example, consider how to output the representation of a Date
      object in MM-DD-YYYY format. The following inserter does the job:
      -->
      <para>
	Como ejemplo, considere como representar la salida de un
	objeto <classname>Date</classname> en formato MM-DD-AAAA . El siguiente
	insertador hace este trabajo:
      </para>


<programlisting>
ostream&amp; operator&lt;&lt;(ostream&amp; os, const Date&amp; d) {
  char fillc = os.fill('0');
  os &lt;&lt; setw(2) &lt;&lt; d.getMonth() &lt;&lt; '-'
     &lt;&lt; setw(2) &lt;&lt; d.getDay() &lt;&lt; '-'
     &lt;&lt; setw(4) &lt;&lt; setfill(fillc) &lt;&lt; d.getYear();
  return os;
}
</programlisting>

      <!--
      This function cannot be a member of the Date class because the left
      operand of the << operator must be the output stream. The fill( ) member
      function of ostream changes the padding character used when the width of
      an output field, determined by the manipulator setw( ), is greater than
      needed for the data. We use a '0' character so that months preceding
      October will display a leading zero, such as '09' for September. The
      fill( ) function also returns the previous fill character (which
      defaults to a single space) so that we can restore it later with the
      manipulator setfill( ). We discuss manipulators in depth later in this
      chapter.
      -->
      <para>
	Esta función no puede ser miembro de la clase
	<classname>Date</classname> por que el operando de la izquierda &lt;&lt;
	debe ser el <classname>stream</classname> de salida. La función miembro
	<function>fill()</function> de <classname>ostream</classname> cambia el
	carácter de relleno usado cuando la anchura del campo de salida,
	determinada por el manipulador <function>setw()</function>, es mayor que
	el necesitado por los datos. Usamos un caracter '0' ya que los meses
	anteriores a Octubre mostrarán un cero en primer lugar, como '09' para
	Septiembre. La funcion <function>fill()</function> también retorna el
	caracter de relleno anterior (que por defecto es un espacio en blanco)
	para que podamos recuperarlo después con el manipulador
	<function>setfill()</function>. Discutiremos los manipuladores en
	profundidad más adelante en este capítulo.
      </para>

      <!--
      Extractors require a little more care because things can go wrong with
      input data. The way to signal a stream error is to set the stream's
      fail bit, as follows:
      -->
      <para>
	Los extractores requieren algo más cuidado porque las cosas
	pueden ir mal con los datos de entrada. La manera de avisar sobre errores
	en el <classname>stream</classname> es activar el bit de error del
	<classname>stream</classname>, como se muestra a continuación:
      </para>


<programlisting>
istream&amp; operator>>(istream&amp; is, Date&amp; d) {
  is >> d.month;
  char dash;
  is >> dash;
  if(dash != '-')
    is.setstate(ios::failbit);
  is >> d.day;
  is >> dash;
  if(dash != '-')
    is.setstate(ios::failbit);
  is >> d.year;
  return is;
}
</programlisting>

      <!--
      When an error bit is set in a stream, all further streams operations are
      ignored until the stream is restored to a good state (explained
      shortly). That's why the code above continues extracting even if
      ios::failbit gets set. This implementation is somewhat forgiving in that
      it allows white space between the numbers and dashes in a date string
      (because the >> operator skips white space by default when reading
      built-in types). The following are valid date strings for this
      extractor:
      -->
      <para>
	Cuando se activa el bit de error en un
	<classname>stream</classname>, todas las operaciones posteriores serán
	ignoradas hasta que el <classname>stream</classname> sea devuelto a un
	estado correcto (explicado brevemente). Esto es porque el código de arriba
	continua extrayendo incluso is <code>ios::failbit</code> está activado.
	Esta implementación es poco estricta ya que permite espacios en blanco
	entre los numeros y guiones en la cadena de la fecha (por que el operador
	&gt;&gt; ignora los espacios en blanco por defecto cuado lee tipos
	fundamentales). La cadena de fecha a continuación es válida para este
	extractor:
      </para>


<programlisting>
"08-10-2003"
"8-10-2003"
"08 - 10 - 2003"
</programlisting>


      <!-- but these are not: -->
      <para>
	Pero estas no:
      </para>


<programlisting>
"A-10-2003" // No alpha characters allowed
"08%10/2003" // Only dashes allowed as a delimiter
</programlisting>


      <!--
      We'll discuss stream state in more depth in the section 'Handling
      stream errors' later in this chapter.
      -->
      <para>
	Discutiremos los estados de los <classname>stream</classname>
	en mayor profundidad en la sección 'Manejar errores de
	<classname>stream</classname>' después en este capítulo.
      </para>

    </sect2>
    <sect2>
      <!-- : Common usage -->
      <title>Uso común</title>

      <!--
      As the Date extractor illustrated, you must be on guard for erroneous
      input. If the input produces an unexpected value, the process is skewed,
      and it's difficult to recover. In addition, formatted input defaults to
      white space delimiters. Consider what happens when we collect the code
      fragments from earlier in this chapter into a single program:
      -->
      <para>
	Como se ilustraba en el extractor de
	<classname>Date</classname>, debe estar alerta por las entradas erróneas.
	Si la entrada produce un valor inesperado, el proceso se tuerce y es
	difícil de recuperar. Además, por defecto, la entrada formateada está
	delimitada por espacios en blanco. Considere que ocurre cuando recogemos
	los fragmentos de código anteriores en un solo programa:
      </para>


<programlisting>
//: V2C04:Iosexamp.cpp {RunByHand}
</programlisting>

      <!-- and give it the following input: -->
      <para>
	y le proporcionamos la siguiente entrada:
      </para>


<programlisting>
12 1.4 c this is a test
</programlisting>


      <!-- We expect the same output as if we gave it -->
      <para>
	esperamos la misma salida que si le hubieramos proporcionado esto:
      </para>


<programlisting>
12
1.4
c
this is a test
</programlisting>


      <!-- but the output is, somewhat unexpectedly -->
      <para>
	pero la salida es algo inesperado
      </para>


<programlisting>
i = 12
f = 1.4
c = c
buf = this 0xc
</programlisting>


      <!--
      Notice that buf got only the first word because the input routine looked
      for a space to delimit the input, which it saw after 'this.' In
      addition, if the continuous input string is longer than the storage
      allocated for buf, we overrun the buffer.
      -->
      <para>
	Nótese que <varname>buf</varname> solo tiene la primera
	palabra porque la rutina de entrada busca un espacio que delimite la
	entrada, que es el que se encuentra después de 'tihs.' Además, si la
	entrada continua de datos es mayor que el espacio reservado por
	<varname>buf</varname>, sobrepasamos los limites del buffer.
      </para>

      <!--
      In practice, you'll usually want to get input from interactive programs
      a line at a time as a sequence of characters, scan them, and then
      perform conversions once they're safely in a buffer. This way you don'
      t need to worry about the input routine choking on unexpected data.
      -->
      <para>
	En la práctica, usualmente deseará obtener la entrada desde
	programas interactivos, una linea cada vez como secuencia de carácteres,
	leerla, y después hacer las conversiones necesarias hasta que estén
	seguras en un buffer. De esta manera no deberá preocuparse por la rutina
	de entrada fallando por datos inesperados.
      </para>

      <!--
      Another consideration is the whole concept of a command-line
      interface. This made sense in the past when the console was little more
      than a glass typewriter, but the world is rapidly changing to one where
      the graphical user interface (GUI) dominates. What is the meaning of
      console I/O in such a world? It makes much more sense to ignore cin
      altogether, other than for simple examples or tests, and take the
      following approaches:
      -->
      <para>
	Otra consideración es todo el concepto de interfaz de línea de
	comandos. Esto tenia sentido en el pasado cuando la consola era la única
	interfaz con la máquina, pero el mundo está cambiando rápidamente hacia
	otro donde la interfaz gráfica de usuario (GUI) domina. ¿Cual es el
	sentido de la E/S por consola en este mundo? Esto le da mucho más sentido
	a ignorar <classname>cin </classname>en general, salvo para ejemplos
	simples y tests, y hacer los siguientes acercamientos:
      </para>

     <orderedlist>
      <!--
      1.  If your program requires input, read that input from a file?you'll
      soon see that it's remarkably easy to use files with
      iostreams. Iostreams for files still works fine with a GUI.
      -->
      <listitem>
	<para>
	  Si su programa requiere entrada, ¿leer esta entrada desde
	  un fichero? Pronto verá que es remarcablemente fácil usar ficheros con
	  <classname>iostream</classname>. <classname>Iostream</classname> para
	  ficheros todavia funciona perfectamente con una GUI.
	</para>
      </listitem>
      <!--
      2.  Read the input without attempting to convert it, as we just
      suggested. When the input is some place where it can't foul things up
      during conversion, you can safely scan it.
      -->
      <listitem>
	<para>
	  Leer la entrada sin intentar convertirla, como hemos
	  sugerido. Cuando la entrada es algun sitio donde no podemos arriesgarnos
	  durante la conversión, podemos escanearla de manera segura.
	</para>
      </listitem>

      <!--
      3.  Output is different. If you're using a GUI, cout doesn't
      necessarily work, and you must send it to a file (which is identical to
      sending it to cout) or use the GUI facilities for data
      display. Otherwise it often makes sense to send it to cout. In both
      cases, the output formatting functions of iostreams are highly useful.
      -->
      <listitem>
	<para>
	  La salida es diferente. Si está usando una interfaz
	  gráfica, <classname>cout</classname> no necesariamente funciona, y usted
	  debe mandarlo a un fichero (que es indéntico a mandarlo a un
	  <classname>cout</classname>) o usar los componentes del GUI para mostrar
	  los datos. En cualquier otra situacion, a menudo tiene sentido mandarlo a
	  <classname>cout</classname>. En ambos casos, la funciones de formateo de
	  la salida de <classname>iostream</classname> son muy útiles.
	</para>
      </listitem>
     </orderedlist>
      <!--
      Another common practice saves compile time on large projects. Consider,
      for example, how you would declare the Date stream operators introduced
      earlier in the chapter in a header file. You only need to include the
      prototypes for the functions, so it's not really necessary to include
      the entire <iostream> header in Date.h. The standard practice is to only
      declare classes, something like this:
      -->
      <para>
	Otra práctica común ahorra tiempo en compilaciones largas. Consideres, por
	ejemplo, cómo quiere declarar los operadores del stream Date introducidos
	antes en el capítulo en un fichero de cabecera. Usted solo necesita incluir los
	prototipos para las funciones, luego no es necesario incluir la cabecera entera
	de &lt;iostream&gt; en Date.h. La práctica estándar es declarar solo las clases,
	algo como esto:
      </para>


<programlisting>
class ostream;
</programlisting>

      <!--
      This is an age-old technique for separating interface from
      implementation and is often called a forward declaration (and ostream at
      this point would be considered an incomplete type, since the class
      definition has not yet been seen by the compiler).
      -->
      <para>
	Esta es una vieja tecnica para separar la interfaz de la implementación y
	a menudo la llaman declaración avanzada( y <classname>ostream</classname> en este punto debe ser
	considerada un tipo incompleto, ya que la definición de la clase no ha sido vista
	todavia por el compilador).
      </para>

      <!-- This will not work as is, however, for two reasons: -->
      <para>
	Esto con funcionará asi, igualmente, por dos razones:
      </para>

      <!-- 1.  The stream classes are defined in the std namespace. -->
      <para>
	Las clases stream estan definidas en el espacio de nombres <varname>std</varname>.
      </para>

      <!-- 2.  They are templates. -->
      <para>
	Son plantillas.
      </para>

      <!--
      The proper declaration would be:  -->
      <para>
	La declaración correcta debería ser:
      </para>


<programlisting>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT> >
    class basic_ostream;
  typedef basic_ostream&lt;char> ostream;
}
</programlisting>

      <!--
      (As you can see, like the string class, the streams classes use the
      character traits classes mentioned in Chapter 3). Since it would be
      terribly tedious to type all that for every stream class you want to
      reference, the standard provides a header that does it for you:
      -->
      <para>
	(Como puede ver, como las clase string, las clases stream usan las clases
	de rasgos de caracter mencionadas en el Capítulo 3). Como  puede ser terriblemente
	tedioso darle un tipo a todas las clases stream a las que quiere referenciar, el
	estándar provee una cabecera que lo hace por usted:
      </para>


<programlisting>
// Date.h
#include &lt;iosfwd>

class Date {
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;,
                                  const Date&amp;);
  friend std::istream&amp; operator>>(std::istream&amp;, Date&amp;);
  // Etc.
</programlisting>

    </sect2>
    <sect2>
      <!-- : Line?oriented input -->
      <title>Entrada orientada a líneas</title>

      <!-- To grab input a line at a time, you have three choices: -->
      <para>
	Para recoger la entrada de línea en línea, tiene tres opciones:
      </para>

      <!-- · The member function get( ) -->
      <para>
	La función miembre <function>get()</function>
      </para>

      <!-- · The member function getline( ) -->
      <para>
	La función miembro <function>getline()</function>
      </para>

      <!-- · The global function getline( ) defined in the <string> header -->
      <para>
	La función global <function>getline()</function> definida en la cabecera &lt;string&gt;
      </para>

      <!-- The first two functions take three arguments: -->
      <para>
	Las primeras dos funciones toman tres parámentros:
      </para>

      <!-- 1.  A pointer to a character buffer in which to store the result. -->
      <para>
	Un puntero a un buffer de carácters donde se guarda el resultado.
      </para>

      <!-- 2.  The size of that buffer (so it's not overrun). -->
      <para>
	El tamaño de este buffer (para no sobrepasarlo).
      </para>

      <!-- 3.  The terminating character, to know when to stop reading input. -->
      <para>
	El carácter de finalización, para conocer cuando parar de leer la entrada.
      </para>

      <!--
      The terminating character has a default value of '\n', which is what you'
      ll usually use. Both functions store a zero in the result buffer when
      they encounter the terminating character in the input.
      -->
      <para>
	El carácter de finalización tiene un valor por defecto de '\n', que es el
	que usted usará usualmente. Ambas funciones almacenan un cero en el buffer
	resultante cuando encuentran el caracter de terminación en la entrada.
      </para>

      <!--
      So what's the difference? Subtle, but important: get( ) stops when it
      sees the delimiter in the input stream, but it doesn't extract it from
      the input stream. Thus, if you did another get( ) using the same
      delimiter, it would immediately return with no fetched
      input. (Presumably, you either use a different delimiter in the next
      get( ) statement or a different input function.) The getline( )
      function, on the other hand, extracts the delimiter from the input
      stream, but still doesn't store it in the result buffer.
      -->
      <para>
	Entonces, ¿cual es la diferencia? Sutil pero importante:
	<function>get()</function> se detiene cuando vee el delimitador en el
	stream de entrada, pero no lo extrae de <classname>stream</classname>
	de entrada. Entonces, si usted hace otro <function>get()</function>
	usando el mismo delimitador, retornará inmediatamente sin ninguna entrada
	contenida. (Presumiblemente, en su lugar usará un delimitador diferente
	en la siguiente sentencia <function>get()</function> o una función de
	entrada diferente.) La función <function>getline()</function>, por el
	contrario, extrae el delimitador del <classname>stream</classname> de
	entrada, pero tampoco lo almacena en el buffer resultante.
      </para>

      <!--
      The getline( ) function defined in <string> is convenient. It is not a
      member function, but rather a stand-alone function declared in the
      namespace std. It takes only two non-default arguments, the input stream
      and the string object to populate. Like its namesake, it reads
      characters until it encounters the first occurrence of the delimiter
      ('\n' by default) and consumes and discards the delimiter. The advantage
      of this function is that it reads into a string object, so you don't
      need to worry about buffer size.
      -->
      <para>
	La función <function>getline()</function> definida en &lt;string&gt; es conveniente.
	No es una función miembro, sino una función aislada declarada en el espacio
	de nombres <code>std</code>. Sólo toma dos parámetros que no son por defecto, el
	<classname>stream</classname> de entrada y el objeto <classname>string</classname>
	para rellenar. Como su propio nombre dice, lee carácteres hasta que encuentra la primera
	aparición del delimitador ('\n' por defecto) y consume y descarta el delimitador.
	La ventaja de esta función es que lo lee dentro del objeto <classname>string</classname>,
	así que no se tiene que preocuparse del tamaño del buffer.
      </para>

      <!--
      Generally, when you're processing a text file that you read a line at a
      time, you'll want to use one of the getline( ) functions.
      -->
      <para>
	Generalmente, cuando esta procesando un fichero de texto en el que usted
	quiere leer de línea en línea, usted querra usar una de las funciones
	<function>getline()</function>. Versiones sobrecargadas de <function>get()</function>
      </para>


      <sect3>
      <!--
	   Overloaded versions of get( )
	-->
      <title>
	Versiones sobrecargadas de <function>get()</function>
      </title>

      <!--
      The get( ) function also comes in three other overloaded versions: one
      with no arguments that returns the next character using an int return
      value; one that stuffs a character into its char argument using a
      reference; and one that stores directly into the underlying buffer
      structure of another iostream object. The latter is explored later in
      the chapter.
      -->
	<para>
	  La función <function>get()</function> también viene en tres
	  versiones sobrecargadas: una sin argumentos que retorna el
	  siguiente carácter usando un valor de retorno
	  <type>int</type>; una que recoge un carácter dentro de su
	  argumento <type>char</type> usando una referencia; y una que
	  almacena directamente dentro del buffer subyacente de otro
	  objeto iostream. Este último se explora después en el
	  capítulo.
	</para>
      </sect3>


      <sect3>
      <!--
	Reading raw bytes
	-->
      <title>
	Leyendo bytes sin formato
      </title>

      <!--
      If you know exactly what you're dealing with and want to move the bytes
      directly into a variable, an array, or a structure in memory, you can
      use the unformatted I/O function read( ). The first argument for this
      function is a pointer to the destination memory, and the second is the
      number of bytes to read. This is especially useful if you've previously
      stored the information to a file, for example, in binary form using the
      complementary write( ) member function for an output stream (using the
      same compiler, of course). You'll see examples of all these functions
      later.
      -->
      <para>
	Si usted sabe exactamente con que esta tratando y quiere mover
	los bytes directamente dentro de una variable, un array, o una
	estructura de memoria, puede usar la función de E/S sin
	formatear <function>read()</function>. El primer argumento
	para esta función es un puntero a la destinación en memoria, y
	el segundo es el número de bytes para leer. Es especialmente
	útil su usted ha almacenado previamente la información a un
	fichero, por ejemplo, en formato binario usando la función
	miembro complementaria <function>write()</function> para el
	<classname>stream</classname> de salida (usando el mismo
	compilador, por supuesto). Verá ejemplos de todas estas
	funciones más adelante.
      </para>
      </sect3>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Handling stream errors -->
    <title>Manejo errores de <classname>stream</classname></title>

    <!--
    The Date extractor shown earlier sets a stream's fail bit under certain
    conditions. How does the user know when such a failure occurs? You can
    detect stream errors by either calling certain stream member functions
    to see if an error state has occurred, or if you don't care what the
    particular error was, you can just evaluate the stream in a Boolean
    context. Both techniques derive from the state of a stream's error
    bits.  Stream state
    -->
    <para>
      El extractor de <classname>Date</classname> mostrado antes
      activa el bit de error de un <classname>stream</classname> bajo
      ciertas condiciones. ¿Como sabe un usuario que este error ha
      ocurrido? Puede detectar errores del
      <classname>stream</classname> llamando a ciertas funciones
      miembro del stream para ver si tenemos un estado de error, o si
      a usted no le preocupa qué tipo de error ha pasado, puede
      evaluar el <filename>stream</filename> en un contexto
      Booleano. Ambas técnicas derivan del estado del bit de error de
      un <classname>stream</classname>.
    </para>

    <sect2>
      <title>Estados del <classname>stream</classname></title>
      <!--
      The ios_base class, from which ios derives,[42] defines four flags that
      you can use to test the state of a stream:
      -->
      <para>
	La clase <classname>ios_base</classname>, desde la que
	<classname>ios</classname> deriva,<footnote><para>Por esa
	razón usted puede escribir <classname>ios::failbit</classname>
	en lugar de <classname>ios_base::failbit</classname> para
	ahorrar pulsaciones.</para></footnote>define cuatro banderas
	que puede usar para comprobar el estado de un
	<classname>stream</classname>:
      </para>

    <!-- Flag -->
    <para>
      Bandera
    </para>

    <!-- Meaning -->
    <para>
      Significado
    </para>

    <!-- badbit -->
    <para>
     <code>badbit</code>
    </para>

    <!--
    Some fatal (perhaps physical) error occurred. The stream should be
    considered unusable.
    -->
    <para>
      Algún error fatal (quizás físico) ha ocurrido. El
      <classname>stream</classname> debe considerarse no usable.
    </para>

    <!-- eofbit -->
    <para>
      <code>eofbit</code>
    </para>

    <!--
    End-of-input has occurred (either by encountering the physical end of a
    file stream or by the user terminating a console stream, such as with
    Ctrl-Z or Ctrl?D).
    -->
    <para>
      Ha ocurrido un final de entrada (ya sea por haber encontrado un final físico de un <classname>stream</classname> de fichero o por que el usuario ha terminado el <classname>stream</classname> de consola, (usando un Ctrl-Z o Ctrl-D).
    </para>

    <!-- failbit -->
    <para>
      <code>failbit</code>
    </para>

    <!--
    An I/O operation failed, most likely because of invalid data (e.g.,
    letters were found when trying to read a number). The stream is still
    usable. The failbit flag is also set when end-of-input occurs.
    -->
    <para>
      Una operación de E/S ha fallado, casi seguro que por datos inválidos (p.e. encontrar
      letras cuando se intentaba leer un número). El <classname>stream</classname> todavía se
      puede usar. El <code>failbit</code> también se activa cuando ocurre un final de entrada.
    </para>

    <!-- goodbit -->
    <para>
      <code>goodbit</code>
    </para>

    <!-- All is well; no errors. End-of-input has not yet occurred. -->
    <para>
      Todo va bien; no hay errores. La final de la entrada todavía no ha ocurrido.
    </para>

    <!--
    You can test whether any of these conditions have occurred by calling
    corresponding member functions that return a Boolean value indicating
    whether any of these have been set. The good( ) stream member function
    returns true if none of the other three bits are set. The eof( )
    function returns true if eofbit is set, which happens with an attempt to
    read from a stream that has no more data (usually a file). Because
    end-of-input happens in C++ when trying to read past the end of the
    physical medium, failbit is also set to indicate that the 'expected'
    data was not successfully read. The fail( ) function returns true if
    either failbit or badbit is set, and bad( ) returns true only if the
    badbit is set.
    -->
    <para>
      Puede comprobar si alguna de estas condiciones ha ocurrido
      llamando a la función miembro correspondiente que retorna un
      valor Booleano indicando cual de estas ha sido activada.  La
      función miembro de <classname>stream </classname>
      <function>good()</function> retorna cierto si ninguno de los
      otros tres bits se han activado. La función
      <function>eof()</function> retorna cierto si <code>eofbit</code>
      está activado, que ocurre con un intento de leer de un
      <classname>stream</classname> que ya no tiene datos
      (generalmente un fichero). Como el final de una entrada ocurre
      en C++ cuando tratamos de leer pasado el final del medio físico,
      <code>failbit</code> también se activa para indicar que los
      datos esperados no han sido correctamente leídos. La función
      <function>fail()</function> retorna cierto si
      <code>failbit</code> o <code>badbit</code> están activados, y
      <function>bad()</function> retorna cierto solo si
      <code>badbit</code> está activado.
    </para>

    <!--
    Once any of the error bits in a stream's state are set, they remain
    set, which is not always what you want. When reading a file, you might
    want to reposition to an earlier place in the file before end-of-file
    occurred. Just moving the file pointer doesn't automatically reset
    eofbit or failbit; you must do it yourself with the clear( ) function,
    like this: myStream.clear(); // Clears all error bits
    -->
    <para>
      Una vez alguno de los bit de error de un <classname>stream</classname> se activa,
      permanece activo, cosa que no siempre es lo que se quiere. Cuando leemos un fichero,
      usted puede querer colocarse en una posición anterior en el fichero antes de su final.
      Simplemenete moviendo el puntero del fichero no se desactiva el <code>eofbit</code> o
      el <code>failbit</code>; debe hacerlo usted mismo con la función <function>clear()</function>,
      haciendo algo así:
    </para>

    <programlisting>
      myStream.clear(); // Clears all error bits
    </programlisting>

    <!--
    After calling clear( ), good( ) will return true if called
    immediately. As you saw in the Date extractor earlier, the setstate( )
    function sets the bits you pass it. It turns out that setstate( ) doesn'
    t affect any other bits?if they're already set, they stay set. If you
    want to set certain bits but at the same time reset all the rest, you
    can call an overloaded version of clear( ), passing it a bitwise
    expression representing the bits you want to set, as in:
    myStream.clear(ios::failbit | ios::eofbit);
    -->
    <para>
      Después de llamar a <function>clear()</function>,
      <function>good()</function> retornará cierto si es llamada
      inmediatamente. Como vió en el extractor de
      <classname>Date</classname> antes, la función
      <function>setstate()</function> activa los bits que usted le
      pasa.¿Eso significa que setstate no afecta a los otros bits? Si
      ya esta activo, permanece activo. Si usted quiere activar
      ciertos bits pero en el mismo momento, desactivar el resto,
      usted puede llamar una versión sobrecargada de
      <function>clear()</function>, pasandole una expresion binaria
      representando los bits que quiere que se activen, así:
    </para>

    <programlisting>
      myStream.clear(ios::failbit | ios::eofbit);
    </programlisting>

    <!--
    Most of the time you won't be interested in checking the stream state
    bits individually. Usually you just want to know if everything is
    okay. This is the case when you read a file from beginning to end; you
    just want to know when the input data is exhausted. You can use a
    conversion function defined for void* that is automatically called when
    a stream occurs in a Boolean expression. Reading a stream until
    end-of-input using this idiom looks like the following:
    -->
    <para>
      La mayoría del tiempo usted no estará interesado en comprobar los bits de estado
      del <classname>stream</classname> individualmente. Generalmente usted simplemente
      quiere conocer si todo va bien. Ese es el caso cuando quiere leer un fichero del
      principio al final; usted quiere saber simplemente cuando la entrada de datos se
      ha agotado. Puede usar una conversion de la función definida para <type>void*</type>
      que es automáticamente llamada cuando un <classname>stream</classname> esta en una
      expresión booleana. Leer un <classname>stream</classname> hasta el final de la entrada
      usando este idioma se parece a lo siguiente:
    </para>

<programlisting>
int i;
while(myStream >> i)
  cout &lt;&lt; i &lt;&lt; endl;
</programlisting>

    <!--
    Remember that operator>>( ) returns its stream argument, so the while
    statement above tests the stream as a Boolean expression. This
    particular example assumes that the input stream myStream contains
    integers separated by white space. The function ios_base::operator
    void*( ) simply calls good( ) on its stream and returns the result.[43]
    Because most stream operations return their stream, using this idiom is
    convenient.
    -->
    <para>
      Recuerde que <function>operator&gt;&gt;()</function> retorna su
      argumento <classname>stream</classname>, así que la sentencia
      <code>while</code> anterior comprueba el
      <classname>stream</classname> como una expresión booleana. Este
      ejemplo particular asume que el <classname>stream</classname> de
      entrada myStream contiene enteros separados por un espacio en
      blanco. La función <function>ios_base::operator
      void*()</function> simplemente llama a
      <function>good()</function> en su <classname>stream</classname>
      y retorna el resultado.<footnote><para>Es común el uso de
      <function>operator void*()</function> en vez de
      <function>operator bool()</function> porque las conversiones
      implícitas de booleano a entero pueden causar sorpresas; pueden
      emplazarle incorrectamente un stream en un contexto donde una
      conversion a integer puede ser aplicada. La función
      <function>operator void*()</function> solo será llamada
      implícitamente en el cuerpo de una expresión
      booleana.</para></footnote> Como la mayoría de operaciones de
      <classname>stream</classname> retornan su
      <classname>stream</classname>, usar ese idioma es conveniente.
    </para>
    </sect2>

    <sect2>
    <!--Streams and exceptions -->
    <title>Streams y excepciones</title>
    <!--
    Iostreams existed as part of C++ long before there were exceptions, so
    checking stream state manually was just the way things were done. For
    backward compatibility, this is still the status quo, but modern
    iostreams can throw exceptions instead. The exceptions( ) stream member
    function takes a parameter representing the state bits for which you
    want exceptions to be thrown. Whenever the stream encounters such a
    state, it throws an exception of type std::ios_base::failure, which
    inherits from std::exception.
    -->
    <para>
      Los <classname>iostream</classname> han existido como parte de
      C++ mucho antes que hubieran excepciones, luego comprobar el
      estado de un <classname>stream</classname> manualmente era la
      manera en que se hacia. Para mantener la compatibilidad, este es
      todavía el status quo, pero los modernos
      <classname>iostream</classname> pueden lanzar excepciones en su
      lugar. La función miembro de <classname>stream</classname>
      <function>exceptions()</function> toma un parámetro
      representando los bits de estado para los que usted quiere
      lanzar la excepcion. Siempre que el stream encuentra este
      estado,este lanza una excepcion de tipo
      <function>std::ios_base::failure</function>, que hereda de
      <function>std::exception</function>.
    </para>

    <!--
    Although you can trigger a failure exception for any of the four stream
    states, it's not necessarily a good idea to enable exceptions for all
    of them. As Chapter 1 explains, use exceptions for truly exceptional
    conditions, but end-of-file is not only not exceptional?it's expected!
    For that reason, you might want to enable exceptions only for the errors
    represented by badbit, which you would do like this:

    -->
    <para>
      Aunque usted puede disparar una excepción para alguno de los
      cuatro estados de un <classname>stream</classname>, no es
      necesariamente una buena idea activar las excepciones para cada
      uno de ellos. Tal como explica el Capítulo uno, se usan las
      excepciones para condiciones verdaderamente excepcionales, ¡pero
      el final de un fichero no solo no es excepcional! ¡Es lo que se
      espera! Por esta razón, solo debe querer activar las excepciones
      para errores representados por <code>badbit</code>, que deberia
      ser como esto:
    </para>

    <programlisting>
      myStream.exceptions(ios::badbit);
    </programlisting>

    <!--
    You enable exceptions on a stream-by-stream basis, since exceptions( )
    is a member function for streams. The exceptions( ) function returns a
    bitmask[44] (of type iostate, which is some compiler-dependent type
    convertible to int) indicating which stream states will cause
    exceptions. If those states have already been set, an exception is
    thrown immediately. Of course, if you use exceptions in connection with
    streams, you had better be ready to catch them, which means that you
    need to wrap all stream processing with a try block that has an
    ios::failure handler. Many programmers find this tedious and just check
    states manually where they expect errors to occur (since, for example,
    they don't expect bad( ) to return true most of the time anyway). This
    is another reason that having streams throw exceptions is optional and
    not the default. In any case, you can choose how you want to handle
    stream errors. For the same reasons that we recommend using exceptions
    for error handling in other contexts, we do so here.
    -->
    <para>
      Usted activa las excepciones <classname>stream</classname> por <classname>stream</classname>, ya que <function>exceptions()</function> es una función miembro para los <classname>streams</classname>. La función <function>exceptions()</function> retorna una máscara de bits <footnote><para>un tipo integral usado para alojar bits aislados.</para></footnote> (de tipo <classname>iostate</classname>, que es un tipo dependiente del compilador convertible a int) indicando que estados de stream causarán excepciones. Si estos estados ya han sido activados, la excepción será lanzada inmediatamente. Por supuesto, si usa excepciones en conexiones a streams, debería estar preparado paracapturarlas, lo que quiere decir que necesita envolver todos los stream bon bloques try que tengan un manejador ios::failure. Muchos programadores encuentran tedioso y simplemente comprueban manualmente donde esperan encontrar errores (ya que, por ejemplo, no esperan encontrar bad() al retornar true la mayoria de veces). Esto es otra razón que tienen los streams para que el lanzamiento de excepciones sea opcional y no por defecto. en cualquier caso, usted peude elegir como quiere manejar los errores de stream. Por las mismas razones que recomendamos el uso de excepciones para el manejo de rrores en otros contextos, lo hacemos aqui.
    </para>
    </sect2>

  </sect1>
  <sect1>
    <!-- : File iostreams -->
    <title>Iostreams de fichero</title>

    <!--
    Manipulating files with iostreams is much easier and safer than using
    stdio in C. All you do to open a file is create an object?the
    constructor does the work. You don't need to explicitly close a file
    (although you can, using the close( ) member function) because the
    destructor will close it when the object goes out of scope. To create a
    file that defaults to input, make an ifstream object. To create one that
    defaults to output, make an ofstream object. An fstream object can do
    both input and output.
    -->
    <para>
      Manipular ficheros con <classname>iostream</classname> es mucho más fácil y seguro
      que usar <code>stdio</code> en C. Todo lo que tiene que hacer es crear un objeto - el
      constructor hace el trabajo. No necesita cerrar el fichero explícitamente (aunque puede,
      usando la función miembro <function>close()</function>) porque el destructor lo cerrará cuando
      el objeto salga del ámbito. Para crear un fichero que por defecto sea de entrada, cree un objeto
      <classname>ifstream</classname> . Para crear un fichero que por defecto es de salida, cree un
      objeto <classname>ofstream</classname>. Un <classname>fstream</classname> puede hacer ambas cosas.
    </para>

    <!--
    The file stream classes fit into the iostreams classes as shown in the
    following figure:
    -->
    <para>
      Las clases de <classname>stream</classname> de fichero encajan dentro de las clases <classname>iostream</classname> como
      se muestra en la siguiente figura:
    </para>

    <!--
    As before, the classes you actually use are template specializations
    defined by type definitions. For example, ifstream, which processes
    files of char, is defined as
    -->
    <para>
      Como antes, las clases que usted usa en realidad son especializaciones de
      plantillas definidas por definiciones de tipo. Por ejemplo, <classname>ifstream</classname>,
      que procesa ficheros de <type>char</type>, es definida como:
    </para>

    <!-- typedef basic_ifstream<char> ifstream; -->
    <programlisting>typedef basic_ifstream&lt;char&gt; ifstream;</programlisting>

    <sect2>
      <!-- : A File-Processing Example -->
      <title>Un ejemplo de procesado de fichero.</title>

      <!--
      Here's an example that shows many of the features discussed so
      far. Notice the inclusion of <fstream> to declare the file I/O
      classes. Although on many platforms this will also include <iostream>
      automatically, compilers are not required to do so. If you want portable
      code, always include both headers.
      -->
      <para>
	Aqui tiene un ejemplo que muestra algunas de las características discutidas antes. Nótese
	que la inclusión de &lt;fstream&gt; para delarar las clases de fichero de E/S. Aunque en muchas
	plataformas esto también incluye &lt;iostream&gt; automáticamente, los compiladores no están
	obligados a hacer esto. Si usted quiere compatibilidad, incluya siempre ambas cabeceras.
      </para>

//: V2C04:Strfile.cpp


      <!--
      The creation of both the ifstream and ofstream are followed by an
      assure( ) to guarantee the file was successfully opened. Here again the
      object, used in a situation where the compiler expects a Boolean result,
      produces a value that indicates success or failure.
      -->
      <para>
	La creación tanto del ifstream como del ofstream están seguidas de un
	<function>assure()</function> para garantizar que el fichero ha sido abierto
	exitosamente. El objeto resultante, usado en una situación donde el compilador
	espera un resultado booleano, produce un valor que indica éxito o fracaso.
      </para>

      <!--
      The first while loop demonstrates the use of two forms of the get( )
      function. The first gets characters into a buffer and puts a zero
      terminator in the buffer when either SZ-1 characters have been read or
      the third argument (defaulted to '\n') is encountered. The get( )
      function leaves the terminator character in the input stream, so this
      terminator must be thrown away via in.get( ) using the form of get( )
      with no argument, which fetches a single byte and returns it as an
      int. You can also use the ignore( ) member function, which has two
      default arguments. The first argument is the number of characters to
      throw away and defaults to one. The second argument is the character at
      which the ignore( ) function quits (after extracting it) and defaults to
      EOF.
      -->
      <para>
	El primer <code>while</code> demuestra el uso de dos formas de la función
	<function>get()</function>. La primera toma los carácteres dentro de un buffer y pone
	un delimitador cero en el buffer cuando bien SZ-1 carácteres han sido leidos o bien el
	tercer argumento (que por defecto es '\n') es encontrado. La función <function>get()</function>
	deja el carácter delimitador en el <classname>stream</classname> de entrada, así que este
	delimitador debe ser eliminado via <function>in.get()</function> usando la forma de
	<function>get()</function> sin argumentos. Puede usar tambien la función miembro
	<function>ignore()</function>, que tiene dos parámetros por defecto. El primer argumento es el
	número de carácteres para descartar y por defecto es uno. El segundo argumento es el carácter
	en el que <function>ignore()</function> se detiene (después de extraerlo) y por defecto es EOF.
      </para>

      <!--
      Next, you see two output statements that look similar: one to cout and
      one to the file out. Notice the convenience here?you don't need to
      worry about the object type because the formatting statements work the
      same with all ostream objects. The first one echoes the line to standard
      output, and the second writes the line out to the new file and includes
      a line number.
      -->
      <para>
	A continuación, se muestran dos sentencias de salida
	similares: una hacia <classname>cout</classname> y la otra al
	fichero de salida. Nótese la conveniencia aquí - no necesita
	preocuparse del tipo de objeto porque las sentencias de
	formateo trabajan igual con todos los objetos
	<classname>ostream</classname>.  El primero hace eco de la
	linea en la salida estándar, y el segundo escribe la línea
	hacia el fichero de salida e incluye el número de línea.
      </para>

      <!--
      To demonstrate getline( ), open the file we just created and strip off
      the line numbers. To ensure the file is properly closed before opening
      it to read, you have two choices. You can surround the first part of the
      program with braces to force the out object out of scope, thus calling
      the destructor and closing the file, which is done here. You can also
      call close( ) for both files; if you do this, you can even reuse the in
      object by calling the open( ) member function.
      -->
      <para>
	Para demostrar <function>getline()</function>, abra el fichero recién creado y quite los números de linea.
	Para asegurarse que el fichero se cierra correctamente antes de abrirlo para la lectura, usted tiene dos
	opciones. Puede envolver la primera parte del programa con llaves para forzar que el objeto <varname>out</varname>
	salga del ámbito, llamando así al destructor y cerrando el fichero, que es lo que se hace aquí. Tambien puede l
	lamar a <function>close()</function> para ambos ficheros; si hace esto, puede despues rehusar el objeto de entrada
	llamando a la función miembro <function>open()</function>.
      </para>

      <!--
      The second while loop shows how getline( ) removes the terminator
      character (its third argument, which defaults to '\n') from the input
      stream when it's encountered. Although getline( ), like get( ), puts a
      zero in the buffer, it still doesn't insert the terminating character.
      -->
      <para>
	El segundo <code>while</code> muestra como <function>getline()</function> borra el caracter terminador
	(su tercer argumento, que por defecto es '\n') del <classname>stream</classname> de entrada cuando este
	es encontrado. Aunque <function>getline()</function>, como <function>get()</function>, pone un cero en
	el buffer, este todavía no inserta el carácter de terminación.
      </para>

      <!--
      This example, as well as most of the examples in this chapter, assumes
      that each call to any overload of getline( ) will encounter a newline
      character. If this is not the case, the eofbit state of the stream will
      be set and the call to getline( ) will return false, causing the program
      to lose the last line of input.
      -->
      <para>
	Este ejemplo, así como la mayoría de ejemplos en este capítulo, asume que cada llamada a alguna sobrecarga
	de <function>getline()</function> encontrará un carácter de nueva línea. Si este no es el caso, la estado
	<code>eofbit</code> del <classname>stream</classname> será activado y la llamada a <function>getline()</function>
	retornará falso, causando que el programa pierda la última línea de la entrada.
      </para>

    </sect2>
    <sect2>
      <!-- : Open modes -->
      <title>Modos de apertura</title>

      <!--
      You can control the way a file is opened by overriding the constructor'
      s default arguments. The following table shows the flags that control
      the mode of the file:
      -->
      <para>
	Puede controlar la manera en que un fichero es abierto sobreescribiendo los argumentos por defecto del
	constructor. La siguiente tabla muestra las banderas que controlan el modo de un fichero:
      </para>

      <!-- Flag -->
      <para>
	Bandera
      </para>

      <!-- Function -->
      <para>
	Función
      </para>

      <!-- ios::in -->
      <para>
	<varname>ios::in</varname>
      </para>

      <!--
      Opens an input file. Use this as an open mode for an ofstream to prevent
      truncating an existing file.
      -->
      <para>
	Abre el fichero de entrada. Use esto como un modo de apertura para un <classname>ofstream</classname> para
	prevenir que un fichero existente sea truncado.
      </para>

      <!-- ios::out -->
      <para>
	<varname>ios::out</varname>
      </para>

      <!--
      Opens an output file. When used for an ofstream without ios::app,
      ios::ate or ios::in, ios::trunc is implied.
      -->
      <para>
	Abre un fichero de salida. Cuando es usado por un <classname>ofstream</classname> sin <varname>ios::app</varname>,
	<varname>ios::ate</varname> o <varname>ios::in</varname>, <varname>ios::trunc</varname> es implicado.
      </para>

      <!-- ios::app -->
      <para>
	<varname>ios::app</varname>
      </para>

      <!-- Opens an output file for appending only. -->
      <para>
	Abre un fichero de salida para solo añadir .
      </para>

      <!-- ios::ate -->
      <para>
	<varname>ios::ate</varname>
      </para>

      <!-- Opens an existing file (either input or output) and seeks to the end. -->
      <para>
	Abre un fichero existente (ya sea de entrada o salida) y busca el final.
      </para>

      <!-- ios::trunc -->
      <para>
	<varname>ios::trunc</varname>
      </para>

      <!-- Truncates the old file if it already exists. -->
      <para>
	Trunca el fichero antiguo si este ya existe.
      </para>

      <!-- ios::binary -->
      <para>
	<varname>ios::binary</varname>
      </para>

      <!-- Opens a file in binary mode. The default is text mode. -->
      <para>
	Abre un fichero en modo binario. Por defecto es en modo texto.
      </para>

      <!-- You can combine these flags using a bitwise or operation. -->
      <para>
	Puede combinar estas banderas usando la operación <code>or</code> para bits
      </para>

      <!--
      The binary flag, while portable, only has an effect on some non-UNIX
      systems, such as operating systems derived from MS-DOS, that have
      special conventions for storing end-of-line delimiters. For example, on
      MS-DOS systems in text mode (which is the default), every time you
      output a newline character ('\n'), the file system actually outputs two
      characters, a carriage-return/linefeed pair (CRLF), which is the pair of
      ASCII characters 0x0D and 0x0A. Conversely, when you read such a file
      back into memory in text mode, each occurrence of this pair of bytes
      causes a '\n' to be sent to the program in its place. If you want to
      bypass this special processing, you open files in binary mode. Binary
      mode has nothing whatsoever to do with whether you can write raw bytes
      to a file?you always can (by calling write( )) . You should, however,
      open a file in binary mode when you'll be using read( ) or write( ),
      because these functions take a byte count parameter. Having the extra
      '\r' characters will throw your byte count off in those instances. You
      should also open a file in binary mode if you're going to use the
      stream-positioning commands discussed later in this chapter.
      -->
      <para>
	El flag binario, aun siendo portable, solo tiene efecto en algunos sistemas no UNIX, como sistemas operativos
	derivados de MS-DOS, que tiene convenciones especiales para el almacenamiento de delimitadores de final de línea.
	Por ejemplo, en sistemas MS-DOS en modo texto (el cual es por defecto), cada vez que usted inserta un nuevo
	carácter de nueva línea ('\n'), el sistema de ficheros en realidad inserta dos carácteres, un par retorno de
	carro/fin de línea (CRLF), que es el par de carácteres ASCII 0x0D y 0x0A. En sentido opuesto, cuando usted lee este
	fichero de vuelta a memoria en modo texto, cada ocurrencia de este par de bytes causa que un '\n' sea enviado al
	programa en su lugar. Si quiere sobrepasar este procesado especial, puede abrir el fichero en modo binario. El modo
	binario no tiene nada que ver ya que usted puede escribir bytes sin formato en un fichero - siempre puede (llamando a
	<function>write()</function>). Usted debería, por tanto, abrir un fichero en modo binario cuando vaya a usar
	<function>read()</function> o <function>write()</function>, porque estas funciones toman un contador de bytes como
	parámetro. Tener carácteres extra '\r' estropeará su contador de bytes en estas instancias. Usted también puede abrir
	un fichero en formato binario si va a usar comandos de posicionamiento en el <classname>stream</classname> que se
	discuten más adelante.
      </para>

      <!--
      You can open a file for both input and output by declaring an fstream
      object. When declaring an fstream object, you must use enough of the
      open mode flags mentioned earlier to let the file system know whether
      you want to input, output, or both. To switch from output to input, you
      need to either flush the stream or change the file position. To change
      from input to output, change the file position. To create a file via an
      fstream object, use the ios::trunc open mode flag in the constructor
      call to do both input and output.
      -->
      <para>
	Usted puede abrir un fichero tanto para entrada como salida declarando un objeto <classname>fstream</classname>.
	cuando declara un objeto <classname>fstream</classname>, debe usar suficientes banderas de modos de apertura
	mencionados antes para dejar que el sistema de ficheros sepa si quiere leer, escribir, o ambos. Para cambiar de
	salida a entrada, necesita o bien limpiar el <classname>stream</classname> o bien cambiar la posición en el fichero.
	Para cambiar de entrada a salida, cambie la posicion en el fichero. Para crear un fichero usando un objeto
	<classname>fstream</classname>, use la bandera de modo de apertura <code>ios::trunc</code> en la llamada al constructor
	para usar entrada y salida.
      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Iostream buffering -->
    <title>Almacenamiento de <classname>iostream</classname></title>

    <!--
    Good design practice dictates that, whenever you create a new class, you
    should endeavor to hide the details of the underlying implementation as
    much as possible from the user of the class. You show them only what
    they need to know and make the rest private to avoid confusion. When
    using inserters and extractors, you normally don't know or care where
    the bytes are being produced or consumed, whether you're dealing with
    standard I/O, files, memory, or some newly created class or device.
    -->
    <para>
      Las buenas prácticas de diseño dictan que, cuando cree una nueva clase, debe esforzarse
      en ocultar los detalles de la implementación subyacente tanto como sea posible al usuario
      de la clase. Usted le muestra solo aquello que necesita conocer y el resto se hace privado
      para evitar confusiones. Cuando usamos insertadores y extractores, normalmente usted no conoce
      o tiene cuidado con los bytes que se consumen o se producen, ya que usted está tratando con
      E/S estándar, ficheros, memoria, o alguna nueva clase o dispositivo creado.
    </para>

    <!--
    A time comes, however, when it is important to communicate with the part
    of the iostream that produces and consumes bytes. To provide this part
    with a common interface and still hide its underlying implementation,
    the standard library abstracts it into its own class, called
    streambuf. Each iostream object contains a pointer to some kind of
    streambuf. (The type depends on whether it deals with standard I/O,
    files, memory, and so on.) You can access the streambuf directly; for
    example, you can move raw bytes into and out of the streambuf without
    formatting them through the enclosing iostream. This is accomplished by
    calling member functions for the streambuf object.
    -->
    <para>
      Llega un momento, no obstante, en el que es importante comunicar con la parte del <classname>iostream</classname>
      que produce o consume bytes. Para proveer esta parte con una interfaz común y esconder todavía su implementación
      subyacente, la librería estándar la abstrae dentro de su clase, llamada <classname>streambuf</classname>. Cada
      objeto <classname>iostream</classname> contiene un puntero a alguna clase de <classname>streambuf</classname>. (El
      tipo depende de que se esté tratando con E/S estándar, ficheros, memoria, etc.). Puede acceder al
      <classname>streambuf</classname> directamente; por ejemplo, puede mover bytes sin formatear dentro y fuera del
      <classname>streambuf</classname> sin formatearlos a través de la encapsulación del <classname>iostream</classname>.
      Esto es posible llamando a las funciones miembro del objeto <classname>streambuf</classname>.
    </para>

    <!--
    Currently, the most important thing for you to know is that every
    iostream object contains a pointer to a streambuf object, and the
    streambuf object has some member functions you can call if
    necessary. For file and string streams, there are specialized types of
    stream buffers, as the following figure illustrates:
    -->
    <para>
      Actualmente, la cosa más importante que debe conocer es que cada objeto <classname>iostream</classname> contiene un
      puntero a un objeto <classname>streambuf</classname>, y el objeto <classname>streambuf</classname> tiene algunas
      funciones miembro que puede llamar si es necesario. Para ficheros y <classname>streams</classname> de string, hay
      tipos especializados de buffers de <classname>stream</classname>, como ilustra la figura siguiente:
    </para>

    <!--
    To allow you to access the streambuf, every iostream object has a member
    function called rdbuf( ) that returns the pointer to the object's
    streambuf. This way you can call any member function for the underlying
    streambuf. However, one of the most interesting things you can do with
    the streambuf pointer is to connect it to another iostream object using
    the << operator. This drains all the characters from your object into
    the one on the left side of the <<. If you want to move all the
    characters from one iostream to another, you don't need to go through
    the tedium (and potential coding errors) of reading them one character
    or one line at a time. This is a much more elegant approach.
    -->
    <para>
      Para permitirle el acceso al <classname>streambuf</classname>, cada objeto <classname>iostream</classname> tiene una
      función miembro llamada <function>rdbuf()</function> que retorna el puntero a un objeto <classname>streambuf</classname>.
      De esta manera usted puede llamar cualquier función miembro del <classname>streambuf</classname> subyacente. No obstante,
      una de las cosas más interesantes que usted puede hacer con el puntero al <classname>streambuf</classname> es conectarlo
      con otro objeto <classname>iostream</classname> usando el operador &lt;&lt;. Esto inserta todos los carácteres del objeto
      dentro del que está al lado izquierdo del &lt;&lt;. Si quiere mover todos los carácteres de un <classname>iostream</classname>
      a otro, no necesita ponerse con el tedioso (y potencialmente inclinado a errores de código) proceso de leer de carácter
      por carácter o línea por línea. Este es un acercamiento mucho más elegante.
    </para>

    <!--
    Here's a simple program that opens a file and sends the contents to
    standard output (similar to the previous example):
    -->
    <para>
      Aqui está un programa muy simple que abre un fichero y manda el contenido a la salida estándar (similar al ejemplo previo):
    </para>

//: V2C04:Stype.cpp


    <!--
    An ifstream is created using the source code file for this program as an
    argument. The assure( ) function reports a failure if the file cannot be
    opened. All the work really happens in the statement
    -->
    <para>
      Un ifstream se crea usando el fichero de código fuente  para este programa como argumento. La función
      <function>assure()</function> reporta un fallo si el fichero no puede ser abierto. Todo el trabajo pasa
      realmente en la sentencia
    </para>

<!--
cout << in.rdbuf();
-->
<programlisting>
cout &lt;&lt; in.rdbuf();
</programlisting>

    <!--
    which sends the entire contents of the file to cout. This is not only
    more succinct to code, it is often more efficient than moving the bytes
    one at a time.
    -->
    <para>
      que manda todo el contenido del fichero a <classname>cout</classname>. No solo es un código más sucinto,
      a menudo es más eficiente que mover los byte de uno en uno.
    </para>

    <!--
    A form of get( ) writes directly into the streambuf of another
    object. The first argument is a reference to the destination streambuf,
    and the second is the terminating character ('\n' by default), which
    stops the get( ) function. So there is yet another way to print a file
    to standard output:
    -->
    <para>
      Una forma de <function>get()</function> escribe directamente dentro del <classname>streambuf</classname>
      de otro objeto. El primer argumento es una referencia al <classname>streambuf</classname> de destino, y el
      segundo es el carácter de terminación ('\n' por defecto), que detiene la función <function>get()</function>.
      Así que existe todavía otra manera de imprimir el resultado de un fichero en la salida estándar:
    </para>

//: V2C04:Sbufget.cpp


    <!--
    The rdbuf( ) function returns a pointer, so it must be dereferenced to
    satisfy the function's need to see an object. Stream buffers are not
    meant to be copied (they have no copy constructor), so we define sb as a
    reference to cout's stream buffer. We need the calls to fail( ) and
    clear( ) in case the input file has a blank line (this one does). When
    this particular overloaded version of get( ) sees two newlines in a row
    (evidence of a blank line), it sets the input stream's fail bit, so we
    must call clear( ) to reset it so that the stream can continue to be
    read. The second call to get( ) extracts and echoes each newline
    delimiter. (Remember, the get( ) function doesn't extract its delimiter
    like getline( ) does.)
    -->
    <para>
      La función <function>rdbuf()</function> retorna un puntero, que tiene que ser desreferenciado para satisfacer las
      necesidades de la función para ver el objeto. Los buffers de <classname>stream</classname> no estan pensados para
      ser copiados (no tienen contructor de copia), por lo que definimos <varname>sb</varname> como una referencia al buffer
      de <classname>stream</classname> de <classname>cout</classname>. Necesitamos las llamadas a <function>fail()</function>
      y <function>clear()</function> en caso de que el fichero de entrada tenga una línea en blanco (este la tiene). Cuando
      esta particular versión sobrecargada de <function>get()</function> vee dos carácteres de nueva línea en una fila (una
      evidencia de una línea en blanco), activa el bit de error del <classname>stream</classname> de entrada, asi que se debe
      llamar a <function>clear()</function> para resetearlo y que así el <classname>stream</classname> pueda continuar siendo
      leído. La segunda llamada a <function>get()</function> extrae y hace eco de cualquier delimitador de nueva línea. (Recuerde,
      la función <function>get()</function> no extrae este delimitador como sí lo hace <function>getline()</function>).
    </para>

    <!--
    You probably won't need to use a technique like this often, but it's
    nice to know it exists.[45]
    -->
    <para>
      Probablemente no necesitará usar una técnica como esta a menudo, pero es bueno saber que existe.<footnote><para>Un tratado mucho más en profundidad de buffers de stream y streams en general puede ser encontrado en<citation> Langer &amp; Kreft's, Standar C++ iostreams and Locales, Addison-Wesley, 1999.</citation></para></footnote>
    </para>

  </sect1>
  <sect1>
    <!-- : Seeking in iostreams -->
    <title>Buscar en iostreams</title>

    <!--
    Each type of iostream has a concept of where its 'next' character will
    come from (if it's an istream) or go (if it's an ostream). In some
    situations, you might want to move this stream position. You can do so
    using two models: one uses an absolute location in the stream called the
    streampos; the second works like the Standard C library functions fseek(
    ) for a file and moves a given number of bytes from the beginning, end,
    or current position in the file.
    -->
    <para>
      Cada tipo de iostream tiene el concepto de donde está el 'siguiente' carácter que proviene de (si es un
      <classname>istream</classname>) o que va hacia (si es un <classname>ostream</classname>). En algunas
      situaciones, puede querer mover la posición en este <classname>stream</classname>. Puede hacer esto usando
      dos modelos: uno usa una localización absoluta en el stream llamada <varname>streampos</varname>; el segundo
      trabaja como las funciones <function>fseek()</function> de la librería estándar de C para un fichero y
      se mueve un número dado de bytes desde el principio, final o la posición actual en el fichero.
    </para>

    <!--
    The streampos approach requires that you first call a 'tell' function:
    tellp( ) for an ostream or tellg( ) for an istream. (The 'p' refers to
    the 'put pointer,' and the 'g' refers to the 'get pointer.') This
    function returns a streampos you can later use in calls to seekp( ) for
    an ostream or seekg( ) for an istream when you want to return to that
    position in the stream.
    -->
    <para>
      El acercamiento de <classname>streampos</classname> requiere que primero llame una función 'tell':(
      <function>tellp()</function> para un <classname>ostream</classname> o <function>tellg()</function> para
      un <classname>istream</classname>. (La 'p' se refiere a 'put pointer' y la 'g' se refiere a 'get pointer').
      Esta función retorna un <classname>streampos</classname> que puede usar después en llamadas a
      <function>seekp()</function> para un <classname>ostream</classname> o <function>seekg()</function> para un
      <classname>ostream</classname> cuando usted quiere retornar a la posición en el <classname>stream</classname>.
    </para>

    <!--
    The second approach is a relative seek and uses overloaded versions of
    seekp( ) and seekg( ). The first argument is the number of characters to
    move: it can be positive or negative. The second argument is the seek
    direction:
    -->
    <para>
      La segunda aproximación es una búsqueda relativa y usa versiones sobrecargadas de <function>seekp()</function> y
      <function>seekg()</function>. El primer argumento es el número de carácteres a mover: puede ser positivo o
      negativo. El segundo argumento es la dirección desde donde buscar:
    </para>

    <!-- ios::beg -->
    <para>
      <code>ios::beg</code>
    </para>

    <!-- From beginning of stream -->
    <para>
      Desde el principio del <classname>stream</classname>
    </para>

    <!-- ios::cur -->
    <para>
      <code>ios::cur</code>
    </para>

    <!-- Current position in stream -->
    <para>
      Posición actual del <classname>stream</classname>
    </para>

    <!-- ios::end -->
    <para>
      <code>ios::end</code>
    </para>

    <!-- From end of stream -->
    <para>
      Desde el principio del <classname>stream</classname>
    </para>

    <!--
    Here's an example that shows the movement through a file, but remember,
    you're not limited to seeking within files as you are with C's
    stdio. With C++, you can seek in any type of iostream (although the
    standard stream objects, such as cin and cout, explicitly disallow it):
    -->
    <para>
      Aquí un ejemplo que muestra el movimiento por un fichero, pero recuerde, no esta limitado a buscar en ficheros
      como lo está con <code>stdio</code> de C. Con C++, puede buscar en cualquier tipo de <classname>iostream</classname>
      (aunque los objetos <classname>stream</classname> estándar, como <classname>cin</classname> y <classname>cout</classname>,
      lo impiden explícitamente):
    </para>

//: V2C04:Seeking.cpp


    <!--
    This program writes a poem to a file using a binary output stream. Since
    we reopen it as an ifstream, we use seekg( ) to position the 'get
    pointer.' As you can see, you can seek from the beginning or end of the
    file or from the current file position. Obviously, you must provide a
    positive number to move from the beginning of the file and a negative
    number to move back from the end.
    -->
    <para>
      Este programa escribe un poema a un fichero usando un <classname>stream</classname> de salida binaria. Como
      reabrimos como un <classname>ifstream</classname>, usamos <function>seekg()</function> para posicionar el
      'get pointer'. Como puede ver, puede buscar desde el principio o el final del archivo o desde la posición actual
      del archivo. Obviamente, debe proveer un número positivo para mover desde el principio del archivo y un número
      negativo para mover hacia atrás.
    </para>

    <!--
    Now that you know about the streambuf and how to seek, you can
    understand an alternative method (besides using an fstream object) for
    creating a stream object that will both read and write a file. The
    following code first creates an ifstream with flags that say it's both
    an input and an output file. You can't write to an ifstream, so you
    need to create an ostream with the underlying stream buffer:
    -->
    <para>
      Ahora que ya conoce el <classname>streambuf</classname> y como buscar, ya puede entender un método alternativo
      (aparte de usar un objeto <classname>fstream</classname>) para crear un objeto <classname>stream</classname> que
      podrá leer y escribir en un archivo. El siguiente código crea un <classname>ifstream</classname> con banderas
      que dicen que es un fichero de entrada y de salida. Usted no puede escribir en un <classname>ifstream</classname>,
      así que necesita crear un <classname>ostream</classname> con el buffer subyacente del <classname>stream</classname>:
    </para>


<programlisting>
ifstream in("filename", ios::in | ios::out);
ostream out(in.rdbuf());
</programlisting>


    <!--
    You might wonder what happens when you write to one of these
    objects. Here's an example:
    -->
    <para>
      Debe estar preguntándose que ocurre cuando usted lee en uno de estos objetos. Aqui tiene un ejemplo:
    </para>

//: V2C04:Iofile.cpp


    <!--
    The first five lines copy the source code for this program into a file
    called iofile.out and then close the files. This gives us a safe text
    file to play with. Then the aforementioned technique is used to create
    two objects that read and write to the same file. In cout << in2.rdbuf(
    ), you can see the 'get' pointer is initialized to the beginning of
    the file. The 'put' pointer, however, is set to the end of the file
    because 'Where does this end up'? appears appended to the
    file. However, if the put pointer is moved to the beginning with a
    seekp( ), all the inserted text overwrites the existing text. Both
    writes are seen when the get pointer is moved back to the beginning with
    a seekg( ), and the file is displayed. The file is automatically saved
    and closed when out2 goes out of scope and its destructor is called.
    -->
    <para>
      Las primeras cinco líneas copian el código fuente de este programa en un fichero llamado iofile.out
      y después cierra los ficheros. Esto le da un texto seguro con el que practicar. Entonces, la técnica
      antes mencionada se usa para crear dos objetos que leen y escriben en el mismo fichero. En
      <code>cout &lt;&lt; in2.rebuf()</code>, puede ver como puntero 'get' es inicializado al principio del fichero.
      El puntero 'put', en cambio, se coloca en el final del fichero para que 'Where does this end up' aparezca
      añadido al fichero. No obstante, si el puntero 'put' es movido al principio con un <function>seekp()</function>,
      todo el texto insertado sobreescribe el existente. Ambas escrituras pueden verse cuando el puntero 'get'
      se mueve otra vez al principio con <function>seekg()</function>, y el fichero se muestra. El fichero es
      automáticamente guardado cuando <varname>out2</varname> sale del ámbito y su destructor es invocado.
    </para>

  </sect1>
  <sect1>
    <!-- : String iostreams -->
    <title>Iostreams de <classname>string</classname></title>

    <!--
    A string stream works directly with memory instead of a file or standard
    output. It uses the same reading and formatting functions that you use
    with cin and cout to manipulate bytes in memory. On old computers, the
    memory was referred to as core, so this type of functionality is often
    called in-core formatting.
    -->
    <para>
      Un <classname>stream</classname> de cadena funciona directamente en memoria en vez de con ficheros o la salida
      estándar. Usa las mismas funciones de lectura y formateo que usó con <classname>cin</classname> y
      <classname>cout</classname> para manipular bits en memoria. En ordenadores antiguos, la memoria se refería al
      núcleo, con lo que este tipo de funcionalidad se llama a menudo formateo en el núcleo.
    </para>

    <!--
    The class names for string streams echo those for file streams. If you
    want to create a string stream to extract characters from, you create an
    istringstream. If you want to put characters into a string stream, you
    create an ostringstream. All declarations for string streams are in the
    standard header <sstream>. As usual, there are class templates that fit
    into the iostreams hierarchy, as shown in the following figure:
    -->
    <para>
      Los nombres de clases para <classname>streams</classname> de cadena son una copia de los <classname>streams</classname> de
      ficheros. Si usted quiere crear un <classname>stream</classname> de cadena para extraer carácteres de él, puede crear un
      <classname>istringstream</classname>. Si quiere poner carácteres en un <classname>stream</classname> de cadena, puede crear
      un <classname>ostringstream</classname>. Todas las declaraciones para <classname>streams</classname> de cadena están en la
      cabecera estándar &lt;sstream&gt;. Como es habitual, hay plantillas de clases dentro de la jerarquia de los
      <classname>iostreams</classname>, como se muestra en la siguiente figura:
    </para>

    <sect2>
      <!-- : Input string streams -->
      <title>Streams de cadena de entrada</title>

      <!--
      To read from a string using stream operations, you create an
      istringstream object initialized with the string. The following program
      shows how to use an istringstream object:
      -->
      <para>
	Para leer de un <classname>string</classname> usando
	operaciones de <classname>stream</classname>, cree un objeto
	<classname>istringstream</classname> inicializado con el
	<classname>string</classname>. El siguiente programa muestra
	como usar un objeto <classname>istringstream</classname>:
      </para>


//: V2C04:Istring.cpp


      <!--
      You can see that this is a more flexible and general approach to
      transforming character strings to typed values than the standard C
      library functions such as atof( ) or atoi( ), even though the latter may
      be more efficient for single conversions.
      -->
      <para>
	Puede ver que es un acercamiento más flexible y general para
	transformar cadenas de carácteres para valores con tipo que la
	librería de funciones del estándar de C, como
	<function>atof()</function> o <function>atoi()</function>,
	aunque esta última puede ser más eficaz para las conversiones
	individuales.
      </para>

      <!--
      In the expression s >> i >> f, the first number is extracted into i, and
      the second into f. This isn't 'the first whitespace-delimited set of
      characters' because it depends on the data type it's being extracted
      into. For example, if the string were instead, '1.414 47 This is a
      test,' then i would get the value 1 because the input routine would
      stop at the decimal point. Then f would get 0.414. This could be useful
      if you want to break a floating-point number into a whole number and a
      fraction part. Otherwise it would seem to be an error. The second
      assert( ) calculates the relative error between what we read and what we
      expected; it's always better to do this than to compare floating-point
      numbers for equality. The constant returned by epsilon( ), defined in <limits>,
      represents the machine epsilon for double-precision numbers, which is the best
      tolerance you can expect comparisons of doubles to satisfy.
      -->
      <para>
	En la expresión <code>s &gt;&gt; i &gt;&gt; f</code>, el
	primer número se extrae en <varname>i</varname>, y en el
	segundo en <varname>f</varname>. Este no es 'el primer
	conjunto de carácteres delimitado por espacios en blanco' por
	que depende del tipo de datos que está siendo extraído. Por
	ejemplo, si la cadena fuera '1.414 47 This is a test',
	entonces <varname>i</varname> tomaría el valor 1 porque la
	rutina de entrada se pararía en el punto decimal. Entonces
	<varname>f</varname> tomaría 0.414. Esto puede ser muy útil i
	si quiere partir un número de coma flotante entre la parte
	entera y la decimal. De otra manera parecería un error.  El
	segundo <function>assert()</function> calcula el error
	relativo entre lo que leemos y lo que esperamos; siempre es
	mejor hacer esto que comparar la igualdad de números de coma
	flotante. La constante devuelta por
	<function>epsilon()</function>, definida en &lt;limits&gt;,
	representa la epsilon de la máquina para números de doble
	precisión, el cual es la mejor tolerancia que se puede esperar
	para satisfacer las comparaciones de double.<footnote>
	<para>Para más información sobre la epsilon de la máquina y el
	cómputo de punto flotante en general, vea el artículo de
	Chuck, "The Standard C Library, Part 3", C/C++ Users Journal,
	Marzo 1995, disponible en
	www.freshsources.com/1995006a.htm</para></footnote>.
     </para>

      <!--
      As you may already have guessed, buf2 doesn't get the rest of the
      string, just the next white-space-delimited word. In general, it's best
      to use the extractor in iostreams when you know the exact sequence of
      data in the input stream and you're converting to some type other than
      a character string. However, if you want to extract the rest of the
      string all at once and send it to another iostream, you can use rdbuf( )
      as shown.
      -->
      <para>
	Como debe haber supuesto, <varname>buf2</varname> no toma el
	resto del <classname>string</classname>, simplemente la
	siguiente palabra delimitada por espacios en blanco. En
	general, el mejor usar el extractor en
	<classname>iostreams</classname> cuando usted conoce
	exactamente la secuencia de datos en el
	<classname>stream</classname> de entrada y los convierte a
	algún otro tipo que un <classname>string</classname> de
	carácteres. No obstante, si quiere extraer el resto del
	<classname>string</classname> de una sola vez y enviarlo a
	otro <classname>iostream</classname>, puede usar
	<function>rdbuf()</function> como se muestra.
      </para>

      <!--
      To test the Date extractor at the beginning of this chapter, we used an
      input string stream with the following test program:
      -->
      <para>
	Para probar el extractor de <classname>Date</classname> al
	principio de este capítulo, hemos usado un
	<classname>stream</classname> de cadena de entrada con el
	siguiente programa de prueba:
      </para>


//: V2C04:DateIOTest.cpp


      <!--
      Each string literal in main( ) is passed by reference to testDate( ),
      which in turn wraps it in an istringstream so we can test the stream
      extractor we wrote for Date objects. The function testDate( ) also
      begins to test the inserter, operator<<( ).
      -->
      <para>
	Cada literal de cadena en <function>main()</function> se pasa
	por referencia a <function>testDate()</function>, que a su vez
	lo envuelve en un <classname>istringstream</classname> con lo
	que podemos probar el extractor de
	<classname>stream</classname> que escribimos para los objetos
	<classname>Date</classname>. La función
	<function>testDate()</function> también empieza por probar el
	insertador, <function>operator&lt;&lt;()</function>.
      </para>

    </sect2>
    <sect2>
      <!-- : Output string streams -->
      <title>Streams de cadena de salida</title>

      <!--
      To create an output string stream, you just create an ostringstream
      object, which manages a dynamically sized character buffer to hold
      whatever you insert. To get the formatted result as a string object, you
      call the str( ) member function. Here's an example:
      -->
      <para>
	Para crear un stream de cadena de salida, simplemente cree un
	objeto ostringstream, que maneja un buffer de carácteres
	dinamicamente dimensionado para guardar cualquier cosas que
	usted inserte. Para tomar el resultado formateado como un
	objeto de string, llame a la función miembro setr(). Aqui
	tiene un ejemplo:
      </para>


//: V2C04:Ostring.cpp {RunByHand}



      <!--
      This is similar to the Istring.cpp example earlier that fetched an int
      and a float. A sample execution follows (the keyboard input is in bold
      type).
      -->
      <para>
	Esto es similar al ejemplo Istring.cpp anterior que pedía un
	<type>int</type> y un <type>float</type>. A continueación una
	simple ejecución (la entrada por teclado está escrita en
	negrita).
      </para>

<screen>
type an int, a float and a string: FIXME:10 20.5 the end
integer = 10
float = 20.5
string = the end
</screen>

      <!--
      You can see that, like the other output streams, you can use the
      ordinary formatting tools, such as the << operator and endl, to send
      bytes to the ostringstream. The str( ) function returns a new string
      object every time you call it so the underlying stringbuf object owned
      by the string stream is left undisturbed.
      -->
      <para>
	Puede ver que, como otros <classname>stream</classname> de
	salida, puede usar las herramientas ordinarias de formateo,
	como el operador &lt;&lt; y <function>endl</function>, para
	enviar bytes hacia el <classname>ostringstream</classname>. La
	función <function>str()</function> devuelve un nuevo objeto
	<classname>string</classname> cada vez que usted la llama con
	lo que el <classname>stringbuf</classname> contenido permanece
	inalterado.
      </para>

      <!--
      In the previous chapter, we presented a program, HTMLStripper.cpp, that
      removed all HTML tags and special codes from a text file. As promised,
      here is a more elegant version using string streams.
      -->
      <para>
	En el capítulo previo, presentamos un programa,
	HTMLStripper.cpp, que borraba todas las etiqietas HTML y los
	códigos especiales de un fichero de texto. Como prometíamos,
	aqui está una versión más elegante usando
	<classname>streams</classname> de cadena.
      </para>


//: V2C04:HTMLStripper2.cpp {RunByHand}


      <!--
      In this program we read the entire file into a string by inserting a
      rdbuf( ) call to the file stream into an ostringstream. Now it's an
      easy matter to search for HTML delimiter pairs and erase them without
      having to worry about crossing line boundaries like we had to with the
      previous version in Chapter 3.
      -->
      <para>
	En este programa leemos el fichero entero dentro de un <classname>string</classname> insertando una llamada <function>rdbuf()</function>
	del <classname>stream</classname> de fichero al <classname>ostringstream</classname>. Ahora es fácil buscar parejas de delimitadores HTML
	y borrarlas sin tener que preocuparnos de límites de líneas como teniamos con la versión previa en el Capítulo 3.
      </para>

      <!--
      The following example shows how to use a bidirectional (that is,
      read/write) string stream:
      -->
      <para>
	El siguiente ejemplo muestra como usar un stream de cadena
	bidireccional (esto es, lectura/escritura):
      </para>


//: V2C04:StringSeeking.cpp {-bor}{-dmc}


      <!--
      As always, to move the put pointer, you call seekp( ), and to reposition
      the get pointer, you call seekg( ). Even though we didn't show it with
      this example, string streams are a little more forgiving than file
      streams in that you can switch from reading to writing or vice-versa at
      any time. You don't need to reposition the get or put pointers or flush
      the stream. This program also illustrates the overload of str( ) that
      replaces the stream's underlying stringbuf with a new string.
      -->
      <para>
	Como siempre para mover el puntero de inserción, usted llama a
	<function>seekp()</function>, y para reposicionar el fichero
	de lectura, usted llama a
	<function>seekg()</function>. Incluso aunque no lo hemos
	mostrado con este ejemplo, los <classname>stream</classname>
	de cadeana son un poco más permisivos que los
	<classname>stream</classname> de fichero ya que podemos
	cambiar de lectura a escritura y viceversa en cualquier
	momento. No necesita reposicionar el puntero de lectura o de
	escritura o vaciar el <classname>stream</classname>. Este
	progrma también ilustra la sobrecarga de
	<function>str()</function> que reemplaza el
	<classname>stringbuf</classname> contenido en el
	<classname>stream</classname> con una nueva cadena.
      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Output stream formatting -->
    <title>Formateo de stream de salida</title>

    <!--
    The goal of the iostreams design is to allow you to easily move and/or
    format characters. It certainly wouldn't be useful if you couldn't do
    most of the formatting provided by C's printf( ) family of
    functions. In this section, you'll learn all the output formatting
    functions that are available for iostreams, so you can format your bytes
    the way you want them.
    -->
    <para>
      El objetivo del diseño de los <classname>iostream</classname> es
      permitir que usted pueda mover y/o formatear carácteres
      fácilmente.  Ciertamente no podria ser de mucha utilidad si no
      se pudiera hacer la mayoria de los formateos provistos por la
      familia de funciones de <function>printf()</function> en C. Es
      esta sección, usted aprenderá todo sobre las funciones de
      formateo de salida que estan disponibles para
      <classname>iostream</classname>, con lo que puede formatear los
      bytes de la manera que usted quiera.
    </para>

    <!--
    The formatting functions in iostreams can be somewhat confusing at first
    because there's often more than one way to control the formatting:
    through both member functions and manipulators. To further confuse
    things, a generic member function sets state flags to control
    formatting, such as left or right justification, to use uppercase
    letters for hex notation, to always use a decimal point for
    floating-point values, and so on. On the other hand, separate member
    functions set and read values for the fill character, the field width,
    and the precision.
    -->
    <para>
      Las funciones de formateo en iostream pueden ser algo cunfusas
      al principio porque a menudo existe más de una manera de
      controlar el formateo: a través de funciones miembro y
      manipuladores. Para confundir más las cosas, una función miembro
      genérica pone banderas de estado para controlar el formateo,
      como la justificación a la derecha o izquierda, el uso de letras
      mayúsculas para la notación hexadecimal, para siempre usar un
      punto decimal para valores de coma flotante, y cosas así. En el
      otro lado, funciones miembro separadas activan y leen valores
      para el caracter de relleno, la anchura del campo, y la
      precisión.
    </para>

    <!--
    In an attempt to clarify all this, we'll first examine the internal
    formatting data of an iostream, along with the member functions that can
    modify that data. (Everything can be controlled through the member
    functions, if desired.) We'll cover the manipulators separately.
    -->
    <para>
      En un intento de clarificar todo esto, primero examinaremos el
      formateo interno de los datos de un iostream, y las funciones
      miembro que pueden modificar estos datos. (Todo puede ser
      controlado por funciones miembro si se desea). Cubriremos los
      manipuladores aparte.
    </para>

    <sect2>
      <!-- : Format flags -->
      <title>Banderas de formateo</title>

      <!--
      The class ios contains data members to store all the formatting
      information pertaining to a stream. Some of this data has a range of
      values and is stored in variables: the floating-point precision, the
      output field width, and the character used to pad the output (normally a
      space). The rest of the formatting is determined by flags, which are
      usually combined to save space and are referred to collectively as the
      format flags. You can find out the value of the format flags with the
      ios::flags( ) member function, which takes no arguments and returns an
      object of type fmtflags (usually a synonym for long) that contains the
      current format flags. All the rest of the functions make changes to the
      format flags and return the previous value of the format flags.
      -->
      <para>
	La clase <classname>ios</classname> contiene los miembros de
	datos para guardar toda la información de formateo
	perteneciente a un <classname>stream</classname>. Algunos de
	estos datos tiene un rango de valores de datos y son guardados
	en variables: la precisión de la coma flotante, la anchura del
	campo de salida, y el carácter usado para rellenar la salida
	(normalmente un espacio). El resto del formateo es determinado
	por banderas, que generalmente están combinadas para ahorrar
	espacio y se llaman colectivamente banderas de formateo. Puede
	recuperar los valores de las banderas de formateo con la
	función miembro <function>ios::flag()</function>, que no toma
	argumentos y retorna un objeto de tipo
	<classname>fmtflags</classname> (usualmente un sinónimo de
	<type>long</type>) que contiene las banderas de
	formateo actuales. El resto de funciones hacen cambios en las
	banderas de formateo y retornan el valor previo de las
	banderas de formateo.
      </para>


<programlisting>
  fmtflags ios::flags(fmtflags newflags);
  fmtflags ios::setf(fmtflags ored_flag);
  fmtflags ios::unsetf(fmtflags clear_flag);
  fmtflags ios::setf(fmtflags bits, fmtflags field);
</programlisting>


      <!--
      The first function forces all the flags to change, which is sometimes
      what you want. More often, you change one flag at a time using the
      remaining three functions.
      -->
      <para>
	La primera función fuerza que todas las banderas cambien, que a veces es lo que usted quiere. Más a menudo, usted cambia una
	bandera cada vez usando las otras tres funciones.
      </para>

      <!--
      The use of setf( ) can seem somewhat confusing. To know which overloaded
      version to use, you must know what type of flag you're changing. There
      are two types of flags: those that are simply on or off, and those that
      work in a group with other flags. The on/off flags are the simplest to
      understand because you turn them on with setf(fmtflags) and off with
      unsetf(fmtflags). These flags are shown in the following table:
      -->
      <para>
	El uso de <function>setf()</function> puede parecer algo confusa. Para conocer qué versión sobrecargada usar, debe conocer el
	tipo de la bandera que está cambiando. Existen dos tipos de banderas: las que simplemente estan activadas o no, y aquellas que
	trabajan en grupo con otras banderas. La banderas que estan encendidas/apagadas son las más simples de entender por que usted
	las enciende con <function>setf(fmtflags)</function> y las apaga con <function>unsetf(fmtflags)</function>. Estas banderas
	se muestran en la siguiente tabla:
      </para>

      <!-- on/off flag -->
      <para>
	bandera activa/inactiva
      </para>

      <!-- Effect -->
      <para>
	Efecto
      </para>

      <!-- ios::skipws -->
      <para>
	<function>ios::skipws</function>
      </para>

      <!-- Skip white space. (For input; this is the default.) -->
      <para>
	Se salta los espacios en blanco. ( Para la entrada esto es por defecto).
      </para>

      <!-- ios::showbase -->
      <para>
	<function>ios::showbase</function>
      </para>

      <!--
      Indicate the numeric base (as set, for example, by dec, oct, or hex)
      when printing an integral value. Input streams also recognize the base
      prefix when showbase is on.
      -->
      <para>
	Indica la base numérica (que puede ser, por ejemplo, decimal, octal o  hexadecimal) cuando imprimimos el valor entero.
	Los <classname>stream</classname> de entrada tambié reconocen el prefijo de base cuando <varname>showbase</varname> está
	activo.
      </para>

      <!-- ios::showpoint -->
      <para>
	<varname>ios::showpoint</varname>
      </para>

      <!-- Show decimal point and trailing zeros for floating-point values. -->
      <para>
	Muestra el punto decimal insertando ceros para valores de coma flotante.
      </para>

      <!-- ios::uppercase -->
      <para>
	<varname>ios::uppercase</varname>
      </para>

      <!--
      Display uppercase A-F for hexadecimal values and E for scientific
      values.
      -->
      <para>
	Muestra A-F mayúsculas para valores hexadecimales y E para científicos.
      </para>

      <!-- ios::showpos -->
      <para>
	<varname>ios::showpos</varname>
      </para>

      <!-- Show plus sign (+) for positive values. -->
      <para>
	Muestra el signo de sumar (+) para los valores positivos
      </para>

      <!-- ios::unitbuf -->
      <para>
	<varname>ios::unitbuf</varname>
      </para>

      <!-- 'Unit buffering.' The stream is flushed after each insertion. -->
      <para>
	'Unit buffering.' El <classname>stream</classname> es borrado después de cada inseción.
      </para>

      <!--
      For example, to show the plus sign for cout, you say
      cout.setf(ios::showpos). To stop showing the plus sign, you say
      cout.unsetf(ios::showpos).
      -->
      <para>
	Por ejemplo, para mostrar el signo de sumar para <classname>cout</classname>, puede usar <function>cout.setf(ios::showpos)</function>.
	Para dejar de mostrar el signo de sumar, escriba <function>cout.unsetf(ios::showpos)</function>.
      </para>

      <!--
      The unitbuf flag controls unit buffering, which means that each
      insertion is flushed to its output stream immediately. This is handy for
      error tracing, so that in case of a program crash, your data is still
      written to the log file. The following program illustrates unit
      buffering:
      -->
      <para>
	La bandera de <varname>unitbuf</varname> controla  el almacenamiento unitario, que significa que cada inserción es lanzada a su
	<classname>stream</classname> de salida inmediatamente. Esto es útil para hacer recuento de errores, ya que en caso de fallo del
	programa, sus datos son todavía escritos al fichero de log. El siguiente programa ilustra el almacenamiento unitario.
      </para>

//: V2C04:Unitbuf.cpp {RunByHand}


      <!--
      It is necessary to turn on unit buffering before any insertions are made
      to the stream. When we commented out the call to setf( ), one particular
      compiler had written only the letter 'o' to the file log.txt. With
      unit buffering, no data was lost.
      -->
      <para>
	Es necesario activar el almacenamiento unitario antes de que cualquier inserción sea hecha en el <classname>stream</classname>.
	Cuando hemos descomentado la llamada a <function>setf()</function>, un compilador en particular ha escrito solo la letra 'o' en
	el fichero log.txt. Con el almacenamiento unitario, ningun dato se perdió.
      </para>

      <!--
      The standard error output stream cerr has unit buffering turned on by
      default. There is a cost for unit buffering, so if an output stream is
      heavily used, don't enable unit buffering unless efficiency is not a
      consideration.
      -->
      <para>
	El <classname>stream</classname> de salida estándar <classname>cerr</classname> tiene el almacenamiento unitario activado por
	defecto. Hay un coste para el almacenamiento unitario, asi que si un <classname>stream</classname> de salida se usa intensivamente,
	no active el almacenamiento unitario a menos que la eficiencia no sea una consideración.
      </para>

    </sect2>
    <sect2>
      <!-- : Format fields -->
      <title>Campos de formateo</title>

      <!--
      The second type of formatting flags work in a group. Only one of these
      flags can be set at a time, like the buttons on old car radios?you push
      one in, the rest pop out. Unfortunately this doesn't happen
      automatically, and you must pay attention to what flags you're setting
      so that you don't accidentally call the wrong setf( ) function. For
      example, there's a flag for each of the number bases: hexadecimal,
      decimal, and octal. Collectively, these flags are referred to as the
      ios::basefield. If the ios::dec flag is set and you call setf(ios::hex),
      you'll set the ios::hex flag, but you won't clear the ios::dec bit,
      resulting in undefined behavior. Instead, call the second form of setf(
      ) like this: setf(ios::hex, ios::basefield). This function first clears
      all the bits in the ios::basefield and then sets ios::hex. Thus, this
      form of setf( ) ensures that the other flags in the group 'pop out'
      whenever you set one. The ios::hex manipulator does all this for you,
      automatically, so you don't need to concern yourself with the internal
      details of the implementation of this class or to even care that it's a
      set of binary flags. Later you'll see that there are manipulators to
      provide equivalent functionality in all the places you would use setf(
      ).
      -->
      <para>
	El segundo tipo de banderas de formateo trabajan en grupo. Solo una de estas banderas pueden ser activadas cada vez, como
	los botones de una vieja radio de coche - usted apretaba una y el resto saltaban. Desafortunadamente esto no pasa automáticamente,
	y usted tiene que poner atención a que bandera  está activando para no llamar accidentalmente a la función <function>setf()</function>
	incorrecta. Por ejemplo, hay una bandera para cada una de las bases numéricas: hexadecimal, decimal y octal. A estas banderas
	se refiere en conjunto <code>ios::basefield</code>. Si la bandera <code>ios::dec</code> está activa y usted llama
	<code>setf(ios::hex)</code>, usted activará la bandera de <code>ios::hex</code>, pero no desactivará la bandera de
	<code>ios::dec</code>, resultando en un comportamiento indeterminado. En vez de esto,llame a la segunda forma de la función
	<function>setf()</function> como esta: <code>setf(ios::hex, ios::basefield)</code> . Esta función primero limpia todos los
	bits de <code>ios::basefield</code> y luego activa <code>ios::hex</code>. Así, esta forma de <function>setf()</function> asegura
	que las otras banderas en el grupo 'saltan' cuando usted activa una. El manipulador <code>ios::hex</code> lo hace todo por usted,
	automáticamente, asi que no tiene que preocuparse con los detalles de la implementación interna de esta clase o tener cuidado de
	que esto es una seria de banderas binarias. Más adelante verá que  hay manipuladores para proveer de la funcionalidad equivalente en
	todas las parts donde usted fuera a usar <function>setf()</function>.
      </para>

      <!-- Here are the flag groups and their effects: -->
      <para>
	Aquí están los grupos de banderas y sus efectos:
      </para>

      <!-- ios::basefield -->
      <para>
	<code>ios::basefield</code>
      </para>

      <!-- Effect -->
      <para>
	Efecto
      </para>

      <!-- ios::dec -->
      <para>
	<code>ios::dec</code>
      </para>

      <!--
      Format integral values in base 10 (decimal) (the default radix?no prefix
      is visible).
      -->
      <para>
	Formatea valores enteros en base 10 (decimal)(Formateo por defecto - ningún prefijo es visible).
      </para>

      <!-- ios::hex -->
      <para>
	<code>ios::hex</code>
      </para>

      <!-- Format integral values in base 16 (hexadecimal). -->
      <para>
	Formatea valores enteros en base 16 (hexadecimal).
      </para>

      <!-- ios::oct -->
      <para>
	<code>ios::oct</code>
      </para>

      <!-- Format integral values in base 8 (octal). -->
      <para>
	Formatea valores enteros en base 8 (octal).
      </para>

      <!-- ios::floatfield -->
      <para>
	<code>ios::floatfield</code>
      </para>

      <!-- Effect -->
      <para>
	Efecto
      </para>

      <!-- ios::scientific -->
      <para>
	<code>ios::scientific</code>
      </para>

      <!--
      Display floating-point numbers in scientific format. Precision field
      indicates number of digits after the decimal point.
      -->
      <para>
	Muestra números en coma flotante en formato científico. El campo precisión indica el numero de dígitos después del punto decimal.
      </para>

      <!-- ios::fixed -->
      <para>
	<code>ios::fixed</code>
      </para>

      <!--
      Display floating-point numbers in fixed format. Precision field
      indicates number of digits after the decimal point.
      -->
      <para>
	Muestra números en coma flotante en formato fijado. El campo precisión indica en número de dígitos después del punto decimal.
      </para>

      <!-- 'automatic' (Neither bit is set.) -->
      <para>
	'automatic' (Ninguno de los bits está activado).
      </para>

      <!-- Precision field indicates the total number of significant digits. -->
      <para>
	El campo precisión indica el número total de dígitos significativos.
      </para>

      <!-- ios::adjustfield -->
      <para>
	<code>ios::adjustfield</code>
      </para>

      <!-- Effect -->
      <para>
	Efecto
      </para>

      <!-- ios::left -->
      <para>
	<code>ios::left</code>
      </para>

      <!-- Left-align values; pad on the right with the fill character. -->
      <para>
	Valores con alineación izquierda; se llena hasta la derecha con el carácter de relleno.
      </para>

      <!-- ios::right -->
      <para>
	<code>ios::right</code>
      </para>

      <!--
      Right-align values. Pad on the left with the fill character. This is the
      default alignment.
      -->
      <para>
	Valores con alineación derecha; se llena hasta la izquierda con el carácter de relleno. Esta es la alineación por defecto.
      </para>

      <!-- ios::internal -->
      <para>
	<code>ios::internal</code>
      </para>

      <!--
      Add fill characters after any leading sign or base indicator, but before
      the value. (In other words, the sign, if printed, is left-justified
      while the number is right-justified.)
      -->
      <para>
	Añade carácteres de relleno despues de algún signo inicial o indicador de base, pero antes del valor. (En otras palabras,
	el signo, si está presente, se justifica a la izquierda mientras el número se justifica a la derecha).
      </para>

    </sect2>
    <sect2>
      <!-- : Width, fill, and precision -->
      <title>Anchura, relleno y precisión</title>

      <!--
      The internal variables that control the width of the output field, the
      fill character used to pad an output field, and the precision for
      printing floating-point numbers are read and written by member functions
      of the same name.
      -->
      <para>
	La variables internas que controlan la anchura del campo de salida, el carácter usado para rellenar el campo de salida,
	y la precisión para escribir números de coma flotante son escritos y leídos por funciones miembro del mismo nombre.
      </para>

      <!-- Function -->
      <para>
	Función
      </para>

      <!-- Effect -->
      <para>
	Efecto
      </para>

      <!-- int ios::width( ) -->
      <para>
	<code>int ios::width( )</code>
      </para>

      <!--
      Returns the current width. Default is 0. Used for both insertion and
      extraction.
      -->
      <para>
	Retorna la anchura actual. Por defecto es 0. Se usa para la inserción y la extracción.
      </para>

      <!-- int ios::width(int n) -->
      <para>
	<code>int ios::width(int n)</code>
      </para>

      <!-- Sets the width, returns the previous width. -->
      <para>
	Pone la anchura, retorna la anchura previa.
      </para>

      <!-- int ios::fill( ) -->
      <para>
	<code>int ios::fill( )</code>
      </para>

      <!-- Returns the current fill character. Default is space. -->
      <para>
	Retorna el carácter de relleno actual. Por defecto es el espacio.
      </para>

      <!-- int ios::fill(int n) -->
      <para>
	<code>int ios::fill(int n)</code>
      </para>

      <!-- Sets the fill character, returns the previous fill character. -->
      <para>
	Poner el carácter de relleno, retorna el carácter de relleno anterior.
      </para>

      <!-- int ios::precision( ) -->
      <para>
	<code>int ios::precision( )</code>
      </para>

      <!-- Returns current floating-point precision. Default is 6. -->
      <para>
	Retorna la precisión actual de la coma flotante. Por defecto es 6.
      </para>

      <!-- int ios::precision(int n) -->
      <para>
	<code>int ios::precision(int n)</code>
      </para>

      <!--
      Sets floating-point precision, returns previous precision. See
      ios::floatfield table for the meaning of 'precision.'
      -->
      <para>
	Pone la precisión de la coma flotante, retorna la precisión anteriot. Vea la tabla <code>ios::floatfield</code>
	para el significado de 'precisión'.
      </para>

      <!--
      The fill and precision values are fairly straightforward, but width
      requires some explanation. When the width is zero, inserting a value
      produces the minimum number of characters necessary to represent that
      value. A positive width means that inserting a value will produce at
      least as many characters as the width; if the value has fewer than width
      characters, the fill character pad the field. However, the value will
      never be truncated, so if you try to print 123 with a width of two, you'
      ll still get 123. The field width specifies a minimum number of
      characters; there's no way to specify a maximum number.
      -->
      <para>
	El relleno y la precisión son bastante claras, pero la anchura requiera alguna explicación. Cuando la anchura es 0,
	insertar un valor produce el mínimo número de carácteres necesario para representar este valor. Una anchura positiva
	significa que insertar un valor producirá al menos tantos carácteres como la anchura; si el valor tiene menos carácteres
	que la anchura, el carácter de relleno llena el campo. No obstante, el valor nunca será truncado, con lo que si usted
	intenta escribir 123 con una anchura de dos, seguirá obteniendo 123. El campo anchura especifica un minimo número de
	carácteres; no hay forma de especificar un número mínimo.
      </para>

      <!--
      The width is also distinctly different because it's reset to zero by
      each inserter or extractor that could be influenced by its value. It's
      really not a state variable, but rather an implicit argument to the
      inserters and extractors. If you want a constant width, call width( )
      after each insertion or extraction.
      -->
      <para>
	La anchura también es diferente por que vuelve a ser cero por cada insertador o extractor que puede ser influenciado por
	este valor. Realmente no es una variable de estado, sino más bien un argumento implícito para los extractores y insertadores.
	Si quiere una anchura constante, llame a <function>width()</function> despues de cada inserción o extracción.
      </para>

    </sect2>
    <sect2>
      <!-- : An exhaustive example -->
      <title>Un ejemplo exhaustivo</title>

      <!--
      To make sure you know how to call all the functions previously
      discussed, here's an example that calls them all:
      -->
      <para>
	Para estar seguros de que usted conoce como llamar a todas las funciones discutidas previamente, aquí tiene un ejemplo que las llama a todas:
      </para>

//: V2C04:Format.cpp

      <!--
      This example uses a trick to create a trace file so that you can monitor
      what's happening. The macro D(a) uses the preprocessor 'stringizing'
      to turn a into a string to display. Then it reiterates a so the
      statement is executed. The macro sends all the information to a file
      called T, which is the trace file. The output is
      -->
      <para>
	Este ejemplo usa un truco para crear un fichero de traza para que pueda monitorizar lo que está pasando. La macro D(a) usa el preprocesador
	'convirtiendo a string' para convertir a en una cadena para mostrar. Entonces se reitera a con lo que la sentencia se ejecuta. La macro
	envia toda la información a un fichero llamado T, que es el fichero de traza. La salida es:
      </para>


<screen>
int i = 47;
float f = 2300114.414159;
T.setf(ios::unitbuf);
T.setf(ios::showbase);
T.setf(ios::uppercase | ios::showpos);
T &lt;&lt; i &lt;&lt; endl;
+47
T.setf(ios::hex, ios::basefield);
T &lt;&lt; i &lt;&lt; endl;
0X2F
T.setf(ios::oct, ios::basefield);
T &lt;&lt; i &lt;&lt; endl;
057
T.unsetf(ios::showbase);
T.setf(ios::dec, ios::basefield);
T.setf(ios::left, ios::adjustfield);
T.fill('0');
T &lt;&lt; "fill char: " &lt;&lt; T.fill() &lt;&lt; endl;
fill char: 0
T.width(10);
+470000000
T.setf(ios::right, ios::adjustfield);
T.width(10);
0000000+47
T.setf(ios::internal, ios::adjustfield);
T.width(10);
+000000047
T &lt;&lt; i &lt;&lt; endl;
+47
T.unsetf(ios::showpos);
T.setf(ios::showpoint);
T &lt;&lt; "prec = " &lt;&lt; T.precision() &lt;&lt; endl;
prec = 6
T.setf(ios::scientific, ios::floatfield);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.300114E+06
T.unsetf(ios::uppercase);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.300114e+06
T.setf(ios::fixed, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.500000
T.precision(20);
T &lt;&lt; "prec = " &lt;&lt; T.precision() &lt;&lt; endl;
prec = 20
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2300114.50000000000000000000
T.setf(ios::scientific, ios::floatfield);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.30011450000000000000e+06
T.setf(ios::fixed, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.50000000000000000000
T.width(10);
Is there any more?
T.width(40);
0000000000000000000000Is there any more?
T.setf(ios::left, ios::adjustfield);
T.width(40);
Is there any more?0000000000000000000000
</screen>


      <!--
      Studying this output should clarify your understanding of the iostream
      formatting member functions.
      -->
      <para>
	Estudiar esta salida debería clarificar su entendimiento del formateo de las funciones miembro de iostream .
      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Manipulators -->
    <title>Manipuladores</title>

    <!--
    As you can see from the previous program, calling the member functions
    for stream formatting operations can get a bit tedious. To make things
    easier to read and write, a set of manipulators is supplied to duplicate
    the actions provided by the member functions. Manipulators are a
    convenience because you can insert them for their effect within a
    containing expression; you don't need to create a separate
    function-call statement.
    -->
    <para>
      Como puede ver en el programa previo, llamar a funciones miembro para operaciones de formateo de <classname>stream</classname>
      puede ser un poco tedioso. Para hacer las cosas mas fáciles de leer y escribir, existe un conjunto de manipuladores para duplicar
      las acciones previstas por las funciones miembro. Las manipuladores son convenientes por que usted puede insertarlos para que actuen
      dentro de una expresion contenedora; no necesita crear una sentencia de llamada a función separada.
    </para>

    <!--
    Manipulators change the state of the stream instead of (or in addition
    to) processing data. When you insert endl in an output expression, for
    example, it not only inserts a newline character, but it also flushes
    the stream (that is, puts out all pending characters that have been
    stored in the internal stream buffer but not yet output). You can also
    just flush a stream like this:
    -->
    <para>
      Los manipuladores cambian el estado de un <classname>stream</classname> en vez de (o además de) procesar los datos. Cuando
      insertamos un <function>endl</function> en una expresión de salida, por ejemplo, no solo inserta un carácter de nueva linea,
      sino que ademas termina el <classname>stream</classname> (esto es, saca todos los carácteres pendientes que han sido almacenadas
      en el buffer interno del <classname>stream</classname> pero todavia no en la salida). Puede terminar el <classname>stream</classname>
      simplemente asi:
    </para>


<programlisting>
cout &lt;&lt; flush;
</programlisting>


    <!-- which causes a call to the flush( ) member function, as in: -->
    <para>
      Lo que causa una llamada a la función miembro<function> flush()</function>, como esta:
    </para>


<programlisting>
cout.flush();
</programlisting>


    <!--
    as a side effect (nothing is inserted into the stream). Additional basic
    manipulators will change the number base to oct (octal), dec (decimal)
    or hex (hexadecimal):
    -->
    <para>
      como efecto lateral (nada es insertado dentro de <classname>stream</classname>). Adicionalmente los manipuladores
      básicos cambirán la base del número a oct (octal), dec (decimal) o hex (hexadecimal).
    </para>


<programlisting>
cout &lt;&lt; hex &lt;&lt; "0x" &lt;&lt; i &lt;&lt; endl;
</programlisting>


    <!--
    In this case, numeric output will continue in hexadecimal mode until you
    change it by inserting either dec or oct in the output stream.
    -->
    <para>
      En este caso, la salida numérica continuará en modo hexadecimal hasta que usted lo cambie insertando o dec o oct en el
      <classname>stream</classname> de salida.
    </para>

    <!-- There's also a manipulator for extraction that 'eats' white space: -->
    <para>
      También existe un manipulador para la extracción que se 'come' los espacios en blanco:
    </para>


<programlisting>
cin >> ws;
</programlisting>


    <!--
    Manipulators with no arguments are provided in <iostream>. These include
    dec, oct, and hex, which perform the same action as, respectively,
    setf(ios::dec, ios::basefield), setf(ios::oct, ios::basefield), and
    setf(ios::hex, ios::basefield), albeit more succinctly. The <iostream>
    header also includes ws, endl, and flush and the additional set shown
    here:
    -->
    <para>
      Los manipuladores sin argumentos son provistos en &lt;iostream&gt;. Esto incluye dec, oct,y hex, que hacen las
      mismas acciones que, respectivamente, <code>setf(ios::dec, ios::basefield)</code>,
      <code>setf(ios::oct, ios::basefield)</code>, y <code>setf(ios::hex, ios::basefield)</code>, aunque
      más sucintamente. La cabecera &lt;iostream&gt; también incluye ws, endl, y flush y el conjunto adicional mostrado aquí:
    </para>

    <!-- Manipulator -->
    <para>
      Manipulador
    </para>

    <!-- Effect -->
    <para>
      Efecto
    </para>

    <!-- showbase noshowbase -->
    <para>
      <emphasis>showbase noshowbase</emphasis>
    </para>

    <!--
    Indicate the numeric base (dec, oct, or hex) when printing an integral
    value.
    -->
    <para>
      Indica la base numérica (dec, oct, o hex) cuando imprimimos un entero.
    </para>

    <!-- showpos noshowpos -->
    <para>
      <emphasis>showpos noshowpos</emphasis>
    </para>

    <!-- Show plus sign (+) for positive values. -->
    <para>
      Muestra el signo más (+) para valores positivos.
    </para>

    <!-- uppercase nouppercase -->
    <para>
      <emphasis>uppercase nouppercase</emphasis>
    </para>

    <!--
    Display uppercase A-F for hexadecimal values, and display E for
    scientific values.
    -->
    <para>
      Muestra mayúsculas A-F para valores hexadecimales, y muestra E para valores científicos.
    </para>

    <!-- showpoint noshowpoint -->
    <para>
      <emphasis>showpoint noshowpoint</emphasis>
    </para>

    <!-- Show decimal point and trailing zeros for floating-point values. -->
    <para>
      Muestra punto decimal y ceros arrastrados para valores de coma flotante.
    </para>

    <!-- skipws noskipws -->
    <para>
      <emphasis>skipws noskipws</emphasis>
    </para>

    <!-- Skip white space on input. -->
    <para>
      Escapa los espacios en blanco en la entrada.
    </para>

    <!-- left right internal -->
    <para>
      <emphasis>left right internal</emphasis>
    </para>

    <!--
    Left-align, pad on right.  Right-align, pad on left.  Fill between
    leading sign or base indicator and value.
    -->
    <para>
      Alineación izquierda, relleno a la derecha. Alineación derecha, relleno a la izquierda. Rellenar entre el signo o el indicador de base y el valor.
    </para>

    <!-- scientific fixed -->
    <para>
      <emphasis>scientific fixed</emphasis>
    </para>

    <!--
    Indicates the display preference for floating-point output (scientific
    notation vs. fixed-point decimal).
    -->
    <para>
      Indica la preferencia al mostrar la salida para coma flotante (notación científica versus coma flotante decimal).
    </para>

    <sect2>
      <!-- : Manipulators with arguments -->
      <title>Manipuladores con argumentos</title>

      <!--
      There are six standard manipulators, such as setw( ), that take
      arguments. These are defined in the header file <iomanip>, and are
      summarized in the following table:
      -->
      <para>
	Existen seis manipuladores estándar, como <function>setw()</function>, que toman argumentos. Están definidos en el fichero de cabecera &lt;iomanip&gt;, y están enumerados en la siguiente tabla:
      </para>

      <!-- Manipulator -->
      <para>
	Manipulador
      </para>

      <!-- effect -->
      <para>
	Efecto
      </para>

      <!-- setiosflags(fmtflags n) -->
      <para>
	<function>setiosflags(fmtflags n)</function>
      </para>

      <!--
      Equivalent to a call to setf(n). The setting remains in effect until the
      next change, such as ios::setf( ).
      -->
      <para>
	Equivalente a una llamada a <function>setf(n)</function>. La activación continua hasta el siguiente cambio,
	como <function>ios::setf()</function>.
      </para>

      <!-- resetiosflags(fmtflags n) -->
      <para>
	<function>resetiosflags(fmtflags n)</function>
      </para>

      <!--
      Clears only the format flags specified by n. The setting remains in
      effect until the next change, such as ios::unsetf( ).
      -->
      <para>
	Limpia solo las banderas de formato especificadas por n. La activación permanece hasta el siguiente
	cambio, como <function>ios::unsetf()</function>.
      </para>

      <!-- setbase(base n) -->
      <para>
	<function>setbase(base n)</function>
      </para>

      <!--
      Changes base to n, where n is 10, 8, or 16. (Anything else results in
      0.) If n is zero, output is base 10, but input uses the C conventions:
      10 is 10, 010 is 8, and 0xf is 15. You might as well use dec, oct, and
      hex for output.
      -->
      <para>
	Cambia la base a n, donde n es 10, 8 o 16. (Caulquier otra opción resulta en 0). Si n es cero, la salida es base 10,
	pero la entrada usa convenciones de C: 10 es 10, 010 es 8, y 0xf es 15. Puede usar también dec, oct y hex para la salida.
      </para>

      <!-- setfill(char n) -->
      <para>
	<function>setfill(char n)</function>
      </para>

      <!-- Changes the fill character to n, such as ios::fill( ). -->
      <para>
	Cambia el carácter de relleno a n, como <function>ios::fill()</function>.
      </para>

      <!-- setprecision(int n) -->
      <para>
	<function>setprecision(int n)</function>
      </para>

      <!-- Changes the precision to n, such as ios::precision( ). -->
      <para>
	Cambia la precision a n, como <function>ios::precision()</function>.
      </para>

      <!-- setw(int n) -->
      <para>
	<function>setw(int n)</function>
      </para>

      <!-- Changes the field width to n, such as ios::width( ). -->
      <para>
	Cambia la anchura del campo a n, como en <function>ios::width()</function>
      </para>

      <!--
      If you're doing a lot of formatting, you can see how using manipulators
      instead of calling stream member functions can clean up your code. As an
      example, here's the program from the previous section rewritten to use
      the manipulators. (The D( ) macro is removed to make it easier to read.)
      -->
      <para>
	Si está usando mucho el formateo, usted puede ver como usar los manipuladores en vez de llamar a funciones
	miembro de stream puede limpiar su código. Como ejemplo, aquí tiene un programa de la sección previa reescrito
	para usar los manipuladores. (La macro D() ha sido borrada para hacerlo más fácil de leer).
      </para>

//: V2C04:Manips.cpp


      <!--
      You can see that a lot of the multiple statements have been condensed
      into a single chained insertion. Notice the call to setiosflags( ) in
      which the bitwise-OR of the flags is passed. This could also have been
      done with setf( ) and unsetf( ) as in the previous example.
      -->
      <para>
	Puede ver que un montón de sentencias múltiples han sido condensadas dentro de una sola inserción encadenada. Nótese
	que la llamada a setiosflags() en que se pasa el OR binario de las banderas. Esto se podría haber hecho también con
	<function>setf()</function> y <function>unsetf()</function> como en el ejemplo previo.
      </para>

      <!--
      When using setw( ) with an output stream, the output expression is
      formatted into a temporary string that is padded with the current fill
      character if needed, as determined by comparing the length of the
      formatted result to the argument of setw( ). In other words, setw( )
      affects the result string of a formatted output operation. Likewise,
      using setw( ) with input streams only is meaningful when reading
      strings, as the following example makes clear:
      -->
      <para>

      </para>

//: V2C04:InputWidth.cpp


      <!--
      If you attempt to read a string, setw( ) will control the number of
      characters extracted quite nicely' up to a point. The first extraction
      gets two characters, but the second only gets one, even though we asked
      for two. That is because operator>>( ) uses white space as a delimiter
      (unless you turn off the skipws flag). When trying to read a number,
      however, such as x, you cannot use setw( ) to limit the characters
      read. With input streams, use only setw( ) for extracting strings.
      -->
      <para>

      </para>

    </sect2>
    <sect2>
      <!-- : Creating manipulators -->
      <title> </title>

      <!--
      Sometimes you'd like to create your own manipulators, and it turns out
      to be remarkably simple. A zero-argument manipulator such as endl is
      simply a function that takes as its argument an ostream reference and
      returns an ostream reference. The declaration for endl is
      -->
      <para>

      </para>


<programlisting>
ostream&amp; endl(ostream&amp;);
</programlisting>


      <!-- Now, when you say: -->
      <para>

      </para>


<programlisting>
cout &lt;&lt; "howdy" &lt;&lt; endl;
</programlisting>


      <!--
      the endl produces the address of that function. So the compiler asks,
      'Is there a function that can be applied here that takes the address of
      a function as its argument'? Predefined functions in <iostream> do
      this; they're called applicators (because they apply a function to a
      stream). The applicator calls its function argument, passing it the
      ostream object as its argument. You don't need to know how applicators
      work to create your own manipulator; you only need to know that they
      exist. Here's the (simplified) code for an ostream applicator:
      -->
      <para>

      </para>


<programlisting>
ostream&amp; ostream::operator&lt;&lt;(ostream&amp; (*pf)(ostream&amp;)) {
   return pf(*this);
}
</programlisting>


      <!--
      The actual definition is a little more complicated since it involves
      templates, but this code illustrates the technique. When a function such
      as *pf (that takes a stream parameter and returns a stream reference) is
      inserted into a stream, this applicator function is called, which in
      turn executes the function to which pf points. Applicators for ios_base,
      basic_ios, basic_ostream, and basic_istream are predefined in the
      Standard C++ library.
      -->
      <para>

      </para>

      <!--
      To illustrate the process, here's a trivial example that creates a
      manipulator called nl that is equivalent to just inserting a newline
      into a stream (i.e., no flushing of the stream occurs, as with endl):
      -->
      <para>

      </para>

//: V2C04:nl.cpp


      <!--
      When you insert nl into an output stream, such as cout, the following
      sequence of calls ensues:
      -->
      <para>

      </para>


<programlisting>
cout.operator&lt;&lt;(nl) è nl(cout)
</programlisting>


      <!-- The expression -->
      <para>

      </para>


<programlisting>
os &lt;&lt; '\n';
</programlisting>


      <!--
      inside nl( ) calls ostream::operator(char), which returns the stream,
      which is what is ultimately returned from nl( ).[47]
      -->
      <para>

      </para>

    </sect2>
    <sect2>
      <!-- : Effectors -->
      <title> </title>

      <!--
      As you've seen, zero-argument manipulators are easy to create. But what
      if you want to create a manipulator that takes arguments? If you inspect
      the <iomanip> header, you'll see a type called smanip, which is what
      the manipulators with arguments return. You might be tempted to somehow
      use that type to define your own manipulators, but don't do it. The
      smanip type is implementation-dependent and thus not
      portable. Fortunately, you can define such manipulators in a
      straightforward way without any special machinery, based on a technique
      introduced by Jerry Schwarz, called an effector.[48] An effector is a
      simple class whose constructor formats a string representing the desired
      operation, along with an overloaded operator<< to insert that string
      into a stream. Here's an example with two effectors. The first outputs
      a truncated character string, and the second prints a number in binary.
      -->
      <para>

      </para>

//: V2C04:Effector.cpp


      <!--
      The constructor for Fixw creates a shortened copy of its char* argument,
      and the destructor releases the memory created for this copy. The
      overloaded operator<< takes the contents of its second argument, the
      Fixw object, inserts it into the first argument, the ostream, and then
      returns the ostream so that it can be used in a chained expression. When
      you use Fixw in an expression like this: cout << Fixw(string, i) <<
      endl;
      -->
      <para>

      </para>

      <!--
      a temporary object is created by the call to the Fixw constructor, and
      that temporary object is passed to operator<<. The effect is that of a
      manipulator with arguments. The temporary Fixw object persists until the
      end of the statement.
      -->
      <para>

      </para>

      <!--
      The Bin effector relies on the fact that shifting an unsigned number to
      the right shifts zeros into the high bits. We use
      numeric_limits<unsigned long>::max( ) (the largest unsigned long value,
      from the standard header <limits>) to produce a value with the high bit
      set, and this value is moved across the number in question (by shifting
      it to the right), masking each bit in turn. We've juxtaposed string
      literals in the code for readability; the separate strings are
      concatenated into a single string by the compiler.
      -->
      <para>

      </para>

      <!--
      Historically, the problem with this technique was that once you created
      a class called Fixw for char* or Bin for unsigned long, no one else
      could create a different Fixw or Bin class for their type. However, with
      namespaces, this problem is eliminated. Effectors and manipulators aren'
      t equivalent, although they can often be used to solve the same
      problem. If you find that an effector isn't enough, you will need to
      conquer the complexity of manipulators.
      -->
      <para>

      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Iostream examples -->
    <title> </title>

    <!--
    In this section you'll see examples that use what you've learned in
    this chapter. Although many tools exist to manipulate bytes (stream
    editors such as sed and awk from UNIX are perhaps the most well known,
    but a text editor also fits this category), they generally have some
    limitations. Both sed and awk can be slow and can only handle lines in a
    forward sequence, and text editors usually require human interaction, or
    at least learning a proprietary macro language. The programs you write
    with iostreams have none of these limitations: they're fast, portable,
    and flexible.
    -->
    <para>

    </para>

    <sect2>
      <!-- : Maintaining class library source code -->
      <title> </title>

      <!--
      Generally, when you create a class, you think in library terms: you make
      a header file Name.h for the class declaration, and then create a file
      called Name.cpp where the member functions are implemented. These files
      have certain requirements: a particular coding standard (the program
      shown here uses the coding format for this book), and preprocessor
      statements surrounding the code in the header file to prevent multiple
      declarations of classes. (Multiple declarations confuse the compiler?it
      doesn't know which one you want to use. They could be different, so it
      throws up its hands and gives an error message.)
      -->
      <para>

      </para>

      <!--
      This example creates a new header/implementation pair of files or
      modifies an existing pair. If the files already exist, it checks and
      potentially modifies the files, but if they don't exist, it creates
      them using the proper format.
      -->
      <para>

      </para>

//: V2C04:Cppcheck.cpp


      <!--
      First notice the useful function startsWith( ), which does just what its
      name says?it returns true if the first string argument starts with the
      second argument. This is used when looking for the expected comments and
      include-related statements. Having the array of strings, part, allows
      for easy looping through the series of expected statements in source
      code. If the source file doesn't exist, we merely write the statements
      to a new file of the given name. If the file does exist, we search a
      line at a time, verifying that the expected lines occur. If they are not
      present, they are inserted. Special care must be taken to make sure we
      don't drop existing lines (see where we use the Boolean variable
      lineUsed). Notice that we use a stringstream for an existing file, so we
      can first write the contents of the file to it and then read from and
      search it.
      -->
      <para>

      </para>

      <!--
      The names in the enumeration are BASE, the capitalized base file name
      without extension; HEADER, the header file name; IMPLEMENT, the
      implementation file (cpp) name; HLINE1, the skeleton first line of the
      header file; GUARD1, GUARD2, and GUARD3, the 'guard' lines in the
      header file (to prevent multiple inclusion); CPPLINE1, the skeleton
      first line of the cpp file; and INCLUDE, the line in the cpp file that
      includes the header file.
      -->
      <para>

      </para>

      <!--
      If you run this program without any arguments, the following two files
      are created:
      -->
      <para>

      </para>

 <programlisting>
// CPPCHECKTEST.h
#ifndef CPPCHECKTEST_H
#define CPPCHECKTEST_H
#endif // CPPCHECKTEST_H
</programlisting>


 <programlisting>
// PPCHECKTEST.cpp
#include "CPPCHECKTEST.h"
</programlisting>


      <!--
      (We removed the colon after the double-slash in the first comment lines
      so as not to confuse the book's code extractor. It will appear in the
      actual output produced by cppCheck.)
      -->
      <para>

      </para>

      <!--
      You can experiment by removing selected lines from these files and
      re-running the program. Each time you will see that the correct lines
      are added back in. When a file is modified, the string '//@//' is
      placed as the first line of the file to bring the change to your
      attention. You will need to remove this line before you process the file
      again (otherwise cppcheck will assume the initial comment line is
      missing).
      -->
      <para>

      </para>

    </sect2>
    <sect2>
      <!-- : Detecting compiler errors -->
      <title> </title>

      <!--
      All the code in this book is designed to compile as shown without
      errors. Lines of code that should generate a compile-time error may be
      commented out with the special comment sequence '//!'. The following
      program will remove these special comments and append a numbered comment
      to the line. When you run your compiler, it should generate error
      messages, and you will see all the numbers appear when you compile all
      the files. This program also appends the modified line to a special file
      so that you can easily locate any lines that don't generate errors.
      -->
      <para>

      </para>

//: V2C04:Showerr.cpp {RunByHand}


      <!-- You can replace the marker with one of your choice. -->
      <para>

      </para>

      <!--
      Each file is read a line at a time, and each line is searched for the
      marker appearing at the head of the line; the line is modified and put
      into the error line list and into the string stream, edited. When the
      whole file is processed, it is closed (by reaching the end of a scope),
      it is reopened as an output file, and edited is poured into the
      file. Also notice the counter is saved in an external file. The next
      time this program is invoked, it continues to increment the counter.
      -->
      <para>

      </para>

    </sect2>
    <sect2>
      <!-- : A simple data logger -->
      <title> </title>

      <!--
      This example shows an approach you might take to log data to disk and
      later retrieve it for processing. It is meant to produce a
      temperature-depth profile of the ocean at various points. The DataPoint
      class holds the data:
      -->
      <para>

      </para>

//: V2C04:DataLogger.h


      <!--
      A DataPoint consists of a time stamp, which is stored as a time_t value
      as defined in <ctime>, longitude and latitude coordinates, and values
      for depth and temperature. We use inserters for easy formatting. Here's
      the implementation file:
      -->
      <para>

      </para>

//: V2C04:DataLogger.cpp {O}


      <!--
      The Coord::toString( ) function is necessary because the DataPoint
      inserter calls setw( ) before it prints the latitude and longitude. If
      we used the stream inserter for Coord instead, the width would only
      apply to the first insertion (that is, to Coord::deg), since width
      changes are always reset immediately. The call to setf( ) causes the
      floating-point output to be fixed-precision, and precision( ) sets the
      number of decimal places to four. Notice how we restore the fill
      character and precision to whatever they were before the inserter was
      called.
      -->
      <para>

      </para>

      <!--
      To get the values from the time encoding stored in DataPoint::timestamp,
      we call the function std::localtime( ), which returns a static pointer
      to a tm object. The tm struct has the following layout:
      -->
      <para>

      </para>

      <!--
      struct tm { int tm_sec; // 0-59 seconds int tm_min; // 0-59 minutes int
      tm_hour; // 0-23 hours int tm_mday; // Day of month int tm_mon; //
      0-11 months int tm_year; // Years since 1900 int tm_wday; // Sunday ==
      0, etc.  int tm_yday; // 0-365 day of year int tm_isdst; // Daylight
      savings?  };
      -->
      <para>

      </para>

      <!-- Generating test data -->
      <para>

      </para>

      <!--
      Here's a program that creates a file of test data in binary form (using
      write( )) and a second file in ASCII form using the DataPoint
      inserter. You can also print it out to the screen, but it's easier to
      inspect in file form.
      -->
      <para>

      </para>

//: V2C04:Datagen.cpp


      <!--
      The file data.txt is created in the ordinary way as an ASCII file, but
      data.bin has the flag ios::binary to tell the constructor to set it up
      as a binary file. To illustrate the formatting used for the text file,
      here is the first line of data.txt (the line wraps because it's longer
      than this page will allow): 07\28\2003 12:54:40 Lat:45*20'31",
      Long:22*34'18", depth: 16.0164, temp: 242.0122
      -->
      <para>

      </para>

      <!--
      The Standard C library function time( ) updates the time_t value its
      argument points to with an encoding of the current time, which on most
      platforms is the number of seconds elapsed since 00: 00: 00 GMT, January
      1 1970 (the dawning of the age of Aquarius?). The current time is also a
      convenient way to seed the random number generator with the Standard C
      library function srand( ), as is done here.
      -->
      <para>

      </para>

      <!--
      After this, the timer is incremented by 55 seconds to give an
      interesting interval between readings in this simulation.
      -->
      <para>

      </para>

      <!--
      The latitude and longitude used are fixed values to indicate a set of
      readings at a single location. Both the depth and the temperature are
      generated with the Standard C library rand( ) function, which returns a
      pseudorandom number between zero and a platform-dependent constant,
      RAND_MAX, defined in <cstdlib> (usually the value of the platform's
      largest unsigned integer). To put this in a desired range, use the
      remainder operator % and the upper end of the range. These numbers are
      integral; to add a fractional part, a second call to rand( ) is made,
      and the value is inverted after adding one (to prevent divide-by-zero
      errors).
      -->
      <para>

      </para>

      <!--
      In effect, the data.bin file is being used as a container for the data
      in the program, even though the container exists on disk and not in
      RAM. write( ) sends the data out to the disk in binary form. The first
      argument is the starting address of the source block?notice it must be
      cast to a char* because that's what write( ) expects for narrow
      streams. The second argument is the number of characters to write, which
      in this case is the size of the DataPoint object (again, because we're
      using narrow streams). Because no pointers are contained in DataPoint,
      there is no problem in writing the object to disk. If the object is more
      sophisticated, you must implement a scheme for serialization, which
      writes the data referred to by pointers and defines new pointers when
      read back in later. (We don't talk about serialization in this
      volume?most vendor class libraries have some sort of serialization
      structure built into them.)  Verifying and viewing the data
      -->
      <para>

      </para>

      <!--
      To check the validity of the data stored in binary format, you can read
      it into memory with the read( ) member function for input streams, and
      compare it to the text file created earlier by Datagen.cpp. The
      following example just writes the formatted results to cout, but you can
      redirect this to a file and then use a file comparison utility to verify
      that it is identical to the original:
      -->
      <para>

      </para>

//: V2C04:Datascan.cpp

    </sect2>
  </sect1>
  <sect1>
    <!-- : Internationalization -->
    <title> </title>

    <!--
    The software industry is now a healthy, worldwide economic market, with
    demand for applications that can run in various languages and
    cultures. As early as the late 1980s, the C Standards Committee added
    support for non-U.S. formatting conventions with their locale
    mechanism. A locale is a set of preferences for displaying certain
    entities such as dates and monetary quantities. In the 1990s, the C
    Standards Committee approved an addendum to Standard C that specified
    functions to handle wide characters (denoted by the type wchar_t), which
    allow support for character sets other than ASCII and its commonly used
    Western European extensions. Although the size of a wide character is
    not specified, some platforms implement them as 32-bit quantities, so
    they can hold the encodings specified by the Unicode Consortium, as well
    as mappings to multi-byte characters sets defined by Asian standards
    bodies. C++ has integrated support for both wide characters and locales
    into the iostreams library.
    -->
    <para>

    </para>

    <sect2>
      <!-- : Wide Streams -->
      <title> </title>

      <!--
      A wide stream is a stream class that handles wide characters. All the
      examples so far (except for the last traits example in Chapter 3) have
      used narrow streams that hold instances of char. Since stream operations
      are essentially the same no matter the underlying character type, they
      are encapsulated generically as templates. So all input streams, for
      example, are connected to the basic_istream class template:
      template<class charT, class traits = char_traits<charT> > class
      basic_istream {...};
      -->
      <para>

      </para>

      <!--
      In fact, all input stream types are specializations of this template,
      according to the following type definitions:
      -->
      <para>

      </para>

      <!--
      typedef basic_istream<char> istream; typedef basic_istream<wchar_t>
      wistream; typedef basic_ifstream<char> ifstream; typedef
      basic_ifstream<wchar_t> wifstream; typedef basic_istringstream<char>
      istringstream; typedef basic_istringstream<wchar_t> wistringstream;
      -->
      <para>

      </para>

      <!-- All other stream types are defined in similar fashion. -->
      <para>

      </para>

      <!--
      In a perfect world, this is all you'd need to create streams of
      different character types. But things aren't that simple. The reason is
      that the character-processing functions provided for char and wchar_t
      don't have the same names. To compare two narrow strings, for example,
      you use the strcmp( ) function. For wide characters, that function is
      named wcscmp( ). (Remember these originated in C, which does not have
      function overloading, hence unique names are required.) For this reason,
      a generic stream can't just call strcmp( ) in response to a comparison
      operator. There needs to be a way for the correct low-level functions to
      be called automatically.
      -->
      <para>

      </para>

      <!--
      The solution is to factor out the differences into a new
      abstraction. The operations you can perform on characters have been
      abstracted into the char_traits template, which has predefined
      specializations for char and wchar_t, as we discussed at the end of the
      previous chapter. To compare two strings, then, basic_string just calls
      traits::compare( ) (remember that traits is the second template
      parameter), which in turn calls either strcmp( ) or wcscmp( ), depending
      on which specialization is being used (transparent to basic_string).
      -->
      <para>

      </para>

      <!--
      You only need to be concerned about char_traits if you access the
      low-level character processing functions; most of the time you don't
      care. Consider, however, making your inserters and extractors more
      robust by defining them as templates, just in case someone wants to use
      them on a wide stream.
      -->
      <para>

      </para>

      <!--
      To illustrate, recall again the Date class inserter from the beginning
      of this chapter. We originally declared it as: ostream&
      operator<<(ostream&, const Date&);
      -->
      <para>

      </para>

      <!--
      This accommodates only narrow streams. To make it generic, we simply
      make it a template based on basic_ostream:
      -->
      <para>

      </para>

      <!--
      template<class charT, class traits> std::basic_ostream<charT, traits>&
      operator<<(std::basic_ostream<charT, traits>& os, const Date& d) { charT
      fillc = os.fill(os.widen('0')); charT dash = os.widen('-'); os <<
      setw(2) << d.month << dash << setw(2) << d.day << dash << setw(4) <<
      d.year; os.fill(fillc); return os; }
      -->
      <para>

      </para>

      <!--
      Notice that we also have to replace char with the template parameter
      charT in the declaration of fillc, since it could be either char or
      wchar_t, depending on the template instantiation being used.
      -->
      <para>

      </para>

      <!--
      Since you don't know when you're writing the template which type of
      stream you have, you need a way to automatically convert character
      literals to the correct size for the stream. This is the job of the
      widen( ) member function. The expression widen('-'), for example,
      converts its argument to L'-' (the literal syntax equivalent to the
      conversion wchar_t('-')) if the stream is a wide stream and leaves it
      alone otherwise. There is also a narrow( ) function that converts to a
      char if needed.
      -->
      <para>

      </para>

      <!--
      We can use widen( ) to write a generic version of the nl manipulator we
      presented earlier in the chapter.
      -->
      <para>

      </para>

      <!--
      template<class charT, class traits> basic_ostream<charT,traits>&
      nl(basic_ostream<charT,traits>& os) { return os <<
      charT(os.widen('\n')); }
      -->
      <para>

      </para>

    </sect2>
    <sect2>
      <!-- : Locales -->
      <title> </title>

      <!--
      Perhaps the most notable difference in typical numeric computer output
      from country to country is the punctuator used to separate the integer
      and fractional parts of a real number. In the United States, a period
      denotes a decimal point, but in much of the world, a comma is expected
      instead. It would be quite inconvenient to do all your own formatting
      for locale-dependent displays. Once again, creating an abstraction that
      handles these differences solves the problem.
      -->
      <para>

      </para>

      <!--
      That abstraction is the locale. All streams have an associated locale
      object that they use for guidance on how to display certain quantities
      for different cultural environments. A locale manages the categories of
      culture-dependent display rules, which are defined as follows:
      -->
      <para>

      </para>

      <!-- Category -->
      <para>

      </para>

      <!-- Effect -->
      <para>

      </para>

      <!-- collate -->
      <para>

      </para>

      <!--
      Allows comparing strings according to different, supported collating
      sequences.
      -->
      <para>

      </para>

      <!-- ctype -->
      <para>

      </para>

      <!--
      Abstracts the character classification and conversion facilities found
      in <cctype>.
      -->
      <para>

      </para>

      <!-- monetary -->
      <para>

      </para>

      <!-- Supports different displays of monetary quantities. -->
      <para>

      </para>

      <!-- numeric -->
      <para>

      </para>

      <!--
      Supports different display formats of real numbers, including radix
      (decimal point) and grouping (thousands) separators.
      -->
      <para>

      </para>

      <!-- time -->
      <para>

      </para>

      <!-- Supports various international formats for display of date and time. -->
      <para>

      </para>

      <!-- messages -->
      <para>

      </para>

      <!--
      Scaffolding to implement context-dependent message catalogs (such as for
      error messages in different languages).
      -->
      <para>

      </para>

      <!-- The following program illustrates basic locale behavior: -->
      <para>

      </para>

//: V2C04:Locale.cpp {-g++}{-bor}{-edg} {RunByHand}

      <!-- Here's the output: -->
      <para>

      </para>

      <!--
      C C 1234.56 French_France.1252 1234,56 Enter the literal 7890,12:
      7890,12 7890,12 7890.12
      -->
      <para>

      </para>

      <!--
      The default locale is the 'C' locale, which is what C and C++
      programmers have been used to all these years (basically, English
      language and American culture). All streams are initially 'imbued'
      with the 'C' locale. The imbue( ) member function changes the locale
      that a stream uses. Notice that the full ISO name for the 'French'
      locale is displayed (that is, French used in France vs. French used in
      another country). This example shows that this locale uses a comma for a
      radix point in numeric display. We have to change cin to the same locale
      if we want to do input according to the rules of this locale.
      -->
      <para>

      </para>

      <!--
      Each locale category is divided into number of facets, which are classes
      encapsulating the functionality that pertains to that category. For
      example, the time category has the facets time_put and time_get, which
      contain functions for doing time and date input and output
      respectively. The monetary category has facets money_get, money_put, and
      moneypunct. (The latter facet determines the currency symbol.) The
      following program illustrates the moneypunct facet. (The time facet
      requires a sophisticated use of iterators which is beyond the scope of
      this chapter.)
      -->
      <para>

      </para>

//: V2C04:Facets.cpp {-bor}{-g++}{-mwcc}{-edg}

      <!-- The output shows the French currency symbol and decimal separator: -->
      <para>

      </para>

      <!-- I made Ç12,34 today! -->
      <para>

      </para>

      <!--
      You can also define your own facets to construct customized locales.[49]
      Be aware that the overhead for locales is considerable. In fact, some
      library vendors provide different 'flavors' of the Standard C++
      library to accommodate environments that have limited space.[50]
      -->
      <para>

      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- : Summary -->
    <title> </title>

    <!--
    This chapter has given you a fairly thorough introduction to the
    iostream class library. What you've seen here is likely to be all you
    need to create programs using iostreams. However, be aware that some
    additional features in iostreams are not used often, but you can
    discover them by looking at the iostream header files and by reading
    your compiler's documentation on iostreams or the references mentioned
    in this chapter and in the appendices.
    -->
    <para>

    </para>

  </sect1>
  <sect1>
    <!-- : Exercises -->
    <title> </title>

    <!--
    Solutions to selected exercises can be found in the electronic document
    The Thinking in C++ Volume 2 Annotated Solution Guide, available for a
    small fee from www.MindView.net.
    -->
    <para>

    </para>

    <!--
    1.  Open a file by creating an ifstream object. Make an ostringstream
    object and read the entire contents into the ostringstream using the
    rdbuf( ) member function. Extract a string copy of the underlying buffer
    and capitalize every character in the file using the Standard C toupper(
    ) macro defined in <cctype>. Write the result out to a new file.
    -->
    <para>

    </para>

    <!--
    2.  Create a program that opens a file (the first argument on the
    command line) and searches it for any one of a set of words (the
    remaining arguments on the command line). Read the input a line at a
    time, and write out the lines (with line numbers) that match to the new
    file.
    -->
    <para>

    </para>

    <!--
    3.  Write a program that adds a copyright notice to the beginning of all
    source-code files indicated by the program's command-line arguments.
    -->
    <para>

    </para>

    <!--
    4.  Use your favorite text-searching program (grep, for example) to
    output the names (only) of all the files that contain a particular
    pattern. Redirect the output into a file. Write a program that uses the
    contents of that file to generate a batch file that invokes your editor
    on each of the files found by the search program.
    -->
    <para>

    </para>

    <!--
    5.  We know that setw( ) allows for a minimum of characters read in, but
    what if you wanted to read a maximum? Write an effector that allows the
    user to specify a maximum number of characters to extract. Have your
    effector also work for output, in such a way that output fields are
    truncated, if necessary, to stay within width limits.
    -->
    <para>

    </para>

    <!--
    6.  Demonstrate to yourself that if the fail or bad bit is set, and you
    subsequently turn on stream exceptions, that the stream will immediately
    throw an exception.
    -->
    <para>

    </para>

    <!--
    7.  String streams accommodate easy conversions, but they come with a
    price. Write a program that races atoi( ) against the stringstream
    conversion system to see the effect of the overhead involved with
    stringstream.
    -->
    <para>

    </para>

    <!--
    8.  Make a Person struct with fields such as name, age, address,
    etc. Make the string fields fixed-size arrays. The social security
    number will be the key for each record. Implement the following Database
    class:
    -->
    <para>

    </para>

    <!--
    class DataBase { public: // Find where a record is on disk size_t
    query(size_t ssn); // Return the person at rn (record number) Person
    retrieve(size_t rn); // Record a record on disk void add(const Person&
    p); };
    -->
    <para>

    </para>

    <!--
    Write some Person records to disk (do not keep them all in memory). When
    the user requests a record, read it off the disk and return it. The I/O
    operations in the DataBase class use read( ) and write( ) to process all
    Person records.
    -->
    <para>

    </para>

    <!--
    9.  Write an operator<< inserter for the Person struct that can be used
    to display records in a format for easy reading. Demonstrate it by
    writing data out to a file.
    -->
    <para>

    </para>

    <!--
    10.  Suppose the database for your Person structs was lost but that you
    have the file you wrote from the previous exercise. Recreate your
    database using this file. Be sure to use error checking.
    -->
    <para>

    </para>

    <!--
    11.  Write size_t(-1) (the largest unsigned int on your platform) to a
    text file 1,000,000 times. Repeat, but write to a binary file. Compare
    the size of the two files, and see how much room is saved using the
    binary format. (You may first want to calculate how much will be saved
    on your platform.)
    -->
    <para>

    </para>

    <!--
    12.  Discover the maximum number of digits of precision your
    implementation of iostreams will print by repeatedly increasing the
    value of the argument to precision( ) when printing a transcendental
    number such as sqrt(2.0).
    -->
    <para>

    </para>

    <!--
    13.  Write a program that reads real numbers from a file and prints
    their sum, average, minimum, and maximum.
    -->
    <para>

    </para>

    <!--
    14.  Determine the output of the following program before it is
    executed:
    -->
    <para>

    </para>

//: V2C04:Exercise14.cpp


    <!--
    15.  Suppose you are given line-oriented data in a file formatted as
    follows:
    -->
    <para>

    </para>

//: V2C04:Exercise15.txt


    <!--
    The heading of each section is a region, and every line under that
    heading is a seller in that region. Each comma-separated field
    represents the data about each seller. The first field in a line is the
    SELLER_ID which unfortunately was written out in hexadecimal format. The
    second is the PHONE_NUMBER (notice that some are missing area
    codes). LAST_NAME and FIRST_NAME then follow. TOTAL_SALES is the second
    to the last column. The last column is the decimal amount of the total
    sales that the seller represents for the company. You are to format the
    data on the terminal window so that an executive can easily interpret
    the trends. Sample output is given below.
    -->
    <para>

    </para>

    <!-- Australia -->
    <para>

    </para>

    <!--   _______________________________   -->
    <para>

    </para>

    <!-- *Last Name* *First Name* *ID* *Phone* *Sales* *Percent* -->
    <para>

    </para>

    <!-- Langler Tyson 24150 766-723-0284 31.24 4.21E-02 -->
    <para>

    </para>

    <!-- Oneill Zeke 11159 XXX-758-6701 553.43 7.47E-01 -->
    <para>

    </para>

    <!-- (etc.) -->
    <para>

    </para>
  </sect1>
</chapter>
