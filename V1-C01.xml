<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml; coding: utf-8 -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: Gloria Barberán González
  Formateado DocBook:  ""
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C1"
  >
  
  <!--
  1: Introduction to Objects
  -->

  <title>Introducción a los Objetos</title>

  <!-- 
  The genesis of the computer revolution was in a machine. The genesis
  of our programming languages thus tends to look like that machine.
  -->

  <highlights>
    <para>
      El origen de la revolución informática ocurrió dentro de una
      máquina. Por tanto, el origen de nuestros lenguajes de
      programación tiende a parecerse a esa máquina.
    </para>
  </highlights>

  <!--
  But computers are not so much machines as they are mind
  amplification tools ("bicycles for the mind", as Steve Jobs is fond
  of saying) and a different kind of expressive medium. As a result,
  the tools are beginning to look less like machines and more like
  parts of our minds, and also like other expressive mediums such as
  writing, painting, sculpture, animation, and
  filmmaking. Object-oriented programming is part of this movement
  toward using the computer as an expressive medium.
  -->
  <para>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente (<quote>bicicletas para la mente</quote>,
    como le gusta decir a <personname> <firstname>Steve</firstname>
    <surname>Jobs</surname></personname>) y un medio de expresión
    diferente.  Como resultado, las herramientas empiezan a parecerse
    menos a las máquinas y más a partes de nuestras mentes, y también a
    otros medios de expresión como la escritura, la pintura, la
    escultura, la animación y la cinematografía. La programación
    orientada a objetos es parte de este movimiento hacia un uso del
    ordenador como medio de expresión.
  </para>

  <!--
  This chapter will introduce you to the basic concepts of
  object-oriented programming (OOP), including an overview of OOP
  development methods. This chapter, and this book, assume that you
  have had experience in a procedural programming language, although
  not necessarily C. If you think you need more preparation in
  programming and the syntax of C before tackling this book, you
  should work through the "Thinking in C: Foundations for C++ and

  Java" training CD ROM, bound in with this book and also available at
  www.BruceEckel.com.
  -->
  <para>
    Este capítulo le servirá de introducción a los conceptos básicos de
    la programación orientada a objetos (POO), incluyendo un resumen de
    los métodos de desarrollo de la POO. Este capítulo, y este libro,
    presuponen que el lector ya tiene experiencia con un lenguaje de
    programación procedural, aunque no tiene porqué ser C. Si cree que
    necesita más preparación en programación y en la sintaxis de C antes
    de abordar este libro, debería leer el CD-ROM de entrenamiento
    <citetitle>Thinking in C: Foundations for C++ and Java</citetitle>,
    que acompaña a este libro, y está disponible también en <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
  </para>

  <!--
  This chapter is background and supplementary material. Many people
  do not feel comfortable wading into object-oriented programming
  without understanding the big picture first. Thus, there are many
  concepts that are introduced here to give you a solid overview of
  OOP. However, many other people don't get the big picture concepts
  until they've seen some of the mechanics first; these people may
  become bogged down and lost without some code to get their hands
  on. If you're part of this latter group and are eager to get to the
  specifics of the language, feel free to jump past this chapter-
  skipping it at this point will not prevent you from writing programs
  or learning the language. However, you will want to come back here
  eventually to fill in your knowledge so you can understand why
  objects are important and how to design with them.
  -->
  <para>
    Este capítulo contiene material básico y suplementario. Mucha gente
    no se siente cómoda adentrándose en la programación orientada a
    objetos sin tener antes una visión global. Por eso, aquí se
    introducen muchos conceptos que intentan darle una visión sólida de
    la POO. Sin embargo, muchas personas no captan los conceptos
    globales hasta que no han visto primero parte de la mecánica; puede
    que se atasquen o pierdan si no hay ningún trozo de código al que
    ponerle las manos encima. Si usted pertenece a este último grupo, y
    está ansioso por llegar a las especificaciones del lenguaje,
    siéntase libre de saltar este capítulo; eso no le impedirá
    escribir programas o aprender el lenguaje. Sin embargo, quizá quiera
    volver a este capítulo para completar sus conocimientos y poder
    comprender porqué son importantes los objetos y cómo diseñar con
    ellos.
  </para>

  <sect1>

    <!--  The progress of abstraction  -->
    <title>El progreso de abstracción</title>

    <!--
    All programming languages provide abstractions. It can be argued
    that the complexity of the problems you're able to solve is
    directly related to the kind and quality of abstraction. By "kind"
    I mean, "What is it that you are abstracting?" Assembly language
    is a small abstraction of the underlying machine. Many so-called
    "imperative" languages that followed (such as Fortran, BASIC, and
    C) were abstractions of assembly language. These languages are big
    improvements over assembly language, but their primary abstraction
    still requires you to think in terms of the structure of the
    computer rather than the structure of the problem you are trying
    to solve. The programmer must establish the association between
    the machine model (in the "solution space", which is the place
    where you're modeling that problem, such as a computer) and the
    model of the problem that is actually being solved (in the
    "problem space", which is the place where the problem exists). The
    effort required to perform this mapping, and the fact that it is
    extrinsic to the programming language, produces programs that are
    difficult to write and expensive to maintain, and as a side effect
    created the entire "programming methods" industry.
  -->

    <para>
      Todos los lenguajes de programación proporcionan abstracciones. Se
      puede afirmar que la complejidad de los problemas que se pueden
      resolver está directamente relacionada con el tipo y calidad de la
      abstracción. Por <quote>tipo</quote> me refiero a <quote>¿Qué es
      lo que está abstrayendo?</quote>. El lenguaje ensamblador es una
      pequeña abstracción de la máquina subyacente. Muchos lenguajes
      llamados <quote>imperativos</quote> que siguieron (como Fortran,
      BASIC y C) eran abstracciones del lenguaje ensamblador. Estos
      lenguajes suponen grandes mejoras con respecto al lenguaje
      ensamblador, pero su abstracción primaria todavía requiere pensar
      en términos de la estructura del ordenador, en lugar de la
      estructura del problema que intenta resolver. El programador debe
      establecer la asociación entre el modelo de la máquina (en el
      <quote>espacio de soluciones</quote>, que es el lugar donde está
      modelando ese problema, como un ordenador) y el modelo del
      problema que se está resolviendo (en el <quote>espacio de
      problemas</quote>, que es el lugar donde existe el problema). El
      esfuerzo requerido para realizar esta correspondencia, y el hecho
      de que sea extrínseco al lenguaje de programación, produce
      programas difíciles de escribir y caros de mantener y, como efecto
      secundario, creó toda la industria de <quote>métodos de
      programación</quote>.
    </para>

    <!--
    The alternative to modeling the machine is to model the problem
    you're trying to solve. Early languages such as LISP and APL chose
    particular views of the world ("All problems are ultimately lists"
    or "All problems are algorithmic"). PROLOG casts all problems into
    chains of decisions. Languages have been created for
    constraint-based programming and for programming exclusively by
    manipulating graphical symbols. (The latter proved to be too
    restrictive.) Each of these approaches is a good solution to the
    particular class of problem they' designed to solve, but when you
    step outside of that domain they become awkward.
    -->
    <para>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como LISP y
      APL eligieron concepciones del mundo particulares
      (<quote>Todos los problemas son listas en última
      instancia</quote>, o <quote>Todos los problemas son
      algorítmicos</quote>). PROLOG reduce todos los problemas a
      cadenas de decisiones. Se han creado lenguajes para programación
      basados en restricciones y para programar manipulando
      exclusivamente símbolos gráficos (lo último demostró ser
      demasiado restrictivo). Cada uno de estos métodos es una buena
      solución para el tipo particular de problema para el que fueron
      diseñados, pero cuando uno sale de ese dominio se hacen
      difíciles de usar.
    </para>
      
    <!--
    The object-oriented approach goes a step farther by providing
    tools for the programmer to represent elements in the problem
    space. This representation is general enough that the programmer
    is not constrained to any particular type of problem. We refer to
    the elements in the problem space and their representations in the
    solution space as "objects". (Of course, you will also need other
    objects that don't have problem-space analogs.) The idea is that
    the program is allowed to adapt itself to the lingo of the problem
    by adding new types of objects, so when you read the code
    describing the solution, you're reading words that also express
    the problem. This is a more flexible and powerful language
    abstraction than what we've had before. Thus, OOP allows you to
    describe the problem in terms of the problem, rather than in terms
    of the computer where the solution will run. There's still a
    connection back to the computer, though. Each object looks quite a
    bit like a little computer; it has a state, and it has operations
    that you can ask it to perform. However, this doesn't seem like
    such a bad analogy to objects in the real world; they all have
    characteristics and behaviors.
    -->

    <para>
      El método orientado a objetos va un paso más allá, proporcionando
      herramientas para que el programador represente los elementos en
      el espacio del problema. Esta representación es lo suficientemente
      general como para que el programador no esté limitado a un tipo
      particular de problema. Nos referimos a los elementos en el
      espacio del problema, y a sus representaciones en el espacio de la
      solución, como <quote>objetos</quote> (por supuesto, necesitará
      otros objetos que no tengan analogías en el espacio del problema).
      La idea es que permita al programa adaptarse al lenguaje del
      problema añadiendo nuevos tipos de objetos de modo que cuando lea
      el código que describe la solución, esté leyendo palabras que
      además expresan el problema. Es un lenguaje de abstracción más
      flexible y potente que los que haya usado antes. De esta manera,
      la POO permite describir el problema en términos del problema, en
      lugar de usar términos de la computadora en la que se ejecutará la
      solución. Sin embargo, todavía existe una conexión con la
      computadora. Cada objeto se parece un poco a una pequeña
      computadora; tiene un estado y operaciones que se le puede pedir
      que haga. Sin embargo, no parece una mala analogía a los objetos
      en el mundo real; todos ellos tienen características y comportamientos.
    </para>

    <!--
    Some language designers have decided that object-oriented
    programming by itself is not adequate to easily solve all
    programming problems, and advocate the combination of various
    approaches into multiparadigm programming languages.[4]See
    Multiparadigm Programming in Leda by Timothy Budd (Addison-Wesley
    1995).
    -->
    <para>
      Algunos diseñadores de lenguajes han decidido que la
      programación orientada a objetos en sí misma no es adecuada para
      resolver fácilmente todos los problemas de programación, y
      abogan por una combinación de varias aproximaciones en lenguajes
      de programación <emphasis>multiparadigma</emphasis>.
      <footnote>
	<para>
	  Ver <citetitle>Multiparadigm Programming in Leda</citetitle>
	  de <personname><firstname>Timothy</firstname>
	  <surname>Budd</surname></personname> (Addison-Wesley 1995).
	</para>
      </footnote>
    </para>
  
    <!--
    Alan Kay summarized five basic characteristics of Smalltalk, the
    first successful object-oriented language and one of the languages
    upon which C++ is based. These characteristics represent a pure
    approach to object-oriented programming:
    -->
    <para>
      <personname><firstname>Alan</firstname>
      <surname>Kay</surname></personname> resumió las cinco
      características básicas de Smalltalk, el primer lenguaje
      orientado a objetos con éxito y uno de los lenguajes en los que
      está basado C++. Esas características representan una
      aproximación a la programación orientada a objetos:
    </para>
    
    <!--
    1. Everything is an object. Think of an object as a fancy variable; it
    stores data, but you can "make requests" to that object, asking it
    to perform operations on itself. In theory, you can take any
    conceptual component in the problem you're trying to solve (dogs,
    buildings, services, etc.) and represent it as an object in your
    program.
    -->
    <orderedlist>
      <listitem>
	<para>
	  Todo es un objeto. Piense en un objeto como una variable
	  elaborada; almacena datos, pero puede <quote>hacer
	  peticiones</quote> a este objeto, solicitando que realice
	  operaciones en sí mismo. En teoría, puede coger cualquier
	  componente conceptual del problema que está intentando
	  resolver (perros, edificios, servicios, etc.) y
	  representarlos como un objeto en su programa.
	</para>
      </listitem>

      <!--
      2. A program is a bunch of objects telling each other what to do
      by sending messages. To make a request of an object, you "send a
      message" to that object. More concretely, you can think of a
      message as a request to call a function that belongs to a
      particular object.
      -->
     <listitem>
	<para>
	  Un programa es un grupo de objetos enviando mensajes a otros
	  para decirles qué hacer. Para hacer una petición a un
	  objeto, <quote>envía un mensaje</quote> a ese objeto. Más
	  concretamente, puede pensar en un mensaje como una petición
	  de invocación a una función que pertenece a un objeto
	  particular.
	</para>
      </listitem>

      <!--
      3. Each object has its own memory made up of other objects. Put
      another way, you create a new kind of object by making a package
      containing existing objects. Thus, you can build complexity in a
      program while hiding it behind the simplicity of objects.
      -->
     <listitem>
	<para>
	  Cada objeto tiene su propia memoria constituida por otros
	  objetos. Visto de otra manera, puede crear un nuevo tipo de
	  objeto haciendo un paquete que contenga objetos
	  existentes. Por consiguiente, puede hacer cosas complejas en
	  un programa ocultando la complejidad de los objetos.
	</para>
      </listitem>

      <!--
      4. Every object has a type. Using the parlance, each object is an
      instance of a class, in which "class" is synonymous with "type."
      The most important distinguishing characteristic of a class is
      "What messages can you send to it?"
      -->
      <listitem>
	<para>
	  Cada objeto tiene un tipo. Usando el argot, cada objeto es
	  una instancia de una clase, en el que <quote>clase</quote>
	  es sinónimo de <quote>tipo</quote>. La característica más
	  importante que lo distingue de una clase es <quote>¿Qué
	  mensajes puede enviarle?</quote>
	</para>
      </listitem>

      <!--
      5. All objects of a particular type can receive the same
      messages. This is actually a loaded statement, as you will see
      later. Because an object of type "circle" is also an object of
      type "shape," a circle is guaranteed to accept shape
      messages. This means you can write code that talks to shapes and
      automatically handles anything that fits the description of a
      shape. This substitutability is one of the most powerful concepts
      in OOP.
      -->
      <listitem>
	<para>
	  Todos los objetos de un tipo particular pueden recibir los
	  mismos mensajes. En realidad es una frase con doble sentido,
	  como verá más tarde. Como un objeto de tipo
	  <classname>círculo</classname> es también un objeto de tipo
	  <classname>figura</classname>, está garantizado que un círculo
	  aceptará los mensajes de figura. Esto significa que puede
	  escribir código que habla con objetos
	  <classname>figura</classname> y automáticamente funcionará con
	  cualquier otro objeto que coincida con la descripción de
	  <classname>figura</classname>. Esta
	  <emphasis>sustituibilidad</emphasis> es uno de los conceptos
	  más poderosos en la POO.
	</para>
      </listitem>
    </orderedlist>


  </sect1>

  <sect1>

    <!-- An object has an interface -->
      <title>Cada objeto tiene una interfaz</title>

    <!--
    Aristotle was probably the first to begin a careful study of the
    concept of type; he spoke of "the class of fishes and the class of
    birds."  The idea that all objects, while being unique, are also
    part of a class of objects that have characteristics and behaviors
    in common was used directly in the first object-oriented language,
    Simula-67, with its fundamental keyword class that introduces a
    new type into a program.
    -->
    
    <para>
      Aristóteles fue probablemente el primero en hacer un estudio
      minucioso del concepto de <emphasis>tipo</emphasis>; él habló de
      <quote>la clase de peces y la clase de pájaros</quote>. La idea
      de que todos los objetos, aún siendo únicos, también son parte
      de una clase de objetos que tienen características y
      comportamientos comunes se utilizó directamente en el primer
      lenguaje orientado a objetos, Simula-67, con su palabra
      reservada <kw>class</kw> que introduce un nuevo tipo en un
      programa.
    </para>


    <!-- 
    Simula, as its name implies, was created for developing simulations
    such as the classic "bank teller problem[5]." In this, you have
    a bunch of tellers, customers, accounts, transactions, and units
    of money - a lot of "objects". Objects that are identical except
    for their state during a program's execution are grouped
    together into "classes of objects" and that's where the keyword
    class came from. Creating abstract data types (classes) is a
    fundamental concept in object-oriented programming. Abstract
    data types work almost exactly like built-in types: You can
    create variables of a type (called objects or instances in
    object-oriented parlance) and manipulate those variables (called
    sending messages or requests; you send a message and the object
    figures out what to do with it). The members (elements) of each
    class share some commonality: every account has a balance, every
    teller can accept a deposit, etc. At the same time, each member
    has its own state, each account has a different balance, each
    teller has a name. Thus, the tellers, customers, accounts,
    transactions, etc., can each be represented with a unique entity
    in the computer program. This entity is the object, and each
    object belongs to a particular class that defines its
    characteristics and behaviors.
    -->

    <!--
    [5] You can find an interesting implementation of this problem in
    Volume 2 of this book, available at www.BruceEckel.com.
    -->

    <para>
      Simula, como su nombre indica, fue creado para desarrollar
      simulaciones como el clásico <quote>problema del cajero</quote>
      <footnote>
        <para>
          Puede encontrar una implementación interesante de este
          problema en el Volumen 2 de este libro, disponible en <ulink
          url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>
        </para>
      </footnote>.  Tiene un grupo de cajeros, clientes, cuentas,
      transacciones, y unidades de moneda - un montón de
      <quote>objetos</quote>. Los objetos idénticos exceptuando por su
      estado durante la ejecución del programa se agrupan juntos en
      <quote>clases de objetos</quote> y de ahí es de donde viene la
      palabra reservada <kw>class</kw>. Crear tipos de datos abstractos
      (clases) es un concepto fundamental en la programación orientada a
      objetos. Los tipos de datos abstractos trabajan casi exactamente
      como tipos predefinidos: puede crear variables de un tipo
      (llamadas <emphasis>objetos</emphasis> o
      <emphasis>instancias</emphasis> en el argot de la programación
      orientada a objetos) y manipular estas variables (llamado
      <emphasis>envío de mensajes</emphasis> o
      <emphasis>peticiones</emphasis>; envía un mensaje y el objeto
      decide qué hacer con él). Los miembros (elementos) de cada clase
      tienen algo en común: cada cuenta tiene un balance, cada
      cajero puede aceptar un depósito, etc. Al mismo tiempo, cada
      miembro tiene su propio estado, cada cuenta tiene un balance
      diferente, cada cajero tiene un nombre. De este modo, cada
      cajeros, clientes, cuentas, transacciones, etc., se puede
      representar con una única entidad en el programa de
      computador. Esta entidad es un objeto, y cada objeto pertenece a
      una clase particular que define sus características y
      comportamientos.
    </para>

<!-- revisando David Villa -->

    <!--
    So, although what we really do in object-oriented programming is
    create new data types, virtually all object-oriented programming
    languages use the "class" keyword. When you see the word "type"
    think "class" and vice versa[6].

    [6] Some people make a distinction, stating that type determines
    the interface while class is a particular implementation of that
    interface.  
    -->

    <para>
      Así, aunque lo que realmente hace un programa orientado a
      objetos es crear un nuevo tipo de datos, prácticamente todos los
      lenguajes de programación orientados a objetos usan la palabra
      reservada <kw>class</kw>. Cuando vea la palabra
      <quote>type</quote>, piense en <quote>class</quote> y viceversa
      <footnote>
        <para>
          Hay quien hace una distinción, afirmando que <kw>type</kw>
          determina la interfaz mientras <kw>class</kw> es una
          implementación particular de esta interfaz.
        </para>
      </footnote>.
    </para>

    <!-- 
    Since a class describes a set of objects that have identical
    characteristics (data elements) and behaviors (functionality), a
    class is really a data type because a floating point number, for
    example, also has a set of characteristics and behaviors. The
    difference is that a programmer defines a class to fit a problem
    rather than being forced to use an existing data type that was
    designed to represent a unit of storage in a machine. You extend the
    programming language by adding new data types specific to your
    needs. The programming system welcomes the new classes and gives
    them all the care and type-checking that it gives to built-in types.
    -->

    <para>
      Ya que una clase describe un conjunto de objetos que tienen
      características idénticas (elementos de datos) y comportamientos
      (funcionalidad), una clase es realmente un tipo de datos porque
      un número de punto flotante, por ejemplo, también tiene un
      conjunto de características y comportamientos. La diferencia
      está en que el programador define una clase para resolver un
      problema más que forzar el uso de un tipo de dato existente
      diseñado para representar una unidad de almacenamiento en una
      máquina. Amplía el lenguaje de programación añadiendo nuevos
      tipos de datos específicos según sus necesidades. El sistema de
      programación acoge las nuevas clases y les da toda la atención y
      comprobación de tipo que da a la contrucción de tipos.
    </para>

    <!-- 
    The object-oriented approach is not limited to building
    simulations. Whether or not you agree that any program is a
    simulation of the system you're designing, the use of OOP
    techniques can easily reduce a large set of problems to a simple
    solution.
    -->

    <para>
      El enfoque orientado a objetos no está limitado a la
      construcción de simulaciones. Esté o no de acuerdo con que
      cualquier problema es una simulación del sistema que está
      diseñando, el uso de técnicas POO puede reducir fácilmente un
      amplio conjunto de problemas a una simple solución.
    </para>

    <!-- 
    Once a class is established, you can make as many objects of that
    class as you like, and then manipulate those objects as if they are
    the elements that exist in the problem you are trying to
    solve. Indeed, one of the challenges of object-oriented programming
    is to create a one-to-one mapping between the elements in the
    problem space and objects in the solution space.
    -->

    <para>
      Una vez establecida una clase, puede hacer tantos objetos de esta
      clase como quiera, y manipularlos como si fueran elementos que
      existen en el problema que está intentando resolver. De hecho, uno
      de los desafíos de la programación orientada a objetos es crear
      una correspondencia unívoca entre los elementos en el espacio del
      problema y objetos en el espacio de la solución.
    </para>

    <!-- 
    But how do you get an object to do useful work for you? There must
    be a way to make a request of the object so that it will do
    something, such as complete a transaction, draw something on the
    screen or turn on a switch. And each object can satisfy only certain
    requests. The requests you can make of an object are defined by its
    interface, and the type is what determines the interface. A simple
    example might be a representation of a light bulb:

    -->

    <para>
      ¿Pero cómo se consigue que un objeto haga algo útil para usted?
      Debe haber una forma de hacer una petición al objeto para que
      haga algo, como completar una transacción, dibujar algo en la
      pantalla o activar un interruptor. Y cada objeto puede satisfacer
      sólo ciertas peticiones. Las peticiones que puede hacer de un
      objeto están definidas por su intefaz, y el tipo es lo que
      determina la intefaz. Un ejemplo simple puede ser una
      representación de una bombilla:
    </para>
    
    <mediaobject>
      <imageobject role="latex">
	<imagedata fileref="./images/V1_03.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html">
	<imagedata fileref="./images/V1_03.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>


<programlisting>
Luz luz1;
luz1.encender(); 
</programlisting>


    <!-- 
    The interface establishes what requests you can make for a
    particular object. However, there must be code somewhere to satisfy
    that request. This, along with the hidden data, comprises the
    implementation. From a procedural programming standpoint, it's not
    that complicated. A type has a function associated with each
    possible request, and when you make a particular request to an
    object, that function is called. This process is usually summarized
    by saying that you "send a message" (make a request) to an object,
    and the object figures out what to do with that message (it executes
    code).
    -->

    <para>
      La interfaz establece qué peticiones se pueden hacer a un objeto
      particular. Sin embargo, debe ser codificado en algún sitio para
      satisfacer esta petición. Ésta, junto con los datos ocultos,
      comprende la implementación. Desde el punto de vista de la
      programación procedural, no es complicado. Un tipo tiene una
      función asociada para cada posible petición, y cuando se hace una
      petición particular a un objeto, se llama a esta función. Este
      proceso normalmente se resume diciendo que ha <quote>enviado un
      mensaje</quote> (hecho una petición) a un objeto, y el objeto
      comprende qué hacer con este mensaje (ejecuta el código).
    </para>

    <!-- 
    Here, the name of the type/class is Light, the name of this
    particular Light object is lt, and the requests that you can make of
    a Light object are to turn it on, turn it off, make it brighter or
    make it dimmer. You create a Light object by declaring a name (lt)
    for that object. To send a message to the object, you state the name
    of the object and connect it to the message request with a period
    (dot). From the standpoint of the user of a pre-defined class,
    that's pretty much all there is to programming with objects.  
    -->

    <para>
      Aquí, el nombre del tipo/clase es <classname>Luz</classname>, el
      nombre de este objeto particular de <classname>Luz</classname> es
      <varname>luz1</varname>, y las peticiones que puede hacer al
      objeto <classname>Luz</classname> son encender, apagar,
      intensificar o atenuar. Usted crea un objeto
      <classname>Luz</classname> declarando un nombre
      (<varname>luz1</varname>) para este objeto. Para enviar un mensaje
      al objeto, escribe el nombre del objeto y lo conecta al mensaje de
      petición con un punto. Desde el punto de vista del usuario de una
      clase predefinida, eso es prácticamente todo lo relacionado con la
      programación con objetos.
    </para>

    <!-- 
    The diagram shown above follows the format of the Unified Modeling
    Language (UML). Each class is represented by a box, with the type
    name in the top portion of the box, any data members that you care
    to describe in the middle portion of the box, and the member
    functions (the functions that belong to this object, which receive
    any messages you send to that object) in the bottom portion of the
    box. Often, only the name of the class and the public member
    functions are shown in UML design diagrams, and so the middle
    portion is not shown. If you're interested only in the class name,
    then the bottom portion doesn't need to be shown, either.
    -->

    <para>
      El diagrama mostrado arriba sigue el formato del Lenguaje
      Unificado de Modelado (UML). Cada clase se representa con una
      caja, con el nombre del tipo en la parte de arriba, cualquier
      atributo que necesite describir en la parte central de la caja, y
      los métodos (las funciones que pertenecen a este objeto, que
      reciben cualquier mensaje que se envíe al objeto) en la parte
      inferior de la caja. A menudo, en los diagramas de diseño UML se
      muestra sólo el nombre de la clase y el nombre de los métodos
      públicos, y por eso la parte central no se muestra. Si sólo está
      interesado en el nombre de la clase, entonces tampoco es necesario
      mostrar la parte inferior.
    </para>

  </sect1>

  <sect1>

    <!-- The hidden implementation  -->
    <title>La implementación oculta</title>

    <!--
    It is helpful to break up the playing field into class creators
    (those who create new data types) and client programmers[7] (the
    class consumers who use the data types in their applications). The
    goal of the client programmer is to collect a toolbox full of
    classes to use for rapid application development. The goal of the
    class creator is to build a class that exposes only what's
    necessary to the client programmer and keeps everything else
    hidden. Why? Because if it's hidden, the client programmer can't
    use it, which means that the class creator can change the hidden
    portion at will without worrying about the impact to anyone
    else. The hidden portion usually represents the tender insides of
    an object that could easily be corrupted by a careless or
    uninformed client programmer, so hiding the implementation reduces
    program bugs. The concept of implementation hiding cannot be
    overemphasized.
    -->

   <para>
      Es útil distinguir entre los <emphasis>creadores de
      clases</emphasis> (aquellos que crean nuevos tipos de datos) y los
      <emphasis>programadores clientes</emphasis>
      <footnote>
	<para>
	  Estoy agradecido a mi amigo <personname>
	    <firstname>Scott</firstname> <surname>Meyers</surname>
	  </personname> por este término.
	</para>
      </footnote> (los consumidores de clases que usan los tipos de
      datos en sus aplicaciones). El objetivo del programador cliente es
      acumular una caja de herramientas llena de clases que usar para un
      desarrollo rápido de aplicaciones. El objetivo del creador de
      clases es construir una clase que exponga sólo lo necesario para
      el programador cliente y mantenga todo lo demás oculto. ¿Por qué?
      Porque si está oculto, el programador cliente no puede usarlo, lo
      cual significa que el creador de clases puede cambiar la parte
      oculta sin preocuparse de las consecuencias sobre lo demás. La
      parte oculta suele representar las interioridades delicadas de un
      objeto que podría fácilmente ser corrompida por un programador
      cliente descuidado o desinformado, así que ocultando la
      implementación se reducen los errores de programación. No se debe
      abusar del concepto de implementación oculta.
    </para>

    <!--
    In any relationship it's important to have boundaries that are
    respected by all parties involved. When you create a library, you
    establish a relationship with the client programmer, who is also a
    programmer, but one who is putting together an application by
    using your library, possibly to build a bigger library.
    -->

    <para>
      En cualquier relación es importante tener límites que sean
      respetados por todas las partes involucradas. Cuando se crea una
      librería, se establece una relación con el programador cliente,
      quien también es programador, porque puede estar utilizando la
      librería para crear a su vez una librería mayor.
    </para>


    <!--
    If all the members of a class are available to everyone, then the
    client programmer can do anything with that class and there's no
    way to enforce rules. Even though you might really prefer that the
    client programmer not directly manipulate some of the members of
    your class, without access control there's no way to prevent
    it. Everything's naked to the world.
    -->

    <para>
      Si todos los miembros de una clase están disponibles para
      cualquiera, entonces el programador cliente puede hacer
      cualquier cosa con la clase y no hay forma de imponer las
      reglas. Incluso si quisiera que el programador cliente no
      manipulase directamente algunos de los miembros de su clase, sin
      control de acceso no hay forma de impedirlo. Nadie está a salvo.
    </para>

   <!--
    So the first reason for access control is to keep client
    programmers'hands off portions they shouldn't touch - parts that
    are necessary for the internal machinations of the data type but
    not part of the interface that users need in order to solve their
    particular problems. This is actually a service to users because
    they can easily see what's important to them and what they can
    ignore.
    -->

    <para>
      Por eso la principal razón del control de acceso es impedir que
      el cliente toque las partes que no debería - partes que son
      necesarias para los mecanismos internos de los tipos de datos,
      pero no parte de la interfaz que los usuarios necesitan para
      resolver sus problemas particulares. Realmente esto es un
      servicio para los usuarios porque pueden ver fácilmente qué es
      importante para ellos y qué pueden ignorar.
    </para>

    <!--
    The second reason for access control is to allow the library
    designer to change the internal workings of the class without
    worrying about how it will affect the client programmer. For
    example, you might implement a particular class in a simple
    fashion to ease development, and then later discover that you need
    to rewrite it in order to make it run faster. If the interface and
    implementation are clearly separated and protected, you can
    accomplish this easily and require only a relink by the user.
    -->

    <para>
      La segunda razón para el control de acceso es permitir al
      diseñador de la librería cambiar la implementación interna de la
      clase sin preocuparse de cómo afectará a los programadores
      clientes. Por ejemplo, podría implementar una clase particular
      de una manera sencilla para un desarrollo fácil, y más tarde
      descubrir que necesita reescribirla para hacerla más rápida. Si
      la interfaz y la implementación están claramente separadas y
      protegidas, puede conseguirlo fácilmente y sólo requiere que el
      usuario vuelva a enlazar la aplicación.
    </para>

    <!--
    C++ uses three explicit keywords to set the boundaries in a class:
    public, private, and protected. Their use and meaning are quite
    straightforward. These access specifiers determine who can use the
    definitions that follow. public means the following definitions
    are available to everyone. The private keyword, on the other hand,
    means that no one can access those definitions except you, the
    creator of the type, inside member functions of that type. private
    is a brick wall between you and the client programmer. If someone
    tries to access a private member, they'll get a compile-time
    error. protected acts just like private, with the exception that
    an inheriting class has access to protected members, but not
    private members. Inheritance will be introduced shortly.
    -->

    <para>
      C++ utiliza tres palabras reservadas explícitas para poner límites
      en una clase: <kw>public</kw>, <kw>private</kw>, y
      <kw>protected</kw>. Su uso y significado son bastante
      sencillos. Estos <emphasis>especificadores de acceso</emphasis>
      determinan quién usa las definiciones que siguen. <kw>public</kw>
      significa que las definiciones posteriores están disponibles para
      cualquiera. La palabra reservada <kw>private</kw>, por otro lado,
      significa que nadie puede acceder a estas definiciones excepto el
      creador del tipo, es decir, los métodos internos de la
      clase. <kw>private</kw> es una pared entre el creador de la clase
      y el programador cliente. Si alguien intenta acceder a un miembro
      privado, obtendrá un error al compilar. <kw>protected</kw> actúa
      como <kw>private</kw>, con la excepción de que las clases
      derivadas tienen acceso a miembros protegidos, pero no a los
      privados. La herencia se explicará en breve.
    </para>

  </sect1>

  <sect1>

    <!-- Reusing the implementation -->
    <title>Reutilizar la implementación</title>

    <!--
    Once a class has been created and tested, it should (ideally)
    represent a useful unit of code. It turns out that this
    reusability is not nearly so easy to achieve as many would hope;
    it takes experience and insight to produce a good design. But once
    you have such a design, it begs to be reused. Code reuse is one of
    the greatest advantages that object-oriented programming languages
    provide.
    -->

    <para>
      Una vez que una clase ha sido creada y probada, debería
      representar (idealmente) una unidad útil de código. Sin embargo,
      esta reutilización no es tan fácil de conseguir como muchos
      esperarían; requiere experiencia y entendimiento el producir un
      buen diseño. Pero una vez que se tiene semejante diseño, éste pide
      ser reutilizado. El código reutilizado es una de las mejores
      ventajas de los lenguajes de programación orientada a objetos.
    </para>


    <!--
    The simplest way to reuse a class is to just use an object of that
    class directly, but you can also place an object of that class
    inside a new class. We call this "creating a member object". Your
    new class can be made up of any number and type of other objects,
    in any combination that you need to achieve the functionality
    desired in your new class. Because you are composing a new class
    from existing classes, this concept is called composition (or more
    generally, aggregation). Composition is often referred to as a
    "has-a" relationship, as in "a car has an engine".
    -->
    
    <para>
      La forma más fácil de reutilizar una clase es precisamente
      utilizar un objeto de esa clase directamente, pero también puede
      colocar un objeto de esta clase dentro de una clase nueva. Podemos
      llamarlo <quote>crear un objeto miembro</quote>. Su nueva
      clase puede estar compuesta de varios objetos de cualquier tipo,
      en alguna combinación que necesite para conseguir la
      funcionalidad deseada en su nueva clase. Ya que está componiendo
      una nueva clase desde clases existentes, este concepto se llama
      <emphasis>composición</emphasis> (o más generalmente,
      <emphasis>agregación</emphasis>). A menudo nos referimos a la
      composición como una relación <quote>tiene-un</quote>, como en
      <quote>un coche tiene-un motor</quote>.
    </para>


    <mediaobject>
      <imageobject role="latex">
	<imagedata fileref="./images/V1_04.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject lang="es">
	<imagedata fileref="./images/V1_04.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>



    <!--
    (The above UML diagram indicates composition with the filled
    diamond, which states there is one car. I will typically use a
    simpler form: just a line, without the diamond, to indicate an
    association.[8])

    [8] This is usually enough detail for most diagrams, and you don't
    need to get specific about whether you're using aggregation or
    composition.
    -->

    <para>
      (El diagrama UML anterior indica composición con el rombo relleno,
      lo cual implica que hay un coche. Típicamente usaré una forma más
      simple: sólo una línea, sin el rombo, para indicar una asociación.
      <footnote>
	<para>
	  Normalmente este es suficiente para la mayoría de los
	  diagramas y no necesita especificar sobre si está usando
	  agregación o composición.
	</para>
      </footnote>)
    </para>

    <!-- REVISION 1: OSCAR A. -->
    <!--
    Composition comes with a great deal of flexibility. The member
    objects of your new class are usually private, making them
    inaccessible to the client programmers who are using the
    class. This allows you to change those members without disturbing
    existing client code. You can also change the member objects at
    runtime, to dynamically change the behavior of your
    program. Inheritance, which is described next, does not have this
    flexibility since the compiler must place compile-time
    restrictions on classes created with inheritance.
    -->

    <para>
      La composición es un mecanismo muy flexible. Los objetos miembros
      de su nueva clase son habitualmente privados, haciéndolos
      inaccesibles para los programadores clientes que están usando la
      clase. Esto permite cambiar esos miembros sin perturbar al código
      cliente existente. También puede cambiar los miembros del objeto
      en tiempo de ejecución, para cambiar dinámicamente el
      comportamiento de su programa. La herencia, descrita más adelante,
      no tiene esta flexibilidad dado que el compilador debe imponer
      restricciones durante la compilación en clases creadas con herencia.
    </para>
    

    <!--
    Because inheritance is so important in object-oriented programming
    it is often highly emphasized, and the new programmer can get the
    idea that inheritance should be used everywhere. This can result
    in awkward and overly-complicated designs. Instead, you should
    first look to composition when creating new classes, since it is
    simpler and more flexible. If you take this approach, your designs
    will stay cleaner. Once you've had some experience, it will be
    reasonably obvious when you need inheritance.
    -->
    
    <para>
      Porque la herencia es tan importante en la programación orientada
      a objetos, se suele enfatizar mucho su uso, y el nuevo programador
      puede tener la idea de que la herencia debería ser usada en todas
      partes. Esto puede dar como resultado diseños torpes y demasiado
      complicados. En cambio, debería mirar primero la composición
      cuando cree nuevas clases, ya que es más simple y flexible. Si
      acepta esta propuesta, sus diseños serán más limpios. Una vez que
      tenga experiencia, los casos en los que necesite la herencia serán
      razonablemente evidentes.
    </para>
  </sect1>


  <sect1>
    <!-- Inheritance: reusing the interface -->
    <title>Herencia: reutilización de interfaces</title>
  
    <!--
    By itself, the idea of an object is a convenient tool. It allows
    you to package data and functionality together by concept, so you
    can represent an appropriate problem-space idea rather than being
    forced to use the idioms of the underlying machine. These concepts
    are expressed as fundamental units in the programming language by
    using the class keyword.
    -->

    <para>
      Por sí misma, la idea de un objeto es una herramienta
      conveniente. Permite empaquetar datos y funcionalidad junto al
      concepto, además puede representar una idea apropiada del espacio
      del problema más que estar forzado a usar el vocabulario de la
      máquina subyacente. Estos conceptos se expresan como unidades
      fundamentales en el lenguaje de programación mediante la palabra
      clave <kw>class</kw>.
    </para>

    <!-- 
    It seems a pity, however, to go to all the trouble to create
    a class and then be forced to create a brand new one that might
    have similar functionality. It's nicer if we can take the
    existing class, clone it, and then make additions and
    modifications to the clone. This is effectively what you get with
    inheritance, with the exception that if the original class (called
    the base or super or parent class) is changed, the modified
    "clone" (called the derived or inherited or sub or
    child class) also reflects those changes.  
    -->
    
    <para>
      Parece una pena, sin embargo, tomarse muchas molestias en crear
      una clase y ser forzado a crear un nuevo tipo que puede tener
      similar funcionalidad. Es más sencillo si se puede usar la clase
      existente, clonarla, y hacerle añadidos y modificaciones al
      clon. Esto es efectivamente lo que hace la
      <emphasis>herencia</emphasis>, con la excepción de que la clase
      original (llamada clase <classname>base</classname> o
      <classname>super</classname> o <classname>padre</classname>) se
      cambia, el <quote>clon</quote> modificado (llamado
      <emphasis>derivado</emphasis> o <emphasis>heredado</emphasis> o
      <emphasis>sub</emphasis> o clase <emphasis>hija</emphasis>)
      también refleja estos cambios.
   </para>



    <mediaobject>
      <imageobject role="latex">
	<imagedata fileref="./images/V1_05.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject lang="es">
	<imagedata fileref="./images/V1_05.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>


    <!--
    (The arrow in the above UML diagram points from the derived class
    to the base class. As you will see, there can be more than one
    derived class.)
    -->

    <para>
      (En el diagrama UML anterior, la flecha apunta desde la clase
      derivada hacia la clase base. Como se puede comprobar, puede haber
      más de una clase derivada.)
    </para>
    

    <!--
    A type does more than describe the constraints on a set of objects; it
    also has a relationship with other types. Two types can have
    characteristics and behaviors in common, but one type may contain more
    characteristics than another and may also handle more messages (or
    handle them differently). Inheritance expresses this similarity
    between types using the concept of base types and derived types. A
    base type contains all of the characteristics and behaviors that are
    shared among the types derived from it. You create a base type to
    represent the core of your ideas about some objects in your
    system. From the base type, you derive other types to express the
    different ways that this core can be realized.
    -->

    <para>
      Un tipo hace más que describir las restricciones de un conjunto de
      objetos; también tiene una relación con otros tipos. Dos tipos
      pueden tener características y comportamientos en común, pero un
      tipo puede contener más características que otro y también puede
      manipular más mensajes (o hacerlo de forma diferente). La herencia
      expresa esto de forma similar entre tipos usando el concepto de
      tipos base y tipos derivados. Un tipo base contiene todas las
      características y comportamientos compartidos entre los tipos
      derivados de él. Cree un tipo base para representar lo esencial de
      sus ideas sobre algunos objetos en su sistema. Del tipo base,
      derive otros tipos para expresar caminos diferentes que este
      núcleo puede realizar.
    </para>


    <!--
    For example, a trash-recycling machine sorts pieces of trash. The base
    type is "trash," and each piece of trash has a weight, a value, and so
    on, and can be shredded, melted, or decomposed. From this, more
    specific types of trash are derived that may have additional
    characteristics (a bottle has a color) or behaviors (an aluminum can
    may be crushed, a steel can is magnetic). In addition, some behaviors
    may be different (the value of paper depends on its type and
    condition). Using inheritance, you can build a type hierarchy that
    expresses the problem you're trying to solve in terms of its types.
    -->

    <para>
      Por ejemplo, una máquina de reciclado de basura clasifica piezas
      de basura. El tipo base es <quote>basura</quote> y otra pieza de
      basura tiene un peso, un valor, y también, puede ser triturada,
      fundida o descompuesta. A partir de ahí, se obtienen más tipos
      específicos de basura que pueden tener características adicionales
      (una botella tiene un color) o comportamientos (el aluminio puede
      ser aplastado, el acero puede ser magnético). Además, algunos
      comportamientos pueden ser diferentes (el valor del papel depende
      del tipo y condición). Usando la herencia, se puede construir un
      tipo de jerarquía que exprese el problema que se intenta resolver
      en términos de sus tipos.
    </para>


    <!--
    A second example is the classic "shape" example, perhaps used in a
    computer-aided design system or game simulation. The base type is
    "shape," and each shape has a size, a color, a position, and so
    on. Each shape can be drawn, erased, moved, colored, etc. From this,
    specific types of shapes are derived (inherited): circle, square,
    triangle, and so on, each of which may have additional characteristics
    and behaviors. Certain shapes can be flipped, for example. Some
    behaviors may be different, such as when you want to calculate the
    area of a shape. The type hierarchy embodies both the similarities and
    differences between the shapes.
    -->

    <para>
      Un segundo ejemplo es el clásico ejemplo
      <classname>figura</classname>, tal vez usado en un sistema de
      diseño asistido por computador o juegos de simulación. El tipo
      base es <classname>figura</classname>, y cada figura tiene un
      tamaño, un color, una posición y así sucesivamente. Cada figura
      puede ser dibujada, borrada, movida, coloreada, etc. A partir de
      ahí, los tipos específicos de figuras derivan (heredan): círculo,
      cuadrado, triángulo, y así sucesivamente, cada uno de ellos puede
      tener características y comportamientos adicionales. Ciertas
      figuras pueden ser, por ejemplo, volteadas. Algunos
      comportamientos pueden ser diferentes, como cuando se quiere
      calcular el área de una figura. La jerarquía tipo expresa las
      similitudes y las diferencias entre las figuras.
   </para>



    <mediaobject>
      <imageobject role="latex">
	<imagedata fileref="./images/V1_06.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject lang="es">
	<imagedata fileref="./images/V1_06.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>

    <!--
    Casting the solution in the same terms as the problem is tremendously
    beneficial because you don't need a lot of intermediate models to get
    from a description of the problem to a description of the
    solution. With objects, the type hierarchy is the primary model, so
    you go directly from the description of the system in the real world
    to the description of the system in code. Indeed, one of the
    difficulties people have with object-oriented design is that it's too
    simple to get from the beginning to the end. A mind trained to look
    for complex solutions is often stumped by this simplicity at first.
    -->

   <para>
      Modelar la solución en los mismos términos que el problema es
      tremendamente beneficioso porque no se necesitan muchos modelos
      intermedios para transformar una descripción del problema en una
      descripción de la solución. Con objetos, la jerarquía tipo es el
      principal modelo, va directamente desde la descripción del sistema
      en el mundo real a la descripción del sistema en
      código. Efectivamente, una de las dificultades que la gente tiene
      con el diseño orientado a objetos es que es demasiado fácil ir
      desde el principio hasta el final. Una mente entrenada para buscar
      soluciones complejas a menudo se confunde al principio a causa de
      la simplicidad.
   </para>

    <!--
    When you inherit from an existing type, you create a new type. This
    new type contains not only all the members of the existing type
    (although the private ones are hidden away and inaccessible), but more
    importantly it duplicates the interface of the base class. That is,
    all the messages you can send to objects of the base class you can
    also send to objects of the derived class. Since we know the type of a
    class by the messages we can send to it, this means that the derived
    class is the same type as the base class. In the previous example, "a
    circle is a shape." This type equivalence via inheritance is one of
    the fundamental gateways in understanding the meaning of
    object-oriented programming.
    -->

    <para>
      Cuando hereda desde un tipo existente, se crea un tipo nuevo. Este
      nuevo tipo contiene no sólo todos los miembros del tipo existente
      (aunque los datos privados <emphasis>private</emphasis> están
      ocultos e inaccesibles), pero más importante duplica la interfaz
      de la clase base. Es decir, todos los mensajes que se pueden
      enviar a los objetos de la clase base pueden enviarse también a
      los objetos de la clase derivada. Dado que se conoce el tipo de
      una clase por los mensajes que se le pueden enviar, esto significa
      que la clase derivada <emphasis>es del mismo tipo que la clase
      base</emphasis>. En el ejemplo anterior, <quote>un círculo es una
      figura</quote>. Este tipo equivante vía herencia es uno de las
      principales puertas para entender la programación orientada a
      objetos.
    </para>

    <!--
    Since both the base class and derived class have the same interface,
    there must be some implementation to go along with that
    interface. That is, there must be some code to execute when an object
    receives a particular message. If you simply inherit a class and don't
    do anything else, the methods from the base-class interface come right
    along into the derived class. That means objects of the derived class
    have not only the same type, they also have the same behavior, which
    isn't particularly interesting.
    -->

    <para>
      Dado que ambas clases, base y derivada, tienen la misma interfaz,
      debe haber alguna implementación que esté de acuerdo con esa
      interfaz. Es decir, debe haber código para ejecutar cuando un
      objeto recibe un mensaje particular. Si simplemente hereda de una
      clase y no hace nada más, los métodos de la interfaz de la clase
      base están disponibles en la clase derivada. Esto significa que
      los objetos de la clase derivada no sólo tienen el mismo tipo,
      también tienen el mismo comportamiento, lo cual no es
      particularmente interesante.
    </para>

    <!--
    You have two ways to differentiate your new derived class from the
    original base class. The first is quite straightforward: You simply
    add brand new functions to the derived class. These new functions are
    not part of the base class interface. This means that the base class
    simply didn't do as much as you wanted it to, so you added more
    functions. This simple and primitive use for inheritance is, at times,
    the perfect solution to your problem. However, you should look closely
    for the possibility that your base class might also need these
    additional functions. This process of discovery and iteration of your
    design happens regularly in object-oriented programming.
   -->

    <para>
      Hay dos caminos para diferenciar la nueva clase derivada de la
      clase base original. El primero es bastante sencillo: simplemente
      hay que añadir nuevas funciones a la clase derivada. Estas nuevas
      funciones no son parte de la interfaz de la clase base. Esto
      significa que la clase base simplemente no hace tanto como
      necesitamos, por lo que se añaden más funciones. Este uso simple y
      primitivo de la herencia es, a veces, la solución perfecta a su
      problema. Sin embargo, quizá debería pensar en la posibilidad de
      que su clase base puede necesitar también funciones
      adicionales. Este proceso de descubrimiento e iteración de su
      diseño ocurre regularmente en la programación orientada a objetos.
    </para>


    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_07.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_07.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>

 
    <!--
    Although inheritance may sometimes imply that you are going to add new
    functions to the interface, that's not necessarily true. The second
    and more important way to differentiate your new class is to change
    the behavior of an existing base-class function. This is referred to
    as overriding that function.
    -->

    <para>
      Aunque la herencia algunas veces supone que se van a añadir
      nuevas funciones a la interfaz, esto no es necesariamente
      verdad. El segundo y más importante camino para diferenciar su
      nueva clase es <emphasis>cambiar</emphasis> el comportamiento de
      una función de una clase base existente. Es referenciado como
      una función <emphasis>primordial</emphasis>.
    </para>


    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_08.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_08.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>


    <!--
    To override a function, you simply create a new definition for the
    function in the derived class. You're saying, "I'm using the same
    interface function here, but I want it to do something different for
    my new type."
    -->

    <para>
      Para anular una función, simplemente hay que crear una nueva
      definición para una función en la clase derivada. Está diciendo,
      <quote>Estoy usando la misma función de interfaz aquí,
      pero quiero hacer algo diferente para mi nuevo tipo</quote>.
    </para>

    <sect2>
      <!-- Is-a vs. is-like-a relationships -->
      <title> Relaciones es-un vs. es-como-un </title>

   <!--
    There's a certain debate that can occur about inheritance: Should
    inheritance override only base-class functions (and not add new member
    functions that aren't in the base class)? This would mean that the
    derived type is exactly the same type as the base class since it has
    exactly the same interface. As a result, you can exactly substitute an
    object of the derived class for an object of the base class. This can
    be thought of as pure substitution, and it's often referred to as the
    substitution principle. In a sense, this is the ideal way to treat
    inheritance. We often refer to the relationship between the base class
    and derived classes in this case as an is-a relationship, because you
    can say "a circle is a shape." A test for inheritance is to determine
    whether you can state the is-a relationship about the classes and have
    it make sense.
    -->

    <para>
      Hay un debate seguro que puede ocurrir sobre la herencia: ¿debería
      la herencia anular sólo funciones de la clase base (y no añadir
      nuevas funciones miembros que no estén en la clase base)? Esto
      puede significar que el tipo derivado es
      <emphasis>exactamente</emphasis> el mismo tipo que la clase base
      desde que tiene exactamente la misma interfaz. Como resultado, se
      puede sustituir un objeto de una clase derivada por un objeto de
      la clase base. Se puede pensar como una <emphasis>sustitución
      pura</emphasis>, y suele ser referida como la
      <emphasis>sustitución general</emphasis>. En cierto modo, este es
      el camino ideal para tratar la herencia. A menudo nos referimos a
      las relaciones entre la clase base y clases derivadas en este caso
      como una relación es-un, porque se dice <quote>un círculo es una
      figura</quote>. Una prueba para la herencia es determinar si se
      puede declarar la relación es-un sobre las clases y si tiene
      sentido.
    </para>

   <!--
    There are times when you must add new interface elements to a
    derived type, thus extending the interface and creating a new
    type. The new type can still be substituted for the base type, but
    the substitution isn't perfect because your new functions are not
    accessible from the base type. This can be described as an
    is-like-a relationship; the new type has the interface of the old
    type but it also contains other functions, so you can't really say
    it's exactly the same. For example, consider an air
    conditioner. Suppose your house is wired with all the controls for
    cooling; that is, it has an interface that allows you to control
    cooling. Imagine that the air conditioner breaks down and you
    replace it with a heat pump, which can both heat and cool. The
    heat pump is-like-an air conditioner, but it can do more. Because
    the control system of your house is designed only to control
    cooling, it is restricted to communication with the cooling part
    of the new object. The interface of the new object has been
    extended, and the existing system doesn't know about anything
    except the original interface.
    -->

    <para>
      Hay ocasiones en las que se deben añadir nuevos elementos a la
      interfaz de un tipo derivado, de esta manera se amplía la interfaz
      y se crea un tipo nuevo. El nuevo tipo todavía puede ser
      sustituido por el tipo base, pero la sustitución no es perfecta
      porque sus nuevas funciones no son accesibles desde el tipo
      base. Esto puede ser descrito como una relación
      <emphasis>es-como-un</emphasis>; el nuevo tipo tiene la interfaz
      del viejo tipo, pero también contiene otras funciones, por lo que
      se puede decir que es exactamente el mismo. Por ejemplo, considere
      un aire acondicionado. Suponga que su casa está conectada con
      todos los controles para refrigerar; es decir, tiene una interfaz
      que le permite controlar la temperatura. Imagine que el aire
      acondicionado se avería y lo reemplaza por una bomba de calor, la
      cual puede dar calor y frío. La bomba de calor
      <emphasis>es-como-un</emphasis> aire acondicionado, pero puede
      hacer más cosas. Porque el sistema de control de su casa está
      diseñado sólo para controlar el frío, está rentringida para
      comunicarse con la parte fría del nuevo objeto. La interfaz del
      nuevo objeto se ha extendido, y el sistema existente no conoce
      ninguna excepción de la interfaz original.
    </para>



    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_09.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_09.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>


   <!--
    Of course, once you see this design it becomes clear that the base
    class "cooling system" is not general enough, and should be renamed to
    "temperature control system" so that it can also include heating at
    which point the substitution principle will work. However, the diagram
    above is an example of what can happen in design and in the real
    world.
    -->

    <para>
      Por supuesto, una vez que ve este diseño se ve claro que la clase
      base <quote>sistema de frío</quote> no es bastante general, y
      debería ser renombrada a <quote>sistema de control de
      temperatura</quote> además también puede incluir calor - en este
      punto se aplica el principio de sustitución. Sin embargo, el
      diagrama de arriba es un ejemplo de qué puede ocurrir en el diseño
      y en el mundo real.
    </para>

   <!--
    When you see the substitution principle it's easy to feel like this
    approach (pure substitution) is the only way to do things, and in fact
    it is nice if your design works out that way. But you'll find that
    there are times when it's equally clear that you must add new
    functions to the interface of a derived class. With inspection both
    cases should be reasonably obvious.
   -->

    <para>
      Cuando ve el principio de sustitución es fácil entender cómo este
      acercamiento (sustitución pura) es el único camino para hacer
      cosas, y de hecho es bueno para sus diseños si entrena este
      camino. Pero verá que hay ocasiones en que está igualmente claro
      que se deben añadir nuevas funciones a la interfaz de la clase
      derivada. Con experiencia, ambos casos puede ser razonablemente
      obvios.
    </para>
  </sect2>

  </sect1>

  <sect1>

    <!-- Interchangeable objects with polymorphism -->
    <title>Objetos intercambiables gracias al polimorfismo</title>

    <!--
    When dealing with type hierarchies, you often want to treat an object
    not as the specific type that it is but instead as its base type. This
    allows you to write code that doesn't depend on specific types. In the
    shape example, functions manipulate generic shapes without respect to
    whether they're circles, squares, triangles, and so on. All shapes can
    be drawn, erased, and moved, so these functions simply send a message
    to a shape object; they don't worry about how the object copes with
    the message.
    -->

    <para>
      Cuando se manejan tipos jerárquicos, se suele tratar un objeto no
      como el tipo específico que es si no como su tipo base. Esto le
      permite escribir código que no depende de los tipos
      específicos. En el ejemplo de la figura, las funciones manipulan
      figuras genéricas sin respetar si son círculos, cuadrados,
      triángulos, y así sucesivamente. Todas las figuras pueden ser
      dibujadas, borradas y movidas, pero estas funciones simplemente
      envían un mensaje a un objeto figura; no se preocupa sobre cómo el
      objeto se las arregla con este mensaje.
    </para>

   <!--
    Such code is unaffected by the addition of new types, and adding new
    types is the most common way to extend an object-oriented program to
    handle new situations. For example, you can derive a new subtype of
    shape called pentagon without modifying the functions that deal only
    with generic shapes. This ability to extend a program easily by
    deriving new subtypes is important because it greatly improves designs
    while reducing the cost of software maintenance.
    -->

    <para>
      Semejante código no está afectado por la adición de nuevos
      tipos, y añadir nuevos tipos es el camino más común para
      extender un programa orientado a objetos para tratar nuevas
      situaciones. Por ejemplo, puede derivar un nuevo subtipo de
      figura llamado pentágono sin modificar las funciones que tratan
      sólo con figuras genéricas. Esta habilidad para extender un
      programa fácilmente derivando nuevos subtipos es importante
      porque mejora enormemente los diseños mientras se reduce el
      coste del mantenimiento del software.
    </para>

   <!--
    There's a problem, however, with attempting to treat derived-type
    objects as their generic base types (circles as shapes, bicycles as
    vehicles, cormorants as birds, etc.). If a function is going to tell
    a generic shape to draw itself, or a generic vehicle to steer, or a
    generic bird to move, the compiler cannot know at compile-time
    precisely what piece of code will be executed. That's the whole
    point when the message is sent, the programmer doesn't want to know
    what piece of code will be executed; the draw function can be
    applied equally to a circle, a square, or a triangle, and the object
    will execute the proper code depending on its specific type. If you
    don't have to know what piece of code will be executed, then when
    you add a new subtype, the code it executes can be different without
    requiring changes to the function call. Therefore, the compiler
    cannot know precisely what piece of code is executed, so what does
    it do? For example, in the following diagram the BirdController
    object just works with generic Bird objects, and does not know what
    exact type they are. This is convenient from BirdController's
    perspective, because it doesn't have to write special code to
    determine the exact type of Bird it's working with, or that Bird's
    behavior. So how does it happen that, when move( ) is called while
    ignoring the specific type of Bird, the right behavior will occur (a
    Goose runs, flies, or swims, and a Penguin runs or swims)?
    -->

    <para>
      Hay un problema, no obstante, con intentar tratar un tipo
      derivado como sus tipos base genéricos (círculos como figuras,
      bicicletas como vehículos, cormorantes como pájaros, etc). Si
      una función va a indicar a una figura genérica que se dibuje así
      misma, o a un vehículo genérico que se conduzca, o a un pájaro
      genérico que se mueva, el compilador no sabe en el momento de la
      compilación con precisión qué pieza del código será
      ejecutada. Este es el punto clave - cuando el mensaje se envía, el
      programador no <emphasis>quiere</emphasis> saber qué pieza del
      código será ejecutada; la función dibujar puede ser aplicada
      igualmente a un círculo, a un cuadrado, o a un triángulo, y el
      objeto ejecutará el código correcto dependiendo de tipo
      específico. Si no sabe qué pieza del código se ejecuta, ¿qué
      hace? Por ejemplo, en el siguiente diagrama el objeto
      <classname>BirdController</classname> trabaja con los objetos
      genéricos<classname>Bird</classname> , y no se sabe de qué tipo
      son exactamente. Esto es conveniente desde la perspectiva
      <classname>BirdController</classname>, porque no hay que
      escribir código especial para determinar el tipo exacto de
      <classname>Bird</classname> que está trabajando, o el
      comportamiento del pájaro. Entonces, ¿cómo ocurre esto cuando se
      llama a <function>move()</function> mientras se ignora el tipo
      específico de <classname>Bird</classname>, puede ocurrir el
      comportamiento correcto (un <classname>Ganso</classname> corre,
      vuela, o nada, y un <classname>Pingüino</classname> corre o
      nada)?
    </para>


    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_10.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_10.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>



   <!--
    The answer is the primary twist in object-oriented programming:
    The compiler cannot make a function call in the traditional
    sense. The function call generated by a non-OOP compiler causes
    what is called early binding, a term you may not have heard before
    because you've never thought about it any other way. It means the
    compiler generates a call to a specific function name, and the
    linker resolves this call to the absolute address of the code to
    be executed. In OOP, the program cannot determine the address of
    the code until runtime, so some other scheme is necessary when a
    message is sent to a generic object.
    -->

    <para>
      La respuesta es el primer giro en la programación orientada a
      objetos: El compilador no hace una llamada a la función en el
      sentido tradicional. La llamada a la función generada por un
      compilador no de POO provoca que se llame pronto vinculante, un
      término que no quizá no haya oído antes porque nunca ha pensado
      en ningún otro camino. Significa que el compilador genera una
      llamada al nombre de la función específica, y el enlazador
      resuelve esta llamada en la dirección completa del código
      ejecutado. En OOP, el programa no determina la dirección del
      código hasta el tiempo de ejecución, si alguna otra combinación
      es necesaria cuando el mensaje se envía a un objeto genérico.
    </para>

    <!--
    To solve the problem, object-oriented languages use the concept of
    late binding. When you send a message to an object, the code being
    called isn't determined until runtime. The compiler does ensure that
    the function exists and performs type checking on the arguments and
    return value (a language in which this isn't true is called weakly
    typed), but it doesn't know the exact code to execute.
    -->

    <para>
      Para resolver el problema, los lenguajes orientados a objetos
      usan el concepto de <emphasis>vinculación
      tardía</emphasis>. Cuando envía un mensaje a un objeto, el
      código llamado no está determinado hasta el tiempo de
      ejecución. El compilador se asegura de que la función existe e
      interpreta el tipo viendo los argumentos y devolviendo un valor
      (un lenguaje en el cual esto no es cierto llamado
      <emphasis>débilmente escrito</emphasis>), pero no sabe el código
      exacto a ejecutar.
    </para>


    <!--
    To perform late binding, the C++ compiler inserts a special bit of
    code in lieu of the absolute call. This code calculates the address of
    the function body, using information stored in the object (this
    process is covered in great detail in Chapter 15). Thus, each object
    can behave differently according to the contents of that special bit
    of code. When you send a message to an object, the object actually
    does figure out what to do with that message.
    -->

    <para>
      Para interpretar la vinculación tardía, el compilador de C++
      inserta un trozo especial de código en lugar de la llamada
      absoluta. Este código calcula la dirección del cuerpo de la
      función, usando información almacenada en el objeto (este proceso
      está incluido al detalle en el Capítulo 15). De esta manera,
      cualquier objeto puede comportarse de forma diferente de acuerdo a
      los contenidos de este trozo especial de código. Cuando envía un
      mensaje a un objeto, el objeto realmente comprende qué hacer con
      este mensaje.
    </para>


    <!--
    You state that you want a function to have the flexibility of
    late-binding properties using the keyword virtual. You don't need
    to understand the mechanics of virtual to use it, but without it
    you can't do object-oriented programming in C++. In C++, you must
    remember to add the virtual keyword because, by default, member
    functions are not dynamically bound. Virtual functions allow you
    to express the differences in behavior of classes in the same
    family. Those differences are what cause polymorphic behavior.
    -->

    <para>
      Afirma que quiere una función para tener la flexibilidad de las
      propiedades de la vinculación tardía usando la palabra reservada
      <kw>virtual</kw>. No necesita entender el mecanismo de
      <kw>virtual</kw> para usarla, pero sin ella no puede hacer
      programación orientada a objetos en C++. En C++, debe recordar
      añadir la palabra reservada <kw>virtual</kw> porque, por defecto,
      las funciones miembro <emphasis>no</emphasis> son vinculadas
      dinámicamente. Las funciones virtuales le permiten expresar las
      diferencias en comportamiento de clases en la misma familia. Estas
      diferencias son las que causan comportamientos polimórficos.
    </para>


    <!--
    Consider the shape example. The family of classes (all based on
    the same uniform interface) was diagrammed earlier in the
    chapter. To demonstrate polymorphism, we want to write a single
    piece of code that ignores the specific details of type and talks
    only to the base class. That code is decoupled from type-specific
    information, and thus is simpler to write and easier to
    understand. And, if a new type a Hexagon, for example is added
    through inheritance, the code you write will work just as well for
    the new type of Shape as it did on the existing types. Thus, the
    program is extensible.
    -->

    <para>
      Considere el ejemplo de la figura. El diagrama de la familia de
      clases (todas basadas en la misma interfaz uniforme) apareció
      antes en este capítulo. Para demostrar el polimorfismo, se
      quiere escribir una pieza única de código que ignore los
      detalles específicos de tipo y hable sólo con la clase
      base. Este código está <emphasis>desacoplado</emphasis> de la
      información del tipo específico, y de esta manera es más simple
      de escribir y más fácil de entender. Y, si tiene un nuevo tipo -
      un <classname>Hexágono</classname>, por ejemplo - se añade a
      través de la herencia, el código que escribe funcionará tan bien
      para el nuevo tipo de <classname>Figura</classname> como para
      los tipos anteriores. De esta manera, el programa es extensible.
    </para>


    <!--
    If you write a function in C++ (as you will soon learn how to do):
    -->

    <para>
      Si escribe una función C++ (podrá aprender dentro de poco cómo hacerlo):
    </para>


<programlisting>
void doStuff(Shape&amp; s) {
    s.erase();
    // ...
    s.draw();
} 
</programlisting>


    <!--
    This function speaks to any Shape, so it is independent of the
    specific type of object that it's drawing and erasing (the '&amp;' means
    "Take the address of the object that's passed to doStuff( )," but it's
    not important that you understand the details of that right now). If
    in some other part of the program we use the doStuff( ) function:
    -->

    <para>
      Esta función habla de alguna <classname>Figura</classname>, esto
      es tan independiente del tipo específico del objeto que es
      dibujado y borrado (el '<emphasis>&amp;</emphasis>' significa
      <quote>Coge la dirección del objeto que se pasa por
      <function>doStuff()</function></quote>, pero no es importante
      que entienda los detalles ahora). Si en alguna otra parte del
      programa usamos la función <function>doStuff()</function>:
    </para>


<programlisting>
Circle c;
Triangle t;
Line l;
doStuff(c);
doStuff(t);
doStuff(l); 
</programlisting>


   <!--
    The calls to doStuff( ) automatically work right, regardless of the
    exact type of the object.
    -->

    <para>
      Las llamadas a <function>doStuff()</function> trabajan
      automáticamente bien, a pesar del tipo exacto del objeto.
    </para>


    <!--
    This is actually a pretty amazing trick. Consider the line:
    -->

    <para>
      En efecto esto es un bonito y asombroso truco. Considere la
      línea:
    </para>


<programlisting>
doStuff(c);
</programlisting>


    <!--
    What's happening here is that a Circle is being passed into a function
    that's expecting a Shape. Since a Circle is a Shape it can be treated
    as one by doStuff( ). That is, any message that doStuff( ) can send to
    a Shape, a Circle can accept. So it is a completely safe and logical
    thing to do.
    -->

    <para>
      Lo que está ocurriendo aquí es que
      <classname>Círculo</classname> está pasando a una función que
      está esperando una <classname>Figura</classname>. Desde que un
      <classname>Círculo</classname> es una
      <classname>Figura</classname> puede ser tratado como uno por
      <function>doStuff()</function>. Es decir, ningún mensaje que
      <function>doStuff()</function> pueda enviar a una
      <classname>Figura</classname>, un <classname>Círculo</classname>
      puede aceptarlo. Esto es una cosa prudente y lógica que hacer.
    </para>
   

    <!-- 
    We call this process of treating a derived type as though it were its
    base type upcasting. The name cast is used in the sense of casting
    into a mold and the up comes from the way the inheritance diagram
    is typically arranged, with the base type at the top and the
    derived classes fanning out downward. Thus, casting to a base type
    is moving up the inheritance diagram: "upcasting".
    -->

    <para>
      A este proceso de tratar un tipo derivado como si fuera su tipo
      base se le llama conversión de tipos
      <emphasis>upcasting</emphasis> (<emphasis>moldeado hacia
      arriba</emphasis>). El nombre <emphasis>cast</emphasis> (moldear)
      se usa en el sentido de moldear (convertir)un molde y es
      <emphasis>hacia arriba</emphasis> como se ordenada típicamente la
      herencia los diagramas, con el tipo base en la parte superior y
      las clases derivadas colgando hacia abajo. De esta manera, moldear
      un tipo base es moverse hacia arriba por el diagrama de herencias.
    </para>


    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_11.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_11.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>




    <!-- 
    An object-oriented program contains some upcasting somewhere, because
    that's how you decouple yourself from knowing about the exact type
    you're working with. Look at the code in doStuff( ):
    -->

    <para>
      Un programa orientado a objetos contiene algún moldeado hacia
      arriba en algún sitio, porque así es como se desvincula de saber
      sobre el tipo exacto con el que está trabajando. Mire el código en
      <function>doStuff()</function>:
    </para>


<programlisting>
s.erase();
// ...
s.draw();
</programlisting>



    <!-- 
    Notice that it doesn't say "If you're a Circle, do this, if you're a
    Square, do that, etc." If you write that kind of code, which checks
    for all the possible types that a Shape can actually be, it's messy
    and you need to change it every time you add a new kind of
    Shape. Here, you just say "You're a shape, I know you can erase( ) and
    draw( ) yourself, do it, and take care of the details correctly."
    -->

    <para>
      Observe que no dice <quote>Si es un
      <classname>Círculo</classname>, haz esto, si es un
      <classname>Cuadrado</classname>, haz esto, etc.</quote>. Si
      escribe este tipo de código, el cual comprueba todos los
      posibles tipos que una <classname>Figura</classname> puede tener
      realmente, es desordenado y necesita cambiarlo cada vez que
      añade un nuevo tipo de <classname>Figura</classname>. Aquí, debe
      decir <quote>Es una figura, sé que se puede
      <function>erase()</function> y <function>draw()</function>, esto
      es, y ten cuidado de los detalles</quote>.
    </para>


    <!-- 
    What's impressive about the code in doStuff( ) is that, somehow, the
    right thing happens. Calling draw( ) for Circle causes different code
    to be executed than when calling draw( ) for a Square or a Line, but
    when the draw( ) message is sent to an anonymous Shape, the correct
    behavior occurs based on the actual type of the Shape. This is amazing
    because, as mentioned earlier, when the C++ compiler is compiling the
    code for doStuff( ), it cannot know exactly what types it is dealing
    with. So ordinarily, you'd expect it to end up calling the version of
    erase( ) and draw( ) for Shape, and not for the specific Circle,
    Square, or Line. And yet the right thing happens because of
    polymorphism. The compiler and runtime system handle the details; all
    you need to know is that it happens and more importantly how to design
    with it. If a member function is virtual, then when you send a message
    to an object, the object will do the right thing, even when upcasting
    is involved.
    -->

    <para>
      Lo impresionante del código en <function>doStuff()</function> es
      que, de alguna manera, ocurre lo correcto. Llamar a
      <function>draw()</function> para un <classname>Círculo</classname>
      provoca diferente código para ser ejecutado que cuando llama a
      <function>draw()</function> para un
      <classname>Cuadrado</classname> o una
      <classname>Línea</classname>, pero cuando el mensaje
      <function>draw()</function> es enviado a un
      <classname>Círculo</classname> anónimo, la conducta correcta
      sucede basado en el tipo real de
      <classname>Figura</classname>. Esto es asombroso porque, como se
      mencionó anteriormente, cuando el compilador C++ está compilando
      el código para <function>doStuff()</function>, no se sabe
      exactamente qué tipos está manipulando. Así normalmente, se espera
      que acabe invocando a la versión de <function>erase()</function> y
      <function>draw()</function> para <classname>Figura</classname>, y
      no para el <classname>Círculo</classname>,
      <classname>Cuadrado</classname>, o <classname>Línea</classname>
      específico. Y todavía ocurre la forma correcta a causa del
      polimorfismo. El compilador y el sistema de tiempo real manipulan
      los detalles; todo lo que necesita conocer es que esto ocurre y lo
      que es más importante cómo diseñar con él. Si una función miembro
      es <kw>virtual</kw>, entonces cuando mande el mensaje a un objeto,
      el objeto hará lo correcto, incluso cuando sea involucrado el
      moldeado hacia arriba.
    </para>
  </sect1>
  
  <sect1>

    <!-- Creating and destroying objects -->
    <title>Creación y destrucción de objetos</title>

    <!--
    Technically, the domain of OOP is abstract data typing, inheritance,
    and polymorphism, but other issues can be at least as important. This
    section gives an overview of these issues.
    -->

    <para>
      En teoría, el dominio de OOP es tipos de datos abstractos,
      herencia, y polimorfismo, pero otros usos pueden ser menos
      importantes. Esta sección da una visión general de estos usos.
    </para>


    <!--
    Especially important is the way objects are created and
    destroyed. Where is the data for an object and how is the lifetime
    of that object controlled? Different programming languages use
    different philosophies here. C++ takes the approach that control
    of efficiency is the most important issue, so it gives the
    programmer a choice. For maximum runtime speed, the storage and
    lifetime can be determined while the program is being written, by
    placing the objects on the stack or in static storage. The stack
    is an area in memory that is used directly by the microprocessor
    to store data during program execution. Variables on the stack are
    sometimes called automatic or scoped variables. The static storage
    area is simply a fixed patch of memory that is allocated before
    the program begins to run. Using the stack or static storage area
    places a priority on the speed of storage allocation and release,
    which can be valuable in some situations. However, you sacrifice
    flexibility because you must know the exact quantity, lifetime,
    and type of objects while you're writing the program. If you are
    trying to solve a more general problem, such as computer-aided
    design, warehouse management, or air-traffic control, this is too
    restrictive.
    -->

    <para>
      Especialmente importante es la forma en que se crean y se
      destruyen los objetos. ¿Dónde está el dato para un objeto y cómo
      es la vida de este objeto controlado? Diferentes lenguajes de
      programación usan distintas filosofías al respecto. C++ adopta el
      enfoque de que el control de eficiencia es el uso más importante,
      pero esto cede al programador una elección. Para una velocidad
      máxima de ejecución, el almacenamiento y la vida se determinan
      mientras el programa se escribe, colocando los objetos en la pila
      o en almacenamiento estático. La pila es un área de memoria usada
      directamente por el microprocesador para almacenar datos durante
      la ejecución del programa. A veces las variables en la pila se
      llaman variables <emphasis>automatic</emphasis> o
      <emphasis>scoped</emphasis>. El área de almacenamiento estático es
      simplemente un parche fijo de memoria localizable destinado antes
      de que el programa empiece a ejecutarse. Usar la pila o el área de
      almacenamiento estático pone una prioridad en la rapidez de
      asignación y liberación de almacenamiento, el cual puede ser
      valioso en algunas situaciones. Sin embargo, se sacrifica
      flexibilidad porque debe conocerse la cantidad exacta, vida, y
      tipo de objetos <emphasis>mientras</emphasis> escribe el
      programa. Si está intentando resolver un problema más general,
      como un diseño asistido por computadora, gestión de almacén, o
      control de tráfico aéreo, esto es también restrictivo.
    </para>
    

    <!--
    The second approach is to create objects dynamically in a pool of
    memory called the heap. In this approach you don't know until runtime
    how many objects you need, what their lifetime is, or what their exact
    type is. Those decisions are made at the spur of the moment while the
    program is running. If you need a new object, you simply make it on
    the heap when you need it, using the new keyword. When you're finished
    with the storage, you must release it using the delete keyword.
    -->

    <para>
      El segundo enfoque es crear objetos dinámicamente en un espacio
      de memoria llamado <emphasis>heap</emphasis>. En esta propuesta no
      se sabe hasta el momento de ejecución cuántos objetos son
      necesarios, qué tiempo de vida tiene, o el tipo exacto que
      es. Estas decisiones se toman de improviso mientras el programa
      está corriendo. Si se necesita un nuevo objeto, simplemente hágalo
      en el montículo cuando lo necesite, usando la palabra reservada
      <kw>new</kw>. Cuando haya acabado con el almacenamiento, debe
      liberarlo usando la palabra reservada <kw>delete</kw>.
    </para>


    <!--
    Because the storage is managed dynamically at runtime, the amount of
    time required to allocate storage on the heap is significantly longer
    than the time to create storage on the stack. (Creating storage on the
    stack is often a single microprocessor instruction to move the stack
    pointer down, and another to move it back up.) The dynamic approach
    makes the generally logical assumption that objects tend to be
    complicated, so the extra overhead of finding storage and releasing
    that storage will not have an important impact on the creation of an
    object. In addition, the greater flexibility is essential to solve
    general programming problems.
    -->

    <para>
      Porque el almacenamiento se administra dinámicamente en tiempo de
      ejecución, la cantidad de tiempo requerido para destinar el
      almacenamiento en el montículo es considerablemente más largo que
      el tiempo para crear almacenamiento en la pila. (Crear
      almacenamiento en la pila es a menudo una única instrucción del
      microprocesador para mover el puntero de la pila hacia abajo, y
      otro para moverlo de nuevo hacia arriba). La propuesta dinámica
      hace generalmente la asunción lógica de que los objetos tienden a
      ser complicados, por eso la sobrecargar extra de encontrar
      almacenamiento y liberarlo, éste no tendrá un impacto importante
      en la creación de un objeto. Admeás, la mayor flexibilidad es
      esencial para resolver problemas generales de programación.
    </para>


    <!--
    There's another issue, however, and that's the lifetime of an
    object. If you create an object on the stack or in static storage,
    the compiler determines how long the object lasts and can
    automatically destroy it. However, if you create it on the heap,
    the compiler has no knowledge of its lifetime. In C++, the
    programmer must determine programmatically when to destroy the
    object, and then perform the destruction using the delete
    keyword. As an alternative, the environment can provide a feature
    called a garbage collector that automatically discovers when an
    object is no longer in use and destroys it. Of course, writing
    programs using a garbage collector is much more convenient, but it
    requires that all applications must be able to tolerate the
    existence of the garbage collector and the overhead for garbage
    collection. This does not meet the design requirements of the C++
    language and so it was not included, although third-party garbage
    collectors exist for C++.
    -->

    <para>
      Hay otra cuestión, sin embargo, y es el tiempo de vida de un
      objeto. Si crea un objeto en la pila o en el almacenamiento
      estático, el compilador determina cuánto tiempo dura el objeto y
      puede destruirlo automáticamente. No obstante, si lo crea en el
      montículo, el compilador no tiene conocimiento de su tiempo de
      vida. En C++, el programador debe determinar programáticamente
      cuándo destruir el objeto, y entonces llevar a cabo la destrucción
      usando la palabra reservada <kw>delete</kw>. Como alternativa, el
      entorno puede proveer una característica llamada <emphasis>garbage
      collector</emphasis> que automáticamente descubre cuándo un objeto
      ya no se usa y lo destruye. Naturalmente, escribir programas
      usando un recolector de basura es mucho más conveniente, pero
      requiere que todas las aplicaciones sean capaces de tolerar la
      existencia del recolector de basura y de la sobrecarga para el
      recolector de basura. Este no conoce los requerimientos del diseño
      del lenguaje C++ por lo que no se incluyen, aunque existen para
      C++ terceros recolectores de basura.
    </para>
  </sect1>


  <sect1>

    <!-- Exception handling: dealing with errors -->
    <title>Gestión de excepciones: tratamiento de errores</title>


    <!--
    Ever since the beginning of programming languages, error handling has
    been one of the most difficult issues. Because it's so hard to design
    a good error-handling scheme, many languages simply ignore the issue,
    passing the problem on to library designers who come up with halfway
    measures that can work in many situations but can easily be
    circumvented, generally by just ignoring them. A major problem with
    most error-handling schemes is that they rely on programmer vigilance
    in following an agreed-upon convention that is not enforced by the
    language. If programmers are not vigilant, which often occurs when
    they are in a hurry, these schemes can easily be forgotten.
    -->

    <para>
      Desde los inicios de los lenguajes de programación, la gestión de
      errores ha sido uno de los asuntos más difíciles. Es tan
      complicado diseñar un buen esquema de gestión de errores, que
      muchos lenguajes simplemente lo ignoran, delegando el problema en
      los diseñadores de la librería quienes lo resuelven a medias de
      forma que puede funcionar en muchas situaciones, pero se pueden
      eludir, normalmente ignorándolos. El problema más importante de la
      mayoría de los esquemas de gestión de errores es que dependen de
      que el programador se preocupe en seguir un convenio que no está
      forzado por el lenguaje. Si los programadores no se preocupan,
      cosa que ocurre cuando se tiene prisa, estos esquemas se olvidan
      fácilmente.
    </para>


   <!--
    Exception handling wires error handling directly into the
    programming language and sometimes even the operating system. An
    exception is an object that is "thrown" from the site of the error
    and can be "caught" by an appropriate exception handler designed
    to handle that particular type of error. It's as if exception
    handling is a different, parallel path of execution that can be
    taken when things go wrong. And because it uses a separate
    execution path, it doesn't need to interfere with your
    normally-executing code. This makes that code simpler to write
    since you aren't constantly forced to check for errors. In
    addition, a thrown exception is unlike an error value that's
    returned from a function or a flag that's set by a function in
    
order to indicate an error condition these can be ignored. An
    exception cannot be ignored so it's guaranteed to be dealt with at
    some point. Finally, exceptions provide a way to recover reliably
    from a bad situation. Instead of just exiting the program, you are
    often able to set things right and restore the execution of a
    program, which produces much more robust systems.
    -->

    <para>
      <emphasis>El manejo de excepciones</emphasis> conecta la gestión
      de errores directamente en el lenguaje de programación y a veces
      incluso en el sistema operativo. Una excepción es un objeto que se
      <quote>lanza</quote> desde el lugar del error y puede ser
      <quote>capturado</quote> por un manejador de excepción apropiado
      diseñado para manipular este tipo particular de error. Es como si
      el manejo de errores fuera una ruta de ejecución diferente y
      paralela que se puede tomar cuando las cosas van mal. Y como usa
      un camino separado de ejecución, no necesita interferir con el
      código ejecutado normalmente. Eso hace que el código sea más
      simple de escribir ya que no se fuerza al programador a comprobar
      los errores constantemente. Además, una excepción no es lo mismo
      que un valor de error devuelto por una función o una bandera
      marcada para indicar una condición de error, que se puede
      ignorar. Una excepción no se puede ignorar, de modo que está
      garantizado que habrá que tratarla en algún momento. Finalmente,
      las excepciones proporcionan una forma para recuperar una
      situación consistente. En lugar de salir simplemente del programa,
      a menudo es posible arreglar las cosas y restaurar la ejecución,
      lo que produce sistemas más robustos.
    </para>


   <!--
    It's worth noting that exception handling isn't an object-oriented
    feature, although in object oriented languages the exception is
    normally represented with an object. Exception handling existed before
    object-oriented languages.
    -->

    <para>
      Merece la pena tener en cuenta que el manejo de excepciones no es
      una característica orientada a objetos, aunque en lenguajes
      orientados a objetos las excepciones normalmente se representan
      con objetos. El manejo de excepciones existía antes que los
      lenguajes orientados a objetos.
    </para>


   <!--
    Exception handling is only lightly introduced and used in this Volume;
    Volume 2 (available from www.BruceEckel.com) has thorough coverage of
    exception handling.
    -->

    <para>
      En este Volumen se usa y explica el manejo de excepciones sólo por
      encima; el Volúmen 2 (disponible en <ulink
      url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>) cubre
      con más detalle el manje de excepciones.
    </para>
      
  </sect1>

  <sect1>

   <!-- Analysis and design -->
    <title>Análisis y diseño</title>


   <!--  
    The object-oriented paradigm is a new and different way of thinking
    about programming and many folks have trouble at first knowing how to
    approach an OOP project. Once you know that everything is supposed to
    be an object, and as you learn to think more in an object-oriented
    style, you can begin to create "good" designs that take advantage of
    all the benefits that OOP has to offer.
    -->

    <para>
      El paradigma orientado a objetos es una nueva forma de pensar
      sobre programación y mucha gente tiene problemas la primera vez
      que escucha cómo abordar un proyecto POO. Una vez que se sabe que
      se supone que todo es un objeto, y como aprender a pensar al
      estilo orientado a objetos, puede empezar a crear
      <quote>buenos</quote> diseños que aprovechen las ventajas de todos
      los beneficios que ofrece la POO.
    </para>
 

   <!--    
    A method (often called a methodology) is a set of processes and
    heuristics used to break down the complexity of a programming
    problem. Many OOP methods have been formulated since the dawn of
    object-oriented programming. This section will give you a feel for
    what you're trying to accomplish when using a method.

    -->

    <para>
      Un <emphasis>método</emphasis> (llamado a menudo
      <emphasis>metodología</emphasis>) es un conjunto de procesos y
      heurísticas usado para tratar la complejidad de un problema de
      programación. Desde el comienzo de la programación orientada a
      objetos se han formulado muchos métodos. Esta sección le dará una
      idea de cuál es el objetivo que se intenta consegui cuando se usa
      un método.
    </para>


   <!--

    Especially in OOP, methodology is a field of many experiments, so it
    is important to understand what problem the method is trying to
    solve before you consider adopting one. This is particularly true
    with C++, in which the programming language is intended to reduce
    the complexity (compared to C) involved in expressing a
    program. This may in fact alleviate the need for ever-more-complex
    methodologies. Instead, simpler ones may suffice in C++ for a much
    larger class of problems than you could handle using simple
    methodologies with procedural languages.
    -->

    <para>
      Especialmente en POO, la metodología es un campo de muchos
      experimentos, así que antes de elegir un método, es importante que
      comprenda cuál es el problema que resuelve. Eso es particularmente
      cierto con C++, en el que el lenguaje de programación pretende
      reducir la complejidad (comparado con C) que implica expresar un
      programa. De hecho puede aliviar la necesidad de metodologías aún
      más complejas. En cambio, otras más simples podrían ser
      suficientes en C++ para muchos tipos de problemas grandes que
      podría manejar usando metodologías simples con lenguajes
      procedurales.
    </para>


   <!--    
    It's also important to realize that the term "methodology" is often
    too grand and promises too much. Whatever you do now when you design
    and write a program is a method. It may be your own method, and you
    may not be conscious of doing it, but it is a process you go through
    as you create. If it is an effective process, it may need only a small
    tune-up to work with C++. If you are not satisfied with your
    productivity and the way your programs turn out, you may want to
    consider adopting a formal method, or choosing pieces from among the
    many formal methods.
    -->

    <para>
      También es importante darse de cuenta de que el término
      <quote>metodología</quote> a menudo es demasiado grande y
      prometedor. A partir de ahora, cuando diseñe y escriba un programa
      FIXME[es un método]. Puede ser su propio método, y puede no ser
      consciente, pero es un proceso por el que pasa cuando lo crea. Si
      es un proceso efectivo, puede que sólo necesite un pequeño ajuste
      para que funcione con C++. Si no está satisfecho con su
      productividad y con el camino que sus programas han tomado, puede
      considerar adoptar un método formal, o elegir trozos de entre
      muchos métodos formales.
    </para>


   <!--   
    While you're going through the development process, the most important
    issue is this: Don't get lost. It's easy to do. Most of the analysis
    and design methods are intended to solve the largest of
    problems. Remember that most projects don't fit into that category, so
    you can usually have successful analysis and design with a relatively
    small subset of what a method recommends[9]. But some sort of process,
    no matter how limited, will generally get you on your way in a much
    better fashion than simply beginning to code.

    [9] An excellent example of this is UML Distilled, by Martin
    Fowler (Addison-Wesley 2000), which reduces the
    sometimes-overwhelming UML process to a manageable subset.
    -->

    <para>
      Mientras pasa por el proceso de desarrollo, el uso más importante
      es éste: No perderse. Esto es fácil. La mayoría de los análisis y
      métodos de diseño pretenden resolver los problemas más
      grandes. Recuerde que la mayoría de los proyectos no encajan en
      esta categoría, normalmente puede tener un análisis y diseño
      exitoso con un subconjunto relativamente pequeño de lo que
      recomienda el método <footnote>
	<para>
	  Un ejemplo excelente es FIXME[título de libro]<emphasis>UML
	  Distilled</emphasis>, de
	  <personname><firstname>Martin</firstname>
	  <surname>Fowler</surname></personname> (Addison-Wesley 2000),
	  que reduce el a menudo el insoportable proceso UML a un
	  subconjunto manejable.
	</para>
      </footnote> Pero muchos tipos de procesos, sin importar lo
      limitados que sean, generalmente le ofrecerán un camino mucho
      mejor que simplemente empezar a codificar.
    </para>


   <!--    
    It's also easy to get stuck, to fall into "analysis paralysis," where
    you feel like you can't move forward because you haven't nailed down
    every little detail at the current stage. Remember, no matter how much
    analysis you do, there are some things about a system that won't
    reveal themselves until design time, and more things that won't reveal
    themselves until you're coding, or not even until a program is up and
    running. Because of this, it's crucial to move fairly quickly through
    analysis and design, and to implement a test of the proposed system.
    -->

    <para>
      También en fácil quedarse estancado, caer en <emphasis>análisis
      parálisis</emphasis>, donde sentirá que no puede avanzar porque en
      la plataforma que está usando no está especificado cada pequeño
      detalle. Recuerde, no importa cuánto análisis haga, hay algunas
      cosas sobre un sistema que no se revelan hasta el momento del
      diseño, y más cosas que no se revelarán hasta que esté
      codificando, o incluso hasta que el programa esté funcionando. Por
      eso, es crucial moverse bastante rápido durante del análisis y
      diseño, e implementar un test del sistema propuesto.
    </para>


   <!--
    
    This point is worth emphasizing. Because of the history we've had
    with procedural languages, it is commendable that a team will want
    to proceed carefully and understand every minute detail before
    moving to design and implementation. Certainly, when creating a
    DBMS, it pays to understand a customer's needs thoroughly. But a
    DBMS is in a class of problems that is very well-posed and
    well-understood; in many such programs, the database structure is
    the problem to be tackled. The class of programming problem
    discussed in this chapter is of the "wild-card" (my term) variety,
    in which the solution isn't simply re-forming a well-known solution,
    but instead involves one or more "wild-card factors" elements for
    which there is no well-understood previous solution, and for which
    research is necessary[10]. Attempting to thoroughly analyze a
    wild-card problem before moving into design and implementation
    results in analysis paralysis because you don't have enough
    information to solve this kind of problem during the analysis
    phase. Solving such a problem requires iteration through the whole
    cycle, and that requires risk-taking behavior (which makes sense,
    because you're trying to do something new and the potential rewards
    are higher). It may seem like the risk is compounded by "rushing"
    into a preliminary implementation, but it can instead reduce the
    risk in a wild-card project because you're finding out early whether
    a particular approach to the problem is viable. Product development
    is risk management.

    [10] My rule of thumb for estimating such projects: If there's
    more than one wild card, don't even try to plan how long it's
    going to take or how much it will cost until you've created a
    working prototype. There are too many degrees of freedom.

    -->

    <para>
      Este punto merece la pena enfatizarlo. Debido a nuestra
      experiencia con los lenguajes procedurales, es encomiable que un
      equipo quiera proceder con cuidado y entender cada pequeño detalle
      antes de pasar al diseño y a la implementación. Desde luego,
      cuando crea una SGBD (Sistema Gestor de Bases de Datos), conviene
      entender la necesidad de un cliente a fondo. Pero un SGBD está en
      una clase de problemas que es muy concreto y bien entendido; en
      muchos programas semejantes, la estructura de la base de datos
      <emphasis>es</emphasis> el problema que debe afrontarse. El tipo
      de problema de programación tratado en este capítulo es de la
      variedad de <quote>comodín</quote>] (en mis palbras), en el que la
      solución no es simplemente adaptar una solución bien conocida,
      pero en cambio involucra uno o más <quote>factores
      comodín</quote>] -elementos para los que no hay solución previa
      bien entendida,y para los que es necesario investigar.
      <footnote>
	<para>
	  Mi regla general para el cálculo de semejantes proyectos: Si
	  hay más de un comodín, no intente planear cuánto tiempo le
	  llevará o cuánto costará hasta que haya creado un prototipo
	  funcional. También hay muchos grados de libertad.
	</para>
      </footnote> Intentar analizar minuciosamente un problema comodín
      antes de pasar al diseño y la implementación provica un análisis
      parálisis porque usted no tiene suficiente información para
      resolver este tipo de problema durante la fase de
      análisis. Resolver estos problemas requiere interación a través
      del ciclo completo, y eso requiere comportamientos arriesgados (lo
      cual tiene sentido, porque está intentando hacer algo nuevo y los
      beneficios potenciales son mayores). Puede parecer que el riesgo
      está compuesto por <quote>prisas</quote> en una implementación
      preliminar, pero en cambio puede reducir el riesgo en un proyecto
      comodín porque está descubriendo pronto si es viable un enfoque
      particular para el problema. El desarrollo del producto es gestión
      de riesgo.
    </para>


   <!--
    It's often proposed that you "build one to throw away". With OOP, you
    may still throw part of it away, but because code is encapsulated into
    classes, during the first iteration you will inevitably produce some
    useful class designs and develop some worthwhile ideas about the
    system design that do not need to be thrown away. Thus, the first
    rapid pass at a problem not only produces critical information for the
    next analysis, design, and implementation iteration, it also creates a
    code foundation for that iteration.
    -->

    <para>
      A menudo se proponer que <quote>construya uno
      desechable</quote>. Con la POO, todavía debe andar
      <emphasis>parte</emphasis> de este camino, pero debido a que el
      código está encapsulado en clases, durante la primera iteración
      inevitablemente producirá algunos diseños de clases útiles y
      desarrollar algunas ideas válidas sobre el diseño del sistema que
      no necesita ser [FIXME: dado enseguida]. De esta manera, la
      primera pasada rápida al problema no produce sólo información
      crítica para la siguiente iteración de análisis, diseño, e
      implementación, además crea el código base para esa iteración.
    </para>


    <!--
    That said, if you're looking at a methodology that contains tremendous
    detail and suggests many steps and documents, it's still difficult to
    know when to stop. Keep in mind what you're trying to discover:
    -->

    <para>
      Es decir, si está buscando una metodología que contenga detalles
      tremendos y sugiera muchos pasos y documentos, es aún más difícil
      saber cuándo parar. Tenga en presente lo que está intentando
      encontrar:
    </para>


    <!--
    1. What are the objects? (How do you partition your project into its
    component parts?)
    2. What are their interfaces? (What messages do you
    need to be able to send to each object?)
    -->

    <orderedlist>
      <listitem>
	<para>
	 ¿Cuáles son los objetos? (¿Cómo divide su proyecto en sus
	 partes componentes?)
	</para>
      </listitem>
 
      <listitem>
	<para>
	 ¿Cuáles son sus interfaces? (¿Qué mensajes necesita enviar a
	 otros objetos?)
	</para>
      </listitem>
    </orderedlist>

    <!--
    If you come up with nothing more than the objects and their
    interfaces, then you can write a program. For various reasons you
    might need more descriptions and documents than this, but you can't
    get away with any less.
    -->

    <para>
      Si sólo cuenta con los objetos y sus interfaces, entonces puede
      escribir un programa. Por varias razones podría necesitar más
      descripciones y documentos, pero no puede hacerlo con menos.
    </para>


    <!--
    The process can be undertaken in five phases, and a phase 0 that is
    just the initial commitment to using some kind of structure.
    -->

    <para>
      El proceso se puede realizar en cinco fases, y una fase 0 que es
      simplemente el compromiso inicial de usar algún tipos de
      estructura.
    </para>


    <sect2>

      <!-- Phase 0: Make a plan -->
      <title> Fase 0: Hacer un plan </title>

      <!-- 
      You must first decide what steps you're going to have in your
      process. It sounds simple (in fact, all of this sounds simple) and yet
      people often don't make this decision before they start coding. If
      your plan is "let's jump in and start coding", fine. (Sometimes that's
      appropriate when you have a well-understood problem.) At least agree
      that this is the plan.
      -->

      <para>
	Primero debe decidir qué pasos va a dar en su proceso. Parece
	fácil (de hecho, todo esto parece fácil) y sin embargo la gente
	a menudo no toma esta decisión antes de ponerse a programar. Si
	su plan es <quote>ponerse directamente a programar</quote>, de
	acuerdo. (A veces es adecuado cuando es un problema bien
	conocido). Al menos estará de acuerdo en que eso es el plan.
      </para>


      <!-- 
      You might also decide at this phase that some additional process
      structure is necessary, but not the whole nine yards. Understandably
      enough, some programmers like to work in "vacation mode" in which no
      structure is imposed on the process of developing their work; "It will
      be done when it's done." This can be appealing for awhile, but I've
      found that having a few milestones along the way helps to focus and
      galvanize your efforts around those milestones instead of being stuck
      with the single goal of "finish the project". In addition, it divides
      the project into more bite-sized pieces and makes it seem less
      threatening (plus the milestones offer more opportunities for
      celebration).
      -->

      <para>
	También debe decidir en esta fase que es necesario alguna
	estructura de proceso adicional, pero no las nueve yardas
	completas. Bastante comprensible, algunos programadores
	prefieren trabajar en <quote>modo vacaciones</quote> en cuyo
	caso no se impone ninguna estructura en el proceso de desarrollo
	de su trabajo. <quote>Se hará cuando se haga</quote>. Eso puede
	ser atractivo durante un rato, pero se ha descubierto que tener
	unos pocos hitos a lo largo del camino ayuda a enfocar e
	impulsar sus esfuerzos alrededor de esos hitos en lugar de
	empezar a atascarse con el único objetivo de <quote>finalizar el
	proyecto</quote>. Además, divide el proyecto en más piezas más
	pequeñas y hace que dé menos miedo (y además los hitos ofrecen
	más oportunidades para celebraciones).
      </para>


      <!-- 
      When I began to study story structure (so that I will someday write a
      novel) I was initially resistant to the idea of structure, feeling
      that when I wrote I simply let it flow onto the page. But I later
      realized that when I write about computers the structure is clear
      enough so that I don't think much about it. But I still structure my
      work, albeit only semi-consciously in my head. So even if you think
      that your plan is to just start coding, you still somehow go through
      the subsequent phases while asking and answering certain questions.
      -->

      <para>
	Cuando empecé a estudiar la estructura de la historia(por eso
	algún día escribiré una novela)inicialmente me resistía a la
	idea de una estructura, sentía que cuando escribía simplemente
	permitía que fluyera en la página. Pero más tarde me di cuenta
	de que cuando escribo sobre computadoras la estructura es
	bastante limpia, pero no pienso mucho sobre ello. Pero aún así
	estructuro mi trabajo, aunque sólo semi-inconscientemente en mi
	cabeza. Si aún piensa que su plan es sólo ponerse a codificar,
	de algún modo, usted pasará por las posteriores fases
	mientras pregunta y responde ciertas cuestiones.
      </para>

      <sect3>
	<!-- The mission statement -->
	<title>Declaración de objetivos</title>

	<!-- 
	Any system you build, no matter how complicated, has a fundamental
	purpose, the business that it's in, the basic need that it
	satisfies. If you can look past the user interface, the hardware or
	system-specific details, the coding algorithms and the efficiency
	problems, you will eventually find the core of its being, simple and
	straightforward. Like the so-called high concept from a Hollywood
	movie, you can describe it in one or two sentences. This pure
	description is the starting point.
	-->

	<para>
	  Cualquier sistema construido, no importa cuan complicado,
	  tiene un propósito fundamental, el negocio que hay en él, la
	  necesidad básica que satisface. Si puede ver [FIXME: pass] la
	  interfaz de usuario, el hardware o los detalles específicos
	  del sistema, los algoritmos de codificación y la problemas de
	  eficiencia, finalmente encontrará el núcleo de su existencia,
	  simple y sencillo. Como el así llamado FIXME: <emphasis>sentido
	  elevado </emphasis> de una película de Hollywood, puede
	  describirlo en una o dos frases. Esta descripción pura es el
	  punto de partida.
	</para>


	<!-- 
	The high concept is quite important because it sets the tone for your
	project; it's a mission statement. You won't necessarily get it right
	the first time (you may be in a later phase of the project before it
	becomes completely clear), but keep trying until it feels right. For
	example, in an air-traffic control system you may start out with a
	high concept focused on the system that you're building: "The tower
	program keeps track of the aircraft". But consider what happens when
	you shrink the system to a very small airfield; perhaps there's only a
	human controller or none at all. A more useful model won't concern the
	solution you're creating as much as it describes the problem:
	"Aircraft arrive, unload, service and reload, and depart".
	-->

	<para>
	  El concepto elevado es bastante importante porque le da el
	  tono a su proyecto; es una declaración de principios. No tiene
	  porque no necesariamente lo conseguirá la primera vez (podría
	  estar en una fase posterior del proyecto antes de tenerlo
	  completamente claro), pero siga intentándolo hasta que lo
	  consiga. Por ejemplo, en un sistema de control de tráfico
	  aéreo puede empezar con un concepto elevado centrado en el
	  sistema que está construyendo: "El programa de la torre sigue
	  la pista a los aviones". Pero considere qué ocurre cuando
	  adapta el sistema para un pequeño aeropuerto; quizá sólo haya
	  un controlador humano o ninguno. Un modelo más útil no se
	  preocupará de la solución que está creando tanto como la
	  descripción del problema: "Llega un avión, descarga, se revisa
	  y recarga, y se marcha".
	</para>
      </sect3>
    </sect2>

    <sect2>
      <!-- Phase 1: What are we making? -->
      <title> Fase 1: ¿Qué estamos haciendo? </title>      

      <!--
      In the previous generation of program design (called procedural
      design), this is called "creating the requirements analysis and system
      specification". These, of course, were places to get lost;
      intimidatingly-named documents that could become big projects in their
      own right. Their intention was good, however. The requirements
      analysis says "Make a list of the guidelines we will use to know when
      the job is done and the customer is satisfied". The system
      specification says "Here's a description of what the program will do
      (not how) to satisfy the requirements". The requirements analysis is
      really a contract between you and the customer (even if the customer
      works within your company or is some other object or system). The
      system specification is a top-level exploration into the problem and
      in some sense a discovery of whether it can be done and how long it
      will take. Since both of these will require consensus among people
      (and because they will usually change over time), I think it's best to
      keep them as bare as possible ideally, to lists and basic diagrams to
      save time. You might have other constraints that require you to expand
      them into bigger documents, but by keeping the initial document small
      and concise, it can be created in a few sessions of group
      brainstorming with a leader who dynamically creates the
      description. This not only solicits input from everyone, it also
      fosters initial buy-in and agreement by everyone on the team. Perhaps
      most importantly, it can kick off a project with a lot of enthusiasm.
      -->

      <para>
	En la generación previa de diseño de programas (llamado
	<emphasis>diseño procedural</emphasis>), llamado <quote>crear el
	<emphasis>análisis de requisitos</emphasis> y
	<emphasis>especificación del sistema</emphasis></quote>". Estos,
	por supuesto, se colocaron para perderse; documentos con nombres
	intimidantes que podrían llegar a ser grandes proyectos. Sin
	embargo, su intención fue buena. El análisis de requerimientos
	dice: <quote>Haga una lista de las directrices que usará para
	saber cuándo ha hecho su trabajo y el cliente está
	satisfecho</quote>. La especificación del sistema dice:
	<quote>Hay una descripción de <emphasis>lo que</emphasis> hará
	el programa (no <emphasis>cómo</emphasis>) por satisfacer los
	requisitos</quote>. El análisis de requisitos es realmente un
	contrato entre usted y el cliente (incluso si el cliente trabaja
	dentro de su compañía o es algún otro objeto o sistema). Las
	especificaciones del sistema son una exploración de alto nivel
	del problema y en algún sentido un descubrimiento de si se puede
	hacer y cuánto se tardará. Dado que ambos requerirán consenso
	entre la gente (y porque suelen cambiar todo el tiempo), creo
	que es mejor mantenerlos todo lo escueto posible -en el mejor de
	los casos, listas y diagramas básicos- para ahorrar tiempo. Debe
	tener otras restricciones que le exijan ampliarla en documentos
	más grandes, pero manteniendo el documento inicial pequeño y
	conciso, puede crearse en algunas sesiones de tormentas de ideas
	de grupo con un líder que cree la descripción
	dinámicamente. Esto no sólo requiere entradas para todos,
	también fomenta aprobación inicial y llegar a acuerdos entre
	todos. Quizá lo más importante, sea empezar el proyecto con
	mucho entusiasmo.
      </para>


      <!--
      HASTA AQUÍ
      -->


      <!--
      It's necessary to stay focused on the heart of what you're trying to
      accomplish in this phase: determine what the system is supposed to
      do. The most valuable tool for this is a collection of what are called
      "use cases". Use cases identify key features in the system that will
      reveal some of the fundamental classes you'll be using. These are
      essentially descriptive answers to questions like[11]: 

      [11] Thanks for help from James H Jarrett.
      -->

      <para>
	Es necesario estar centrado en el fondo de lo que está
	intentando conseguir en esta fase: determinar qué sistema se
	supone que quiere hacer. La herramienta más valiosa para esto es
	una colección de los llamados <quote>casos de uso</quote>. Los
	casos de uso identifican claves características en el sistema
	que pueden revelar algunas de las clases fundamentales que está
	usando. En esencia son respuestas descritivas a preguntas como:
	
	Están descritas esencialmente respuesas a preguntas como
	<footnote>
	  <para>
	   Gracias a <personname><firstname>James</firstname> <surname>H
	      Jarrett</surname></personname> por su ayuda.
	  </para>
	</footnote>:
      </para>

      <!--
      # "Who will use this system?"
      # "What can those actors do with the system?"
      # "How does this actor do that with this system?"
      # "How else might this work if someone else were doing this, or
        if the same actor had a different objective?" (to reveal
        variations)
      # "What problems might happen while doing this with the system?"
        (to reveal exceptions)
      -->

      <orderedlist>
	<listitem>
	  <para>
	    <quote>¿Quién usará el sistema?</quote>
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    <quote>¿Qué pueden hacer estos actores con el sistema?</quote>
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <quote>¿Cómo puede el actor hacer eso con este sistema?</quote>
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <quote>¿Cómo podría alguien más hacer este trabajo si
	    alguien más estuviera haciéndolo, o si el mismo actor
	    tuviera un objetivo diferente?</quote> (para revelar
	    variaciones).
	  </para>
	</listitem>
      
	<listitem>
	  <para>
	    <quote>¿Qué problemas podrían ocurrir mientras hace esto
	    con el sistema?</quote> (para revelar excepciones).
	  </para>
	</listitem>
      </orderedlist>
      
    
      <!--
      If you are designing an auto-teller, for example, the use case for a
      particular aspect of the functionality of the system is able to
      describe what the auto-teller does in every possible situation. Each
      of these "situations" is referred to as a scenario, and a use case can
      be considered a collection of scenarios. You can think of a scenario
      as a question that starts with: "What does the system do if...?" For
      example, "What does the auto-teller do if a customer has just
      deposited a check within 24 hours and there's not enough in the
      account without the check to provide the desired withdrawal?"
      -->

      <para>
	Si está diseñando un contestador automático, por ejemplo, el
	caso de uso para un aspector particular de la funcionalidad
	del sistema es poder describir qué hace el contestador
	automático en todas las situaciones posibles. Algunas de estas
	<quote>situaciones</quote> son referidas como a un
	<emphasis>escenario</emphasis>, y un caso de uso puede
	considerarse una colección de escenarios. Puede pensar en un
	escenario como una cuestión que comienza con: <quote>¿Qué hace
	el sistema si...?</quote> Por ejemplo, <quote>¿Qué hace el
	contestador si un cliente acaba de dejar una nota dentro de 24
	horas y no hay espacio en la cuenta para la nota para
	proporcionar la renuncia deseada?</quote>
      </para>


      <!-- 
      Use case diagrams are intentionally simple to prevent you from getting
      bogged down in system implementation details prematurely:
      -->

      <para>
	Usar diagramas de caso es intencionadamente sencillo para
	prevenirle de atascarse en los detalles de implementación del
	sistema prematuramente:
      </para>


    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_12.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_12.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>




      <!--
      Each stick person represents an "actor", which is typically a human or
      some other kind of free agent. (These can even be other computer
      systems, as is the case with "ATM".) The box represents the boundary
      of your system. The ellipses represent the use cases, which are
      descriptions of valuable work that can be performed with the
      system. The lines between the actors and the use cases represent the
      interactions.
      -->

      <para>
	Cada [FIXME: stick] persona representa un
	<quote>actor</quote>, el cual es tipicamente un humano o algún
	otro tipo de agente libre. (Este puede ser incluso otro
	sistema de computación, como es el caso de
	<quote>ATM</quote>). La caja representa el límite de su
	sistma. Las elipses representan los casos de uso, los cuales
	son descripciones de trabajo valioso que puede ser llevado a
	cabo con el sistema. Las líneas entre los actores y los casos
	de uso representan las interacciones.
      </para>


      <!--
      It doesn't matter how the system is actually implemented, as
      long as it looks like this to the user.
      -->

      <para>
	No debe preocuparle cómo el sistema está realmente
	implementado, mientras le parezca esto al usuario.
      </para>


      <!--
      A use case does not need to be terribly complex, even if the
      underlying system is complex. It is only intended to show the
      system as it appears to the user. For example:
      -->

      <para>
	Un caso de uso no necesita ser terriblemente complejo, incluso
	si el sistema subyacente es complejo. Esto está sólo previsto
	para mostrar cómo el sistema aparece al usuario. Por ejemplo:
      </para>


    <mediaobject>
      <imageobject role="latex" lang="es">
	<imagedata fileref="./images/V1_13.pdf" 
	  align="center" format="PDF"/>
      </imageobject>
      <imageobject role="html" lang="es">
	<imagedata fileref="./images/V1_13.png" 
	  align="center" format="PNG"/>
      </imageobject>
    </mediaobject>




      <!--
      The use cases produce the requirements specifications by determining
      all the interactions that the user may have with the system. You try
      to discover a full set of use cases for your system, and once you've
      done that you have the core of what the system is supposed to do. The
      nice thing about focusing on use cases is that they always bring you
      back to the essentials and keep you from drifting off into issues that
      aren't critical for getting the job done. That is, if you have a full
      set of use cases you can describe your system and move onto the next
      phase. You probably won't get it all figured out perfectly on the
      first try, but that's OK. Everything will reveal itself in time, and
      if you demand a perfect system specification at this point you'll get
      stuck.
      -->

      <para>
	Los casos de uso producen las especificaciones requeridas por
	decisivo todas las interacciones que el usuario puede tener
	con el sistema. Intente descubrir una serie completa de casos
	de uso para su sistema, y una vez que lo ha hecho tiene lo
	esencial de qué sistema se supone que está haciendo. La
	[FIXME:nice thing] sobre centrarse en casos de suo es que
	siempre le devuelve a lo esencial y [FIXME:keep you from
	drifting off] en usos que no son críticos para conseguir hacer
	su trabajo. Es decir, si tiene una serie completa de casos de
	uso puede describir su sistema y pasar a la siguiente
	fase. Probablemente [FIXME:won't get it all figured out]
	perfectamente en el primer intento, pero está bien. Todo le
	será revelado a su tiempo, y si necesita una especificación
	del sistema perfecta en este punto se atascará.
      </para>


      <!--
      If you get stuck, you can kick-start this phase by using a rough
      approximation tool: describe the system in a few paragraphs and then
      look for nouns and verbs. The nouns can suggest actors, context of the
      use case (e.g. "lobby"), or artifacts manipulated in the use
      case. Verbs can suggest interactions between actors and use cases, and
      specify steps within the use case. You'll also discover that nouns and
      verbs produce objects and messages during the design phase (and note
      that use cases describe interactions between subsystems, so the "noun
      and verb" technique can be used only as a brainstorming tool as it
      does not generate use cases) [12].

      [12] More information on use cases can be found in Applying Use
      Cases by Schneider & Winters (Addison-Wesley 1998) and Use Case
      Driven Object Modeling with UML by Rosenberg (Addison-Wesley
      1999).
      -->

      <para>
	Si se ha atascado, puede [FIXME:kick-start] esta fase usando
	una herramienta de aproximación dura: describir el sistema en
	pocos párrafos y entonces buscar sustantivos y verbos. Los
	nombres pueden sugerir actores, contexto del caso de uso
	([FIXME: e.g.] <quote>vestíbulo</quote>), o artefactos
	manipulados en el caso de uso. Los verbos pueden sugerir
	interacción entre actores y casos de uso, y pasos específicos
	dentro del caso de uso. Además descubrirá que nombres y verbos
	producen objetos y mensajes durnte la fase de diseño (y
	observe que los casos de uso describen interacciones entre
	subsistemas, así la técnica <quote>nombre y verbo</quote> sólo
	puede ser usada tanto una herramienta de lluvia de ideas como
	esto no genera casos de uso)	
	<footnote> 
	  <para>
	    Puede encontar más información sobre casos de uso en
	    <citetitle>Applying Use Cases</citetitle> de
	    <personname><surname>Schneider</surname></personname> &amp;
	    <personname><surname>Winters</surname></personname>
	    (Addison-Wesley 1998) y <citetitle>Use Case Driven Object
	    Modeling with UML</citetitle> de
	    <personname><surname>Rosenberg</surname></personname>
	    (Addison-Wesley 1999).
	  </para>
	</footnote>.
      </para>


      <!--
      The boundary between a use case and an actor can point out the
      existence of a user interface, but it does not define such a user
      interface. For a process of defining and creating user interfaces, see
      Software for Use by Larry Constantine and Lucy Lockwood, (Addison
      Wesley Longman, 1999) or go to www.ForUse.com.
      -->

      <para>
	El límite entre un caso de uso y un actor puede mostrar la
	existencia de una interfaz de usuario, pero no define tal
	interfaz de usuario. Para un proceso de definición y creación
	de interfaces de usuario, ver <citetitle>Software for
	Use</citetitle> de <personname><firstname>Larry</firstname>
	<surname>Constantine</surname></personname> y
	<personname><firstname>Lucy</firstname>
	<surname>Lockwood</surname></personname>, (Addison Wesley
	Longman, 1999) o ir a <ulink
	url="http://www.foruse.com">www.ForUse.com</ulink>.
      </para>

      <!--
      Although it's a black art, at this point some kind of basic scheduling
      is important. You now have an overview of what you're building so
      you'll probably be able to get some idea of how long it will take. A
      lot of factors come into play here. If you estimate a long schedule
      then the company might decide not to build it (and thus use their
      resources on something more reasonable that's a good thing). Or a
      manager might have already decided how long the project should take
      and will try to influence your estimate. But it's best to have an
      honest schedule from the beginning and deal with the tough decisions
      early. There have been a lot of attempts to come up with accurate
      scheduling techniques (like techniques to predict the stock market),
      but probably the best approach is to rely on your experience and
      intuition. Get a gut feeling for how long it will really take, then
      double that and add 10 percent. Your gut feeling is probably correct;
      you can get something working in that time. The "doubling" will turn
      that into something decent, and the 10 percent will deal with the
      final polishing and details[13]. However you want to explain it, and
      regardless of the moans and manipulations that happen when you reveal
      such a schedule, it just seems to work out that way.

      [13] My personal take on this has changed lately. Doubling and
      adding 10 percent will give you a reasonably accurate estimate
      (assuming there are not too many wild-card factors), but you
      still have to work quite diligently to finish in that time. If
      you want time to really make it elegant and to enjoy yourself in
      the process, the correct multiplier is more like three or four
      times, I believe.
      -->

      <para>
	Aunque esto es una magia negra, en este punto algun tipo de
	programa básico es importante. Ahora tiene una visión general
	de qué está construyendo pero probablemente será capaz de
	tener alguna idea cuánto aprovechará. Muchos actores entran en
	juego aquí. Si estima un programa largo entonces la compañía
	puede decidir decidir no construirlo (y así usar sus recursos
	en algo más razonable -esto es <emphasis>bueno</emphasis>). O
	un gerente puede tener ya decidido cuánto puede llevar un
	proyecto e intentar influir en su estimación. Pero es mejor
	tener un programa honesto desde el principio y dar con las
	decisiones difíciles pronto. Ha habido un montón de tentativas
	[FIXME: to come up] con técnicas acertadas de programación
	(como téncicas para predecir las existencias de mercado), pero
	probablemente el mejor acercamiento enfoque es confiar en su
	experiencia e intuición. Tenga instinto visceral para cuándo
	será realmente hecho, entonces doble este y añada un 10
	porciento. Su instinto visceral probablemente sea correcto;
	<emphasis>puede</emphasis> conseguir algo trabajando en este
	tiempo. El <quote>doblar</quote> tornará en algo decente, y el
	10 por ciento dará con los refinamientos y detalles finales
	<footnote> 
	  <para>
	    Últimamente mi contrato personal con esto ha
	    cambiado. Doblar y añadir un 10 por ciento puede darle una
	    estimación bastante acertada (asumiendo que no hay
	    demasiados factores comodín), pero debe tener
	    para trabajar bastante diligencia para acabar a tiempo. Si
	    realmente quiere tiempo para hacer esto elegante y
	    pasárselo bien en el proceso, el multiplicador correcto es
	    más de tres o cuatro veces, creo yo.
	  </para>
	</footnote>. Sin embargo quiere explicarlo, y a pesar de quejas
	y manipulaciones que ocurren cuando revela un calendario, parece
	salir bien este camino.
      </para>
    </sect2>


    <sect2>

      <!-- Phase 2: How will we build it? -->
      <title> Fase 2: ¿Cómo podemos construirlo? </title>

      <!--
      In this phase you must come up with a design that describes what the
      classes look like and how they will interact. An excellent technique
      in determining classes and interactions is the
      Class-Responsibility-Collaboration (CRC) card. Part of the value of
      this tool is that it's so low-tech: you start out with a set of blank
      3 "by 5" cards, and you write on them. Each card represents a single
      class, and on the card you write:
      -->

      <para>
	En esta fase debe acercarse con un diseño que describe qué
	clases se parecen y y cómo interactúan. Una técnica excelente
	en determinar clases es la ficha
	<emphasis>Class-Responsibility-Collaboration</emphasis>
	(CRC). Parte del valor de esta herramienta es que es
	baja-tecnología: inicia con una colección de 3
	[FIXME:<quote>by5</quote>] fichas en blanco, y escribe sobre
	ellas. Cada ficha representa una única clase, y en la carta
	escribe:
      </para>



      <orderedlist>
	<listitem>
	  <!-- 
	  1. The name of the class. It's important that this name
	  capture the essence of what the class does, so that it makes
	  sense at a glance.
	  -->
	  <para>
	    El nombre de la clase. Es importante que el nombre capture
	    la esencia de lo que la clase hace, así tiene sentido con
	    un vistazo.
	  </para>
	</listitem>
	<listitem>
	  <!-- 
	  2. The "responsibilities" of the class: what it should
	  do. This can typically be summarized by just stating the names
	  of the member functions (since those names should be
	  descriptive in a good design), but it does not preclude other
	  notes. If you need to seed the process, look at the problem
	  from a lazy programmer's standpoint: What objects would you
	  like to magically appear to solve your problem?  
	  -->
	  <para>
	    Las <quote>responsabilidades</quote> de la clase: qué debe
	    hacer. Típicamente puede ser resumido por la misma
	    declaración de las funciones miembro (ya que esos nombres
	    pueden ser descritos en un buen diseño), pero no descarta
	    otras notas. Si necesita sembrar el proceso, mire el
	    problema desde un punto de vista de programador perezoso:
	    ¿Qué objetos quiere que aparezcan por arte de magia para
	    resolver su problema?
	  </para>
	</listitem>
	<listitem>
	  <!--
 	  3 The "collaborations" of the class: what other classes does
	  it interact with? "Interact" is an intentionally broad term;
	  it could mean aggregation or simply that some other object
	  exists that will perform services for an object of the
	  class. Collaborations should also consider the audience for
	  this class. For example, if you create a class Firecracker,
	  who is going to observe it, a Chemist or a Spectator? The
	  former will want to know what chemicals go into the
	  construction, and the latter will respond to the colors and
	  shapes released when it explodes.
	  -->
	  <para>
	    Las <quote>colaboraciones</quote> de la clase: ¿qué otras
	    clases interactúan con esta? <quote>Relacionarse</quote>
	    es un término extenso a propósito; puede significar
	    agregación o simplemente que algún otro objeto existe que
	    lleva a cabo servicios para un objeto de una
	    clase. También se consideran colaboraciones la audiencia
	    para esta clase. Por ejemplo, si crea una clase
	    <classname>Firecracker</classname>, ¿quién va a
	    observarlo, un <classname>Chemist</classname> o un
	    <classname> Spectator</classname>? El anterior puede
	    querer saber qué químicos van en la construcción, y el
	    último responderá a los colores y figuras [FIXME:
	    released] cuando explote.
	  </para>
	</listitem>
      </orderedlist>


      <!--
      You may feel like the cards should be bigger because of all the
      information you'd like to get on them, but they are intentionally
      small, not only to keep your classes small but also to keep you from
      getting into too much detail too early. If you can't fit all you need
      to know about a class on a small card, the class is too complex
      (either you're getting too detailed, or you should create more than
      one class). The ideal class should be understood at a glance. The idea
      of CRC cards is to assist you in coming up with a first cut of the
      design so that you can get the big picture and then refine your
      design.
      -->
      
      <para>
	Puede creer que las fichas pueden ser más grandes porque toda
	la información [FIXME:you'd like to get] en ellas, pero son
	pequeñas a propósito, no sólo tiene sus pequeñas clases pero
	[FIXME:also to keep you from getting into too much detail too
	early]. Si no puede ajustar todo lo que necesita saber sobre
	una clase en una ficha pequeña, la clase es también compleja
	([FIXME: either you're getting too detailed], o crea más de
	una clase). La clase ideal se entiende con un vistazo. La idea
	de las fichas CRC es ayudarle en [FIXME:comming up] con un
	primer corte del diseño y que pueda conseguir la gran imagen y
	entonces refinar su diseño.
      </para>
      

      <!--
      One of the great benefits of CRC cards is in communication. It's best
      done real-time, in a group, without computers. Each person takes
      responsibility for several classes (which at first have no names or
      other information). You run a live simulation by solving one scenario
      at a time, deciding which messages are sent to the various objects to
      satisfy each scenario. As you go through this process, you discover
      the classes that you need along with their responsibilities and
      collaborations, and you fill out the cards as you do this. When you've
      moved through all the use cases, you should have a fairly complete
      first cut of your design.
      -->

      <para>
	Uno de los mayores beneficios de las fichas CRC es en
	comunicación. Mejor hecho en tiempo-real, en un grupo, sin
	ordenadores. Cada persona tiene responsabilidad de varias
	clases (la cual al principo no tiene nombres ni otra
	información). Ejecute una simulación viva resolviendo un
	escenario en un tiempo, decidiendo qué mensajes envía a varios
	objetos para satisfacer cada escenario. Como va a través de
	este proceso, descubre las clases que necesitará con sus
	responsabilidades y colaboraciones, rellene las fichas
	[FIXME:as you do this]. Cuando haya movido a través todos los
	casos de uso, podrá tener primera vista bastante completa de
	su diseño.
      </para>

      <!--
      Before I began using CRC cards, the most successful consulting
      experiences I had when coming up with an initial design involved
      standing in front of a team, who hadn't built an OOP project before,
      and drawing objects on a whiteboard. We talked about how the objects
      should communicate with each other, and erased some of them and
      replaced them with other objects. Effectively, I was managing all the
      "CRC cards" on the whiteboard. The team (who knew what the project was
      supposed to do) actually created the design; they "owned" the design
      rather than having it given to them. All I was doing was guiding the
      process by asking the right questions, trying out the assumptions, and
      taking the feedback from the team to modify those assumptions. The
      true beauty of the process was that the team learned how to do
      object-oriented design not by reviewing abstract examples, but by
      working on the one design that was most interesting to them at that
      moment: theirs.
      -->

      <para>
	Antes de empezar a usar fichas CRC, las experiencias de
	consulta más existosas que tuve cuando [FIXME: coming up] con
	un diseño inicial complicado estando al frente de un equipo,
	quien no haya construido un proyecto POO antes, y dibujando
	objetos en un [FIXME: whiteboard]. Se habló sobre cómo los
	objetos suelen comunicar con otros, y borrar algunos de ellos
	y reemplazarlos por otros objetos. Efectivamente, estuve
	dirigiendo todas las<quote>fichas CRC</quote> en el [FIXME:
	whiteboard]. El equipo (que conocía que proyecto se suponía
	había que hacer) hasta creado el diseño;
	<quote>poseyeron</quote> el diseño [FIXME: rather than having
	it given to them]. Todo lo que hacía era guiar el proceso
	preguntando las cuestiones adecuadas, probar los supuestos, y
	llevar la retroalimentación desde el equipo para modificar
	estos supuestos. La verdadera belleza del proceso fue que el
	equipo aprendió cómo hacer diseños orientado a objetos no
	revisando ejemplos abstractos, sino trabajando sobre un diseño
	que era más interesante para ellos en el momento: los suyos.
      </para>

      <!--
      Once you've come up with a set of CRC cards, you may want to create a
      more formal description of your design using UML[14]. You don't need
      to use UML, but it can be helpful, especially if you want to put up a
      diagram on the wall for everyone to ponder, which is a good idea. An
      alternative to UML is a textual description of the objects and their
      interfaces, or, depending on your programming language, the code
      itself[15].

      [14] For starters, I recommend the aforementioned UML Distilled.

      [15] Python (www.Python.org) is often used as "executable
      pseudocode". 
      -->

      <para>
	Una vez que se acerque con una serie de fichas CRC, puede
	querer crear un descripción más formal de su diseño usando
	UML
	<footnote> 
	  <para>
	    Para novatos, recomiendo el mencionado <citetitle>UML
	    Distilled</citetitle>.
	  </para>
	</footnote>. No necesita usar UML, pero puede servirle de ayuda,
	especialmente si quiere ofrecer un diagrama en la pared para que
	todo el mundo lo considere, lo cual es una buena idea. Una
	alternativa a UML es una descripción textual de los objetos y
	sus interfaces, o, dependiendo de su lenguaje de programación,
	su propio código
	<footnote> 
	  <para>
	    Python (<ulink
	      url="http://www.python.org">www.Python.org</ulink>) suele
	      utilizarse como <quote>pseudocódigo ejecutable</quote>.
	  </para>
	</footnote>.
      </para>


      <!--
      UML also provides an additional diagramming notation for describing
      the dynamic model of your system. This is helpful in situations in
      which the state transitions of a system or subsystem are dominant
      enough that they need their own diagrams (such as in a control
      system). You may also need to describe the data structures, for
      systems or subsystems in which data is a dominant factor (such as a
      database).
      -->

      <para>
	UML también proporciona una anotación de diagrama adicional
	para describir el modelo dinámico de su sistema. Esto es útil
	en situaciones en las que las transiciones de estado de un
	sistema o subsistema son bastante más dominantes de lo que
	necesitan sus propios diagramas (como en un sistema de
	control). También puede necesitar describir las estructuras de
	datos, para sistemas o subsistemas en cuyos datos es una
	factor dominante (como una base de datos).
      </para>

      <!--
      You'll know you're done with phase 2 when you have described the
      objects and their interfaces. Well, most of them there are usually a
      few that slip through the cracks and don't make themselves known until
      phase 3. But that's OK. All you are concerned with is that you
      eventually discover all of your objects. It's nice to discover them
      early in the process but OOP provides enough structure so that it's
      not so bad if you discover them later. In fact, the design of an
      object tends to happen in five stages, throughout the process of
      program development.
      -->

      <para>
	Sabrá qué está haciendo con la fase 2 cuando haya descrito los
	objetos y sus interfaces. Bien, habitualmente la mayoría de
	ellos son algunos que deterioran a causa de las fracturas y no
	se hacen conocer hasta la fase 3. Pero está bien. Todo lo que
	le preocupa es que finalmente encuentre todo de sus
	proyectos. Es bueno descubrirlo pronto en el proceso pero la
	POO provee bastante estructura que no es mala si la descubre
	luego. De hecho, el diseño de un objeto suele courrir in cinco
	estados, durante todo el proceso de desarrollo del programa.
      </para>

      <sect3>
	<!-- Five stages of object design -->
	<title>Las cinco etapas del diseño de objetos</title>

	<!--
	The design life of an object is not limited to the time when you're
	writing the program. Instead, the design of an object appears over a
	sequence of stages. It's helpful to have this perspective because you
	stop expecting perfection right away; instead, you realize that the
	understanding of what an object does and what it should look like
	happens over time. This view also applies to the design of various
	types of programs; the pattern for a particular type of program
	emerges through struggling again and again with that problem (Design
	Patterns are covered in Volume 2). Objects, too, have their patterns
	that emerge through understanding, use, and reuse.
	-->

	<para>
	  La vida de diseño de un objeto no se limita al tiempo cuando
	  escribe el programa. En cambio, el diseño de un objeto
	  aparece sobre una secuencia de estados. Es útil tener esta
	  perspectiva porque para de esperar perfección en seguida; en
	  cambio, se dará cuenta de que sus conocimientos de lo que un
	  objeto hace y qué suele parecerse a lo que ocurre en el
	  tiempo extra. Esta vista también se aplica en el diseño de
	  varios tipos de programas; el diseño para un particular tipo
	  de programa surge a través de peleas otra vez y de nuevo con
	  este problema (<emphasis>Patrones de Diseño</emphasis> se
	  desarrolla en el Volumen 2). Los objetos, también, tienen
	  sus patrones que surgen a través del entendimiento, uso y
	  reutilización.
	</para>

	<orderedlist>
	  <listitem>
	    <!--
	    1. Object discovery. This stage occurs during the initial
	    analysis of a program. Objects may be discovered by looking
	    for external factors and boundaries, duplication of elements
	    in the system, and the smallest conceptual units. Some
	    objects are obvious if you already have a set of class
	    libraries. Commonality between classes suggesting base
	    classes and inheritance may appear right away, or later in
	    the design process.  
	    -->

	    <para>
	      Objeto descubierto. Este estado ocurre durante el
	      análisis inicial de un programa. Los objetos pueden
	      descubrirse viendo los factores externos y los límites,
	      duplicación de elementos en el sistema, y las unidades
	      conceptuales más pequeñas. Algunos objetos son obvios si
	      ya tienen una colección de clases de librerías. La
	      comunidad entre clases sugiere clases base y herencia
	      puede parecer en seguida, o despúes en el proceso de
	      diseño.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <!-- 2. Object assembly. As you're building an object you'll
	    discover the need for  new members that didn't appear during
	    discovery.  The internal  needs  of the  object may  require
	    other classes to support it.  -->

	    <para>
	      Objeto reunido. Si está construyendo un objeto
	      descubrirá la necesidad para nuevos miembros que no
	      aparecen durante el descubrimiento. Lo interno necesita
	      del objeto que requiere otras clases de soporte.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- 3. System construction. Once again, more requirements
	    for an object may appear at this later stage. As you learn,
	    you evolve your objects. The need for communication and
	    interconnection with other objects in the system may change
	    the needs of your classes or require new classes. For
	    example, you may discover the need for facilitator or helper
	    classes, such as a linked list, that contain little or no
	    state information and simply help other classes function.
	    -->

	    <para>
	      Construcción del sistema. Una vez más, más
	      requerimientos para un objeto puede aparecer en este
	      largo estado. Si aprende, desarrolla sus objetos. La
	      necesidad de comunicación e interconexión con otros
	      objetos en el sistema puede cambiar las necesidades de
	      sus clases o requerir nuevas clases. Por ejemplo, puede
	      descubrir la necesidad de clases facilitadoras o
	      ayudantes, como una lista enlazada, que contiene algo o
	      no información oficial y sencillamente servir otras
	      clases de funciones.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- 4. System extension. As you add new features to a
	    system you may discover that your previous design doesn't
	    support easy system extension. With this new information,
	    you can restructure parts of the system, possibly adding new
	    classes or class hierarchies.  -->

	    <para>
	      Extensión del sistema. Cuanco añada nuevas características
	      a un sistema puede descubrir que su diseño previo no
	      soporta extensiones de sistema sencillas. Con esta nueva
	      información, puede reestructurar partes del sistema,
	      posiblemente añadiendo nuevas clases o jerarquía de
	      clases.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- 5. Object reuse. This is the real stress test for a
	    class. If someone tries to reuse it in an entirely new
	    situation, they'll probably discover some shortcomings. As
	    you change a class to adapt to more new programs, the
	    general principles of the class will become clearer, until
	    you have a truly reusable type. However, don't expect most
	    objects from a system design to be reusable it is perfectly
	    acceptable for the bulk of your objects to be
	    system-specific. Reusable types tend to be less common, and
	    they must solve more general problems in order to be
	    reusable.  -->

	    <para>
	      Reutilización de objetos. Este es el verdadero test de
	      estrés para una clase. Si alguien intenta reutilizarla
	      en una situación completamente nueva, probablemente
	      descubrirá algunos defectos. Si cambia una clase para
	      adaptarla a nuevos programas, los principios generales
	      de la clase se verán más claros, hasta que consiga un
	      tipo verdaderamente reutilizable. Sin embargo, no espere
	      que muchos objetos del diseño de un sistema sean
	      reutilizables -es perfectamente aceptable que la mayor
	      parte de los objetos sean específicos para el
	      sistema. Los tipos reutilizables tienden a ser menos
	      comunes, y deben resolver problemas más generales para
	      ser reutilizables.
	    </para>
	  </listitem>
	</orderedlist>

      </sect3>

      <sect3>
	<!-- Guidelines for object development -->
	<title>Directrices para desarrollo de objetos</title>
	
	<!--
	These stages suggest some guidelines when thinking about
	developing your classes: 
	-->
	
	<para>
	  Estos estados sugieren algunas directrices cuando se piensa
	  acerca del desarrollo de las clases:
	</para>

	<orderedlist>
	  <listitem>
	    <!-- 
	    Let a specific problem generate a class, then let
	    the class grow and mature during the solution of other
	    problems.
	    -->
	    <para>
	      Permita que un problema específico dé lugar a una clase,
	      después deje que la clase crezca y madure durante la
	      solución de otros problemas.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- 
	    Remember, discovering the classes you need (and their
	    interfaces) is the majority of the system design. If you
	    already had those classes, this would be an easy project.
	    -->
	    <para>
	      Recuerde, descubrir las clases que necesita (y sus
	      interfaces) es la mayor parte del diseño del sistema. Si
	      ya tenía esas clases, sería un proyecto fácil.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- Don't force yourself to know everything at the
	    beginning; learn as you go. This will happen anyway.  
	    -->
	    <para>
	      No se fuerce por saber todo desde el principio; aprenda
	      conforme avanza. Ocurrá de todos modos.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- 
	    Start programming; get something working so you can prove
	    or disprove your design. Don't fear that you'll end up
	    with procedural-style spaghetti code - classes partition
	    the problem and help control anarchy and entropy. Bad
	    classes do not break good classes.
	    -->
	    <para>
	      Comience a programar; consiga tener algo funcionando
	      para poder aprobar o desaprobar su diseño. No tenga
	      miedo a que acabe haciendo código procedural espagueti
	      -las clases dividen el problema y ayudan a controlar la
	      anarquía y la entropía. Las clases malas no estropean
	      las buenas.
	    </para>
	  </listitem>

	  <listitem>
	    <!-- 
	    Always keep it simple. Little clean objects with
	    obvious utility are better than big complicated
	    interfaces. When decision points come up, use an Occam's
	    Razor approach: Consider the choices and select the one
	    that is simplest, because simple classes are almost always
	    best. Start small and simple, and you can expand the class
	    interface when you understand it better, but as time goes
	    on, it's difficult to remove elements from a class.
	    -->
	    <para>
	      Manténgalo simple. Pequeños objetos claros con
	      utilidades obvias son mejores que grandes interfaces
	      complicadas. Cuando [FIXME: decision points come up],
	      use una propuesta de
	      <personname><firstname>Occam</firstname>
	      <surname>Razor</surname></personname>: Considere las
	      elecciones y seleccione casi siempre la mejor. Empezará
	      pequeño y sencillo, y podrá ampliar la clase interfaz
	      cuando lo entienda mejor, pero cuando esto ocurra, será
	      difícil eliminar elementos de una clase.
	    </para>
	  </listitem>
	</orderedlist>
      </sect3>

    </sect2>

    <sect2>
      <!-- Phase 3: Build the core -->
      <title> Fase 3: Construir el núcleo </title>
      
      <!--
      This is the initial conversion from the rough design into a compiling
      and executing body of code that can be tested, and especially that
      will prove or disprove your architecture. This is not a one-pass
      process, but rather the beginning of a series of steps that will
      iteratively build the system, as you'll see in phase 4.
      -->

      <para>
	Esta es la conversión inicial desde el diseño duro al cuerpo
	del código compilable y ejecutable que puede ser probado, y
	especialmente que aprobará y desaprobará su arquitectura. No
	es un proceso de paso, más bien el principio de una serie de
	pasos que iterativamente construirán el sistema, como verá en
	el fase 4.
      </para>


      <!--
      Your goal is to find the core of your system architecture that
      needs to be implemented in order to generate a running system,
      no matter how incomplete that system is in this initial
      pass. You're creating a framework that you can build upon with
      further iterations. You're also performing the first of many
      system integrations and tests, and giving the stakeholders
      feedback about what their system will look like and how it is
      progressing. Ideally, you are also exposing some of the critical
      risks. You'll probably also discover changes and improvements
      that can be made to your original architecture - things you
      would not have learned without implementing the system.
      -->

      <para>
	Su objetivo es encontrar el núcle de la arquitectura de su
	sistema que necesita ser implementado para generar un sistema
	de gestión, no importa cómo esté de incompleto este sistema en
	su paso inicial. Está creando una estructura que puede
	construir en base a más iteraciones. También está llevando a
	cabo el primero de muchas integraciones del sistema y test, y
	dando a los clientes feedback acerca de lo que parecerán sus
	sistemas y cómo progresan. Perfectamente, también expone
	algunos de los peligros críticos. Probablemente discubrirá
	cambios y mejoras que se pueden hacer en la arquitectura
	original -cosas que puede no haber aprendido sin implementar
	el sistema.
      </para>


      <!--
      Part of building the system is the reality check that you get
      from testing against your requirements analysis and system
      specification (in whatever form they exist). Make sure that your
      tests verify the requirements and use cases. When the core of
      the system is stable, you're ready to move on and add more
      functionality.
      -->

      <para>
	Parte de construir el sistema es control real que consigue de
	probar en contra los análisis de requerimientos y
	especificación del sistema (de cualquier forma
	existe). Asegúrese de que sus test verifican los
	requerimientos y los casos de uso. Cuando el núcleo de sus
	sistema sea estable, estará preparado para moverlo y añadir
	más funcionalidad.
      </para>
    </sect2>

    <sect2>
      <!-- Phase 4: Iterate the use cases -->
      <title> Fase 4: Repetir los casos de uso</title>
      
      <!--
      Once the core framework is running, each feature set you add is
      a small project in itself. You add a feature set during an
      iteration, a reasonably short period of development.
      -->

      <para>
	Una vez que la estructura del núcleo está corriendo, cada
	característica asignada que añade es un pequeño proyecto
	propio. Añada una colección de características durante una
	<emphasis>iteración</emphasis>, un periodo bastante corto de
	desarrollo.
      </para>


      <!--
      How big is an iteration? Ideally, each iteration lasts one to
      three weeks (this can vary based on the implementation
      language). At the end of that period, you have an integrated,
      tested system with more functionality than it had before. But
      what's particularly interesting is the basis for the iteration:
      a single use case. Each use case is a package of related
      functionality that you build into the system all at once, during
      one iteration. Not only does this give you a better idea of what
      the scope of a use case should be, but it also gives more
      validation to the idea of a use case, since the concept isn't
      discarded after analysis and design, but instead it is a
      fundamental unit of development throughout the software-building
      process.
      -->

      <para>
	¿Cómo es una iteración grande? Perfectamente, cada iteración
	dura unas tres semanas (puede cambiar basándose en el lenguaje
	de implementación). Al final de este periodo, tendrá un
	integrado, sistema probado con más funcionalidades de las que
	tuvo antes. Pero qué es particularmente interesante en las
	bases de la iteración: un único caso de uso. Cada caso de uso
	es un paquete de funcionalidades relacionadas que puede
	construir en su sistema de repente, durante una iteración. No
	sólo le da una mejor idea de qué alcance suele tener un caso
	de uso, ya que el concepto no está descartado después del
	análisis y diseño, pero es una unidad fundamental de
	desarrollo durante el proceso de construcción de software.
      </para>


      <!--
      You stop iterating when you achieve target functionality or an
      external deadline arrives and the customer can be satisfied with
      the current version. (Remember, software is a subscription
      business.) Because the process is iterative, you have many
      opportunities to ship a product instead of a single endpoint;
      open-source projects work exclusively in an iterative,
      high-feedback environment, which is precisely what makes them
      successful.
      -->

      <para>
	Para la iteración cuando se consigue el objetivo funcional o
	llega un límite externo y el cliente está satisfecho con la
	versión actual. (Recuerde, el software es una subscripción de
	negocios). Porque el proceso es iterativo, tiene muchas
	oportunidades para enviar un producto en vez de un simple
	punto final; los proyectos de código abierto trabajan
	exclusivamente en un iterativo, entorno de alto feedback, que
	es precisamente el que lo hace exitoso.
      </para>


      <!--
      An iterative development process is valuable for many
      reasons. You can reveal and resolve critical risks early, the
      customers have ample opportunity to change their minds,
      programmer satisfaction is higher, and the project can be
      steered with more precision. But an additional important benefit
      is the feedback to the stakeholders, who can see by the current
      state of the product exactly where everything lies. This may
      reduce or eliminate the need for mind-numbing status meetings
      and increase the confidence and support from the stakeholders.
      -->

      <para>
	Un proceso de desarrollo iterativo es valioso por muchas
	razones. Puede mostrar y resolver riesgos críticos pronto, los
	clientes tienen abundantes oportunidades de cambiar sus
	opiniones, la satisfacción del programador es más alta, y el
	proyecto puede dirigirse con más precisión. Pero un beneficio
	adicional importante es el feedback con los clientes, los
	cuales pueden ver por el estado actual del producto
	exactamente donde se encuentra todo. Esto puede reducir o
	eliminar la necesidad de misterios abrumadores [FIXME:status
	meetings] y aumentar la confidencia y el soporte con los
	clientes.
      </para>

    </sect2>


    <sect2>
      <!-- Phase 5: Evolution -->
      <title>Fase 5: Evolución</title>

      <!-- 
      This is the point in the development cycle that has traditionally been
      called "maintenance", a catch-all term that can mean everything from
      "getting it to work the way it was really supposed to in the first
      place" to "adding features that the customer forgot to mention" to the
      more traditional "fixing the bugs that show up" and "adding new
      features as the need arises". So many misconceptions have been applied
      to the term "maintenance" that it has taken on a slightly deceiving
      quality, partly because it suggests that you've actually built a
      pristine program and all you need to do is change parts, oil it, and
      keep it from rusting. Perhaps there's a better term to describe what's
      going on.
      -->

      <para>
	Este es el punto en el ciclo de desarrollo que se conoce
	tradicionalmente como <quote>mantenimiento</quote>, [FIXME:
	catch-all] un término que puede significar de todo desde
	<quote>cogerlo para trabajar el camino en realidad se supuso
	en un primer lugar</quote> hasta <quote>añadir características
	que el cliente olvidó mencionar</quote> para el más
	tradicional <quote>arreglo de bugs que aparecen</quote> y
	<quote>añadir nuevas características según se presente la
	necesidad</quote>. Algunas ideas equivocadasse han aplicado al
	término <quote>mantenimiento</quote> que ha asumido un ligera
	calidad de engaño, en parte porque sugiere que actualmente ha
	construido un programa prístino y todo lo que necesita hacer
	es cambiar partes, aceite de oliva, y guardarlo hasta que se
	oxide. Quizá haya un término mejor para describir que está
	haciendo.
      </para>


      <!--
      I'll use the term evolution[16]. That is, "You won't get it
      right the first time, so give yourself the latitude to learn and
      to go back and make changes." You might need to make a lot of
      changes as you learn and understand the problem more deeply. The
      elegance you'll produce if you evolve until you get it right will
      pay off, both in the short and the long term. Evolution is where
      your program goes from good to great, and where those issues that
      you didn't really understand in the first pass become clear. It's 
      also where your classes can evolve from single-project usage to
      reusable resources. 

      [16] At least one aspect of evolution is covered in Martin
      Fowler's book Refactoring: improving the design of existing code
      (Addison-Wesley 1999). Be forewarned that this book uses Java
      examples exclusively. 
      -->

      <para>
	Se usará el término <emphasis>evolución</emphasis>
	<footnote> 
	  <para>
	    Por lo menos un aspecto de evolución se explica en el
	    libro <emphasis>Refactoring: improving the design of
	    existing code</emphasis> (Addison-Wesley 1999) de
	    <personname> <firstname>Martin</firstname>
	    <surname>Fowler</surname> </personname>. Fíjese en que
	    este libro usa exlusivamente ejemplo en Java.
	  </para>
	</footnote>. Es decir, <quote>No podrá hacerlo bien la primera
	vez, pero le dará la latitud para aprender y volver y hacer
	cambios</quote>. Puede necesitar hacer muchos cambios así
	aprenderá y entenderá el problema más profundamente. La
	elegancia se producirá si evoluciona hasta hacerlo bien valdrá
	la pena, ambos en el término corto y el largo. Evolución es
	donde su programa pasa de bueno a fenomenal, y donde estos
	usos que realmente no entiende en un primer momento pasan
	después a ser más claros. Es también donde sus clases pueden
	evolucionar desde un uso de proyecto simple a recursos
	reutilizables.
      </para>

      <!--
      What it means to "get it right" isn't just that the program
      works according to the requirements and the use cases. It also
      means that the internal structure of the code makes sense to
      you, and feels like it fits together well, with no awkward
      syntax, oversized objects, or ungainly exposed bits of code. In
      addition, you must have some sense that the program structure
      will survive the changes that it will inevitably go through
      during its lifetime, and that those changes can be made easily
      and cleanly. This is no small feat. You must not only understand
      what you're building, but also how the program will evolve (what
      I call the vector of change[17]). Fortunately, object-oriented
      programming languages are particularly adept at supporting this
      kind of continuing modification - the boundaries created by the
      objects are what tend to keep the structure from breaking
      down. They also allow you to make changes - ones that would seem
      drastic in a procedural program - without causing earthquakes
      throughout your code. In fact, support for evolution might be
      the most important benefit of OOP.

      [17] This term is explored in the Design Patterns chapter in
      Volume 2.
      -->

      <para>
	Lo que significa <quote>hacerlo bien</quote> no es
	precisamente que el programa trabaja según los requerimientos
	y los casos de uso. Lo que significa es que la estructura
	interna del código le hace juicios, y parece que quedan bien
	juntos, sin sintaxis difícil, [FIXME: oversized ]objetos, o
	desgarbados pedazos de código expuesto. Además, debe tener
	alguna sentencia de la estructura del programa que sobreviva a
	los cambios que inevitablemente habrá durante el desarrollo de
	su vida, y estos cambios pueden hacerse fácil y
	limpiamente. No es una proeza pequeña. Debe entender no
	sólamente lo que está construyendo, sino también cómo el
	programa evolucionará (lo que yo llamo el <emphasis>vector de
	cambio</emphasis>
	<footnote>
	  <para>
	    Este término se explica en capítulo <emphasis>Los
	    patrones de diseño</emphasis> en el Volumen 2
	  </para>
	</footnote>. Afortunadamente, los lenguajes de programación
      orientados a objetos son particularmente expertos en soportar
      este tipo de motidificaciones continuas - los límites creados
      por los objetos son los que tienden a conservar la estructura
      para dividirla. También le permiten hacer cambios - algunos
      pueden parecer drásticos en un programa procedural - sin causar
      terremotos durante todo su código. En realidad, respaldo para
      evolución puede ser el beneficio más importante de la POO.
      </para>

      <!--
      With evolution, you create something that at least approximates
      what you think you're building, and then you kick the tires,
      compare it to your requirements and see where it falls short. Then
      you can go back and fix it by redesigning and re-implementing the
      portions of the program that didn't work right[18]. You might
      actually need to solve the problem, or an aspect of the problem,
      several times before you hit on the right solution. (A study of
      Design Patterns, described in Volume 2, is usually helpful here.)

      [18]This is something like "rapid prototyping", where you were
      supposed to build a quick-and-dirty version so that you could
      learn about the system, and then throw away your prototype and
      build it right. The trouble with rapid prototyping is that
      people didn't throw away the prototype, but instead built upon
      it. Combined with the lack of structure in procedural
      programming, this often produced messy systems that were
      expensive to maintain.
      -->

      <para>
	Con evolución, crea algo que al menos se aproxima a lo que
	piensa que está construyendo, y luego [FIXME: kick the tires],
	compárelo con sus requerimientos y vea dónde no
	alcanza. Entonces puede regresar y arreglarlo rediseñando y
	re-implementando las porciones del programa que no funcionen bien
	<footnote>
	  <para>
	    Esto es algo como <quote>prototipado rápido</quote>, donde
	    se propuso construir un borrador de la versión rápido así
	    que puede aprender sobre el sistema, y entonces puede
	    tirar su prototipo y construir el bueno. El problema con
	    el prototipado rápido es que la gente no tiró el
	    prototipo, y sin embargo construyó sobre él. Combinado con
	    la falta de estructura en la programación procedural, esto
	    producía a menudo sistemas desordenados que eran difíciles
	    de mantener.
	  </para>
	</footnote>. Realmente puede necesitar resolver el problema, o
	un aspecto del mismo, varias veces antes de dar con la
	solución correcta. (Un estudio de <emphasis>Diseño de
	Patrones</emphasis>, descrito en el Volumen 2, es normalmente
	útil aquí).
      </para>

      <!--
      Evolution also occurs when you build a system, see that it matches
      your requirements, and then discover it wasn't actually what you
      wanted. When you see the system in operation, you find that you
      really wanted to solve a different problem. If you think this kind
      of evolution is going to happen, then you owe it to yourself to
      build your first version as quickly as possible so you can find
      out if it is indeed what you want.
      -->
      
      <para>
	La evolución también ocurre cuando construye un sistema, ve
	que encaja con sus requerimientos, y entonces descubre que no
	era realmente lo que buscaba. Cuando ve el sistema en
	funcionamiento, descubre que realmente buscaba resolver un
	problema diferente. Si piensa que este tipo de evolución le va
	a suceder, entonces se debe construir su primera versión lo
	más rápidamente posible que pueda informarse de que esto tan
	bueno como buscaba.
      </para>


      <!--
      Perhaps the most important thing to remember is that by default -
      by definition, really - if you modify a class then its super- and
      subclasses will still function. You need not fear modification
      (especially if you have a built-in set of unit tests to verify the
      correctness of your modifications). Modification won't
      necessarily break the program, and any change in the outcome will
      be limited to subclasses and/or specific collaborators of the
      class you change.
      -->

      <para>
	Quizás lo más importante que recordar es que por defecto -por
	definición, realmente- si modifica una clase entonces está
	bien y las subclases [FIXME: will still] función. Necesita no
	temer la modificación (especialmente si tiene un conjunto
	incorporado de test de unidad para verificar la exactitud de
	sus modificaciones). La modificación no romperá necesariamente
	el programa, y ningún cambio en el resultado será limitado a
	subclases y/o colaboradores específicos de la clase que
	cambie.
      </para>

    </sect2>

    <sect2>
      <!-- Plans pay off -->
      <title>Los planes valen la pena</title>

      <!--
      Of course you wouldn't build a house without a lot of
      carefully-drawn plans. If you build a deck or a dog house, your
      plans won't be so elaborate but you'll probably still start with
      some kind of sketches to guide you on your way. Software
      development has gone to extremes. For a long time, people didn't
      have much structure in their development, but then big projects
      began failing. In reaction, we ended up with methodologies that
      had an intimidating amount of structure and detail, primarily
      intended for those big projects. These methodologies were too
      scary to use - it looked like you'd spend all your time writing
      documents and no time programming. (This was often the case.) I
      hope that what I've shown you here suggests a middle path - a
      sliding scale. Use an approach that fits your needs (and your
      personality). No matter how minimal you choose to make it, some
      kind of plan will make a big improvement in your project as
      opposed to no plan at all. Remember that, by most estimates, over
      50 percent of projects fail (some estimates go up to 70 percent!).
      -->

      <para>
	Por supuesto, no construiría una casa sin un montón de planos
	cuidadosamente dibujados. Si construye un piso o una casa para
	el perro, sus planos no serán muy elaborados pero probablemente
	empezará con algún tipo de esbozo para guiarle en su camino. El
	desarrollo de software ha ido hasta el extremo. Durante mucho
	tiempo, la gente tenía poca estructura en sus desarrollos, pero
	entonces grandes proyectos empezaron a fracasar. Como resultado,
	se acabó utilizando metodologías que tenían una cantidad
	abrumadora de estructura y detalle, se intentó principialmente
	para esos grandes proyectos. Estas metodologías eran muy
	complicadas de usar - la sensación era que se estaba perdiendo
	todo el tiempo escribiendo documentos y no programando. (A
	menudo era así). Espero haberle mostrado aquí sugerencias a
	medio camino - [FIXME: una escala corrediza. Usar una propuesta
	que se ajusta a sus necesidades (y a su personalidad). No
	importa lo pequeño que desee hacerlo,
	<emphasis>cualquier</emphasis> tipo de plan supondrá una gran
	mejora en su proyecto respecto a no planear nada. Recuerde que,
	según la mayoría de las estimaciones, sobre el 50% de proyectos
	fracasan (¡algunas estimaciones superan el 70%!).
      </para>

      <!--
      By following a plan - preferably one that is simple and brief -
      and coming up with design structure before coding, you'll
      discover that things fall together far more easily than if you
      dive in and start hacking, and you'll also realize a great deal
      of satisfaction. It's my experience that coming up with an
      elegant solution is deeply satisfying at an entirely different
      level; it feels closer to art than technology. And elegance always
      pays off; it's not a frivolous pursuit. Not only does it give you
      a program that's easier to build and debug, but it's also easier
      to understand and maintain, and that's where the financial value
      lies.
      -->

      <para>
	Seguir un plan - preferiblemente uno que es simple y breve - y
	esbozar la estructura del diseño antes de empezar a codificar,
	descubrirá que cosas FIXME: together far more fácilmente que si
	se lanza a programar, y también alcanzará un mayor grado de
	satisfacción. Esta es mi experiencia que partiendo de una
	solución elegante es profundamente satisfactorio en un nivel
	completamente diferente; parece más arte que tecnología. Y la
	elegancia siempre vale la pena; no es una búsqueda frívola. No
	sólo le permite tener un programa fácil de construir y depurar,
	pero también es más fácil de comprender y mantener, y ahí es
	donde recae su valor económico.
      </para>

    </sect2>
  </sect1>
    

  <sect1>
    <title>Programación Extrema</title>

    <!--
    I have studied analysis and design techniques, on and off, since I
    was in graduate school. The concept of Extreme Programming (XP) is
    the most radical, and delightful, that I've seen. You can find it
    chronicled in Extreme Programming Explained by Kent Beck
    (Addison-Wesley 2000) and on the Web at www.xprogramming.com.
    -->

    <para>
      He estudiado técnicas de análisis y diseño, por activa y por
      pasiva, desde mis estudios univertarios. El concepto de
      <emphasis>Programación Extrema</emphasis> (XP) es el más radical,
      encantador, que nunca he visto. Puede encontrarlo explicado en
      <citetitle>Extreme Programming Explained</citetitle> de
      <personname> <firstname>Kent</firstname>
      <surname>Beck</surname></personname> (Addison-Wesley 2000) y en la
      web <ulink
      url="http://www.xprogramming.com">www.xprogramming.com</ulink>
    </para>

    <!--
    XP is both a philosophy about programming work and a set of
    guidelines to do it. Some of these guidelines are reflected in other
    recent methodologies, but the two most important and distinct
    contributions, in my opinion, are "write tests first" and "pair
    programming." Although he argues strongly for the whole process,
    Beck points out that if you adopt only these two practices you'll
    greatly improve your productivity and reliability.
    -->

    <para>
      XP es una filosofía sobre trabajo de programación y también un
      conjunto de directrices para ello. Alguna de estas directrices se
      reflejan en otras metodologías recientes, pero las dos
      contribuciones más importantes y destacables, en mi opinión, son
      <quote>escribir primero las pruebas</quote> y la
      <quote>programación en parejas</quote>. Aunque defiende con fuerza
      el proceso entero,
      <personname><surname>Benk</surname></personname> señala que si
      adopta únicamente estas dos prácticas mejorará sensiblemente su
      productividad y fiabilidad.
    </para>

    <sect2>
      <!-- Write tests first -->
      <title>Escriba primero las pruebas</title>

      <!--
      Testing has traditionally been relegated to the last part of a
      project, after you've "gotten everything working, but just to be
      sure." It's implicitly had a low priority, and people who
      specialize in it have not been given a lot of status and have
      often even been cordoned off in a basement, away from the "real
      programmers." Test teams have responded in kind, going so far as
      to wear black clothing and cackling with glee whenever they broke
      something (to be honest, I've had this feeling myself when
      breaking C++ compilers).
      -->

      <para>
	El proceso de prueba ha sido tradicionalmente relegado a la
	parte final del proyecto, después de que <quote>consiga tener
	todo funcionando, pero tiene que estar
	seguro</quote>. Implícitamente ha tenido una prioridad baja, y
	la gente que se especializa en ello nunca ha tenido estatus y
	tiene a menudo siempre ha sido acordonado en un sótano, lejos de
	<quote>los programadores reales</quote>. Los equipos de pruebas
	han respondido en especia, yendo más allá vistiendo trajes
	negros y hablando con regocijo siempre que encontrabas algo
	(para ser honesto, he tenido este mismo sentimiento cuando
	encontraba fallos en los compiladores de C++).
      </para>


      <!--
      XP completely revolutionizes the concept of testing by giving it
      equal (or even greater) priority than the code. In fact, you write
      the tests before you write the code that's being tested, and the
      tests stay with the code forever. The tests must be executed
      successfully every time you do an integration of the project
      (which is often, sometimes more than once a day).
      -->

      <para>
	XP revoluciona completamente el concepto del proceso de prueba
	dándole la misma <quote>o incluso mayor</quote> prioridad que
	al código. De hecho, se escriben las pruebas antes de escribir
	el código que está probando, y las pruebas permanecen con el
	código siempre. Las pruebas deben ser ejecutadas con éxito
	cada vez que hace una integración del proyecto (que es a
	menudo, a veces más de una vez al día).
      </para>

      <!--
      Writing tests first has two extremely important effects.
      -->

      <para>
	Escribir primero las pruebas tiene dos efectos extremadamente
	importantes.
      </para>

      <!--
      First, it forces a clear definition of the interface of a class. I'
      ve often suggested that people "imagine the perfect class to
      solve a particular problem" as a tool when trying to design the
      system. The XP testing strategy goes further than that - it
      specifies exactly what the class must look like, to the consumer
      of that class, and exactly how the class must behave. In no
      uncertain terms. You can write all the prose, or create all the
      diagrams you want describing how a class should behave and what it
      looks like, but nothing is as real as a set of tests. The former
      is a wish list, but the tests are a contract that is enforced by
      the compiler and the running program. It's hard to imagine a more
      concrete description of a class than the tests.
      -->

      <para>
	Primero, fuerza una definición clara de la interfaz de una
	clase. A menudo sugiero que la gente <quote>imagine la clase
	perfecta para resolver un problema particular</quote> como una
	herramienta cuando intenta diseñar el sistema. La estrategia
	del proceso de prueba de XP va más lejos que esto - especifica
	exactamente cual es la clase que debe parecer, para el
	consumidor de esta clase, y exactamente cómo debe portarse la
	clase. En términos no seguros. Debe escribir todo la prosa, o
	crear todos los diagramas donde quiere describir como debe
	portarse una clase y qué debe parecer, pero nada es tan real
	como un conjunto de pruebas. El primero es una lista deseada,
	pero las pruebas son un contrato que se cumple por el
	compilador y el funcionamiento del programa. Es difícil de
	imaginar una descripción más concreta de una clase que las
	pruebas.
      </para>

      <!--
      
      While creating the tests, you are forced to completely think out
      the class and will often discover needed functionality that might
      be missed during the thought experiments of UML diagrams, CRC
      cards, use cases, etc.
      -->

      <para>
	Mientras se crean las pruebas, está completamente forzado a
	elaborar la clase y a menudo descubrirá necesidades de
	funcionalidad que deben ser omitidas durante los experimentos
	planificados de diagramas UML, tarjetas CRC, casos de uso,
	etc.
      </para>

      <!--
      The second important effect of writing the tests first comes
      from running the tests every time you do a build of your
      software. This activity gives you the other half of the testing
      that's performed by the compiler. If you look at the evolution
      of programming languages from this perspective, you'll see that
      the real improvements in the technology have actually revolved
      around testing. Assembly language checked only for syntax, but C
      imposed some semantic restrictions, and these prevented you from
      making certain types of mistakes. OOP languages impose even more
      semantic restrictions, which if you think about it are actually
      forms of testing. "Is this data type being used properly? Is
      this function being called properly?" are the kinds of tests
      that are being performed by the compiler or run-time
      system. We've seen the results of having these tests built into
      the language: people have been able to write more complex
      systems, and get them to work, with much less time and
      effort. I've puzzled over why this is, but now I realize it's
      the tests: you do something wrong, and the safety net of the
      built-in tests tells you there's a problem and points you to
      where it is.   
      -->

      <para>
	El segundo efecto importante de escribir las pruebas primero
	viene desde el funcionamiento de las pruebas cada vez que hace
	una construcción de su software. Esta actividad le da la otra
	parte del proceso de prueba que es intrepretado por el
	compilador. Si mira la evolución de los lenguajes de
	programación desde esta perspectiva, verá que las mejoras
	reales en la tecnología actualmente giran alrededor del
	proceso de prueba. FIXME: Assembly lenguaje revisados sólo por
	sintaxis, pero C impone algunas resctricciones de semántica, y
	éstas le impiden realizar cierto tipo de errores. Los
	lenguajes POO imponen incluso más resticciones de semántica,
	si lo piensa son realmente formas de proceso de
	prueba. <quote>¿Se utilizan apropiadamente este tipo de datos?
	¿Está esta función llamada apropiadamente?</quote> son el tipo
	de pruebas que se llevan a cabo por el compilador en tiempo de
	ejecución del sistema. Se han visto los resultados de tener
	estas pruebas construidas en el lenguaje: la gente ha sido
	capaz de escribir sistemas más complejos, y les han dado
	trabajo, con mucho menos tiempo y esfuerzo. He tratado de
	comprender porqué es así, pero ahora me doy cuenta de que esto
	son las pruebas: hace algo mal, y la red de seguridad de las
	pruebas FIXME:built-in le dicen que hay un problema y le
	indica dónde.
      </para>

      <!--
      But the built-in testing afforded by the design of the language
      can only go so far. At some point, you must step in and add the
      rest of the tests that produce a full suite (in cooperation with
      the compiler and run-time system) that verifies all of your
      program. And, just like having a compiler watching over your
      shoulder, wouldn't you want these tests helping you right from
      the beginning? That's why you write them first, and run them
      automatically with every build of your system. Your tests become
      an extension of the safety net provided by the language.
      -->

      <para>
	Pero FIXME: the built-in testing le permiten por el diseño del
	lenguaje puede solo ir más lejos. En este punto, debe
	intervenir y añadir el resto de las pruebas que producen un
	juego completo (en cooperación con el compiladore y el tiempo
	de ejecución del sistema) que verifica todo su programa. Y,
	tal como tiene un compilador vigilando su hombro, ¿no querría
	que estas pruebas le ayudaran a empezar bien? Esto es porque
	las escribe primero, y las ejecuta automáticamente con cada
	construcción de su sistema. Sus pruebas se convierten en una
	extensión de seguridad de red proporcionada por el lenguaje.
      </para>

      <!--
      One of the things that I've discovered about the use of more and
      more powerful programming languages is that I am emboldened to try
      more brazen experiments, because I know that the language will
      keep me from wasting my time chasing bugs. The XP test scheme does
      the same thing for your entire project. Because you know your
      tests will always catch any problems that you introduce (and you
      regularly add any new tests as you think of them), you can make
      big changes when you need to without worrying that you'll throw
      the whole project into complete disarray. This is incredibly
      powerful.
      -->

      <para>
	Una de las cosas que he descubierto sobre el uso de lenguajes
	de programación cada vez más poderosos es que estoy dispuesto
	a probar más experimentos descarados, porque sé que el
	lenguaje me seguirá haciendo perder el tiempo persiguiendo
	errores. La combinación de pruebas de XP hace lo mismo para
	todo su proyecto. Porque conoce sus pruebas siempre pillará
	algunos problemas que introduzca (y regularmente añade alguna
	nueva prueba como piensa), puede hacer grandes cambios cuando
	necesite sin preocuparse de que arrojará el proyecto entero a
	un completo desorden. Esto es increíblemente poderoso.
      </para>

    </sect2>

    <sect2>
      <!-- Pair programming -->
      <title>Programación en parejas</title>
      
      <!--

      Pair programming goes against the rugged individualism that we've
      been indoctrinated into from the beginning, through school (where
      we succeed or fail on our own, and working with our neighbors is
      considered "cheating") and media, especially Hollywood movies in
      which the hero is usually fighting against mindless
      conformity[19]. Programmers, too, are considered paragons of
      individuality - "cowboy coders" as Larry Constantine likes to
      say. And yet XP, which is itself battling against conventional
      thinking, says that code should be written with two people per
      workstation. And that this should be done in an area with a group
      of workstations, without the barriers that the facilities design
      people are so fond of. In fact, Beck says that the first task of
      converting to XP is to arrive with screwdrivers and Allen wrenches
      and take apart everything that gets in the way.[20] (This will
      require a manager who can deflect the ire of the facilities
      department.)

      [19] Although this may be a more American perspective, the
      stories of Hollywood reach everywhere.

      [20] Including (especially) the PA system. I once worked in a company that
      insisted on broadcasting every phone call that arrived for every
      executive, and it constantly interrupted our productivity (but the
      managers couldn't begin to conceive of stifling such an important
      service as the PA). Finally, when no one was looking I started
      snipping speaker wires.

      -->

      <para>
	Programar en parejas va en contra del duro individualismo en
	el que hemos sido adoctrinados desde el principio, a través de
	la facultad (donde triunfábamos o fracasábamos por nosotros
	mismos, y trabajar con nuestros vecinos se consideraba
	<quote>engañoso</quote>) y medios de comunicación,
	especialmente las películas de Hollywood donde el héroe es
	habitualmente FIXME: fighting against mindless
	conformity. <footnote>
	  <para>
	    Aunque esto puede ser una perspectiva americana, las
	    historias de Hollywood llegan a todas partes.
	  </para>
	</footnote>. Los programadores, también, se consideran
	dechados de individualismo -<quote>cowboy FIXME:
	coders</quote> como <personname> <firstname>Larry</firstname>
	<surname>Constantine</surname></personname> suele
	decir. Aunque XP, el cual es él mismo una batalla contra el
	pensamiento convecional, dice que el código suele ser escrito
	por dos personas por estaciones de trabajo. Y esto puede ser
	hecho en una área con un grupo de estaciones de trabajo, sin
	las barreras que las facilidades de diseño a las que la gente
	le tiene tanto cariño. De hecho,
	<personname><firstname>Beck</firstname></personname> dice que
	la primera tarea de convertir a XP es llegar con
	destornilladores y
	<personname><firstname>Allen</firstname></personname> arranca
	y desmonta todo lo que encuentra en su camino. <footnote>
	  <para>
	    Incluyendo (especialmente) el sistema PA. Una vez trabajé
	    en una compañía que exigía transmisión en cada llamada de
	    teléfono que llegaba para cada ejecutivo, y constantemente
	    interrumpía nuestra productividad (pero los directores no
	    pudieron empezar a concebir el agobio como un servicio
	    importante de PA). Finalmente, cuando ninguno estaba
	    mirando empecé a cortar los cables de los hablantes.
	  </para>
	</footnote>. (Esto puede requerir un director que pueda
	desviar la ira de FIXME: facilities department).
      </para>

      <!--
      The value of pair programming is that one person is actually doing
      the coding while the other is thinking about it. The thinker
      keeps the big picture in mind, not only the picture of the
      problem at hand, but the guidelines of XP. If two people are
      working, it's less likely that one of them will get away with
      saying, "I don't want to write the tests first," for
      example. And if the coder gets stuck, they can swap places. If
      both of them get stuck, their musings may be overheard by
      someone else in the work area who can contribute. Working in
      pairs keeps things flowing and on track. Probably more
      important, it makes programming a lot more social and fun.
      -->

      <para>
	El valor de la programación en parejas es que una persona está
	realmente haciendo el código mientras la otra está pensando
	cómo. El pensador guarda la gran imagen en su mente, no sólo
	la imagen del problema a mano, sino también las pautas de
	XP. Si dos personas están trabajando, es menos probable que
	uno de ellos salga diciendo, <quote>No quiero escribir las
	primeras pruebas</quote>, por ejemplo. Y si el programador se
	atasca, pueden cambiar los papeles. Si ambos se atascan, sus
	pensamientos pueden ser FIXME: overheard por otro en el área
	de trabajo que puede contribuir. Trabajar en parejas mantiene
	cosas circulando y en la pista. Probablemente más importante,
	hace la programación mucho más social y divertida.
      </para>

      <!--
      I've begun using pair programming during the exercise periods in
      some of my seminars and it seems to significantly improve everyone'
      s experience.
      -->

      <para>
	He empezado a usar programación en parejas durante los
	periodos de ejercicio en algunos de mis seminarios y parece
	mejorar considerablemente la experiencia de todo el mundo.
      </para>

    </sect2>
  </sect1>

  <sect1>
    <title>Porqué triunfa C++</title>

    <!--

    Part of the reason C++ has been so successful is that the goal was
    not just to turn C into an OOP language (although it started that
    way), but also to solve many other problems facing developers
    today, especially those who have large investments in
    C. Traditionally, OOP languages have suffered from the attitude
    that you should abandon everything you know and start from scratch
    with a new set of concepts and a new syntax, arguing that it's
    better in the long run to lose all the old baggage that comes with
    procedural languages. This may be true, in the long run. But in
    the short run, a lot of that baggage was valuable. The most
    valuable elements may not be the existing code base (which, given
    adequate tools, could be translated), but instead the existing
    mind base. If you're a functioning C programmer and must drop
    everything you know about C in order to adopt a new language, you
    immediately become much less productive for many months, until
    your mind fits around the new paradigm. Whereas if you can
    leverage off of your existing C knowledge and expand on it, you
    can continue to be productive with what you already know while
    moving into the world of object-oriented programming.As everyone
    has his or her own mental model of programming, this move is messy
    enough as it is without the added expense of starting with a new
    language model from square one. So the reason for the success of
    C++, in a nutshell, is economic: It still costs to move to OOP,
    but C++ may cost less[21].

    [21] I say "may" because, due to the complexity of C++, it might
    actually be cheaper to move to Java. But the decision of which
    language to choose has many factors, and in this book I'll assume
    that you've chosen C++.


    -->

    <para>
      Parte de la razón por la que C++ ha sido tan exitoso es que la
      meta no era precisamente convertir C en un lenguaje de POO
      (aunque comenzó este camino), pero también resolver muchos otros
      problemas orientado a los desarrolladores hoy en día,
      especialmente aquellos que tienen grandes inversiones en
      C. Tradicionalmente, los lenguajes de POO han sufrido de la
      actitud que debería abandonar todo lo que sabe y empezar desde
      cero, con un nuevo conjunto de conceptos y una nueva sintaxis,
      argumentando que es mejor en la larga carrera para perder todo
      el viejo equipaje que viene con los lenguajes
      procedurales. Puede ser cierto, en la larga carrera. Pero en la
      carrera corta, mucho de este equipaje era valioso. Los elementos
      más valiosos podían no estar en el código base existente (el
      cual, daba suficientes herramientas, podría ser traducido), pero
      en cambio la <emphasis>opinión base</emphasis> existente. Si es
      una programador funcional de C y tiene que dejar todo lo que
      sabe sobre C para adoptar un nuevo lenguaje, inmediatamente se
      convierte en mucho menos productivo por muchos meses, hasta que
      su mente su ajuste cerca del nuevo paradigma. Mientras que si
      puede hacer palanca sobre su actual conocimiento de C y
      ampliarlo, puede continuar siendo productivo con lo que
      realmente sabe mientras se pasa al mundo de la programación
      orientada a objetos. Como todo el mundo tiene su propio modelo
      mental de la programación, este cambio es bastante desordenado
      como es sin el gasto añadido de volver a empezar con un nuevo
      modelo de lenguaje. Así la razón del éxito de C++, en dos
      palabras, es económico: todavía cuesta cambiarse a la POO, pero
      C++ puede costar menos <footnote>
	  <para>
	  Dije <quote>puede</quote> porque, debido a la complejidad de
	  C++, realmente podría ser más económico cambiarse a
	  Java. Pero la decisión de qué lenguaje elegir tiene muchos
	  factores, y en este libro asumiré que ha elegido C++.
	  </para>
	</footnote>.
    </para>
    
    <!--
    The goal of C++ is improved productivity. This productivity comes in
    many ways, but the language is designed to aid you as much as
    possible, while hindering you as little as possible with arbitrary
    rules or any requirement that you use a particular set of
    features. C++ is designed to be practical; C++ language design
    decisions were based on providing the maximum benefits to the
    programmer (at least, from the world view of C).
    -->

    <para>
      La meta de C++ es mejorar la productividad. Ésta viene por
    muchos caminos, pero el lenguaje está diseñado para ayudarle lo
    más posible, mientras dificultarle tan poco como sea posible con
    reglas arbitrarias o algún requerimiento que use un conjunto
    particular de características. C++ está diseñado para ser
    práctico; las decisiones de diseño del lenguaje C++ estaban
    basadas en proveer los beneficios máximos al programador (por lo
    menos, de la visión del mundo de C).
    </para>

    <sect2>
      <!-- A better C -->
      <title>Un C mejor</title>

      <!--
      You get an instant win even if you continue to write C code
      because C++ has closed many holes in the C language and provides
      better type checking and compile-time analysis. You're forced to
      declare functions so that the compiler can check their use. The
      need for the preprocessor has virtually been eliminated for value
      substitution and macros, which removes a set of difficult-to-find
      bugs. C++ has a feature called references that allows more
      convenient handling of addresses for function arguments and return
      values. The handling of names is improved through a feature called
      function overloading, which allows you to use the same name for
      different functions. A feature called namespaces also improves the
      control of names. There are numerous smaller features that improve
      the safety of C.
      -->

      <para>
	Consigue un instante de victoria incluso si continua
	escribiendo código C porque C++ ha cerrado muchos agujeros en
	el lenguaje C y provee mejor tipo de control y análisis de
	tiempo de compilación. Está obligado a declarar funciones que
	el compilador puede controlar su uso. La necesidad del
	preprocesador ha sido prácticamente eliminada por sustitución
	de valor y macros, los cuales eliminan un conjunto de
	dificultades de encontrar errores. C++ tiene un característica
	llamada <emphasis>referencias</emphasis> que permite más
	manejos convenientes de direcciones para argumentos de
	funciones y devuelve valores. El manejo de nombres se mejora a
	través de una característica llamada <emphasis>sobrecarga de
	función</emphasis>, el cual le permite usar el mismo nombre
	para diferentes funciones. Una característica llamada
	FIXME <emphasis>namespaces</emphasis> también mejora la
	seguridad de C.
      </para>

    </sect2>
    <sect2>
      <!-- You're already on the learning curve -->
      <title>Usted ya está en la curva de aprendizaje</title>

      <!--
      The problem with learning a new language is productivity. No
      company can afford to suddenly lose a productive software engineer
      because he or she is learning a new language. C++ is an extension
      to C, not a complete new syntax and programming model. It allows
      you to continue creating useful code, applying the features
      gradually as you learn and understand them. This may be one of the
      most important reasons for the success of C++.
      -->

      <para>
	El problema con el aprendizaje de un nuevo lenguaje es la
	productividad. Ninguna empresa puede permitirse de repente
	perder un ingeniero de software productivo porque está
	aprendiendo un nuevo lenguaje. C++ es una extensión de C++, no
	una sintaxis nueva completa y modelo de programación. Le
	permite continuar creando código útil, usando las
	características gradualmente según va aprendiendo y
	entendiéndolas. Esto puede ser uno de las más importantes
	razones del éxito de C++.
      </para>

      <!--
      In addition, all of your existing C code is still viable in C++,
      but because the C++ compiler is pickier, you'll often find hidden
      C errors when recompiling the code in C++.
      -->

      <para>
	Además, todo su código C existente es todavía viable en C++,
	pero porque el compilador de C++ es más delicado, a menudo
	encontrará errores ocultos de C cuando recompile un código en
	C++.
      </para>
    </sect2>


    <sect2>
      <!-- Efficiency -->
      <title>Eficiencia</title>

      <!--
      Sometimes it is appropriate to trade execution speed for
      programmer productivity. A financial model, for example, may be
      useful for only a short period of time, so it's more important to
      create the model rapidly than to execute it rapidly. However, most
      applications require some degree of efficiency, so C++ always errs
      on the side of greater efficiency. Because C programmers tend to
      be very efficiency-conscious, this is also a way to ensure that
      they won't be able to argue that the language is too fat and
      slow. A number of features in C++ are intended to allow you to
      tune for performance when the generated code isn't efficient
      enough.
      -->

      <para>
	A veces es apropiado intercambiar velocidad de ejecución por
	productividad de programación. Un modelo económico, por
	ejemplo, puede ser útil sólo por un periodo corto de tiempo,
	pero es más importante crear el modelo rápidamente. No
	obstante, la mayoría de las aplicaciones requieren algún grado
	de eficiencia, de modo que C++ siempre yerra a parte de la más
	grande eficiencia. Porque los programadores de C tienden a ser
	muy conscientes de su eficiencia, es además un camino para
	asegurar que no serán capaces de exponer que el lenguaje es
	también gordo y lento. Un número de características en C++
	intentan permitirle afinar para la ejecución cuando el código
	generado no es lo bastante eficiente.
      </para>

      <!--
      Not only do you have the same low-level control as in C (and the
      ability to directly write assembly language within a C++ program),
      but anecdotal evidence suggests that the program speed for an
      object-oriented C++ program tends to be within ±10% of a program
      written in C, and often much closer[22]. The design produced for
      an OOP program may actually be more efficient than the C
      counterpart.

      [22] However, look at Dan Saks' columns in the C/C++ User's
      Journal for some important investigations into C++ library
      performance.

      -->

      <para>
	No sólo se puede conseguir el mismo bajo nivel de C (y la
	capacidad de escribir directamente lenguaje ensamblador dentro
	de un programa C++), además la experiencia práctica sugiere que
	la velocidad para un programa C++ orientado a objetos tiende
	a ser FIXME +-10% de un programa escrito en C, y a menudo mucho menos 
	<footnote>
	  <para>
	    Sin embargo, mire en las columnas de
	    <personname><firstname>Dan</firstname>
	    <surname>Saks</surname></personname> en <citetitle>C/C++
	    User's Journal</citetitle> para algunas investigaciones
	    importantes en rendimiento de librerías de C++.
	  </para>
	</footnote>. El diseño producido por un programa POO puede ser
	realmente más eficiente que el homólogo en C.
      </para>
    </sect2>

    <sect2>
      <!-- Systems are easier to express and understand -->
      <title>Los sistemas son más fáciles de expresar y entender</title>

      <!--
      Classes designed to fit the problem tend to express it
      better. This means that when you write the code, you're
      describing your solution in the terms of the problem space ("Put
      the grommet in the bin") rather than the terms of the computer,
      which is the solution space ("Set the bit in the chip that means
      that the relay will close"). You deal with higher-level concepts
      and can do much more with a single line of code.
      -->

      <para>
	Las clases diseñadas para ajustar el problema tienden a
	expresarlo mejor. Esto significa que cuando escribe el código,
	está describiendo su solución en los términos del espacio del
	problema (<quote>Ponga el plástico en el cubo</quote>) mejor que
	en los términos de la computadora, los cuales están en el
	espacio de la solución (<quote>Active el bit para cerrar el relé
	</quote>). Usted maneja conceptos de alto nivel y puede hacer
	mucho más con una única línea de código.
      </para>

      <!--
      The other benefit of this ease of expression is maintenance, which
      (if reports can be believed) takes a huge portion of the cost over
      a program's lifetime. If a program is easier to understand, then
      it's easier to maintain. This can also reduce the cost of
      creating and maintaining the documentation.
      -->

      <para>
	El otro beneficio de esta facilidad de expresión es el
	mantenimiento, el cual (si informa puede ser creíble) toma una
	enorme porción del coste sobre el tiempo de vida del
	programa. Si un programa es más fácil de entender, entonces es
	más fácil de mantener. También puede reducir el coste de crear y
	mantener la documentación.
      </para>
    </sect2>

    <sect2>
      <!-- Maximal leverage with libraries -->
      <title>FIXME:Máximizar el rendimiento gracias a las librerías</title>

      <!--
      The fastest way to create a program is to use code that's already
      written: a library. A major goal in C++ is to make library use
      easier. This is accomplished by casting libraries into new data
      types (classes), so that bringing in a library means adding new
      types to the language. Because the C++ compiler takes care of how
      the library is used - guaranteeing proper initialization and
      cleanup, and ensuring that functions are called properly - you can
      focus on what you want the library to do, not how you have to do
      it.
      -->

      <para>
	El camino más rápido para crear un programa es usar código que
	ya está escrito: una librería. Un objetivo mayor en C++ es hacer
	más sencillo el uso de las librerías. Esto se consigue viendo
	las librerías como nuevos tipos de datos (clases), así que crear
	librerías significa añadir nuevos tipos al lenguaje. Como el
	compilador C++ se preocupa de cómo se usa la librería -
	garantizando una inicialización y limpieza apropiadas, y
	asegurando que las funciones se llaman apropiadamente - puede
	centrarse en lo qué hace la librería, no en cómo tiene que
	hacerlo.
      </para>

      <!--
      Because names can be sequestered to portions of your program via
      C++ namespaces, you can use as many libraries as you want without
      the kinds of name clashes you'd run into with C.
      -->

      <para>
	Como los nombres están jerarquizados en las partes de su
	programa por medio de los espacios de nombres de C++, puede usar
	tantas librerías como quiera sin los conflictos de nombres
	típicos de C.
      </para>

    </sect2>

    <sect2>
      <!-- Source-code reuse with templates -->
      <title>Reutilización de código fuente con plantillas</title>

      <!--
      There is a significant class of types that require source-code
      modification in order to reuse them effectively. The template
      feature in C++ performs the source code modification
      automatically, making it an especially powerful tool for reusing
      library code. A type that you design using templates will work
      effortlessly with many other types. Templates are especially nice
      because they hide the complexity of this kind of code reuse from
      the client programmer.
      -->

      <para>
	Hay una categoría importante de tipos que requiere
	modificaciones del código fuente para lograr una reutilización
	efectiva. La plantilla C++ lleva a cabo la modificación del
	código fuente automáticamente, conviertiéndola en una
	herramienta especialmente potente para la reutilización del
	código de las librerías. Si se diseña un tipo usando plantillas
	funcionará fácilmente con muchos otros tipos. Las plantillas son
	especialmente interesantes porque ocultan al programador cliente
	la complejidad de esta forma de reutilizar código.
      </para>
    </sect2>


    <sect2>
      <!-- Error handling -->
      <title>Manejo de errores</title>

      <!--
      Error handling in C is a notorious problem, and one that is often
      ignored - finger-crossing is usually involved. If you're building
      a large, complex program, there's nothing worse than having an
      error buried somewhere with no clue as to where it came from. C++
      exception handling (introduced in this Volume, and fully covered
      in Volume 2, which is downloadable from www.BruceEckel.com) is a
      way to guarantee that an error is noticed and that something
      happens as a result.
      -->

      <para>
	La gestión de errores en C es un problema muy conocido, y a
	menudo ignorado - cruzando los dedos. Si está construyendo un
	programa complejo y grande, no hay nada peor que tener un error
	enterrado en cualquier lugar sin la menor idea de cómo llegó
	allí. La gestión de excepciones de C (introducida en este
	Volumen, y completamente explicada en el Volumen 2, el cual es
	descargable desde <ulink
	url="www.bruceeckel.com">www.BruceEckel.com</ulink>) es un
	camino para garantizar que un error se notifica y que algo
	ocurre como resultado.
      </para>

    </sect2>

    <sect2>
      <!-- Programming in the large -->
      <title>Programar a lo grande </title>

      <!--
      Many traditional languages have built-in limitations to program
      size and complexity. BASIC, for example, can be great for pulling
      together quick solutions for certain classes of problems, but if
      the program gets more than a few pages long or ventures out of the
      normal problem domain of that language, it's like trying to swim
      through an ever-more viscous fluid. C, too, has these
      limitations. For example, when a program gets beyond perhaps
      50,000 lines of code, name collisions start to become a problem -
      effectively, you run out of function and variable names. Another
      particularly bad problem is the little holes in the C language -
      errors buried in a large program can be extremely difficult to
      find.
      -->

      <para>
	Muchos lenguajes tradicionales tienen limitaciones propias para
	hacer programas grandes y complejos. BASIC, por ejemplo, puede
	valer para solucionar ciertas clases de problemas rápidamente,
	pero si el programa tiene más de unas cuantas páginas de largo o
	se sale del dominio de problemas de ese lenguaje, es como
	intentar nadar a través de un fluido aún más viscoso. C,
	también, tiene estas limitaciones. Por ejemplo, cuando un
	programa tiene más allá quizá de 50.000 líneas de código, las
	choques de nombres empiezan a ser un problema - efectivamente,
	se queda sin nombres de funciones o variables. Otro problema
	particularmente malo son los pequeños agujeros en el lenguaje C
	- errores enterrados en un programa grande pueden ser
	extremadamente difíciles de encontrar.
      </para>

      <!--
      There's no clear line that tells you when your language is
      failing you, and even if there were, you'd ignore it. You don't
      say, "My BASIC program just got too big; I'll have to rewrite it
      in C!" Instead, you try to shoehorn a few more lines in to add
      that one new feature. So the extra costs come creeping up on you.
      -->

      <para>
	No hay una línea de código clara que diga cuando está fallando
	su lenguaje, e incluso si la hay, debería ignorarla. No diga:
	<quote>Mi programa BASIC se ha hecho demasiado grande; ¡lo tendré
	que reescribir en C!</quote> En su lugar, intente calzar unas
	cuantas líneas más para añadirle una nueva característica. De
	ese modo, el coste extra lo decide de usted.
      </para>
      
      <!--
      C++ is designed to aid programming in the large, that is, to erase
      those creeping-complexity boundaries between a small program and a
      large one. You certainly don't need to use OOP, templates,
      namespaces, and exception handling when you're writing a
      hello-world style utility program, but those features are there
      when you need them. And the compiler is aggressive about ferreting
      out bug-producing errors for small and large programs alike.
      -->

      <para>
	C++ está diseñado para ayudarle a <emphasis>programar a lo
	grande</emphasis>, es decir, eliminar las diferencias de
	complejidad entre un programa pequeño y uno grande. Ciertamente
	no necesita usar POO, plantillas, espacio de nombres, y
	manejador de excepciones cuando esté escribiendo un programa
	tipo <quote>hola mundo</quote>, pero estas prestaciones están
	ahí cuando las necesita. Y el compilador es agresivo en la
	detección de errores tanto para programas pequeños como grandes.
      </para>

    </sect2>

  </sect1>

  <sect1>
    <title>Estrategias de transición</title>

    <!--
    If you buy into OOP, your next question is probably, "How can I
    get my manager/colleagues/department/peers to start using
    objects?"  Think about how you - one independent programmer -
    would go about learning to use a new language and a new
    programming paradigm. You' ve done it before. First comes
    education and examples; then comes a trial project to give you a
    feel for the basics without doing anything too confusing. Then
    comes a "real world" project that actually does something
    useful. Throughout your first projects you continue your education
    by reading, asking questions of experts, and trading hints with
    friends. This is the approach many experienced programmers suggest
    for the switch from C to C++. Switching an entire company will of
    course introduce certain group dynamics, but it will help at each
    step to remember how one person would do it.
    -->
    
    <para>
      Si acepta la POO, su próxima pregunta seguramente será:
      <quote>¿Cómo puedo hacer que mi jefe, mis colegas, mi
      departamento, mis compañeros empiecen a utilizar
      objetos?</quote> Piense sobre cómo usted - un programador
      independiente - puede ir aprendiendo a usar un nuevo lenguaje y
      un nuevo paradigma de programación. Ya lo ha hecho
      antes. Primero viene la educación y los ejemplos; entonces llega
      un proyecto problemático que le da una sensación por los básicos
      sin hacer cualquier cosa demasiado confuso. Entonces llega un
      proyecto del <quote>mundo real</quote> que realmente hace algo
      útil. Durante todos sus primeros proyectos continúa su educación
      leyendo, preguntando a expertos, e intercambiando consejos con
      amigos. Este es el acercamiento que sugieren muchos
      programadores experimentados para el cambio de C a C++. Por
      supuesto, cambiar una compañía entera introduce grupos dinámicos
      seguros, lo que puede ayudar en otro paso a recordar cómo una
      persona lo podría hacer.
    </para>

    <sect2>
      <!-- Guidelines -->
      <title>Directrices</title>

      <!--
      Here are some guidelines to consider when making the transition to
      OOP and C++:
      -->

      <para>
	Aquí hay algunas pautas a considerar cuando se hace la
	transición de POO y C++:
      </para>


      <sect3>
	<!-- Training -->
	<title>Entrenamiento</title>
	
	<!--
	The first step is some form of education. Remember the company'
	s investment in plain C code, and try not to throw everything
	into disarray for six to nine months while everyone puzzles over
	how multiple inheritance works. Pick a small group for
	indoctrination, preferably one composed of people who are
	curious, work well together, and can function as their own
	support network while they're learning C++.
	-->

	<para>
	  El primer paso es algún tipo de educación. Recuerde que la
	  inversión de la compañía es código C claro, e intentar no
	  tenerlo todo desorganizado durante seis o nueve meses
	  mientras todo el mundo da vueltas sobre cómo trabajar con
	  herencia múltiple. Elija un pequeño grupo para formarlo,
	  preferiblemente uno compuesto de gente que sea curiosa,
	  trabaje bien junta, y pueda funcionar a parte del soporte de
	  red mientras están aprendiendo C++.
	</para>

	<!--
	An alternative approach that is sometimes suggested is the
	education of all company levels at once, including overview
	courses for strategic managers as well as design and programming
	courses for project builders. This is especially good for
	smaller companies making fundamental shifts in the way they do
	things, or at the division level of larger companies. Because
	the cost is higher, however, some may choose to start with
	project-level training, do a pilot project (possibly with an
	outside mentor), and let the project team become the teachers
	for the rest of the company.
	-->

	<para>
	  Una alternativa abordada que se sugiere a veces es la
	  educación a todos los niveles de la compañía a la vez,
	  incluyendo una visión general de los cursos para gerentes
	  estratégicos es tan bueno como cursos de diseño y
	  programación para trabajadores de proyectos. Es
	  especialmente bueno para compañías más pequeñas al hacer
	  cambios fundamentales en el camino en el que hacen cosas, o
	  en la división de niveles de compañías más grandes. Como el
	  coste es mayor, sin embargo, algo puede cambiar al empezar
	  con entrenamiento de nivel de proyecto, hacer un proyecto
	  piloto (posiblemente con un mentor fuera), y dejar que el
	  equipo de trabajo se convierta en los profesores para el
	  resto de la compañía.
	</para>


      </sect3>

      <sect3>
	<!-- Low-risk project -->
	<title>Proyectos de bajo riesgo</title>

	<!--
	Try a low-risk project first and allow for mistakes. Once you'
	ve gained some experience, you can either seed other projects
	from members of this first team or use the team members as an
	OOP technical support staff. This first project may not work
	right the first time, so it should not be mission-critical for
	the company. It should be simple, self-contained, and
	instructive; this means that it should involve creating classes
	that will be meaningful to the other programmers in the company
	when they get their turn to learn C++.
	-->

	<para>
	  Intentar un bajo riesgo en el primer proyecto y permitir
	  errores. Una vez que adquiera alguna experiencia, puede
	  FIXME: seed cualquier otro proyecto con miembros del primer
	  equipo o usar los miembros del equipo como una plantillo de
	  soporte técnico de POO. Este primer proyecto puede que no
	  funcione bien la primera vez, pero no suele ser una tarea
	  crítica para la compañía. Suele ser simple, contenerse
	  asímismo, e instructivo; esto significa que suele implicar
	  la creación de clases que serán significativas para otros
	  programadores en la compañía cuando les llegue el turno de
	  aprender C++.
	</para>

      </sect3>

      <sect3>
	<!-- Model from success -->
	<title>Modelar desde el éxito</title>

	<!--
	Seek out examples of good object-oriented design before starting
	from scratch. There's a good probability that someone has
	solved your problem already, and if they haven't solved it
	exactly you can probably apply what you've learned about
	abstraction to modify an existing design to fit your needs. This
	is the general concept of design patterns, covered in Volume 2.
	-->

	<para>
	  Buscar ejemplos de un buen diseño orientado a objetos antes
	  de partir de cero. Hay una buena probabilidad de que alguien
	  ya haya resuelto su problema, y si ellos no lo han resuelto
	  exactamente probablemente puede aplicar lo que ha aprendido
	  sobre abstracción para modificar un diseño existente para
	  adecuar sus necesidades. Este es concepto general de los
	  patrones de diseño, visto en el Volumen 2.
	</para>

      </sect3>

      <sect3>
	<!-- Use existing class libraries -->
	<title>Use librerías de clases existentes</title>

	<!--
	The primary economic motivation for switching to OOP is the
	easy use of existing code in the form of class libraries (in
	particular, the Standard C++ libraries, which are covered in
	depth in Volume two of this book). The shortest application
	development cycle will result when you don't have to write
	anything but main( ), creating and using objects from
	off-the-shelf libraries. However, some new programmers don't
	understand this, are unaware of existing class libraries, or,
	through fascination with the language, desire to write classes
	that may already exist. Your success with OOP and C++ will be
	optimized if you make an effort to seek out and reuse other
	people's code early in the transition process.
	-->

	<para>
	  La primera motivación económica para cambiar a POO es el
	  fácil uso de código existente en la forma de librerías de
	  clases (en particular, las librerías Standard de C++,
	  explicadas en profundidad en el Volumen dos de este
	  libro). El ciclo de desarrollo de aplicación más corto
	  resultará cuando no tenga que escribir cualquier cosa menos
	  <function>main()</function>, creando y usando objetos de las
	  librerías de fábrica. No obstante, algunos programadores
	  nuevos no lo entienden, no son conscientes de la existencia
	  de librerías de clases, o, a través de la fascinación con el
	  lenguaje, desear escribir clases que ya existen
	  realmente. Su éxito con POO y C++ se optimizará si hace un
	  esfuerzo por buscar y reutilizar código de otras personas al
	  principio del proceso de transición.
	</para>

      </sect3>

      <sect3>
	<!-- Don't rewrite existing code in C++ -->
	<title>No reescriba en C++ código que ya existe</title>

	<!--
	Although compiling your C code with a C++ compiler usually
	produces (sometimes tremendous) benefits by finding problems in
	the old code, it is not usually the best use of your time to
	take existing, functional code and rewrite it in C++. (If you
	must turn it into objects, you can "wrap" the C code in C++
	classes.) There are incremental benefits, especially if the code
	is slated for reuse. But chances are you aren't going to see
	the dramatic increases in productivity that you hope for in your
	first few projects unless that project is a new one. C++ and OOP
	shine best when taking a project from concept to reality.
	-->

	<para>
	  Aunque compilar su código C con un compilador de C++
	  usualmente produce (de vez en cuando tremendos) beneficios
	  encontrando problemas en el viejo código, normalmente no es
	  el mejor uso de su tiempo para coger código funcional
	  existente y reescribirlo en C++. (Si tiene que darle la
	  vuelta a objetos, puede <quote>envolver</quote> el código C
	  en clases C++). Hay un incremento de los beneficios,
	  especialmente si el código es criticado por
	  reutilizarlo. Pero los cambios no le van a hacer ver los
	  espectaculares incrementos en productividad que espera para
	  sus primeros proyectos a menos que ese proyecto sea uno
	  nuevo. C++ y la POO destacan más cuando se hace un proyecto
	  desde un concepto de realidad.
	</para>

      </sect3>
    </sect2>


    <sect2>
      <!-- Management obstacles -->
      <title>Obstáculos de la gestión</title>
      
      <!--
      If you're a manager, your job is to acquire resources for your
      team, to overcome barriers to your team's success, and in general
      to try to provide the most productive and enjoyable environment so
      your team is most likely to perform those miracles that are always
      being asked of you. Moving to C++ falls in all three of these
      categories, and it would be wonderful if it didn't cost you
      anything as well. Although moving to C++ may be cheaper -
      depending on your constraints[23] - than the OOP alternatives for
      a team of C programmers (and probably for programmers in other
      procedural languages), it isn't free, and there are obstacles you
      should be aware of before trying to sell the move to C++ within
      your company and embarking on the move itself.

      [23] Because of its productivity improvements, the Java language
      should also be considered here.
      -->

      <para>
	Si es gerente, su trabajo está adquiriendo recursos para su
	equipo, para superar las barreras del éxito de su equipo, y en
	general para intentar proporcionar el entorno más productivo y
	agradable así su equipo es más probable que interprete estos
	milagros que se pregunta siempre. Cambiar a C++ cae en tres de
	estas categorías, y puede ser maravilloso si no le costó
	demasiado. Aunque cambiar a C++ puede ser más económico -
	dependiendo de sus restricciones 
	<footnote>
	  <para>
	    A causa de la mejora de su productividad, el lenguaje JAVA
	    también suele considerarse.
	  </para>
	</footnote> - como las alternativas de la POO para un equipo
	de programadores de C (y probablemente para programadores en
	otros lenguajes procedurales), no es gratis, y hay obstáculos
	que debería conocer antes de intentar comunicar el cambio a
	C++ dentro de su compañía y embarcarse en el cambio así xmismo.
      </para>

      <sect3>
	<!-- Startup costs -->
	<title>Costes iniciales</title>

	<!--
	The cost of moving to C++ is more than just the acquisition of
	C++ compilers (the GNU C++ compiler, one of the very best, is
	free). Your medium- and long-term costs will be minimized if
	you invest in training (and possibly mentoring for your first
	project) and also if you identify and purchase class libraries
	that solve your problem rather than trying to build those
	libraries yourself. These are hard-money costs that must be
	factored into a realistic proposal. In addition, there are the
	hidden costs in loss of productivity while learning a new
	language and possibly a new programming environment. Training
	and mentoring can certainly minimize these, but team members
	must overcome their own struggles to understand the new
	technology. During this process they will make more mistakes
	(this is a feature, because acknowledged mistakes are the
	fastest path to learning) and be less productive. Even then,
	with some types of programming problems, the right classes,
	and the right development environment, it's possible to be
	more productive while you're learning C++ (even considering
	that you' re making more mistakes and writing fewer lines of
	code per day) than if you'd stayed with C.
	-->

	<para>
	  El coste del cambio a C++ es más que solamente la
	  adquisición de compiladores C++ (el compilador GNU de C++,
	  uno de los mejores, es libre). Sus costes a medio y largo
	  plazo se minimizarán si invierte en formación (y
	  posiblemente un mentor para su primer proyecto) y también si
	  identifica y compra librerías de clases que resuelven su
	  problema más que intentar construir las librerías usted
	  mismo. Es un coste en moneda extranjeta que puede ser
	  propuesto en un proyecto realista. Además, están los costes
	  ocultos en pérdidas de productividad mientras se aprende un
	  nuevo lenguaje y posiblemente un nuevo entorno de
	  programación. Formar y orientar puede ciertamente
	  minimizarlo, pero los miembros del equipo deben superar sus
	  propias peleas para entender la nueva tecnología. A lo largo
	  del proceso pueden cometer más errores (esto es una
	  característica, porque los errores reconocidos son la ruta
	  más rápida para aprender) y ser menos productivos. Incluso
	  entonces, con algunos tipos de problemas de programación, es
	  posible ser más productivo mientras se está aprendiendo C++
	  (incluso considerando que está cometiendo más errores y
	  escribiendo menos líneas de código por día) como si
	  estuviera trabajando con C.
	</para>
      </sect3>

      <sect3>
	<!-- Performance issues -->
	<title>Cuestiones de rendimiento</title>

	<!--
	A common question is, "Doesn't OOP automatically make my
	programs a lot bigger and slower?" The answer is, "It
	depends." Most traditional OOP languages were designed with
	experimentation and rapid prototyping in mind rather than
	lean-and-mean operation. Thus, they virtually guaranteed a
	significant increase in size and decrease in speed. C++,
	however, is designed with production programming in mind. When
	your focus is on rapid prototyping, you can throw together
	components as fast as possible while ignoring efficiency
	issues. If you're using any third party libraries, these are
	usually already optimized by their vendors; in any case it's
	not an issue while you're in rapid-development mode. When you
	have a system that you like, if it's small and fast enough,
	then you're done. If not, you begin tuning with a profiling
	tool, looking first for speedups that can be done with simple
	applications of built-in C++ features. If that doesn't help,
	you look for modifications that can be made in the underlying
	implementation so no code that uses a particular class needs
	to be changed. Only if nothing else solves the problem do you
	need to change the design. The fact that performance is so
	critical in that portion of the design is an indicator that it
	must be part of the primary design criteria. You have the
	benefit of finding this out early using rapid development.
	-->

	<para>
	  Una pregunta común es, <quote>¿La POO no hace
	  automáticamente mis programas mucho más grandes y
	  lentos</quote> La respuesta es: <quote>Depende</quote>. Los
	  lenguajes de POO más tradicionales se diseñaron con
	  experimentación y prototipado rápido en la mente más que
	  operaciones magras y excelentes. De esta manera,
	  prácticamente garantiza un incremento significativo en
	  tamaño y una disminución en velocidad. C++ sin ambargo, está
	  diseñado teniendo presente la producción de
	  programación. Cuando su foco es un prototipado rápido, puede
	  lanzar componente juntos tan rápido como sea posible
	  mientras ignora la eficiencia de la cuestión. Si está usando
	  una tercera parte de las librerías, normalmente ya están
	  optimizadas por sus vendedores; en cualquier caso no es una
	  cuestión mientras está en un modo de desarrollo
	  rápido. Cuando tenga el sistema que quiera, si es bastante
	  pequeño y rápido, entonces ya está hecho. Si no, irá a tono
	  con una herramienta perfilada, mire primero los avances que
	  puede haber hecho con aplicaciones simples de
	  características de C++ empotradas. Si esto no le ayuda, mire
	  las modificaciones que pueden ser hechas en la
	  implementación subyancente así que no es necesario cambiar
	  ningún código que utilice una clase particular. Sólo si nada
	  más soluciona el problema necesita cambiar el diseño. El
	  hecho de que esta realización sea tan crítica en esta
	  porción del diseño es un indicador de que debe ser parte del
	  criterio del diseño primario. Tiene el beneficio de
	  descubrirlo antes de usar un desarrollo rápido.
	</para>


	<!--
	As mentioned earlier, the number that is most often given for
	the difference in size and speed between C and C++ is ±10%, and
	often much closer to par. You might even get a significant
	improvement in size and speed when using C++ rather than C
	because the design you make for C++ could be quite different
	from the one you'd make for C.
	-->

	<para>
	  Como se mencionó anteriormente, el número dado con más
	  frecuencia para la diferencia en tamaño y velocidad entre C
	  y C++ es 10%, y a menudo más cercano al par. Incluso podría
	  conseguir una mejora significativa en tamaño y velocidad
	  cuando usa C++ más que con C porque el diseño que hace para
	  C++ puede ser bastante diferente para el que hizo para C.
	</para>


	<!--
	The evidence for size and speed comparisons between C and C++
	tends to be anecdotal and is likely to remain so. Regardless of
	the number of people who suggest that a company try the same
	project using C and C++, no company is likely to waste money
	that way unless it's very big and interested in such research
	projects. Even then, it seems like the money could be better
	spent. Almost universally, programmers who have moved from C (or
	some other procedural language) to C++ (or some other OOP
	language) have had the personal experience of a great
	acceleration in their programming productivity, and that's the
	most compelling argument you can find.
	-->

	<para>
	  La evidencia entre las comparaciones de tamaño y velocidad
	  entre C y C++ tienden a ser anecdóticas y es probable
	  permanecer así. A pesar del número de gente que sugiere que
	  una compañía intenta el mismo proyecto usando C y C++,
	  probablemente ninguna compañía quiere perder dinero en el
	  camino a no ser que sea muy grande e interesante con tantos
	  proyectos de investigación. Incluso entonces, parece que el
	  dinero puede ser mejor gastado. Casi universalmente, los
	  programadores que se han cambiado de C (o cualquier otro
	  lenguaje procedural) a C++ (o cualquier otro lenguaje de
	  POO) han tenido la experiencia personal de una gran
	  aceleración en su productividad de programación, y es el
	  argumento más convincente que pueda encontrar.
	</para>
	
      </sect3>
      <sect3>
	<!-- Common design errors -->
	<title>Errores comunes de diseño</title>

	<!--
	When starting your team into OOP and C++, programmers will
	typically go through a series of common design errors. This
	often happens because of too little feedback from experts during
	the design and implementation of early projects, because no
	experts have been developed within the company and there may be
	resistance to retaining consultants. It's easy to feel that you
	understand OOP too early in the cycle and go off on a bad
	tangent. Something that's obvious to someone experienced with
	the language may be a subject of great internal debate for a
	novice. Much of this trauma can be skipped by using an
	experienced outside expert for training and mentoring.
	-->

	<para>
	  Cuando su equipo empiza con POO y C++, típicamente los
	  programadores pasan por una serie de errores de diseño
	  comunes. Esto ocurre a menudo porque FIXME: of too little
	  feedback de expertos durante el diseño y la emplementación
	  de proyectos anticipados, porque ningún experto ha sido
	  desarrollador dentro de la compañía y puede haber
	  resistencia a retener especialistas. Es fácil sentir que
	  entiende la POO demasiado pronto en el ciclo y se pasa a
	  mala tangente. Algo que es obvio para alguien experimentado
	  con el lenguaje puede ser un tema de gran debate interno
	  para un novato. La mayor parte de este trauma puede ser
	  olvidado usando un experto experimentado del exterior para
	  enseñar y tutorizar.

	</para>

	<!--
	On the other hand, the fact that it is easy to make these design
	errors points to C++'s main drawback: its backward
	compatibility with C (of course, that's also its main
	strength). To accomplish the feat of being able to compile C
	code, the language had to make some compromises, which have
	resulted in a number of "dark corners." These are a reality,
	and comprise much of the learning curve for the language. In
	this book and the subsequent volume (and in other books; see
	Appendix C), I try to reveal most of the pitfalls you are likely
	to encounter when working with C++. You should always be aware
	that there are some holes in the safety net.
	-->

	<para>
	  Por otro lado, a pesar de que es fácil de cometer estos
	  errores de diseño apuntan al principal inconveniente de C++:
	  su subdesarrollada compatibilidad con C (por supuesto,
	  también es su principal fuerza). Para llevar a cabo la
	  hazaña de ser capaz de compilar código C, el lenguaje debe
	  cumplir algunos compromisos, como resultado en un número de
	  <quote>rincones oscuros</quote>. Esto es una realidad, y
	  comprende mucha de la curva de aprendizaje para el
	  lenguaje. En este libro y en el posterior volumen (y en
	  otros libros; ver el Apéndice C), intento mostrar la mayoría
	  de los obstáculos que probablemente encontrará cuando
	  trabaje con C++. Siempre debería ser consciente de que hay
	  algunos agujeros en la red de seguridad.
	  
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>

    <!--
    This chapter attempts to give you a feel for the broad issues of
    object-oriented programming and C++, including why OOP is different,
    and why C++ in particular is different, concepts of OOP
    methodologies, and finally the kinds of issues you will encounter
    when moving your own company to OOP and C++.
    -->

    <para>
      Este capítulo intenta darle un sentido a los extensos usos de la
      programación orientada a objetos y C++, incluyendo porqué la POO
      es diferente, y porqué C++ en particular es diferente, conceptos
      de metodología de POO, y finalmente los tipos de usos que
      encontrará cuando cambie su propia compañía a POO y C++.
    </para>


    <!--
    OOP and C++ may not be for everyone. It's important to evaluate
    your own needs and decide whether C++ will optimally satisfy those
    needs, or if you might be better off with another programming
    system (including the one you're currently using). If you know
    that your needs will be very specialized for the foreseeable
    future and if you have specific constraints that may not be
    satisfied by C++, then you owe it to yourself to investigate the
    alternatives[24]. Even if you eventually choose C++ as your
    language, you'll at least understand what the options were and
    have a clear vision of why you took that direction.

    [24] In particular, I recommend looking at Java
    (http://java.sun.com) and Python (http://www.Python.org).
    -->

    <para>
      La POO y C++ puede no ser para todos. Es importante evaluar sus
      necesidades y decidir si C++ satisfará de forma óptima sus
      necesidades, o si debe ser mejor con otros sistema de
      programación (incluido el que utiliza actualmente). Si sabe que
      sus necesidades serán muy especializadas en un futuro inmediato
      y tiene restricciones específicas que no pueden ser satisfechas
      por C++, entonces debe investigar las alternativas
      <footnote>
	<para>
	  En particular, recomiendo mirar Java <ulink
	    url="http://java.sun.com">http://java.sun.com</ulink> y
	    Python <ulink
	    url="http://www.python.org">http://www.Python.org</ulink>.
	</para>
      </footnote>. Incluso si finalmente elige C++ como su lenguaje,
      porlo menos entenderá que las opciones son y tienen una visión
      clara de porqué toma esta dirección.
    </para>

    <!--
    You know what a procedural program looks like: data definitions and
    function calls. To find the meaning of such a program you have to
    work a little, looking through the function calls and low-level
    concepts to create a model in your mind. This is the reason we need
    intermediate representations when designing procedural programs - by
    themselves, these programs tend to be confusing because the terms of
    expression are oriented more toward the computer than to the problem
    you're solving.
    -->

    <para>
      Sabe que un programa procedural parece: difiniciones de datos y
      llamadas a funciones. Para encontrar el significado de semejante
      programa tiene que trabajar un poco, revisando las llamadas a la
      función y los conceptos de bajo nivel para crear un modelo en su
      mente. Esta es la razón por la que necesitamos representaciones
      intermedias cuando diseñamos programas procedurales - por ellos
      mismos, estos programas tienden a ser confusos porque los
      términos de expresión están orientados más hacia la computadira
      que a resolver el problema.
    </para>
       
    <!--
    Because C++ adds many new concepts to the C language, your natural
    assumption may be that the main( ) in a C++ program will be far more
    complicated than for the equivalent C program. Here, you'll be
    pleasantly surprised: A well-written C++ program is generally far
    simpler and much easier to understand than the equivalent C
    program. What you'll see are the definitions of the objects that
    represent concepts in your problem space (rather than the issues of
    the computer representation) and messages sent to those objects to
    represent the activities in that space. One of the delights of
    object-oriented programming is that, with a well-designed program,
    it's easy to understand the code by reading it. Usually there's a
    lot less code, as well, because many of your problems will be solved
    by reusing existing library code.
    -->

    <para>
      Como C++ añade muchos nuevos conceptos al lenguaje C, puede que su
      asunción natural sea que el <function>main()</function> en un
      programa de C++ será mucho más complicado que el equivalente del
      programa en C. En eso, quedará gratamente sorprendido: un programa
      C++ bien escrito es generalmente mucho más simple y mucho más
      sencillo de entender que el programa equivalente en C. Lo que verá
      son las definiciones de los objetos que representan conceptos en
      el espacio de su problema (en lugar de cuestiones de la
      representación del computador) y mensajes enviados a otros objetos
      para representar las actividades en este espacio. Ese es Uno de
      los placeres de la programación orientada a objetos, con un
      programa bien diseñado, es fácil entender el código
      leyéndolo. Normalmente hay mucho menos código, en parte, porque
      muchos de sus problemas se resolverán utilizando código de
      librerías existentes.
    </para>
  </sect1>

</chapter>
