<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C1">
  
  <!--
  1: Introduction to Objects
  -->

  <title>Introducción a los Objetos</title>

  <!-- 
  The genesis of the computer revolution was in a machine. The genesis
  of our programming languages thus tends to look like that machine.
  -->

  <highlights>
    <para>
      La génesis de los lenguajes de la revolución informática ocurrió
      dentro de una máquina. Por tanto, la génesis de nuestros
      lenguajes de programación tiende a parecerse a esa máquina.
    </para>
  </highlights>

  <!--
  But computers are not so much machines as they are mind
  amplification tools ("bicycles for the mind", as Steve Jobs is fond
  of saying) and a different kind of expressive medium. As a result,
  the tools are beginning to look less like machines and more like
  parts of our minds, and also like other expressive mediums such as
  writing, painting, sculpture, animation, and
  filmmaking. Object-oriented programming is part of this movement
  toward using the computer as an expressive medium.
  -->

  <para>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente (<quote>bicicletas para la
    mente</quote>), como le gusta decir a decir Steve Jobs) y una
    manera diferente de medio de expresión.  Como resultado, las
    herramientas empiezan a parecerse menos a las máquinas y más a
    partes de nuestra mente, y también a otros medios de expresión
    como la escritura, la pintura, la escultura, la animación y la
    cinematografía. La programación orientada a objetos es parte de
    este movimiento hacia un uso del ordenador como medio de
    expresión.
  </para>

  <!--
  This chapter will introduce you to the basic concepts of
  object-oriented programming (OOP), including an overview of OOP
  development methods. This chapter, and this book, assume that you
  have had experience in a procedural programming language, although
  not necessarily C. If you think you need more preparation in
  programming and the syntax of C before tackling this book, you
  should work through the "Thinking in C: Foundations for C++ and
  Java" training CD ROM, bound in with this book and also available at
  www.BruceEckel.com.
  -->

  <para>
    Este capítulo le servirá de introducción a los conceptos básicos
    de la programación orientada a objetos (POO), incluyendo un
    resumen de los métodos de desarrollo de la POO. Este capítulo, y
    este libro, suponen que usted tiene ya experiencia con un lenguaje
    de programación procedural, aunque no sea necesariamente C. Si
    cree que necesita más preparación en programación y en la sintaxis
    de C antes de abordar este libro, debería mirarse el CD-ROM de
    entrenamiento <citetitle>Thinking in C: Foundations for C++ and
    Java</citetitle>, que viene junto con este libro, y también está
    disponible en <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
  </para>

  <!--
  This chapter is background and supplementary material. Many people
  do not feel comfortable wading into object-oriented programming
  without understanding the big picture first. Thus, there are many
  concepts that are introduced here to give you a solid overview of
  OOP. However, many other people don't get the big picture concepts
  until they've seen some of the mechanics first; these people may
  become bogged down and lost without some code to get their hands
  on. If you're part of this latter group and are eager to get to the
  specifics of the language, feel free to jump past this chapter-
  skipping it at this point will not prevent you from writing programs
  or learning the language. However, you will want to come back here
  eventually to fill in your knowledge so you can understand why
  objects are important and how to design with them.
  -->

  <para>
    Este capítulo es material básico y suplementario. Mucha gente no
    se siente cómoda adentrándose en la programación orientada a
    objetos sin tener antes una visión global. Por tanto, aquí se
    introducen muchos conceptos para darle una visión sólida de la
    POO. Sin embargo, mucha otra gente no capta los conceptos globales
    hasta que no han visto parte de la mecánica primero; esta gente
    puede atascarse y perderse sin algún trozo de código al que
    ponerle las manos encima. Si usted es parte de este último grupo,
    y está ansioso por llegar a las especificaciones del lenguaje,
    siéntase libre de saltarse este capítulo; esto no le impedirá
    escribir programas o aprender el lenguaje. Sin embargo, quizá
    quiera volver a este capítulo para completar sus conocimientos y
    poder comprender porqué son importantes los objetos y cómo diseñar
    con ellos.
  </para>

  <sect1>

  <!--
  The progress of abstraction
  -->

    <title>El progreso de abstracción</title>

  <!--
    All programming languages provide abstractions. It can be argued
    that the complexity of the problems you're able to solve is
    directly related to the kind and quality of abstraction. By "kind"
    I mean, "What is it that you are abstracting?" Assembly language
    is a small abstraction of the underlying machine. Many so-called
    "imperative" languages that followed (such as Fortran, BASIC, and
    C) were abstractions of assembly language. These languages are big
    improvements over assembly language, but their primary abstraction
    still requires you to think in terms of the structure of the
    computer rather than the structure of the problem you are trying
    to solve. The programmer must establish the association between
    the machine model (in the "solution space", which is the place
    where you're modeling that problem, such as a computer) and the
    model of the problem that is actually being solved (in the
    "problem space", which is the place where the problem exists). The
    effort required to perform this mapping, and the fact that it is
    extrinsic to the programming language, produces programs that are
    difficult to write and expensive to maintain, and as a side effect
    created the entire "programming methods" industry.
  -->

    <para>
      Todos los lenguajes de programación proporcionan
      abstracciones. Se puede afirmar que la complejidad de los
      problemas que se pueden resolver está relacionada directamente
      con el tipo y calidad de la abstracción. Por <quote>tipo</quote>
      me refiero a <quote>¿Qué es lo que está abstrayendo?</quote>. El
      lenguaje ensamblador es una pequeña abstracción de la máquina
      subyacente. Muchos lenguajes llamados <quote>imperativos</quote>
      que siguieron (como Fortran, BASIC y C) eran abstracciones del
      lenguaje ensamblador. Estos lenguajes son grandes mejoras con
      respecto al lenguaje ensamblador, pero su abstracción primaria
      todavía requiere que usted piense en términos de la estructura
      de la computadora, en lugar de la estructura del problema que
      intenta resolver. El programador debe establecer la asociación
      entre el modelo de la máquina (en el <quote>espacio de
      soluciones</quote>, que es el lugar donde está modelando ese
      problema, como un ordenador) y el modelo del problema que se
      está resolviendo (en el <quote>espacio de problemas</quote>, que
      es el lugar donde existe el problema). El esfuerzo requerido
      para realizar esta correspondencia, y el hecho de que sea
      extrínseco al lenguaje de programación, produce programas que
      son difíciles de escribir y caros de mantener y, como efecto
      secundario, creó toda la industria de <quote>métodos de
      programación</quote>.
    </para>

  <!--
    The alternative to modeling the machine is to model the problem
    you're trying to solve. Early languages such as LISP and APL chose
    particular views of the world ("All problems are ultimately lists"
    or "All problems are algorithmic"). PROLOG casts all problems into
    chains of decisions. Languages have been created for
    constraint-based programming and for programming exclusively by
    manipulating graphical symbols. (The latter proved to be too
    restrictive.) Each of these approaches is a good solution to the
    particular class of problem they' designed to solve, but when you
    step outside of that domain they become awkward.
  -->

    <para>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como el LISP y
      el APL eligieron concepciones del mundo particulares
      (<quote>Todos los problemas son listas en última
      instancia</quote>, o <quote>Todos los problemas son
      algorítmicos</quote>). El PROLOG reduce todos los problemas a
      cadenas de decisiones. Se han creado lenguajes para programación
      basada en restricciones y para programar manipulando
      exclusivamente símbolos gráficos (el último demostró ser
      demasiado restrictivo). Cada uno de estos métodos es una buena
      solución para el tipo particular de problema para el que fueron
      diseñados, pero cuando uno se sale de ese dominio se hacen
      difíciles de usar.
    </para>
      
  <!--
    The object-oriented approach goes a step farther by providing
    tools for the programmer to represent elements in the problem
    space. This representation is general enough that the programmer
    is not constrained to any particular type of problem. We refer to
    the elements in the problem space and their representations in the
    solution space as "objects". (Of course, you will also need other
    objects that don't have problem-space analogs.) The idea is that
    the program is allowed to adapt itself to the lingo of the problem
    by adding new types of objects, so when you read the code
    describing the solution, you're reading words that also express
    the problem. This is a more flexible and powerful language
    abstraction than what we've had before. Thus, OOP allows you to
    describe the problem in terms of the problem, rather than in terms
    of the computer where the solution will run. There's still a
    connection back to the computer, though. Each object looks quite a
    bit like a little computer; it has a state, and it has operations
    that you can ask it to perform. However, this doesn't seem like
    such a bad analogy to objects in the real world; they all have
    characteristics and behaviors.
  -->

    <para>
      El método orientado a objetos va un paso más allá,
      proporcionando herramientas para que el programador represente
      los elementos en el espacio de problemas. Esta representación es
      lo suficientemente general para que el programador no esté
      limitado a ningún tipo particular de problema. Nos referimos a
      los elementos en el espacio de problemas, y a sus
      representaciones en el espacio de soluciones, como
      <quote>objetos</quote>. (Por supuesto, necesitará otros objetos
      que no tengan analogías en el espacio del problema.)  La idea es
      que se permita al programa adaptarse al FIXME:lingo del problema
      añadiendo nuevos tipos de objetos de modo que cuando lea el
      código describiendo la solución, está leyendo palabras que
      además expresan el problema. Este es el lenguaje de abstracción
      más flexible y potente que haya usado antes. De esta manera, la
      POO permite describir el problema en términos del problema, en
      lugar de usar términos de la computadora en la que se ejecutará
      la solución. Sin embargo, todavía existe una conexión con la
      computadora. Cada objeto se parece un poco a una pequeña
      computadora; tiene un estado, y operaciones que se le puede
      pedir hacer. Sin embargo, no parece una mala analogía a los
      objetos en el mundo real; todos tienen características y
      comportamientos.
    </para>

    <!--
    Some language designers have decided that object-oriented
    programming by itself is not adequate to easily solve all
    programming problems, and advocate the combination of various
    approaches into multiparadigm programming languages.[4]See
    Multiparadigm Programming in Leda by Timothy Budd (Addison-Wesley
    1995).
    -->

    <para>
      Algunos diseñadores de lenguajes han decidido que la
      programación orientada a objetos en sí misma no es adecuada para
      resolver fácilmente todos los problemas de programación, y
      abogan por una combinación de varias aproximaciones en lenguajes
      de programación <emphasis>multiparadigma</emphasis>. <footnote>
      <para>Ver <emphasis>Multiparadigm Programming in Leda</emphasis>
      de <personname><firstname>Timothy</firstname>
      <surname>Budd</surname></personname> (Addison-Wesley
      1995).</para>
      </footnote>
    </para>
  
    <!--
    Alan Kay summarized five basic characteristics of Smalltalk, the
    first successful object-oriented language and one of the languages
    upon which C++ is based. These characteristics represent a pure
    approach to object-oriented programming:
    -->

    <para>
      <personname><firstname>Alan</firstname>
      <surname>Kay</surname></personname> resumió las cinco
      características básicas de Smalltalk, el primer lenguaje
      orientado a objetos exitoso y uno de los lenguajes en los que
      está basado C++. Esas características representan un
      aproximación a la programación orientada a objetos:
    </para>
    
    <!--

    1. Everything is an object. Think of an object as a fancy variable; it
    stores data, but you can "make requests" to that object, asking it
    to perform operations on itself. In theory, you can take any
    conceptual component in the problem you're trying to solve (dogs,
    buildings, services, etc.) and represent it as an object in your
    program.
    -->

    <orderedlist>
      <listitem>
	<para>
	  Todo es un objeto. Pensar en un objeto como una variable
	  elaborada; almacena datos, pero puede <quote>hacer
	  peticiones</quote> a este objeto, pidiendo que realice
	  operaciones en sí mismo. En teoría, puede coger cualquier
	  componente conceptual del problema que está intentando
	  resolver (perros, edificios, servicios, etc.) y
	  representarlo como un objeto en su programa.
	</para>
      </listitem>

   
    <!--
    2. A program is a bunch of objects telling each other what to do
      by sending messages. To make a request of an object, you "send a
      message" to that object. More concretely, you can think of a
      message as a request to call a function that belongs to a
      particular object.
    -->

     <listitem>
	<para>
	  Un programa es un grupo de objetos enviando mensajes a otros
	  para decirles qué hacer. Para hacer una petición a un
	  objeto, <quote>envía un mensaje</quote> a ese objeto. Más
	  concretamente, puede pensar en un mensaje como una petición
	  de invocación a una función que pertenece a un objeto
	  particular.
	</para>
      </listitem>

    <!--
   3. Each object has its own memory made up of other objects. Put
      another way, you create a new kind of object by making a package
      containing existing objects. Thus, you can build complexity in a
      program while hiding it behind the simplicity of objects.
    -->

     <listitem>
	<para>
	  Cada objeto tiene su propia memoria hecha a base de otro
	  objetos. Visto de otra manera, puedes crear un nuevo tipo de
	  objeto haciendo un paquete que contiene objetos
	  existentes. Por consiguiente, puede construir de forma
	  compleja en un programa ocultando la complejidad de los
	  objetos.
	</para>
      </listitem>

    <!--
   4. Every object has a type. Using the parlance, each object is an
      instance of a class, in which "class" is synonymous with "type."
      The most important distinguishing characteristic of a class is
      "What messages can you send to it?"
    -->

      <listitem>
	<para>
	  Cada objeto es un tipo. Usando el FIXME:parlance, cada
	  objeto es una instancia de una clase, en el que
	  <quote>clase</quote> es sinónimo de <quote>tipo</quote>. La
	  característica más importante que lo distingue de una clase
	  es <quote>¿Qué mensajes puede enviarle?</quote>
	</para>
      </listitem>

    <!--
    5. All objects of a particular type can receive the same
    messages. This is actually a loaded statement, as you will see
    later. Because an object of type "circle" is also an object of
    type "shape," a circle is guaranteed to accept shape
    messages. This means you can write code that talks to shapes and
    automatically handles anything that fits the description of a
    shape. This substitutability is one of the most powerful concepts
    in OOP.
    -->

      <listitem>
	<para>
	  Todos los objetos de un tipo particular pueden recibir los
	  mismos mensajes. Es realmente una declaración con doble
	  sentido, como se verá más tarde. Porque un objeto de tipo
	  <classname>círculo</classname> es también un objeto de tipo
	  <classname>figura</classname>, está garantizado que un
	  círculo recibirá los mensajes de figura. Esto significa que
	  puede escribir código que habla con objetos
	  <classname>figura</classname> y automáticamente funciona con
	  cualquier otro objeto que coincida con la descripción de
	  <classname>figura</classname>. Esta
	  <emphasis>sustitutabilidad</emphasis> es una de los más
	  poderosos conceptos en la POO.
	</para>
      </listitem>
    </orderedlist>


  </sect1>

  <sect1>

    <!--
    An object has an interface
    -->
      <title>Un objeto tiene una interfaz</title>

    <!--
    Aristotle was probably the first to begin a careful study of the
    concept of type; he spoke of "the class of fishes and the class of
    birds."  The idea that all objects, while being unique, are also
    part of a class of objects that have characteristics and behaviors
    in common was used directly in the first object-oriented language,
    Simula-67, with its fundamental keyword class that introduces a
    new type into a program.
    -->
    

    <para>
    Aristóteles probablemente fue el primero en hacer un estudio minucioso
    del concepto de <emphasis>tipo</emphasis>; él habló de <quote>las
    clases de peces y las clases de pájaros</quote>. La idea de que todos
    los objetos, aún siendo únicos, también son parte de una clase de
    objetos que tienen características y comportamientos comunes se
    utilizó directamente en el primer lenguaje orientado a objetos,
    Simula-67, con su palabra reservada <keyword>class</keyword> que
    introduce un nuevo tipo en un programa.
    </para>

    <!-- 
    Simula, as its name implies, was created for developing simulations
    such as the classic "bank teller problem[5]." In this, you have
    a bunch of tellers, customers, accounts, transactions, and units
    of money - a lot of "objects". Objects that are identical except
    for their state during a program's execution are grouped
    together into "classes of objects" and that's where the keyword
    class came from. Creating abstract data types (classes) is a
    fundamental concept in object-oriented programming. Abstract
    data types work almost exactly like built-in types: You can
    create variables of a type (called objects or instances in
    object-oriented parlance) and manipulate those variables (called
    sending messages or requests; you send a message and the object
    figures out what to do with it). The members (elements) of each
    class share some commonality: every account has a balance, every
    teller can accept a deposit, etc. At the same time, each member
    has its own state, each account has a different balance, each
    teller has a name. Thus, the tellers, customers, accounts,
    transactions, etc., can each be represented with a unique entity
    in the computer program. This entity is the object, and each
    object belongs to a particular class that defines its
    characteristics and behaviors.
    -->


    <!--
    [5] You can find an interesting implementation of this problem in
    Volume 2 of this book, available at www.BruceEckel.com.
    -->

    <para>
      Simula, como su nombre indica, fue creado para desarrollar
      simulaciones como el clásico FIXME:<quote>back teller
      problem</quote><footnote>
	<para>
	  Puede encontrar una interesante implementación de este
	  problema en el 2º Volumen de este libro, disponible en
	  <ulink
	  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>
	</para>
      </footnote>
      En él, tiene un grupo de cajeros, clientes, cuentas,
      transacciones, y unidades de moneda -- un montón de
      <quote>objetos</quote>. Los objetos que son idénticos
      exceptuando su estado durante la ejecución del programa se
      agrupan juntos en <quote>clases de objetos</quote> y de ahí es
      de donde viene la palabra clave <keyword>class</keyword>. Crear
      tipos de datos abstractos (clases) es un concepto fundamental en
      la programación orientada a objetos. Los tipos de datos
      abstractos trabajan casi exactamente como tipos empotrados:
      puede crear variables de un tipo (llamados
      <emphasis>objetos</emphasis> o <emphasis>instancias</emphasis>
      en el argot de la programación orientada a objetos) y manipular
      estas variables FIXME:(llamadas <emphasis>sending
      messages</emphasis> o <emphasis>requests</emphasis>; envía un
      mensaje y the object figures out what to do with it). Los
      miembros (elementos) de cada clase comparten FIXME: some
      commonality: cada cuenta tiene un balance, cada cajero puede
      aceptar un depósito, etc. Al mismo tiempo, cada miembro tiene su
      propio estado, cada cuenta tiene un balance diferente, cada
      cajero tiene un nombre. De esta manera, los cajeros, clientes,
      cuentas, transacciones, etc., cada uno puede ser representado
      con una única entidad en el programa de computadora. Esta
      entidad es un objeto, y cada objeto pertenece a una clase
      particular que define sus características y comportamientos.
      </para>
  </sect1>

  <sect1>

    <!--
    The hidden implementation
    -->
    <title>La implementación oculta</title>

    <!--
    It is helpful to break up the playing field into class creators
    (those who create new data types) and client programmers[7] (the
    class consumers who use the data types in their applications). The
    goal of the client programmer is to collect a toolbox full of
    classes to use for rapid application development. The goal of the
    class creator is to build a class that exposes only what's
    necessary to the client programmer and keeps everything else
    hidden. Why? Because if it's hidden, the client programmer can't
    use it, which means that the class creator can change the hidden
    portion at will without worrying about the impact to anyone
    else. The hidden portion usually represents the tender insides of
    an object that could easily be corrupted by a careless or
    uninformed client programmer, so hiding the implementation reduces
    program bugs. The concept of implementation hiding cannot be
    overemphasized.
    -->

   <para>
      Es útil distinguir entre los <emphasis>creadores de
	clases</emphasis> (aquellos que crean nuevos tipos de datos) y
	<emphasis>programadores clientes[7]</emphasis> (los
	consumidores de clases que usan los tipos de datos en sus
	aplicaciones). El objetivo del programador cliente es acumular
	una caja de herramientas llena de clases que usar para un
	desarrollo rápido de aplicaciones. El objetivo del creador de
	clases es construir una clase que exponga sólo lo necesario
	para el programador cliente y mantiene todo lo demás
	oculto. ¿Por qué? Porque si está oculto, el programador
	cliente no puede usarlo, lo cual significa que el creador de
	clases puede cambiar la parte oculta sin preocuparse de las
	consecuencia sobre los demás. La parte oculta suele
	representar las interioridades delicadas de un objeto que
	podría fácilmente corrompida por un programador cliente
	descuidado o desinformado, así que ocultando la implementación
	se reducen los errores de programación. No se debe abusar del
	concepto de implementación oculta.
    </para>

    <!--
    In any relationship it's important to have boundaries that are
    respected by all parties involved. When you create a library, you
    establish a relationship with the client programmer, who is also a
    programmer, but one who is putting together an application by
    using your library, possibly to build a bigger library.
    -->

    <para>
      En cualquier relación es importante tener límites que sean
      respetadas por todas las partes involucradas. Cuando se cree una
      librería, se establece una relación con el programador cliente,
      quien también es programador, porque puede estar utilizando la
      librería para crear a su vez una librería mayor.
    </para>


    <!--
    If all the members of a class are available to everyone, then the
    client programmer can do anything with that class and there's no
    way to enforce rules. Even though you might really prefer that the
    client programmer not directly manipulate some of the members of
    your class, without access control there's no way to prevent
    it. Everything's naked to the world.
    -->

    <para>
      Si todos los miembros de una clase están disponibles para
      cualquiera, entonces el programador cliente puede hacer
      cualquier cosa con la clase y no hay forma de imponer las
      reglas. Incluso si prefiere que el programador cliente no
      manipule directamente algunos de los miembros de su clase, son
      control de acceso no hay forma de impedirlo. Nadie está a salvo.
    </para>

   <!--
    So the first reason for access control is to keep client
    programmers'hands off portions they shouldn't touch - parts that
    are necessary for the internal machinations of the data type but
    not part of the interface that users need in order to solve their
    particular problems. This is actually a service to users because
    they can easily see what's important to them and what they can
    ignore.
    -->

    <para>
      Por eso la principal razón del control de acceso es impedir que
      el cliente toque las partes que no debería - partes que son
      necesarias para los mecanismos internos de los tipos de datos
      pero no parte de la interfaz que los usuarios necesitan para
      resolver sus problemas particulares. Realmente esto es un
      servicio para los usuarios porque pueden ver fácilmente qué es
      importante para ellos y qué pueden ignorar.
    </para>

    <!--
    The second reason for access control is to allow the library
    designer to change the internal workings of the class without
    worrying about how it will affect the client programmer. For
    example, you might implement a particular class in a simple
    fashion to ease development, and then later discover that you need
    to rewrite it in order to make it run faster. If the interface and
    implementation are clearly separated and protected, you can
    accomplish this easily and require only a relink by the user.
    -->

    <para>
      La segunda razón para el control de acceso es permitir al
      diseñador de la librería cambiar los trabajos internos de la
      clase sin preocuparse de cómo afectará a los programadores
      clientes. Por ejemplo, podría implementar una clase particular
      de una manera sencilla para un desarrollo fácil, y más tarde
      descubrir que necesita reescribirla para hacerla más rápida. Si
      la interfaz y la implementación están claramente separadas y
      protegidas, puede conseguirlo fácilmente y sólo requiere que el
      usuario vuelva a enlazar la aplicación.
    </para>

    <!--
    C++ uses three explicit keywords to set the boundaries in a class:
    public, private, and protected. Their use and meaning are quite
    straightforward. These access specifiers determine who can use the
    definitions that follow. public means the following definitions
    are available to everyone. The private keyword, on the other hand,
    means that no one can access those definitions except you, the
    creator of the type, inside member functions of that type. private
    is a brick wall between you and the client programmer. If someone
    tries to access a private member, they'll get a compile-time
    error. protected acts just like private, with the exception that
    an inheriting class has access to protected members, but not
    private members. Inheritance will be introduced shortly.
    -->

    <para>
      C++ utiliza tres palabras reservadas explícitas para poner
      límites en una clase: <keyword>public</keyword>,
      <keyword>private</keyword>, y <keyword>protected</keyword>. Su
      uso y significado son bastante sencillos. Estos
      <emphasis>especificadores de acceso</emphasis> determinan quien
      usa las definiciones que siguen. <keyword>public</keyword>
      significa que las definiciones posteriores están disponibles
      para cualquiera. La palabra reservada
      <keyword>private</keyword>, por otro lado, significa que nadie
      puede acceder a estas definiciones excepto el creador del tipo,
      es decir, los métodos internos de la
      clase. <keyword>private</keyword> es una pared entre el creador
      de la clase y el programador cliente. Si alguien intenta acceder
      a un miembro privado, obtendrá un error al
      compilar. <keyword>protected</keyword> actúa como
      <keyword>private</keyword>, con la excepción de que las clases
      [FIXME: herederas] tienen acceso a miembros protegidos, pero no
      a los privados. La herencia se explicará en breve.
    </para>


  </sect1>

  <sect1>

    <!--
    Reusing the implementation
    -->

    <title>Reutilizando la implementación</title>

    <!--
    Once a class has been created and tested, it should (ideally)
    represent a useful unit of code. It turns out that this
    reusability is not nearly so easy to achieve as many would hope;
    it takes experience and insight to produce a good design. But once
    you have such a design, it begs to be reused. Code reuse is one of
    the greatest advantages that object-oriented programming languages
    provide.
    -->

    <para>
      Una vez que una clase ha sido creada y probada, debería
      (perfectamente) representar una unidad útil de código. Eso
      [FIXME:turns out that] esta reusabilidad casi no es tan fácil de
      conseguir como muchos [FIXME:would hope]; coge experiencia y
      entendimiento para producir un buen diseño. Pero una vez que
      tiene semejante diseño, éste pide ser reutilizado. El código
      reutilizado es una de las mejores ventajas de los lenguajes de
      programación orientada a objetos.
    </para>


    <!--
    The simplest way to reuse a class is to just use an object of that
    class directly, but you can also place an object of that class
    inside a new class. We call this "creating a member object". Your
    new class can be made up of any number and type of other objects,
    in any combination that you need to achieve the functionality
    desired in your new class. Because you are composing a new class
    from existing classes, this concept is called composition (or more
    generally, aggregation). Composition is often referred to as a
    "has-a" relationship, as in "a car has an engine".
    -->
    
    <para>
      La forma más fácil de reutilizar una clase es precisamente
      utilizar un objeto de esa clase directamente, pero también puede
      colocar un objeto de esta clase dentro de una clase
      nueva. Podemos llamarlo [FIXME:<quote>crear un objeto miembro</quote>]. Su
      nueva clase puede estar compuesta de algún número y tipo de
      otros objetos, en alguna combinación que necesite para conseguir
      la funcionalidad deseada en su nueva clase. Porque está
      componiendo una nueva clase desde clases existentes, este
      concepto se llama <emphasys>composition</emphasys> (o más
      generalmente, <emphasys>aggregation</emphasys>. [FIXME:
      Composition is often referred to as a <quote>has-a</quote> relationship, as
      in <quote>a car has an engine</quote>].
    </para>


    <!--
    (The above UML diagram indicates composition with the filled
    diamond, which states there is one car. I will typically use a
    simpler form: just a line, without the diamond, to indicate an
    association.[8])

    [8] This is usually enough detail for most diagrams, and you don't
    need to get specific about whether you're using aggregation or
    composition.
    -->

    <para>
      (El diagrama UML superior indica composición con [FIXME: the
      filled diamond, which states there is one car]. Típicamente se
      usará una forma simple: [FIXME:just] una línea, sin [FIXME: the
      diamond], para indicar una asociación.[FIXME: [8]]).
      
      [8] El bastante habitual detallar para más diagramas, y no
      necesita [FIXME:to get specific] sobre si está usando agregación
      o composición.
    </para>


    <!--
    Composition comes with a great deal of flexibility. The member
    objects of your new class are usually private, making them
    inaccessible to the client programmers who are using the
    class. This allows you to change those members without disturbing
    existing client code. You can also change the member objects at
    runtime, to dynamically change the behavior of your
    program. Inheritance, which is described next, does not have this
    flexibility since the compiler must place compile-time
    restrictions on classes created with inheritance.
    -->

    <para>
      La composición viene con una gran [FIXME: deal] de
      flexibilidad. Los objetos miembros de su nueva clase son
      habitualmente privados, haciéndolos inaccesibles para los
      programadores clientes que están usando la clase. Esto permite
      cambiar esos miembros sin [FIXME:disturbing existing] código
      cliente. También puede cambiar los objetos miembros [FIXME:at
      runtime], para cambiar dinámicamente el comportamiento de su
      programa. La herencia, descrita más delante, no tiene esta
      flexibilidad desde el compilador [FIXME:must place compile-time]
      restricciones en clases creadas con herencia.
    </para>
    

    <!--
    Because inheritance is so important in object-oriented programming
    it is often highly emphasized, and the new programmer can get the
    idea that inheritance should be used everywhere. This can result
    in awkward and overly-complicated designs. Instead, you should
    first look to composition when creating new classes, since it is
    simpler and more flexible. If you take this approach, your designs
    will stay cleaner. Once you've had some experience, it will be
    reasonably obvious when you need inheritance.
    -->
    
    <para>
      Porque la herencia es tan importante en la programación
      orientada a objetos, esto sumamente emfatizado, y el nuevo
      programador puede tener la idea de que la herencia debería ser
      usada en todas partes. Esto puede dar como resultado diseños
      torpes y demasiado complicados. En cambio, debería mirar primero
      la composición cuando cree nuevas clases, ya que es más simple y
      flexible. Si acepta esta propuesta, sus diseños serán más
      limpios. Una vez que tenga experiencia, será razonablemente
      evidente cuando necesite herencia.
    </para>


  </sect1>

  <sect1>
   <!--
    Inheritance:
    reusing the interface
    -->

    <title>Herencia: reutilización de interfaces</title>
  
    <!--
    By itself, the idea of an object is a convenient tool. It allows
    you to package data and functionality together by concept, so you
    can represent an appropriate problem-space idea rather than being
    forced to use the idioms of the underlying machine. These concepts
    are expressed as fundamental units in the programming language by
    using the class keyword.
    -->

    <para>
      Por sí misma, la idea de un objeto es una herramienta
      conveniente. Permite empaquetar datos y funcionalidad junto al
      concepto, además puede representar una idea apropiada
      [FIXME:problem-space] más que estar forzado a usar los idiomas de
      la máquina subyacente. Estos conceptos se ecpresan como unidades
      fundamentales en el lenguaje de programación mediante la palabra
      clave <keyword>class</keyword>.
    </para>

    <!-- 
    It seems a pity, however, to go to all the trouble to create
    a class and then be forced to create a brand new one that might
    have similar functionality. It's nicer if we can take the
    existing class, clone it, and then make additions and
    modifications to the clone. This is effectively what you get with
    inheritance, with the exception that if the original class (called
    the base or super or parent class) is changed, the modified
    "clone" (called the derived or inherited or sub or
    child class) also reflects those changes.  
    -->
    
    <para>
      Parece una pena, sin embargo, tomarse muchas molestias en crear
      una clase y ser forzado a crear un nuevo tipo puede tener
      similar funcionalidad. Es más sencillo si se pueden usar la
      clase existente, clonarla, y hacerle añadidos y modificaciones
      al clon. Esto es efectivamente lo que hace la
      <emphasis>herencia</emphasis>, con la excepción de que la clase
      original (llamada clase <emphasis>base</emphasis> o
      <emphasis>super</emphasis> o <emphasis>padre</emphasis>) se
      cambia, el <quote>clon</quote> modificado (llamado
      <emphasis>derivado</emphasis> o <emphasis>heredado</emphasis> o
      <emphasis>sub</emphasis> o clase <emphasis>hija</emphasis>)
      también refleja estos cambios.
   </para>


    <!--
    (The arrow in the above UML diagram points from the derived class
    to the base class. As you will see, there can be more than one
    derived class.)
    -->

    <para>
    (La flecha sobre el diagrama UML señala desde la clase derivada a
    la clase base. Como se puede ver, puede haber más de una clase derivada.)
    </para>
    

    <!--
    A type does more than describe the constraints on a set of objects; it
    also has a relationship with other types. Two types can have
    characteristics and behaviors in common, but one type may contain more
    characteristics than another and may also handle more messages (or
    handle them differently). Inheritance expresses this similarity
    between types using the concept of base types and derived types. A
    base type contains all of the characteristics and behaviors that are
    shared among the types derived from it. You create a base type to
    represent the core of your ideas about some objects in your
    system. From the base type, you derive other types to express the
    different ways that this core can be realized.
    -->

    <para>
      Un tipo hace más que describir las restricciones de un conjunto
      de objetos; también tiene una relación con otros tipos. Dos
      tipos pueden tener características y comportamientos en común,
      pero un tipo puede contener más características que otro y
      también puede manipular más mensajes (o hacerlo de forma
      diferente). La herencia expresa esto de forma similar entre
      tipos usando el concepto de tipos base y tipos derivados. Un
      tipo base contiene todas las características y comportamientos
      compartidos entre los tipos derivados [FIXME: from it]. Cree un
      tipo base para representar lo esencial de sus ideas sobre
      algunos objetos en su sistema. Del tipo base, derive otros tipos
      para expresar caminos diferentes que este núcleo puede realizar.
    </para>


    <!--
    For example, a trash-recycling machine sorts pieces of trash. The base
    type is “trash,” and each piece of trash has a weight, a value, and so
    on, and can be shredded, melted, or decomposed. From this, more
    specific types of trash are derived that may have additional
    characteristics (a bottle has a color) or behaviors (an aluminum can
    may be crushed, a steel can is magnetic). In addition, some behaviors
    may be different (the value of paper depends on its type and
    condition). Using inheritance, you can build a type hierarchy that
    expresses the problem you’re trying to solve in terms of its types.
    -->

    <para>
      Por ejemplo, una máquina de reciclado de basura clasifica piezas
      de basura. El tipo base es <quote>basura</quote> y otra pieza de
      basura tiene un peso, un valor, y tambié, puede ser triturada,
      fundida o descompuesta. [FIXME: From this], se obtienen más
      tipos específicos de basura que pueden tener características
      adicionales (una botella tiene un color) o comportamientos (el
      aluminio puede ser aplastado, el acero puede ser
      magnético). Además, algunos comportamientos puedes ser
      diferentes (el valor del papel depende del tipo y
      condición). Usando la herencia, se puede construir un tipo de
      jerarquía que exprese el problema que se intenta resolver en
      términos de sus tipos.
    </para>



    <!--
    A second example is the classic “shape” example, perhaps used in a
    computer-aided design system or game simulation. The base type is
    “shape,” and each shape has a size, a color, a position, and so
    on. Each shape can be drawn, erased, moved, colored, etc. From this,
    specific types of shapes are derived (inherited): circle, square,
    triangle, and so on, each of which may have additional characteristics
    and behaviors. Certain shapes can be flipped, for example. Some
    behaviors may be different, such as when you want to calculate the
    area of a shape. The type hierarchy embodies both the similarities and
    differences between the shapes.
    -->

    <para>
      Un segundo ejemplo es el clásic ejemplo <quote>figura</quote>,
      tal vez usado en un [FIXME:computer-aided design system] o
      juegos de simulación. El tipo base es <quote>figura</quote>, y
      cada figura tiene un tamaño, un color, una posición y así
      sucesivamente. Cada figura puede ser dibujado, borrado, movido,
      coloreado, etc. [FIXME: From this], tipos específicos de figuras
      derivan (heredan): círculo, cuadrado, triángulo, y así
      sucesivamente, cada uno de ellos puede tener características y
      comportamientos adicionales. Ciertas figuras pueden ser, por
      ejemplo, volteadas. Algunos comportamientos pueden ser
      diferentes, como cuando se quiere calcular el área de una
      figura. La jerarquía tipo expresa las similitudes y las
      diferencias entre las figuras.
   </para>

    <!--
    Casting the solution in the same terms as the problem is tremendously
    beneficial because you don’t need a lot of intermediate models to get
    from a description of the problem to a description of the
    solution. With objects, the type hierarchy is the primary model, so
    you go directly from the description of the system in the real world
    to the description of the system in code. Indeed, one of the
    difficulties people have with object-oriented design is that it’s too
    simple to get from the beginning to the end. A mind trained to look
    for complex solutions is often stumped by this simplicity at first.
    -->

   <para>
      Emitir la solución en los mismos términos que el problema es
      tremendamente beneficios porque no se necesitan muchos modelos
      intermedios para tener desde una descripción del problema a una
      descripción de la solución. Con objetos, la jerarquía tipo es el
      principal modelo, va directamente desde la descripción del
      sistema en el mundo real a la descripción del sistema en
      código. Efectivamente, una de las dificultades de que gente
      tiene con el diseño orientado a objetos es que es muy simple
      [FIXME:to get] desde el principo hasta el final. Una mente
      entrenada para buscar soluciones complejas es a menudo
      confundida con la simplicidad al principio.
   </para>

    <!--
    When you inherit from an existing type, you create a new type. This
    new type contains not only all the members of the existing type
    (although the private ones are hidden away and inaccessible), but more
    importantly it duplicates the interface of the base class. That is,
    all the messages you can send to objects of the base class you can
    also send to objects of the derived class. Since we know the type of a
    class by the messages we can send to it, this means that the derived
    class is the same type as the base class. In the previous example, “a
    circle is a shape.” This type equivalence via inheritance is one of
    the fundamental gateways in understanding the meaning of
    object-oriented programming.
    -->

    <para>
      Cuando hereda desde un tipo existente, se crea un tipo
      nuevo. Este nuevo tipo contiene no sólo todos los miembros del
      tipo existente (aunque [FIXME:the <emphasis>private</emphasis>
      ones] están ocultos e inaccesibles), pero más importante duplica
      la interfaz de la clase base. Es decir, todos los mensajes que
      se pueden enviar a los objetos de la clase base pueden enviarse
      también a los objetos de la clase derivada. Desde que se conoce
      el tipo de una clase por los mensajes que se le pueden enviar,
      esto significa que la clase derivada <emphasis>es del mismo tipo
      que la clase base</emphasis>. En el ejemplo anterior, <quote>un
      círculo es una figura</quote>. Este tipo equivante vía herencia
      es uno de las principales puertas para entender la programación
      orientada a objetos.
    </para>

    <!--
    Since both the base class and derived class have the same interface,
    there must be some implementation to go along with that
    interface. That is, there must be some code to execute when an object
    receives a particular message. If you simply inherit a class and don’t
    do anything else, the methods from the base-class interface come right
    along into the derived class. That means objects of the derived class
    have not only the same type, they also have the same behavior, which
    isn’t particularly interesting.
    -->

    <para>
      Desde que ambas clases, base y derivada, tienen la misma
      interfaz, debe haber alguna implementación que esté de acuerdo
      con esa interfaz. Es decir, debe haber código para ejecutar
      cuando un objeto recibe un mensaje particular. Si simplemente
      hereda una clase y no hace nada más, los métodos de la interfaz
      de la clase base [FIXME:come right along into] la clase
      derivada. Esto significa que los objetos de la clase derivada no
      sólo tienen el mismo tipo, también tienen el mismo
      comportamiento, el cual no es particularmente interesante.
    </para>

    <!--
    You have two ways to differentiate your new derived class from the
    original base class. The first is quite straightforward: You simply
    add brand new functions to the derived class. These new functions are
    not part of the base class interface. This means that the base class
    simply didn’t do as much as you wanted it to, so you added more
    functions. This simple and primitive use for inheritance is, at times,
    the perfect solution to your problem. However, you should look closely
    for the possibility that your base class might also need these
    additional functions. This process of discovery and iteration of your
    design happens regularly in object-oriented programming.
   -->

    <para>
      Hay dos caminos para diferenciar la nueva clase derivada de la
      clase base original. El primero es bastante sencillo:
      simplemente hay que añadir nuevos tipos de funciones a la clase
      derivada. Estas nuevas funciones no son parte de la interfaz de
      la clase base. Esto significa que la clase base simplemente no
      hace tanto como necesitamos, por lo que se añaden más
      funciones. Este uso simple y primitivo de la herencia es, a
      veces, la solución perfecta a su problema. Sin embargo,
      [FIXME:should look closely] a la posibilidad de que su clase
      base puede necesitar también funciones adicionales. Este proceso
      de descubrimiento e iteración de su diseño ocurre regularmente
      en la programación orientada a objetos.
    </para>
 
    <!--
    Although inheritance may sometimes imply that you are going to add new
    functions to the interface, that’s not necessarily true. The second
    and more important way to differentiate your new class is to change
    the behavior of an existing base-class function. This is referred to
    as overriding that function.
    -->

    <para>
      Aunque la herencia algunas veces supone que se van a añadir
      nuevas funciones a la interfaz, esto no es necesariamente
      verdad. El segundo y más imporante camino para diferenciar su
      nueva clase es <emphasis>cambiar</emphasis> el comportamiento de
      una función de una clase base existente. Es referenciado como
      una función <emphasis>primordial</emphasis>.
    </para>

    <!--
    To override a function, you simply create a new definition for the
    function in the derived class. You’re saying, “I’m using the same
    interface function here, but I want it to do something different for
    my new type.”
    -->

    <para>
      Para anular una función, simplemente hay que crear una nueva
      definición para una función en la clase derivada. Está diciendo,
      <quote>Estoy usando la misma función de interfaz aquí,
      pero quiero hacer algo diferente para mi nuevo tipo</quote>.
    </para>



  </sect1>
  
  <sect1>
    <title>Objetos intercambiables gracias al polimorfismo</title>
    <para></para>    
  </sect1>
  
  <sect1>
    <title>Creación y destrucción de objetos</title>
    <para></para>    
  </sect1> 

  <sect1>
    <title>Gestión de excepciones: tratamiento de errores</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Análisis y diseño</title>
    <para></para>   
  </sect1>
    
  <sect1>
    <title>Programación Extrema</title>
    <para></para>    
  </sect1>

  <sect1>
    <title>Porqué triunfa C++</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Estrategias para la transición</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para></para>  
  </sect1>

</chapter>


  