<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C1">
  
  <!--
  1: Introduction to Objects
  -->

  <title>Introducción a los Objetos</title>

  <!-- 
  The genesis of the computer revolution was in a machine. The genesis
  of our programming languages thus tends to look like that machine.
  -->

  <highlights>
    <para>
      La génesis de los lenguajes de la revolución informática ocurrió
      dentro de una máquina. Por tanto, la génesis de nuestros
      lenguajes de programación tiende a parecerse a esa máquina.
    </para>
  </highlights>

  <!--
  But computers are not so much machines as they are mind
  amplification tools ("bicycles for the mind", as Steve Jobs is fond
  of saying) and a different kind of expressive medium. As a result,
  the tools are beginning to look less like machines and more like
  parts of our minds, and also like other expressive mediums such as
  writing, painting, sculpture, animation, and
  filmmaking. Object-oriented programming is part of this movement
  toward using the computer as an expressive medium.
  -->

  <para>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente (<quote>bicicletas para la
    mente</quote>), como le gusta decir a decir Steve Jobs) y una
    manera diferente de medio de expresión.  Como resultado, las
    herramientas empiezan a parecerse menos a las máquinas y más a
    partes de nuestra mente, y también a otros medios de expresión
    como la escritura, la pintura, la escultura, la animación y la
    cinematografía. La programación orientada a objetos es parte de
    este movimiento hacia un uso del ordenador como medio de
    expresión.
  </para>

  <!--
  This chapter will introduce you to the basic concepts of
  object-oriented programming (OOP), including an overview of OOP
  development methods. This chapter, and this book, assume that you
  have had experience in a procedural programming language, although
  not necessarily C. If you think you need more preparation in
  programming and the syntax of C before tackling this book, you
  should work through the "Thinking in C: Foundations for C++ and
  Java" training CD ROM, bound in with this book and also available at
  www.BruceEckel.com.
  -->

  <para>
    Este capítulo le servirá de introducción a los conceptos básicos
    de la programación orientada a objetos (POO), incluyendo un
    resumen de los métodos de desarrollo de la POO. Este capítulo, y
    este libro, suponen que usted tiene ya experiencia con un lenguaje
    de programación procedural, aunque no sea necesariamente C. Si
    cree que necesita más preparación en programación y en la sintaxis
    de C antes de abordar este libro, debería mirarse el CD-ROM de
    entrenamiento <citetitle>Thinking in C: Foundations for C++ and
    Java</citetitle>, que viene junto con este libro, y también está
    disponible en <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
  </para>

  <!--
  This chapter is background and supplementary material. Many people
  do not feel comfortable wading into object-oriented programming
  without understanding the big picture first. Thus, there are many
  concepts that are introduced here to give you a solid overview of
  OOP. However, many other people don't get the big picture concepts
  until they've seen some of the mechanics first; these people may
  become bogged down and lost without some code to get their hands
  on. If you're part of this latter group and are eager to get to the
  specifics of the language, feel free to jump past this chapter-
  skipping it at this point will not prevent you from writing programs
  or learning the language. However, you will want to come back here
  eventually to fill in your knowledge so you can understand why
  objects are important and how to design with them.
  -->

  <para>
    Este capítulo es material básico y suplementario. Mucha gente no
    se siente cómoda adentrándose en la programación orientada a
    objetos sin tener antes una visión global. Por tanto, aquí se
    introducen muchos conceptos para darle una visión sólida de la
    POO. Sin embargo, mucha otra gente no capta los conceptos globales
    hasta que no han visto parte de la mecánica primero; esta gente
    puede atascarse y perderse sin algún trozo de código al que
    ponerle las manos encima. Si usted es parte de este último grupo,
    y está ansioso por llegar a las especificaciones del lenguaje,
    siéntase libre de saltarse este capítulo; esto no le impedirá
    escribir programas o aprender el lenguaje. Sin embargo, quizá
    quiera volver a este capítulo para completar sus conocimientos y
    poder comprender porqué son importantes los objetos y cómo diseñar
    con ellos.
  </para>

  <sect1>

  <!--
  The progress of abstraction
  -->

    <title>El progreso de abstracción</title>

  <!--
    All programming languages provide abstractions. It can be argued
    that the complexity of the problems you're able to solve is
    directly related to the kind and quality of abstraction. By "kind"
    I mean, "What is it that you are abstracting?" Assembly language
    is a small abstraction of the underlying machine. Many so-called
    "imperative" languages that followed (such as Fortran, BASIC, and
    C) were abstractions of assembly language. These languages are big
    improvements over assembly language, but their primary abstraction
    still requires you to think in terms of the structure of the
    computer rather than the structure of the problem you are trying
    to solve. The programmer must establish the association between
    the machine model (in the "solution space", which is the place
    where you're modeling that problem, such as a computer) and the
    model of the problem that is actually being solved (in the
    "problem space", which is the place where the problem exists). The
    effort required to perform this mapping, and the fact that it is
    extrinsic to the programming language, produces programs that are
    difficult to write and expensive to maintain, and as a side effect
    created the entire "programming methods" industry.
  -->

    <para>
      Todos los lenguajes de programación proporcionan
      abstracciones. Se puede afirmar que la complejidad de los
      problemas que se pueden resolver está relacionada directamente
      con el tipo y calidad de la abstracción. Por <quote>tipo</quote>
      me refiero a <quote>Â¿Qué es lo que está abstrayendo?</quote>. El
      lenguaje ensamblador es una pequeña abstracción de la máquina
      subyacente. Muchos lenguajes llamados <quote>imperativos</quote>
      que siguieron (como Fortran, BASIC y C) eran abstracciones del
      lenguaje ensamblador. Estos lenguajes son grandes mejoras con
      respecto al lenguaje ensamblador, pero su abstracción primaria
      todavía requiere que usted piense en términos de la estructura
      de la computadora, en lugar de la estructura del problema que
      intenta resolver. El programador debe establecer la asociación
      entre el modelo de la máquina (en el <quote>espacio de
      soluciones</quote>, que es el lugar donde está modelando ese
      problema, como un ordenador) y el modelo del problema que se
      está resolviendo (en el <quote>espacio de problemas</quote>, que
      es el lugar donde existe el problema). El esfuerzo requerido
      para realizar esta correspondencia, y el hecho de que sea
      extrínseco al lenguaje de programación, produce programas que
      son difíciles de escribir y caros de mantener y, como efecto
      secundario, creó toda la industria de <quote>métodos de
      programación</quote>.
    </para>

  <!--
    The alternative to modeling the machine is to model the problem
    you're trying to solve. Early languages such as LISP and APL chose
    particular views of the world ("All problems are ultimately lists"
    or "All problems are algorithmic"). PROLOG casts all problems into
    chains of decisions. Languages have been created for
    constraint-based programming and for programming exclusively by
    manipulating graphical symbols. (The latter proved to be too
    restrictive.) Each of these approaches is a good solution to the
    particular class of problem they' designed to solve, but when you
    step outside of that domain they become awkward.
  -->

    <para>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como el LISP y
      el APL eligieron concepciones del mundo particulares
      (<quote>Todos los problemas son listas en última
      instancia</quote>, o <quote>Todos los problemas son
      algorítmicos</quote>). El PROLOG reduce todos los problemas a
      cadenas de decisiones. Se han creado lenguajes para programación
      basada en restricciones y para programar manipulando
      exclusivamente símbolos gráficos (el último demostró ser
      demasiado restrictivo). Cada uno de estos métodos es una buena
      solución para el tipo particular de problema para el que fueron
      diseñados, pero cuando uno se sale de ese dominio se hacen
      difíciles de usar.
    </para>
      
  <!--
    The object-oriented approach goes a step farther by providing
    tools for the programmer to represent elements in the problem
    space. This representation is general enough that the programmer
    is not constrained to any particular type of problem. We refer to
    the elements in the problem space and their representations in the
    solution space as "objects". (Of course, you will also need other
    objects that don't have problem-space analogs.) The idea is that
    the program is allowed to adapt itself to the lingo of the problem
    by adding new types of objects, so when you read the code
    describing the solution, you're reading words that also express
    the problem. This is a more flexible and powerful language
    abstraction than what we've had before. Thus, OOP allows you to
    describe the problem in terms of the problem, rather than in terms
    of the computer where the solution will run. There's still a
    connection back to the computer, though. Each object looks quite a
    bit like a little computer; it has a state, and it has operations
    that you can ask it to perform. However, this doesn't seem like
    such a bad analogy to objects in the real world; they all have
    characteristics and behaviors.
  -->

    <para>
      El método orientado a objetos va un paso más allá,
      proporcionando herramientas para que el programador represente
      los elementos en el espacio de problemas. Esta representación es
      lo suficientemente general para que el programador no esté
      limitado a ningún tipo particular de problema. Nos referimos a
      los elementos en el espacio de problemas, y a sus
      representaciones en el espacio de soluciones, como
      <quote>objetos</quote>. (Por supuesto, necesitará otros objetos
      que no tengan analogías en el espacio del problema.)  La idea es
      que se permita al programa adaptarse al FIXME:lingo del problema
      añadiendo nuevos tipos de objetos de modo que cuando lea el
      código describiendo la solución, está leyendo palabras que
      además expresan el problema. Este es el lenguaje de abstracción
      más flexible y potente que haya usado antes. De esta manera, la
      POO permite describir el problema en términos del problema, en
      lugar de usar términos de la computadora en la que se ejecutará
      la solución. Sin embargo, todavía existe una conexión con la
      computadora. Cada objeto se parece un poco a una pequeña
      computadora; tiene un estado, y operaciones que se le puede
      pedir hacer. Sin embargo, no parece una mala analogía a los
      objetos en el mundo real; todos tienen características y
      comportamientos.
    </para>

    <!--
    Some language designers have decided that object-oriented
    programming by itself is not adequate to easily solve all
    programming problems, and advocate the combination of various
    approaches into multiparadigm programming languages.[4]See
    Multiparadigm Programming in Leda by Timothy Budd (Addison-Wesley
    1995).
    -->

    <para>
      Algunos diseñadores de lenguajes han decidido que la
      programación orientada a objetos en sí misma no es adecuada para
      resolver fácilmente todos los problemas de programación, y
      abogan por una combinación de varias aproximaciones en lenguajes
      de programación <emphasis>multiparadigma</emphasis>. <footnote>
      <para>Ver <emphasis>Multiparadigm Programming in Leda</emphasis>
      de <personname><firstname>Timothy</firstname>
      <surname>Budd</surname></personname> (Addison-Wesley
      1995).</para>
      </footnote>
    </para>
  
    <!--
    Alan Kay summarized five basic characteristics of Smalltalk, the
    first successful object-oriented language and one of the languages
    upon which C++ is based. These characteristics represent a pure
    approach to object-oriented programming:
    -->

    <para>
      <personname><firstname>Alan</firstname>
      <surname>Kay</surname></personname> resumió las cinco
      características básicas de Smalltalk, el primer lenguaje
      orientado a objetos exitoso y uno de los lenguajes en los que
      está basado C++. Esas características representan un
      aproximación a la programación orientada a objetos:
    </para>
    
    <!--

    1. Everything is an object. Think of an object as a fancy variable; it
    stores data, but you can "make requests" to that object, asking it
    to perform operations on itself. In theory, you can take any
    conceptual component in the problem you're trying to solve (dogs,
    buildings, services, etc.) and represent it as an object in your
    program.
    -->

    <orderedlist>
      <listitem>
	<para>
	  Todo es un objeto. Pensar en un objeto como una variable
	  elaborada; almacena datos, pero puede <quote>hacer
	  peticiones</quote> a este objeto, pidiendo que realice
	  operaciones en sí mismo. En teoría, puede coger cualquier
	  componente conceptual del problema que está intentando
	  resolver (perros, edificios, servicios, etc.) y
	  representarlo como un objeto en su programa.
	</para>
      </listitem>

   
    <!--
    2. A program is a bunch of objects telling each other what to do
      by sending messages. To make a request of an object, you "send a
      message" to that object. More concretely, you can think of a
      message as a request to call a function that belongs to a
      particular object.
    -->

     <listitem>
	<para>
	  Un programa es un grupo de objetos enviando mensajes a otros
	  para decirles qué hacer. Para hacer una petición a un
	  objeto, <quote>envía un mensaje</quote> a ese objeto. Más
	  concretamente, puede pensar en un mensaje como una petición
	  de invocación a una función que pertenece a un objeto
	  particular.
	</para>
      </listitem>

    <!--
   3. Each object has its own memory made up of other objects. Put
      another way, you create a new kind of object by making a package
      containing existing objects. Thus, you can build complexity in a
      program while hiding it behind the simplicity of objects.
    -->

     <listitem>
	<para>
	  Cada objeto tiene su propia memoria hecha a base de otro
	  objetos. Visto de otra manera, puedes crear un nuevo tipo de
	  objeto haciendo un paquete que contiene objetos
	  existentes. Por consiguiente, puede construir de forma
	  compleja en un programa ocultando la complejidad de los
	  objetos.
	</para>
      </listitem>

    <!--
   4. Every object has a type. Using the parlance, each object is an
      instance of a class, in which "class" is synonymous with "type."
      The most important distinguishing characteristic of a class is
      "What messages can you send to it?"
    -->

      <listitem>
	<para>
	  Cada objeto es un tipo. Usando el FIXME:parlance, cada
	  objeto es una instancia de una clase, en el que
	  <quote>clase</quote> es sinónimo de <quote>tipo</quote>. La
	  característica más importante que lo distingue de una clase
	  es <quote>Â¿Qué mensajes puede enviarle?</quote>
	</para>
      </listitem>

    <!--
    5. All objects of a particular type can receive the same
    messages. This is actually a loaded statement, as you will see
    later. Because an object of type "circle" is also an object of
    type "shape," a circle is guaranteed to accept shape
    messages. This means you can write code that talks to shapes and
    automatically handles anything that fits the description of a
    shape. This substitutability is one of the most powerful concepts
    in OOP.
    -->

      <listitem>
	<para>
	  Todos los objetos de un tipo particular pueden recibir los
	  mismos mensajes. Es realmente una declaración con doble
	  sentido, como se verá más tarde. Porque un objeto de tipo
	  <classname>círculo</classname> es también un objeto de tipo
	  <classname>figura</classname>, está garantizado que un
	  círculo recibirá los mensajes de figura. Esto significa que
	  puede escribir código que habla con objetos
	  <classname>figura</classname> y automáticamente funciona con
	  cualquier otro objeto que coincida con la descripción de
	  <classname>figura</classname>. Esta
	  <emphasis>sustitutabilidad</emphasis> es una de los más
	  poderosos conceptos en la POO.
	</para>
      </listitem>
    </orderedlist>


  </sect1>

  <sect1>

    <!--
    An object has an interface
    -->
      <title>Un objeto tiene una interfaz</title>

    <!--
    Aristotle was probably the first to begin a careful study of the
    concept of type; he spoke of "the class of fishes and the class of
    birds."  The idea that all objects, while being unique, are also
    part of a class of objects that have characteristics and behaviors
    in common was used directly in the first object-oriented language,
    Simula-67, with its fundamental keyword class that introduces a
    new type into a program.
    -->
    

    <para>
    Aristóteles probablemente fue el primero en hacer un estudio minucioso
    del concepto de <emphasis>tipo</emphasis>; él habló de <quote>las
    clases de peces y las clases de pájaros</quote>. La idea de que todos
    los objetos, aún siendo únicos, también son parte de una clase de
    objetos que tienen características y comportamientos comunes se
    utilizó directamente en el primer lenguaje orientado a objetos,
    Simula-67, con su palabra reservada <keyword>class</keyword> que
    introduce un nuevo tipo en un programa.
    </para>

    <!-- 
    Simula, as its name implies, was created for developing simulations
    such as the classic "bank teller problem[5]." In this, you have
    a bunch of tellers, customers, accounts, transactions, and units
    of money - a lot of "objects". Objects that are identical except
    for their state during a program's execution are grouped
    together into "classes of objects" and that's where the keyword
    class came from. Creating abstract data types (classes) is a
    fundamental concept in object-oriented programming. Abstract
    data types work almost exactly like built-in types: You can
    create variables of a type (called objects or instances in
    object-oriented parlance) and manipulate those variables (called
    sending messages or requests; you send a message and the object
    figures out what to do with it). The members (elements) of each
    class share some commonality: every account has a balance, every
    teller can accept a deposit, etc. At the same time, each member
    has its own state, each account has a different balance, each
    teller has a name. Thus, the tellers, customers, accounts,
    transactions, etc., can each be represented with a unique entity
    in the computer program. This entity is the object, and each
    object belongs to a particular class that defines its
    characteristics and behaviors.
    -->


    <!--
    [5] You can find an interesting implementation of this problem in
    Volume 2 of this book, available at www.BruceEckel.com.
    -->

    <para>
      Simula, como su nombre indica, fue creado para desarrollar
      simulaciones como el clásico FIXME:<quote>back teller
      problem</quote><footnote>
	<para>
	  Puede encontrar una interesante implementación de este
	  problema en el 2Âº Volumen de este libro, disponible en
	  <ulink
	  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>
	</para>
      </footnote>
      En él, tiene un grupo de cajeros, clientes, cuentas,
      transacciones, y unidades de moneda -- un montón de
      <quote>objetos</quote>. Los objetos que son idénticos
      exceptuando su estado durante la ejecución del programa se
      agrupan juntos en <quote>clases de objetos</quote> y de ahí es
      de donde viene la palabra clave <keyword>class</keyword>. Crear
      tipos de datos abstractos (clases) es un concepto fundamental en
      la programación orientada a objetos. Los tipos de datos
      abstractos trabajan casi exactamente como tipos empotrados:
      puede crear variables de un tipo (llamados
      <emphasis>objetos</emphasis> o <emphasis>instancias</emphasis>
      en el argot de la programación orientada a objetos) y manipular
      estas variables FIXME:(llamadas <emphasis>sending
      messages</emphasis> o <emphasis>requests</emphasis>; envía un
      mensaje y the object figures out what to do with it). Los
      miembros (elementos) de cada clase comparten FIXME: some
      commonality: cada cuenta tiene un balance, cada cajero puede
      aceptar un depósito, etc. Al mismo tiempo, cada miembro tiene su
      propio estado, cada cuenta tiene un balance diferente, cada
      cajero tiene un nombre. De esta manera, los cajeros, clientes,
      cuentas, transacciones, etc., cada uno puede ser representado
      con una única entidad en el programa de computadora. Esta
      entidad es un objeto, y cada objeto pertenece a una clase
      particular que define sus características y comportamientos.
      </para>
  </sect1>

  <sect1>

    <!--
    The hidden implementation
    -->
    <title>La implementación oculta</title>

    <!--
    It is helpful to break up the playing field into class creators
    (those who create new data types) and client programmers[7] (the
    class consumers who use the data types in their applications). The
    goal of the client programmer is to collect a toolbox full of
    classes to use for rapid application development. The goal of the
    class creator is to build a class that exposes only what's
    necessary to the client programmer and keeps everything else
    hidden. Why? Because if it's hidden, the client programmer can't
    use it, which means that the class creator can change the hidden
    portion at will without worrying about the impact to anyone
    else. The hidden portion usually represents the tender insides of
    an object that could easily be corrupted by a careless or
    uninformed client programmer, so hiding the implementation reduces
    program bugs. The concept of implementation hiding cannot be
    overemphasized.
    -->

   <para>
      Es útil distinguir entre los <emphasis>creadores de
      clases</emphasis> (aquellos que crean nuevos tipos de datos) y
      <emphasis>programadores clientes[7]</emphasis> (los consumidores
      de clases que usan los tipos de datos en sus aplicaciones). El
      objetivo del programador cliente es acumular una caja de
      herramientas llena de clases que usar para un desarrollo rápido de
      aplicaciones. El objetivo del creador de clases es construir una
      clase que exponga sólo lo necesario para el programador cliente y
      mantiene todo lo demás oculto. ¿Por qué? Porque si está oculto,
      el programador cliente no puede usarlo, lo cual significa que el
      creador de clases puede cambiar la parte oculta sin preocuparse de
      las consecuencia sobre los demás. La parte oculta suele
      representar las interioridades delicadas de un objeto que podría
      fácilmente corrompida por un programador cliente descuidado o
      desinformado, así que ocultando la implementación se reducen los
      errores de programación. No se debe abusar del concepto de
      implementación oculta.
    </para>

    <!--
    In any relationship it's important to have boundaries that are
    respected by all parties involved. When you create a library, you
    establish a relationship with the client programmer, who is also a
    programmer, but one who is putting together an application by
    using your library, possibly to build a bigger library.
    -->

    <para>
      En cualquier relación es importante tener límites que sean
      respetadas por todas las partes involucradas. Cuando se cree una
      librería, se establece una relación con el programador cliente,
      quien también es programador, porque puede estar utilizando la
      librería para crear a su vez una librería mayor.
    </para>


    <!--
    If all the members of a class are available to everyone, then the
    client programmer can do anything with that class and there's no
    way to enforce rules. Even though you might really prefer that the
    client programmer not directly manipulate some of the members of
    your class, without access control there's no way to prevent
    it. Everything's naked to the world.
    -->

    <para>
      Si todos los miembros de una clase están disponibles para
      cualquiera, entonces el programador cliente puede hacer
      cualquier cosa con la clase y no hay forma de imponer las
      reglas. Incluso si prefiere que el programador cliente no
      manipule directamente algunos de los miembros de su clase, son
      control de acceso no hay forma de impedirlo. Nadie está a salvo.
    </para>

   <!--
    So the first reason for access control is to keep client
    programmers'hands off portions they shouldn't touch - parts that
    are necessary for the internal machinations of the data type but
    not part of the interface that users need in order to solve their
    particular problems. This is actually a service to users because
    they can easily see what's important to them and what they can
    ignore.
    -->

    <para>
      Por eso la principal razón del control de acceso es impedir que
      el cliente toque las partes que no debería - partes que son
      necesarias para los mecanismos internos de los tipos de datos
      pero no parte de la interfaz que los usuarios necesitan para
      resolver sus problemas particulares. Realmente esto es un
      servicio para los usuarios porque pueden ver fácilmente qué es
      importante para ellos y qué pueden ignorar.
    </para>

    <!--
    The second reason for access control is to allow the library
    designer to change the internal workings of the class without
    worrying about how it will affect the client programmer. For
    example, you might implement a particular class in a simple
    fashion to ease development, and then later discover that you need
    to rewrite it in order to make it run faster. If the interface and
    implementation are clearly separated and protected, you can
    accomplish this easily and require only a relink by the user.
    -->

    <para>
      La segunda razón para el control de acceso es permitir al
      diseñador de la librería cambiar los trabajos internos de la
      clase sin preocuparse de cómo afectará a los programadores
      clientes. Por ejemplo, podría implementar una clase particular
      de una manera sencilla para un desarrollo fácil, y más tarde
      descubrir que necesita reescribirla para hacerla más rápida. Si
      la interfaz y la implementación están claramente separadas y
      protegidas, puede conseguirlo fácilmente y sólo requiere que el
      usuario vuelva a enlazar la aplicación.
    </para>

    <!--
    C++ uses three explicit keywords to set the boundaries in a class:
    public, private, and protected. Their use and meaning are quite
    straightforward. These access specifiers determine who can use the
    definitions that follow. public means the following definitions
    are available to everyone. The private keyword, on the other hand,
    means that no one can access those definitions except you, the
    creator of the type, inside member functions of that type. private
    is a brick wall between you and the client programmer. If someone
    tries to access a private member, they'll get a compile-time
    error. protected acts just like private, with the exception that
    an inheriting class has access to protected members, but not
    private members. Inheritance will be introduced shortly.
    -->

    <para>
      C++ utiliza tres palabras reservadas explícitas para poner
      límites en una clase: <keyword>public</keyword>,
      <keyword>private</keyword>, y <keyword>protected</keyword>. Su
      uso y significado son bastante sencillos. Estos
      <emphasis>especificadores de acceso</emphasis> determinan quien
      usa las definiciones que siguen. <keyword>public</keyword>
      significa que las definiciones posteriores están disponibles
      para cualquiera. La palabra reservada
      <keyword>private</keyword>, por otro lado, significa que nadie
      puede acceder a estas definiciones excepto el creador del tipo,
      es decir, los métodos internos de la
      clase. <keyword>private</keyword> es una pared entre el creador
      de la clase y el programador cliente. Si alguien intenta acceder
      a un miembro privado, obtendrá un error al
      compilar. <keyword>protected</keyword> actúa como
      <keyword>private</keyword>, con la excepción de que las clases
      [FIXME: herederas] tienen acceso a miembros protegidos, pero no
      a los privados. La herencia se explicará en breve.
    </para>


  </sect1>

  <sect1>

    <!--
    Reusing the implementation
    -->

    <title>Reutilizando la implementación</title>

    <!--
    Once a class has been created and tested, it should (ideally)
    represent a useful unit of code. It turns out that this
    reusability is not nearly so easy to achieve as many would hope;
    it takes experience and insight to produce a good design. But once
    you have such a design, it begs to be reused. Code reuse is one of
    the greatest advantages that object-oriented programming languages
    provide.
    -->

    <para>
      Una vez que una clase ha sido creada y probada, debería
      (perfectamente) representar una unidad útil de código. Eso
      [FIXME:turns out that] esta reusabilidad casi no es tan fácil de
      conseguir como muchos [FIXME:would hope]; coge experiencia y
      entendimiento para producir un buen diseño. Pero una vez que
      tiene semejante diseño, éste pide ser reutilizado. El código
      reutilizado es una de las mejores ventajas de los lenguajes de
      programación orientada a objetos.
    </para>


    <!--
    The simplest way to reuse a class is to just use an object of that
    class directly, but you can also place an object of that class
    inside a new class. We call this "creating a member object". Your
    new class can be made up of any number and type of other objects,
    in any combination that you need to achieve the functionality
    desired in your new class. Because you are composing a new class
    from existing classes, this concept is called composition (or more
    generally, aggregation). Composition is often referred to as a
    "has-a" relationship, as in "a car has an engine".
    -->
    
    <para>
      La forma más fácil de reutilizar una clase es precisamente
      utilizar un objeto de esa clase directamente, pero también puede
      colocar un objeto de esta clase dentro de una clase
      nueva. Podemos llamarlo [FIXME:<quote>crear un objeto miembro</quote>]. Su
      nueva clase puede estar compuesta de algún número y tipo de
      otros objetos, en alguna combinación que necesite para conseguir
      la funcionalidad deseada en su nueva clase. Porque está
      componiendo una nueva clase desde clases existentes, este
      concepto se llama <emphasys>composition</emphasys> (o más
      generalmente, <emphasys>aggregation</emphasys>. [FIXME:
      Composition is often referred to as a <quote>has-a</quote> relationship, as
      in <quote>a car has an engine</quote>].
    </para>


    <!--
    (The above UML diagram indicates composition with the filled
    diamond, which states there is one car. I will typically use a
    simpler form: just a line, without the diamond, to indicate an
    association.[8])

    [8] This is usually enough detail for most diagrams, and you don't
    need to get specific about whether you're using aggregation or
    composition.
    -->

    <para>
      (El diagrama UML superior indica composición con [FIXME: the
      filled diamond, which states there is one car]. Típicamente se
      usará una forma simple: [FIXME:just] una línea, sin [FIXME: the
      diamond], para indicar una asociación.[FIXME: [8]]).
      
      [8] El bastante habitual detallar para más diagramas, y no
      necesita [FIXME:to get specific] sobre si está usando agregación
      o composición.
    </para>


    <!--
    Composition comes with a great deal of flexibility. The member
    objects of your new class are usually private, making them
    inaccessible to the client programmers who are using the
    class. This allows you to change those members without disturbing
    existing client code. You can also change the member objects at
    runtime, to dynamically change the behavior of your
    program. Inheritance, which is described next, does not have this
    flexibility since the compiler must place compile-time
    restrictions on classes created with inheritance.
    -->

    <para>
      La composición viene con una gran [FIXME: deal] de
      flexibilidad. Los objetos miembros de su nueva clase son
      habitualmente privados, haciéndolos inaccesibles para los
      programadores clientes que están usando la clase. Esto permite
      cambiar esos miembros sin [FIXME:disturbing existing] código
      cliente. También puede cambiar los objetos miembros [FIXME:at
      runtime], para cambiar dinámicamente el comportamiento de su
      programa. La herencia, descrita más delante, no tiene esta
      flexibilidad desde el compilador [FIXME:must place compile-time]
      restricciones en clases creadas con herencia.
    </para>
    

    <!--
    Because inheritance is so important in object-oriented programming
    it is often highly emphasized, and the new programmer can get the
    idea that inheritance should be used everywhere. This can result
    in awkward and overly-complicated designs. Instead, you should
    first look to composition when creating new classes, since it is
    simpler and more flexible. If you take this approach, your designs
    will stay cleaner. Once you've had some experience, it will be
    reasonably obvious when you need inheritance.
    -->
    
    <para>
      Porque la herencia es tan importante en la programación
      orientada a objetos, esto sumamente emfatizado, y el nuevo
      programador puede tener la idea de que la herencia debería ser
      usada en todas partes. Esto puede dar como resultado diseños
      torpes y demasiado complicados. En cambio, debería mirar primero
      la composición cuando cree nuevas clases, ya que es más simple y
      flexible. Si acepta esta propuesta, sus diseños serán más
      limpios. Una vez que tenga experiencia, será razonablemente
      evidente cuando necesite herencia.
    </para>


  </sect1>

  <sect1>
   <!--
    Inheritance:
    reusing the interface
    -->

    <title>Herencia: reutilización de interfaces</title>
  
    <!--
    By itself, the idea of an object is a convenient tool. It allows
    you to package data and functionality together by concept, so you
    can represent an appropriate problem-space idea rather than being
    forced to use the idioms of the underlying machine. These concepts
    are expressed as fundamental units in the programming language by
    using the class keyword.
    -->

    <para>
      Por sí misma, la idea de un objeto es una herramienta
      conveniente. Permite empaquetar datos y funcionalidad junto al
      concepto, además puede representar una idea apropiada
      [FIXME:problem-space] más que estar forzado a usar los idiomas de
      la máquina subyacente. Estos conceptos se ecpresan como unidades
      fundamentales en el lenguaje de programación mediante la palabra
      clave <keyword>class</keyword>.
    </para>

    <!-- 
    It seems a pity, however, to go to all the trouble to create
    a class and then be forced to create a brand new one that might
    have similar functionality. It's nicer if we can take the
    existing class, clone it, and then make additions and
    modifications to the clone. This is effectively what you get with
    inheritance, with the exception that if the original class (called
    the base or super or parent class) is changed, the modified
    "clone" (called the derived or inherited or sub or
    child class) also reflects those changes.  
    -->
    
    <para>
      Parece una pena, sin embargo, tomarse muchas molestias en crear
      una clase y ser forzado a crear un nuevo tipo puede tener
      similar funcionalidad. Es más sencillo si se pueden usar la
      clase existente, clonarla, y hacerle añadidos y modificaciones
      al clon. Esto es efectivamente lo que hace la
      <emphasis>herencia</emphasis>, con la excepción de que la clase
      original (llamada clase <classname>base</classname> o
      <classname>super</classname> o <classname>padre</classname>) se
      cambia, el <quote>clon</quote> modificado (llamado
      <emphasis>derivado</emphasis> o <emphasis>heredado</emphasis> o
      <emphasis>sub</emphasis> o clase <emphasis>hija</emphasis>)
      también refleja estos cambios.
   </para>


    <!--
    (The arrow in the above UML diagram points from the derived class
    to the base class. As you will see, there can be more than one
    derived class.)
    -->

    <para>
    (La flecha sobre el diagrama UML señala desde la clase derivada a
    la clase base. Como se puede ver, puede haber más de una clase derivada.)
    </para>
    

    <!--
    A type does more than describe the constraints on a set of objects; it
    also has a relationship with other types. Two types can have
    characteristics and behaviors in common, but one type may contain more
    characteristics than another and may also handle more messages (or
    handle them differently). Inheritance expresses this similarity
    between types using the concept of base types and derived types. A
    base type contains all of the characteristics and behaviors that are
    shared among the types derived from it. You create a base type to
    represent the core of your ideas about some objects in your
    system. From the base type, you derive other types to express the
    different ways that this core can be realized.
    -->

    <para>
      Un tipo hace más que describir las restricciones de un conjunto
      de objetos; también tiene una relación con otros tipos. Dos
      tipos pueden tener características y comportamientos en común,
      pero un tipo puede contener más características que otro y
      también puede manipular más mensajes (o hacerlo de forma
      diferente). La herencia expresa esto de forma similar entre
      tipos usando el concepto de tipos base y tipos derivados. Un
      tipo base contiene todas las características y comportamientos
      compartidos entre los tipos derivados [FIXME: from it]. Cree un
      tipo base para representar lo esencial de sus ideas sobre
      algunos objetos en su sistema. Del tipo base, derive otros tipos
      para expresar caminos diferentes que este núcleo puede realizar.
    </para>


    <!--
    For example, a trash-recycling machine sorts pieces of trash. The base
    type is "trash," and each piece of trash has a weight, a value, and so
    on, and can be shredded, melted, or decomposed. From this, more
    specific types of trash are derived that may have additional
    characteristics (a bottle has a color) or behaviors (an aluminum can
    may be crushed, a steel can is magnetic). In addition, some behaviors
    may be different (the value of paper depends on its type and
    condition). Using inheritance, you can build a type hierarchy that
    expresses the problem you're trying to solve in terms of its types.
    -->

    <para>
      Por ejemplo, una máquina de reciclado de basura clasifica piezas
      de basura. El tipo base es <quote>basura</quote> y otra pieza de
      basura tiene un peso, un valor, y tambié, puede ser triturada,
      fundida o descompuesta. [FIXME: From this], se obtienen más
      tipos específicos de basura que pueden tener características
      adicionales (una botella tiene un color) o comportamientos (el
      aluminio puede ser aplastado, el acero puede ser
      magnético). Además, algunos comportamientos puedes ser
      diferentes (el valor del papel depende del tipo y
      condición). Usando la herencia, se puede construir un tipo de
      jerarquía que exprese el problema que se intenta resolver en
      términos de sus tipos.
    </para>



    <!--
    A second example is the classic "shape" example, perhaps used in a
    computer-aided design system or game simulation. The base type is
    "shape," and each shape has a size, a color, a position, and so
    on. Each shape can be drawn, erased, moved, colored, etc. From this,
    specific types of shapes are derived (inherited): circle, square,
    triangle, and so on, each of which may have additional characteristics
    and behaviors. Certain shapes can be flipped, for example. Some
    behaviors may be different, such as when you want to calculate the
    area of a shape. The type hierarchy embodies both the similarities and
    differences between the shapes.
    -->

    <para>
      Un segundo ejemplo es el clásic ejemplo <classname>figura</classname>,
      tal vez usado en un [FIXME:computer-aided design system] o
      juegos de simulación. El tipo base es <classname>figura</classname>, y
      cada figura tiene un tamaño, un color, una posición y así
      sucesivamente. Cada figura puede ser dibujado, borrado, movido,
      coloreado, etc. [FIXME: From this], tipos específicos de figuras
      derivan (heredan): círculo, cuadrado, triángulo, y así
      sucesivamente, cada uno de ellos puede tener características y
      comportamientos adicionales. Ciertas figuras pueden ser, por
      ejemplo, volteadas. Algunos comportamientos pueden ser
      diferentes, como cuando se quiere calcular el área de una
      figura. La jerarquía tipo expresa las similitudes y las
      diferencias entre las figuras.
   </para>

    <!--
    Casting the solution in the same terms as the problem is tremendously
    beneficial because you don't need a lot of intermediate models to get
    from a description of the problem to a description of the
    solution. With objects, the type hierarchy is the primary model, so
    you go directly from the description of the system in the real world
    to the description of the system in code. Indeed, one of the
    difficulties people have with object-oriented design is that it's too
    simple to get from the beginning to the end. A mind trained to look
    for complex solutions is often stumped by this simplicity at first.
    -->

   <para>
      Emitir la solución en los mismos términos que el problema es
      tremendamente beneficios porque no se necesitan muchos modelos
      intermedios para tener desde una descripción del problema a una
      descripción de la solución. Con objetos, la jerarquía tipo es el
      principal modelo, va directamente desde la descripción del
      sistema en el mundo real a la descripción del sistema en
      código. Efectivamente, una de las dificultades de que gente
      tiene con el diseño orientado a objetos es que es muy simple
      [FIXME:to get] desde el principo hasta el final. Una mente
      entrenada para buscar soluciones complejas es a menudo
      confundida con la simplicidad al principio.
   </para>

    <!--
    When you inherit from an existing type, you create a new type. This
    new type contains not only all the members of the existing type
    (although the private ones are hidden away and inaccessible), but more
    importantly it duplicates the interface of the base class. That is,
    all the messages you can send to objects of the base class you can
    also send to objects of the derived class. Since we know the type of a
    class by the messages we can send to it, this means that the derived
    class is the same type as the base class. In the previous example, "a
    circle is a shape." This type equivalence via inheritance is one of
    the fundamental gateways in understanding the meaning of
    object-oriented programming.
    -->

    <para>
      Cuando hereda desde un tipo existente, se crea un tipo
      nuevo. Este nuevo tipo contiene no sólo todos los miembros del
      tipo existente (aunque [FIXME:the <emphasis>private</emphasis>
      ones] están ocultos e inaccesibles), pero más importante duplica
      la interfaz de la clase base. Es decir, todos los mensajes que
      se pueden enviar a los objetos de la clase base pueden enviarse
      también a los objetos de la clase derivada. Desde que se conoce
      el tipo de una clase por los mensajes que se le pueden enviar,
      esto significa que la clase derivada <emphasis>es del mismo tipo
      que la clase base</emphasis>. En el ejemplo anterior, <quote>un
      círculo es una figura</quote>. Este tipo equivante vía herencia
      es uno de las principales puertas para entender la programación
      orientada a objetos.
    </para>

    <!--
    Since both the base class and derived class have the same interface,
    there must be some implementation to go along with that
    interface. That is, there must be some code to execute when an object
    receives a particular message. If you simply inherit a class and don't
    do anything else, the methods from the base-class interface come right
    along into the derived class. That means objects of the derived class
    have not only the same type, they also have the same behavior, which
    isn't particularly interesting.
    -->

    <para>
      Desde que ambas clases, base y derivada, tienen la misma
      interfaz, debe haber alguna implementación que esté de acuerdo
      con esa interfaz. Es decir, debe haber código para ejecutar
      cuando un objeto recibe un mensaje particular. Si simplemente
      hereda una clase y no hace nada más, los métodos de la interfaz
      de la clase base [FIXME:come right along into] la clase
      derivada. Esto significa que los objetos de la clase derivada no
      sólo tienen el mismo tipo, también tienen el mismo
      comportamiento, el cual no es particularmente interesante.
    </para>

    <!--
    You have two ways to differentiate your new derived class from the
    original base class. The first is quite straightforward: You simply
    add brand new functions to the derived class. These new functions are
    not part of the base class interface. This means that the base class
    simply didn't do as much as you wanted it to, so you added more
    functions. This simple and primitive use for inheritance is, at times,
    the perfect solution to your problem. However, you should look closely
    for the possibility that your base class might also need these
    additional functions. This process of discovery and iteration of your
    design happens regularly in object-oriented programming.
   -->

    <para>
      Hay dos caminos para diferenciar la nueva clase derivada de la
      clase base original. El primero es bastante sencillo:
      simplemente hay que añadir nuevos tipos de funciones a la clase
      derivada. Estas nuevas funciones no son parte de la interfaz de
      la clase base. Esto significa que la clase base simplemente no
      hace tanto como necesitamos, por lo que se añaden más
      funciones. Este uso simple y primitivo de la herencia es, a
      veces, la solución perfecta a su problema. Sin embargo,
      [FIXME:should look closely] a la posibilidad de que su clase
      base puede necesitar también funciones adicionales. Este proceso
      de descubrimiento e iteración de su diseño ocurre regularmente
      en la programación orientada a objetos.
    </para>
 
    <!--
    Although inheritance may sometimes imply that you are going to add new
    functions to the interface, that's not necessarily true. The second
    and more important way to differentiate your new class is to change
    the behavior of an existing base-class function. This is referred to
    as overriding that function.
    -->

    <para>
      Aunque la herencia algunas veces supone que se van a añadir
      nuevas funciones a la interfaz, esto no es necesariamente
      verdad. El segundo y más imporante camino para diferenciar su
      nueva clase es <emphasis>cambiar</emphasis> el comportamiento de
      una función de una clase base existente. Es referenciado como
      una función <emphasis>primordial</emphasis>.
    </para>

    <!--
    To override a function, you simply create a new definition for the
    function in the derived class. You're saying, "I'm using the same
    interface function here, but I want it to do something different for
    my new type."
    -->

    <para>
      Para anular una función, simplemente hay que crear una nueva
      definición para una función en la clase derivada. Está diciendo,
      <quote>Estoy usando la misma función de interfaz aquí,
      pero quiero hacer algo diferente para mi nuevo tipo</quote>.
    </para>

    <!--
    Is-a vs. is-like-a relationships
    -->

    <para>
      Es-un versus es-como-un
    </para>

   <!--
    There's a certain debate that can occur about inheritance: Should
    inheritance override only base-class functions (and not add new member
    functions that aren't in the base class)? This would mean that the
    derived type is exactly the same type as the base class since it has
    exactly the same interface. As a result, you can exactly substitute an
    object of the derived class for an object of the base class. This can
    be thought of as pure substitution, and it's often referred to as the
    substitution principle. In a sense, this is the ideal way to treat
    inheritance. We often refer to the relationship between the base class
    and derived classes in this case as an is-a relationship, because you
    can say "a circle is a shape." A test for inheritance is to determine
    whether you can state the is-a relationship about the classes and have
    it make sense.
    -->

    <para>
      Hay un debate seguro que puede ocurrir sobre la herencia:
      ¿debería la herencia anular sólo funciones de la clase base (y
      no añadir nuevas funciones miembros que no estén en la clase
      base)? Esto puede significar que el tipo derivado es
      <emphasis>exactamente</emphasis> el mismo tipo que la clase base
      desde que tiene exactamente la misma interfaz. Como resultado,
      se puede sustituir un objeto de una clase derivada por un objeto
      de la clase base. Se puede pensar como una <emphasis>sustitución
      pura</emphasis>, y suele ser referida como la
      <emphasis>sustitución general</emphasis>. En cierto modo, este
      es el camino ideal para tratar la herencia. A menudo nos
      referimos a las relaciones entre la clase base y clases
      derivadas en este caso como una relación es-un, porque se dice
      <quote>un círculo es una figura</quote>. Una prueba para la
      herencia es determinar si se puede declarar la relación es-un
      sobre las clases y [FIXME: have it make sense].
    </para>

   <!--
    There are times when you must add new interface elements to a
    derived type, thus extending the interface and creating a new
    type. The new type can still be substituted for the base type, but
    the substitution isn't perfect because your new functions are not
    accessible from the base type. This can be described as an
    is-like-a relationship; the new type has the interface of the old
    type but it also contains other functions, so you can't really say
    it's exactly the same. For example, consider an air
    conditioner. Suppose your house is wired with all the controls for
    cooling; that is, it has an interface that allows you to control
    cooling. Imagine that the air conditioner breaks down and you
    replace it with a heat pump, which can both heat and cool. The
    heat pump is-like-an air conditioner, but it can do more. Because
    the control system of your house is designed only to control
    cooling, it is restricted to communication with the cooling part
    of the new object. The interface of the new object has been
    extended, and the existing system doesn't know about anything
    except the original interface.
    -->

    <para>
      Hay ocasiones en las que se deben añadir elementos a la nueva
      interfaz a un tipo derivado, de esta manera se amplía la
      interfaz y se crea un tipo nuevo. El nuevo tipo todavía puede
      ser sustituido por el tipo base, pero la sustitución no es
      perfecta porque sus nuevas funciones no son accesibles desde el
      tipo base. Esto puede ser descrito como una relación
      <emphasis>es-como-un</emphasis>; el nuevo tipo tiene la interfaz
      del viejo tipo, pero también contiene otras funciones, por lo
      que se puede decir que es exactamente el mismo. Por ejemplo,
      considere un aire acondicionado. Suponga que su casa está
      conectada con todos los controles [FIXME: for cooling]; es
      decir, tiene una interfaz que le permite controlar [FIXME:
      cooling]. Imagine que el aire acondicionado se avería y lo
      reemplaza por una bomba de calor, la cual puede dar calor y
      fría. La bomba de calor <emphasis>es-como-un</emphasis> aire
      acondicionado, pero puede hacer más cosas. Porque el sistema de
      control de su casa está diseñado sólo para controlar el frío,
      está rentrigida para comunicarse con la parte fría del nuevo
      objeto. La interfaz del nuevo objeto se ha extendido, y el
      sistema existente no conoce ninguna excepción de la interfaz
      original.
    </para>

   <!--
    Of course, once you see this design it becomes clear that the base
    class "cooling system" is not general enough, and should be renamed to
    "temperature control system" so that it can also include heating at
    which point the substitution principle will work. However, the diagram
    above is an example of what can happen in design and in the real
    world.
    -->

    <para>
      Por supuesto, una vez que ve este diseño se ve claro que la
      clase base <quote>sistema de frío</quote> no es bastante
      general, y puede ser renombrada a <quote>sistema de control de
      temperatura</quote> además también puede incluir [FIXME:heating]
      - en ete punto trabajará la sustitución principal. Sin embargo,
      el diagrama de arriba es un ejemplo de qué puede ocurrir en el
      diseño y en el mundo real.
    </para>

   <!--
    When you see the substitution principle it's easy to feel like this
    approach (pure substitution) is the only way to do things, and in fact
    it is nice if your design works out that way. But you'll find that
    there are times when it's equally clear that you must add new
    functions to the interface of a derived class. With inspection both
    cases should be reasonably obvious.
   -->

    <para>
      Cuando ve la sustitución principal es fácil entender cómo este
      acercamiento (sustitución pura) es el único camino para hacer
      cosas, y de hecho es bueno si sus diseños si entrena este
      camino. Pero encontrará qu hay ocasiones en que es igualmente
      claro que se debe añadir nuevas fnciones a la interfaz de la
      clase derivada. Con inspección ambos casos puede ser
      razonablemente obvio.
    </para>
  </sect1>
  
  <sect1>

    <!--
    Interchangeable objects with polymorphism
    -->

    <title>Objetos intercambiables gracias al polimorfismo</title>


    <!--
    When dealing with type hierarchies, you often want to treat an object
    not as the specific type that it is but instead as its base type. This
    allows you to write code that doesn't depend on specific types. In the
    shape example, functions manipulate generic shapes without respect to
    whether they're circles, squares, triangles, and so on. All shapes can
    be drawn, erased, and moved, so these functions simply send a message
    to a shape object; they don't worry about how the object copes with
    the message.
    -->

    <para>
      Cuando [FIXME: dealing] con tipos jerárquicos, se suele tratar
      un objeto no como el tipo específico que es en lugar de como un
      tipo base. Esto le permite escribir código que no depende de los
      tipos específicos. En el ejemplo de la figura, [FIXME: functions
      manipulate generic shapes]sin respetar si son círculos,
      cuadrados, triángulos, y así sucesivamente. Todas las figuras
      pueden ser dibujadas, borradas y movidas, pero estas funciones
      simplemente envían un mensaje a un objeto figura; no se preocupa
      sobre cómo el obejto se las arregla con este mensaje.
    </para>

   <!--
    Such code is unaffected by the addition of new types, and adding new
    types is the most common way to extend an object-oriented program to
    handle new situations. For example, you can derive a new subtype of
    shape called pentagon without modifying the functions that deal only
    with generic shapes. This ability to extend a program easily by
    deriving new subtypes is important because it greatly improves designs
    while reducing the cost of software maintenance.
    -->

    <para>
      Semejante código no está afectado por la adición de nuevos
      tipos, y añadir nuevos tipos es el camino más común para
      extender un programa orientado a objetos para tratar nuevas
      situaciones. Por ejemplo, puede derivar un nuevo subtipo de
      figura llamado pentágono sin modificar las funciones que tratan
      solo con figuras genéricas. Esta habilidad para extender un
      programa fácilmente derivando nuevos subtipos es importante
      porque mejora enormemente los diseños mientras se reduce el
      coste del mantenimiento del software.
    </para>

   <!--

    There's a problem, however, with attempting to treat derived-type
    objects as their generic base types (circles as shapes, bicycles
    as vehicles, cormorants as birds, etc.). If a function is going to
    tell a generic shape to draw itself, or a generic vehicle to
    steer, or a generic bird to move, the compiler cannot know at
    compile-time precisely what piece of code will be executed. That's
    the whole point when the message is sent, the programmer doesn't
    want to know what piece of code will be executed; the draw
    function can be applied equally to a circle, a square, or a
    triangle, and the object will execute the proper code depending on
    its specific type. If you don't have to know what piece of code
    will be executed, then when you add a new subtype, the code it
    executes can be different without requiring changes to the
    function call. Therefore, the compiler cannot know precisely what
    piece of code is executed, so what does it do? For example, in the
    following diagram the BirdController object just works with
    generic Bird objects, and does not know what exact type they
    are. 

This is convenient from BirdController's perspective, because
    it doesn't have to write special code to determine the exact type
    of Bird it's working with, or that Bird's behavior. So how does it
    happen that, when move( ) is called while ignoring the specific
    type of Bird, the right behavior will occur (a Goose runs, flies,
    or swims, and a Penguin runs or swims)?
    
    -->

    <para>
      Hay un problema, no obstante, con intentar tratar un tipo
      derivado como sus tipos base genéricos (círuclos como figuras,
      bicicletas como vehículos, cormorantes como pájaros, etc. Si una
      función va a indicar una figura genérica que se dibuje así
      misma. o a un vehículo genérico que se conduzca, o a un pájaro
      genérico que se mueva, el compilador no sabe en el [FIXME:
      compile-time] precisamente qué pieza del código será
      ejecutada. Este es el punto - cuando el mensaje se envía, el
      programador no <emphasis>quiere</emphasis> saber qué pieza del
      código será ejecutada; la función dibujar puede ser aplicada
      igualmente a un círculo, a un cuadrado, o a un triángulo, y el
      objeto ejecutará el código correcto dependiendo de tipo
      específico. Si no sabe qué pieza del código es ejecutada, ¿qué
      hace esto? Por ejemplo, en el siguiente diagrama el objeto
      <classname>BirdController</classname> trabaja con los objetos
      genéricos<classname>Bird</classname> , y no se sabe de qué tipo
      exactamente son. Esto es conveniente desde la perspectiva
      <classname>BirdController</classname>, porque no hay que
      escribir código especial para determinar el tipo exacto de
      <classname>Bird</classname> que está trabajando, o [FIXME: that
      Bird's behavior]. Entonces, ¿cómo ocurre esto cuando se llama a
      <function>move()</function> mientras se ignora el tipo
      específico de <classname>Bird</classname>, puede ocurrir el
      comportamiento correcto (un <classname>Ganso</classname> corre,
      vuela, o nada, y un <classname>Pingüino</classname> corre o
      nada)?
    </para>
    
   <!--
    The answer is the primary twist in object-oriented programming:
    The compiler cannot make a function call in the traditional
    sense. The function call generated by a non-OOP compiler causes
    what is called early binding, a term you may not have heard before
    because you've never thought about it any other way. It means the
    compiler generates a call to a specific function name, and the
    linker resolves this call to the absolute address of the code to
    be executed. In OOP, the program cannot determine the address of
    the code until runtime, so some other scheme is necessary when a
    message is sent to a generic object.
    -->

    <para>
      La respuesta es el primer [FIXME: twist] en la programación
      orientada a objetos: El compilador no hace una llamada a la
      función en el sentido tradicional. La llamada a la función
      generada por un compilador [FIXME: non-OOP] provoca que se llame
      [FIXME:early binding], un término que no quizá no haya oído
      antes porque nunca ha pensado en ningún otro camino. [FIXME: It
      means] el compilador genera una llamada al nombre de la función
      específica, y el [FIXME: linker] resuelve esta llamada en la
      dirección completa del código ejecutado. En OOP, el programa no
      determina la dirección del código hasta [FIXME: runtime], si
      alguna otra combinaicón es necesaria cuando el mensaje se envía
      a un objeto genérico.
    </para>

    <!--
    To solve the problem, object-oriented languages use the concept of
    late binding. When you send a message to an object, the code being
    called isn't determined until runtime. The compiler does ensure that
    the function exists and performs type checking on the arguments and
    return value (a language in which this isn't true is called weakly
    typed), but it doesn't know the exact code to execute.
    -->

    <para>
      Para resolver el problema, los lenguajes orientados a objetos
      usan el concepto de [FIXME: <emphasis>late
      binding</emphasis>]. Cuando envía un mensaje a un objeto, el
      código llamado no está determinado hasta [FIXME:runtime]. El
      compilador se asegura de que la función exite e interpreta el
      tipo viendo los argumentos y devolviendo un valor (un lenguaje
      [FIXME: in which this isn't true] llamado
      [FIXME:<emphasis>weakly typed</emphasis>), pero no sabe el
      código exacto a ejecutar.
    </para>


    <!--
    To perform late binding, the C++ compiler inserts a special bit of
    code in lieu of the absolute call. This code calculates the address of
    the function body, using information stored in the object (this
    process is covered in great detail in Chapter 15). Thus, each object
    can behave differently according to the contents of that special bit
    of code. When you send a message to an object, the object actually
    does figure out what to do with that message.
    -->

    <para>
      Para interpretar [FIXME: late binding], el compilador de C++
      inserta un trozo especial de código en lugar de la llamada
      absoluta. Este código calcula la dirección del cuerpo de la
      función, usando información almacenada en el objeto (este
      proceso está incluido al detalle en el Capítulo 15). De esta
      manera, cualquier objeto puede comportarse de forma diferente de
      acuerdo a los contenidos de este trozo especial de
      código. Cuando envía un mensaje a un objeto, el objeto realmente
      [FIXME: does figure out what to do] con este mensaje.
    </para>


    <!--
    You state that you want a function to have the flexibility of
    late-binding properties using the keyword virtual. You don't need
    to understand the mechanics of virtual to use it, but without it
    you can't do object-oriented programming in C++. In C++, you must
    remember to add the virtual keyword because, by default, member
    functions are not dynamically bound. Virtual functions allow you
    to express the differences in behavior of classes in the same
    family. Those differences are what cause polymorphic behavior.
    -->

    <para>
      Afirma que quiere una función para tener la flexibilidad de
      [FIXME: late-binding] propiedades usando la palabra reservada
      <keyword>virtual</keyword>. No necesita entender el mecanismo de
      <keyword>virtual</keyword> para usarla, pero sin ella no puede
      hacer programación orientada a objetos en C++. En C++, debe
      recordar añadir la palabra reservada <keyword>virtual</keyword>
      porque, por defecto, las funciones miembro
      <emphasis>no</emphasis> son vinculadas dinámicamente. Las
      funciones virtuales le permiten expresar las diferencias en
      comportamiento de clases en la misma familia. Estas diferencias
      son las que causan comportamientos polimórficos.
    </para>


    <!--
    Consider the shape example. The family of classes (all based on
    the same uniform interface) was diagrammed earlier in the
    chapter. To demonstrate polymorphism, we want to write a single
    piece of code that ignores the specific details of type and talks
    only to the base class. That code is decoupled from type-specific
    information, and thus is simpler to write and easier to
    understand. And, if a new type a Hexagon, for example is added
    through inheritance, the code you write will work just as well for
    the new type of Shape as it did on the existing types. Thus, the
    program is extensible.
    -->

    <para>
      Considere el ejemplo de la figura. La familia de clases (todas
      basadas en la misma interfaz uniforme) [FIXME: was diagrammed]
      antes en el capítulo. Para demostrar el polimorfismo, se quiere
      escribir una pieza única de código que ignore los detalles
      específicos de tipo y hable sólo de la clase base. Este código
      es [FIXME: <emphasis>decoupled</emphasis>] desde la información
      del tipo específico, y de esta manera es más simple escribir y
      más fácil de entender. Y, si tiene un nuevo tipo - un
      <classname>Hexágono</classname>, por ejemplo - se añade a través
      de la herencia, el código que escribe trabajará tan bien como
      para un nuevo tipo de <classname>Figura</classname> [FIXME: as
      it did on the existing types]. De esta manera, el programa es
      extensible.
    </para>


    <!--
    If you write a function in C++ (as you will soon learn how to do):
    -->

    <para>
      Si escribe una función C++ (podrá aprender dentro de poco cómo hacerlo):
      <programlisting>
	void doStuff(Shape& s) {
	s.erase();
	// ...
	s.draw();
	} 
      </programlisting>
    </para>


    <!--
    This function speaks to any Shape, so it is independent of the
    specific type of object that it's drawing and erasing (the '&' means
    "Take the address of the object that's passed to doStuff( )," but it's
    not important that you understand the details of that right now). If
    in some other part of the program we use the doStuff( ) function:
    -->

    <para>
      Esta función habla de alguna <classname>Figura</classname>, esto
      es tan independiente del tipo específico del objeto que es
      dibujado y borrado (el '<emphasis>&</emphasis>' significa
      <quote>Coge la dirección del objeto que se pasa por
      <function>doStuff()</function></quote>, pero no es importante
      que entienda los detalles ahora). Si en alguna otra parte del
      programa usamos la función <function>doStuff()</function>:
      <programlisting>
	Circle c;
	Triangle t;
	Line l;
	doStuff(c);
	doStuff(t);
	doStuff(l); 
      </programlisting>
    </para>


   <!--
    The calls to doStuff( ) automatically work right, regardless of the
    exact type of the object.
    -->

    <para>
      Las llamadas a <function>doStuff()</function> trabajan
      automáticamente bien, a pesar del tipo exacto del objeto.
    </para>


    <!--
    This is actually a pretty amazing trick. Consider the line:
    -->

    <para>
      En efecto esto es un bonito y asombroso truco. Considere la
      línea:
      <programlisting>
	doStuff(c);
      </programlisting>
    </para>


    <!--
    What's happening here is that a Circle is being passed into a function
    that's expecting a Shape. Since a Circle is a Shape it can be treated
    as one by doStuff( ). That is, any message that doStuff( ) can send to
    a Shape, a Circle can accept. So it is a completely safe and logical
    thing to do.
    -->

    <para>
      Lo que está ocurriendo aquí es que
      <classname>Círculo</classname> está pasando a una función que
      está esperando una <classname>Figura</classname>. Desde que un
      <classname>Círculo</classname> es una
      <classname>Figura</classname> puede ser tratado como uno por
      <function>doStuff()</function>. Es decir, ningún mensaje que
      <function>doStuff()</function> pueda enviar a una
      <classname>Figura</classname>, un <classname>Círculo</classname>
      puede aceptarlo. Esto es una cosa prudente y lógica que hacer.
    </para>
   

    <!-- 
    We call this process of treating a derived type as though it were its
    base type upcasting. The name cast is used in the sense of casting
    into a mold and the up comes from the way the inheritance diagram
    is typically arranged, with the base type at the top and the
    derived classes fanning out downward. Thus, casting to a base type
    is moving up the inheritance diagram: "upcasting".
    -->

    <para>
      Llamamos este proceso de prueba un tipo derivado como si fuera
      su tipo base [FIXME:<emphasis>upcasting</emphasis>]. El nombre
      [FIXME:<emphasis>cast</emphasis>] se usa en la sentencia de
      [FIXME: casting into a mold and the <emphasis>up</emphasis>
      comes from] el camino la herencia [FIXME:diagram] es típicamente
      ordenada, con el tipo base y a parte superior y las clases
      derivadas [FIXME: fanning out downward]. De esta manera, moldear
      un tipo base es mover hacia arriba la herencia [FIXME: diagram]:
      <quote>upcasting</quote>.
    </para>


    <!-- 
    An object-oriented program contains some upcasting somewhere, because
    that's how you decouple yourself from knowing about the exact type
    you're working with. Look at the code in doStuff( ):
    -->

    <para>
      Un programa orientado a objetos contiene algunos [FIXME:
      upcasting] en algún sitio, porque así es como [FIXME:decouple
      yourself] de saber sobre el tipo exacto con el que está
      trabajando. Mire el código en <function>doStuff()</function>:
      <programlisting>
	s.erase();
	// ...
	s.draw();
      </programlisting>
    </para>


    <!-- 
    Notice that it doesn't say "If you're a Circle, do this, if you're a
    Square, do that, etc." If you write that kind of code, which checks
    for all the possible types that a Shape can actually be, it's messy
    and you need to change it every time you add a new kind of
    Shape. Here, you just say "You're a shape, I know you can erase( ) and
    draw( ) yourself, do it, and take care of the details correctly."
    -->

    <para>
      Observe que no dice <quote>Si es un
      <classname>Círculo</classname>, haz esto, si es un
      <classname>Cuadrado</classname>, haz esto, etc.</quote>. Si
      escribe este tipo de código, el cual comprueba todos los
      posibles tipos que una <classname>Figura</classname> puede tener
      realmente, es desordenado y necesita cambiarlo cada vez que
      añade un nuevo tipo de <classname>Figura</classname>. Aquí, debe
      decir <quote>Es una figura, sé que se puede
      <function>erase()</function> y <function>draw()</function>, esto
      es, y ten cuidado de los detalles</quote>.
    </para>


    <!-- 
    What's impressive about the code in doStuff( ) is that, somehow, the
    right thing happens. Calling draw( ) for Circle causes different code
    to be executed than when calling draw( ) for a Square or a Line, but
    when the draw( ) message is sent to an anonymous Shape, the correct
    behavior occurs based on the actual type of the Shape. This is amazing
    because, as mentioned earlier, when the C++ compiler is compiling the
    code for doStuff( ), it cannot know exactly what types it is dealing
    with. So ordinarily, you'd expect it to end up calling the version of
    erase( ) and draw( ) for Shape, and not for the specific Circle,
    Square, or Line. And yet the right thing happens because of
    polymorphism. The compiler and runtime system handle the details; all
    you need to know is that it happens and more importantly how to design
    with it. If a member function is virtual, then when you send a message
    to an object, the object will do the right thing, even when upcasting
    is involved.
    -->

    <para>
      Lo impresionante del código en <function>doStuff()</function> es
      que, de alguna manera, ocurre lo correcto. Llamar a
      <function>draw()</function> para un
      <classname>Círculo</classname> provoca diferente código para ser
      ejecutado que cuando llama a <function>draw()</function> para un
      <classname>Cuadrado</classname> o una
      <classname>Línea</classname>, pero cuando el mensaje
      <function>draw()</function> es enviado a un
      <classname>Círculo</classname> anónimo, la conducta correcta
      sucede basado en el tipo actual de
      <classname>Figura</classname>. Esto es asombroso porque, como se
      mencionó anteriormente, cuando el compilador C++ esta compilando
      el código para <function>doStuff()</function>, no se sabe
      exactamente qué tipos está [FIXME:dealing whit]. Así
      normalmente, [FIXME: you'd expect it to end up calling] la
      versión de <function>erase()</function> y
      <function>draw()</function> para <classname>Figura</classname>,
      y no para el <classname>Círculo</classname>,
      <classname>Cuadrado</classname>, o <classname>Línea</classname>
      específico. Y todavía la forma correcta ocurre a causa del
      polimorfismo. El compilador y [FIXME: runtime] sistema manipulan
      los detalles; todo lo que necesita conocer es que esto ocurre y
      lo que es más importante cómo diseñar con él. Si una función
      miembro es <keyword>virtual</keyword>, entonces cuando mande el
      mensaje a un objeto, el objeto hará lo correcto, incluso cuando
      [FIXME: upcasting] sea complicado.
    </para>


  </sect1>
  
  <sect1>
    <title>Creación y destrucción de objetos</title>
    <para></para>    
  </sect1> 

  <sect1>
    <title>Gestión de excepciones: tratamiento de errores</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Análisis y diseño</title>
    <para></para>   
  </sect1>
    
  <sect1>
    <title>Programación Extrema</title>
    <para></para>    
  </sect1>

  <sect1>
    <title>Porqué triunfa C++</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Estrategias para la transición</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Resumen</title>
    <xi:include parse="xml" href="./ejercicios.xml"/>

    <para></para>  
  </sect1>

</chapter>


  