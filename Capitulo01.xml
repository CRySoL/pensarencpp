<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C1">
  
  <!--
  1: Introduction to Objects
  -->

  <title>Introducción a los Objetos</title>

  <!-- 
  The genesis of the computer revolution was in a machine. The genesis
  of our programming languages thus tends to look like that machine.
  -->

  <highlights>
    <para>
      La génesis de los lenguajes de la revolución informática ocurrió
      dentro de una máquina. Por tanto, la génesis de nuestros lenguajes
      de programación tiende a parecerse a esa máquina.
    </para>
  </highlights>

  <!--
  But computers are not so much machines as they are mind amplification
  tools (\u201cbicycles for the mind,\u201d as Steve Jobs is fond of
  saying) and a different kind of expressive medium. As a result, the
  tools are beginning to look less like machines and more like parts of
  our minds, and also like other expressive mediums such as writing,
  painting, sculpture, animation, and filmmaking. Object-oriented
  programming is part of this movement toward using the computer as an
  expressive medium.
  -->

  <para>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente (<quote>bicicletas para la mente</quote>),
    como le gusta decir a decir Steve Jobs) y una manera diferente de
    medio de expresión.  Como resultado, las herramientas empiezan a
    parecerse menos a las máquinas y más a partes de nuestra mente, y
    también a otros medios de expresión como la escritura, la pintura,
    la escultura, la animación y la cinematografía. La programación
    orientada a objetos es parte de este movimiento hacia un uso del
    ordenador como medio de expresión.
  </para>

  <!--
  This chapter will introduce you to the basic concepts of
  object-oriented programming (OOP), including an overview of OOP
  development methods. This chapter, and this book, assume that you have
  had experience in a procedural programming language, although not
  necessarily C. If you think you need more preparation in programming
  and the syntax of C before tackling this book, you should work through
  the \u201cThinking in C: Foundations for C++ and Java\u201d training
  CD ROM, bound in with this book and also available at
  www.BruceEckel.com.
  -->

  <para>
    Este capítulo le servirá de introducción a los conceptos básicos de
    la programación orientada a objetos (POO), incluyendo un resumen de
    los métodos de desarrollo de la POO. Este capítulo, y este libro,
    suponen que usted tiene ya experiencia con un lenguaje de
    programación procedural, aunque no sea necesariamente C. Si cree que
    necesita más preparación en programación y en la sintaxis de C antes
    de abordar este libro, debería mirarse el CD-ROM de entrenamiento
    <citetitle>Thinking in C: Foundations for C++ and Java</citetitle>,
    que viene junto con este libro, y también está disponible en <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
  </para>

  <!--
  This chapter is background and supplementary material. Many people do
  not feel comfortable wading into object-oriented programming without
  understanding the big picture first. Thus, there are many concepts
  that are introduced here to give you a solid overview of OOP. However,
  many other people don\u2019t get the big picture concepts until
  they\u2019ve seen some of the mechanics first; these people may become
  bogged down and lost without some code to get their hands on. If
  you\u2019re part of this latter group and are eager to get to the
  specifics of the language, feel free to jump past this chapter \u2013
  skipping it at this point will not prevent you from writing programs
  or learning the language. However, you will want to come back here
  eventually to fill in your knowledge so you can understand why objects
  are important and how to design with them.
  -->

  <para>
    Este capítulo es material básico y suplementario. Mucha gente no se
    siente cómoda adentrándose en la programación orientada a objetos
    sin tener antes una visión global. Por tanto, aquí se introducen
    muchos conceptos para darle una visión sólida de la POO. Sin
    embargo, mucha otra gente no capta los conceptos globales hasta que
    no han visto parte de la mecánica primero; esta gente puede
    atascarse y perderse sin algún trozo de código al que ponerle las
    manos encima. Si usted es parte de este último grupo, y está ansioso
    por llegar a las especificaciones del lenguaje, siéntase libre de
    saltarse este capítulo; esto no le impedirá escribir programas o
    aprender el lenguaje. Sin embargo, quizá quiera volver a este
    capítulo para completar sus conocimientos y poder comprender porqué
    son importantes los objetos y cómo diseñar con ellos.
  </para>

  <sect1>

  <!--
  The progress of abstraction
  -->

    <title>El progreso de abstracción</title>

  <!--
    All programming languages provide abstractions. It can be argued
    that the complexity of the problems you\u2019re able to solve is
    directly related to the kind and quality of abstraction. By
    \u201ckind\u201d I mean, \u201cWhat is it that you are
    abstracting?\u201d Assembly language is a small abstraction of the
    underlying machine. Many so-called \u201cimperative\u201d languages
    that followed (such as Fortran, BASIC, and C) were abstractions of
    assembly language. These languages are big improvements over
    assembly language, but their primary abstraction still requires you
    to think in terms of the structure of the computer rather than the
    structure of the problem you are trying to solve. The programmer
    must establish the association between the machine model (in the
    \u201csolution space,\u201d which is the place where you\u2019re
    modeling that problem, such as a computer) and the model of the
    problem that is actually being solved (in the \u201cproblem
    space,\u201d which is the place where the problem exists). The
    effort required to perform this mapping, and the fact that it is
    extrinsic to the programming language, produces programs that are
    difficult to write and expensive to maintain, and as a side effect
    created the entire \u201cprogramming methods\u201d industry.
  -->

    <para>
      Todos los lenguajes de programación proporcionan abstracciones. Se
      puede afirmar que la complejidad de los problemas que se pueden
      resolver está relacionada directamente con el tipo y calidad de la
      abstracción. Por <quote>tipo</quote> me refiero a <quote>¿Qué es
      lo que está abstrayendo?</quote>. El lenguaje ensamblador es una
      pequeña abstracción de la máquina subyacente. Muchos lenguajes
      llamados <quote>imperativos</quote> que siguieron (como Fortran,
      BASIC y C) eran abstracciones del lenguaje ensamblador. Estos
      lenguajes son grandes mejoras con respecto al lenguaje
      ensamblador, pero su abstracción primaria todavía requiere que
      usted piense en términos de la estructura de la computadora, en
      lugar de la estructura del problema que intenta resolver. El
      programador debe establecer la asociación entre el modelo de la
      máquina (en el <quote>espacio de soluciones</quote>, que es el
      lugar donde está modelando ese problema, como un ordenador) y el
      modelo del problema que se está resolviendo (en el <quote>espacio
      de problemas</quote>, que es el lugar donde existe el
      problema). El esfuerzo requerido para realizar esta
      correspondencia, y el hecho de que sea extrínseco al lenguaje de
      programación, produce programas que son difíciles de escribir y
      caros de mantener y, como efecto secundario, creó toda la
      industria de <quote>métodos de programación</quote>.
    </para>

  <!--
    The alternative to modeling the machine is to model the problem
    you\u2019re trying to solve. Early languages such as LISP and APL
    chose particular views of the world (\u201cAll problems are
    ultimately lists\u201d or \u201cAll problems are
    algorithmic\u201d). PROLOG casts all problems into chains of
    decisions. Languages have been created for constraint-based
    programming and for programming exclusively by manipulating
    graphical symbols. (The latter proved to be too restrictive.) Each
    of these approaches is a good solution to the particular class of
    problem they\u2019re designed to solve, but when you step outside of
    that domain they become awkward. 
  -->

    <para>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como el LISP y el
      APL eligieron concepciones del mundo particulares (<quote>Todos
      los problemas son listas en última instancia</quote>, o
      <quote>Todos los problemas son algorítmicos</quote>). El PROLOG
      reduce todos los problemas a cadenas de decisiones. Se han creado
      lenguajes para programación basada en restricciones y para
      programar manipulando exclusivamente símbolos gráficos (el último
      demostró ser demasiado restrictivo). Cada uno de estos métodos es
      una buena solución para el tipo particular de problema para el que
      fueron diseñados, pero cuando uno se sale de ese dominio se hacen
      difíciles de usar.
    </para>
      
  <!--
    The object-oriented approach goes a step farther by providing tools
    for the programmer to represent elements in the problem space. This
    representation is general enough that the programmer is not
    constrained to any particular type of problem. We refer to the
    elements in the problem space and their representations in the
    solution space as \u201cobjects.\u201d (Of course, you will also
    need other objects that don\u2019t have problem-space analogs.) The
    idea is that the program is allowed to adapt itself to the lingo of
    the problem by adding new types of objects, so when you read the
    code describing the solution, you\u2019re reading words that also
    express the problem. This is a more flexible and powerful language
    abstraction than what we\u2019ve had before. Thus, OOP allows you to
    describe the problem in terms of the problem, rather than in terms
    of the computer where the solution will run. There\u2019s still a
    connection back to the computer, though. Each object looks quite a
    bit like a little computer; it has a state, and it has operations
    that you can ask it to perform. However, this doesn\u2019t seem like
    such a bad analogy to objects in the real world; they all have
    characteristics and behaviors. 
  -->

    <para>
      El método orientado a objetos va un paso más allá, proporcionando
      herramientas para que el programador represente los elementos en
      el espacio de problemas. Esta representación es lo suficientemente
      general para que el programador no esté limitado a ningún tipo
      particular de problema. Nos referimos a los elementos en el
      espacio de problemas, y a sus representaciones en el espacio de
      soluciones, como <quote>objetos</quote>. (Por supuesto, necesitará
      otros objetos que no tengan analogías en el espacio del problema.)
      La idea es que se permita al programa adaptarse al FIXME:lingo del
      problema añadiendo nuevos tipos de objetos de modo que cuando lea
      el código describiendo la solución, está leyendo palabras que
      además expresan el problema. Este es el lenguaje de abstracción
      más flexible y potente que haya usado antes. De esta manera, la POO
      permite describir el problema en términos del problema, en lugar
      de usar términos de la computadora en la que se ejecutará la
      solución. Sin embargo, todavía existe una conexión con la
      computadora. Cada objeto se parece un poco a una pequeña
      computadora; tiene un estado, y operaciones que se le puede pedir
      hacer. Sin embargo, no parece una mala analogía a los objetos en el mundo
      real; todos tienen características y comportamientos.
    </para>

    <!--
    Some language designers have decided that object-oriented programming by
    itself is not adequate to easily solve all programming problems, and
    advocate the combination of various approaches into multiparadigm
    programming languages.[4]See Multiparadigm Programming in Leda by
    Timothy Budd (Addison-Wesley 1995).
    -->

    <para>
      Algunos diseñadores de lenguajes han decidido que la programación
      orientada a objetos en sí misma no es adecuada para resolver
      fácilmente todos los problemas de programación, y abogan por una
      combinación de varias aproximaciones en lenguajes de programación
      <emphasis>multiparadigma</emphasis>. <footnote> <para>Ver
      <emphasis>Multiparadigm Programming in Leda</emphasis> de
      <personname><firstname>Timothy</firstname>
      <surname>Budd</surname></personname> (Addison-Wesley 1995).</para>
      </footnote>
    </para>
  
    <!--
    Alan Kay summarized five basic characteristics of Smalltalk, the
    first successful object-oriented language and one of the languages
    upon which C++ is based. These characteristics represent a pure
    approach to object-oriented programming:
    -->

    <para>
      <personname><firstname>Alan</firstname>
      <surname>Kay</surname></personname> resumió las cinco
      características básicas de Smalltalk, el primer lenguaje orientado
      a objetos exitoso y uno de los lenguajes en los que está basado
      C++. Esas características representan un aproximación a la
      programación orientada a objetos:
    </para>
    
    <!-- 1. Everything is an object. Think of an object as a fancy
    variable; it stores data, but you can "make requests" to that
    object, asking it to perform operations on itself. In theory, you
    can take any conceptual component in the problem you're trying to
    solve (dogs, buildings, services, etc.) and represent it as an
    object in your program.  -->

    <orderedlist>
      <listitem>
	<para>
	  Todo es un objeto. Pensar en un objeto como una variable
	  elaborada; almacena datos, pero puede <quote>hacer
	  peticiones</quote> a este objeto, pidiendo que realice
	  operaciones en sí mismo. En teoría, puede coger cualquier
	  componente conceptual del problema que está intentando
	  resolver (perros, edificios, servicios, etc.) y representarlo
	  como un objeto en su programa.
	</para>
      </listitem>

   
    <!--
    2. A program is a bunch of objects telling each other what to do by
      sending messages. To make a request of an object, you "send a
      message" to that object. More concretely, you can think of a
      message as a request to call a function that belongs to a
      particular object.
    -->

     <listitem>
	<para>
	  Un programa es un grupo de objetos enviando mensajes a otros
	  para decirles qué hacer. Para hacer una petición a un objeto,
	  <quote>envía un mensaje</quote> a ese objeto. Más
	  concretamente, puede pensar en un mensaje como una petición de
	  invocación a una función que pertenece a un objeto particular. 
	</para>
      </listitem>

    <!--
   3. Each object has its own memory made up of other objects. Put
      another way, you create a new kind of object by making a package
      containing existing objects. Thus, you can build complexity in a
      program while hiding it behind the simplicity of objects.
    -->

     <listitem>
	<para>
	  Cada objeto tiene su propia memoria hecha a base de otro
	  objetos. Visto de otra manera, puedes crear un nuevo tipo de
	  objeto haciendo un paquete que contiene objetos
	  existentes. Por consiguiente, puede construir de forma
	  compleja en un programa ocultando la complejidad de los objetos.
	</para>
      </listitem>

    <!--
   4. Every object has a type. Using the parlance, each object is an
      instance of a class, in which "class" is synonymous with
      "type." The most important distinguishing characteristic
      of a class is "What messages can you send to it?"
    -->

      <listitem>
	<para>
	  Cada objeto es un tipo. Usando el FIXME:parlance, cada
	  objeto es una instancia de una clase, en el que
	  <quote>clase</quote> es sinónimo de <quote>tipo</quote>. La
	  característica más importante que lo distingue de una clase es
	  <quote>¿Qué mensajes puede enviarle?</quote>
	</para>
      </listitem>

    <!--
    5. All objects of a particular type can receive the same
    messages. This is actually a loaded statement, as you will see
    later. Because an object of type "circle" is also an
    object of type "shape," a circle is guaranteed to accept
    shape messages. This means you can write code that talks to shapes
    and automatically handles anything that fits the description of a
    shape. This substitutability is one of the most powerful concepts in
    OOP.
    -->

      <listitem>
	<para>
	  Todos los objetos de un tipo particular pueden recibir los
	  mismos mensajes. Es realmente una declaración con doble
	  sentido, como se verá más tarde. Porque un objeto de tipo
	  <classname>círculo</classname> es también un objeto de tipo
	  <classname>figura</classname>, está garantizado que un círculo
	  recibirá los mensajes de figura. Esto significa que puede
	  escribir código que habla con objetos
	  <classname>figura</classname> y automáticamente funciona con
	  cualquier otro objeto que coincida con la descripción de
	  <classname>figura</classname>. Esta
	  <emphasis>sustitutabilidad</emphasis> es una de los más
	  poderosos conceptos en la POO.
	</para>
      </listitem>
    </orderedlist>


  </sect1>

  <sect1>

    <!--
    An object has an interface
    -->
      <title>Un objeto tiene una interfaz</title>

      <!-- Aristotle was probably the first to begin a careful study of
      the concept of type; he spoke of "the class of fishes and the
      class of birds."      The idea that all objects, while being
      unique, are also part of a class of objects that have
      characteristics and behaviors in common was used directly in the
      first object-oriented language, Simula-67, with its fundamental
      keyword class that introduces a new type into a program.
      -->

      <para>
	Aristóteles probablemente fue el primero en hacer un estudio
	minucioso del concepto de <emphasis>tipo</emphasis>; él habló
	de <quote>las clases de peces y las clases de
	pájaros</quote>. La idea de que todos los objetos, aún siendo
	únicos, también son parte de una clase de objetos que tienen
	características y comportamientos comunes se utilizó directamente
	en el primer lenguaje orientado a objetos, Simula-67, con su
	palabra reservada <keyword>class</keyword> que introduce un
	nuevo tipo en un programa.
      </para>

      <!-- 
      Simula, as its name implies, was created for developing
      simulations such as the classic "bank teller
      problem[5]." In this, you have a bunch of tellers, customers,
      accounts, transactions, and units of money \u2013 a lot of
      \u201cobjects.\u201d Objects that are identical except for their
      state during a program\u2019s execution are grouped together into
      \u201cclasses of objects\u201d and that\u2019s where the keyword
      class came from. Creating abstract data types (classes) is a
      fundamental concept in object-oriented programming. Abstract data
      types work almost exactly like built-in types: You can create
      variables of a type (called objects or instances in
      object-oriented parlance) and manipulate those variables (called
      sending messages or requests; you send a message and the object
      figures out what to do with it). The members (elements) of each
      class share some commonality: every account has a balance, every
      teller can accept a deposit, etc. At the same time, each member
      has its own state, each account has a different balance, each
      teller has a name. Thus, the tellers, customers, accounts,
      transactions, etc., can each be represented with a unique entity
      in the computer program. This entity is the object, and each
      object belongs to a particular class that defines its
      characteristics and behaviors.
      -->
    <!--
    [5] You can find an interesting implementation of this problem in Volume
    2 of this book, available at www.BruceEckel.com.
    -->

    <para>
      Simula, como su nombre indica, fue creado para desarrollar
      simulaciones como el clásico FIXME:<quote>back teller
      problem</quote><footnote>
	<para>
	  Puede encontrar una interesante implementación de este
	  problema en el 2º Volumen de este libro, disponible en <ulink
	    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>
	</para>
      </footnote>
      En él, tiene un grupo de cajeros, clientes, cuentas,
      transacciones, y unidades de moneda -- un montón de
      <quote>objetos</quote>. Los objetos que son idénticos exceptuando
      su estado durante la ejecución del programa se agrupan juntos en
      <quote>clases de objetos</quote> y de ahí es de donde viene la
      palabra clave <keyword>class</keyword>. Crear tipos de datos
      abstractos (clases) es un concepto fundamental en la programación
      orientada a objetos. Los tipos de datos abstractos trabajan casi
      exactamente como tipos empotrados: puede crear variables de un
      tipo (llamados <emphasis>objetos</emphasis> o
      <emphasis>instancias</emphasis> en el argot de la
      programación orientada a objetos) y manipular estas variables
      FIXME:(llamadas <emphasis>sending messages</emphasis> o
      <emphasis>requests</emphasis>; envía un mensaje y the object
      figures out what to do with it). Los miembros (elementos) de cada
      clase comparten FIXME: some commonality: cada cuenta tiene un
      balance, cada cajero puede aceptar un depósito, etc. Al
      mismo tiempo, cada miembro tiene su propio estado, cada cuenta
      tiene un balance diferente, cada cajero tiene un nombre. De
      esta manera, los cajeros, clientes, cuentas, transacciones,
      etc., cada uno puede ser representado con una única entidad en el
      programa de computadora. Esta entidad es un objeto, y cada objeto
      pertenece a una clase particular que define sus características y
      comportamientos.
      </para>
  </sect1>

  <sect1>

    <!--
    The hidden implementation
    -->
    <title>La implementación oculta</title>

    <!--
    It is helpful to break up the playing field into class creators
    (those who create new data types) and client programmers[7] (the
    class consumers who use the data types in their applications). The
    goal of the client programmer is to collect a toolbox full of
    classes to use for rapid application development. The goal of the
    class creator is to build a class that exposes only what's
    necessary to the client programmer and keeps everything else
    hidden. Why? Because if it's hidden, the client programmer
    can't use it, which means that the class creator can change the
    hidden portion at will without worrying about the impact to anyone
    else. The hidden portion usually represents the tender insides of an
    object that could easily be corrupted by a careless or uninformed
    client programmer, so hiding the implementation reduces program
    bugs. The concept of implementation hiding cannot be overemphasized.
    -->

   <para>
      Es útil distinguir entre los <emphasis>creadores de
	clases</emphasis> (aquellos que crean nuevos tipos de datos) y
      <emphasis>programadores clientes[7]</emphasis> (los consumidores
	de clases que usan los tipos de datos en sus aplicaciones). El
	objetivo del programador cliente es acumular una caja de
	herramientas llena de clases que usar para un desarrollo rápido
	de aplicaciones. El objetivo del creador de clases es construir
	una clase que exponga sólo lo necesario para el programador
	cliente y mantiene todo lo demás oculto. ¿Por qué? Porque si
	está oculto, el programador cliente no puede usarlo, lo cual
	significa que el creador de clases puede cambiar la parte oculta
	sin preocuparse de las consecuencia sobre los demás. La parte
	oculta suele representar las interioridades delicadas de un
	objeto que podría fácilmente corrompida por un programador
	cliente descuidado o desinformado, así que ocultando la
	implementación se reducen los errores de programación. No se
	debe abusar del concepto de implementación oculta.
    </para>

    <!--
    In any relationship it's important to have boundaries that are
    respected by all parties involved. When you create a library, you
    establish a relationship with the client programmer, who is also a
    programmer, but one who is putting together an application by using
    your library, possibly to build a bigger library.
    -->

    <para>
      En cualquier relación es importante tener límites que sean
      respetadas por todas las partes involucradas. Cuando se cree una
      librería, se establece una relación con el programador cliente,
      quien también es programador, porque puede estar utilizando la
      librería para crear a su vez una librería mayor.
    </para>


    <!--
    If all the members of a class are available to everyone, then the
    client programmer can do anything with that class and there's
    no way to enforce rules. Even though you might really prefer that
    the client programmer not directly manipulate some of the members of
    your class, without access control there's no way to prevent
    it. Everything's naked to the world.
    -->

    <para>
      Si todos los miembros de una clase están disponibles para
      cualquiera, entonces el programador cliente puede hacer cualquier
      cosa con la clase y no hay forma de imponer las reglas. Incluso si
      prefiere que el programador cliente no manipule directamente
      algunos de los miembros de su clase, son control de acceso no hay
      forma de impedirlo. Nadie está a salvo.
    </para>

   <!--
    So the first reason for access control is to keep client
    programmers'hands off portions they shouldn't touch - parts that are
    necessary for the internal machinations of the data type but not
    part of the interface that users need in order to solve their
    particular problems. This is actually a service to users because
    they can easily see what's important to them and what they can
    ignore.
    -->

    <para>
      Por eso la principal razón del control de acceso es impedir que el
      cliente toque las partes que no debería - partes que son
      necesarias para los mecanismos internos de los tipos de datos pero
      no parte de la interfaz que los usuarios necesitan para resolver
      sus problemas particulares. Realmente esto es un servicio para los
      usuarios porque pueden ver fácilmente qué es importante para ellos
      y qué pueden ignorar.
    </para>

    <!--
    The second reason for access control is to allow the library
    designer to change the internal workings of the class without
    worrying about how it will affect the client programmer. For
    example, you might implement a particular class in a simple fashion
    to ease development, and then later discover that you need to
    rewrite it in order to make it run faster. If the interface and
    implementation are clearly separated and protected, you can
    accomplish this easily and require only a relink by the user.
    -->

    <para>
      La segunda razón para el control de acceso es permitir al
      diseñador de la librería cambiar los trabajos internos de la clase
      sin preocuparse de cómo afectará a los programadores clientes. Por
      ejemplo, podría implementar una clase particular de una manera
      sencilla para un desarrollo fácil, y más tarde descubrir que
      necesita reescribirla para hacerla más rápida. Si la interfaz y la
      implementación están claramente separadas y protegidas, puede
      conseguirlo fácilmente y sólo requiere que el usuario vuelva a
      enlazar la aplicación.
    </para>

    <!--
    C++ uses three explicit keywords to set the boundaries in a class:
    public, private, and protected. Their use and meaning are quite
    straightforward. These access specifiers determine who can use the
    definitions that follow. public means the following definitions are
    available to everyone. The private keyword, on the other hand, means
    that no one can access those definitions except you, the creator of
    the type, inside member functions of that type. private is a brick
    wall between you and the client programmer. If someone tries to
    access a private member, they'll get a compile-time
    error. protected acts just like private, with the exception that an
    inheriting class has access to protected members, but not private
    members. Inheritance will be introduced shortly.
    -->

    <para>
      C++ utiliza tres palabras reservadas explícitas para poner límites
      en una clase: <keyword>public</keyword>,
      <keyword>private</keyword>, y <keyword>protected</keyword>. Su uso
      y significado son bastante sencillos. Estos
      <emphasis>especificadores de acceso</emphasis> determinan quien
      usa las definiciones que siguen. <keyword>public</keyword>
      significa que las definiciones posteriores están disponibles para
      cualquiera. La palabra reservada <keyword>private</keyword>, por
      otro lado, significa que nadie puede acceder a estas definiciones
      excepto el creador del tipo, es decir, los métodos internos de la
      clase. <keyword>private</keyword> es una pared entre el creador de
      la clase y el programador cliente. Si alguien intenta acceder a un
      miembro privado, obtendrá un error al
      compilar. <keyword>protected</keyword> actúa como
      <keyword>private</keyword>, con la excepción de que las clases
      [FIXME: herederas] tienen acceso a miembros protegidos, pero no a
      los privados. La herencia se explicará en breve.
    </para>


  </sect1>

  <sect1>

    <!--
    Reusing the implementation
    -->

    <title>Reutilizando la implementación</title>


    <!--
    Once a class has been created and tested, it should (ideally)
    represent a useful unit of code. It turns out that this reusability is
    not nearly so easy to achieve as many would hope; it takes experience
    and insight to produce a good design. But once you have such a design,
    it begs to be reused. Code reuse is one of the greatest advantages
    that object-oriented programming languages provide.
    -->

    <para>
      Una vez que una clase ha sido creada y probada, debería
      (perfectamente) representar una unidad útil de código. Eso
      [FIXME:turns out that] esta reusabilidad casi no es tan fácil de
      conseguir como muchos [FIXME:would hope]; coge experiencia y
      entendimiento para producir un buen diseño. Pero una vez que tiene
      semejante diseño, éste pide ser reutilizado. El código reutilizado es
      una de las mejores ventajas de los lenguajes de programación orientada
      a objetos.
    </para>


    <!--
    The simplest way to reuse a class is to just use an object of that
    class directly, but you can also place an object of that class inside
    a new class. We call this "creating a member object". Your
    new class can be made up of any number and type of other objects, in
    any combination that you need to achieve the functionality desired in
    your new class. Because you are composing a new class from existing
    classes, this concept is called composition (or more generally,
    aggregation). Composition is often referred to as a "has-a"
    relationship, as in "a car has an engine".
    -->
    
    <para>
      La forma más fácil de reutilizar una clase es precisamente
      utilizar un objeto de esa clase directamente, pero también puede
      colocar un objeto de esta clase dentro de una clase nueva. Podemos
      llamarlo [FIXME:"crear un objeto miembro"]. Su nueva clase puede
      estar compuesta de algún número y tipo de otros objetos, en alguna
      combinación que necesite para conseguir la funcionalidad deseada
      en su nueva clase. Porque está componiendo una nueva clase desde
      clases existentes, este concepto se llama
      <emphasys>composition</emphasys> (o más generalmente,
      <emphasys>aggregation</emphasys>. [FIXME: "Composition is often
      referred to as a "has-a" relationship, as in "a car has an
      engine"].
    </para>


    <!--
    (The above UML diagram indicates composition with the filled diamond,
    which states there is one car. I will typically use a simpler form: just
    a line, without the diamond, to indicate an association.[8])

    [8] This is usually enough detail for most diagrams, and you don't need
    to get specific about whether you're using aggregation or composition.
    -->

    <para>
      (El diagrama UML superior indica composición con [FIXME: the filled
      diamond, which states there is one car]. Típicamente se usará una
      forma simple: [FIXME:just] una línea, sin [FIXME: the diamond], para
      indicar una asociación.[FIXME: [8]]).
      
      [8] El bastante habitual detallar para más diagramas, y no necesita
      [FIXME:to get specific] sobre si está usando agregación o composición. 
    </para>


    <!--
    Composition comes with a great deal of flexibility. The member objects
    of your new class are usually private, making them inaccessible to the
    client programmers who are using the class. This allows you to change
    those members without disturbing existing client code. You can also
    change the member objects at runtime, to dynamically change the
    behavior of your program. Inheritance, which is described next, does
    not have this flexibility since the compiler must place compile-time
    restrictions on classes created with inheritance.
    -->

    <para>
      La composición viene con una gran [FIXME: deal] de flexibilidad. Los
      objetos miembros de su nueva clase son habitualmente privados,
      haciéndolos inaccesibles para los programadores clientes que están
      usando la clase. Esto permite cambiar esos miembros sin
      [FIXME:disturbing existing] código cliente. También puede cambiar los
      objetos miembros [FIXME:at runtime], para cambiar dinámicamente el
      comportamiento de su programa. La herencia, descrita más delante, no
      tiene esta flexibilidad desde el compilador [FIXME:must place
      compile-time] restricciones en clases creadas con herencia.
    </para>
    

    <!--
    Because inheritance is so important in object-oriented programming it
    is often highly emphasized, and the new programmer can get the idea
    that inheritance should be used everywhere. This can result in awkward
    and overly-complicated designs. Instead, you should first look to
    composition when creating new classes, since it is simpler and more
    flexible. If you take this approach, your designs will stay
    cleaner. Once you've had some experience, it will be reasonably
    obvious when you need inheritance.
    -->
    
    <para>
      Porque la herencia es tan importante en la programación orientada a
      objetos, esto sumamente emfatizado, y el nuevo programador puede tener
      la idea de que la herencia debería ser usada en todas partes. Esto
      puede dar como resultado diseños torpes y demasiado complicados. En
      cambio, debería mirar primero la composición cuando cree nuevas
      clases, ya que es más simple y flexible. Si acepta esta propuesta, sus
      diseños serán más limpios. Una vez que tenga experiencia, será
      razonablemente evidente cuando necesite herencia.
    </para>


  </sect1>

  <sect1>



    <title>Herencia: reutilización de interfaces</title>
    <para></para>
  </sect1>
  
  <sect1>
    <title>Objetos intercambiables gracias al polimorfismo</title>
    <para></para>    
  </sect1>
  
  <sect1>
    <title>Creación y destrucción de objetos</title>
    <para></para>    
  </sect1> 

  <sect1>
    <title>Gestión de excepciones: tratamiento de errores</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Análisis y diseño</title>
    <para></para>   
  </sect1>
    
  <sect1>
    <title>Programación Extrema</title>
    <para></para>    
  </sect1>

  <sect1>
    <title>Porqué triunfa C++</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Estrategias para la transición</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para></para>  
  </sect1>

</chapter>


  