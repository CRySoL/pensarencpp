<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C1">
  
  <title>Introduction a los Objetos (INCOMPLETO)</title>

  <highlights>
    <para>
      La génesis de los lenguajes de la revolución informática ocurrió
      dentro de una máquina. Por tanto, la génesis de nuestros lenguajes
      de programación tiende a parecerse a esa máquina.
    </para>
  </highlights>

  <para>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente (<quote>bicicletas para la mente</quote>),
    como le gusta decir a decir Steve Jobs) y una manera diferente de
    medio de expresión.  Como resultado, las herramientas empiezan a
    parecerse menos a las máquinas y más a partes de nuestra mente, y
    también a otras medios de expresión como la escritura, la pintura,
    la escultura, la animación y la cinematografía. La programación
    orientada a objetos es parte de este movimiento hacia un uso del
    ordenador como medio de expresión.
</para>

  <para>
    Este capítulo le servirá de introducción a los conceptos básicos de
    la programación orientada a objetos (POO), incluyendo un resumen de
    los métodos de desarrollo de la POO. Este capítulo, y este libro,
    suponen que usted tiene ya experiencia con un lenguaje de
    programación procedural, aunque no sea necesariamente C. Si cree que
    necesita más preparación en programación y en la sintaxis de C antes
    de abordar este libro, debería mirarse el CD-ROM de entrenamiento
    <citetitle>Thinking in C: Foundations for C++ and Java</citetitle>,
    que viene junto con este libro, y también está disponible en <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>.
  </para>

  <para>
    Este capítulo es material básico y suplementario. Mucha gente no se
    siente cómoda adentrándose en la programación orientada a objetos
    sin tener antes una visión global. Por tanto, aquí se introducen
    muchos conceptos para darle una visión sólida de la POO. Sin
    embargo, mucha otra gente no capta los conceptos globales hasta que
    no han visto parte de la mecánica primero; esta gente puede
    atrancarse y perderse sin algún trozo de código al que ponerle las
    manos encima. Si usted es parte de este último grupo, y está ansioso
    por llegar a las especificaciones del lenguaje, siéntase libre de
    saltarse este capítulo; esto no le impedirá escribir programas o
    aprender el lenguaje. Sin embargo, eventualmente querrá volver atrás
    hasta aquí para rellenar su conocimiento y poder comprender por qué
    son importantes los objetos y cómo diseñar con ellos.
  </para>

  <sect1>
    <title>El progreso de abstracción</title>

    <para>
      Todos los lenguajes de programación proporcionan abstracciones. Se
      puede afirmar que la complejidad de los problemas que se pueden
      resolver está relacionada directamente con el tipo y calidad de la
      abstracción. Por <quote>tipo</quote> me refiero a <quote>¿Qué es
      lo que está abstrayendo?</quote>. El lenguaje ensamblador es una
      pequeña abstracción de la máquina subyaciente. Muchos lenguajes
      llamados <quote>imperativos</quote> que siguieron (como Fortran,
      BASIC y C) eran abstracciones del lenguaje ensamblador. Estos
      lenguajes son grandes mejoras con respecto al lenguaje
      ensamblador, pero su abstracción primaria todavía requiere que
      usted piense en términos de la estructura de la computadora, en
      lugar de la estructura del problema que intenta resolver. El
      programador debe establecer la asociación entre el modelo de la
      máquina (en el <quote>espacio de soluciones</quote>, que es el
      lugar donde está modelando ese problema, como un ordenador) y el
      modelo del problema que se está resolviendo (en el <quote>espacio
      de problemas</quote>, que es el lugar donde existe el
      problema). El esfuerzo requerido para realizar esta
      correspondencia, y el hecho de que sea extrínseco al lenguaje de
      programación, produce programas que son difíciles de escribir y
      caros de mantener, y, como efecto secundario, creó toda la
      industria de <quote>métodos de programación</quote>.
    </para>

    <para>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como el LISP y el
      APL eligieron concepciones del mundo particulares (<quote>Todos
      los problemas son listas en última instancia</quote>, o
      <quote>Todos los problemas son algorítmicos</quote>). El PROLOG
      reduce todos los problemas a cadenas de decisiones. Se han creado
      lenguajes para programación basada en restricciones y para
      programar manipulando exclusivamente símbolos gráficos (el último
      demostró ser demasiado restrictivo). Cada uno de estos métodos es
      una buena solución para el tipo particular de problema para el que
      fueron diseñados, pero cuando uno se sale de ese dominio, se hacen
      difíciles de usar.
    </para>


    <!--
    The object-oriented approach goes a step farther by providing tools for
    the programmer to represent elements in the problem space. This
    representation is general enough that the programmer is not
    constrained to any particular type of problem. We refer to the
    elements in the problem space and their representations in the
    solution space as "objects." 

    (Of course, you will also need other objects that don\u2019t have
    problem-space analogs.) The idea is that the program is allowed to
    adapt itself to the lingo of the problem by adding new types of
    objects, so when you read the code describing the solution,
    you\u2019re reading words that also express the problem. This is a
    more flexible and powerful language abstraction than what we\u2019ve
    had before. Thus, OOP allows you to describe the problem in terms of
    the problem, rather than in terms of the computer where the solution
    will run. There\u2019s still a connection back to the computer,
    though. Each object looks quite a bit like a little computer; it has
    a state, and it has operations that you can ask it to
    perform. However, this doesn\u2019t seem like such a bad analogy to
    objects in the real world; they all have characteristics and
    behaviors.  -->
    
    <para>
      El método orientado a objetos va un paso más allá, proporcionando
      herramientas para que el programador represente los elementos en
      el espacio de problemas. Esta representación es lo suficientemente
      general para que el programador no esté limitado a ningún tipo
      particular de problema. Nos referimos a los elementos en el
      espacio de problemas, y a sus representaciones en el espacio de
      soluciones, como <quote>objetos</quote>.
    </para>

    <!--
    Some language designers have decided that object-oriented
    programming by itself is not adequate to easily solve all
    programming problems, and advocate the combination of various
    approaches into multiparadigm programming languages.[4]
    -->

    <!--
    [4] See Multiparadigm Programming in Leda by Timothy Budd
    (Addison-Wesley 1995).
    -->

    <para>
      Algunos diseñadores de lenguajes han decidido que que la
      programación orientada a objetos por si misma no es adecuada para
      resolver fácilmente todos los problemas de programación, y abogan
      por una combinación de varias aproximaciones en lenguajes de
      programación multiparadigma.<footnote>
	<para>FIXME:[4]</para>
      </footnote>
    </para>

    <!--
    Alan Kay summarized five basic characteristics of Smalltalk, the
    first successful object-oriented language and one of the languages
    upon which C++ is based. These characteristics represent a pure
    approach to object-oriented programming:
    -->

    <para>
      <personname><firstname>Alan</firstname>
      <surname>Kay</surname></personname> resumió las cinco
      características básicas de Smalltalk, el primer lenguaje orientado
      a objetos exitoso y uno de los lenguajes en los que está basado
      C++. Esas características representan un aproximación a la
      programación orientada a objetos:
    </para>
    
    <!-- 1. Everything is an object. Think of an object as a fancy
    variable; it stores data, but you can "make requests" to that
    object, asking it to perform operations on itself. In theory, you
    can take any conceptual component in the problem you're trying to
    solve (dogs, buildings, services, etc.) and represent it as an
    object in your program.  -->

    <orderedlist>
      <listitem>
	<para>
	  Todo es un objeto
	</para>
      </listitem>
    </orderedlist>

   
    <!--
    2. A program is a bunch of objects telling each other what to do by
      sending messages. To make a request of an object, you "send a
      message" to that object. More concretely, you can think of a
      message as a request to call a function that belongs to a
      particular object.
    -->

    <para>
    </para>
    
    <!--
   3. Each object has its own memory made up of other objects. Put
      another way, you create a new kind of object by making a package
      containing existing objects. Thus, you can build complexity in a
      program while hiding it behind the simplicity of objects.
    -->
    
    <para>
    </para>

    <!--
   4. Every object has a type. Using the parlance, each object is an
      instance of a class, in which "class" is synonymous with
      "type." The most important distinguishing characteristic
      of a class is "What messages can you send to it?"
    -->

    <para>
    </para>

    <!--
    5. All objects of a particular type can receive the same
    messages. This is actually a loaded statement, as you will see
    later. Because an object of type "circle" is also an
    object of type "shape," a circle is guaranteed to accept
    shape messages. This means you can write code that talks to shapes
    and automatically handles anything that fits the description of a
    shape. This substitutability is one of the most powerful concepts in
    OOP.
    -->
    
    <para>
    </para>

  </sect1>

  <sect1>
      <title>Un objeto tiene una interfaz</title>

      <!-- Aristotle was probably the first to begin a careful study of
      the concept of type; he spoke of "the class of fishes and the
      class of birds."      The idea that all objects, while being
      unique, are also part of a class of objects that have
      characteristics and behaviors in common was used directly in the
      first object-oriented language, Simula-67, with its fundamental
      keyword class that introduces a new type into a program.
      -->

      <para>
	Aristoteles probablemente fue el primero en hacer un estudio
	minucioso del concepto de <emphasis>>tipo</emphasis>; él habló
	de <quote>las clases de peces y las clases de
	pájaros</quote>. La idea de que todos los objetos, aún siendo
	únicos, también son parte de una clase de objetos que tienen
	características y comportamiento común se utilizó directamente
	en el primer lenguaje orientado a objetos, Simula-67, con su
	palabra reservada <keyword>class</keyword> que introduce un
	nuevo tipo en un programa.
      </para>

      <!-- 
      Simula, as its name implies, was created for developing
      simulations such as the classic "bank teller
      problem[5]." In this, you have a bunch of tellers, customers,
      accounts, transactions, and units of money \u2013 a lot of
      \u201cobjects.\u201d Objects that are identical except for their
      state during a program\u2019s execution are grouped together into
      \u201cclasses of objects\u201d and that\u2019s where the keyword
      class came from. Creating abstract data types (classes) is a
      fundamental concept in object-oriented programming. Abstract data
      types work almost exactly like built-in types: You can create
      variables of a type (called objects or instances in
      object-oriented parlance) and manipulate those variables (called
      sending messages or requests; you send a message and the object
      figures out what to do with it). The members (elements) of each
      class share some commonality: every account has a balance, every
      teller can accept a deposit, etc. At the same time, each member
      has its own state, each account has a different balance, each
      teller has a name. Thus, the tellers, customers, accounts,
      transactions, etc., can each be represented with a unique entity
      in the computer program. This entity is the object, and each
      object belongs to a particular class that defines its
      characteristics and behaviors.  -->

    <!--
    [5] You can find an interesting implementation of this problem in Volume
    2 of this book, available at www.BruceEckel.com.
    -->
    
      <para>
	Simula, como su nombre indica, fue creado para desarrollar
	simulaciones como el clásico FIXME:<quote>back teller
	problem</quote><footnote>
	<para>
	  Puede encontrar una interesante implementación de este
	  problema en el 2º Volumen de este libro, disponible en <ulink
	    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>
	</para>
      </footnote>

      </para>

  </sect1>

  <sect1>
    <title>La implementación oculta</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Reutilizando la implementación</title>
    <para></para>
  </sect1>

  <sect1>
    <title>Herencia: reutilización de interfaces</title>
    <para></para>
  </sect1>
  
  <sect1>
    <title>Objetos intercambiables gracias al polimorfismo</title>
    <para></para>    
  </sect1>
  
  <sect1>
    <title>Creación y destrucción de objetos</title>
    <para></para>    
  </sect1> 

  <sect1>
    <title>Gestión de excepciones: tratamiento de errores</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Análisis y diseño</title>
    <para></para>   
  </sect1>
    
  <sect1>
    <title>Programación Extrema</title>
    <para></para>    
  </sect1>

  <sect1>
    <title>Porqué triunfa C++</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Estrategias para la transición</title>
    <para></para>   
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para></para>  
  </sect1>

</chapter>

<!-- Local Variables: -->
<!-- sgml-parent-document:"PensarEnC++.sgml" -->
<!-- End: -->
  