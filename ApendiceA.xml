<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: David Villa Alises
  Formateado DocBook:  David Villa Alises
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<appendix
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="ApendiceA">
  
  <!-- Coding Style -->

  <title>Estilo de codificación</title>

  <!--
  This appendix is not about indenting and placement of parentheses and
  curly braces, although that will be mentioned. It is about the general
  guidelines used in this book for organizing the code listings.
  -->

  <para>
    Este apéndice no trata sobre indentación o colocación de paréntesis
    y llaves, aunque si que se menciona. Trata sobre las directrices
    generales que se usan en este libro para la organización de los
    listados de código.
  </para>


  <!-- 
  Although many of these issues have been introduced throughout the
  book, this appendix appears at the end so it can be assumed that every
  topic is fair game, and if you don't understand something you can
  look it up in the appropriate section.
  -->

  <para>
    Aunque muchas de estas cuestiones se han tratado a lo largo del
    libro, este apéndice aparece al final así que se puede asumir que
    cada tema es FIXME:juego limpio, y si no entiende algo puede buscar
    en la sección correspondiente.
  </para>


  <!-- 
  All the decisions about coding style in this book have been
  deliberately considered and made, sometimes over a period of years. Of
  course, everyone has their reasons for organizing code the way they
  do, and I'm just trying to tell you how I arrived at mine and the
  constraints and environmental factors that brought me to those
  decisions.
  -->

  <para>
    Todas las decisiones sobre estilo de codificación en este libro han
    sido consideradas y ejectuadas deliberadamente, a veces a lo largo
    de períodos de años. Por supuesto, cada uno tiene sus razones para
    organizar el código en el modo en que lo hace, y yo simplemente
    intento explicarle cómo llegué a tomar mi postura y las
    restricciones y factores del entorno que me llevarón a tomar esas
    decisiones.
  </para>


  <sect1>
     <!--  General -->
    <title>General</title>

    <!-- 
    In the text of this book, identifiers (function, variable, and class
    names) are set in bold. Most keywords will also be set in bold, except
    for those keywords that are used so much that the bolding can become
    tedious, such as "class" and "virtual."
    -->

    <para>
      En el testo de este libro, los identificadores (funciones,
      variables, y nombres de clases) aparecen en negrita. Muchas
      palabras reservadas también son negritas, exceptuando aquellas que
      se usan tan a menudo que escribirlas en negrita puede resultar
      tedioso, como <quote>class</quote> o <quote>virtual</quote>.
    </para>

    
    <!-- 
    I use a particular coding style for the examples in this book. It
    was developed over a number of years, and was partially inspired by
    Bjarne Stroustrup's style in his original The C++ Programming
    Language.[64] The subject of formatting style is good for hours of
    hot debate, so I' ll just say I'm not trying to dictate correct
    style via my examples; I have my own motivation for using the style
    that I do. Because C++ is a free-form programming language, you can
    continue to use whatever style you're comfortable with.
    -->

    <para>
      Utilizo un estilo de codificación particular para los ejemplos de
      este libro. Se desarrolló a lo largo de varios años, y se inspiró
      parcialmente en el estilo de <author>Bjarne Stroustrup</author> en
      el <citetitle>The C++ Programming Language</citetitle>
      <footnote>
	<para>
	  FIXME
	</para>
      </footnote>
      origina. El asunto del estilo de formato es perfecto para horas de
      acalorado debate, así que sólo diré que no trato de dictar el
      estilo correcto a través de mis ejemplos; tengo mis propios
      motivos para usar el estilo que uso. Como C++ es un lenguaje de
      FIXME:forma libre, cada uno puede continuar usando aquel estilo
      en que se encuentre más cómodo.
    </para>


    <!--
    That said, I will note that it is important to have a consistent
    formatting style within a project. If you search the Internet, you
    will find a number of tools that can be used to reformat all the
    code in your project to achieve this valuable consistency.
    -->

    <para>
      Dicho esto, si haré hincapié en que es importante tener un estilo
      consistente dentro de un proyecto. Si busca en Internet,
      encontrará un buen número de herramientas que se pueden utilizar
      para reformatear todo el código de un proyecto para conseguir esa
      valiosa consistencia.
    </para>


    <!--   
    The programs in this book are files that are automatically extracted
    from the text of the book, which allows them to be tested to ensure
    that they work correctly. Thus, the code files printed in the book
    should all work without compile-time errors when compiled with an
    implementation that conforms to Standard C++ (note that not all
    compilers support all language features). The errors that should cause
    compile-time error messages are commented out with the comment //! so
    they can be easily discovered and tested using automatic means. Errors
    discovered and reported to the author will appear first in the
    electronic version of the book (at www.BruceEckel.com) and later in
    updates of the book.
    -->

    <para>
      Los programas de este libro son ficheros que has sido extraidos
      automáticamentente del texto del libro, lo que permite que se
      puedan probar para asegurar que funcionan correctamente 
      <footnote>
	<para>
	  (N. de T.) Se refiere al libro original. En esta traducción,
	  los programas son ficheros externos incluidos en el texto.
	</para>
      </footnote>. De ese modo, el código mostrado en el libro debería
      funcionar sin errores cuando se compile con una implementación
      conforme al Estándar C++ (no todos los compiladores soportan todas
      las características del lenguaje). Las sentencias que causarían
      errores de compilación están comentadas con //! de modo que se
      pueden descubrir y probar fácilmente de modo automático. Los
      errores desubiertos por el autor aparecerán primero en la versión
      electrónica del libro (<ulink
      url="http://www.BruceEchel.com">www.BruceEckel.com</ulink>) y
      después en las actualizaciones del libro.
    </para>


    <!-- 
    One of the standards in this book is that all programs will compile
    and link without errors (although they will sometimes cause
    warnings). To this end, some of the programs, which demonstrate only a
    coding example and don't represent stand-alone programs, will have
    empty main( ) functions, like this
    -->

    <para>
      Uno de los estándares de este libro es que todos los programas
      compilarán y enlazarán sin errores (aunque a veces causarán
      advertencias). Algunos de los programas, que demuestran sólo un
      ejemplo de codificación y no representan programas completos,
      tendrán funciones <function>main()</function> vacias, como ésta:
    </para>

    <programlisting>
    int main() {}
</programlisting>
 

    <!-- 
    This allows the linker to complete without an error.
    -->

    <para>
      Esto permite que se pueda enlazar el programa sin errores.
    </para>

    <!-- 
    The standard for main( ) is to return an int, but Standard C++
    states that if there is no return statement inside main( ), the
    compiler will automatically generate code to return 0. This option
    (no return statement in main( )) will be used in this book (some
    compilers may still generate warnings for this, but those are not
    compliant with Standard C++).  
    -->

    <para>
      El estándar para <function>main()</function> es retornar un
      <type>int</type>, pero C++ Estándar estipula que si no hay una
      sentencia <keyword>return</keyword> en
      <function>main()</function>, el compilador generará
      automáticamente código para <programlisting>return
      0</programlisting>. Esta opción (no poner un
      <keyword>return</keyword> en <function>main()</function>) se usa
      en el libro (algunos compiladores producen advertencias sobre
      ello, pero es porque no son conformes con C++ Estándar).
    </para>
  </sect1>

  <sect1>
   <!--  File names -->
    <title>Nombres de fichero</title>

    <!-- 
    In C, it has been traditional to name header files (containing
    declarations) with an extension of .h and implementation files (that
    cause storage to be allocated and code to be generated) with an
    extension of .c. C++ went through an evolution. It was first developed
    on Unix, where the operating system was aware of upper and lower case
    in file names. The original file names were simply capitalized
    versions of the C extensions: .H and .C. This of course didn't work
    for operating systems that didn't distinguish upper and lower case,
    such as DOS. DOS C++ vendors used extensions of hxx and cxx for header
    files and implementation files, respectively, or hpp and cpp.

 Later,
    someone figured out that the only reason you needed a different
    extension for a file was so the compiler could determine whether to
    compile it as a C or C++ file. Because the compiler never compiled
    header files directly, only the implementation file extension needed
    to be changed. The custom, across virtually all systems, has now
    become to use cpp for implementation files and h for header
    files. Note that when including Standard C++ header files, the option
    of having no file name extension is used, i.e.: #include &lt;iostream>.
    -->

    <para>
      En C, es tradición nombrar a lo ficheros de cabecera (que
      contienen las declaraciones) con una extensión
      <filename>.h</filename> y a los ficheros de implementación (que
      generan alojamiento en memoria y código) con una extensión
      <filename>.c</filename>. C++ supuso una evolución. Primero fue
      desarrollado en Unix, donde el sistema operativo distingue entre
      mayúsculas y minúsculas para nombres de ficheros. Los nombres
      originales para los ficheros simplemente se pusieron en mayúscula:
      <filename>.H</filename> y <filename>.C</filename>. Esto, por
      supuesto, no funcionaba en sistemas operativos que no distinguen
      entre mayúsculas y minúsculas como DOS. Los vendedores de C++ para
      DOS usaban extenciones <filename>hxx</filename> y
      <filename>cxx</filename>, o <filename>hpp</filename> y
      <filename>cpp</filename>. Después, alguien se dió cuenta que la
      única razón por la que se puede necesitar un extensión diferente
      es que el compilador no puede determinar si debe compilarlo como C
      o C++. Como el compilador nunca compila ficheros de cabecera
      directamente, sólo el fichero de implementación necesita una
      distinción. Ahora, en prácticamente todos los sistemas, la
      costumbre es usar <filename>cpp</filename> para los ficheros de
      implementación y <filename>.h</filename> para los ficheros de
      cabecera. Fíjese que cuando se incluye un fichero de cabecera C++,
      se usa la opción de no poner extensión al nombre del fichero, por
      ejemplo: <programlisting>#include &lt;iostream></programlisting>.
    </para>
  </sect1>

  <sect1>
   <!-- Begin and end comment tags -->
    <title>Marcas comentadas de inicio y fin</title>

    
    <!-- 
    A very important issue with this book is that all code that you see in
    the book must be verified to be correct (with at least one
    compiler). This is accomplished by automatically extracting the files
    from the book. To facilitate this, all code listings that are meant to
    be compiled (as opposed to code fragments, of which there are few)
    have comment tags at the beginning and end. These tags are used by the
    code-extraction tool ExtractCode.cpp in Volume 2 of this book (which
    you can find on the Web site www.BruceEckel.com) to pull each code
    listing out of the plain-ASCII text version of this book.
    -->

    <para>
      Un tema muy importante en este libro es que todo el código que
      puede ver en el libro deber ser verificado (con al menos un
      compilador). Esto se consigue extrayendo automáticamente los
      listados del libro. Para facilitar esta tarea, todos los listados
      de código susceptibles de ser compilados (al contrario que los
      fragmentos, de los que hay pocos) tienen unas marcas comentadas al
      principio y al final. Estas marcas las usa la herramienta de
      extracción de código <filename>ExtractCode.cpp</filename> del
      Volumen 2 de este libro (y que se puede encontrar en el sitio web
      (<ulink
      url="http://www.BruceEchel.com">www.BruceEckel.com</ulink>)) para
      extraer cada listado de código a partir de la versión en texto
      plano ASCII de este libro.
    </para>


    <!-- 
    The end-listing tag simply tells ExtractCode.cpp that it's the end of
    the listing, but the begin-listing tag is followed by information
    about what subdirectory the file belongs in (generally organized by
    chapters, so a file that belongs in Chapter 8 would have a tag of
    C08), followed by a colon and the name of the listing file.
    -->

    <para>
      La marca de fin de listado simplemente le indica a
      <filename>ExtractCode.cpp</filename> que ese es el final del
      listado, pero la marca de comienzo incluye información sobre el
      subdirectorio al que corresponde el fichero (normalmente
      organizado por capítulos, así que si corresponde al Capítulo 8
      debería tener una marca como C08), seguido de dos puntos y el
      nombre del fichero.
    </para>


    <!-- 
    Because ExtractCode.cpp also creates a makefile for each subdirectory,
    information about how a program is made and the command-line used to
    test it is also incorporated into the listings. If a program is
    stand-alone (it doesn't need to be linked with anything else) it has
    no extra information. This is also true for header files. However, if
    it doesn't contain a main( ) and is meant to be linked with something
    else, then it has an {O} after the file name. If this listing is meant
    to be the main program but needs to be linked with other components,
    there's a separate line that begins with //{L} and continues with all
    the files that need to be linked (without extensions, since those can
    vary from platform to platform).
    -->

    <para>
      Como <filename>ExtractCode.cpp</filename> también crea un
      <filename>makefile</filename> para cada subdirectorio, la
      información de cómo construir el programa y la línea de comando
      que se debe usar para probarlo también se incorpora a los
      listados. Si un programa es autónomo (no necesita ser enlazado con
      nada más) no tiene información extra. Esto también es cierto para
      los ficheros de cabecera. Sin embargo, si no contiene un
      <filename>main()</filename> y necesita enlazarse con algo otro,
      aparece un {O} después del nombre del fichero. Si ese listado es
      el programa principal pero necesita ser enlazado con otros
      componentes, hay una línea adicional que comienza con //{L} y
      continua con todos los ficheros con los que necesita ser enlazado
      (sin extensiones, dado que puede varía entre plataformas).
    </para>


    <!-- 
    You can find examples throughout the book.
    -->

    <para>
      Puede encontrar ejemplos a lo largo del libro.
    </para>


    <!-- 
    If a file should be extracted but the begin- and end-tags should not
    be included in the extracted file (for example, if it's a file of
    test data) then the begin-tag is immediately followed by a '!'.
    -->

    <para>
      Cuando un fichero debe extraerse sin que las marcas de inicio y fin 
      deban incluirse en el fichero extraido (por ejemplo, si es un
      fichero con datos para una prueba) la marca de inicio va seguida
      de un '!'.
    </para>
  </sect1>

  
  <sect1>
   <!-- Parentheses, braces, and indentation -->
    <title>Paréntesis, llaves e indentación</title>


    <!-- 
    You may notice the formatting style in this book is different from
    many traditional C styles. Of course, everyone thinks their own style
    is the most rational. However, the style used here has a simple logic
    behind it, which will be presented here mixed in with ideas on why
    some of the other styles developed.
    -->

    <para>
      Habrá notado que el estilo de este libro es diferente a la mayoría
      de los estilos C tradicionales. Por supuesto, cualquiera puede
      pensar que su propio estilo es más racional. Sin embargo, el
      estilo que se emplea aquí tiene una lógica más simple, que se
      presentará mezclada con las de otros estilos desarrollados.
    </para>


    <!-- 
    The formatting style is motivated by one thing: presentation, both in
    print and in live seminars. You may feel your needs are different
    because you don't make a lot of presentations. However, working code
    is read much more than it is written, and so it should be easy for the
    reader to perceive. My two most important criteria are "scannability"
    (how easy it is for the reader to grasp the meaning of a single line)
    and the number of lines that can fit on a page. This latter may sound
    funny, but when you are giving a live presentation, it's very
    distracting for the audience if the presenter must shuffle back and
    forth between slides, and a few wasted lines can cause this.
    -->

    <para>
      El estilo está motivado por una cosa: la presentación, tanto
      impresa como en un seminario. Quizá sus necesidades sean
      diferentes porque no realiza muchas presentaciones. Sin embargo,
      el código real se lee muchas veces de las que se escribe, y por
      eso deberías ser fácil de leer. Mis dos criterios más importantes
      son la <quote>scannability</quote> (que se refiere a la facilidad
      con la que el lector puede comprender el significado de una única
      línea) y el número de líneas que caben en una página. Lo segundo
      puede sonar gracioso, pero cuando uno da una charla, distrae mucho
      a la audiencia que el ponente tenga que avanzar y retroceder
      diapositivas, y sólo unas pocas líneas de más puede provocar este
      efecto.
    </para>


    <!-- 
    Everyone seems to agree that code inside braces should be
    indented. What people don't agree on - and the place where there's
    the most inconsistency within formatting styles - is this: Where does
    the opening brace go? This one question, I think, is what causes such
    variations among coding styles (For an enumeration of coding styles,
    see C++ Programming Guidelines, by Tom Plum and Dan Saks, Plum Hall
    1991.) I'll try to convince you that many of today's coding styles
    come from pre-Standard C constraints (before function prototypes) and
    are thus inappropriate now.
    -->
    
    <para>
      Todo el mundo parece estar de acuerdo en el que código que se pone
      dentro de llaves debe estar indentado. En lo que la gente no está
      de acuerdo - y es el sitio donde más inconsistencia tienen los
      estilos - es: ¿Dónde debe ir la llave de apertura? Esta única
      cuestió, creo yo, es la que causa la mayoría de las variaciones en
      los estilos de codificación (Si quiere ver una enumeración de
      estilos de codificación vea <citetitle>Directrices de Programación
      C++</citetitle>, de Tom Plum y Dan Saks, Plum Hall 1991.)
      Intentaré convencerle de que muchos de los estilos de codificación
      actuales provienen de la restricciones previas al C Estándar
      (antes de los prototipos de función) de manera que no son
      apropiadas actualmente.
    </para>


    <!-- 
    First, my answer to that key question: the opening brace should always
    go on the same line as the "precursor" (by which I mean "whatever
    the body is about: a class, function, object definition, if statement,
    etc."). This is a single, consistent rule I apply to all of the code
    I write, and it makes formatting much simpler. It makes the
    "scannability" easier - when you look at this line:
    -->
    
    <para>
      Lo primero, mi respuesta a esa pregunta clave: la llave de
      apertura debería ir siempre en la misma línea que el
      <quote>precursor</quote> (es decir <quote>cualquier cosa de la que
      sea cuerpo: una clase, función, definición de objeto, sentencia
      <keyword>if</keyword>, etc</quote>. ES una regla única y
      consistente que aplico a todos el código que escribo, y hace que
      el formateo de código sea mucho más sencillo. Hace más sencilla la
      <quote>scannabilidad</quote> - cuando se lee esta línea:
    </para>


    <programlisting>
    int func(int a);
</programlisting> 

    <!-- 
    you know, by the semicolon at the end of the line, that this is a
    declaration and it goes no further, but when you see the line:
    -->

    <para>
      Se sabe, por el punto y coma al final de la línea, que esto es una
      declaración y no hay nada más, pero al leer la línea:
    </para>


    <programlisting>
  int func(int a) {
</programlisting>  

    <!-- 
    you immediately know it's a definition because the line finishes with
    an opening brace, not a semicolon. By using this approach, there's no
    difference in where you place the opening parenthesis for a multi-line
    definition:
    -->

    <para>
      inmediatamente se sabe que se una definición porque la línea
      termina con una llave de apertura, no un punto y coma. Usando este
      enfoque, no hay diferencia a la hora de colocar el paréntesis de
      apertura en una definición de múltiples líneas.
    </para>


    <programlisting>
    int func(int a) {
      int b = a + 1;
      return b * 2;
    } 
</programlisting> 


    <!-- 
    and for a single-line definition that is often used for inlines:
    -->
    
    <para>
      y para una definición de una sola línea que a menudo se usa para inlines:
    </para>


    <programlisting>
    int func(int a) { return (a + 1) * 2; }
</programlisting> 


    <!-- 
    Similarly, for a class:
    -->

    <para>
      Igualmente, para una clase:
    </para>


    <programlisting>
    class Thing;
</programlisting> 


    <!-- 
    is a class name declaration, and
    -->

    <para>
      es una declaración del nombre de una clase, y
    </para>


    <programlisting>
    class Thing {
</programlisting> 


    <!-- 
    is a class definition. You can tell by looking at the single line in
    all cases whether it's a declaration or definition. And of course,
    putting the opening brace on the same line, instead of a line by
    itself, allows you to fit more lines on a page.
    -->

    <para>
      es una definición de clase. En todos los casos, se puede saber
      mirando una sola línea si se trata de una declaración o una
      definición. Y por suspuesto, poniendo la llave de apertura en la
      misma línea, en lugar de una línea propia, permite ahorrar espacio
      en la página.
    </para>


    <!-- 
    So why do we have so many other styles? In particular, you'll notice
    that most people create classes following the style above (which
    Stroustrup uses in all editions of his book The C++ Programming
    Language from Addison-Wesley) but create function definitions by
    putting the opening brace on a single line by itself (which also
    engenders many different indentation styles). Stroustrup does this
    except for short inline functions. With the approach I describe here,
    everything is consistent - you name whatever it is (class, function,
    enum, etc.) and on that same line you put the opening brace to
    indicate that the body for this thing is about to follow. Also, the
    opening brace is the same for short inlines and ordinary function
    definitions.
    -->

    <para>
      Así que ¿por qué tenemos tantos otros estilos? En concreto, verá
      que mucha gente crea clases siguiente el estilo anterior (que
      Stroustrup usa en todas las ediciones de su libro <citetitle>The
      C++ Programming Language</citetitle> de Addison-Wesley) pero crean
      definiciones de funciones poniendo la llave de apertura en una
      línea aparte (lo que da lugar a muchos estilos de indentación
      diferentes). Stroustrup lo hace excepto para funciones inline
      cortas. Con el enfoque que yo describo aquí, todo es consistente -
      se nombra lo que sea (clase, función, enumerado, etc) y en la
      misma línea se pone la llave de apertura para indicar que el
      cuerpo de esa cosa está debajo. Y también, la llave de apertura se
      pone en el mismo sitio para funciones inline que para definiciones
      de funciones ordinarias.
    </para>


    <!-- 
    I assert that the style of function definition used by many folks
    comes from pre-function-prototyping C, in which you didn't declare
    the arguments inside the parentheses, but instead between the closing
    parenthesis and the opening curly brace (this shows C's
    assembly-language roots):
    -->

    <para>
    </para>


    <programlisting>
    void bar()
     int x;
     float y;
    {
     /* body here */
    } 
</programlisting> 


    <!-- 
    Here, it would be quite ungainly to put the opening brace on the same
    line, so no one did it. However, they did make various decisions about
    whether the braces should be indented with the body of the code or
    whether they should be at the level of the "precursor." Thus, we got
    many different formatting styles.
    -->

    <para>
    </para>


    <!-- 
    There are other arguments for placing the brace on the line
    immediately following the declaration (of a class, struct, function,
    etc.). The following came from a reader, and is presented here so you
    know what the issues are:
    -->

    <para>
    </para>


    <!-- 
    Experienced 'vi' (vim) users know that typing the ']' key twice
    will take the user to the next occurrence of '{' (or ^L) in column
    0. This feature is extremely useful in navigating code (jumping to the
    next function or class definition). [My comment: when I was initially
    working under Unix, GNU Emacs was just appearing and I became enmeshed
    in that. As a result, 'vi' has never made sense to me, and thus I do
    not think in terms of "column 0 locations." However, there is a fair
    contingent of 'vi' users out there, and they are affected by this
    issue.]
    -->

    <para>
    </para>


    <!-- 
    Placing the '{' on the next line eliminates some confusing code in
    complex conditionals, aiding in the scannability. Example:
    -->

    <para>
    </para>

    <programlisting>
    if(cond1
       &amp;&amp; cond2
       &amp;&amp; cond3) {
       statement;
    } 
</programlisting> 


    <!-- 
    The above [asserts the reader] has poor scannability. However,
    -->

    <para>
    </para>

    <programlisting>
    if (cond1
    &amp;&amp; cond2
    &amp;&amp; cond3)
    {
    statement;
    } 
</programlisting>  


    <!-- 
    breaks up the 'if' from the body, resulting in better
    readability. [Your opinions on whether this is true will vary
    depending on what you're used to.]
    -->

    <para>
    </para>


    <!-- 
    Finally, it's much easier to visually align braces when they are
    aligned in the same column. They visually "stick out" much
    better. [End of reader comment]
    -->

    <para>
    </para>


    <!-- 
    The issue of where to put the opening curly brace is probably the most
    discordant issue. I've learned to scan both forms, and in the end it
    comes down to what you've grown comfortable with. However, I note
    that the official Java coding standard (found on Sun's Java Web site)
    is effectively the same as the one I present here - since more folks
    are beginning to program in both languages, the consistency between
    coding styles may be helpful.
    -->

    <para>
    </para>


    <!-- 
    The approach I use removes all the exceptions and special cases, and
    logically produces a single style of indentation as well. Even within
    a function body, the consistency holds, as in:
    -->

    <para>
    </para>

    <programlisting>
    for(int i = 0; i &lt; 100; i++) {
      cout &lt;&lt; i &lt;&lt; endl;
      cout &lt;&lt; x * i &lt;&lt; endl;
    } 
</programlisting> 


    <!-- 
    The style is easy to teach and to remember - you use a single,
    consistent rule for all your formatting, not one for classes, two for
    functions (one-line inlines vs. multi-line), and possibly others for
    for loops, if statements, etc. The consistency alone, I think, makes
    it worthy of consideration. Above all, C++ is a newer language than C,
    and although we must make many concessions to C, we shouldn't be
    carrying too many artifacts with us that cause problems in the
    future. Small problems multiplied by many lines of code become big
    problems. For a thorough examination of the subject, albeit in C, see
    C Style: Standards and Guidelines, by David Straker (Prentice-Hall
    1992).
    -->

    <para>
    </para>


    <!-- 
    The other constraint I must work under is the line width, since the
    book has a limitation of 50 characters. What happens when something is
    too long to fit on one line? Well, again I strive to have a consistent
    policy for the way lines are broken up, so they can be easily
    viewed. As long as something is part of a single definition, argument
    list, etc., continuation lines should be indented one level in from
    the beginning of that definition, argument list, etc.
    -->

    <para>
    </para>
  </sect1>


  <sect1>
    <!-- Identifier names -->
    <title>Nombres para identificadores</title>


    <!-- 
    Those familiar with Java will notice that I have switched to using the
    standard Java style for all identifier names. However, I cannot be
    completely consistent here because identifiers in the Standard C and
    C++ libraries do not follow this style.
    -->

    <para>
    </para>

    <!--
    The style is quite straightforward. The first letter of an identifier
    is only capitalized if that identifier is a class. If it is a function
    or variable, then the first letter is lowercase. The rest of the
    identifier consists of one or more words, run together but
    distinguished by capitalizing each word. So a class looks like this:
    -->
    
    <para>
    </para>

    <programlisting>
    class FrenchVanilla : public IceCream {
</programlisting> 


    <!-- 
    an object identifier looks like this:
    -->

    <para>
    </para>

    <programlisting>
    FrenchVanilla myIceCreamCone(3);
</programlisting> 


    <!-- 
    and a function looks like this:
    -->

    <para>
    </para>


    <programlisting>
    void eatIceCreamCone();
</programlisting>  


    <!-- 
    (for either a member function or a regular function).
    -->

    <para>
    </para>

    
    <!-- 
    The one exception is for compile-time constants (const or #define), in
    which all of the letters in the identifier are uppercase.
    -->

    <para>
    </para>


    <!-- 
    The value of the style is that capitalization has meaning - you can
    see from the first letter whether you're talking about a class or an
    object/method. This is especially useful when static class members are
    accessed.
    -->

    <para>
    </para>
  </sect1>


  <sect1>
    
    <!-- Order of header inclusion -->
    <title>Orden de los #includes</title>

    <!-- 
    Headers are included in order from "the most specific to the most
    general." That is, any header files in the local directory are
    included first, then any of my own "tool" headers, such as
    require.h, then any third-party library headers, then the Standard C++
    Library headers, and finally the C library headers.
    -->
    
    <para>
    </para>


    <!-- 
    The justification for this comes from John Lakos in Large-Scale C++
    Software Design (Addison-Wesley, 1996):
    -->

    <para>
    </para>


    <!-- 
    Latent usage errors can be avoided by ensuring that the .h file of a
    component parses by itself - without externally-provided declarations
    or definitions... Including the .h file as the very first line of the
    .c file ensures that no critical piece of information intrinsic to the
    physical interface of the component is missing from the .h file (or,
    if there is, that you will find out about it as soon as you try to
    compile the .c file).
    -->

    <para>
    </para>


    <!-- 
    If the order of header inclusion goes "from most specific to most
    general," then it's more likely that if your header doesn't parse
    by itself, you'll find out about it sooner and prevent annoyances
    down the road.
    -->

    <para>
    </para>
  </sect1>

  
  <sect1>
    <!-- Include guards on header files -->
    <title>Guardas de inclusión en ficheros de cabecera</title>

    <!-- 
    Include guards are always used inside header files to prevent multiple
    inclusion of a header file during the compilation of a single .cpp
    file. The include guards are implemented using a preprocessor #define
    and checking to see that a name hasn't already been defined. The name
    used for the guard is based on the name of the header file, with all
    letters of the file name uppercase and replacing the '.' with an
    underscore. For example:
    -->

    <para>
    </para>

    <programlisting>
    // IncludeGuard.h
    #ifndef INCLUDEGUARD_H
    #define INCLUDEGUARD_H
    // Body of header file here...
    #endif // INCLUDEGUARD_H
</programlisting>


    <!-- 
    The identifier on the last line is included for clarity. Although some
    preprocessors ignored any characters after an #endif, that isn't
    standard behavior and so the identifier is commented.
    -->

    <para>
    </para>
  </sect1>


  <sect1>
    <!-- Use of namespaces -->
    <title>Utilidad de los espacios de nombres</title>

    <!-- 
    In header files, any "pollution" of the namespace in which the
    header is included must be scrupulously avoided. That is, if you
    change the namespace outside of a function or class, you will cause
    that change to occur for any file that includes your header, resulting
    in all kinds of problems. No using declarations of any kind are
    allowed outside of function definitions, and no global using
    directives are allowed in header files.
    -->
    
    <para>
    </para>


    <!-- 
    In cpp files, any global using directives will only affect that file,
    and so in this book they are generally used to produce more
    easily-readable code, especially in small programs.
    -->
    
    <para>
    </para>
  </sect1>


  <sect1>
    <!-- Use of require( ) and assure( ) -->
    <title>
      Utilidad de <filename>require()</filename> and
      <filename>assure)()</filename>
    </title>

    <!-- 
    The require( ) and assure( ) functions defined in require.h are used
    consistently throughout most of the book, so that they may properly
    report problems. If you are familiar with the concepts of
    preconditions and postconditions (introduced by Bertrand Meyer) you
    will recognize that the use of require( ) and assure( ) more or less
    provide preconditions (usually) and postconditions
    (occasionally). Thus, at the beginning of a function, before any of
    the "core" of the function is executed, the preconditions are
    checked to make sure everything is proper and that all of the
    necessary conditions are correct. Then the "core" of the function is
    executed, and sometimes some postconditions are checked to make sure
    that the new state of the data is within defined parameters. You'll
    notice that the postcondition checks are rare in this book, and
    assure( ) is primarily used to make sure that files were opened
    successfully.
    -->

    <para>
    </para>
  </sect1>

</appendix>
