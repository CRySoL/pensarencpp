<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: jesus lopez mollo <i302154@correo.unnet.es>
                       (anterior a LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:
  2ª Revisión

-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C16">

  <title>Introducción a las Plantillas</title>

  <highlights>
    <para>
      La herencia y la composición proporcionan una forma de retilizar
      código objeto.  Las plantillas de C++ proporcionan una manera de
      reutilizar el código <emphasis>fuente</emphasis>.
    </para>
  </highlights>

  <para>
    Aunque las plantillas (o templates) son una herramienta de
    programación de propósito general, cuando fueron introducidos en el
    lenguaje, parecían oponerse al uso de las jerarquías de clases
    contenedoras basadas en objetos (demostrado al final del Capítulo
    15). Además, los contenedores y algoritmos del C++ Standard
    (explicados en dos capítulos del Volumen 2 de este libro, que se
    puede bajar de <ulink
    url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>) están
    construidos exclusivamente con plantillas y son relativamente
    fáciles de usar por el programador.
  </para>

  <para>
    Este capítulo no sólo muestra los fundamentos de los templates,
    también es una introducción a los contenedores, que son componentes
    fundamentales de la programación orientada a objetos lo cual se
    evidencia a través de los contenedores de la librería estándar de
    C++. Se verá que este libro ha estado usando ejemplos contenedores -
    <classname>Stash</classname> y <classname>Stack</classname>- para
    hacer más sencillo el concepto de los contenedores; en este capítulo
    se sumará el concepto del <classname>iterator</classname>. Aunque
    los contenedores son el ejemplo ideal para usarlos con las
    plantillas, en el Volumen 2 (que tiene un capítulo con plantillas
    avanzadas) se aprenderá que también hay otros usos para los
    templates.
  </para>


  <sect1>
    <title>Contenedores</title>

    <para>
      Supóngase que se quiere crear una pila, como se ha estado haciendo
      a través de este libro. Para hacerlo sencillo, esta clase manejará
      enteros.
    </para>


//: V1C16:IntStack.cpp


    <!--
    The class IntStack is a trivial example of a push-down stack. For
    simplicity it has been created here with a fixed size, but you can
    also modify it to automatically expand by allocating memory off the
    heap, as in the Stack class that has been examined throughout the
    book.
    -->

    <para>
      La clase <classname>IntStack</classname> es un ejemplo trivial de
      una pila. Para mantener la simplicidad ha sido creada con un
      tamaño fijo, pero se podría modificar para que automáticamente se
      expanda usando la memoria del montón, como en la clase
      <classname>Stack</classname> que ha sido examinada a través del
      libro.
    </para>

    <para>
      <function>main()</function> añade algunos enteros a la pila, y
      posteriormente los extrae.  Para hacer el ejemplo más interesante,
      los enteros son creados con la función
      <function>fibonacci()</function>, que genera los tradicionales
      números de la reproducción del conejo. Aquí está el archivo de
      cabecera que declara la función:
    </para>



//: V1C16:fibonacci.h



    <para>
      Aquí está la implementación:
    </para>



//: V1C16:fibonacci.cpp



    <para>
      Esta es una implementación bastante eficiente, porque nunca se
      generan los números más de una vez. Se usa un array
      <kw>static</kw> de <type>int</type>, y se basa en el hecho de que
      el compilador inicializará el array estático a cero.  El primer
      bucle <kw>for</kw> mueve el índice <varname>i</varname> a la
      primera posición del array que sea cero, entonces un bucle
      <kw>while</kw> añade números Fibonacci al array hasta que se
      alcance el elemento deseado. Hay que hacer notar que si los
      números Fibonacci hasta el elemento <varname>n</varname> ya están
      inicializados, entonces también se salta el bucle <kw>while</kw>.
    </para>


    <sect2>
      <title>La necesidad de los contenedores</title>

      <para>
	Obviamente, una pila de enteros no es una herramienta
	crucial. La necesidad real de los contenedores viene cuando se
	empizan a crear objetos en el montón (heap) usando <kw>new</kw> y se destruyen con <kw>delete</kw>. En un problema general de
	programación no se saben cuantos objetos van a ser necesarios
	cuando se está escribiendo el programa. Por ejemplo, en un
	sistema de control de tráfico aéreo no se quiere limitar el
	número de aviones que el sistema pueda gestionar. No puede ser
	que el programa se aborte sólo porque se excede algún
	número. En un sistema de diseño asistido por computadora, se
	están manejando montones de formas, pero únicamente el usuario
	determina (en tiempo de ejecución) cuantas formas serán
	necesarias. Una vez apreciemos estas tendencias, se
	descubrirán montones de ejemplos en otras situaciones de
	programación.
      </para>

      <para>
	Los programadores de C que dependen de la memoria virtual para
	manejar su "gestión de memoria" encuentran a menudo como
	perturbantentes las ideas del <kw>new</kw>, <kw>delete</kw> y de los contenedores de
	clases. Aparentemente, una práctica en C es crear un enorme
	array global, más grande que cualquier cosa que el programa
	parezca necesitar. Para esto no es necesario pensar demasiado
	(o hay que meterse en el uso de <function>malloc()</function>
	y <function>free()</function>), pero se producen programas que
	no se pueden portar bien y que esconden sutiles errores.
      </para>

      <para>
	Además, si se crea un enorme array global de objetos en C++,
	la sobrecarga de los constructores y de los destructores
	pueden enlentecer las cosas de forma significativa. La
	aproximación de C++ funciona mucho mejor: Cuando se necesite
	un objeto, se crea con <kw>new</kw>,
	y se pone su puntero en un contenedor. Más tarde, se saca y se
	hace algo con él. De esta forma, sólo se crean los objetos
	cuando sea necesario. Y normalmente no se dan todas las
	condiciones para la inicialización al principio del
	programa. <kw>new</kw> permite
	esperar hasta que suceda algo en el entorno para poder crear
	el objeto.
      </para>

      <para>
	Así, en la situación más común, se creará un contenedor que
	almacene los punteros de algunos objetos de interés. Se
	crearán esos objetos usando <kw>new</kw> y se pondrá el puntero resultante
	en el contenedor (potencialmete haciendo upcasting en el
	proceso), más tarde el objeto se puede recuperar cuando sea
	necesario.  Esta técnica produce el tipo de programas más
	flexible y general.
      </para>

    </sect2>
  </sect1>
  <sect1>
    <!-- Overview of templates -->
    <title>Un vistazo a las plantillas</title>

    <para>
      Ahora surge un nuevo problema. Tenemos un
      <classname>IntStack</classname>, que maneja enteros. Pero
      queremos una pila que maneje formas, o flotas de aviones, o
      plantas o cualquier otra cosa.  Reinventar el código fuente cada
      vez no parece una aproximación muy inteligente con un lenguaje
      que propugna la reutilización. Debe haber un camino mejor.
    </para>

    <para>
      Hay tres técnicas para reutilizar código en esta situación: el modo
      de C, presentado aquí como contraste; la aproximación de
      Smalltalk, que afectó de forma significativa a C++, y la
      aproximación de C++: los templates.
    </para>

    <!-- FIXME: Esto es una enumeración de las técnicas con una pequeña
    explicación, pero no sé cómo ponerlo en  docbook -->
    <para>
      <emphasis>La solución de C</emphasis>. Por supuesto hay que
      escapar de la aproximación de C porque es desordenada y provoca
      errores, al mismo tiempo que no es nada elegante. En esta
      aproximación, se copia el código de una <classname>Stack
      </classname> y se hacen modificaciones a mano, introduciendo
      nuevos errores en el proceso. Esta no es una técnica muy
      productiva.
    </para>


    <!-- FIXME: referencia -->
    <para>
      <emphasis>La solución de Smalltalk</emphasis>. Smalltalk (y Java
      siguiendo su ejemplo) optó por una solución simple y directa: Se
      quiere reutilizar código, pues utilicese la herencia. Para
      implementarlo, cada clase contenedora maneja elementos de una
      clase base genérica llamada <classname>Object </classname> (similar
      al ejemplo del final del capítulo 15). Pero debido a que la
      librería de Smalltalk es fundamental, no se puede crear una
      clase desde la nada. En su lugar, siempre hay que heredar de una
      clase existente. Se encuentra una clase lo más cercana posible a
      lo que se desea, se hereda de ella, y se hacen un par de
      cambios. Obviamente, esto es un beneficio porque minimiza el
      trabajo (y explica porque se pierde un montón de tiempo
      aprendiendo la librería antes de ser un programador efectivo en
      Smalltalk).
    </para>

    <para>
      Pero también significa que todas las clases de Smalltalk acaban
      siendo parte de un único árbol de herencia. Hay que heredar de
      una rama de este árbol cuando se está creando una nueva
      clase. La mayoría del árbol ya esta allí (es la librería de
      clases de Smalltalk), y la raiz del árbol es una clase llamada
      <classname>Object</classname> - la misma clase que los contenedores
      de Smalltalk manejan.
    </para>



    <para>
      Es un truco ingenioso porque significa que cada clase en la
      jerarquía de herencia de Smalltalk (y Java<footnote> <para>Con
	  la excepción, en Java, de los tipos de datos primitivos, que se
	  hicieron no <classname>Object</classname>s por eficiencia. </para>
      </footnote>) se deriva de <classname>Object</classname>, por lo
      que cualquier clase puede ser almacenada en cualquier contenedor
      (incluyendo a los propios contenedores). Este tipo de jerarquía
      de árbol única basada en un tipo genérico fundamental (a menudo
      llamado <classname>Object</classname>, como también es el caso
      en Java) es conocido como "jerarquía basada en objectos". Se
      puede haber oido este témino y asumido que es un nuevo concepto
      fundamental de la POO, como el polimorfismo. Sin embargo,
      simplemente se refiere a la raíz de la jerarquía como
      <classname>Object </classname> (o algún témino similar) y a
      contenedores que almacenan <classname>Object</classname>s.
    </para>

    <para>
      Debido a que la librería de clases de Smalltalk tenía mucha más
      experiencia e historia detrás de la que tenía C++, y porque los
      compiladores de C++ originales no tenían librerías de clases
      contenedoras, parecía una buena idea duplicar la librería de
      Smalltalk en C++. Esto se hizo como experimento con una de las
      primeras implementaciónes de C++<footnote> <para>La librería
	  OOPS, por Keith Gorlen, mientras estaba en el NIH.</para>
      </footnote>, y como representaba un significativo ahorro de
      código mucha gente empezo a usarlo. En el proceso de intentar
      usar las clases contenedoras, descubrieron un problema.
    </para>

    <para>
      El problema es que en Smalltalk (y en la mayoría de los
      lenguajes de POO que yo conozco), todas las clases derivan
      automáticamente de la jerarquía única, pero esto no es cierto en
      C++. Se puede tener una magnifica jerarquía basada en objetos
      con sus clases contenedoras, pero entonces se compra un conjunto
      de clases de figuras, o de aviones de otro vendedor que no usa
      esa jerarquía. (Esto se debe a que usar una jerarquía supone
      sobrecarga, rechazada por los programadores de C). ¿Cómo se
      inserta un árbol de clases independientes en nuestra jerarquía?
      El problema se parece a lo siguiente:
    </para>

    <figure>
      <title>Contenedores</title>
      <mediaobject>
	<imageobject role="latex">
	  <imagedata fileref="./images/V1_21.pdf" align="center" format="PDF"/>
	</imageobject>
	<imageobject role="html">
	  <imagedata fileref="./images/V1_21.png" align="center" format="PNG"/>
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      Debido a que C++ suporta múltiples jerarquías independientes, la
      jerarquía basada en objetos de Smalltalk no funciona tan bien.
    </para>

    <para>
      La solución parace obvia. Si se pueden tener múltiples
      jerarquías de herencia, entonces hay que ser capaces de heredar
      de más de una clase: La herencia múltiple resuelve el
      problema. Por lo que se puede hacer lo siguiente (un ejemplo
      similar se dió al final del Capítulo 15).
    </para>

    <figure>
      <title>Herencia múltiple</title>
      <mediaobject>
	<imageobject role="latex">
	  <imagedata fileref="./images/V1_22.pdf" align="center" format="PDF"/>
	</imageobject>
	<imageobject role="html">
	  <imagedata fileref="./images/V1_22.png" align="center" format="PNG"/>
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      Ahora <classname>OShape</classname> tiene las características y
      el comportamiento de <classname>Shape</classname>, pero como
      también está derivado de <classname>Object</classname> puede ser
      insertado en el contenedor. La herencia extra dada a
      <classname>OCircle</classname>, <classname>OSquare</classname>,
      etc. es necesaria para que esas clases puedan hacer upcast hacia
      <classname>OShape </classname> y puedan mantener el
      comportamiento correcto. Se puede ver como las cosas se están
      volviendo confusas rápidamente.
    </para>

    <para>
      Los vendedores de compiladores inventaron e incluyeron sus
      propias jerarquías y clases contenedoras, muchas de las cuales
      han sido reemplazadas desde entonces por versiones de templates.
      Se puede argumentar que la herencia múltiple es necesaria para
      resolver problemas de programación general, pero como se verá en
      el Volumen 2 de este libro es mejor evitar esta complejidad
      excepto en casos especiales.
    </para>

    <sect2>
      <!-- The template solution -->
      <title>La solución de la plantilla</title>

      <para>
	Aunque una jerarquía basada en objetos con herencia múltiple
	es conceptualmente correcta, se vuelve difícil de usar. En su
	libro<footnote> <para><emphasis>The C++ Programming
	      Language</emphasis> by Bjarne Stroustrup (1ª edición,
	    Addison-Wesley, 1986)</para> </footnote>, Stroustrup demostró
	lo que el consideraba una alternativa preferible a la
	jerarquía basada en objetos.  Clases contenedoras que fueran
	creadas como grandes macros del preprocesador con argumentos
	que pudieran ser sustituidos con el tipo deseado. Cuando se
	quiera crear un contenedor que maneje un tipo en concreto, se
	hacen un par de llamadas a macros.
      </para>

      <para>
	Desafortunadamente, esta aproximación era confusa para toda la
	literatura existente de Smalltalk y para la experiencia de
	programación, y era un poco inmanejable.  Básicamente, nadie
	la entendía.
      </para>

      <para>
	Mientras tanto, Stroustrup y el equipo de C++ de los
	Laboratorios Bell habían modificado su aproximación de las
	macros, simplificándola y moviéndola del dominio del
	preprocesador al compilador. Este nuevo dispositivo de
	sustitución de código se conoce como <kw>template</kw>
	<footnote>
	  <para>
	    La inspiración de los templates parece venir de los
	    <kw>generics</kw> de ADA</para>
	</footnote>
	(plantilla), y representa un modo completamente diferente de
	reutilizar el código. En vez de reutilizar código objeto, como
	en la herencia y en la composición, un template reutiliza
	<emphasis>código fuente</emphasis>. El contenedor no maneja una
	clase base genérica llamada <classname>Object</classname>, si no
	que gestiona un parámetro no especificado. Cuando se usa un
	template, el parámetro es sustituido <emphasis>por el
	compilador</emphasis>, parecido a la antigua aproximación de las
	macros, pero más claro y fácil de usar.
      </para>

      <para>
	Ahora, en vez de preocuparse por la herencia o la composición
	cuando se quiera usar una clase contenedora, se usa la versión
	en plantilla del contenedor y se crea una versión específica
	para el problema, como lo siguiente:
      </para>

      <figure>
	<title>Contenedor de objetos <classname>Figura</classname></title>
	<mediaobject>
	  <imageobject role="latex">
	    <imagedata fileref="./images/V1_23.pdf" align="center" format="PDF"/>
	  </imageobject>
	  <imageobject role="html">
	    <imagedata fileref="./images/V1_23.png" align="center" format="PNG"/>
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	El compilador hace el trabajo por nosotros, y se obtiene el
	contenedor necesario para hacer el trabajo, en vez de una
	jerarquía de herencia inmanejable. En C++, el template
	implementa el concepto de <emphasis>tipo
	  parametrizado</emphasis>. Otro beneficio de la aproximación de
	las plantillas es que el programador novato que no tenga
	familiaridad o esté incómodo con la herencia puede usar las
	clases contenedoras de manera adecuada (como se ha estado
	haciendo a lo largo del libro con el
	<classname>vector</classname>).

      </para>

    </sect2>
  </sect1>


  <sect1>
    <title>Sintaxis del Template</title>

    <para>
      La palabra reservada <kw>template</kw>
      le dice al compilador que la definición de clases que sigue
      manipulará uno o más tipos no especificados. En el momento en
      que el código de la clase actual es generado, los tipos deben
      ser especificados para que el compilador pueda sustituirlos.
    </para>

    <para>
      Para demostrar la sintaxis, aquí está un pequeño ejemplo que
      produce un array con límites comprobados:
    </para>



//: V1C16:Array.cpp



    <para>
      Se puede ver que parece una clase normal excepto por la línea.
    </para>

<programlisting>
    template&lt;class T&gt;
</programlisting>

    <para>
      que indica que <parameter>T</parameter> es un parámetro de
      sustitución, y que representa un nombre de un tipo. Además, se
      puede ver que <parameter>T</parameter> es usado en todas las
      partes de la clase donde normalmente se vería al tipo específico
      que el contenedor gestiona.
    </para>

    <para>
      En <classname>Array</classname> los elementos son insertados y
      extraidos con la misma función: el operador sobrecargado
      <oper>operator[]</oper>. Devuelve una
      referencia, por lo que puede ser usado en ambos lados del signo
      igual (es decir, tanto como <oper>lvalue</oper> como
      <literal>rvalue</literal>). Hay que hacer notar que si el índice
      se sale de los límites se usa la función <function>require()
      </function> para mostrar un mensaje. Como <oper>operator[] </oper> es <kw>inline</kw>, se puede usar esta aproximación
      para garantizar que no se producen violaciones del límite del
      array para entonces eliminar el <function>require()</function>.
    </para>

    <para>
      En el <function>main()</function>, se puede ver lo fácil que es
      crear <classname>Array</classname>s que manejen distintos tipos de
      objetos. Cuando se dice:
    </para>

<programlisting>
    Array&lt;int&gt; ia;
    Array&lt;float&gt; fa;
</programlisting>

    <para>
      el compilador expande dos veces la plantilla del
      <classname>Array </classname> (que se conoce como <kw>instantiation </kw> o crear una instancia),
      para crear dos nuevas <emphasis>clases generadas</emphasis>, las
      cuales pueden ser interpretadas como <classname>Array_int
      </classname> y <classname>Array_float</classname>. Diferentes
      compiladores pueden crear los nombres de diferentes
      maneras. Estas clases son idénticas a las que hubieran producido
      de estar hechas a mano, excepto que el compilador las crea por
      nosotros cuando se definen los objetos <varname>ia </varname> y
      <varname>fa</varname>. También hay que notar que las
      definiciones de clases duplicadas son eludidas por el
      compilador.
    </para>


    <sect2>
      <title>Definiciones de función no inline</title>

      <para>
	Por supuesto, hay veces en las que se querrá tener definición
	de funciones no inline. En ese caso, el compilador necesita
	ver la declaración del <kw>template</kw> antes que
	la definición de la función miembro.  Aquí está el ejemplo
	anterior, modificado para mostrar la definición del miembro no
	inline.
      </para>



//: V1C16:Array2.cpp



      <para>
	Cualquier referencia al nombre de una plantilla de clase debe
	estar acompañado por la lista de argumentos del template, como
	en
	<code>Array&lt;T&gt;operator[]</code>. Se
	puede imaginar que internamente, el nombre de la clase se
	rellena con los argumentos de la lista de argumentos de la
	plantilla para producir un nombre identificador único de la
	clase for cada instanciación de la plantilla.
      </para>

      <sect3>
	<title>Archivos cabecera</title>

	<para>
	  Incluso si se crean definiciones de funciones no inline,
	  normalmente se querrá poner todas las declaraciones y
	  definiciones de un template en un archivo cabecera. Esto
	  parece violar la regla usual de los archivos cabecera de
	  <quote>No poner nada que asigne almacenamiento</quote>, (lo
	  cual previene múltiples errores de definición en tiempo de
	  enlace), pero las definiciones de plantillas son
	  especial. Algo precedido por
	  <code>template&lt;...&gt; </code>
	  significa que el compilador no asignará almacenamiento en
	  ese momento, sino que se esperará hasta que se lo indiquen
	  (en la instanciación de una plantilla), y que en algún lugar
	  del compilador y del enlazador hay un mecanismo para
	  eliminar las múltiples definiciones de una plantilla
	  idéntica.  Por lo tanto casi siempre se pondrá toda la
	  declaración y definición de la plantilla en el archivo
	  cabecera por facilidad de uso.
	</para>

	<para>
	  Hay veces en las que puede ser necesario poner las
	  definiciones de la plantilla en un archivo <filename
	    role="extension">cpp </filename> separado para satisfacer
	  necesidades especiales (por ejemplo, forzar las
	  instanciaciones de las plantillas para que se encuentren en
	  un único archivo <filename role="extension">dll </filename>
	  de Windows). La mayoría de los compiladores tienen algún
	  mecanismo para permitir esto; hay que investigar la
	  documentación del compilador concreto para usarlo.
	</para>

	<para>
	  Algunas personas sienten que poner el código fuente de la
	  implementación en un archivo cabecera hace posible que se
	  pueda robar y modificar el código si se compra la
	  librería. Esto puede ser una característica, pero
	  probablemente dependa del modo de mirar el problema: ¿Se
	  está comprando un producto o un servicio? Si es un producto,
	  entonces hay que hacer todo lo posible por protegerlo, y
	  probablemente no se quiera dar el código fuente, sino sólo
	  el código compilado. Pero mucha gente ve el software como un
	  servicio, incluso más, como un servicio por suscripción. El
	  cliente quiere nuestra pericia, quieren que se mantenga ese
	  fragmento de código reutilizable para no tenerlo que hacer él -
	  para que se pueda enfocar en hacer su propio trabajo.
	  Personalmente creo que la mayoría de los clientes le
	  tratarán como una fuente de recursos a tener en cuenta y no
	  querrán poner en peligro su relación con usted.  Y para los
	  pocos que quieran robar en vez de comprar o hacer el trabajo
	  original, de todas formas probablemante tampoco se
	  mantendrían con usted.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>IntStack como plantilla</title>

      <para>
	Aquí está el contenedor y el iterador de
	<filename>IntStack.cpp</filename>, implementado como una clase
	contenedora genérica usando plantillas:
      </para>



//: V1C16:StackTemplate.h



      <para>
	Hay que darse cuenta que esta plantilla asume ciertas
	características de los objetos que está manejando. Por
	ejemplo, <classname>StackTemplate </classname> asume que hay
	alguna clase de operación de asignación a <parameter>T
	</parameter> dentro de la función
	<function>push()</function>. Se puede decir que una plantilla
	<quote>implica una interfaz</quote> para los tipos que es
	capaz de manejar.
      </para>

      <para>
	Otra forma de decir esto es que las plantillas proporcionan
	una clase de mecanismo de <emphasis>tipado débil</emphasis> en
	C++, lo cual es típico en un lenguaje fuertemente tipado. En
	vez de insistir en que un objeto sea del mismo tipo para que
	sea aceptable, el tipado débil requiere únicamente que la
	función miembro a la que se quiere llamar esté
	<emphasis>disponible</emphasis> para un objeto en
	particular. Es decir, el código débilmente tipado puede ser
	aplicado a cualquier objeto que acepte esas llamadas a
	funciones miembro, lo que lo hace mucho más flexible<footnote>
	  <para>Todos los métodos en Smalltalk y Python están débilmente
	    tipados, y ese es el motivo por lo que estos lenguajes no
	    necesitan el mecanismo de los templates.  En efecto, se
	    consiguen plantillas sin templates.</para>
	</footnote>.
      </para>

      <para>
	Aquí tenemos el objeto revisado para comprobar la plantilla:
      </para>



//: V1C16:StackTemplateTest.cpp



      <para>
	La única diferencia está en la creación de
	<varname>is</varname>. Dentro de la lista de argumentos del
	template hay que especificar el tipo de objeto que la pila y
	el iterador deberán manejar. Para demostrar la genericidad de
	la plantilla, se crea un <classname>StackTemplate </classname>
	para manejar <type>string</type>. El ejemplo lee las líneas
	del archivo con el código fuente.
      </para>

    </sect2>

    <sect2>
      <title>Constantes en los Templates</title>

      <para>
	Los argumentos de los templates no restrigen su uso a tipos
	class; se pueden también usar tipos empotrados. Los valores de
	estos argumentos se convierten en constantes en tiempo de
	compilación para una instanciación en particular de la
	plantilla. Se pueden usar incluso valores por defecto para
	esos argumentos. El siguiente ejemplo nos permite indicar el
	tamaño de la clase <classname>Array </classname> durante la
	instanciación, pero también proporciona un valor por defecto:
      </para>


//: V1C16:Array3.cpp



      <para>
	Como antes, <classname>Array </classname> es un array de
	objetos que previene de rebasar los límites.  La clase
	<classname>Holder </classname> es muy parecida a
	<classname>Array </classname> excepto que tiene un puntero a
	<classname>Array </classname> en vez de un tener incrustrado
	un objeto del tipo <classname>Array</classname>. Este puntero
	no se inicializa en el constructor; la inicialización es
	retrasada hasta el primer acceso. Esto se conoce como
	<emphasis>inicialización perezosa</emphasis>; se puede usar
	una técnica como esta si se están creando un montón de
	objetos, pero no se está accediendo a todos ellos y se quiere
	ahorrar almacenamiento.
      </para>

      <para>
	Hay que resaltar que nunca se almacena internamente el valor
	de <varname>size</varname> en la clase, pero se usa como si
	fuera un dato interno dentro de las funciones miembro.
      </para>

    </sect2>
  </sect1>
  <sect1>
    <title>Stack y Stash como Plantillas</title>

    <para>
      Los problemas recurrentes de <quote>propiedad</quote> con las
      clases contenedoras <classname>Stack</classname> y
      <classname>Stash </classname> (Pila y Cola respectivamente) que
      han sido usadas varias veces a través del libro, vienen del
      hecho de que estos contenedores no son capaces de saber
      exactamente que tipo manejan. Lo más cerca que han estado es en
      el <quote>contenedor</quote> de objectos <classname>Stack
      </classname> que se vio al final del capítulo 15 en
      <filename>OStackTest.cpp</filename>.
    </para>

    <para>
      Si el programador cliente no elimina explícitamente todos los
      punteros a objeto que están almacenados en el contenedor,
      entonces el contenedor debería ser capaz de eliminar esos
      punteros de manera adecuada. Es decir, el contenedor
      <quote>posee</quote> cualquiera de los objetos que no hayan sido
      eliminados, y es el responsable de limpiarlos. La dificultad
      radica en que el limpiado requiere conocer el tipo del objeto, y
      crear un contenedor genérico <emphasis>no </emphasis> requiere
      conocer el tipo de ese objeto. Con los templates, sin embargo,
      podemos escribir código que no conozcan el tipo de objeto, y
      fácilmente instanciar una nueva versión del contenedor por cada
      tipo que queramos que contenga. La instancia contenedora
      individual <emphasis>conoce </emphasis> el tipo de objetos que
      maneja y puede por tanto llamar al destructor correcto
      (asumiendo que se haya proporcionado un destructor virtual).
    </para>

    <para>
      Para la pila es bastante sencillo debido a todas las funciones
      miembro pueden ser introducidas en línea:
    </para>


//: V1C16:TStack.h



    <para>
      Si se compara esto al ejemplo de <filename>OStack.h </filename> al
      final del capítulo 15, se verá que <classname>Stack </classname> es
      virtualmente idéntica, excepto que <classname>Object </classname> ha
      sido reemplazado con <parameter>T</parameter>. El programa de prueba
      también es casi idéntico, excepto por la necesidad de múltiple
      herencia de <type>string </type> y <classname>Object
      </classname> (incluso por la necesidad de <classname>Object
      </classname> en sí mismo) que ha sido eliminada. Ahora no tenemos
      una clase <classname>MyString </classname> para anunciar su
      destrucción por lo que añadimos una pequeña clase nueva para
      mostrar como la clase contenedora <classname>Stack </classname>
      limpia sus objetos:
    </para>


//: V1C16:TStackTest.cpp



    <para>
      El destructor de <classname>X </classname> es virtual, no porque se
      sea necesario aquí, sino porque <varname>xx</varname> podría
      ser usado más tarde para manejar objetos derivados de
      <classname>X</classname>.
    </para>

    <para>
      Note lo fácil que es crear diferentes clases de
      <classname>Stack</classname>s para <type>string</type> y para
      <classname>X</classname>. Debido a la plantilla, se consigue lo
      mejor de los dos mundos: la facilidad de uso de la
      <classname>Stack </classname> junto con un limpiado correcto.
    </para>

    <sect2>
      <title>Cola de punteros mediante plantillas</title>

      <para>
	Reorganizar el código de <classname>PStash </classname> en un
	template no es tan simple porque hay un número de funciones
	miembro que no deben estar en línea. Sin embargo, como buena
	plantilla aquellas definiciones de función deben permanecer en
	el archivo cabecera (el compilador y el enlazador se
	preocuparán por los problemas de múltiples definiciones). El
	código parece bastante similar al <classname>PStash
	</classname> ordinario excepto que el tamaño del incremento
	(usado por <function>inflate()</function>) ha sido puesto en
	el template como un parámetro no de clase con un valor por
	defecto, para que el tamaño de incremento pueda ser modificado
	en el momento de la instanciación (esto significa que el
	tamaño es fijo aunque se podría argumentar que el tamaño de
	incremento debería ser cambiable a lo largo de la vida del
	objeto):
      </para>


//: V1C16:TPStash.h



      <para>
	El tamaño del incremento por defecto es muy pequeño para
	garantizar que se produzca la llamada a
	<function>inflate()</function>. Esto nos asegura que funcione
	correctamente.
      </para>

      <para>
	Para comprobar el control de propiedad de <classname>PStack
	</classname> en template, la siguiente clase muestra informes
	de creación y destrucción de elementos, y también garantiza
	que todos los objetos que hayan sido creados sean destruidos.
	<classname>AutoCounter </classname> permitirá crear objetos en
	la pila sólo a los objetos de su tipo:
      </para>



//: V1C16:AutoCounter.h



      <para>
	La clase <classname>AutoCounter </classname> hace dos
	cosas. Primero, numera cada instancia de <classname>AutoCounter
	</classname> de forma secuencial: el valor de este número se
	guarda en <varname>id</varname>, y el número se genera usando
	el dato miembro <varname>count </varname> que es
	<kw>static</kw>.
      </para>

      <para>
	Segundo, y más complejo, una instancia estática (llamada
	<varname>verifier</varname>) de la clase
	<classname>CleanupCheck </classname> se mantiene al tanto de
	todos los objetos <classname>AutoCounter </classname> que son
	creados y destruidos, y nos informa si no se han limpiado
	todos (por ejemplo si existe un agujero en memoria). Este
	comportamiento se completa con el uso de la clase
	<classname>set</classname> de la Librería Estándar de C++, lo
	cual es un magnífico ejemplo de cómo las plantillas bien
	diseñadas nos pueden hacer la vida más fácil (se podrá
	aprender más de los contenedores en el Volumen 2 de este
	libro).
      </para>

      <para>
	La clase <classname>set </classname> está instanciada para el tipo
	que maneja; aquí hay una instancia que maneja punteros a
	<classname>AutoCounter</classname>. Un <classname>set </classname>
	permite que se inserte sólo una instancia de cada objeto; en
	<function>add() </function> se puede ver que esto sucede con la
	función <function>set::insert()</function>.  <function>insert()
	</function> nos informa con su valor de retorno si se está
	intentando añadir algo que ya se había incluido; sin embargo,
	desde el momento en que las direcciones a objetos se inserten
	podemos confiar en C++ para que garantice que todos los
	objetos tengan direcciones únicas.
      </para>

      <para>
	En <function>remove()</function>, se usa <function>set::erase()
	</function> para eliminar un puntero a <classname>AutoCounter
	</classname> del <classname>set</classname>. El valor de retorno
	indica cuantas instancias del elemento se han eliminado; en
	nuestro caso el valor puede ser únicamente uno o cero. Si el
	valor es cero, sin embargo, significa que el objeto ya había
	sido borrado del conjunto y que se está intentando borrar por
	segunda vez, lo cual es un error de programación que debe ser
	mostrado mediante <function>require()</function>.
      </para>

      <para>
	El destructor de <classname>CleanupCheck </classname> hace una
	comprobación final asegurándose de que el tamaño del
	<classname>set </classname> es cero - Lo que significa que todos
	los objetos han sido eliminados de manera adecuada. Si no es
	cero, se tiene un agujero de memoria, lo cual se muestra
	mediante el <function>require()</function>.
      </para>

      <para>
	El constructor y el destructor de <classname>AutoCounter
	</classname> se registra y desregistra con el objeto
	<varname>verifier</varname>. Hay que resaltar que el
	constructor, el constructor de copia, y el operador de
	asignación son <kw>private</kw>, por
	lo que la única forma de crear un objeto es con la función
	miembro <function>static create() </function> - esto es un
	ejemplo sencillo de una <literal>factory</literal>, y
	garantiza que todos los objetos sean creados en el montón
	(heap), por lo que <varname>verifier</varname> no se verá
	confundido con sobreasignaciones y construcciones de copia.
      </para>

      <para>
	Como todas las funciones miembro han sido definidas inline, la
	única razón para el archivo de implementación es que contenga
	las definiciones de los datos miembro:
      </para>



//: V1C16:AutoCounter.cpp



      <para>
	Con el <classname>AutoCounter </classname> en la mano, podemos
	comprobar las facilidades que proporciona el
	<classname>PStash</classname>. El siguiente ejemplo no sólo
	muestra que el destructor de <classname>PStash </classname> limpia
	todos los objetos que posee, sino que también muestra como la
	clase <classname>AutoCounter </classname> detecta a los objetos
	que no se han limpiado.
      </para>


//: V1C16:TPStashTest.cpp


      <para>
	Cuando se eliminan los elementos <classname>AutoCounter
	</classname> 5 y 6 de la <classname>PStash</classname>, se
	vuelve responsabilidad del que los llama, pero como el cliente
	nunca los borra se podrín producir agujeros de memoria, que
	serín detectados por <classname>AutoCounter </classname> en
	tiempo de ejecución.
      </para>

      <para>
	Cuando se ejecuta el programa, se verá que el mensaje de error
	no es tan específico como podría ser. Si se usa el esquema
	presentado en <classname>AutoCounter </classname> para
	descubrir agujeros de memoria en nuestro sistema,
	probablemente se quiera imprimir información más detallada
	sobre los objetos que no se hayan limpiado. El Volumen 2 de
	este libro muestra algunas formas más sofisticadas de hacer
	esto.
      </para>


    </sect2>
  </sect1>


  <sect1>
    <title>Activando y desactivando la propiedad</title>

    <para>
      Volvamos al problema del propietario. Los contenedores que
      manejan objetos por valor normalmente no se preocupan por la
      propiedad porque claramente poseen los objetos que
      contienen. Pero si el contenedor gestiona punteros (lo cual es
      común en C++, especialmente con el polimorfismo), entonces es
      bastante probable que esos punteros sean usados en algún otro
      lado del programa, y no necesariamente se quiere borrar el
      objeto porque los otros punteros del programa estarán
      referenciando a un objeto destruido. Para prevenir que esto
      ocurra, hay que considerar al propietario cuando se está
      diseñando y usando un contenedor.
    </para>

    <para>
      Muchos programas son más simples que este, y no se encuentran
      con el problema de la propiedad: Un contenedor que maneja
      punteros a objetos y que son usados sólo por ese contenedor. En
      este caso el propietario es evidente: El contenedor posee sus
      objetos.
    </para>

    <para>
      La mejor aproximación para gestionar quién es el propietario es
      dar al programador cliente una elección. Esto se puede realizar
      con un argumento en el constructor que por defecto defina al
      propietario (el caso más sencillo). Además habrá que poner las
      funciones <quote>get</quote> y <quote>set</quote> para poder ver
      y modificar al propietario del contenedor. Si el contenedor
      tiene funciones para eliminar un objeto, el estado de propiedad
      normalmente afecta a la función de eliminación, por lo que se
      deberían encontrar opciones para controlar la destrucción en la
      función de eliminación. Es concebible que se añadan datos
      propietarios por cada elemento que contenga el contenedor, por
      lo que cada posición debería saber cuando es necesario ser
      destruido; esto es una variante del conteo de referencias,
      excepto en que es el contenedor y no el objeto el que conoce el
      número de referencias a un objeto.
    </para>



//: V1C16:OwnerStack.h



    <para>
      El comportamiento por defecto del contenedor consiste en
      destruir sus objetos pero se puede cambiar o modificando el
      argumento del constructor o usando las funciones miembro de
      <function>owns()</function>.
    </para>

    <para>
      Como con la mayoría de las plantillas que se verán, la
      implementación entera se encuentra en el archivo de
      cabecera. Aquí tenemos un pequeño test que muestra las
      capacidades de la propiedad:
    </para>




//: V1C16:OwnerStackTest.cpp



    <para>
      El objeto <varname>ac2 </varname> no posee los objetos que
      pusimos en él, sin embargo <varname>ac </varname> es un
      contenedor <quote>maestro</quote> que tiene la responsabilidad
      de ser el propietario de los objetos. Si en algún momento de la
      vida de un contenedor se quiere cambiar el que un contenedor
      posea a sus objetos, se puede hacer usando
      <function>owns()</function>.
    </para>

    <para>
      También sería posible cambiar la granularidad de la propiedad
      para que estuviera en la base, es decir, objeto por
      objeto. Esto, sin embargo, probablemente haría a la solución del
      problema del propietario más complejo que el propio problema.
    </para>


  </sect1>
  <sect1>
    <title>Manejando objetos por valor</title>

    <para>
      Actualmente crear una copia de los objetos dentro de un
      contenedor genérico sería un problema complejo si no se tuvieran
      plantillas. Con los templates las cosas se vuelven relativamente
      sencillas - sólo hay que indicar que se están manejando objetos
      en vez de punteros:
    </para>



//: V1C16:ValueStack.h



    <para>
      El constructor de copia de los objetos contenidos hacen la
      mayoría del trabajo pasando y devolviendo objetos por
      valor. Dentro de <function>push()</function>, el almacenamiento
      del objeto en el array <classname>Stack </classname> viene
      acompañado con <function>T::operator=</function>.  Para
      garantizar que funciona, una clase llamada
      <classname>SelfCounter </classname> mantiene una lista de las
      creaciones y construcciones de copia de los objetos.
    </para>



//: V1C16:SelfCounter.h



//: V1C16:SelfCounter.cpp



//: V1C16:ValueStackTest.cpp


    <para>
      Cuando se crea un contenedor <classname>Stack</classname>, el
      constructor por defecto del objeto a contener es ejecutado por
      cada objeto en el array. Inicialmente se verán 100 objetos
      <classname>SelfCounter </classname> creados sin ningún motivo
      aparente, pero esto es justamente la inicialización del
      array. Esto puede resultar un poco caro, pero no existe ningún
      problema en un diseño simple como este. Incluso en situaciones
      más complejas si se hace a <classname>Stack </classname> más general
      permitiendo que crezca dinámicamente, porque en la
      implementación mostrada anteriormente esto implicaría crear un
      nuevo array más grande, copiando el anterior al nuevo y
      destruyendo el antiguo array (de hecho, así es como lo hace la
      clase <classname>vector </classname> de la Librería Estándar de
      C++).
    </para>
  </sect1>


  <sect1>
    <title>Introducción a los iteradores</title>

    <para>
      Un <literal>iterator </literal> es un objeto que se mueve a
      través de un contenedor de otros objetos y selecciona a uno de
      ellos cada vez, sin porporcionar un acceso directo a la
      implementación del contenedor. Los iteradores proporcionan una
      forma estándar de acceder a los elementos, sin importar si un
      contenedor proporciona alguna marnera de acceder a los elementos
      directamente.  Se verán a los iteradores usados frecuentemente
      en asociación con clases contenedoras, y los iteradores son un
      concepto fundamental en el diseño y el uso de los contenedores
      del Standard C++, los cuales son descritos en el Volumen 2 de
      este libro (que se puede bajar de <ulink
	url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>. Un
      iterador es también un tipo de <emphasis>patrón de
	diseño</emphasis>, lo cual es materia de un capítulo del Volumen
      2.
    </para>

    <para>
      En muchos sentidos, un iterador es un <quote>puntero
	elegante</quote>, y de hecho se verá que los iteradores
      normalmente ocultan la mayoría de las operaciones de los
      punteros. Sin embargo, al contrario que un puntero, el iterador
      es diseñado para ser seguro por lo que es mucho menos probable
      de hacer el equivalente de avanzar atravesando el final de un
      array (o si se hace, se encontrará más fácilmente).
    </para>

    <para>
      Considere el primer ejemplo de este capítulo. Aquí está pero
      añadiendo un iterador sencillo:
    </para>


//: V1C16:IterIntStack.cpp


    <para>
      El <classname>IntStackIter </classname> ha sido creado para
      trabajar solo con un <classname>IntStack</classname>.  Hay que
      resaltar que <classname>IntStackIter </classname> es un <kw>friend
      </kw> de <classname>IntStack</classname>, lo que lo da un acceso a
      todos los elementos privados de <classname>IntStack</classname>.
    </para>

    <para>
      Como un puntero, el trabajo de <classname>IntStackIter
      </classname> consiste en moverse a través de un
      <classname>IntStack </classname> y devolver valores. En este
      sencillo ejemplo, el objeto <classname>IntStackIter </classname>
      se puede mover sólo hacia adelante (usando la forma prefija y
      sufija del <oper>operador++ </oper>). Sin
      embargo, no hay límites de la forma en que se puede definir un
      iterador a parte de las restricciones impuestas por el
      contenedor con el que trabaje. Esto es totalmente aceptable
      (incluido los límites del contenedor que se encuentre por
      debajo) para un iterador que se mueva de cualquier forma por su
      contenedor asociado y para que se puedan modificar los valores
      del contenedor.
    </para>

    <para>
      Es usual el que un iterador sea creado con un constructor que lo
      asocie a un único objeto contenedor, y que ese iterador no pueda
      ser asociado a otro contenedor diferente durante su ciclo de
      vida. (Los iteradores son normalemente pequeños y baratos, por
      lo que se puede crear otro fácilmente).
    </para>

    <para>
      Con el iterador, se puede atravesar los elementos de la pila sin
      sacarlos de ella, como un puntero se mueve a través de los
      elementos del array. Sin embargo, el iterador conoce la
      estructura interna de la pila y como atravesar los elementos,
      dando la sensación de que se está moviendo a través de ellos
      como si fuera <quote>incrementar un puntero</quote>, aunque sea
      más complejo lo que pasa por debajo. Esta es la clave del
      iterador: Abstrae el proceso complicado de moverse de un
      elemento del contenedor al siguiente y lo convierte en algo
      parecido a un puntero.  La meta de cada iterador del programa es
      que tengan la misma interfaz para que cualquier código que use
      un iterador no se preocupe de a qué está apuntando - sólo se
      sabe que todos los iteradores se tratan de la misma manera, por
      lo que no es importante a lo que apunte el iterador.  De esta
      forma se puede escribir código más genérico. Todos los
      contenedores y algoritmos en la Librería Estándar de C++ se
      basan en este principio de los iteradores.
    </para>

    <para>
      Para ayudar a hacer las cosas más genéricas, sería agradable
      decir <quote>todas las clases contenedoras tienen una clase
	asociada llamada <classname>iterator</classname></quote>, pero
      esto causará normalmente problemas de nombres. La solución
      consite en añadir una clase anidada para cada contenedor (en
      este caso, <quote><classname>iterator</classname></quote>
      comienza con una letra minúscula para que esté conforme al
      estilo del C++ estándar).  Aquí está el
      <filename>InterIntStack.cpp </filename> con un
      <classname>iterator </classname> anidado:
    </para>


//: V1C16:NestedIterator.cpp


    <para>
      Cuando se crea una clase <kw>friend </kw> anidada, hay
      que seguir el proceso de primero declarar el nombre de la clase,
      después declararla como <kw>friend</kw>, y después
      definir la clase. De otra forma, se confundirá el compilador.
    </para>

    <para>
      Al iterador se le han dado algunas vueltas de tuerca más. La
      función miembro <function>current()</function> produce el
      elemento que el iterador está seleccionando actualmente en el
      contenedor. Se puede <quote>saltar</quote> hacia adelante un
      número arbitrario de elementos usando el <oper>operator+=</oper>. También, se pueden ver
      otros dos operadores sobrecargados: == y != que compararán un
      iterador con otro. Estos operadores pueden comparar dos
      <classname>IntStack::iterator</classname>, pero su intención
      primordial es comprobar si el iterador está al final de una
      secuencia de la misma manera que lo hacen los iteradores
      <quote>reales</quote> de la Librería Estándar de C++. La idea es
      que dos iteradores definan un rango, incluyendo el primer
      elemento apuntado por el primer iterador pero <emphasis>sin
      </emphasis> incluir el último elemento apuntado por el segundo
      iterador. Por esto, si se quiere mover a través del rango
      definido por los dos iteradores, se dirá algo como lo siguiente:
    </para>


<programlisting>
    while (star != end)
    cout &lt;&lt; start++ &lt;&lt; endl;
</programlisting>

    <para>
      Donde <varname>start </varname> y <varname>end </varname> son
      los dos iteradores en el rango.  Note que el iterador
      <varname>end</varname>, al cual se le suele referir como el
      <literal>end sentinel</literal>, no es desreferenciado y nos
      avisa que estamos al final de la secuencia. Es decir, representa
      el que <quote>otro sobrepasa el final</quote>.
    </para>

    <para>
      La mayoría del tiempo se querrá mover a través de la secuencia
      entera de un contenedor, por lo que el contenedor necesitará
      alguna forma de producir los iteradores indicando el principio y
      el final de la secuencia. Aquí, como en la Standard C++ Library,
      estos iteradores se producen por las funciones miembro del
      contenedor <function>begin() </function> y
      <function>end()</function>. <function>begin() </function> usa el
      primer constructor de <classname>iterator </classname> que por
      defecto apunta al principio del contenedor (esto es el primer
      elemento que se introdujo en la pila). Sin embargo, un segundo
      constructor, usado por <function>end()</function>, es necesario
      para crear el iterador final. Estar <quote>al final</quote>
      significa apuntar a lo más alto de la pila, porque <varname>top
      </varname> siempre indica el siguiente espacio de la pila que
      esté disponible pero sin usar. Este constructor del
      <classname>iterator </classname> toma un segundo argumento del
      tipo <type>bool</type>, lo cual es útil para distinguir los dos
      constructores.
    </para>

    <para>
      De nuevo se usan los números Fibonacci para rellenar la
      <classname>IntStack </classname> en el
      <function>main()</function>, y se usan iteradores para moverse
      completamente a través de la <classname>IntStack </classname>
      así como para moverse en un reducido rango de la secuencia.
    </para>

    <para>
      El siguiente paso, por supuesto, es hacer el código general
      transformándolo en un template del tipo que maneje, para que en
      vez ser forzado a manejar enteros se pueda gestionar cualquier
      tipo:
    </para>


//: V1C16:IterStackTemplate.h


    <para>
      Se puede ver que la transformación de una clase regular en un
      <kw>template </kw> es razonablemente
      transparente. Esta aproximación de primero crear y depurar una
      clase ordinaria, y después transformarla en plantilla, está
      generalmente considerada como más sencilla que crear el template
      desde la nada.
    </para>

    <para>
      Dese cuenta que en vez de sólo decir:
    </para>

<programlisting>
    friend iterator;  // Hacerlo amigo
</programlisting>

    <para>
      Este código tiene:
    </para>

<programlisting>
    friend class iterator;  // Hacerlo amigo
</programlisting>

    <para>
      Esto es importante porque el nombre
      <quote><kw>iterator</kw></quote> ya existe en el ámbito de
      resolución, por culpa de un archivo incluido.
    </para>

    <para>
      En vez de la función miembro <function>current()</function>, el
      <classname>iterator </classname> tiene un <oper>operator* </oper>
      para seleccionar el elemento actual, lo que hace que el
      <classname>iterator </classname> se parezca más a un puntero lo
      cual es una práctica común.
    </para>

    <para>
      Aquí está el ejemplo revisado para comprobar el template.
    </para>


//: V1C16:IterStackTemplateTest.cpp


    <para>
      El primer uso del iterador simplemente lo recorre de principio a
      fin (y muestra que el límite final funciona correctamente). En el
      segundo uso, se puede ver como los iteradores permite fácilmente
      especificar un rango de elementos (los contenedores y los
      iteradores del Standard C++ Library usan este concepto de rangos
      casi en cualquier parte). El sobrecargado <oper>operator+= </oper>
      mueve los iteradores <varname>start </varname> y <varname>end
      </varname> a posiciones que están en el medio del rango de
      elementos de <varname>is</varname>, y estos elementos son
      imprimidos. Hay que resaltar, como se ve en la salida, que el
      elemento final no está incluido en el rango, o sea que una vez
      llegado al elemento final (end sentinel) se sabe que se ha pasado
      el final del rango - pero no hay que desreferenciar el elemento
      final o si no se puede acabar desreferenciando un puntero
      nulo. (Yo he puesto un guardian en el
      <classname>StackTemplate::iterator</classname>, pero en la
      Librería Estándar de C++ los contenedores y los iteradores no
      tienen ese código - por motivos de eficiencia - por lo que hay que
      prestar atención).
    </para>

    <para>
      Por último para verificar que el <classname>StackTemplate
      </classname> funciona con objetos clase, se instancia uno para
      <type>string</type>s y se rellena con líneas del código fuente,
      las cuales son posteriormente imprimidas en pantalla.
    </para>


    <sect2>
      <title>Stack con iteradores</title>


      <para>
	Podemos repetir el proceso con la clase de tamaño dinámico
	<classname>Stack</classname> que ha sido usada como un ejemplo
	a lo largo de todo el libro. Aquí está la clase
	<classname>Stack </classname> con un iterador anidado en todo
	el medio:
      </para>


//: V1C16:TStack2.h


      <para>
	Hay que hacer notar que la clase ha sido cambiada para
	soportar la posesión, que funciona ahora debido a que la clase
	conoce ahora el tipo exacto (o al menos el tipo base, que
	funciona asumiendo que son usados los destructores
	virtuales). La opción por defecto es que el contenedor
	destruya sus objetos pero nosotros somos responsables de los
	objetos a los que se haga <function>pop()</function>.
      </para>

      <para>
	El iterador es simple, y físicamente muy pequeño - el tamaño
	de un único puntero. Cuando se crea un
	<classname>iterator</classname>, se inicializa a la cabeza de
	la lista enlazada, y sólo puede ser incrementado avanzando a
	través de la lista. Si se quiere empezar desde el principio,
	hay que crear un nuevo iterador, y si se quiere recordar un
	punto de la lista, hay que crear un nuevo iterador a partir
	del iterador existente que está apuntando a ese elemento
	(usando el constructor de copia del iterador).
      </para>

      <para>
	Para llamar a funciones del objeto referenciado por el
	iterador, se puede usar la función
	<function>current()</function>, el <oper>operator*</oper>, o la desreferencia de
	puntero <oper>operator-> </oper> (un
	elemento común en los iteradores).  La última tiene una
	implementación que <emphasis>parece</emphasis> idéntica a
	<function>current() </function> debido a que devuelve un
	puntero al objeto actual, pero es diferente porque el operador
	desreferencia del puntero realiza niveles extra de
	desreferenciación (ver Capítulo 12).
      </para>

      <para>
	La clase <classname>iterator </classname> sigue el formato que
	se vio en el ejemplo anterior.  <classname>class iterator
	</classname> está anidada dentro de la clase contenedora,
	contiene constructores para crear un iterador que apunta a un
	elemento en el contenedor y un iterador <quote>marcador de
	  final</quote>, y la clase contenedora tiene los métodos
	<function>begin() </function> y <function>end() </function>
	para producir estos iteradores. (Cuando aprenda más de la
	Librería Estándar de C++, verá que los nombres
	<classname>iterator</classname>, <function>begin() </function>
	y <function>end()</function> que se usan aquí tienen
	correspondecia en las clases contenedoras. Al final de este
	capítulo, se verá que esto permite manejar estas clases
	contenedoras como si fueran clases de la STL).
      </para>

      <para>
	La implementación completa se encuentra en el archivo
	cabecera, por lo que no existe un archivo <filename>cpp
	</filename> separado. Aquí tenemos un pequeño test que usa el
	iterador.
      </para>


//: V1C16:TStack2Test.cpp


      <para>
	Una pila <classname>Stack </classname> es instanciada para
	gestionar objetos <type>string </type> y se rellena con líneas
	de un fichero. Entonces se crea un iterador y se usa para
	moverse a través de la secuencia. La décima línea es recordada
	mediante un segundo iterador creado con el constructor de
	copia del primero; posteriormente esta línea es imprimida y el
	iterador - crado dinámicamente - es destruido. Aquí la
	creación dinámica de objetos es usada para controlar la vida
	del objeto.
      </para>


    </sect2>
    <sect2>
      <title>PStash con iteradores</title>

      <para>
	Para la mayoría de los contenedores tiene sentido tener un
	iterador. Aquí tenemos un iterador añadido a la clase
	<classname>PStash</classname>:
      </para>


//: V1C16:TPStash2.h


      <para>
	La mayoría de este archivo es un traducción prácticamente
	directa del anterior <classname>PStash </classname> y el iterador
	anidado dentro de un template. Esta vez, sin embargo, el
	operador devuelve referencias al iterador actual, la cual es
	una aproximación más típica y flexible.
      </para>

      <para>
	El destructor llama a <function>delete </function> para todos
	los punteros que contiene, y como el tipo es obtenido de la
	plantilla, se ejecutará la destrucción adecuada.  Hay que
	estar precavido que si el contenedor controla punteros al tipo
	de la clase base, este tipo debe tener un destructor <kw>virtual </kw> para asegurar un limpiado
	adecuado de los objetos derivados que hayan usado un upcast
	cuando se los alojó en el contenedor.
      </para>

      <para>
	El <varname>PStash::iterator</varname> mantiene el modelo de
	engancharse a un único objeto contenedor durante su ciclo de
	vida. Además, el constructor de copia permite crear un nuevo
	iterador que apunte a la misma posición del iterador desde el
	que se le creo, creando de esta manera un marcador dentro del
	contenedor. Las funciones miembro <function>operator+=
	</function> y el <function>operator-=</function> permiten
	mover un iterador un número de posiciones, mientras se
	respeten los límites del contenedor.  Los operadores
	sobrecargados de incremento y decremento mueven el iterador
	una posición.  El <function>operator+</function> produce un
	nuevo iterador que se mueve adelante la cantidad añadida. Como
	en el ejemplo anterior, los operadores de desreferencia de
	punteros son usados para manejar el elemento al que el
	iterador está referenciando, y <function>remove()</function>
	destruye el objeto actual llamando al
	<function>remove()</function> del contenedor.
      </para>

      <para>
	Se usa la misma clase de código de antes para crear el
	marcador final: un segundo constructor, la función miembro del
	contenedor <function>end()</function>, y el
	<function>operator== </function> y <function>operator!=
	</function> para comparaciones.
      </para>

      <para>
	El siguiente ejemplo crea y comprueba dos diferentes clases de
	objetos <classname>Stash</classname>, uno para una nueva clase
	llamada <classname>Int</classname> que anuncia su construcción y
	destrucción y otra que gestiona objetos <type>string
	</type> de la librería Estándar.
      </para>


//: V1C16:TPStash2Test.cpp


      <para>
	Por conveniencia <classname>Int </classname> tiene asociado un
	<varname>ostream operator&lt;&lt;</varname> para
	<classname>Int&amp;</classname> y <classname>Int*</classname>.
      </para>

      <para>
	El primer bloque de código en <function>main()</function> está
	rodeado de llaves para forzar la destrucción de
	<varname>PStash&lt;Int&gt;</varname> que produce un limpiado
	automático por este destructor. Unos cuantos elementos son
	sacados y borrados a mano para mostrar que <classname>PStash
	</classname> limpia el resto.
      </para>

      <para>
	Para ambas instancias de <classname>PStash</classname>, se
	crea un iterador y se usa para moverse a través del
	contenedor. Note la elegancia generada por el uso de estos
	constructores; no hay que preocuparse por los detalles de
	implementación de usar un array. Se le dice al contenedor y al
	iterador <emphasis>qué</emphasis> hacer y no
	<emphasis>cómo</emphasis> hacerlo. Esto produce una solución
	más sencilla de conceptualizar, construir y modificar.
      </para>

    </sect2>
  </sect1>

  <sect1>
    <title>Por qué usar iteradores</title>

    <para>
      Hasta ahora se han visto los mecanismos de los iteradores, pero
      entender el por qué son tan importantes necesita un ejemplo más
      complejo.
    </para>

    <para>
      Es normal ver el polimorfismo, la creación dinámica de objetos,
      y los contenedores en un programa orientado a objetos real. Los
      contendores y la creación dinámica de objetos resuelven el
      problema de no saber cuantos o que tipo de objetos se
      necesitarán. Y si el contenedor está configurado para manejar
      punteros a la clase base, cada vez que se ponga un puntero a una
      clase derivada hay un upcast (con los beneficios que conlleva de
      claridad de código y extensibilidad). Como código del final del
      Volumen 1, este ejemplo reune varios aspectos de todo lo que se
      ha aprendido - si es capaz de seguir este ejemplo, entonces está
      preparado para el Volumen 2.
    </para>

    <para>
      Suponga que esta creando un programa que permite al usuario
      editar y producir diferentes clases de dibujos. Cada dibujo es
      un objeto que contiene una colección de objetos
      <classname>Shape</classname>:
    </para>


//: V1C16:Shape.h


    <para>
      Se usa la estructura clásica de las funciones virtuales en la
      clase base que son sobreescritas en la clase derivada. Hay que
      resaltar que la clase <classname>Shape </classname> incluye un
      destructor virtual, algo que se debería añadir automáticamente a
      cualquier clase con funciones <kw>virtual</kw>es. Si un contenedor maneja
      punteros o referencias a objetos <classname>Shape</classname>,
      entonces cuando los destructores virtuales sean llamados para
      estos objetos todo será correctamente limpiado.
    </para>

    <para>
      Cada tipo diferente de dibujo en el siguiente ejemplo hace uso
      de una plantilla de clase contenedora diferente: el
      <classname>PStash </classname> y el <classname>Stack
      </classname> que han sido definido en este capítulo, y la clase
      <classname>vector </classname> de la Librería Estándar de
      C++. El <quote>uso</quote> de los contenedores es extremadamente
      simple, y en general la herencia no es la mejor aproximación
      (composición puede tener más sentido), pero en este caso la
      herencia es una aproximación más simple.
    </para>


//: V1C16:Drawing.cpp


    <para>
      Los distintos tipos de contenedores manejan punteros a
      <classname>Shape </classname> y punteros a objetos de clases
      derivadas de <classname>Shape</classname>. Sin embargo, debido
      al polimorfismo, cuando se llama a las funcione virtuales ocurre
      el comportamiento adecuado.
    </para>

    <para>
      Note que <varname>sarray</varname>, el array de
      <classname>Shape*</classname>, puede ser recorrido como un
      contenedor.
    </para>


    <sect2>
      <title>Plantillas Función</title>

      <para>
	En <function>drawAll()</function> se ve algo nuevo. En este
	capítulo, únicamente hemos estado usando <emphasis>plantillas
	  de clases</emphasis>, las cuales pueden instanciar nuevas
	clases basadas en uno o más parámetros de tipo. Sin embargo,
	se puede crear <emphasis>plantillas de función</emphasis>, las
	cuales crean nuevas funciones basadas en parámetros de
	tipo. La razón para crear una plantilla de función es la misma
	por la cual se crea una plantilla de clase: intentar crear
	código más genérico, y se hace retrasando la especificación de
	uno o más tipos.  Se quiere decir que estos parámetros de
	tipos soportan ciertas operaciones, no qué tipos exactos son.
      </para>

      <para>
	Se puede pensar sobre la plantilla función <function>drawAll()
	</function> como si fuera un <emphasis>algoritmo </emphasis>
	(y así es como se llaman la mayoría de las plantillas de
	función de la STL). Sólo dice como hacer algo dado unos
	iteradores que describen un rango de elementos, mientras que
	estos iteradores pueden ser desreferenciados, incrementados, y
	comparados. Estos son exactamente la clase de iteradores que
	hemos estado desarrollando en este capítulo, y también - y no
	por casualidad - la clase de iteradores que son producidos por
	los contenedores de la Librería Estándar de C++, evidenciado
	por el uso de <classname>vector</classname> en este ejemplo.
      </para>

      <para>
	Además nos gustaría que <function>drawAll() </function> fuera un
	<emphasis>algoritmo genérico</emphasis>, para que los
	contenedores pudieran ser de cualquier tipo y que no se
	tuviera que escribir una nueva versión del algoritmo para cada
	tipo diferente del contenedor. Aquí es donde las plantillas de
	funciones son esenciales, porque automáticamente generan el
	código específico para cada tipo de contenedor diferente. Pero
	sin la indirección extra proporcionada por los iteradores,
	estas generalizaciones no serían posibles. Este es el motivo
	por el que los iteradores son importantes; nos permiten
	escribir código de propósito general que involucra a
	contenedores sin conocer la estructura subyacente del
	contenedor. (Note que los iteradores de C++ y los algoritmos
	genéricos requieren plantillas de funciones).
      </para>

      <para>
	Se puede ver el alcance de esto en el
	<function>main()</function>, ya que <function>drawAll()
	</function> funciona sin cambiar cada uno de los diferentes
	tipos de contenedores. E incluso más interesante,
	<function>drawAll() </function> también funciona con punteros
	al principio y al final del array
	<varname>sarray</varname>. Esta habilidad para tratar arrays
	como contenedores está integrada en el diseño de la Librería
	Estándar de C++, cuyos algoritmos se parecen mucho a
	<function>drawAll()</function>.
      </para>

      <para>
	Debido a que las plantillas de clases contenedoras están
	raramente sujetas a la herencia y al upcast se ven como clases
	<quote>ordinarias</quote>, casi nunca se verán funciones virtuales en
	clases contenedoras. La reutilización de las clases contenedoras está
	implementado mediante plantillas, no mediante herencia.
      </para>


    </sect2>

  </sect1>



  <sect1>
    <title>Resumen</title>

    <para>
      Las clases contenedoras son una parte esencial de la
      programación orientada a objetos.  Son otro modo de simplificar
      y ocultar los detalles de un programa y de acelerar el proceso
      de desarrollo del programa. Además, proporcionan un gran nivel
      de seguridad y flexibilidad reemplazando los anticuados arrays y
      las relativamente toscas técnicas de estructuras que se pueden
      encontrar en C.
    </para>

    <para>
      Como el programador cliente necesita contenedores, es esencial
      que sean fáciles de usar.  Aquí es donde entran los <kw>template</kw>s. Con las plantillas la
      sintaxis para el reciclaje del código fuente (al contrario del
      reciclaje del código objeto que proporciona la herencia y la
      composición) se vuelve lo suficientemente trivial para el
      usuario novel. De hecho, la reutilización de código con
      plantillas es notablemente más fácil que la herencia y el
      polimorfismo.
    </para>

    <para>
      Aunque se ha aprendido cómo crear contenedores y clases
      iteradoras en este libro, en la práctica es mucho más útil
      aprender los contenedores e iteradores que contiene la Librería
      Estándar de C++, ya que se puede esperar encontrarlas en
      cualquier compilador. Como se verá en el Volumen 2 de este libro
      (que se puede bajar de <ulink
	url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>, los
      contenedores y algoritmos de la STL colmarán virtualmente sus
      necesidades por lo que no tendrá que crear otras nuevas.
    </para>

    <para>
      Las características que implica el diseño con clases
      contenedoras han sido introducidas a lo largo de todo el
      capítulo, pero hay que resaltar que van mucho más allá. Una
      librería de clases contenedoras más complicada debería cubrir
      todo tipo de características adicionales, como la multitarea, la
      persistencia y la recolección de basura.
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>
	<para>
	  Implemente la jerarquía de herencia del diagrama de
	  <classname>OShape </classname> de este capítulo.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique el resultado del Ejercicio 1 del capítulo 15 para
	  usar la <classname>Stack </classname> y el
	  <classname>iterator </classname> en <filename>TStack2.h
	  </filename> en vez de un array de punteros a
	  <classname>Shape</classname>. Añada destructores a la
	  jerarquía de clases para que se pueda ver que los objetos
	  <classname>Shape </classname> han sido destruidos cuando la
	  <classname>Stack </classname> se sale del ámbito.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>TPStash.h </filename> para que el valor
	  de incremento usado por <function>inflate() </function>
	  pueda ser cambiado durante la vida de un objeto contenedor
	  particular.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>TPStash.h </filename> para que el valor de
	  incremento usado por <function>inflate() </function>
	  automáticamente cambie de tamaño para que reduzca el número
	  de veces que debe ser llamado. Por ejemplo, cada vez que se
	  llama podría doblar el valor de incremento para su uso en la
	  siguiente llamada. Demuestre la funcionalidad mostrando cada
	  vez que se llama a <function>inflate()</function>, y escriba
	  código de prueba en <function>main()</function>.
	</para>
      </listitem>

      <listitem>
	<para>
	  Convierta en plantilla la función de <function>fibonacci()
	  </function> con los tipos que puede producir (puede generar
	  <type>long</type>, <type>float</type>, etc.  en vez de sólo
	  <type>int</type>).
	</para>
      </listitem>

      <listitem>
	<para>
	  Usar el <classname>vector </classname> de la STL como
	  implementación subyacente, para crear una platilla
	  <classname>Set </classname> que acepte solo uno de cada tipo
	  de objeto que se aloje en él. Cree un iterador anidado que
	  soporte el concepto de "marcador final" de este
	  capítulo. Escriba código de prueba para el <classname>Set
	  </classname> en el <function>main()</function>, y entonces
	  sustituyalo por la plantilla <classname>set </classname> de
	  la STL para comprobar que el comportamiento es correcto.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>AutoCounter.h </filename> para que pueda
	  ser usado como un objeto miembro dentro de cualquier clase
	  cuya creación y destrucción quiera comprobar. Añada un
	  miembro <type>string </type> para que contenga el
	  nombre de la clase. Compruebe esta herramienta dentro una
	  clase suya.
	</para>
      </listitem>

      <listitem>
	<para>
	  Cree una versión de <filename>OwnerStack.h </filename> que use
	  un <classname>vector </classname> de la Librería Estándar de C++
	  como su implementación subyacente.  Será necesario conocer
	  algunas de las funciones miembro de <classname>vector
	  </classname> para poder hacerlo (sólo hay que mirar en el
	  archivo cabecera &lt;vector&gt;).
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>ValueStack.h </filename> para que pueda
	  expandirse dinámicamente según se introduzcan más objetos y
	  se quede sin espacio. Cambie <filename>ValueStackTest.cpp
	  </filename> para comprobar su nueva funcionalidad.
	</para>
      </listitem>

      <listitem>
	<para>
	  Repita el ejercicio 9 pero use el <classname>vector
	  </classname> de la STL como la implementación interna de
	  <classname>ValueStack</classname>. Note lo sencillo que es.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>ValueStackTest.cpp </filename> para que
	  use un <classname>vector </classname> de la STL en vez de un
	  <classname>Stack </classname> en el
	  <function>main()</function>. Dése cuenta del comportamiento
	  en tiempo de ejecución: ¿Se genera un grupo de objetos por
	  defecto cuando se crea el <classname>vector</classname>?
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>TStack2.h </filename> para que use un
	  <classname>vector </classname> de la STL.  Asegurese de que no
	  cambia la interfaz, para que <filename>TStack2Test.cpp
	  </filename> funcione sin cambiarse.
	</para>
      </listitem>

      <listitem>
	<para>
	  Repita el Ejercicio 12 usando una <classname>stack </classname>
	  de la Librería Estándar de C++ en vez de un
	  <classname>vector</classname>.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>TPStash2.h </filename> para que use un
	  <classname>vector </classname> de la STL como su
	  implementación interna. Asegurese que no cambia la interfaz,
	  por lo que <filename>TPStash2Test.cpp </filename> funciona
	  sin modificarse.
	</para>
      </listitem>

      <listitem>
	<para>
	  En <filename>IterIntStack.cpp</filename>, modifique
	  <classname>IntStackIter </classname> para darle un
	  constructor de <quote>marcador final</quote>, y añada el
	  <oper>operator== </oper> y el <oper>operator!=</oper>. En el
	  <function>main()</function>, use un iterador para moverse a
	  través de los elementos del contenedor hasta que se
	  encuentre el marcador.
	</para>
      </listitem>

      <listitem>
	<para>
	  Use <filename>TStack2.h</filename>,
	  <filename>TPSTash2.h</filename>, y
	  <filename>Shape.h</filename>, instancie los contenedores
	  <classname>PStash </classname> y <classname>Stack
	  </classname> para que contenga
	  <classname>Shape*</classname>, rellene cada uno con punteros
	  a <classname>Shape</classname>, entonces use iteradores para
	  moverse a través de cada contenedor y llame a
	  <function>draw() </function> para cada objeto.
	</para>
      </listitem>

      <listitem>
	<para>
	  Cree una plantilla en la clase <type>Int </type> para
	  que pueda alojar cualquier tipo de objetos (Siéntase libre
	  de cambiar el nombre de la clase a algo más apropiado).
	</para>
      </listitem>

      <listitem>
	<para>
	  Cree una plantilla de la clase <classname>IntArray
	  </classname> en <filename>IostreamOperatorOverloading.cpp
	  </filename> del capítulo 12, introduzca en plantilla ambos
	  tipos de objetos que están contenidos y el tamaño del array
	  interno
	</para>
      </listitem>

      <listitem>
	<para>
	  Convierta <classname>ObjContainer </classname> en
	  <filename>NestedSmartPointer.cpp </filename> del Capítulo 12
	  en una plantilla. Compruebelo con dos clases diferentes.
	</para>
      </listitem>

      <listitem>
	<para>
	  Modifique <filename>C15:OStack.h </filename> y
	  <filename>C15:OStackTest.cpp </filename> consiguiendo que
	  <classname>class Stack </classname> pueda tener múltiple
	  herencia automáticamente de la clase contenida y de
	  <classname>Object</classname>. La <classname>Stack
	  </classname> contenida debe aceptar y producir sólo punteros
	  del tipo contenido.
	</para>
      </listitem>

      <listitem>
	<para>
	  Repita el ejercicio 20 usando <classname>vector </classname>
	  en vez de <classname>Stack</classname>.
	</para>
      </listitem>

      <listitem>
	<para>
	  Herede una clase <classname>StringVector </classname> de
	  <classname>vector&lt;void&gt; </classname> y redefina las
	  funciones miembro <function>push_back() </function> y el
	  <oper>operator[] </oper> para que acepten y produzcan
	  únicamente <type>string* </type> (y realizen el
	  moldeado adecuado). Ahora creee una plantilla que haga
	  automáticamente lo mismo a una clase contenedora para
	  punteros de cualquier tipo. Esta técnica es a menudo usada
	  para reducir el código producido por muchas instanciaciones
	  de templates.
	</para>
      </listitem>

      <listitem>
	<para>
	  En <filename>TPStash2.h</filename>, añada y compruebe un
	  <oper>operator- </oper> para
	  <classname>PStash::iterator</classname>, siguiendo la lógica
	  de <oper>operator+</oper>.
	</para>
      </listitem>

      <listitem>
	<para>
	  En <filename>Drawing.cpp</filename>, añada y compruebe una
	  plantilla de función que llame a funciones miembro
	  <function>erase()</function>.
	</para>
      </listitem>

      <listitem>
	<para>
	  (Avanzado) Modifique la clase <classname>Stack </classname>
	  en <filename>TStack2.h </filename> para permitir una
	  granularidad de la propiedad: Añada una bandera para cada
	  enlace indicando si el enlace posee el objeto al que apunta,
	  y de soporte a esta información la función <function>push()
	  </function> y en el destructor. Añada funciones miembro para
	  leer y cambiar la propiedad de cada enlace.
	</para>
      </listitem>

      <listitem>
	<para>
	  (Avanzado) Modifique <filename>PointerToMemberOperator.cpp
	  </filename> del Capítulo 12 para que la
	  <classname>FunctionObject </classname> y el <oper>operator->* </oper> sean convertidos en
	  plantillas para que funcionen con cualquier tipo de retorno
	  (para <oper>operator->*</oper>, tendrá
	  que usar <emphasis>plantillas miembro </emphasis> descritas
	  en el Volumen 2). Añada soporte y compruebe para cero, uno y
	  dos argumentos en las funciones miembro
	  <classname>Dog</classname>.
	</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>
