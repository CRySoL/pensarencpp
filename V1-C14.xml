<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 22/PSGML
  Traducción original: Cristobal Tello
  Formateado DocBook:  David Villa Alises
  1ª Revisión:
  2ª Revisión:
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C14">

  <!-- Inheritance & Composition -->
  <title>Herencia y Composición</title>

  <!--
  One of the most compelling features about C++ is code reuse. But
  to be revolutionary, you need to be able to do a lot more than copy
  code and change it.
  -->

  <highlights>
    <para>
      Una de las características más importantes acerca de C++ es la
      reutilización de código. Pero para ser revolucionario, necesita
      ser capaz de hacer algo más que copiar código y modificarlo.
    </para>
  </highlights>

  <!--
  That's the C approach, and it hasn't worked very well. As with most
  everything in C++, the solution revolves around the class. You reuse
  code by creating new classes, but instead of creating them from
  scratch, you use existing classes that someone else has built and
  debugged.
  -->

  <para>
    Este es un enfoque de C y no fue demasiado bien. Como en la mayoría
    de los casos en C++, la solución gira alrededor de la clase. Se
    reutiliza código creando nuevas clases, pero en vez de crearlas
    desde la nada, utilizará clases existentes que alguien ha realizado
    y comprobado que funcionan correctamente.
  </para>


  <!--
  The trick is to use the classes without soiling the existing code. In
  this chapter you'll see two ways to accomplish this. The first is
  quite straightforward: You simply create objects of your existing
  class inside the new class. This is called composition because the new
  class is composed of objects of existing classes.
  -->

  <para>
    La clave consiste en utilizar estas clases sin modificarlas. En este
    capítulo, aprenderá los dos modos de hacerlo. El primero es bastante
    directo: simplemente cree objetos de la clase existente dentro de la
    nueva clase. A esto se le llama composición porqué la nueva clase
    esta compuesta por objetos de clases ya existentes.
  </para>


  <!--
  The second approach is subtler. You create a new class as a type of an
  existing class. You literally take the form of the existing class and
  add code to it, without modifying the existing class. This magical act
  is called inheritance, and most of the work is done by the
  compiler. Inheritance is one of the cornerstones of object-oriented
  programming and has additional implications that will be explored in
  Chapter 15.
  -->

  <para>
    La segunda forma es mucho más sutil. Crear la nueva clase como un
    tipo de una clase existente. Literalmente se toma la forma de la
    clase existente y se añade código, pero sin modificar la clase ya
    existente. A este hecho mágico se le llama herencia, y la mayoría
    del trabajo es realizado por el compilador. La herencia es uno de
    los pilares de la programación orientada a objetos y tiene
    extensiones adicionales que serán exploradas en el capítulo 15.
  </para>

  <!--
  It turns out that much of the syntax and behavior are similar for both
  composition and inheritance (which makes sense; they are both ways of
  making new types from existing types). In this chapter, you'll learn
  about these code reuse mechanisms.
  -->

  <para>
    Esto es, resulta que gran parte de la sintaxis y el comportamiento
    son similares tanto en la composición como en la herencia (lo cual
    tiene sentido; ambas son dos formas de crear nuevos tipos utilizando
    tipos ya existentes). En este capítulo, aprenderá acerca de los
    mecanismos para la reutilización de código.
  </para>


  <sect1>
    <!-- Composition syntax -->
    <title>Sintaxis de la composición</title>

    <!--
    Actually, you've been using composition all along to create
    classes. You've just been composing classes primarily with built-in
    types (and sometimes strings). It turns out to be almost as easy to
    use composition with user-defined types.
    -->

    <para>
      Realmente, ha utilizado la composición a lo largo de la creación
      de una clase. Ha estado construyendo clases principalmente con
      tipos predefinidos (y en ocasiones cadenas). Por esto, resulta
      fácil usar la composición con tipos definidos por el usuario.
    </para>


    <!--
    Consider a class that is valuable for some reason:
    -->

    <para>
      Considere la siguiente clase:
    </para>


//: V1C14:Useful.h


    <!--
    The data members are private in this class, so it's completely safe
    to embed an object of type X as a public object in a new class,
    which makes the interface straightforward:
    -->

    <para>
      En esta clase los miembros son privados, y entonces, es
      completamente seguro declarar un objeto del tipo X público en la
      nueva clase, y por ello, permitir una interfaz directa:
    </para>


//: V1C14:Composition.cpp


    <!--
    Accessing the member functions of the embedded object (referred to
    as a subobject) simply requires another member selection.
    -->

    <para>
      Para acceder a las funciones miembro alojadas en el objeto
      (referido como subobjeto) simplemente requiere otra selección del
      miembro.
    </para>

    <!--
    It's more common to make the embedded objects private, so they
    become part of the underlying implementation (which means you can
    change the implementation if you want). The public interface
    functions for your new class then involve the use of the embedded
    object, but they don't necessarily mimic the object's interface:
    -->

    <para>
      Es habitual hacer privado el objeto alojado, y por ello, formar
      parte de la capa de implementación (lo que significa que es
      posible cambiar la implementación si se desea). La interfaz de
      funciones de la nueva clase implica el uso del objeto alojado,
      pero no necesariamente imita a la interfaz del objeto.
    </para>


//: V1C14:Composition2.cpp


    <!--
    Here, the permute() function is carried through to the new class
    interface, but the other member functions of X are used within the
    members of Y.
    -->

    <para>
      Aquí, la función permute() se ha añadido a la interfaz de la
      clase, pero el resto funciones de X son utilizadas dentro de los
      miembros de Y.
    </para>
  </sect1>

  <sect1>
    <!-- Inheritance syntax -->
    <title>Sintaxis de la herencia</title>

    <!--
    The syntax for composition is obvious, but to perform inheritance
    there's a new and different form.
    -->

    <para>
      La sintaxis en la composición es bastante obvia, en cambio en la
      herencia, la sintaxis es nueva y diferente.
    </para>

    <!--
    When you inherit, you are saying, "This new class is like that old
    class.¡É You state this in code by giving the name of the class as
    usual, but before the opening brace of the class body, you put a
    colon and the name of the base class (or base classes, separated by
    commas, for multiple inheritance). When you do this, you
    automatically get all the data members and member functions in the
    base class. Here's an example:
    -->

    <para>
      Cuando hereda, realmente se expresa "Esta nueva clase es como esta
      otra vieja clase". Se comienza el código proporcionando el nombre
      de la clase, como se realiza normalmente, pero antes de abrir la
      llave del cuerpo de la clase, se colocan dos puntos y el nombre de
      la clase base (o de las clases bases, separadas por comas, para
      herencia múltiple). Una vez realizado, automáticamente se
      consiguen todos los miembros y las funciones de la clase
      base. Ejemplo:
    </para>


//: V1C14:Inheritance.cpp


    <!--
    You can see Y being inherited from X, which means that Y will
    contain all the data elements in X and all the member functions in
    X. In fact, Y contains a subobject of X just as if you had created a
    member object of X inside Y instead of inheriting from X. Both
    member objects and base class storage are referred to as subobjects.
    -->

    <para>
      Como se puede observar, Y hereda de X, que significa que Y
      contendrá todos los miembros de X y todas las funciones de X. De
      hecho, Y contiene un subobjeto X como si se hubiese creado un
      objeto X dentro de la clase Y en vez de heredar de X. Tanto los
      miembros objetos y la clase base son conocidos como subobjetos.
    </para>

    <!--
    All the private elements of X are still private in Y; that is, just
    because Y inherits from X doesn't mean Y can break the protection
    mechanism. The private elements of X are still there, they take up
    space - you just can't access them directly.
    -->

    <para>
      Todos los elementos privados de X continúan siendo privados en Y;
      esto es, aunque Y hereda de X no significa que Y pueda romper el
      mecanismo de protección. Los elementos privados de X continúan
      existiendo, ocupando su espacio - sólo que no se puede acceder a
      ellos directamente.
    </para>

    <!--
    In main() you can see that Y's data elements are combined with X'
    s because the sizeof(Y) is twice as big as sizeof(X).
    -->

    <para>
      En main() observamos que los datos de Y están combinados con los
      datos de X porque sizeof(Y) es el doble de grande que el
      sizeof(X).
    </para>

    <!--
    You'll notice that the base class is preceded by public. During
    inheritance, everything defaults to private. If the base class were
    not preceded by public, it would mean that all of the public members
    of the base class would be private in the derived class. This is
    almost never what you want[51]; the desired result is to keep all
    the public members of the base class public in the derived
    class. You do this by using the public keyword during inheritance.
    -->

    <para>
      Observará que la clase base es precedida por public. Durante la
      herencia, por defecto, todo es privado. Si la clase base no
      estuviese precedida por public, significaría que todos los
      miembros públicos de la clase base serían privados en la clase
      derivada. Esto, en la mayoría de ocasiones no es lo deseado [51];
      el resultado que se desea es mantener todos los miembros públicos
      de la clase base en la clase derivada. Para hacer esto, se usa la
      palabra clave public durante la herencia.
    </para>

    <!--
    In change(), the base-class permute() function is called. The
    derived class has direct access to all the public base-class
    functions.
    -->

    <para>
      En change(), se utiliza a la función de la clase base
      permute(). La clase derivada tiene acceso directo a todas las
      funciones públicas de la clase base.
    </para>

    <!--
    The set() function in the derived class redefines the set()
    function in the base class. That is, if you call the functions read(
    ) and permute() for an object of type Y, you'll get the base-class
    versions of those functions (you can see this happen inside main(
    )). But if you call set() for a Y object, you get the redefined
    version. This means that if you don't like the version of a
    function you get during inheritance, you can change what it
    does. (You can also add completely new functions like change().)
    -->

    <para>
      La función set() en la clase derivada redefine la función set()
      de la clase base. Esto es, si llama a las funciones read() y
      permute() de un objeto Y, conseguirá las versiones de la clase
      base (esto es lo que esta ocurriendo dentro de main()). Pero si
      llamamos a set() en un objeto Y, conseguiremos la versión
      redefinida. Esto significa que si no deseamos un comportamiento de
      una función durante la herencia, se puede cambiar. (También se
      pueden añadir funciones completamente nuevas como change().)
    </para>

    <!--
    However, when you're redefining a function, you may still want to
    call the base-class version. If, inside set(), you simply call set(
    ) you'll get the local version of the function - a recursive
    function call. To call the base-class version, you must explicitly
    name the base class using the scope resolution operator.
    -->

    <para>
      Sin embargo, cuando redefinimos una función, puede ser que desee
      llamar a la versión de la clase base. Si, dentro de set(),
      simplemente llama a set(), conseguiremos una versión local de la
      función - una función recursiva. Para llamar a la versión de la
      clase base, se debe explícitamente utilizar el nombre de la clase
      base y el operador de resolución de alcance.
    </para>

  </sect1>

  <sect1>
    <!-- The constructor initializer list -->
    <title>Lista de inicializadores de un constructor</title>

    <!--
    You've seen how important it is in C++ to guarantee proper
    initialization, and it's no different during composition and
    inheritance. When an object is created, the compiler guarantees that
    constructors for all of its subobjects are called. In the examples
    so far, all of the subobjects have default constructors, and that's
    what the compiler automatically calls. But what happens if your
    subobjects don't have default constructors, or if you want to change
    a default argument in a constructor? This is a problem because the
    new class constructor doesn't have permission to access the private
    data elements of the subobject, so it can't initialize them
    directly.
    -->

    <para>
      Hemos visto lo importante que es en C++ garantizar una correcta
      inicialización, y esto no va a cambiar en la composición ni en la
      herencia. Cuando se crea un objeto, el compilador garantiza la
      ejecución todos los constructores para cada uno de los
      subobjetos. Hasta ahora, en los ejemplos, todos los subobjetos
      tienen un constructor por defecto, que es ejecutado por el
      compilador automáticamente. Pero que ocurre si uno de nuestros
      subobjetos no tiene constructores por defecto, o si queremos
      cambiar los parámetros por defecto de un constructor. Esto supone
      un problema, porque el constructor de la nueva clase no tiene
      permiso para acceder a los miembros privados del subobjeto y por
      ello, no puede inicializarlos directamente.
    </para>

    <!--
    The solution is simple: Call the constructor for the subobject. C++
    provides a special syntax for this, the constructor initializer
    list. The form of the constructor initializer list echoes the act of
    inheritance. With inheritance, you put the base classes after a
    colon and before the opening brace of the class body. In the
    constructor initializer list, you put the calls to subobject
    constructors after the constructor argument list and a colon, but
    before the opening brace of the function body. For a class MyType,
    inherited from Bar, this might look like this:
    -->

    <para>
      La solución es simple: ejecutar el constructor del subobjeto. C++
      proporciona una sintaxis especial para ello, la lista de
      inicializadores de un constructor. La forma de la lista de
      inicializadores de un constructor demuestra como actúa como la
      herencia. Con la herencia, las clases bases son colocadas después
      de dos puntos y justo después, puede abrir la llave para empezar
      con el cuerpo de la clase. En la lista de inicializadores de un
      constructor, se coloca las llamadas a los constructores de los
      subobjetos, después los argumentos del constructor y los dos
      puntos, pero todo esto, antes de abrir el brazo del cuerpo de la
      función. En una clase MyType, que hereda de Bar, sería de la
      siguiente manera:
    </para>


<programlisting>
MyType::MyType(int i) : Bar(i) { // ...
</programlisting>


    <!--
    if Bar has a constructor that takes a single int argument.
    -->

    <para>
      si el constructor de Bar tuviera un solo parámetro del tipo <type>int</type>.
    </para>

    <sect2>
      <!-- Member object initialization -->
      <title>Inicialización de objetos miembros</title>

      <!--
      It turns out that you use this very same syntax for member object
      initialization when using composition. For composition, you give
      the names of the objects instead of the class names. If you have
      more than one constructor call in the initializer list, you
      separate the calls with commas:
      -->

      <para>
	La inicialización de objetos miembros de una clase utiliza la
	misma sintaxis cuando se usa la composición. Para la
	composición, se proporcionan los nombres de los objetos en lugar
	de los nombres de las clases. Si se tiene más de una llamada al
	constructor en la lista de inicializadores, las llamadas se
	separan con comas:
      </para>


<programlisting>
MyType2::MyType2(int i) : Bar(i), m(i+1) { // ...
</programlisting>


      <!--
      This is the beginning of a constructor for class MyType2, which is
      inherited from Bar and contains a member object called m. Note
      that while you can see the type of the base class in the
      constructor initializer list, you only see the member object
      identifier.
      -->

      <para>
	Esta sería la forma de un constructor de la clase MyType2, la
	cual hereda de Bar y contiene un miembro objeto llamado
	m. Fíjese que mientras podemos ver el tipo de la clase base en
	la lista de inicializadores del constructor, sólo podemos ver el
	miembro identificador objeto.
      </para>
    </sect2>

    <sect2>
      <!-- Built-in types in the initializer list -->
      <title>Tipos predefinidos en la lista de inicializadores</title>

      <!--
      The constructor initializer list allows you to explicitly call the
      constructors for member objects. In fact, there's no other way to
      call those constructors. The idea is that the constructors are all
      called before you get into the body of the new class's
      constructor. That way, any calls you make to member functions of
      subobjects will always go to initialized objects. There's no way
      to get to the opening brace of the constructor without some
      constructor being called for all the member objects and base-class
      objects, even if the compiler must make a hidden call to a default
      constructor. This is a further enforcement of the C++ guarantee
      that no object (or part of an object) can get out of the starting
      gate without its constructor being called.
      -->

      <para>
	La lista de inicializadores del constructor permite invocar
	explícitamente a los constructores de los objetos miembros. De
	hecho, no existe otra forma de llamar a esos constructores. La
	idea es que los constructores son llamados antes de la ejecución
	del cuerpo del constructor de la nueva clase. De esta forma,
	cualquier llamada que hagamos a las funciones miembros de los
	subobjetos siempre serán objetos inicializados. No existe otra
	manera de acceder al cuerpo del constructor sin que ningún
	constructor llame a todos los miembros objetos y los objetos de
	la clase base, es más, el compilador crea un constructor oculto
	por defecto. Esto es otra característica de C++, que garantiza
	que ningún objeto (o parte de un objeto) puedan estar desde un
	principio sin que su constructor sea llamado.
      </para>

      <!--
      This idea that all of the member objects are initialized by the
      time the opening brace of the constructor is reached is a
      convenient programming aid as well. Once you hit the opening
      brace, you can assume all subobjects are properly initialized and
      focus on specific tasks you want to accomplish in the
      constructor. However, there's a hitch: What about member objects
      of built-in types, which don't have constructors?
    -->

      <para>
	La idea de que todos los objetos miembros estén inicializados al
	inicio del constructor es una buena ayuda para programar. Una
	vez en el inicio del constructor, puede asumir que todos los
	subobjetos están correctamente inicializados y centrarse en las
	tareas que se desean realizar en el constructor. Sin embargo,
	existe un contratiempo: ¿Qué ocurre con los objetos
	predefinidos, aquellos que no tienen constructor?
      </para>

      <!--
      To make the syntax consistent, you are allowed to treat built-in
      types as if they have a single constructor, which takes a single
      argument: a variable of the same type as the variable you're
      initializing. Thus, you can say
    -->

      <para>
	Para hacer una sintaxis sólida, piense en los tipos predefinidos
	como si tuviesen un solo constructor, con un solo parámetro: una
	variable del mismo tipo como el que esta inicializando. Esto es
      </para>


//: V1C14:PseudoConstructor.cpp


      <!--
      The action of these "pseudo-constructor calls¡É is to perform a
      simple assignment. It's a convenient technique and a good coding
      style, so you'll see it used often.
    -->

      <para>
	El propósito de esta "pseudo-llamadas a los constructores" es una simple
	asignación. Es una técnica recomendada y un buen estilo de programación,
	que usted verá usar a menudo.
      </para>


      <!-- It's even possible to use the pseudo-constructor syntax when
      creating a variable of a built-in type outside of a class: -->

      <para>
	ncluso es posible utilizar esta sintaxis cuando se crean
	variables de tipos predefinidos fuera de la clase:
      </para>


<programlisting>
int i(100);
int* ip = new int(47);
</programlisting>


      <!--
      This makes built-in types act a little bit more like
      objects. Remember, though, that these are not real
      constructors. In particular, if you don't explicitly make a
      pseudo-constructor call, no initialization is performed.
      -->

      <para>
	De esta forma, los tipos predefinidos actúan, más o menos, como
	los objetos. Sin embargo, recuerde que no son constructores
	reales. En particular, si usted no realiza una llamada explícita
	al constructor, no se ejecutará ninguna inicialización.
      </para>
    </sect2>

    <sect2>
      <!-- Combining composition & inheritance -->
      <title>Combinación de composición y herencia</title>

      <!--
      Of course, you can use composition & inheritance together. The
      following example shows the creation of a more complex class using
      both of them.
      -->

      <para>
	Por supuesto, usted puede usar la composición y la herencia a la
	vez. El siguiente ejemplo muestra la creación de una clase más
	compleja utilizando composición y herencia.
      </para>


//: V1C14:Combined.cpp


      <!--
      C inherits from B and has a member object ("is composed of¡É) of
      type A. You can see the constructor initializer list contains
      calls to both the base-class constructor and the member-object
      constructor.
      -->

      <para>
	C hereda de B y tiene un objeto miembro ("esta compuesto de")
	del tipo A. Puede comparar que la lista de inicializadores
	contiene las llamadas al constructor de la clase base y las
	constructores de los objetos miembros.
      </para>

      <!--
      The function C::f() redefines B::f(), which it inherits, and
      also calls the base-class version. In addition, it calls a.f(
      ). Notice that the only time you can talk about redefinition of
      functions is during inheritance; with a member object you can only
      manipulate the public interface of the object, not redefine it. In
      addition, calling f() for an object of class C would not call
      a.f() if C::f() had not been defined, whereas it would call
      B::f().
      -->

      <para>
	La función C::f() redefine B::f(), que era heredada, y también
	llama a la versión de la clase base. Además, se llama a
	a.f(). Fíjese que durante todo este tiempo estamos hablando
	acerca de la redefinición de funciones durante la herencia; con
	un objeto miembro que sólo se puede manipular su interfaz
	pública, no redefinirla. Además, al llamar a f() en un objeto de
	la clase C no podrá llamar a a.f() si C::f() no ha sido
	definido, mientras que sería posible llamar a B::f().
      </para>


      <sect3>
	<!-- Automatic destructor calls -->
	<title>Llamadas automáticas al destructor </title>

	<!--
	Although you are often required to make explicit constructor
	calls in the initializer list, you never need to make explicit
	destructor calls because there's only one destructor for any
	class, and it doesn't take any arguments. However, the compiler
	still ensures that all destructors are called, and that means
	all of the destructors in the entire hierarchy, starting with
	the most-derived destructor and working back to the root.
	-->

	<para>
	  Aunque muy a menudo sea necesario realizar llamadas explicitas
	  a los constructores en la inicialización, nunca será necesario
	  realizar una llamada explicita a los destructores porque sólo
	  existe un destructor para cada clase y éste no tiene
	  parámetros. Sin embargo, el compilador asegura que todos los
	  destructores son llamados, esto significa que todos los
	  destructores de la jerarquía, desde el destructor de la clase
	  derivada y retrocediendo hasta la raíz, serán ejecutados.
	</para>


	<!--
	It's worth emphasizing that constructors and destructors are
	quite unusual in that every one in the hierarchy is called,
	whereas with a normal member function only that function is
	called, but not any of the base-class versions. If you also want
	to call the base-class version of a normal member function that
	you're overriding, you must do it explicitly.
	-->

	<para>
	  Es necesario destacar que los constructores y destructores son
	  un poco inusuales en el modo en que llaman a su jerarquía, en
	  una función miembro normal sólo la función en si es llamada,
	  ninguna versión de la clase base. Si usted desea llamar a la
	  versión de la clase base de una función miembro normal, deberá
	  sobrecargarla y deberá llamarla explícitamente.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <!-- Order of constructor & destructor calls -->
      <title>Orden de llamada de constructores y destructores</title>

      <!--
      It's interesting to know the order of constructor and destructor
      calls when an object has many subobjects. The following example
      shows exactly how it works:
      -->

      <para>
	Es importante conocer el orden de las llamadas de los
	constructores y destructores de un objeto con varios
	subobjetos. El siguiente ejemplo muestra cómo funciona:
      </para>


//: V1C14:Order.cpp


      <!--
      First, an ofstream object is created to send all the output to a
      file. Then, to save some typing and demonstrate a macro technique
      that will be replaced by a much improved technique in Chapter 16,
      a macro is created to build some of the classes, which are then
      used in inheritance and composition. Each of the constructors and
      destructors report themselves to the trace file. Note that the
      constructors are not default constructors; they each have an int
      argument. The argument itself has no identifier; its only reason
      for existence is to force you to explicitly call the constructors
      in the initializer list. (Eliminating the identifier prevents
      compiler warning messages.)
      -->

      <para>
	Primero, se crea un objeto ofstream para enviar la salida a un
	archivo. Entonces, para no teclear tanto y demostrar la técnica
	de las macros que será sustituida por otra mucho más mejorada en
	el capítulo 16, se crea una para construir varias clases que
	utilizan herencia y composición. Cada constructor y destructor
	escribe información en el archivo de salida. Fíjense que los
	constructores no son constructores por defecto; cada uno tiene
	un parámetro del tipo int. Y además, el argumento no tiene
	nombre; la única razón de su existencia es forzar la llamada al
	constructor en la lista de inicializadores del
	constructor. (Eliminando el identificador evita que el
	compilador informe con mensajes de advertencia)
      </para>

      <!--
      The output of this program is
      -->

      <para>
	La salida de este programa es
      </para>


<screen>
Base1 constructor
Member1 constructor
Member2 constructor
Derived1 constructor
Member3 constructor
Member4 constructor
Derived2 constructor
Derived2 destructor
Member4 destructor
Member3 destructor
Derived1 destructor
Member2 destructor
Member1 destructor
Base1 destructor
</screen>


      <!--
      You can see that construction starts at the very root of the class
      hierarchy, and that at each level the base class constructor is
      called first, followed by the member object constructors. The
      destructors are called in exactly the reverse order of the
      constructors - this is important because of potential dependencies
      (in the derived-class constructor or destructor, you must be able
      to assume that the base-class subobject is still available for
      use, and has already been constructed - or not destroyed yet).
      -->

      <para>
	omo puede observar, la construcción empieza desde la raíz de la
	jerarquía de clases y en cada nivel, el constructor de la clase
	base se ejecuta primero, seguido por los constructores de los
	objetos miembro. Los destructores son llamados exactamente en el
	orden inverso que los constructores -esto es importante debido a
	los problemas de dependencias (en el constructor de la clase
	derivada o en el destructor, se debe asumir que el subobjeto de
	la clase base esta todavía disponible para su uso, y ha sido
	construido - o no se ha destruido todavía).
      </para>


      <!--
      It's also interesting that the order of constructor calls for member
      objects is completely unaffected by the order of the calls in the
      constructor initializer list. The order is determined by the order
      that the member objects are declared in the class. If you could
      change the order of constructor calls via the constructor
      initializer list, you could have two different call sequences in
      two different constructors, but the poor destructor wouldn't know
      how to properly reverse the order of the calls for destruction,
      and you could end up with a dependency problem.
    -->

      <para>
	También es interesante que el orden de las llamadas al
	constructor para los objetos miembro no afecten para nada el
	orden de las llamadas en la lista de inicializadores de un
	constructor. El orden es determinado por el orden en que los
	objetos miembros son declarados en la clase. Si usted pudiera
	cambiar el orden del constructor en la lista de inicializadores
	de un constructor, usted podría tener dos secuencias diferentes
	de llamada en dos constructores diferentes, pero el destructor
	no sabría como invertir el orden para llamarse correctamente y
	nos encontraríamos con problemas de dependencias.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <!-- Name hiding -->
    <title>Ocultación de nombres</title>

    <!--
    If you inherit a class and provide a new definition for one of
    its member functions, there are two possibilities. The first is that
    you provide the exact signature and return type in the derived class
    definition as in the base class definition. This is called
    redefining for ordinary member functions and overriding when the
    base class member function is a virtual function (virtual functions
    are the normal case, and will be covered in detail in Chapter
    15). But what happens if you change the member function argument
    list or return type in the derived class? Here's an example: -->

    <para>
      Si se ha heredado de una clase y se proporciona una nueva
      definición para alguna de sus funciones miembros, existen dos
      posibilidades. La primera es proporcionar los mismos argumentos y
      el mismo tipo de retorno en la definición de la clase derivada
      como la clase base. Esto es conocido como redefinición para
      funciones miembro ordinarias y sobrecarga, cuando la función
      miembro de la clase es una función virtual (las funciones
      virtuales son un caso normal y serán tratadas en detalle en el
      capítulo 15). Pero ¿qué ocurre cuando se modifican los argumentos
      de la función miembro o el tipo de retorno en una clase derivada?
      Aquí esta un ejemplo:
    </para>


//: V1C14:NameHiding.cpp


    <!--
    In Base you see an overloaded function f(), and Derived1
    doesn't make any changes to f() but it does redefine g(). In main(),
    you can see that both overloaded versions of f() are available in
    Derived1. However, Derived2 redefines one overloaded version of f( )
    but not the other, and the result is that the second overloaded form
    is unavailable. In Derived3, changing the return type hides both the
    base class versions, and Derived4 shows that changing the argument
    list also hides both the base class versions. In general, we can say
    that anytime you redefine an overloaded function name from the base
    class, all the other versions are automatically hidden in the new
    class. In Chapter 15, you'll see that the addition of the virtual
    keyword affects function overloading a bit more.
    -->

    <para>
      En Base se observa una función sobrecargada f(), en Derived1 no se
      realiza ningún cambio a f() pero se redefine la función g(). En
      main(), se observa que ambas funciones f() están disponibles en
      Derived1. Sin embargo, Derived2 redefine una versión sobrecargada
      de f() pero no la otra, y el resultado es que la segunda forma de
      sobrecarga no esta disponible. En Derived3, se ha cambiado el tipo
      de retorno y esconde ambas versiones de la clase base, y Derived4
      muestra que al cambiar la lista de argumentos también se esconde
      las versiones de la clase base. En general, usted puede expresar
      cada vez que redefine una función sobrecargada de la clase base,
      que todas las otras versiones son automáticamente escondidas en la
      nueva clase. En el capítulo 15, verá como añadir la palabra
      reservada virtual que afecta un significativamente a la sobrecarga
      de una función.
    </para>


    <!--
    If you change the interface of the base class by modifying the
    signature and/or return type of a member function from the base
    class, then you're using the class in a different way than
    inheritance is normally intended to support. It doesn't necessarily
    mean you're doing it wrong, it's just that the ultimate goal of
    inheritance is to support polymorphism, and if you change the
    function signature or return type then you are actually changing the
    interface of the base class. If this is what you have intended to do
    then you are using inheritance primarily to reuse code, and not to
    maintain the common interface of the base class (which is an
    essential aspect of polymorphism). In general, when you use
    inheritance this way it means you're taking a general-purpose class
    and specializing it for a particular need - which is usually, but
    not always, considered the realm of composition.
    -->

    <para>
      Si cambia la interfaz de la clase base modificando la signatura
      y/o el tipo de retorno de una función miembro desde la clase base,
      entonces esta utilizando la clase de una forma diferente en que la
      herencia esta pensado para realizar normalmente. Esto no quiere
      decir que lo que este haciendo sea incorrecto, esto es que el
      principal objetivo de la herencia es soportar el polimorfismo, y
      si usted cambia la signatura de la función o el tipo de retorno
      entonces realmente esta cambiando la interfaz de la clase base. Si
      esto es lo que esta intentando hacer entonces esta utilizando la
      herencia principalmente para la reutilización de código, no para
      mantener interfaces comunes en la clase base (que es un aspecto
      esencial del poliformismo). En general, cuando usa la herencia de
      esta forma significa que esta en una clase de propósito general y
      la especialización para una necesidad particular - que
      generalmente, pero no siempre, se considera parte de la
      composición.
    </para>


    <!--
    For example, consider the Stack class from Chapter 9. One of the
    problems with that class is that you had to perform a cast every
    time you fetched a pointer from the container. This is not only
    tedious, it's unsafe - you could cast the pointer to anything you
    want.  -->

    <para>
      Por ejemplo, considere la clase Stack del capítulo 9. Uno de los
      problemas con esta clase es que se tenía que realizar que
      convertir cada vez que se conseguía un puntero desde el
      contenedor. Esto no es solo tedioso, también inseguro - se puede
      convertir a cualquier cosa que desee.
    </para>

    <!--
    An approach that seems better at first glance is to specialize
    the general Stack class using inheritance. Here's an example that
    uses the class from Chapter 9: -->

    <para>
      Un procedimiento que a primera vista parece mejor es especializar
      la clase general Stack utilizando la herencia. Aquí esta un
      ejemplo que utiliza la clase del capítulo 9.
    </para>


//: V1C14:InheritStack.cpp


    <!--
    Since all of the member functions in Stack4.h are inlines, nothing
    needs to be linked.
    -->

    <para>
      Como todas las funciones miembros en Stack4.h son inline, no es
      necesario ser enlazadas.
    </para>

    <!--
    StringStack specializes Stack so that push() will accept only
    String pointers. Before, Stack would accept void pointers, so the
    user had no type checking to make sure the proper pointers were
    inserted. In addition, peek() and pop() now return String pointers
    instead of void pointers, so no cast is necessary to use the
    pointer.  -->

    <para>
      StringStack especializa Stack para que push() acepte solo punteros
      a String. Antes, Stack acepta punteros a void, y así el usuario no
      tenía que realizar una comprobación de tipos para asegurarse que
      el punteros fuesen insertados. Además, peek() and pop() ahora
      retornan punteros a String en vez de punteros a void, entonces no
      es necesario realizar la conversión para utilizar el puntero.
    </para>

    <!--
    Amazingly enough, this extra type-checking safety is free in
    push( ), peek(), and pop()! The compiler is being given extra type
    information that it uses at compile-time, but the functions are
    inlined and no extra code is generated.  -->

    <para>
      orprendido ¡este mecanismo de comprobación de tipos seguro es
      gratuito, en push(), peek() y pop! Al compilador se le proporciona
      información extra acerca de los tipos y éste lo utiliza en tiempo
      de compilación, pero las funciones son inline y no es necesario
      ningún código extra.
    </para>

    <!--
    Name hiding comes into play here because, in particular, the
    push( ) function has a different signature: the argument list is
    different. If you had two versions of push() in the same class, that
    would be overloading, but in this case overloading is not what we
    want because that would still allow you to pass any kind of pointer
    into push() as a void*. Fortunately, C++ hides the push(void*)
    version in the base class in favor of the new version that's defined
    in the derived class, and therefore it only allows us to push()
    string pointers onto the StringStack.  -->

    <para>
      La ocultación de nombres entra en acción en la función push() que
      tiene la signatura diferente: la lista de argumentos. Si se
      tuviesen dos versiones de push() en la misma clase, tendrían que
      ser sobrecargadas, pero en este caso la sobrecarga no es lo que
      deseamos porque todavía permitiría pasar cualquier tipo de puntero
      a push como void *. Afortunadamente, C++ esconde la versión push
      (void *) en la clase base en favor de la nueva versión que es
      definida en la clase derivada, de este modo, solo se permite
      utilizar la función push() con punteros a String en StringStack.
    </para>

    <!--
    Because we can now guarantee that we know exactly what kind of
    objects are in the container, the destructor works correctly and the
    ownership problem is solved - or at least, one approach to the
    ownership problem. Here, if you push() a string pointer onto the
    StringStack, then (according to the semantics of the StringStack)
    you're also passing ownership of that pointer to the StringStack. If
    you pop() the pointer, you not only get the pointer, but you also
    get ownership of that pointer. Any pointers that are left on the
    StringStack when its destructor is called are then deleted by that
    destructor. And since these are always string pointers and the
    delete statement is working on string pointers instead of void
    pointers, the proper destruction happens and everything works
    correctly.  -->

    <para>
      Ahora podemos asegurar que se conoce exactamente el tipo de objeto
      que esta en el contenedor, el destructor funcionará correctamente
      y problema esta resuelto - o al menos, un parte del
      procedimiento. Si utiliza push( ) con un puntero a String en
      StringStack, entonces (según el significado de StringStack)
      también se esta pasando el puntero a StringStack. Si utiliza
      pop(), no solo consigue puntero, sino que a la vez el
      propietario. Cualquier puntero que se haya dejado en StringStack
      será borrado cuando el destructor sea invocado. Puesto que siempre
      son punteros a Strings y la declaración delete esta funcionando
      con punteros a String en vez de punteros a void, la destrucción se
      realiza de forma adecuada y todo funciona correctamente.
    </para>

    <!--
    There is a drawback: this class works only for string
    pointers. If you want a Stack that works with some other kind of
    object, you must write a new version of the class so that it works
    only with your new kind of object. This rapidly becomes tedious, and
    is finally solved using templates, as you will see in Chapter 16.
    -->

    <para>
      Esto es una desventaja: esta clase solo funciona con punteros de
      cadenas. Si se desea un Stack que funcione con cualquier variedad
      de objetos, se debe escribir una nueva versión de la clase que
      funcione con ese nuevo tipo de objeto. Esto puede convertirse
      rápidamente en una tarea tediosa, pero finalmente es resulta
      utilizando plantillas como se vera en el capítulo 16.
    </para>


    <!--
    We can make an additional observation about this example: it
    changes the interface of the Stack in the process of inheritance. If
    the interface is different, then a StringStack really isn't a Stack,
    and you will never be able to correctly use a StringStack as a
    Stack. This makes the use of inheritance questionable here; if you'
    re not creating a StringStack that is-a type of Stack, then why are
    you inheriting? A more appropriate version of StringStack will be
    shown later in this chapter.  -->

    <para>
      Existen consideraciones adicionales sobre este ejemplo: el cambio
      de la interfaz en Stack en el proceso de herencia. Si la interfaz
      es diferente, entonces StringStack no es realmente un Stack, y
      nunca será posible usar de forma correcta un StringStack como
      Stack. Esto hace que el uso de la herencia sea cuestionable en
      este punto; si no se esta creando un StringStack del tipo Stack,
      entonces, porque hereda de él. Más adelante, sen este mismo
      capítulo se mostrará una versión más adecuada.
    </para>
  </sect1>

  <sect1>
    <!-- Functions that don't automatically inherit -->
    <title>Funciones que no heredan automáticamente</title>

    <!--
    Not all functions are automatically inherited from the base
    class into the derived class. Constructors and destructors deal with
    the creation and destruction of an object, and they can know what to
    do with the aspects of the object only for their particular class,
    so all the constructors and destructors in the hierarchy below them
    must be called. Thus, constructors and destructors don't inherit and
    must be created specially for each derived class.  -->

    <para>
      No todas las funciones son heredadas automáticamente desde la
      clase base a la clase derivada. Los constructores y destructores
      manejan la creación y la destrucción de un objeto y sólo ellos
      saben que hacer con los aspectos de un objeto en sus clases
      particulares y por ello los constructores y destructores
      inferiores de la jerarquía deben llamarlos. Así, los constructores
      y destructores no se heredan y deben ser creados específicamente
      en cada clase derivada.
    </para>

    <!--
    In addition, the operator= doesn't inherit because it performs
    a constructor-like activity. That is, just because you know how to
    assign all the members of an object on the left-hand side of the =
    from an object on the right-hand side doesn't mean that assignment
    will still have the same meaning after inheritance.  -->

    <para>
      Además, operator= tampoco se hereda porque realiza una acción
      parecida al constructor. Esto es, sólo porque conoce como asignar
      todos los miembros de un objeto, la parte izquierda del = a la
      parte derecha del otro objeto, no significa que la asignación
      tendrá el mismo significado después de la herencia.
    </para>

    <!--
    In lieu of inheritance, these functions are synthesized by the
    compiler if you don't create them yourself. (With constructors, you
    can't create any constructors in order for the compiler to
    synthesize the default constructor and the copy-constructor.) This
    was briefly described in Chapter 6. The synthesized constructors use
    memberwise initialization and the synthesized operator= uses
    memberwise assignment. Here's an example of the functions that are
    synthesized by the compiler: -->

    <para>
      En la herencia, estas funciones son creadas por el compilador si
      no son creadas por usted. (Con constructores, no se pueden crear
      constructores para que el compilador cree el constructor por
      defecto y el constructor copia.) Esto fue brevemente descrito en
      el capítulo 6. Los constructores creados se usan en inicialización
      de sus miembros y la creación del operator= usa la asignación de
      los miembros. A continuación, un ejemplo de las funciones que son
      creadas por el compilador.
    </para>


//: V1C14:SynthesizedFunctions.cpp


    <!--
    The constructors and the operator= for GameBoard and Game
    announce themselves so you can see when they're used by the
    compiler. In addition, the operator Other() performs automatic type
    conversion from a Game object to an object of the nested class
    Other. The class Chess simply inherits from Game and creates no
    functions (to see how the compiler responds). The function f() takes
    an Other object to test the automatic type conversion function.  -->

    <para>
      Los constructores y el operator= de GameBoard y Game se describen
      por si solos y por ello distinguirá cuando son utilizados por el
      compilador. Además, el operador Other() ejecuta una conversión
      automática de tipo desde un objeto Game a un objeto de la clase
      anidada Other. La clase Chess simplemente hereda de Game y no crea
      ninguna función (sólo para ver como responde el compilador) La
      función f() coge un objeto Other para comprobar la conversión
      automática del tipo.
    </para>

    <!--
    In main(), the synthesized default constructor and
    copy-constructor for the derived class Chess are called. The Game
    versions of these constructors are called as part of the
    constructor-call hierarchy. Even though it looks like inheritance,
    new constructors are actually synthesized by the compiler. As you
    might expect, no constructors with arguments are automatically
    created because that's too much for the compiler to intuit.  -->

    <para>
      En main(), el constructor creado por defecto y el constructor
      copia de la clase derivada Chess son ejecutados. Las versiones de
      Game de estos constructores son llamados como parte de la
      jerarquía de llamadas a los constructores. Aun cuando esto es
      parecido a la herencia, los nuevos constructores son realmente
      creados por el compilador. Como es de esperar, ningún constructor
      con argumentos es ejecutado automáticamente porque es demasiado
      trabajo para el compilador y no es capaz de intuirlo.
    </para>

    <!--
    The operator= is also synthesized as a new function in Chess
    using memberwise assignment (thus, the base-class version is called)
    because that function was not explicitly written in the new
    class. And of course the destructor was automatically synthesized by
    the compiler.  -->

    <para>
      El operator= es también es creado como una nueva función en Chess
      usando la asignación (así, la versión de la clase base es
      ejecutada) porque esta función no fue explícitamente escrita en la
      nueva clase. Y, por supuesto el destructor es creado
      automáticamente por el compilador.
    </para>

    <!--
    Because of all these rules about rewriting functions that
    handle object creation, it may seem a little strange at first that
    the automatic type conversion operator is inherited. But it's not
    too unreasonable - if there are enough pieces in Game to make an
    Other object, those pieces are still there in anything derived from
    Game and the type conversion operator is still valid (even though
    you may in fact want to redefine it).  -->

    <para>
      El porqué de todas estas reglas acerca de la reescritura de
      funciones en relación a la creación de un objeto pueden parecer un
      poco extrañas en una primera impresión y como se heredan las
      conversiones automáticas de tipo. Pero todo esto tiene sentido -
      si existen suficiente piezas en Game para realizar un objeto
      Other, aquellas piezas están todavía en cualquier objeto derivado
      de Game y el tipo de conversión es válido (aun cuando puede, si lo
      desea, redefinirlo).
    </para>

    <!--
    operator= is synthesized only for assigning objects of the same
    type. If you want to assign one type to another you must always
    write that operator= yourself.  -->

    <para>
      El operator= es creado automáticamente sólo para asignar objeto
      del mismo tipo. Si desea asignar otro tipo, deberá escribir el
      operator= usted mismo.
    </para>

    <!--
    If you look more closely at Game, you'll see that the
    copy-constructor and assignment operators have explicit calls to the
    member object copy-constructor and assignment operator. You will
    normally want to do this because otherwise, in the case of the
    copy-constructor, the default member object constructor will be used
    instead, and in the case of the assignment operator, no assignment
    at all will be done for the member objects!  -->

    <para>
      Si mira con detenimiento Game, observará que el constructor copia
      y la asignación tienen llamadas explicitas a constructor copia del
      objeto miembro y al operador de asignación. En la mayoría de
      ocasiones, deberá hacer esto porque sino, en vez del constructor
      copia, será llamado el constructor por defecto del objeto miembro,
      y en el caso del operador de asignación, ¡ninguna asignación se
      hará en los objetos miembros!
    </para>

    <!--
    Lastly, look at Checkers, which explicitly writes out the
    default constructor, copy-constructor, and assignment operators. In
    the case of the default constructor, the default base-class
    constructor is automatically called, and that's typically what you
    want. But, and this is an important point, as soon as you decide to
    write your own copy-constructor and assignment operator, the
    compiler assumes that you know what you're doing and does not
    automatically call the base-class versions, as it does in the
    synthesized functions. If you want the base class versions called
    (and you typically do) then you must explicitly call them
    yourself. In the Checkers copy-constructor, this call appears in the
    constructor initializer list: -->

    <para>
      Por último, fíjese en Checkers, dónde explícitamente se escribe un
      constructor por defecto, constructor copia y los operadores de
      asignación. En el caso del constructor por defecto, el constructor
      por defecto de la clase base se llama automáticamente, y esto es
      lo normalmente que se desea hacer. Pero, aquí existe un punto
      importante, tan pronto que se decide escribir nuestro propio
      constructor copia y operador de asignación, el compilador asume
      que usted sabe lo que esta haciendo y no ejecutará automáticamente
      las versiones de la clase base así como las funciones creadas
      automáticamente. Si se quiere ejecutar las versiones de la clase
      base, debe llamarlas explícitamente. En el constructor copia de
      Checkers, esta llamada aparece en la lista de inicialización del
      constructor:
    </para>


<programlisting>
Checkers(const Checkers&amp; c) : Game(c) {
</programlisting>


    <!--
    In the Checkers assignment operator, the base class call is the
    first line in the function body: -->

    <para>
      En el operador de asignación de Checkers, la clase base se llama
      en la primera línea del cuerpo de la función:
    </para>


<programlisting>
Game::operator=(c);
</programlisting>


    <!--
    These calls should be part of the canonical form that you use
    whenever you inherit a class.  -->

    <para>
      Estas llamadas deben seguirse de forma canónica cuando usa
      cualquier clase derivada.
    </para>

    <sect2>
      <!-- Inheritance and static member functions -->
      <title>Herencia y métodos estáticos</title>

      <!--
      static member functions act the same as non-static member
      functions:
      -->

      <para>
	Las funciones miembro estáticas funcionan igual que las
	funciones miembros no estáticas:
      </para>


      <!--
      1. They inherit into the derived class.

      2. If you redefine a static member, all the other overloaded
      functions in the base class are hidden.

      3. If you change the signature of a function in the base class, all
      the base class versions with that function name are hidden (this is
      really a variation of the previous point).
      -->

      <orderedlist>
	<listitem>
	  <para>
	    Son heredadas en la clase derivada.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Si redefine un miembro estático, el resto de funciones
	    sobrecargadas en la clase base son ocultas.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Si cambia la signatura de una función en la clase base,
	    todas las versiones con ese nombre de función en la clase
	    base son ocultadas (esto es realmente una variación del
	    punto anterior).
	  </para>
	</listitem>
      </orderedlist>


      <!--
      However, static member functions cannot be virtual (a topic
      covered thoroughly in Chapter 15).
      -->

      <para>
	Sin embargo, las funciones miembro estáticas no pueden ser
	virtuales (este tema se cubrirá detenidamente en el capítulo
	15).
      </para>
    </sect2>

    <sect2>
      <!-- Choosing composition vs. inheritance -->
      <title>Composición vs. herencia</title>

      <!--
      Both composition and inheritance place subobjects inside your new
      class. Both use the constructor initializer list to construct
      these subobjects. You may now be wondering what the difference is
      between the two, and when to choose one over the other.
      -->

      <para>
	La composición y la herencia colocan subobjetos dentro de la
	clase. Ambos usan la lista de inicialización del constructor
	para construir esos subobjetos. Pero se preguntará cuál es la
	diferencia entre los dos, y cuando escoger una y no la otra.
      </para>

      <!--
      Composition is generally used when you want the features of an
      existing class inside your new class, but not its interface. That
      is, you embed an object to implement features of your new class,
      but the user of your new class sees the interface you've defined
      rather than the interface from the original class. To do this, you
      follow the typical path of embedding private objects of existing
      classes inside your new class.
      -->

      <para>
	La composición generalmente se usa cuando se quieren las
	características de una clase existente dentro se su clase, pero
	no en su interfaz. Esto es, aloja un objeto para implementar
	características en su clase, pero el usuario de su clase ve el
	interfaz que se ha definido, en vez del interfaz de la clase
	original. Para hacer esto, se sigue el típico patrón de alojar
	objetos privados de clases existentes en su nueva clase.
      </para>

      <!--
      Occasionally, however, it makes sense to allow the class user to
      directly access the composition of your new class, that is, to
      make the member objects public. The member objects use access
      control themselves, so this is a safe thing to do and when the
      user knows you're assembling a bunch of parts, it makes the
      interface easier to understand. A Car class is a good example:
      -->

      <para>
	En ocasiones, sin embargo, tiene sentido permitir que el usuario
	de la clase acceda a la composición de su clase, esto es, hacer
	públicos los miembros objeto. Los miembros objeto usan su
	control de accesos, entonces es seguro y cuando el usuario
	conoce que esta formando un conjunto de piezas, hace que la
	interfaz sea más fácil de entender. Un buen ejemplo es la clase
	Car:
      </para>


//: V1C14:Car.cpp


      <!--
      Because the composition of a Car is part of the analysis of the
      problem (and not simply part of the underlying design), making the
      members public assists the client programmer's understanding of
      how to use the class and requires less code complexity for the
      creator of the class.
      -->

      <para>
	Como la composición de Car es parte del análisis del problema (y
	no una simple capa del diseño), hace públicos los miembros y
	ayudan al programador a entender como se utiliza la clase y
	requiere menos complejidad de código para el creador de la
	clase.
      </para>

      <!--
      With a little thought, you'll also see that it would make no sense
      to compose a Car using a "vehicle¡É object - a car doesn't contain
      a vehicle, it is a vehicle. The is-a relationship is expressed
      with inheritance, and the has-a relationship is expressed with
      composition.
      -->

      <para>
	Si piensa un poco, observará que no tiene sentido componer un
	Car usando un objeto "vehículo" - un coche no contiene un
	vehículo, es un vehículo. La relación "es-un" es expresado con
	la herencia y la relación "tiene un" es expresado con la
	composición.
      </para>


      <sect3>
	<!-- Subtyping -->
	<title>Subtipado</title>

	<!--
	Now suppose you want to create a type of ifstream object
	that not only opens a file but also keeps track of the name of
	the file. You can use composition and embed both an ifstream and
	a string into the new class: -->

	<para>
	  Ahora suponga que desea crear un objeto del tipo ifstream que
	  no solo abre un fichero sino que también guarde el nombre del
	  fichero. Puede usar la composición e alojar un objeto ifstream
	  y un string en la nueva clase:
	</para>


//: V1C14:FName1.cpp


	<!--
	There's a problem here, however. An attempt is made to allow the
	use of the FName1 object anywhere an ifstream object is used by
	including an automatic type conversion operator from FName1 to an
	ifstream&. But in main, the line
	-->

	<para>
	  Sin embargo, existe un problema. Se intenta permitir el uso de
	  un objeto FName1 en cualquier lugar dónde se utilice un objeto
	  ifstream, incluyendo una conversión automática del tipo desde
	  FName1 a ifstream&amp;. Pero en main, la línea
	</para>


<programlisting>
file.close();
</programlisting>


	<!--
	will not compile because automatic type conversion happens only in
	function calls, not during member selection. So this approach
	won't work.
	-->

	<para>
	  no compilará porque la conversión automática de tipo sólo
	  ocurre cuando se llama a la función, no durante la selección
	  del miembro. Por ello, esta manera no funcionará.
	</para>

	<!--
	A second approach is to add the definition of close() to FName1:
	-->

	<para>
	  Una segunda manera es añadir la definición Close() a FName1:
	</para>


<programlisting>
void close() { file.close(); }
</programlisting>


	<!--
	This will work if there are only a few functions you want to bring
	through from the ifstream class. In that case you're only using
	part of the class, and composition is appropriate.
	-->

	<para>
	  Esto funcionará si sólo existen unas cuantas funciones a las
	  que se desea hacer funcionar como una clase ifstream. En este
	  caso, solo una parte de la clase y la composición apropiada.
	</para>


	<!--
	But what if you want everything in the class to come
	through? This is called subtyping because you're making a new
	type from an existing type, and you want your new type to have
	exactly the same interface as the existing type (plus any other
	member functions you want to add), so you can use it everywhere
	you'd use the existing type. This is where inheritance is
	essential. You can see that subtyping solves the problem in the
	preceding example perfectly: -->

	<para>
	  Pero ¿qué ocurre si se quiere que todo funcione cómo la clase
	  deseada? A eso se le llama subtipos porque esta creando un
	  nuevo tipo desde uno ya existente y lo que se quiere es que el
	  nuevo tipo tenga la misma interfaz que el tipo existente
	  (además de otras funciones que se deseen añadir) para que se
	  pueda utilizar en cualquier lugar donde se utilizaba el tipo
	  existente. Aquí es dónde la herencia es esencial. Puede ver
	  que el subtipo resuelve perfectamente el problema anterior:
	</para>


//: V1C14:FName2.cpp


	<!--
	Now any member function available for an ifstream object is
	available for an FName2 object. You can also see that non-member
	functions like getline() that expect an ifstream can also work
	with an FName2. That's because an FName2 is a type of ifstream;
	it doesn't simply contain one. This is a very important issue
	that will be explored at the end of this chapter and in the next
	one.  -->

	<para>
	  Ahora cualquier función que este disponible para el objeto
	  sfstream también esta disponible para el objeto
	  FName2. Asimismo se observan funciones no miembro como
	  getline() que esperan un objeto ifstream y que pueden
	  funcionar con un objeto FName2. Esto es porque FName2 es un
	  tipo de ifstream; esto no significa simplemente que lo
	  contiene. Esto es un tema muy importante que será explorado al
	  final de este capitulo y el siguiente.
	</para>
      </sect3>

      <sect3>
	<!-- private inheritance -->
	<title>Herencia privada</title>

	<!--
	You can inherit a base class privately by leaving off the
	public in the base-class list, or by explicitly saying private
	(probably a better policy because it is clear to the user that
	you mean it). When you inherit privately, you're "implementing
	in terms of;¡É that is, you're creating a new class that has all
	of the data and functionality of the base class, but that
	functionality is hidden, so it's only part of the underlying
	implementation. The class user has no access to the underlying
	functionality, and an object cannot be treated as a instance of
	the base class (as it was in FName2.cpp).  -->

	<para>
	  Puede heredar utilizando una clase base de forma privada
	  borrando public en la lista de la clase base o explícitamente
	  utilizando private (definitivamente la mejor política a tomar
	  pues indica al usuario lo que desea hacer). Cuando se hereda
	  de forma privada, esta "implementado en términos de", esto es,
	  se esta creando una nueva clase que tiene todos los datos y
	  funcionalidad de la clase base, pero la funcionalidad esta
	  oculta, solo una parte de capa de implementación. La clase
	  derivada no tiene acceso a la capa de funcionalidad y un
	  objeto no puede ser creado como instancia de la clase base
	  (como ocurrió en FName2.cpp).
	</para>

	<!--
	You may wonder what the purpose of private inheritance is,
	because the alternative of using composition to create a private
	object in the new class seems more appropriate. private
	inheritance is included in the language for completeness, but if
	for no other reason than to reduce confusion, you'll usually
	want to use composition rather than private
	inheritance. However, there may occasionally be situations where
	you want to produce part of the same interface as the base class
	and disallow the treatment of the object as if it were a
	base-class object. private inheritance provides this ability.
	-->

	<para>
	  Se sorprenderá del propósito de la herencia privada, porque la
	  alternativa, usar la composición para crear un objeto privado
	  en la nueva clase parece más apropiada. La herencia privada
	  esta incluida para completar el lenguaje pero para reducir
	  confusión, normalmente se usará la composición en vez de la
	  herencia privada. Sin embargo, existen ocasiones donde se
	  desea el mismo interfaz como la clase base y anular
	  tratamiento del objeto. La herencia privada proporciona esta
	  habilidad.
	</para>


	<sect4>
	  <!-- Publicizing privately inherited members -->
	  <title>Publicar los miembros heredados de forma privada</title>

	  <!--
	  When you inherit privately, all the public members of the
	  base class become private. If you want any of them to be
	  visible, just say their names (no arguments or return values)
	  along with the using keyword in the public section of the
	  derived class: -->

	  <para>
	    Cuando se hereda de forma privada, todos los miembros
	    públicos de la clase base llegan como privados. Si desea que
	    cualquiera de ellos sea visible, solo use sus nombres (sin
	    argumentos o valores de retorno) junto con la palabra clave
	    using en una sección pública de la clase derivada:
	  </para>


//: V1C14:PrivateInheritance.cpp


	  <!--
	  Thus, private inheritance is useful if you want to hide
	  part of the functionality of the base class.  -->

	  <para>
	    Así, la herencia privada es útil si desea esconder parte de
	    la funcionalidad de la clase base.
	  </para>

	  <!--
	  Notice that giving exposing the name of an overloaded
	  function exposes all the versions of the overloaded function
	  in the base class.  -->

	  <para>
	    Fíjese que si expone el nombre de una función sobrecargada,
	    expone todas las versiones sobrecargadas de la función en la
	    clase base.
	  </para>

	  <!--
	  You should think carefully before using private
	  inheritance instead of composition; private inheritance has
	  particular complications when combined with runtime type
	  identification (this is the topic of a chapter in Volume 2 of
	  this book, downloadable from www.BruceEckel.com).  -->

	  <para>
	    Debe pensar detenidamente antes de utilizar la herencia
	    privada en vez de la composición; la herencia privada tiene
	    complicaciones particulares cuando son combinadas con la
	    identificación de tipos en tiempo de ejecución (es un tema
	    de un capítulo en el volumen 2, disponible en
	    www.BruceEckel.com)
	  </para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Protected</title>

    <!--
    Now that you've been introduced to inheritance, the keyword
    protected finally has meaning. In an ideal world, private members
    would always be hard-and-fast private, but in real projects there
    are times when you want to make something hidden from the world at
    large and yet allow access for members of derived classes. The
    protected keyword is a nod to pragmatism; it says, "This is private
    as far as the class user is concerned, but available to anyone who
    inherits from this class.¡É -->

    <para>
      Ahora que ya sabe que es la herencia, la palabra reservada
      protected ya tiene significado. En un mundo ideal, los miembros
      privados siempre serian fijos-y-rápidos, pero en los proyectos
      reales hay ocasiones cuando se desea ocultar algo a todo el mundo
      y todavía permitir accesos a los miembros de la clase derivada. La
      palabra clave protected es un movimiento al pragmatismo: este dice
      "Esto es privado como la clase usuario en cuestión, pero
      disponible para cualquiera que hereda de esta clase.
    </para>

    <!--
    The best approach is to leave the data members private - you
    should always preserve your right to change the underlying
    implementation. You can then allow controlled access to inheritors
    of your class through protected member functions: -->

    <para>
      La mejor manera es dejar los miembros de datos privados - siempre
      debe preservar su derecho de cambiar la capa de
      implementación. Entonces puede permitir acceso controlado a los
      herederos de su clase a través de funciones miembro protegidas:
    </para>


//: V1C14:Protected.cpp


    <!--
    You will find examples of the need for protected in examples
    later in this book, and in Volume 2.  -->

    <para>
      Encontrará ejemplos de la necesidad de uso de protected más
      adelante y en el volumen 2.
    </para>


    <sect2>
      <!--protected inheritance -->
      <title>Herencia protegida</title>

      <!--
      When you're inheriting, the base class defaults to private, which
      means that all of the public member functions are private to the
      user of the new class. Normally, you'll make the inheritance
      public so the interface of the base class is also the interface of
      the derived class. However, you can also use the protected keyword
      during inheritance.
      -->

      <para>
	Cuando se hereda, por defecto la clase base es privada, que
	significa que todos las funciones miembro publicas son privadas
	para el usuario en la nueva clase. Normalmente, heredará
	públicamente para que el interfaz de la clase base sea también
	el interfaz de la clase derivada. Sin embargo, puede usar la
	palabra clave protected durante la herencia.
      </para>

      <!--
      Protected derivation means "implemented-in-terms-of¡É to other
      classes but "is-a¡É for derived classes and friends. It's
      something you don't use very often, but it's in the language for
      completeness.
      -->

      <para>
	Derivar de forma protegida significa "implementado en términos
	de" para otras clases pero "es-una" para las clases derivadas y
	amigas. Es algo que no utilizará muy a menudo, pero esta en el
	lenguaje para completarlo.
      </para>
    </sect2>

  </sect1>

  <sect1>
    <!--Operator overloading & inheritance -->
    <title>Herencia y sobrecarga de operadores</title>

    <!--
    Except for the assignment operator, operators are automatically
    inherited into a derived class. This can be demonstrated by
    inheriting from C12:Byte.h: -->

    <para>
      Excepto el operador de asignación, el resto de operadores son
      heredados automáticamente en la clase derivada. Esto se puede
      demostrar heredando de C12:Byte.h:
    </para>


//: V1C14:OperatorInheritance.cpp


    <!--
    The test code is identical to that in C12:ByteTest.cpp except
    that Byte2 is used instead of Byte. This way all the operators are
    verified to work with Byte2 via inheritance.  -->

    <para>
      El código de prueba anterior es idéntico a C12:ByteTest.cpp
      excepto que Byte2 se usa en vez de Byte. De esta forma todos los
      operadores son verificados para trabajar con Byte2 a través de la
      herencia.
    </para>

    <!--
    When you examine the class Byte2, you'll see that the constructor
    must be explicitly defined, and that only the operator= that assigns a
    Byte2 to a Byte2 is synthesized; any other assignment operators
    that you need you'll have to synthesize on your own.
    -->

    <para>
      Cuando examina la clase Byte2, verá que se ha definido
      explícitamente el constructor y que solo se ha credo el operator=
      que asigna un Byte2 a Byte2; cualquier otro operador de asignación
      tendrá que se realizado por usted.
    </para>
  </sect1>

  <sect1>
    <!-- Multiple inheritance -->
    <title>Herencia múltiple</title>

    <!--
    You can inherit from one class, so it would seem to make sense to
    inherit from more than one class at a time. Indeed you can, but
    whether it makes sense as part of a design is a subject of
    continuing debate. One thing is generally agreed upon: You
    shouldn't try this until you've been programming quite a while and
    understand the language thoroughly. By that time, you'll probably
    realize that no matter how much you think you absolutely must use
    multiple inheritance, you can almost always get away with single
    inheritance.
    -->

    <para>
      Si puede heredar de una clase, tendría sentido heredar de más de
      una clase a la vez. De hecho, puede hacerlo, pero si tiene sentido
      como parte del diseño es un tema que todavía se esta
      debatiendo. Una cosa en que generalmente se esta de acuerdo: debe
      evitar intentarlo hasta que haya programado bastante y comprenda
      el lenguaje en profundidad. Por ahora, probablemente no le importa
      cuando debe absolutamente utilizar la herencia múltiple y siempre
      puede utilizar la herencia simple
    </para>

    <!--
    Initially, multiple inheritance seems simple enough: You add more
    classes in the base-class list during inheritance, separated by
    commas. However, multiple inheritance introduces a number of
    possibilities for ambiguity, which is why a chapter in Volume 2 is
    devoted to the subject.
    -->

    <para>
      Inicialmente, la herencia múltiple parece bastante simple: se
      añade las clases en la lista de clases base durante la herencia
      separadas por comas. Sin embargo, la herencia múltiple introduce
      un número mayor de ambigüedades, y por eso, un capítulo del
      Volumen 2 hablará sobre el tema.
    </para>
  </sect1>

  <sect1>
    <!--Incremental development -->
    <title>Desarrollo incremental</title>

    <!--
    One of the advantages of inheritance and composition is that
    these support incremental development by allowing you to introduce
    new code without causing bugs in existing code. If bugs do appear,
    they are isolated within the new code. By inheriting from (or
    composing with) an existing, functional class and adding data
    members and member functions (and redefining existing member
    functions during inheritance) you leave the existing code - that
    someone else may still be using - untouched and unbugged. If a bug
    happens, you know it's in your new code, which is much shorter and
    easier to read than if you had modified the body of existing code.
    -->

    <para>
      Una de las ventajas de la herencia y la composición es el soporte
      al desarrollo incremental permitiendo introducir nuevo código sin
      causar fallos en el ya existente. Si aparecen fallos, éstos son
      rectificados con nuevo código. Heredando de (o componiendo con)
      clases y funciones existentes y añadiendo miembros de datos y
      funciones miembros (y redefiniendo las funciones existentes
      durante la herencia) puede dejar el código existente - por otro
      que todavía se esta usando - que alguien todavía lo este
      utilizando. Si ocurre algún error, ahora sabe donde esta el nuevo
      código, y entonces podrá leerlo mas rápido y fácilmente que si lo
      hubiera modificado en el cuerpo del código existente.
    </para>


    <!--
    It's rather amazing how cleanly the classes are separated. You
    don't even need the source code for the member functions in order
    to reuse the code, just the header file describing the class and
    the object file or library file with the compiled member
    functions. (This is true for both inheritance and composition.)
    -->

    <para>
      Es sorprendente como las clases son limpiamente separadas. Incluso
      no es necesario añadir el código fuente con funciones miembros
      para reutilizar el código, solamente el fichero de cabecera
      describiendo la clase y el fichero objeto o el fichero de librería
      con las funciones miembros compiladas. (Esto es válido tanto para
      la herencia como para la composición.)
    </para>

    <!--
    It's important to realize that program development is an
    incremental process, just like human learning. You can do as much
    analysis as you want, but you still won't know all the answers
    when you set out on a project. You'll have much more success - and
    more immediate feedback - if you start out to "grow¡É your project
    as an organic, evolutionary creature, rather than constructing it
    all at once like a glass-box skyscraper[52].
    -->

    <para>
      Esto es importante para hacer que el desarrollo sea un proceso
      incremental, como el aprendizaje de una persona. Puede hacer
      tantos análisis como desee pero todavía no sabrá todas las
      respuestas cuando configure un proyecto. Tendrá más éxito y un
      progresión inmediata - si su proyecto empieza a crecer como una
      criatura orgánica, evolutiva, parecerá mas bien que esa
      construyendo algo como un rascacielos de cristal [52]
    </para>

    <!--
    Although inheritance for experimentation is a useful technique,
    at some point after things stabilize you need to take a new look at
    your class hierarchy with an eye to collapsing it into a sensible
    structure[53]. Remember that underneath it all, inheritance is meant
    to express a relationship that says, "This new class is a type of
    that old class.¡É Your program should not be concerned with pushing
    bits around, but instead with creating and manipulating objects of
    various types to express a model in the terms given you from the
    problem space.  -->

    <para>
      Sin embargo la herencia es una técnica útil para la
      experimentación, en algún punto donde las cosas están
      estabilizadas, necesita echar un nuevo vistazo a la jerarquía de
      clases para colapsarla dentro de una estructura sensible
      [53]. Recuerde que, por encima de todo, la herencia significa
      expresar una relación que dice "Esta nueva clase es un tipo de
      esta vieja". Su programa no debe preocuparse de cómo mueve pedazos
      de bits por alrededor, en vez debe crear y manipular objetos de
      varios tipos para expresar un modelo en los términos dados para su
      problema.
    </para>
  </sect1>

  <sect1>
    <!-- Upcasting -->
    <title>Upcasting</title>

    <!--
    Earlier in the chapter, you saw how an object of a class
    derived from ifstream has all the characteristics and behaviors of
    an ifstream object. In FName2.cpp, any ifstream member function
    could be called for an FName2 object.  -->

    <para>
      Anteriormente en este capitulo, observo como un objeto de una
      clase que derivaba de ifstream tenia todas las características y
      conductas de un objeto ifstream. En FName2.cpp, cualquier función
      miembro de ifstream podría ser llamada por cualquier objeto
      FName2.
    </para>

    <!--
    The most important aspect of inheritance is not that it
    provides member functions for the new class, however. It's the
    relationship expressed between the new class and the base
    class. This relationship can be summarized by saying, "The new class
    is a type of the existing class.¡É -->

    <para>
      El aspecto más importante de la herencia no es proporcionar nuevas
      funciones miembro a la nueva clase. Es la relación expresada entre
      la nueva clase y la clase base. Esta relación puede ser resumida
      diciendo "La nueva clase es de un tipo de una clase existente".
    </para>

    <!--
    This description is not just a fanciful way of explaining
    inheritance - it's supported directly by the compiler. As an
    example, consider a base class called Instrument that represents
    musical instruments and a derived class called Wind. Because
    inheritance means that all the functions in the base class are also
    available in the derived class, any message you can send to the base
    class can also be sent to the derived class. So if the Instrument
    class has a play() member function, so will Wind instruments. This
    means we can accurately say that a Wind object is also a type of
    Instrument. The following example shows how the compiler supports
    this notion: -->

    <para>
      Esta no es una descripción fantasiosa de explicar la herencia -
      esta directamente soportada por el compilador. Un ejemplo,
      considere una clase base llamada Instrument que representa
      instrumentos musicales y una clase derivada llamada Wind. Dado que
      la herencia significa que todas las funciones en la clase base
      están también disponibles en la clase derivada, cualquier mensaje
      que envié a la clase base puede ser también enviado desde la
      derivada. Entonces si la clase Instrument tiene una función
      miembro play(), también existirá en los instrumentos de Wind. Esto
      significa precisamente que un objeto Wind es un tipo de
      Instrument. El siguiente ejemplo muestra como el compilador
      soporta esta idea:
    </para>


//: V1C14:Instrument.cpp


    <!--
    What's interesting in this example is the tune() function, which
    accepts an Instrument reference. However, in main() the tune()
    function is called by handing it a reference to a Wind
    object. Given that C++ is very particular about type checking, it
    seems strange that a function that accepts one type will readily
    accept another type, until you realize that a Wind object is also
    an Instrument object, and there's no function that tune() could
    call for an Instrument that isn't also in Wind (this is what
    inheritance guarantees). Inside tune(), the code works for
    Instrument and anything derived from Instrument, and the act of
    converting a Wind reference or pointer into an Instrument
    reference or pointer is called upcasting
    -->

    <para>
      Lo interesante en este ejemplo es la función tune(), que acepta
      una referencia Instrument. Sin embargo, en main() la función
      tune() se llama utilizando una referencia a un objeto Wind. Dado
      que C++ es un muy peculiar sobre la comprobación de tipos, parece
      extraño que una función que acepta solo un tipo pueda aceptar otro
      tipo, al menos que sepa que un objeto Instrument es tambien un
      objeto Instrument.
    </para>


    <sect2>
      <!-- Why "upcasting?"  -->
      <title>¿Por qué <quote>upcasting</quote>?</title>

      <!--
      The reason for the term is historical and is based on the way class
      inheritance diagrams have traditionally been drawn: with the root
      at the top of the page, growing downward. (Of course, you can draw
      your diagrams any way you find helpful.) The inheritance diagram
      for Instrument.cpp is then:
      -->

      <para>
	La razón de este término es histórica y esta basada en la
	manera en que se dibuja la herencia: con la raíz en la parte
	superior de la pagina y hacia abajo (por supuesto que puede
	pintar su diagrama de cualquier modo que le sea útil). El
	diagrama para <filename>Instrument.cpp</filename> es:
      </para>

      <figure>
	<title>Upcasting</title>
      <mediaobject>
	<imageobject role="latex">
	  <imagedata fileref="./images/V1_15.pdf" align="center" format="PDF"/>
	</imageobject>
	<imageobject role="html">
	  <imagedata fileref="./images/V1_15.png" align="center" format="PNG"/>
	</imageobject>
      </mediaobject>
      </figure>

      <!--
      Casting from derived to base moves up on the inheritance diagram, so it'
      s commonly referred to as upcasting. Upcasting is always safe
      because you're going from a more specific type to a more general
      type - the only thing that can occur to the class interface is
      that it can lose member functions, not gain them. This is why the
      compiler allows upcasting without any explicit casts or other
      special notation.
      -->

      <para>
	El hecho de pasar de la clase derivada a la clase base, esto es,
	desplazarse hacia arriba en el diagrama de la herencia, es
	normalmente conocido como upcasting. Upcasting es siempre seguro
	porque se esta desplazando de un tipo desde un tipo mas
	especifico a otro tipo mas general. - únicamente puede ocurrir
	es que la interfaz de la clase pierda algunas funciones miembro,
	pero no ganarlas. Esto es porque el compilador permite el
	upcasting sin ninguna conversión explicita o notación especial.
      </para>
    </sect2>

    <sect2>
      <!-- Upcasting and the copy-constructor -->
      <title>FIXME Upcasting y el constructor de copia</title>

      <!--
      If you allow the compiler to synthesize a copy-constructor for a
      derived class, it will automatically call the base-class
      copy-constructor, and then the copy-constructors for all the
      member objects (or perform a bitcopy on built-in types) so you'll
      get the right behavior:
    -->

      <para>
	Si permite que el compilador cree un constructor copia de una
	clase derivada, éste llamara automáticamente al constructor
	copia de la clase base, y entones ,a los constructores copia
	para todos los miembros objeto (o realizará una copia de bits en
	los tipos predefinidos) entonces conseguirá la conducta
	correcta:
      </para>


//: V1C14:CopyConstructor.cpp


      <!--
      The operator<< for Child is interesting because of the way that it
      calls the operator<< for the Parent part within it: by casting the
      Child object to a Parent& (if you cast to a base-class object
      instead of a reference you will usually get undesirable results):
      -->

      <para>
	El operador&lt;&lt; de Child es interesante por la forma en que llama
	al operador&lt;&lt; del padre dentro de éste: convirtiendo el objeto
	Child a Parent&amp; (si lo convierte a un objeto de la clase base en
	vez de una referencia, probablemente obtendrá resultados no
	deseados)
      </para>


<programlisting>
return os &lt;&lt; (Parent&amp;)c &lt;&lt; c.m
</programlisting>


      <!--
      Since the compiler then sees it as a Parent, it calls the Parent
      version of operator<<.
      -->

      <para>
	Dado que el compilador lo ve como Parent, éste llama al
	operador&lt;&lt; Parent.
      </para>

      <!--
      You can see that Child has no explicitly-defined
      copy-constructor. The compiler then synthesizes the
      copy-constructor (since that is one of the four functions it will
      synthesize, along with the default constructor - if you don't
      create any constructors - the operator= and the destructor) by
      calling the Parent copy-constructor and the Member
      copy-constructor. This is shown in the output
      -->

      <para>
	Puede observar que Child no tiene explícitamente definido un
	constructor copia. El compilador crea el constructor copia (es
	una de las cuatro funciones que sintetiza, junto con el
	constructor del defecto - si no creas a ninguna constructores -
	el operator= y el destructor) llamando el constructor copia de
	Parent y el constructor copia de Member. Esto muestra la
	siguiente salida
      </para>


<screen>
Parent(int ii)
Member(int ii)
Child(int ii)
calling copy-constructor:
Parent(const Parent&amp;)
Member(const Member&amp;)
values in c2:
Parent: 2
Member: 2
Child: 2
</screen>


      <!--
      However, if you try to write your own copy-constructor for Child
      and you make an innocent mistake and do it badly:
      -->

      <para>
	Sin embargo, si escribe su propio constructor copia para Child
	puede tener un error inocente y funcionar incorrectamente:
      </para>


<programlisting>
Child(const Child&amp; c) : i(c.i), m(c.m) {}
</programlisting>


      <!--
      then the default constructor will automatically be called for the
      base-class part of Child, since that's what the compiler falls
      back on when it has no other choice of constructor to call
      (remember that some constructor must always be called for every
      object, regardless of whether it's a subobject of another
      class). The output will then be:
      -->

      <para>
	entonces el constructor por defecto será llamado automáticamente
	por la clase base por parte de Child, aquí es dónde el
	compilador muestra un error cuando no tienen otra (recuerde que
	siempre algun constructor se ejecuta para cada objeto, sin
	importar si es un subobjeto de otra clase). La salida será
	entonces:
      </para>


<screen>
Parent(int ii)
Member(int ii)
Child(int ii)
calling copy-constructor:
Parent()
Member(const Member&amp;)
values in c2:
Parent: 0
Member: 2
Child: 2
</screen>


      <!--
      This is probably not what you expect, since generally you'll want
      the base-class portion to be copied from the existing object to
      the new object as part of copy-construction.
      -->

      <para>
	Esto probablemente no es lo que espera, generalmente deseará que
	la parte de la clase base sea copiada del objeto existente al
	nuevo objeto como parte del constructor copia.
      </para>

      <!--
      To repair the problem you must remember to properly call the
      base-class copy-constructor (as the compiler does) whenever you
      write your own copy-constructor. This can seem a little
      strange-looking at first but it's another example of upcasting:
      -->

      <para>
	Para arreglar el problema debe recordar como funciona la llamada
	al constructor copia de la clase base (como el compilador lo
	hace) para que escriba su propio constructor copia. Este puede
	parecer un poco extraño a primera vista pero es otro ejemplo de
	upcasting.
      </para>


<programlisting>
Child(const Child&amp; c)
   : Parent(c), i(c.i), m(c.m) {
   cout &lt;&lt; "Child(Child&amp;)\n";
}
</programlisting>


      <!--
      The strange part is where the Parent copy-constructor is called:
      Parent(c). What does it mean to pass a Child object to a Parent
      constructor? But Child is inherited from Parent, so a Child
      reference is a Parent reference. The base-class copy-constructor
      call upcasts a reference to Child to a reference to Parent and
      uses it to perform the copy-construction. When you write your own
      copy constructors you'll almost always want to do the same thing.
      -->

      <para>
	La parte extraña es cómo el constructor copia es ejecutado:
	Parent(c). ¿Qué significa pasar un objeto Child al constructor
	padre?  Child hereda de Parent, entonces una referencia de Child
	es una referencia Parent. El constructor copia de la clase base
	convierte a una referencia de Child a una referencia de Parent y
	la utiliza en el construcción de la copia. Cuando escribe su
	propio constructor copia la mayoría de ocasiones deseará lo
	mismo.
      </para>
    </sect2>

    <sect2>
      <!-- Composition vs. inheritance (revisited) -->
      <title>Composición vs. herencia FIXME (revisited)</title>

      <!--
      One of the clearest ways to determine whether you should be using
      composition or inheritance is by asking whether you'll ever need
      to upcast from your new class. Earlier in this chapter, the Stack
      class was specialized using inheritance. However, chances are the
      StringStack objects will be used only as string containers and
      never upcast, so a more appropriate alternative is composition:
      -->

      <para>
	Una de las maneras más claras de determinar cuando debe utilizar
	la composición o la herencia es preguntando cuando será
	necesaria la conversión desde su nueva clase. Anteriormente, en
	esta capitulo, la clase Stack fue especializada utilizando la
	herencia. Sin embargo, los cambios en StringStack serán
	utilizados son como contenedores de string y nunca serán
	convertidos, pero ello, es mucho mas apropiado utilizas la
	alternativa de la composición.
      </para>


//: V1C14:InheritStack2.cpp


      <!--
      The file is identical to InheritStack.cpp, except that a Stack
      object is embedded in StringStack, and member functions are called
      for the embedded object. There's still no time or space overhead
      because the subobject takes up the same amount of space, and all
      the additional type checking happens at compile time.
    -->

      <para>
	El fichero es idéntico a InheritStack.cpp, excepto que un objeto
	Stack es alojado en StringStack y se utilizan las funciones
	miembros para llamarlo. No se consume tiempo o espacio porque el
	subobjeto tiene el mismo tamaño y todas las comprobaciones de
	tipos han ocurrido en tiempo de compilación.
      </para>

      <!--
      Although it tends to be more confusing, you could also use private
      inheritance to express "implemented in terms of.¡É This would also
      solve the problem adequately. One place it becomes important,
      however, is when multiple inheritance might be warranted. In that
      case, if you see a design in which composition can be used instead
      of inheritance, you may be able to eliminate the need for multiple
      inheritance.
      -->

      <para>
	Sin embargo, esto tiende a confusión, podría también utilizar la
	herencia privada para expresar "implementado en términos
	de". Esto también resolvería el problema de forma adecuada. Un
	punto importante es cuando la herencia múltiple puede ser
	garantizada. En este caso, si observa un diseño en que la
	composición pueda utilizarse en vez de la herencia, debe
	eliminar la necesidad de utilizar herencia múltiple.
      </para>
    </sect2>

    <sect2>
      <!-- Pointer & reference upcasting -->
      <title>FIXME Upcasting de punteros y referencias</title>

      <!--
      In Instrument.cpp, the upcasting occurs during the function call -
      a Wind object outside the function has its reference taken and
      becomes an Instrument reference inside the function. Upcasting can
      also occur during a simple assignment to a pointer or reference:
      -->

      <para>
	En Instrument.cpp, la conversión ocurre durante la llamada a la
	función - un objeto Wind fuera de la función se toma como
	referencia y se convierte en una referencia Instrument dentro de
	la función. La conversión puede también ocurrir durante una
	asignación a un puntero o una referencia.
      </para>


<programlisting>
Wind w;
Instrument* ip = &amp;w; // Upcast
Instrument&amp; ir = w; // Upcast
</programlisting>


      <!--
      Like the function call, neither of these cases requires an
      explicit cast.
      -->

      <para>
	Como en la llamada a la función, ninguno de estos casos requiere una
	conversión explicita.
      </para>
    </sect2>

    <sect2>
      <!-- A crisis -->
      <title>Una crisis</title>

      <!--
      Of course, any upcast loses type information about an object. If
      you say
      -->

      <para>
	Por supuesto, cualquier conversión pierde la información del tipo sobre
	el objeto. Si dice
      </para>


<programlisting>
Wind w;
Instrument* ip = &amp;w;
</programlisting>


      <!--
      the compiler can deal with ip only as an Instrument pointer and
      nothing else. That is, it cannot know that ip actually happens to
      point to a Wind object. So when you call the play() member
      function by saying
      -->

      <para>
	el compilador puede utilizar ip solo como un puntero a
	Instrumento y nada mas. Esto es, éste no puede conocer que ip
	realmente esta apuntando a un objeto Wind. Entonces cuando llame
	a la función miembro play() diciendo
      </para>


<programlisting>
ip->play(middleC);
</programlisting>


      <!--
      the compiler can know only that it's calling play() for an
      Instrument pointer, and call the base-class version of
      Instrument::play() instead of what it should do, which is call
      Wind::play(). Thus, you won't get the correct behavior.
      -->

      <para>
	el compilador solo puede conocer que la llamada a play() es de
	un puntero a Instrument y llamara a la versión de la clase base
	Instrument::play() en vez de lo que debería hacer, que es llamar
	a Wind::play(). Así, no conseguirá una conducta adecuada.
      </para>

      <!--
      This is a significant problem; it is solved in Chapter 15 by
      introducing the third cornerstone of object-oriented programming:
      polymorphism (implemented in C++ with virtual functions).
      -->

      <para>
	esto es un problema importante; es resulto en el Capitulo 15,
	introducción al tercer pilar de la programación orientada a
	objetos: poliformismo (implementado en C++ con funciones
	virtuales).
      </para>
    </sect2>

    </sect1>

  <sect1>
    <title>Resumen</title>

    <!--
    Both inheritance and composition allow you to create a new type from
    existing types, and both embed subobjects of the existing types
    inside the new type. Typically, however, you use composition to
    reuse existing types as part of the underlying implementation of the
    new type and inheritance when you want to force the new type to be
    the same type as the base class (type equivalence guarantees
    interface equivalence). Since the derived class has the base-class
    interface, it can be upcast to the base, which is critical for
    polymorphism as you'll see in Chapter 15.
    -->

    <para>
      Herencia y composición le permiten crear nuevos tipos desde tipos
      existentes y ambos incluyen subobjetos de tipos existentes dentro
      del nuevo tipo. Sin embargo, normalmente, utilizara la composición
      para reutilizar tipos existentes como parte de la capa de
      implementación de un nuevo tipo y la herencia cuando desea forzar
      al nuevo tipo a ser del mismo tipo que la clase base (la
      equivalencia de tipos garantiza la equivalencia de la
      interfaz). Como las clases derivadas tienen el interfaz de la
      clase base, esta puede ser convertidas a la base, lo cual es
      crítico para el poliformismo como verá el Capítulo 15.
    </para>

    <!--
    Although code reuse through composition and inheritance is very helpful
    for rapid project development, you'll generally want to redesign
    your class hierarchy before allowing other programmers to become
    dependent on it. Your goal is a hierarchy in which each class has a
    specific use and is neither too big (encompassing so much
    functionality that it's unwieldy to reuse) nor annoyingly small
    (you can't use it by itself or without adding functionality).
    -->

    <para>
      Aunque la reutilización de código a través de la composición y la
      herencia es muy útil para el desarrollo rápido de proyectos,
      generalmente deseara rediseñar su jerarquía de clases antes de
      permitir a otros programadores dependan de ella. Su objetivo es
      crear una jerarquía en que cada clase tenga un uso especifico y
      sin ser demasiado grande (esforzándose más en la funcionalidad que
      en la dificultad de la reutilización...), ni pequeña, (no se podrá
      usar por si mismo o sin añadir funcionalidad).
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>
<xi:include parse="xml" href="./ejercicios.xml"/>

   <orderedlist>
      <listitem>
	<!--
	1 Modify Car.cpp so that it also inherits from a class
	called Vehicle, placing appropriate member functions in Vehicle
	(that is, make up some member functions). Add a nondefault
	constructor to Vehicle, which you must call inside Car's
	constructor.  -->
	<para>
	  Modificar Car.cpp para que herede desde una clase llamada
	  Vehicle, colocando correctamente las funciones miembro en
	  Vehicle (esto es, añadir algunas funciones miembro). Añada un
	  constructor (no el de por defecto) a Vehicle, que debe ser
	  llamado desde dentro del constructor Car
	</para>
      </listitem>
      <listitem>
      <!--
    2 Create two classes, A and B, with default constructors that
      announce themselves. Inherit a new class called C from A, and
      create a member object of B in C, but do not create a constructor
      for C. Create an object of class C and observe the results.
    -->
	<para>
	  Crear dos clases, A y B, con constructor por defectos
	  notificándose ellos mismos. Una nueva clase llamada C que
	  hereda de A, y cree un objeto miembro B dentro de C, pero no
	  cree un constructor para C. Cree un objeto de la clase C y
	  observe los resultados.
	</para>
      </listitem>
      <listitem>
      <!--
    3 Create a three-level hierarchy of classes with default
      constructors, along with destructors, both of which announce
      themselves to cout. Verify that for an object of the most derived
      type, all three constructors and destructors are automatically
      called. Explain the order in which the calls are made.
    -->
	<para>
	  Crear una jerarquía de clases de tres niveles con
	  constructores por defecto y con destructores, ambos
	  notificándose utilizando cout. Verificar que el objeto más
	  alto de la jerarquía, los tres constructores y destructores
	  son ejecutados automáticamente. Explicar el orden en que han
	  sido realizados.
	</para>
      </listitem>
      <listitem>
      <!--
    4 Modify Combined.cpp to add another level of inheritance and a new
      member object. Add code to show when the constructors and
      destructors are being called.
    -->
	<para>
	  Modificar Combined.cpp para añadir otro nivel de herencia y un
	  nuevo objeto miembro. Añadir el código para mostrar cuando los
	  constructores y destructores son ejecutados.
	</para>
      </listitem>
      <listitem>
      <!--
    5 In Combined.cpp, create a class D that inherits from B and has a
      member object of class C. Add code to show when the constructors
      and destructors are being called.
	-->
	<para>
	  En Combined.cpp, crear una clase D que herede de B y que tenga
	  un objeto miembro de la clase C. Añadir el código para mostrar
	  cuando los constructores y los destructores son ejecutados.
	</para>
      </listitem>
      <listitem>
      <!--
    6 Modify Order.cpp to add another level of inheritance Derived3 with
      member objects of class Member4 and Member5. Trace the output of
      the program.
	-->
	<para>
	  Modificar Order.cpp para añadir otro nivel de herencia
	  Derived3 con objetos miembro de la clase Member4 y
	  Member5. Compruebe la salida del programa.
	</para>
      </listitem>
      <listitem>
	<!--
    7 In NameHiding.cpp, verify that in Derived2, Derived3, and
      Derived4, none of the base-class versions of f() are available.
	-->
	<para>
	  En NameHidding.cpp, verificar que Derived2, Derived3 y
	  Derived4, ninguna versión de la clase base de f() esta
	  disponible.
	</para>
      </listitem>
      <listitem>
	<!--
    8 Modify NameHiding.cpp by adding three overloaded functions named
      h() to Base, and show that redefining one of them in a derived
      class hides the others.
	-->
	<para>
	  Modificar NameHiding.cpp añadiendo tres funciones
	  sobrecargadas llamadas h() en Base y mostrar como redefiniendo
	  una de ellas en una clase derivada oculta las otras.
	</para>
      </listitem>
      <listitem>
	<!--
    9 Inherit a class StringVector from vector&lt;void*> and redefine the
    push_back() and operator[] member functions to accept and produce
    string*. What happens if you try to push_back() a void*?
	-->
	<para>
	  Crear una clase StringVector que herede de vector&lt;void*> y
	  redefinir push_back y el operador [] para aceptar y producir
	  string*. ¿Qué ocurre si intenta utilizar push_back() un void*?
	</para>
      </listitem>
      <listitem>
	<!--
	10 Write a class containing a long and use the psuedo-constructor
	call syntax in the constructor to initialize the long.
	-->
	<para>
	  Escribir una clase que contenga muchos tipos y utilice una
	  llamada a una función pseudo-constructor que utiliza la misma
	  sintaxis de un constructor.Utilizarla en el constructor para
	  inicializar los tipos.
	</para>
      </listitem>
      <listitem>
	<!--
    11 Create a class called Asteroid. Use inheritance to specialize
    the PStash class in Chapter 13 (PStash.h & PStash.cpp) so that
    it accepts and returns Asteroid pointers. Also modify
    PStashTest.cpp to test your classes. Change the class so PStash
    is a member object.
	-->
	<para>
	  Crear una clase llamada Asteroid. Utilizar la herencia para
	  especializar la clase PStash del capítulo 13 (PStash.h y
	  PStash.cpp) para que la acepte y retorne punteros a
	  Asteroid. También modifique PStashTest.cpp para comprobar sus
	  clases. Cambiar la clase para que PStash sea un objeto
	  miembro.
	</para>
      </listitem>
      <listitem>
	<!--
	12 Repeat Exercise 11 with a vector instead of a PStash.
	-->
	<para>
	  Repita el ejercicio 11 con un vector en vez de la clase
	  PStash.
	</para>
      </listitem>
      <listitem>
	<!--
	13 In SynthesizedFunctions.cpp, modify Chess to give it a
	default constructor, copy-constructor, and assignment
	operator. Demonstrate that you've written these correctly.  -->
	<para>
	  En SynthesizedFunctions.cpp, modifique Chess para
	  proporcionarle un constructor por defecto, un constructor
	  copia y un operador de asignación. Demostrar que han sido
	  escritos correctamente.
	</para>
      </listitem>
      <listitem>
	<!--
	14 Create two classes called Traveler and Pager without
	default constructors, but with constructors that take an
	argument of type string, which they simply copy to an internal
	string variable. For each class, write the correct
	copy-constructor and assignment operator. Now inherit a class
	BusinessTraveler from Traveler and give it a member object of
	type Pager. Write the correct default constructor, a constructor
	that takes a string argument, a copy-constructor, and an
	assignment operator.  -->
	<para>
	  Crear dos clases llamadas Traveler y Pager sin constructores
	  por defecto, pero con constructores que toman un argumento del
	  tipo string, el cual simplemente lo copia a una variable
	  interna del tipo string. Para cada clase, escribir
	  correctamente un constructor copia y el operador de
	  asignación. Entonces cree la clase BusinessTraveler que hereda
	  de Traveler y crear ub objeto miembro Pager dentro
	  ella. Escribir correctamente el constructor por defecto, un
	  constructor que tome una cadena como argumento, un constructor
	  copia y un operador de asignación.
	</para>
      </listitem>
      <listitem>
	<!--
	15 Create a class with two static member functions. Inherit
	from this class and redefine one of the member functions. Show
	that the other is hidden in the derived class.  -->
	<para>
	  Crear una clase con dos funciones miembro estáticas. Herede de
	  estas clases y redefina una de las funciones miembro. Mostrar
	  que la otra función se oculta en la clase derivada.
	</para>
      </listitem>
      <listitem>
	<!--
	16 Look up more of the member functions for ifstream. In
	FName2.cpp, try them out on the file object.  -->
	<para>
	  Mejorar las funciones miembro de ifstream. En FName2.cpp,
	  intentar suprimirlas del objeto file.
	</para>
      </listitem>
      <listitem>
	<!--
	17 Use private and protected inheritance to create two new
	classes from a base class. Then attempt to upcast objects of the
	derived class to the base class. Explain what happens.  -->
	<para>
	  Utilice la herencia privada y protegida para crear dos nuevas
	  clases desde la clase base. Intente convertir los objetos de
	  las clases derivadas en la clase base. Explicar lo que ocurre.
	</para>
      </listitem>
      <listitem>
	<!--
	18 In Protected.cpp, add a member function in Derived that
	calls the protected Base member read().  -->
	<para>
	  En Protected.cpp, añadir una función miembro en Derived que
	  llame al miembro protegido de Base read().
	</para>
      </listitem>
      <listitem>
	<!--
	19 Change Protected.cpp so that Derived is using protected
	inheritance. See if you can call value() for a Derived object.
	-->
	<para>
	  Cambiar Protected.cpp para que Derived utilice herencia
	  protegida. Compruebe si puede llamar a value() desde un objeto
	  Derived.
	</para>
      </listitem>
      <listitem>
	<!--
	20 Create a class called SpaceShip with a fly()
	method. Inherit Shuttle from SpaceShip and add a land()
	method. Create a new Shuttle, upcast by pointer or reference to
	a SpaceShip, and try to call the land() method. Explain the
	results. -->
	<para>
	  Crear una clase llamada SpaceShip con un metodo fly(). Crear
	  Shuttle que hereda de SpaceShip y añadir el metodo
	  land(). Creat un nuevo Shuttle, convertirlo por puntero o
	  referenciaa SpaceShip e intente llamar al metodo
	  land(). Explicar los resultados.
	</para>
      </listitem>
      <listitem>
	<!--
	21 Modify Instrument.cpp to add a prepare() method to
	Instrument. Call prepare() inside tune().  -->
	<para>
	  Modificar Instrument.cpp para añadir un método prepare() a
	  Instrument. Llamar a prepare () dentro de tune().
	</para>
      </listitem>
      <listitem>
	<!--
	22 Modify Instrument.cpp so that play() prints a message to
	cout, and Wind redefines play() to print a different message to
	cout. Run the program and explain why you probably wouldn't want
	this behavior. Now put the virtual keyword (which you will learn
	about in Chapter 15) in front of the play() declaration in
	Instrument and observe the change in the behavior.  -->
	<para>
	  Modificar Instrument.cpp para que play() muestre un mensaje
	  con cout y que Wind redefina play() para que muestra un
	  mensaje diferente con cout. Ejecute el programa y explique
	  porque probamenteble no deseara esta conducta. Ahora ponga la
	  palabra reservada virtual (la cual aprenderá en el capitulo
	  15) delante de de la declaración de play en Instrument y
	  observe el cambio en el comportamiento.
	</para>
      </listitem>
      <listitem>
	<!--
	23 In CopyConstructor.cpp, inherit a new class from Child
	and give it a Member m. Write a proper constructor,
	copy-constructor, operator=, and operator<< for ostreams, and
	test the class in main().  -->
	<para>
	  En CopyConstructor.cpp, herede una nueva clase de Child y
	  proporcionarle un miembro m. Escribir un constructor correcto,
	  un constructor copia, operator= y operator&lt;&lt; de ostreams y
	  comprobar la clase en main().
	</para>
      </listitem>
      <listitem>
	<!--
	24 Take the example CopyConstructor.cpp and modify it by
	adding your own copy-constructor to Child without calling the
	base-class copy-constructor and see what happens. Fix the
	problem by making a proper explicit call to the base-class copy
	constructor in the constructor-initializer list of the Child
	copy-constructor.  -->
	<para>
	  Tomar como ejemplo CopyConstructor.cpp y modifíquelo añadiendo
	  su propio constructor copia a Child sin llamar el constructor
	  copia de clase base y comprobar que ocurre. Arregle el
	  problema añadiendo una llamada explicita al constructor copia
	  de la clase base en la lista de inicialización del constructor
	  del constructor copia de Child.
	</para>
      </listitem>
      <listitem>
	<!--
	25 Modify InheritStack2.cpp to use a vector&lt;string>
	instead of a Stack.  -->
	<para>
	  Modificar InheritStack2.cpp para utilizar un vector&lt;string>
	  en vez de Stack.
	</para>
      </listitem>
      <listitem>
	<!--
	26 Create a class Rock with a default constructor, a
	copy-constructor, an assignment operator, and a destructor, all
	of which announce to cout that they've been called. In main(),
	create a vector&lt;Rock> (that is, hold Rock objects by value)
	and add some Rocks. Run the program and explain the output you
	get. Note whether the destructors are called for the Rock
	objects in the vector. Now repeat the exercise with a
	vector&lt;Rock*>. Is it possible to create a vector&lt;Rock&>?
	-->
	<para>
	  Crear una clase Rock con un constructor por defecto, un
	  constructor copia y un operador de asignación y un destructor,
	  todos ellos mostrándose para saber que han sido ejecutados. En
	  main(), crear un vector&lt;Rock> (esto es, tener objetos Rock
	  por valor) y añadir varios Rocks. Ejecutar el programa y
	  explicar los resultados obtenidos. Fijarse cuando los
	  destructores son llamados desde los objetos Rock en el
	  vector. Ahora repita el ejercicio con un vector&lt;Rock*>. ¿Es
	  posible crear un vector&lt;Rock&amp;>?
	</para>
      </listitem>
      <listitem>
	<!--
	27 This exercise creates the design pattern called
	proxy. Start with a base class Subject and give it three
	functions: f(), g(), and h(). Now inherit a class Proxy and two
	classes Implementation1 and Implementation2 from Subject. Proxy
	should contain a pointer to a Subject, and all the member
	functions for Proxy should just turn around and make the same
	calls through the Subject pointer. The Proxy constructor takes a
	pointer to a Subject that is installed in the Proxy (usually by
	the constructor). In main( ), create two different Proxy objects
	that use the two different implementations. Now modify Proxy so
	that you can dynamically change implementations.  -->
	<para>
	  En este ejercicio cree un patrón de diseño llamado
	  proxy. Comience con la clase base Subject y proporciónele tres
	  funciones: f(), g() y h(). Ahora herede una clase Proxy y dos
	  clases Implementation1 e Implementacion2 de Subject. Proxy
	  tendría que contener un puntero a un Suboject y todos los
	  miembros de Proxy (usualmente el constructor). En main(),
	  crear dos objetos Proxy diferentes que usen las dos
	  implementaciones diferentes. Modificar Proxy para que
	  dinámicamente cambie las implementaciones.
	</para>
      </listitem>
      <listitem>
	<!--
	28 Modify ArrayOperatorNew.cpp from Chapter 13 to show
	that, if you inherit from Widget, the allocation still works
	correctly. Explain why inheritance in Framis.cpp from Chapter 13
	would not work correctly.  -->
	<para>
	  Modificar ArrayOperatorNew del Capítulo 13 para mostrar que si
	  deriva de Widget, la reserva de memoria todavía funciona
	  correctamente. Explicar porque la herencia en Framis.cpp no
	  funcionaria correctamente.
	</para>
      </listitem>
      <listitem>
	<!--
	29 Modify Framis.cpp from Chapter 13 by inheriting from
	Framis and creating new versions of new and delete for your
	derived class. Demonstrate that they work correctly.  -->
	<para>
	  Modificar Framis.cpp del Capítulo 13 para que herede de Framis
	  y crear nuevas versiones de new y delete para su clase
	  derivada. Demostrar como todo ello funciona correctamente.
	</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>
