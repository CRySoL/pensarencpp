<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Miguel Ángel García
  Formateado DocBook:  Miguel Ángel García
  1ª Revisión:         David Martínez Moreno <ender@debian.org>
  2ª Revisión
-->

<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<preface>

  <title>Prefacio</title>

  <!-- FIXME: aún por formatear, revisar, volver a leer, ... -->

  <para>
    Como cualquier lenguaje humano, C++ ofrece maneras de expresar
    conceptos. Si se utiliza de forma correcta, este medio de expresión
    será significativamente más sencillo y más flexible que otras
    alternativas cuando los problemas crezcan en tamaño y complejidad.
  </para>

  <para>
    No se puede ver C++ sólo como una colección de características, ya
    que algunas de estas características no tienen sentido
    aisladas. Sólo se puede utilizar la suma de las partes si se está
    pensando en el diseño, no sólo en el código. Y para entender C++ de
    esta forma, se deben comprender los problemas existentes con el
    lenguaje C y con la programación en general. Este libro trata los
    problemas de programación, porque son problemas, y la aproximación
    que en C++ se ha elegido para solucionarlos.  Además, el conjunto de
    características que explico en cada capítulo se basará en la forma
    en que yo veo un tipo de problema en particular y cómo resolverlo
    con el lenguaje. De esta forma espero llevar al lector, poco a poco,
    del punto de entender C hasta un momento en el que pensar en C++ se
    convierta en su propia lengua.
  </para>


  <!-- en el párrafo siguiente me he tomado algunas licencias que
  facilitan la comprensión del mismo. Miguel Ángel García -->

  <para>
    Durante todo el libro, tomaré la actitud de que el lector desea
    construir en su cabeza un modelo que le permita comprender el
    lenguaje bajando hasta sus raíces; si se tropieza con un
    rompecabezas, será capaz de compararlo con el modelo en su cabeza y
    deducir la respuesta. Trataré de comunicarle las precepciones que
    han reorientado mi cerebro para hacer que «Pensar en C++».
  </para>
	 
  <sect1>
    <title>Material nuevo en la segunda edición</title>

    <para>
      Este libro es una minuciosa reescritura de la primera edición para
      reflejar todos los cambios introducidos en C++ tras la
      finalización del estándar que lo rige, y también para reflejar lo
      que he aprendido desde la escritura de la primera edición. He
      examinado y reescrito el texto completo presente en la primera
      edición, en ocasiones quitando viejos ejemplos, a veces cambiando
      los existentes, y también añadiendo muchos ejercicios nuevos. La
      significativa reorganización y reordenación del material tuvo
      lugar para reflejar la disponibilidad de mejores herramientas, así
      como mi mejor comprensión de cómo aprende C++ la gente. He añadido
      un nuevo capítulo, como introducción al resto del libro, que es
      una introducción rápida a los conceptos de C y a las
      características básicas de C++ para aquellos que no tienen
      experiencia en <acronym>C</acronym>. El <acronym>CD-ROM</acronym>
      incluido al final del libro en la edición en papel contiene un
      seminario que es una introducción aún más ligera a los conceptos
      de <acronym>C</acronym> necesarios para comprender C++ (o
      <acronym>Java</acronym>). Chuck Allison lo escribió para mi
      empresa (MindView, Inc.), y se denomina «Pensar en C: conceptos
      básicos de Java y C++». Le presentará los aspectos de
      <acronym>C</acronym> que necesita conocer para que pueda cambiarse
      a C++ o <acronym>Java</acronym>, abandonando los desagradables
      bits de bajo nivel con los que los programadores de
      <acronym>C</acronym> tratan a diario pero que lenguajes como C++ y
      <acronym>Java</acronym> mantienen lejos (o incluso eliminan, en el
      caso de <acronym>Java</acronym>).
    </para>

    <para>
      Así que la respuesta corta a la preguna «¿Qué es diferente en
      la segunda edición?» sería que aquello que no es completamente nuevo
      se ha reescrito, a veces hasta el punto en el que no podría
      reconocer los ejemplos y el material originales de la primera edición.
    </para>

    <sect2>
      <title>¿Qué contiene el volumen 2 de este libro?</title>

      <para>
	Con la finalización del estándar de C++, también se han
	añadido algunas nuevas bibliotecas importantes, como las
	«string» y los contenedores, y algoritmos de la «biblioteca C++
	estándar», así como añadido complejidad a las
	plantillas. Éstos y otros temas más avanzados se han
	relegado al volumen 2 de este libro, incluyendo temas tales
	como la herencia múltiple, el manejo de excepciones,
	patrones de diseño, y material sobre la creación y
	depuración de sistemas estables.
      </para>
    </sect2>

    <sect2>
      <title>Cómo obtener el volumen 2</title> 

      <para>
	De la misma manera que el libro que lee en estos momentos,
	Pensar en C++, el volumen 2 se puede descargar
	desde mi sitio web en <ulink
	  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>. Se
	puede encontrar información en el sitio web sobre la fecha
	prevista para la impresión del volumen 2.
      </para>

      <para>
	El sitio web también contiene el código fuente para ambos
	libros, junto con actualizaciones e información sobre otros
	<acronym>seminarios en CD-ROM</acronym> que ofrece MidView Inc.,
	seminarios públicos y formación interna, consultas, soporte y
	asistentes paso a paso.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Requisitos</title>

    <para>
      En la primera edición de este libro, decidí suponer por simplificar
      que otra persona le había enseñado previamente <acronym>C</acronym> y
      que el lector tenía, al menos, un nivel de lectura del mismo aceptable.
      Mi primera intención fue hablar de lo que encontré difícil: el lenguaje
      C++. En esta edición he añadido un capítulo como introducción rápida
      a <acronym>C</acronym>, acompañada del «seminario en CD» de
      «Pensar en C», pero aún asumo que usted tiene algún tipo de
      experiencia en programación. Además, de la misma manera que se
      aprenden muchas palabras nuevas intuitivamente viéndolas en el
      contexto de una novela, es posible aprender mucho sobre
      <acronym>C</acronym> por el contexto en el que se utiliza en
      el resto del libro.
    </para>
  </sect1>

  <sect1>
    <title>Aprender C++</title>

    <para>
      Yo me adentré en C++ desde exactamente la misma posición en la
      que espero que se encuentren muchos de los lectores de este
      libro: como un programador con una actitud muy sensata y con
      muchos vicios de programación. Peor aún, por mis circunstancias,
      mi experiencia pertenecía a la programación empotrada a nivel
      hardware, en la que a veces se considera a <acronym>C</acronym>
      como un «lenguaje de alto nivel» y excesivamente ineficiente
      para ahorrar bits. Descubrí más tarde que nunca había sido un
      buen programador en <acronym>C</acronym>, camuflando así mi
      ignorancia sobre estructuras, malloc() y free(), setjmp() y
      longimp(), y otros conceptos «sofisticados», y muriéndome de
      vergüenza cuando estos términos entraban en una conversación, en
      lugar de investigar su utilidad.
    </para>

    <para>
      Cuando comencé mi lucha por aprender C++, el único libro
      decente era el del autodidacta Bjarne Stroustrup «Expert's
      guide»[1], por lo que me dejaron simplificar los conceptos
      básicos por mí mismo. Esto resultó siendo mi primer libro de C++ [2],
      que es esencialmente un plasmado de mi experiencia. Fue
      descrito como una guía de lectura para atraer a los
      programadores a <acronym>C</acronym> y C++ al mismo
      tiempo. Ambas ediciones [3] del libro acumularon una respuesta
      entusiasta.
    </para>

    <para>
      Más o menos al mismo tiempo que aparecía «Using C++», comencé
      a enseñar el lenguaje con seminarios y presentaciones. Enseñar
      C++ (y más tarde, <acronym>Java</acronym>) se convirtió en mi
      profesión; llevo viendo cabezas asintiendo, caras pálidas, y
      expresiones de perplejidad en audiencias por todo el mundo
      desde 1989. Cuando comencé a dar formación interna a grupos de
      gente más pequeños, descubrí algo durante los
      ejercicios. Incluso aquella gente que estaba sonriendo y
      asintiendo se encontraba equivocada en muchos
      aspectos. Descubrí, creando y dirigiendo las pruebas de C++ y
      <acronym>Java</acronym> durante muchos años en el departamento
      de conferencias para desarrollo de software, que tanto otros
      oradores como yo tendíamos a tocar demasiados temas, y todo demasiado
      rápido. Así que, de vez en cuando, a pesar de la variedad del
      nivel de la audiencia e independientemente de la forma en que
      presentara el material, terminaría perdiendo alguna parte de mi
      público. Quizá sea pedir demasiado, pero como soy una de
      esas personas que se resisten a la lectura tradicional (y para
      la mayoría de las personas, creo, esta resistencia resulta del
      aburrimiento), quise intentar mantener a cada uno a su
      velocidad.
    </para>

    <para>
      Durante un tiempo, estuve haciendo presentaciones en orden secuencial.
      A pesar de esto, terminé por aprender experimentando y repitiendo
      todo una y otra vez (una técnica que
      también funciona bien en el diseño de programas en C++). Al final,
      desarrollé un curso usando todo lo que había
      aprendido de mi experiencia en la enseñanza. Así, el aprendizaje se
      efectúa en pequeños pasos, fáciles de digerir, y de cara a un
      seminario práctico (la situación
      ideal para el aprendizaje) hay ejercicios al final de cada
      presentación. Puede encontrar mis seminarios públicos en
      <ulink url="www.BruceEckel.com">www.BruceEckel.com</ulink>, y
      también puede aprender de los seminarios que he pasado a
      <acronym>CD-ROM</acronym>.
    </para>

    <para>
      La primera edición de este libro se gestó a lo largo de
      dos años, y el material de este libro se ha usado
      de muchas formas y en muchos seminarios diferentes. La
      reacción que he obtenido de cada seminario me ha ayudado a
      cambiar y reorientar el material hasta que he sentido que
      funciona bien como un medio de enseñanza. Pero no es sólo un
      manual para dar seminarios; he tratado de recopilar tanta
      información como he podido en estas páginas, y estructurarlas
      para atraerle hasta la siguiente materia. Más que nada, el
      libro está diseñado para servir al lector solitario que lucha
      con un lenguaje de programación nuevo.
    </para>
  </sect1>

<!-- FIXME: Voy por aquí. Ender. -->

  <sect1>
    <title>Objetivos</title>

    <para>
      Mis objetivos en este libro son:</para>

    <orderedlist>
      <listitem>
	<para>
	  Presentar el material paso a paso, de manera que el lector
	  pueda digerir cada concepto fácilmente antes de continuar.
	</para>
      </listitem>
      <listitem>
	<para>
	  Usar ejemplos tan simples y cortos como sea posible. Esto
	  a veces me impide manejar problemas del "mundo real", pero
	  he descubierto que los principiantes normalmente quedan
	  más contentos cuando pueden comprender cada detalle de un
	  ejemplo que siendo impresionados por el ámbito del
	  problema que soluciona. Además, hay un severo límite en la
	  cantidad de código que puede ser absorvido en una
	  clase. Por ello a veces recibo críticas por usar "ejemplos
	  de juguete", pero tengo la buena voluntad de aceptarlas a
	  favor de producir algo pedagógicamente útil.
	</para>
      </listitem>

      <listitem>
	<para>
	  La cuidadosa presentación secuencial de capacidades para
	  que no se vea algo que no ha sido explicado. De acuerdo,
	  esto no siempre es posible; en esos casos, se dará una
	  descripción introductoria breve.
	</para>
      </listitem>

      <listitem>
	<para>
	  Ofrecerle lo que pienso que es importante para que se
	  comprenda el lenguaje, más que todo lo que sé. Creo que
	  hay una "herencia de la importancia de la información", y
	  hay algunos hechos que el 95 por ciento de los
	  programadores nunca necesitará saber y que sólo podría
	  confundirles y añadirse a su percepción de la complejidad
	  del lenguaje. Tomando un ejemplo de <acronym>C</acronym>,
	  si memoriza la tabla de precedencia de los operadores (yo
	  nunca lo hice), puede escribir código más corto. Pero si
	  lo piensa, esto confundirá al lector/actualizador de ese
	  código. Así que olvide la precedencia, y utilice
	  paréntesis cuando las cosas no estén claras. Esta misma
	  actitud se tomará con alguna información del lenguaje C++,
	  la cual creo que es más importante para escritores de
	  compiladores que para programadores.
	</para>
      </listitem>

      <listitem>
	<para>
	  Mantener cada sección suficientemente enfocada como para
	  que el tiempo de lectura -y el tiempo entre los
	  ejercicios- sea razonable. Esto no sólo mantiene las
	  mentes de la audiencia más activas e involucradas durante
	  un seminario práctico, sino que también ofrece al lector
	  un mayor sentido de realización.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  Dar a los lectores una base sólida de manera que puedan
	  comprender las cuestiones lo suficientemente bien como
	  para cambiar a otros cursos y libros más difíciles (en
	  particular, el Volumen 2 de este libro).
	</para>
      </listitem>

      <listitem>
	<para>
	  He tratado de no utilizar ninguna versión de C++ de
	  ningúna compañía en particular porque, para aprender el
	  lenguaje, no creo que los detalles de una implementación
	  en particular sean tan importantes como el lenguaje
	  mismo. La mayoría de la documentación de las compañías
	  sobre su propia expecificación es adecuada.
	</para>
      </listitem>
    </orderedlist>
  </sect1>

  <sect1>
    <title>Capítulos</title>

    <para>
      C++ es un lenguaje en el que se construyen características
      nuevas y diferentes sobre una sintaxis existente (por esta
      razón, nos referiremos a él como un lenguaje de programación
      orientado a objetos híbrido). Como mucha gente sigue una curva
      de aprendizaje, hemos comenzado a apegarnos por la forma en
      que los programadores atraviesan las etapas de las
      características del lenguaje C++. Como parece ser la
      progresión natural de una mente entrenada modularmente, he
      decidido comprender y seguir el mismo camino y acelerar el
      proceso proponiendo y resolviendo las preguntas que se me
      ocurrieron cuando yo aprendía el lenguaje y también las que se
      me ocurrieron en las audiencias en las que yo enseñaba dicho
      lenguaje.
    </para>

    <para>
      El curso fue diseñado con algo en mente: racionalizar el
      proceso de aprender C++. La reacción de la audiencia me ayudó
      a comprender qué partes eran difíciles y necesitaban una
      iluminación extra. En las áreas en las que me volvía ambicioso
      e incluía demasiadas características de una vez, me di cuenta
      -mediante el proceso de la entrega de material- de que si
      incluyes demasiadas características, tendrás que explicarlas
      todas, y la confusión de los estudiantes se verá fácilmente
      agravada. Como resultado, he tenido muchos problemas para
      introducir las características tan lentamente como ha sido
      posible; sólo un concepto importante a la vez por capítulo.
    </para>

    <para>
      Entones, el objetivo en cada capítulo es enseñar un concepto
      simple, o un pequeño grupo de conceptos asociados, en caso de
      que no haya más conceptos adicionales. De esa forma puede
      digerir cada parte en el contexto de su conocimiento actual
      antes de continuar. Para llevar esto a cabo, dejé algunas
      partes de <acronym>C</acronym> en algún lugar más adelante del
      que preferiría. El beneficio es que no se confunda por ver
      usadas todas las características de C++ antes de que éstas
      sean explicadas, así su introducción al lenguaje será
      tranquila y reflejará la forma en que asimile las
      características que dejo en sus manos.
    </para>

    <para>
      He aquí una breve descripción de los capítulos que contiene
      este libro:
    </para>


    <para>
      <xref linkend="C1"/>: <!-- FIXME: título del capítulo
      1 -->
      Cuando los proyectos se vuelven demasiado grandes y difíciles
      de mantener, nace la <quote>crisis de software</quote>, que es
      cuando los programadores dicen: <quote>¡No podemos terminar
	los proyectos, y cuando podemos, son demasiado
	caros!</quote>. Esto provoca gran cantidad de respuestas, que
      se discuten en este capítulo mediante las ideas de
      programación orientada a objetos (<acronym>POO</acronym>) y
      cómo afecta ésta a resolver la crisis de software. El capítulo
      le hará pasar por las características y conceptos básicos de
      la POO y también introduce el análisis y diseño de
      procesos. Además, aprenderá los beneficios y problemas de
      adaptar el lenguaje, y obtendrá sugerencias para adentrarse en
      el mundo de C++.
    </para>

    <para>
      <xref linkend="C2"/>: 
      Este capítulo explica el proceso
      de construir programas usando compiladores y
      librerías. Presenta el primer programa C++ del libro y muestra
      cómo se construyen y compilan los programas. Después se
      presentan algunas de las librerías de objetos básicas que están
      disponibles en C++ estándar. Para cuando acabe el capítulo,
      dominará lo que se refiere a escribir un programa C++
      utilizando las librerías de objetos incluídas.<!--FIXME-->
    </para>

    <para>
      <xref linkend="C3"/>:
      Este capítulo es una densa vista general de las
      características de C que se utilizan en C++, así como gran
      número de características básicas que sólo están disponibles
      en C++. Además introduce la utilidad <quote>make</quote>, que
      es común en el desarrollo software de todo el mundo y que se
      utiliza para construir todos los ejemplos de este libro (el
      código fuente de este libro, que está disponible en <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>,
      contiene los makefiles correspondientes a cada capítulo). El
      capítulo 3 supone que tiene unos conocimientos básicos sólidos
      en algún lenguaje de programación procedural como Pascal, C, o
      incluso algún tipo de Basic (basta con que haya escrito algo
      de código en ese lenguaje, especialmente funciones). Si
      encuentra este capítulo demasiado difícil, debería ir primero
      por el seminario <quote>Pensar en C</quote> del CD que
      acompaña este libro (y también disponible en <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>).
    </para>

    <para>
      <xref linkend="C4"/>:
      La mayor parte de las características de C++ giran entorno a
      la capacidad de crear nuevos tipos de datos. Esto no sólo
      ofrece una mayor organización del código, sino que es el
      trabajo preliminar para las capacidades de POO más poderosas. Verá
      cómo esta idea se facilita con el simple hecho de poner
      funciones dentro de las estructuras, los detalles de cómo
      hacerlo, y qué tipo de código se escribe. También aprenderá la
      mejor manera de organizar su código mediante archivos de cabecera y
      archivos de implementación.
    </para>

    <para>
      <xref linkend="C5"/>:
      Se puede decidir que algunos de los datos y funciones de su
      estructura no estén disponibles para el usuario del tipo nuevo
      haciéndolas privadas. Esto significa que se puede separar la
      implementación principal de la interfaz que el programador
      cliente ve, y de este modo permitir que la implementación se
      cambie fácilmente sin afectar al código del cliente. La
      palabra clave <literal role="keyword">class</literal> también
      se introduce como una manera más imaginativa de describir un
      tipo de datos nuevo, y el significado de la palabra
      <quote>objeto</quote> se desmistifica (es una variable
      divertida).
    </para>

    <para>
      <xref linkend="C6"/>:
      Uno de los errores más comunes en C se debe a las variables no
      inicializadas. El constructor de C++ permite garantizar que
      las variables de su nuevo tipo de datos (<quote>objetos de su
	clase</quote>) siempre serán inicializados correctamente. Si
      sus objetos también requieren algún tipo de reciclado, usted
      puede garantizar que este reciclado siempre se realizará
      mediante el destructor C++.
    </para>
    
    <para>
      <xref linkend="C7"/>:
      Se desea que C++ le ayude a construir proyectos grandes y
      complejos. Mientras que lo consigue, puede obtener múltiples
      bibliotecas que utilicen el mismo nombre de funciones, y
      también puede decidir utilizar un mismo nombre con diferentes
      significados en la misma biblioteca. C++ lo hace sencillo
      mediante la sobrecarga de funciones, lo que le permite
      reutilizar el mismo nombre de función siempre que la lista de
      argumentos sea diferente. Los argumentos por defecto le
      permiten llamar a la misma función de diferentes maneras
      proporcionando, automáticamente, valores por defecto para
      algunos de sus argumentos.
    </para>

    <para>
      <xref linkend="C8"/>:
      Este capítulo cubre las palabras reservadas <literal
	role="keyword">const</literal> y <literal
	role="keyword">volatile</literal>, que en C++ tienen un
      significado adicional, especialmente dentro de las
      clases. Aprenderá lo que significa aplicar <literal
	role="keyword">const</literal> a una definición de
      punteros. El capítulo también muestra cómo varía el
      significado de <literal role="keyword">const</literal> según
      se utilice dentro o fuera de las clases y cómo crear
      constantes inherentes a las clases en tiempo de compilación.
    </para>
    
    <para>
      <xref linkend="C9"/>:
      Las macros del preprocesador eliminan la llamada a funciones
      superiores, pero el preprocesador también elimina la valiosa
      comprobación de tipos de C++. Las funciones en línea le
      ofrecen todos los beneficios de una macro de preprocesador
      además de los beneficios de una verdadera llamada a función. Este
      capítulo explora minuciosamente la implementación y uso de las
      funciones en línea.
    </para>
    
    <para>
      <xref linkend="C10"/>:
      La elección de nombres es una actividad fundamental en la
      programación y, cuando un proyecto se vuelve grande, el número
      de nombres puede ser arrollador. C++ le permite un gran
      control de los nombres en función de su creación, visibilidad,
      lugar de almacenamiento y enlazado. Este capítulo muestra cómo
      se controlan los nombres en C++ utilizando dos
      técnicas. Primero, la palabra clave <literal
	role="keyword">static</literal> se utiliza para controlar la
      visibilidad y enlazado, y se explora su significado especial
      para clases. Una técnica mucho más util para controlar los
      nombres a nivel global es la capacidad del espacio de nombres
      de C++, que le permite dividir el espacio de nombres global en
      distintas regiones.
    </para>
    
    <para>
      <xref linkend="C11"/>:
      Los punteros de C++ trabajan como los punteros de C con el
      beneficio adicional de la comprobación de tipos más fuerte de
      C++. C++ también proporciona un método adicional para manejar
      direcciones: C++ copia la <emphasis>referencia</emphasis> de
      Algol y Pascal, que permite al compilador manejar la
      manipulación de direcciones mientras se utiliza la notación
      ordinaria. También encontrará el Constructor de Copia, que
      controla la manera en que los objetos se pasan por valor hacia
      o desde las funciones. Finalmente, se ilumina el puntero a
      miembros de C++.
    </para>
    
    <para>
      <xref linkend="C12"/>:
      Esta característica se llama algunas veces <quote>azúcar
	sintáctico</quote>; permite dulcificar la sintaxis de uso de
      su tipo permitiendo operadores así como llamadas a
      funciones. En este capítulo aprenderá que la sobrecarga de
      operadores sólo es un tipo de llamada a función diferente y
      aprenderá cómo escribir los suyos propios, manejando el -a
      veces confuso- uso de los argumentos, devolviendo tipos, y la
      decisión de si hacer un operador miembro o amigo.
    </para>
    
    <para>      
      <xref linkend="C13"/>:
      ¿Cuántos aviones necesitará manejar un sistema de tráfico
      aéreo? ¿Cuántas formas requerirá un sistema CAD? En el
      problema de la programación genérica, no se puede saber la
      cantidad, tiempo de vida o el tipo de los objetos necesitará
      el programa una vez lanzado. En este capítulo, aprenderá cómo
      <literal role="keyword">new</literal> y <literal
	role="keyword">delete</literal> solventan elegantemente este
      problema en C++ creando objetos en el montón. También verá
      cómo <literal role="keyword">new</literal> y <literal
	role="keyword">delete</literal> pueden sobrecargarse de
      variadas maneras de forma que puedan controlar cómo se asigna
      y se recupera el almacenamiento.
    </para>

    <para>
      <xref linkend="C14"/>:
      La abstracción de datos le permite crear tipos nuevos de la
      nada, pero con composición y herencia, se puede crear tipos
      nuevos de los ya existentes. Con la composición, se puede
      ensamblar un tipo nuevo utilizando los otros tipos como
      piezas y, con la herencia, puede crear una versión más
      expecífica de un tipo existente. En este capítulo aprenderá la
      sintaxis, cómo redefinir funciones y la importancia de la
      construcción y destrucción para la herencia y la composición.
    </para>

    <para>
      <xref linkend="C15"/>:
      Por su parte, debería tomarle nueve meses descubrir y
      comprender esta piedra angular de la POO. A través de
      ejercicios pequeños y simples, verá cómo crear una familia de
      tipos con herencia y manipular objetos de esa familia mediante
      su clase base común. La palabra reservada <literal
	role="keyword">virtual</literal> le permite tratar todos los
      objetos de su familia de forma genérica, lo que significa que
      el grueso del código no depende de información de tipo
      específica. Esto hace extensibles sus programas, de manera que
      construir programas y mantener el código sea más sencillo y
      más barato.
    </para>

    <para>
      <xref linkend="C16"/>:
      La herencia y la composición permiten reutilizar el código
      objeto, pero eso no resuelve todas las necesidades de
      reutilización. Las plantillas permiten reutilizar el código
      fuente proporcionando al compilador un medio para sustituir el
      nombre de tipo en el cuerpo de una clase o función. Esto
      sostiene el uso de bibliotecas de clase recipiente, lo que son
      herramientas importantes para el desarrollo rápido y robusto
      de programas orientados a objetos (la Biblioteca Estándar de
      C++ incluye una biblioteca significativa de clases
      recipiente). Este capítulo da una base minuciosa en esta
      materia esencial.
    </para>

    <para>
      Temas adicionales (y materias más avanzadas) están disponibles
      en el Volumen 2 de este libro, que puede ser obtenido del
      sitio web <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>.
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>

    <para>
      He descubierto que los ejercicios son excepcionalmente útiles
      durante un seminario para completar la comprensión de los
      estudiantes, así que encontrará algunos al final de cada
      capítulo. El número de ejercicios ha sido incrementado
      enormemente respecto a la primera edición.
    </para>

    <para>
      Muchos de los ejercicios son suficientemente sencillos como
      para que puedan terminarse en una cantidad de tiempo razonable
      en una clase o apartado de laboratorio mientras el instructor
      observa, asegurándose de que todos los estudiantes absorven el
      material. Algunos ejercicios son un poco más complejos para
      mantener entretenidos a los estudiantes avanzados. El grueso
      de los ejercicios se orienta a ser resueltos en poco tiempo y
      se intenta sólo probar y educar su conocimiento más que
      presentar retos importantes (seguramente los encontrará usted
      mismo -o más probablemente, ellos le encontrarán a usted).
    </para>

    <sect2>
      <title>Soluciones a los ejercicios</title>

      <para>
	Las soluciones a los ejercicios seleccionados pueden
	encontrarse en el documento electrónico <emphasis>El
	  Solucionario de Pensar en C++</emphasis>, disponible por una
	pequeña cantidad en <ulink
	  url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>.
      </para>
    </sect2>
  </sect1>
  
  <sect1>
    <title>Código fuente</title>

    <para>
      El código fuente de este libro está registrado como software
      gratuito, distribuido mediante el sitio Web <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>. El
      registro le impide publicar el código en un medio impreso sin
      permiso, pero se le asegura el derecho de usarlo de muchas
      otras maneras (ver más abajo).
    </para>

    <para>
      El código está disponible en un fichero comprimido, destinado
      a extraerse desde cualquier plataforma que tenga una utilidad
      <quote>zip</quote> (la mayoría lo tienen; puede buscar en
      Internet para encontrar una versión para su platarforma si aún
      no tiene una instalada). En el directorio inicial donde
      desempaquete el código encontrará la siguiente nota de
      registro:
    </para>


<!-- FIXME: no tengo ni idea de cómo poner lo siguiente: -->
<!--
		<para>
		  <citation>
//:! :Copyright.txt
Copyright (c) 2000, Bruce Eckel
Source code file from the book "Thinking in C++"
All rights reserved EXCEPT as allowed by the
following statements: You can freely use this file
for your own work (personal or commercial),
including modifications and distribution in
executable form only. Permission is granted to use
this file in classroom situations, including its
use in presentation materials, as long as the book
"Thinking in C++" is cited as the source. 
Except in classroom situations, you cannot copy
and distribute this code; instead, the sole
distribution point is http://www.BruceEckel.com 
(and official mirror sites) where it is
available for free. You cannot remove this
copyright and notice. You cannot distribute
modified versions of the source code in this
package. You cannot use this file in printed
media without the express permission of the
author. Bruce Eckel makes no representation about
the suitability of this software for any purpose.
It is provided "as is" without express or implied
warranty of any kind, including any implied
warranty of merchantability, fitness for a
particular purpose, or non-infringement. The entire
risk as to the quality and performance of the
software is with you. Bruce Eckel and the
publisher shall not be liable for any damages
suffered by you or any third party as a result of
using or distributing this software. In no event 
will Bruce Eckel or the publisher be liable for 
any lost revenue, profit, or data, or for direct,
indirect, special, consequential, incidental, or
punitive damages, however caused and regardless of
the theory of liability, arising out of the use of
or inability to use software, even if Bruce Eckel
and the publisher have been advised of the
possibility of such damages. Should the software
prove defective, you assume the cost of all
necessary servicing, repair, or correction. If you
think you've found an error, please submit the
correction using the form you will find at
www.BruceEckel.com. (Please use the same
form for non-code errors found in the book.)
///:~
		  </citation>
		</para>		  
-->
<!-- FIXME: bueno, admito ideas. Sigo con lo siguiente -->


    <para>
      Se puede usar el código en proyectos y clases siempre y cuando
      la nota de registro se mantenga.
    </para>
  </sect1>


  <sect1>
    <title>Estándares del lenguaje</title>

    <para>
      Durante todo el libro, cuando se haga referencia al estándar
      de C ISO, generalmente se dirá <quote>C</quote>. Sólo si se
      necesita distinguir entre C estándar y otros más viejos,
      versiones previas al estándar de C, se hará la distinción.
    </para>

    <para>
      Cuando se escribió esto, el Comité de Estándares de C++ ya
      había terminar de trabajar en el lenguaje. De este modo, se
      usará el término C++ estándar para referirse al lenguaje
      estandarizado. Si se hace referencia simplemente a C++,
      debería asumir que se quiere decir <quote>C++
	estándar</quote>.
    </para>

    <para>
      Hay alguna confusión sobre el nombre real del Comité de
      Estándares de C++ y el nombre del estándar mismo. Steve Clamage, el
      presidente del comité, clarificó esto:
    </para>

    <!-- FIXME: no sé si es correcto formatearlo de la siguiente
    manera: -->

    <para>
      <emphasis>Hay dos comités de estandarización de C++: El comité
	NCITS (antiguamente X3) J16 y el comité ISO
	JTC1/SC22/WG14. ANSI alquila NCITS para crear comités técnicos
	para desarrollar estándares nacionales americanos.</emphasis>
    </para>

    <para>
      <emphasis>J16 fue alquilado en 1989 para crear un estándar
	americano para C++. Por el año 1991 se alquiló WG14 para crear
	un estándar internacional. El proyecto J16 se convirtión en un
	proyecto <quote>Tipo I</quote> (Internacional) y se subordinó
	al esfuerzo de estandarización de ISO.</emphasis>
    </para>

    <para>
      <emphasis>Los dos comités se encontraron al mismo tiempo en el
	mismo sitio, y el voto de J16 constituye el voto americano con
	WG14. WG14 delega el trabajo técnico a J16. WG14 vota por el
	trabajo técnico de J16.</emphasis>
    </para>
    
    <para>
      <emphasis>El estándar de C++ fue creado originariamente como
	un estándar ISO. ANSI votó más tarde (como recomendaba J16)
	para adoptar el estándar de C++ ISO como el estándar americano
	para C++.</emphasis>
    </para>

    <para>
      Así, <quote>ISO</quote> es la forma correcta de referirse al
      estándar de C++.
    </para>

    
    <sect2>
      <title>Soporte del lenguaje</title>

      <para>
	Puede que su compilador no disponga de todas las
	características discutidas en este libro, especialmente si
	no tiene la versión más actual del compilador. Implementar un
	lenguaje como C++ es una tarea hercúlea, y puede esperar que
	las características aparecerán poco a poco en lugar de todas
	a la vez. Pero si prueba uno de los ejemplos del libro y
	obtiene un montón de errores del compilador, no es
	necesariamente un error en el código o el compilador;
	simplemente puede no estar implementado aún en su compilador
	particular.
      </para>
    </sect2>
  </sect1>


  <sect1>
    <title>El CD-ROM del libro.</title>

    <para>
      El contenido principal del CD-ROM empaquetado al final de este
      libro es un <quote>seminario en CD-ROM</quote> titulado
      <emphasis>Pensar en C</emphasis>: Fundamentos para Java y C++
      obra de Chuck Allison (publicado por MindView, Inc., y también
      disponible en grandes cantidades en <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>). Esto
      contiene muchas horas de grabaciones y transparencias, que pueden
      mostrarse en la mayoría de las computadoras que disponen de
      lector de CD-ROM y sistema de sonido.
    </para>

    <para>
      El objetivo de <emphasis>Pensar en C</emphasis> es llevarle
      cuidadosamente a través de los fundamentos del lenguaje C. Se
      centra en el conocimiento que necesita para poder cambiar a
      los lenguajes C++ o Java en lugar de intentar hacerle un
      experto en todos los recovecos de C (una de las razones de
      utilizar un lenguaje de alto nivel como C++ o Java es,
      precisamente, que se pueden evitar muchos de esos
      recovecos). También contiene ejercicios y soluciones
      guiadas. Téngalo en cuenta porque el Capítulo <xref linkend="C3"/>
      de este libro va más allá del CD de <emphasis>Pensar en
	C</emphasis>, el CD no es una alternativa a este capítulo,
      sino que debería utilizarse como preparación para este libro.
    </para>

    <para>
      Por favor, advierta que el CD-ROM está basado en navegador, por
      lo que debería tener un navegador Web instalado en su máquina
      antes de utilizarlo.
    </para>

  </sect1>

  
  <sect1>
    <title>CD-ROMs, seminarios, y consultas</title>

    <para>
      Hay seminarios en CD-ROM planeados para cubrir el Volumen 1 y
      el Volumen 2 de este libro.  Éstos comprenden muchas horas de
      grabaciones mías que acompañan las transparencias que cubren
      el material seleccionado de cada capítulo del libro. Pueden
      verse en la mayoría de las computadoras que disponen de lector
      de CDROM y sistema de sonido. Estos CDs pueden comprarse en
      <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>,
      donde encontrará más información y lecturas de ejemplo.
    </para>


    <!-- FIXME: en el siguiente párrafo aparece la expresión "code
    walkthrows" que no sé traducir. -->
    <para>
      Mi compañía, MindView, Inc., proporciona seminarios de
      preparación práctica públicos basados en el material de este
      libro y también en temas avanzados. El material seleccionado
      de cada capítulo representa una lección, que se continúa con
      un periodo de ejercicios monitorizados para que cada
      estudiante reciba atención personal. También propocionamos
      preparación <quote>in situ</quote>, consultoría, tutorización,
      y diseño y (FIXME:code walkthrows). Puede encontrar la información y los
      formularios para los próximos seminarios, así como otra
      información de contacto, en <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>.
    </para>

    <para>
      A veces me encuentro disponible para consultas de diseño,
      evaluación de procesos y (FIXME:code walkthrows). Cuando
      comencé a escribir sobre computadoras, mi motivación principal
      fue incrementar mis actividades de consultoría, porque
      encontraba que la consultoría era competitiva, educacional, y
      una de mis experiencias profesionales más valiosas. Así haré
      todo loq ue pueda para incluirle a usted en mi agenda, o para
      proporcionarle uno de mis socios (que son gente que conozco
      bien y con la que he tratado, y a menudo gente que
      co-desarrollan e imparten seminarios conmigo).
    </para>
  </sect1>

  
  <sect1>
    <title>Errores</title>

    <para>
      No importa cuántos trucos emplee un escritor para detectar los
      errores, algunos siempre se escapan y saltan del papel al
      lector atento. Si encuentra algo que crea que es un error, por
      favor, utilice el formulario de correcciones que encontrará al
      en <ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>. Se
      agradece su ayuda.
    </para>
  </sect1>


  <sect1>
    <title>Sobre la portada.</title>

    <para>
      La primera edición de este libro tenía mi cara en la portada,
      pero para la segunda edición yo quería desde el principio una
      portada que se pareciera más una obra de arte, como la portada
      de <emphasis>Pensar en Java</emphasis>. Por alguna razón, C++
      parece sugerirme Art Decó con sus curvas simples y pinceladas
      cromadas. Tengo en mente algo como esos carteles de barcos y
      aviones con cuerpos dulcemente largos.
    </para>
    
    <para>
      Mi amigo Daniel Will-Harris, (<ulink
	url="http://www.Will-Harris.com">www.Will-Harris.com</ulink>)
      a quien conocí en las clases del coro del instituto, iba a
      llegar a ser un diseñador y escritor de talla mundial. Él ha
      hecho prácticamente todos mis diseños, incluída la portada para
      la primera edición de este libro. Durante el proceso de diseño
      de la portada, Daniel, insatisfecho con el progreso que
      realizábamos, siempre preguntaba: <quote>¿Cómo hace esto para
	relacionar a la gente con las
	computadoras?</quote>". Estábamos atascados.
    </para>

    <para>
      Como capricho, sin nada en mente, me pidió que pusiera mi cara
      en el escáner. Daniel tenía uno de sus programas gráficos
      (Corel Xara, su favorito) que <quote>autotrazó</quote> mi
      cara escaneada. Él lo describe de la siguente manera:
      <quote>El autotrazado es la manera de la computadora para
	transformar un dibujo en los tipos de líneas y curvas que
	realmente le gustan</quote>. Entonces jugó con ello hasta
      que obtuvo algo que parecía como un mapa topográfico de mi
      cara, una imagen que podría ser la manera en que una
      computadora ve a la gente.
    </para>

    <para>
      Tomé esta imagen y la fotocopié en papel de acuarela (algunas
      copiadoras pueden manejar paquetes gruesos), y entonces
      comenzó a realizar montones de experimentos añadiendo acuarela
      a la imagen. Seleccionamos las que nos gustaban más, entonces
      Daniel las volvió a escanear y las organizó en la portada,
      añadiendo el texto y otros elementos de diseño. El proceso
      total requirió varios meses, mayormente a causa del tiempo que
      me tomó hacer las acuarelas. Pero me he divertido
      especialmente con ello porque conseguí participar en el arte
      de la portada, y porque me dio un incentivo para hacer más
      acuarelas (lo que dicen sobre la práctica realmente es
      cierto).
    </para>

  </sect1>

  <sect1>
    <title>Diseño del libro y producción</title>

    <para>
      El diseño del interior del libro fue creado por Daniel
      Will-Harris, que solía jugar con letras (FIXME:rub-on) en el
      instituto mientras esperaba la invención de las computadoras y
      los entornos de publicación. De todos modos, yo mismo produje
      las páginas de fotos (FIXME:camera-ready), por lo que los
      errores tipográficos son míos. Se utilizó Microsoft(c) Word para Windows
      Versiones 8 y 9 para escribir el libro y crear las
      páginas (FIXME:camera-ready), incluyendo la generación de la tabla
      de contenidos y el índice (creé un servidor automatizado COM
      en Python, llamado desde las macros VBA de Word, para ayudarme
      en el marcado de los índices). Python (ver <ulink
	url="http://www.BruceEckel.com">www.python.com</ulink>) se
      utilizó para crear algunas de las herramientas para comprobar
      el código, y se habría utilizado como herramienta de
      extracción de código si lo hubiera descubierto antes.
    </para>

    <para>
      ¡¡Creé los diagramas utilizando Visio (c). Gracias a Visio
      Corporation por crear una herramienta tan útil.
    </para>

    <para>
      El tipo de letra del cuerpo es Georgia y los títulos utilizan
      Verdana. La versión (FIXME:camera-ready) definitiva se creó
      con Adobe(c) Acrobat 4 y el
      fichero generado se llevó directamente a la imprenta - muchas
      gracias a Adobe por crear una herramienta que permite enviar
      documentos (FIMXE:camera-ready) por correo electrónico, así
      como permitir que se realicen múltiples revisiones en un único
      día en lugar de recaer sobre mi impresora láser y servicios
      rápidos 24 horas (probamos el proceso Acrobat por primera vez
      con <emphasis>Pensar en Java</emphasis>, y fui capaz de subir
      la versión final de ese libro a la imprenta de U.S. desde Sur
      África).
    </para>

    <para>
      La versión HTML se creó exportando el documento Word a RTF, y
      utilizando entonces RTF2HTML (ver <ulink
	url="http://www.sunpack.com/RTF/">http://www.sunpack.com/RTF/</ulink>)
      para hacer la mayor parte del trabajo de la conversión HTML
      (gracias a Chris Hector por hacer una herramienta tan util y
      especialmente fiable). Los ficheros resultantes se limpiaron
      utilizando un programa Python que truqué, y los WMFs se
      transformaron en GIFs utilizando el PaintShop Pro 6 de
      JASC(c) y su herramienta de conversión por
      lotes (gracias a JASC por resolver tantos de mis problemas con
      su excelente producto). El realce del color de la sintaxis se
      añadió con un script Perl amablemente cedido por Zafir Anjum.
    </para>
  </sect1>



  <sect1>
    <title>Agradecimientos</title>

    <para>
      Lo primero, agradecer a todo aquel que presentó correcciones y
      sugerencias desde Internet; han sido de tremenda ayuda para
      mejorar la calidad de este libro, y no podría haberlo hecho
      sin ustedes. Gracias en especial a John Cook.
    </para>

    <para>
      Las ideas y compensión de este libro han llegado de varias
      fuentes: amigos como Chuck Allison, Andrea Provaglio, Dans
      Sakx, Scott Meyers, Charles Petzold y Michael Wilk; pioneros
      del lenguaje como Bjarne Stroustrup, Andrew Koenig y Rob
      Murray; miembros del Comité de Estándares de C++ como Nathan
      Myers (que fue de particular ayuda y generosidad con sus
      percepciones), Bill Plauger, Reg Charney, Tom Penello, Tom
      Plum, Sam Druker y Uwe Steinmueller; gente que ha hablado de
      mi camino en C++ en la Conferencia de Desarrollo de Software;
      y a menudo estudiantes de mis seminarios, que preguntan
      aquello que necesito oír para aclarar el material.
    </para>

    <para>
      Enormes agradecimientos para mi amigo Gen Kiyooka, cuya
      compañía Digigami me proporcionó un servidor web.
    </para>

    <para>
      Mi amigo Richard Hale Shaw y yo hemos enseñado C++ juntos; las
      percepciones de Richard y su apoyo han sido muy útiles (y las
      de Kim también). Gracias también a DoAnn Vikoren, Eric Faurot,
      Jennifer Jessup, Tara Arrowood, Marco Pardi, Nicole Freeman,
      Barbara Hanscome, Regina Ridley, Alex Dunne y el resto del
      reparto y plantilla de MFI.
    </para>
    
    <para>
      Unos agradecimientos especiales para todos mis profesores y
      todos mis estudiantes (que son profesores míos también).
    </para>

    <para>
      Y para mis escritores favoritos, mi profunda apreciación y
      simpatía por vuestros esfuerzos: John Irving, Neal Stephenson,
      Robertson Davies (te echaremos de menos), Tom Robbins, William
      Gibson, Richard Bach, Carlos Castaneda y Gene Wolfe.
    </para>

    <para>
      A Guido van Rossum, por inventar Python y donarlo desinteresadamente
      al mundo. Has enriquecido mi vida con tu contribución.
    </para>

    <para>
      Gracias a la gente de Prentice Hall: Alan Apt, Ana Terry,
      Scott Disanno, Toni Holm y mi editora de copias electrónicas
      Stephanie English. En márqueting, Bryan Gambrel y Jennie
      Burger.
    </para>

    <para>
      Sonda Donovan me ayudó con la producción del CD Rom. Daniel
      Will-Harris (de acuerdo) creó el diseño de la portada
      (FIXME:silkscreen) que se encuentra en el propio CD.
    </para>

    <para>
      Para todos los grandes amigos de Crested Butte, gracias por
      hacer de él un lugar mágico, especialmente Al Smith (creador
      del maravilloso Camp4 Coffee Garden), mis vecinos Dave y
      Erika, Marsha de la librería Heg's Place, Pat y John de
      Teocalli Temale, Sam de Barkery Café, y a Tiller por su ayuda
      con la investigación en audio. Y a toda la gente terrorífica
      que cuelga de Camp4 y hace interesantes mis mañanas.
    </para>


    <!-- FIXME: "ALMQUISTS" --> "alquimistas" ?? -->
    <para>
      La plantilla de apoyo de amigos incluye, pero no está limitada
      a, Zack Urlocker, Andrew Binstock, Neil Rubenking, Kraig
      Brocschmidt, Steve Sinofsky, JD Hildebrandt, Brian McElhinney,
      Brinkey Barr, Larry O'Brien, Bill Gates en Midnight
      Engineering Magazine, Larry Constantine, Lucy Lockwood, Tom
      Keffer, Dan Putterman, Gene Wang, Dave Mayer, David
      Intersimone, Claire Sawyers, los Italianos (Andrea Provaglio,
      Rossella Gioia, Laura Fallai, Marco &amp; Lella Cantu, Corrado,
      Ilsa y Christina Giustozzi), Chris y laura Strand (y Parker),
      los Alquimistas(FIXME:almquists), Brad Jerbic, Marilyn Cvitanic, el
      Mabrys, el Halflingers, los Pollocks, Peter Vinci, los
      Robbins, los Moelters, Dave Stoner, Laurie Adams, los
      Cranstons, Larry Fogg, Mike y karen Sequeira, Gary Entsminger
      y Allison Brody, Kevin, Sonda &amp; Ella Donovan, Chester y
      Shannon Andersen, Joe Lordi, Dave y Brenda Barlett, los
      Rentschlers, Lynn y Todd y sus familias. Y por supuesto, a Mamá
      y Papá.
    </para>

  </sect1>
</preface>
