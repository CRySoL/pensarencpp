<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML  
  Traducción original: Jesús López Mollo <i302154@correo.unnet.es>
                       (anterior a LuCaS)

  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:         Miguel Ángel García Martínez
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C2">
  
  <title>Construir y usar objetos</title>
  

  <!--
  This chapter will introduce enough C++ syntax and program construction
  concepts to allow you to write and run some simple object-oriented
  programs. In the subsequent chapter we will cover the basic syntax of C
  and C++ in detail.
  -->

  <highlights>
    <para>
      Este capítulo presenta la suficiente sintaxis y
      los conceptos de construcción de programas de C++ como para
      permitirle crear y ejecutar algunos programas simples orientados a
      objetos. El siguiente capítulo cubre la sintaxis
      básica de C y C++ en detalle.  
</para>
</highlights>


  <!--
  By reading this chapter first, you??ll get the basic flavor of what it
  is like to program with objects in C++, and you??ll also discover some
  of the reasons for the enthusiasm surrounding this language. This should
  be enough to carry you through Chapter 3, which can be a bit exhausting
  since it contains most of the details of the C language.
  -->
  <para>
    Leyendo primero este capítulo, le cogerá el gustillo a lo que
    supone programar con objetos en C++, y también descubrirá
    algunas de las razones por las que hay tanto entusiasmo
    alrededor de este lenguaje. Debería ser suficiente para
    pasar al <link linkend="C03">Capítulo 3</link>, que puede ser un poco
    agotador debido a que contiene la mayoría de los detalles del
    lenguaje C.
  </para>
  
  <!-- 
  The user-defined data type, or class, is what distinguishes C++
  from traditional procedural languages. A class is a new data type
  that you or someone else creates to solve a particular kind of
  problem. Once a class is created, anyone can use it without knowing
  the specifics of how it works, or even how classes are built. This
  chapter treats classes as if they are just another built-in data
  type available for use in programs. 
  -->

  <para>
    Los tipos de datos definidos por el usuario, o
    <emphasis>clases</emphasis> es lo que diferencia a C++ de los
    lenguajes procedimentales tradicionales.  Una clase es un nuevo tipo
    de datos que usted o alguna otra persona crea para resolver un
    problema particular. Una vez que se ha creado una clase, cualquiera
    puede utilizarla sin conocer los detalles de su funcionamiento, o
    incluso de la forma en que se han construído.  Este capítulo trata
    las clases como si sólo fueran otro tipo de datos predefinido
    disponible para su uso en programas.
  </para>


  <!-- 
  Classes that someone else has created are typically packaged
  into a library. This chapter uses several of the class libraries
  that come with all C++ implementations. An especially important
  standard library is iostreams, which (among other things) allow you
  to read from files and the keyboard, and to write to files and the
  display. You'll also see the very handy string class, and the
  vector container from the Standard C++ Library. By the end of the
  chapter, you'll see how easy it is to use a pre-defined library
  of classes.
  -->
  <para>
    Las clases creadas por terceras personas se suelen empaquetar en
    librerías.  Este capítulo usa algunas de las librerías que vienen en
    todas las implementaciones de C++. Una librería especialmente
    importante es FIXME:iostreams, que le permite (entre otras cosas)
    leer desde ficheros o teclado, y escribir a ficheros o
    pantalla. También verá la clase <classname>string</classname>, que
    es muy práctica, y el contenedor <classname>vector</classname> de la
    Libreria Estándar de C++. Al final del capítulo, verá lo sencillo
    que resulta utilizar una librería de clases predefinida.
  </para>

  <!--
  In order to create your first program you must understand the tools used
  to build applications.
  -->
  <para>
    Para que pueda crear su primer programa debe conocer primero las
    herramientas utilizadas para construir aplicaciones.
  </para>


  <sect1>
    <!-- The process of language translation -->
    <title>El proceso de traducción del lenguaje</title> 

    <!--
    All computer languages are translated from something that tends to be
    easy for a human to understand (source code) into something that is
    executed on a computer (machine instructions). Traditionally,
    translators fall into two classes: interpreters and compilers.
    -->
    <para>
      Todos los lenguajes de programación se traducen de algo que
      suele ser fácilmente entendible por una persona
      (<emphasis>código fuente</emphasis>) a algo que es ejecutado
      por una computadora (<emphasis>código máquina</emphasis>). Los
      traductores se dividen tradicionalmente en dos
      categorías: <emphasis>intérpretes</emphasis> y
      <emphasis>compiladores</emphasis>.
    </para>
    
    <sect2>
      <!-- Interpreters -->
      <title>Intérpretes</title>

      <!--
      An interpreter translates source code into activities (which may
      comprise groups of machine instructions) and immediately executes those
      activities. BASIC, for example, has been a popular interpreted
      language. Traditional BASIC interpreters translate and execute one line
      at a time, and then forget that the line has been translated. This makes
      them slow, since they must re-translate any repeated code. BASIC has
      also been compiled, for speed. More modern interpreters, such as those
      for the Python language, translate the entire program into an
      intermediate language that is then executed by a much faster
      interpreter[25].
      -->
      <para>
	Un intérprete traduce el código fuente en actividades (las
	cuales pueden comprender grupos de instrucciones máquina) y
	ejecuta inmediatamente estas actividades.  El BASIC, por
	ejemplo, fue un lenguaje interpretado bastante popular. Los
	intérpretes de BASIC tradicionales traducen y ejecutan una línea
	cada vez, y después olvidan la línea traducida. Esto los hace
	lentos debido a que deben volver a traducir cualquier código que
	se repita. BASIC también ha sido compilado para ganar en
	velocidad. La mayoría de los intérpretes modernos, como los de
	Python, traducen el programa entero en un lenguaje intermedio
	que es ejecutable por un intérprete mucho más
	rápido<footnote>

    <!--
    [25] The boundary between compilers and interpreters can tend to become
    a bit fuzzy, especially with Python, which has many of the features and
    power of a compiled language but the quick turnaround of an interpreted
    language.
    -->
	  <para>
	    Los límites entre los compiladores y los intérpretes tienden
	    a ser difusos, especialmente con Python, que tiene muchas de
	    las caractéristicas y el poder de un lenguaje compilado pero
	    también tiene parte de las ventajas de los lenguajes
	    interpretados.
	  </para>
	</footnote>.
      </para>

      <!--
      Interpreters have many advantages. The transition from writing code to
      executing code is almost immediate, and the source code is always
      available so the interpreter can be much more specific when an error
      occurs. The benefits often cited for interpreters are ease of
      interaction and rapid development (but not necessarily execution) of
      programs.
      -->
      <para>
	Los intérpretes tienen muchas ventajas. La transición del
	código escrito al código ejecutable es casi inmediata, y el
	código fuente está siempre disponible, por lo que el intérprete
	puede ser mucho más específico cuando ocurre un error. Los
	beneficios que se suelen mencionar de los intérpretes es la
	facilidad de interacción y el rápido desarrollo (pero no
	necesariamente ejecución) de los programas.
      </para>

      <!--
      Interpreted languages often have severe limitations when building large
      projects (Python seems to be an exception to this). The interpreter (or
      a reduced version) must always be in memory to execute the code, and
      even the fastest interpreter may introduce unacceptable speed
      restrictions. Most interpreters require that the complete source code be
      brought into the interpreter all at once. Not only does this introduce a
      space limitation, it can also cause more difficult bugs if the language
      doesn??t provide facilities to localize the effect of different pieces
      of code.
      -->
      <para>
	Los lenguajes interpretados a menudo tienen severas limitaciones
	cuando se construyen grandes proyectos (Python parece ser una
	excepción). El intérprete (o una versión reducida) debe estar
	siempre en memoria para ejecutar el código e incluso el
	intérprete más rápido puede introducir restricciones de
	velocidad inaceptables. La mayoría de los intérpretes requieren
	que todo el código fuente se les envíe de una sola vez. Esto no
	sólo introduce limitaciones de espacio, sino que puede causar
	errores difíciles de detectar si el lenguaje no incluye
	facilidades para localizar el efecto de las diferentes porciones
	de código.
      </para>
    </sect2>

    <sect2>
      <!-- Compilers -->
      <title>Compiladores</title>

      <!--
      A compiler translates source code directly into assembly language or
      machine instructions. The eventual end product is a file or files
      containing machine code. This is an involved process, and usually takes
      several steps. The transition from writing code to executing code is
      significantly longer with a compiler.
      -->
      <para>
	Un compilador traduce el código fuente directamente a
	lenguaje ensamblador o instrucciones máquina. El producto final
	suele ser uno o varios ficheros que contienen código
	máquina. La forma de realizarlo suele ser un proceso que
	consta de varios pasos. La transición del código escrito al
	código ejecutable es significativamente más larga con un
	compilador.
      </para>

      <!--
      Depending on the acumen of the compiler writer, programs generated
      by a compiler tend to require much less space to run, and they run
      much more quickly. Although size and speed are probably the most
      often cited reasons for using a compiler, in many situations they
      aren't the most important reasons. Some languages (such as C) are
      designed to allow pieces of a program to be compiled
      independently. These pieces are eventually combined into a final
      executable program by a tool called the linker. This process is
      called separate compilation
      -->

      <para>
        Dependiendo de la perspicacia del escritor del compilador, los
        programas generados por un compilador tienden a requerir mucho
        menos espacio para ser ejecutados, y se ejecutan mucho más
        rápido. Aunque el tamaño y la velocidad son probablemente las
        razones más citadas para usar un compilador, en muchas
        situaciones no son las más importantes. Algunos lenguajes (como
        el C) están diseñados para admitir trozos de programas
        compilados independientemente. Estas partes terminan combinando
        en un programa <emphasis>ejecutable</emphasis> final mediante
        una herramienta llamada <emphasis>enlazador</emphasis>
        (<foreignphrase>linker</foreignphrase>). Este proceso se
        conoce como <emphasis>compilación separada</emphasis>.
      </para>

      <!--
      Separate compilation has many benefits. A program that, taken all at
      once, would exceed the limits of the compiler or the compiling
      environment can be compiled in pieces. Programs can be built and tested
      one piece at a time. Once a piece is working, it can be saved and
      treated as a building block. Collections of tested and working pieces
      can be combined into libraries for use by other programmers. As each
      piece is created, the complexity of the other pieces is hidden. All
      these features support the creation of large programs[26].
      -->

      <para>
	La compilación separada tiene muchos beneficios. Un programa
	que, tomado de una vez, excedería los límites del compilador o
	del entorno de compilación puede ser compilado por piezas. Los
	programas se pueden ser construir y probar pieza a pieza.  Una
	vez que una parte funciona, se puede guardar y tratarse como un
	bloque. Los conjuntos de piezas ya funcionales y probadas se
	pueden combinar en <emphasis>librerías</emphasis> para que otros
	programadores puedan usarlos. Como se crean piezas, la
	complejidad de las otras piezas se mantiene oculta.  Todas estas
	características ayudan a la creación de programas grandes,
	<footnote>
	  <!--
	  [26] Python is again an exception, since it also provides
	  separate compilation.
	  -->
	  <para>
	    Python vuelve a ser una excepción, debido a que permite
	    compilación separada.
	  </para>
	</footnote>.
      </para>


      <!--
      Compiler debugging features have improved significantly over time. Early
      compilers only generated machine code, and the programmer inserted print
      statements to see what was going on. This is not always
      effective. Modern compilers can insert information about the source code
      into the executable program. This information is used by powerful
      source-level debuggers to show exactly what is happening in a program by
      tracing its progress through the source code.
      -->
      <para>
	Las características de depuración del compilador han mejorado
	considerablemente con el tiempo. Los primeros compiladores
	simplemente generaban código máquina, y el programador insertaba
	sentencias de impresión para ver qué estaba ocurriendo, lo que
	no siempre era efectivo. Los compiladores modernos pueden
	insertar información sobre el código fuente en el programa
	ejecutable. Esta información se usa por poderosos
	<emphasis>depuradores a nivel de código</emphasis> que muestran
	exactamente lo que pasa en un programa rastreando su progreso
	mediante su código fuente.
      </para>

      <!--
      Some compilers tackle the compilation-speed problem by performing
      in-memory compilation. Most compilers work with files, reading and
      writing them in each step of the compilation process. In-memory
      compilers keep the compiler program in RAM. For small programs, this can
      seem as responsive as an interpreter.
      -->
      <para>
	Algunos compiladores solucionan el problema de la velocidad
	de compilación mediante <emphasis>compilación en
	  memoria</emphasis>. La mayoría de los compiladores trabajan
	con ficheros, leyéndolos y escribiéndolos en cada paso de
	los procesos de compilación. En la compilación en memoria el
	compilador se mantiene en RAM. Para programas pequeños,
	puede parecerse a un intérprete.
      </para>
    </sect2>
    
    <sect2>
      <title>El proceso de compilación</title>

      <!--
      To program in C and C++, you need to understand the steps and tools in
      the compilation process. Some languages (C and C++, in particular) start
      compilation by running a preprocessor on the source code. The
      preprocessor is a simple program that replaces patterns in the source
      code with other patterns the programmer has defined (using preprocessor
      directives). Preprocessor directives are used to save typing and to
      increase the readability of the code. (Later in the book, you??ll learn
      how the design of C++ is meant to discourage much of the use of the
      preprocessor, since it can cause subtle bugs.) The pre-processed code is
      often written to an intermediate file.
      -->
      <para>
	Para programar en C y en C++, es necesario entender los
	pasos y las herramientas del proceso de compilación. Algunos
	lenguajes (C y C++, en particular) empiezan la compilación
	ejecutando un <emphasis>preprocesador</emphasis> sobre el código
	fuente. El preprocesador es un programa simple que sustituye
	patrones que se encuentran en el código fuente con otros que
	ha definido el programador (usando las <emphasis>directivas
	  de preprocesado</emphasis>). Las directivas de
	preprocesado se utilizan para ahorrar escritura y para aumentar
	la legilibilidad del código (posteriormente en este libro,
	aprenderá cómo el diseño de C++ desaconseja en gran medida el uso
	del preprocesador, ya que puede causar errores sutiles). El
	código preprocesado se suele escribir en un fichero
	intermedio.
      </para>

      <!--
      Compilers usually do their work in two passes. The first pass parses the
      pre-processed code. The compiler breaks the source code into small units
      and organizes it into a structure called a tree. In the expression ??A +
      B?? the elements ??A??, ??+,?? and ??B?? are leaves on the parse tree.
      -->
      <para>
	Normalmente, los compiladores hacen su trabajo en dos
	pasadas. La primera pasada consiste en analizar sintácticamente
	el código generado por el preprocesador. El compilador trocea
	el código fuente en pequeñas partes y lo organiza en una
	estructura llamada <emphasis>árbol</emphasis>. En la
	expresión FIXME:<quote>A+B</quote>, los elementos
	<quote>A</quote>, <quote>+</quote>, <quote>B</quote> son
	hojas del árbol.
      </para>
    <!-- FIXME: en el párrafo anterior, las comillas de A+B son dobles
    y las de cada elemento por separado son simples. Además, todas van
    en negrita.
    -->

      <!--
      A global optimizer is sometimes used between the first and second passes
      to produce smaller, faster code.
      -->
      <para>
	A menudo se utiliza un <emphasis>optimizador global</emphasis>
	entre el primer y el segundo paso para producir código más
	pequeño y rápido.
      </para>

      <!--
      In the second pass, the code generator walks through the parse tree and
      generates either assembly language code or machine code for the nodes of
      the tree. If the code generator creates assembly code, the assembler
      must then be run. The end result in both cases is an object module (a
      file that typically has an extension of .o or .obj). A peephole
      optimizer is sometimes used in the second pass to look for pieces of
      code containing redundant assembly-language statements.
      -->
      <para>
	En la segunda pasada, el <emphasis>generador de código</emphasis>
	  recorre el árbol sintáctico y genera lenguaje ensamblador o
	  código máquina para los nodos del árbol. Si el generador de
	  código crea lenguaje ensamblador, entonces se debe ejecutar el
	  programa ensamblador. El resultado final en ambos casos es un
	  módulo objeto (un fichero que típicamente tiene una extensión
	  de <filename>.o</filename> o <filename>.obj</filename>. A
	  veces se utiliza un <emphasis>optimizador de
	  mirilla</emphasis> en esta segunda pasada para buscar trozos de
	  código que contengan sentencias redundantes de lenguaje
	  ensamblador.
      </para>

      <!--
      The use of the word ??object?? to describe chunks of machine code is an
      unfortunate artifact. The word came into use before object-oriented
      programming was in general use. ??Object?? is used in the same sense as
      ??goal?? when discussing compilation, while in object-oriented
      programming it means ??a thing with boundaries.??
      -->
      <para>
	Usar la palabra <quote>objeto</quote> para describir pedazos de
	código máquina es un hecho desafortunado. La palabra comenzó a
	usarse antes de que la programación orientada a objetos tuviera
	un uso generalizado. <quote>Objeto</quote> significa lo mismo
	que <quote>FIXME:meta</quote> en este contexto, mientras que en la
	programación orientada a objetos significa <quote>una cosa con
	límites</quote>.
      </para>

      <!--
      The linker combines a list of object modules into an executable program
      that can be loaded and run by the operating system. When a function in
      one object module makes a reference to a function or variable in another
      object module, the linker resolves these references; it makes sure that
      all the external functions and data you claimed existed during
      compilation do exist. The linker also adds a special object module to
      perform start-up activities.
      -->
      <para>
	El <emphasis>enlazador</emphasis> combina una lista de módulos
	objeto en un programa ejecutable que el sistema operativo puede
	cargar y ejecutar. Cuando una función en un módulo objeto hace
	una referencia a una función o variable en otro módulo objeto,
	el enlazador resuelve estas referencias; se asegura de que todas
	las funciones y los datos externos solicitados durante el
	proceso de compilación existen realmente. Además, el enlazador
	añade un módulo objeto especial para realizar las actividades de
	inicialización.
      </para>


      <!--
      The linker can search through special files called libraries in order to
      resolve all its references. A library contains a collection of object
      modules in a single file. A library is created and maintained by a
      program called a FIXME:librarian.
      -->
      <para>
	El enlazador puede buscar en unos archivos especiales llamados
	<emphasis>librerías</emphasis> para resolver todas sus
	referencias. Una librería contiene una colección de módulos
	objeto en un único fichero. Una librería se crea y mantiene por
	un programa conocido como <emphasis>bibliotecario</emphasis>
	(<foreignphrase>librarian</foreignphrase>).
      </para>

      <sect3>
        <!-- Static type checking -->
	<title>Comprobación estática de tipos</title>

        <!--
        The compiler performs type checking during the first pass. Type checking
        tests for the proper use of arguments in functions and prevents many
        kinds of programming errors. Since type checking occurs during
        compilation instead of when the program is running, it is called static
        type checking.
        -->
	<para>
	  El compilador realiza una <emphasis>comprobación de
	  tipos</emphasis> durante la primera pasada. La comprobación de
	  tipos asegura el correcto uso de los argumentos en las
	  funciones y previene muchos tipos de errores de
	  programación. Como esta comprobación de tipos ocurre se hace
	  la compilación y no cuando el programa se está ejecutado, se
	  conoce como <emphasis>comprobación estática de
	  tipos</emphasis>.
	</para>

        <!--
        Some object-oriented languages (notably Java) perform some type checking
        at runtime (dynamic type checking). If combined with static type
        checking, dynamic type checking is more powerful than static type
        checking alone. However, it also adds overhead to program execution.
        -->
	<para>
	  Algunos lenguajes orientados a objetos (Java por ejemplo)
	  realizan comprobaciones en tiempo de ejecución
	  (<emphasis>comprobación dinámica de tipos</emphasis>). Si se
	  combina con la estática, la comprobación dinámica es más
	  potente que sólo la estática. Sin embargo, añade una
	  sobrecarga a la ejecución del programa.
	</para>

        <!--
        C++ uses static type checking because the language cannot assume any
        particular runtime support for bad operations. Static type checking
        notifies the programmer about misuses of types during compilation, and
        thus maximizes execution speed. As you learn C++, you will see that most
        of the language design decisions favor the same kind of high-speed,
        production-oriented programming the C language is famous for.
        -->
	<para>
	  C++ usa la comprobación estática de tipos debido a que el
	  lenguaje no puede asumir ningún soporte particular durante la
	  ejecución. La comprobación estática de tipos notifica al
	  programador malos usos de los tipos durante la compilación, y
	  así maximiza la velocidad de ejecución. A medida que aprenda
	  C++, comprobará que la mayoría de las decisiones de diseño del
	  lenguaje están tomadas en favor de la mejora del rendimiento,
	  motivo por el cual C es famoso en la programación orientada a
	  la producción.
	</para>

        <!--
        You can disable static type checking in C++. You can also do your own
        dynamic type checking ? you just need to write the code.
        -->
	<para>
	  Se puede deshabilitar la comprobación estática de tipos en
	  C++, e incluso permite al programador usar su propia
	  comprobación dinámica de tipos - simplemente necesita escribir
	  el código.
	</para>
      </sect3>
    </sect2>
  </sect1>
  
  <sect1>
    <!-- Tools for separate compilation -->
    <title>Herramientas para compilación modular</title>

    <!--
    Separate compilation is particularly important when building large
    projects. In C and C++, a program can be created in small, manageable,
    independently tested pieces. The most fundamental tool for breaking a
    program up into pieces is the ability to create named subroutines or
    subprograms. In C and C++, a subprogram is called a function, and
    functions are the pieces of code that can be placed in different files,
    enabling separate compilation. Put another way, the function is the
    atomic unit of code, since you cannot have part of a function in one
    file and another part in a different file; the entire function must be
    placed in a single file (although files can and do contain more than one
    function).
    -->
    <para>
      La compilación modular es particularmente importante cuando se
      construyen grandes proyectos. En C y en C++, un programa se puede
      crear en pequeñas piezas, manejables y comprobables de forma
      independiente. La herramienta más importante para dividir un
      programa en piezas más pequeñas es la capacidad de crear
      subrutinas o subprogramas que tengan un nombre que las
      identifique. En C y en C++, estos subprogramas se llamana
      <emphasis>funciones</emphasis>, que son las piezas de código que
      se pueden almacenar en diferentes ficheros, permitiendo la
      compilación separada. Dicho de otra forma, una función es la
      unidad atómica de código, debido a que no se puede tener una parte
      de una función en un fichero y el resto en otro (aunque los
      ficheros pueden contener más de una función).
    </para>

    <!--
    When you call a function, you typically pass it some arguments, which
    are values you??d like the function to work with during its
    execution. When the function is finished, you typically get back a
    return value, a value that the function hands back to you as a
    result. It??s also possible to write functions that take no arguments
    and return no values.
    -->
    <para>
      Cuando se invoca una función, se le suelen pasar una serie de
      <emphasis>argumentos</emphasis>, que son valores que desea que la
      función utilice durante su ejecución. Cuando la función termina,
      normalmente devuelve un <emphasis>valor de retorno</emphasis>,
      que equivale al resultado. También es posible crear funciones que
      no tengan ni argumentos ni valor de retorno.
    </para>

    <!--
    To create a program with multiple files, functions in one file must
    access functions and data in other files. When compiling a file, the C
    or C++ compiler must know about the functions and data in the other
    files, in particular their names and proper usage. The compiler ensures
    that functions and data are used correctly. This process of ??telling
    the compiler?? the names of external functions and data and what they
    should look like is called declaration. Once you declare a function or
    variable, the compiler knows how to check to make sure it is used
    properly.
    -->
    <para>
      Para crear un programa con múltiples ficheros, las funciones de un
      fichero deben acceder a las funciones y los datos de otros
      ficheros. Cuando se compila un fichero, el compilador de C o C++
      debe conocer las funciones y los datos de los otros ficheros, en
      particular sus nombres y su uso apropiado. El compilador asegura
      que las funciones y los datos son usados correctamente. El proceso
      de "decirle al compilador" los nombres de las funciones externas y
      los datos que necesitan es conocido como
      <emphasis>declaración</emphasis>.  Una vez declarada una función o
      una variable, el compilador sabe cómo comprobar que la función se
      utiliza adecuadamente.
    </para>


    <sect2>
      <!-- Declarations vs. definitions -->
      <title>Declaraciones vs definiciones</title>
      
      <!--
      It??s important to understand the difference between declarations and
      definitions because these terms will be used precisely throughout the
      book. Essentially all C and C++ programs require declarations. Before
      you can write your first program, you need to understand the proper way
      to write a declaration.
      -->
      <para>
      	Es importante comprender la diferencia entre
        <emphasis>declaraciones</emphasis> y
        <emphasis>definiciones</emphasis> porque estos términos se
        usarán de forma precisa en todo el libro. Básicamente todos los
        programas escritos en C o en C++ requieren declaraciones. Antes
        de poder escribir su primer programa, necesita comprender la
        manera correcta de escribir una declaración.
      </para>

      <!--
      A declaration introduces a name - an identifier - to the compiler. It
      tells the compiler ??This function or this variable exists somewhere,
      and here is what it should look like.?? A definition, on the other hand,
      says: ??Make this variable here?? or ??Make this function here.?? It
      allocates storage for the name. This meaning works whether you??re
      talking about a variable or a function; in either case, at the point of
      definition the compiler allocates storage. For a variable, the compiler
      determines how big that variable is and causes space to be generated in
      memory to hold the data for that variable. For a function, the compiler
      generates code, which ends up occupying storage in memory.
      -->
      <para>
	Una <emphasis>declaración</emphasis> presenta un nombre
	-identificador- al compilador. Le dice al compilador <quote>Esta
	función o esta variable existe en algún lugar, y éste es el
	aspecto que debe tener</quote>. Una
	<emphasis>definición</emphasis>, sin embargo, dice: <quote>Crea
	esta variable aquí</quote> o <quote>Crea esta función
	aquí</quote>. Eso reserva memoria para el nombre. Este
	significado sirve tanto para una variable que para una función;
	en ambos casos, el compilador reserva espacio en el momento de
	la definición. Para una variable, el compilador determina su
	tamaño y reserva el espacio en memoria para contener los datos
	de la variable. Para una función, el compilador genera el código
	que finalmente ocupará un espacio en memoria.
      </para>

      <!--
      You can declare a variable or a function in many different places, but
      there must be only one definition in C and C++ (this is sometimes called
      the ODR: one-definition rule). When the linker is uniting all the object
      modules, it will usually complain if it finds more than one definition
      for the same function or variable.
      -->
      <para>
	Se puede declarar una variable o una función en muchos sitios
	diferentes, pero en C o en C++ sólo se puede definir una vez (a
	se conoce a veces como Regla de Definición Única (ODR)
	<footnote>
	  <para>
	    <foreignphrase>one definition rule</foreignphrase>
	  </para>
	</footnote>. Cuando el enlazador une todos los módulos objeto,
	normalmente se quejará si encuentra más de una definición para
	la misma función o variable.
      </para>

      <!--
      A definition can also be a declaration. If the compiler hasn??t seen the
      name x before and you define int x;, the compiler sees the name as a
      declaration and allocates storage for it all at once.
      -->
      <para>
	Una definición puede ser también una declaración. Si el
	compilador no ha visto antes el nombre <varname>x</varname> y
	hay una definición <code>int x;</code>, el compilador ve el
	nombre también como una declaración y asigna memoria al mismo
	tiempo.
      </para>

      <sect3>
        <!-- Function declaration syntax -->
	<title>Sintaxis de declaración de funciones</title>

        <!--
        A function declaration in C and C++ gives the function name, the
        argument types passed to the function, and the return value of the
        function. For example, here is a declaration for a function called
        func1( ) that takes two integer arguments (integers are denoted in C/C++
        with the keyword int) and returns an integer:
        -->
	<para>
	  La declaración de una función en C y en C++ consiste en
	  escribir el nombre de la función, los tipos de argumentos que
	  se pasan a la función, y el valor de retorno de la misma. Por
	  ejemplo, aquí tenemos la declaración de una función llamada
	  <function>func1()</function> que toma dos enteros como
	  argumentos (en C/C++ los enteros se denotan con la palabra
	  reservada <type>int</type>) y que devuelve un entero:
	</para>


<programlisting>
int func1(int, int);
</programlisting>


	<!--
        The first keyword you see is the return value all by itself: int. The
        arguments are enclosed in parentheses after the function name in the
        order they are used. The semicolon indicates the end of a statement; in
        this case, it tells the compiler ??that??s all ? there is no function
        definition here!??
        -->
	<para>
	  La primera palabra reservada es el valor de retorno:
	  <literal>int</literal>. Los argumentos están encerrados
	  entre paréntesis después del nombre de la función en el
	  orden en que se utilizan. El punto y coma indica el final
	  de la sentencia; en este caso le dice al compilador
	  <quote>esto es todo - ¡aquí no está la definición de la
	    función!</quote>.
	</para>

        <!--
        C and C++ declarations attempt to mimic the form of the item??s use. For
        example, if a is another integer the above function might be used this
        way:
        -->
	<para>
	  Las declaraciones en C y C++ tratan de mimetizar la forma en
	  que se utilizará ese elemento. Por ejemplo, si
	  <varname>a</varname> es otro entero la función de arriba se
	  debería usar de la siguiente manera:
	</para>


<programlisting>
a = func1(2, 3);
</programlisting>


        <!--
        Since func1( ) returns an integer, the C or C++ compiler will check the
        use of func1( ) to make sure that a can accept the return value and that
        the arguments are appropriate.
        -->
	<para>
	  Como <function>func1()</function> devuelve un entero, el
	  compilador de C/C++ comprobará el uso de
	  <function>func1()</function> para asegurarse que
	  <varname>a</varname> puede aceptar el valor devuelto y que
	  los argumentos son válidos.
	</para>

        <!--
        Arguments in function declarations may have names. The compiler ignores
        the names but they can be helpful as mnemonic devices for the user. For
        example, we can declare func1( ) in a different fashion that has the
        same meaning:
        -->
	<para>
	  Los argumentos de las declaraciones de funciones pueden tener
	  nombres. El compilador los ignora pero pueden ser útilies como
	  nemotécnicos para el usuario. Por ejemplo, se puede declarar
	  <function>func1()</function> con una apariencia diferente pero
	  con el mismo significado:
	</para>


<programlisting>
int func1(int length, int width);
</programlisting>
      </sect3>
      
      <sect3>
       <!-- A gotcha -->
	<title>Una puntualización</title>

        <!--
        There is a significant difference between C and C++ for functions with
        empty argument lists. In C, the declaration:
        -->
	<para>
	  Existe una diferencia significativa entre C y el C++
	  para las funciones con lista de argumentos vacía. En C, la
	  declaración:
	</para>


<programlisting>
int func2();
</programlisting>


        <!-- 
	means ??a function with any number and type of argument.??
        This prevents type-checking, so in C++ it means ??a function
        with no arguments.??  -->
	<para>
	  significa <quote>una funcion con cualquier número y tipo de
	  argumentos</quote>, lo cual anula la comprobación de tipos. En
	  C++, sin embargo, significa <quote>una función sin
	  argumentos</quote>.
	</para>
      </sect3>
      
      <sect3>
        <!-- : Function definitions -->
	<title>Definición de funciones</title>

        <!--
        Function definitions look like function declarations except that they
        have bodies. A body is a collection of statements enclosed in
        braces. Braces denote the beginning and ending of a block of code. To
        give func1( ) a definition that is an empty body (a body containing no
        code), write:
        -->
	<para>
	  La definición de funciones se parece a la declaración
	  excepto en que tienen cuerpo. Un cuerpo es un conjunto de
	  sentencias encerradas entre llaves. Las llaves indican el
	  comienzo y el final del código. Para dar a
	  <function>func1()</function> una definición con un cuerpo
	  vacío (un cuerpo que no contiene código), escriba:
	</para>


<programlisting>
int func1(int ancho, int largo) {}
</programlisting>


        <!--
        Notice that in the function definition, the braces replace the
        semicolon. Since braces surround a statement or group of statements, you
        don??t need a semicolon. Notice also that the arguments in the function
        definition must have names if you want to use the arguments in the
        function body (since they are never used here, they are optional).
        -->
	<para>
	  Note que en la definición de la función las llaves
	  sustituyen el punto y coma. Como las llaves contienen una
	  sentencia o grupo de sentencias, no es necesario un punto
	  y coma. Tenga en cuenta además que los argumentos en la
	  definición de la función deben nombres si los
	  quiere usar en el cuerpo de la función (como aquí no se
	  usan, son opcionales).
	</para>
      </sect3>
      


      <sect3>
        <!-- : Variable declaration syntax -->
	<title>Sintaxis de declaración de variables</title>

        <!--
        The meaning attributed to the phrase ??variable declaration?? has
        historically been confusing and contradictory, and it??s important that
        you understand the correct definition so you can read code properly. A
        variable declaration tells the compiler what a variable looks like. It
        says, ??I know you haven??t seen this name before, but I promise it
        exists someplace, and it??s a variable of X type.??
        -->
	<para>
	  El significado atribuido a la frase <quote>declaración de
	  variables</quote> históricamente ha sido confuso y
	  contradictorio, y es importante que entienda el significado
	  correcto para poder leer el código correctamente. Una
	  declaración de variable dice al compilador cómo es la
	  variable. Dice al compilador, <quote>Sé que no has visto este
	  nombre antes, pero te prometo que existe en algún lugar, y que
	  es una variable de tipo X</quote>.
	</para>

        <!-- 
	In a function declaration, you give a type (the return
        value), the function name, the argument list, and a
        semicolon. That??s enough for the compiler to figure out that
        it??s a declaration and what the function should look like. By
        inference, a variable declaration might be a type followed by a
        name. For example: -->
	<para>
	  En una declaración de función, se da un tipo (el valor de
	  retorno), el nombre de la función, la lista de argumentos, y
	  un punto y coma. Con esto el compilador ya tiene suficiente
	  información para saber cómo será la función. Por inferencia,
	  una declaración de variable consistirá en un tipo seguido por
	  un nombre. Por ejemplo:
	</para>


<programlisting>
int a;
</programlisting>

        <!--
        could declare the variable a as an integer, using the logic
        above. Here??  s the conflict: there is enough information in
        the code above for the compiler to create space for an integer
        called a, and that??s what happens. To resolve this dilemma, a
        keyword was necessary for C and C++ to say ??This is only a
        declaration; it??s defined elsewhere.?? The keyword is
        extern. It can mean the definition is external to the file, or
        that the definition occurs later in the file.  -->
	<para>
	  podría declarar la variable <varname>a</varname> como un
	  entero usando la lógica usada anteriormente. Pero aquí está el
	  conflicto: existe suficiente información en el código anterior
	  como para que el compilador pueda crear espacio para un entero
	  llamado <varname>a</varname> y es exactamente lo que
	  ocurre. Para resolver el dilema, fue necesaria una palabra
	  reservada en C y C++ para decir <quote>Esto es sólo una
	  declaración; esta variable estará definida en algún otro
	  lado</quote>. La palabra reservada es <kw>extern</kw> que
	  puede significar que la definición es externa al fichero, o
	  que la definición se encuentra después en este fichero.
	</para>

        <!--
        Declaring a variable without defining it means using the extern
        keyword before a description of the variable, like this: -->
	<para>
	  Declarar una variable sin definirla implica usar la palabra
	  reservada <kw>extern</kw> antes de una descripción de la
	  variable, como por ejemplo:
	</para>


<programlisting>
extern int a;
</programlisting>


        <!--
        extern can also apply to function declarations. For func1( ), it looks
        like this:
        -->
	<para>
	  <kw>extern</kw> también se puede aplicar a la declaración de
	  funciones. Para <function>func1()</function> sería algo así:
	</para>


<programlisting>
extern int func1(int length, int width);
</programlisting>


        <!--
        This statement is equivalent to the previous func1( )
        declarations. Since there is no function body, the compiler must treat
        it as a function declaration rather than a function definition. The
        extern keyword is thus superfluous and optional for function
        declarations. It is probably unfortunate that the designers of C did not
        require the use of extern for function declarations; it would have been
        more consistent and less confusing (but would have required more typing,
        which probably explains the decision).
        -->
	<para>
	  Esta sentencia es equivalente a las declaraciones anteriores
	  para <function>func1()</function> . Como no hay cuerpo de
	  función, el compilador debe tratarla como una declaración de
	  función en lugar de como definición. La palabra reservada
	  <kw>extern</kw> es bastante supérflua y opcional para la
	  declaración de funciones. Probablemente sea desafortunado que
	  los diseñadores de C no obligaran al uso de <kw>extern</kw>
	  para la declaración de funciones; hubiera sido más consistente
	  y menos confuso (pero hubiera requerido teclear más, lo cual
	  probablemente explica la decisión).
	</para>

        <!-- Here are some more examples of declarations: -->
	<para>
	  Aquí hay algunos ejemplos más de declaraciones:
	</para>


<programlisting>
<xi:include parse="text" href="./code/C02/Declare.cpp"/>
</programlisting>


        <!--
        In the function declarations, the argument identifiers are optional. In
        the definitions, they are required (the identifiers are required only in
        C, not C++).
        -->
        <para>
          En la declaración de funciones, los identificadores de los argumentos
          son opcionales. En la definición son necesarios (los identificadores
          se requieren solamente en C, no en C++).
        </para>
      </sect3>
      
      <sect3>
        <!-- Including headers -->
        <title>Incluir ficheros de cabecera</title>

        <!-- 
	Most libraries contain significant numbers of functions and
        variables. To save work and ensure consistency when making the
        external declarations for these items, C and C++ use a
        FIXME:device called the header file. A header file is a file
        containing the external declarations for a library; it
        conventionally has a file name extension of ??h??, such as
        headerfile.h. (You may also see some older code using different
        extensions, such as .hxx or .hpp, but this is becoming rare.)
        -->
        <para>
          La mayoría de las librerías contienen un número importante de
          funciones y variables. Para ahorrar trabajo y asegurar la
          consistencia cuando se hacen declaraciones externas para estos
          elementos, C y C++ utilizan un artefacto llamado
          <emphasis>fichero de cabecera</emphasis>. Un fichero de
          cabecera es un fichero que contiene las declaraciones externas
          de una librería; convencionalmente tiene un nombre de fichero
          con extensión <filename>.h</filename>, como
          <filename>headerfile.h</filename> (no es difícil encontrar
          código más antiguo con extensiones diferentes, como
          <filename>.hxx</filename> o <filename>.hpp</filename>, pero es
          cada vez más raro).
        </para>

        <!-- The programmer who creates the library provides the header
        file. To declare the functions and external variables in the
        library, the user simply includes the header file. To include a
        header file, use the #include preprocessor directive. This tells
        the preprocessor to open the named header file and insert its
        contents where the #include statement appears. A #include may
        name a file in two ways: in angle brackets (FIXME:< >) or in
        double quotes.  -->
        <para>
          El programador que crea la librería proporciona el fichero de
          cabecera. Para declarar las funciones y variables externas de
          la librería, el usuario simplemente incluye el fichero de
          cabecera. Para ello se utiliza la directiva de preprocesado
          <kw>#include</kw>. Eso le dice al preprocesador que abra el
          fichero de cabecera indicado e incluya el contenido en el
          lugar donde se encuentra la sentencia <kw>#include</kw>. Un
          <kw>#include</kw> puede indicar un fichero de dos maneras:
          mediante paréntesis angulares ( &lt; &gt; ) o comillas dobles.
	</para>
        
        <!-- File names in angle brackets, such as: -->
	<para>
          Los ficheros entre paréntesis angulares, como:
        </para>


<programlisting>
#include &lt;header&gt;
</programlisting>


        <!--
        cause the preprocessor to search for the file in a way that is
        particular to your implementation, but typically there??s some kind of
        ??include search path?? that you specify in your environment or on the
        compiler command line. The mechanism for setting the search path varies
        between machines, operating systems, and C++ implementations, and may
        require some investigation on your part.
        -->
	<para>
          hacen que el preprocesador busque el fichero como si fuera
          particular a un proyecto, aunque normalmente hay un camino de
          búsqueda que se especifica en el entorno o en la línea de
          comandos del compilador. El mecanismo para cambiar el camino
          de búsqueda (o ruta) varía entre maquinas, sistemas
          operativos, e implementaciones de C++ y puede que requiera un
          poco de investigación por parte del programador.
        </para>

        <!-- File names in double quotes, such as: -->
        <para>
          Los ficheros entre comillas dobles, como:
        </para>


<programlisting>
#include "header"
</programlisting>


        <!--
        tell the preprocessor to search for the file in (according to the
        specification) an ??implementation-defined way.?? What this typically
        means is to search for the file relative to the current directory. If
        the file is not found, then the include directive is reprocessed as if
        it had angle brackets instead of quotes.
        -->
        <para>
          le dicen al preprocesador que busque el fichero en (de acuerdo a la
          especificación) <quote>un medio de definición de
          implementación</quote>, que normalmente significa buscar el fichero de
          forma relativa al directorio actual. Si no lo encuentra, entonces la
          directiva se preprocesada como si tuviera paréntesis angulares
          en lugar de comillas.
        </para>

        <!-- To include the iostream header file, you write: -->
        <para>
          Para incluir el fichero de cabecera
          <filename>iostream</filename>, hay que escribir:
        </para>


<programlisting>
#include &lt;iostream&gt;
</programlisting>

        <!--
        The preprocessor will find the iostream header file (often in a
        subdirectory called ??include??) and insert it.
        -->
        <para>
          El preprocesador encontrará el fichero de cabecera
          <filename>iostream</filename> (a menudo en un subdirectorio llamado
          <quote>include</quote>) y lo incluirá.
        </para>
      </sect3>


      <sect3>
        <!-- Standard C++ include format -->
        <title>Formato de inclusión del estándar C++</title>

        <!-- As C++ evolved, different compiler vendors chose different
        extensions for file names. In addition, various operating
        systems have different restrictions on file names, in particular
        on name length. These issues caused source code portability
        problems. To smooth over these rough edges, the standard uses a
        format that allows file names longer than the notorious eight
        characters and eliminates the extension. For example, instead of
        the old style of including iostream.h, which looks like this:
        -->
	<para>
	  A medida que C++ evolucionaba, los diferentes fabricantes de
	  compiladores elegían diferentes extensiones para los nombres
	  de ficheros. Además, cada sistema operativo tiene sus propias
	  restricciones para los nombres de ficheros, en particular la
	  longitud. Estas características crearon problemas de
	  portabilidad del código fuente. Para limar estos problemas, el
	  estándar usa un formato que permite los nombres de ficheros
	  más largos que los famosos ocho caracteres y permite eliminar
	  la extensión. Por ejemplo en vez de escribir
	  <filename>iostream.h</filename> en el estilo antiguo, que se
	  asemejaría a algo así:
	</para>


<programlisting>
#include &lt;iostream.h&gt;
</programlisting>

        <!-- you can now write: -->
	<para>
	  ahora se puede escribir:
	</para>


<programlisting>
#include &lt;iostream&gt;
</programlisting>


        <!--
        The translator can implement the include statements in a way that suits
        the needs of that particular compiler and operating system, if necessary
        truncating the name and adding an extension. Of course, you can also
        copy the headers given you by your compiler vendor to ones without
        extensions if you want to use this style before a vendor has provided
        support for it.
        -->
	<para>
	  El traductor puede implementar la sentencia del
	  <kw>include</kw> de tal forma que se amolde a las necesidades
	  de un compilador y sistema operativo particular, aunque sea
	  necesario truncar el nombre y añadir una
	  extensión. Evidentemente, también puede copiar las cabeceras
	  que ofrece el fabricante de su compilador a otras sin
	  extensiones si quiere usar este nuevo estilo antes de que su
	  fabricante lo soporte.
	</para>

        <!-- The libraries that have been inherited from C are still
        available with the traditional ??.h?? extension. However, you
        can also use them with the more modern C++ include style by
        prepending a FIXME:LETRA:??c?? before the name. Thus: -->
	<para>
	  Las librerías heredadas de C aún están disponibles con la
	  extensión tradicional
	  <quote><filename>.h</filename></quote>. Sin embargo, se pueden
	  usar con el estilo de inclusión más moderno colocando una
	  <quote><emphasis>c</emphasis></quote> al nombre. Es decir:
	</para>


<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</programlisting>

        <!-- become: -->
	<para>
	  Se transformaría en:
	</para>


<programlisting>
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
</programlisting>


        <!--
        And so on, for all the Standard C headers. This provides a nice
        distinction to the reader indicating when you??re using C versus C++
        libraries.
        -->
	<para>
          Y así para todas cabeceras del C Estándar. Eso proporciona al
          lector una distinción interesante entre el uso de librerías C
          versus C++.
	</para>


        <!-- The effect of the new include format is not identical to
        the old: using the .h gives you the older, non-template version,
        and omitting the FIXME:LETRA:.h gives you the new templatized
        version. You??ll usually have problems if you try to intermix
        the two forms in a single program.  -->
	<para>
          El efecto del nuevo formato de include no es idéntico al
          antiguo: usar el <quote><filename>.h</filename></quote> da
          como resultado una versión más antigua, sin plantillas, y
          omitiendo el <quote><filename>.h</filename></quote> le ofrece
          la nueva versión con plantillas. Normalmente podría tener
          problemas si intenta mezclar las dos formas de inclusión en un
          mismo programa.
        </para>
      </sect3>
    </sect2>
    
    <sect2>
      <!-- Linking -->
      <title>Enlazado</title>

      <!--
      The linker collects object modules (which often use file name extensions
      like .o or .obj), generated by the compiler, into an executable program
      the operating system can load and run. It is the last phase of the
      compilation process.
      -->
      <para>
        El enlazador (<foreignphrase>linker</foreignphrase>) agrupa los
        módulos objeto (que a menudo tienen extensiones como
        <filename>.o</filename> ó <filename>.obj</filename>), generados
        por el compilador, en un programa ejecutable que el sistema
        operativo puede cargar y ejecutar. Es la última fase del proceso
        de compilación.
      </para>

      <!--
      Linker characteristics vary from system to system. In general, you just
      tell the linker the names of the object modules and libraries you want
      linked together, and the name of the executable, and it goes to
      work. Some systems require you to invoke the linker yourself. With most
      C++ packages you invoke the linker through the C++ compiler. In many
      situations, the linker is invoked for you invisibly.
      -->
      <para>
        Las características del enlazador varían de un sistema a
        otro. En general, simplemente se indican al enlazador los
        nombres de los módulos objeto, las librerías que se desean
        enlazar y el nombre del ejecutable de salida. Algunos sistemas
        requieren que sea el programador el que invoque al enlazador,
        aunque en la mayoría de los paquetes de C++ se llama al
        enlazador a través del compilador. En muchas situaciones, de
        manera transparente.
      </para>

      <!--
      Some older linkers won??t search object files and libraries more than
      once, and they search through the list you give them from left to
      right. This means that the order of object files and libraries can be
      important. If you have a mysterious problem that doesn??t show up until
      link time, one possibility is the order in which the files are given to
      the linker.
      -->
      <para>
        Algunos enlazadores antiguos no buscaban ficheros objeto más de
        una vez y buscaban en la lista que se les pasaba de izquierda a
        derecha. Esto significa que el orden de los ficheros objeto y
        las librerías puede ser importante. Si se encuentra con algún
        problema misterioso que no aparece hasta el proceso de enlazado,
        una posible razón es el orden en el que se indican los ficheros
        al enlazador.
      </para>

    </sect2>
    
    <sect2>
      <!-- Using libraries -->
      <title>Uso de librerías</title>

      <!--
      Now that you know the basic terminology, you can understand how to use a
      library. To use a library:
      -->
      <para>
        Ahora que ya conoce la terminología básica, puede entender cómo
        utilizar una librería. Para usarla:
      </para>

      <!--
      1. Include the library??s header file.  2. Use the functions and
      variables in the library.  3. Link the library into the executable
      program.
      -->
      <orderedlist>
        <listitem>
          <para> 
            Se incluye el fichero de cabecera de la librería.
          </para>
        </listitem>
        <listitem>
          <para> 
            Se usan las funciones y las variables de la librería.
          </para>
        </listitem>			 
        <listitem>
          <para>	
            Se enlaza la librería junto con el programa ejecutable.
          </para>
        </listitem>
      </orderedlist>
      
      <!--
      These steps also apply when the object modules aren??t combined into a
      library. Including a header file and linking the object modules are the
      basic steps for separate compilation in both C and C++.
      -->
      <para>
        Estos pasos también se aplican cuando los módulos objeto no se combinan
        para formar una librería. Incluir el fichero cabecera y enlazar los
        módulos objeto es la base para la compilación separada en C y en C++.
      </para>

      <sect3>
        <!-- How the linker searches a library -->
        <title>Cómo busca el enlazador una librería</title>

        <!--
        When you make an external reference to a function or variable in C or
        C++, the linker, upon encountering this reference, can do one of two
        things. If it has not already encountered the definition for the
        function or variable, it adds the identifier to its list of ??unresolved
        references.?? If the linker has already encountered the definition, the
        reference is resolved.
        -->
        <para>
          Cuando se hace una refencia externa a una función o una
          variable en C o C++, al enlazador, una vez encontrada esta
          referencia, puede hacer dos cosas. Si todavía no ha encontrado
          la definición de la función o variable, añade el identificador
          a su lista de <quote>referencias no resueltas</quote>. Si el
          enlazador ya había encontrado la definición, se resuelve la
          referencia.
        </para>
	
        <!--
        If the linker cannot find the definition in the list of object modules,
        it searches the libraries. Libraries have some sort of indexing so the
        linker doesn??t need to look through all the object modules in the
        library ? it just looks in the index. When the linker finds a definition
        in a library, the entire object module, not just the function
        definition, is linked into the executable program. Note that the whole
        library isn??t linked, just the object module in the library that
        contains the definition you want (otherwise programs would be
        unnecessarily large). If you want to minimize executable program size,
        you might consider putting a single function in each source code file
        when you build your own libraries. This requires more editing[27], but
        it can be helpful to the user.
        -->
        <para>
          Si el enlazador no puede encontrar la definición en la lista
          de módulos objeto, busca en las librerías. Las librerías
          tienen algún tipo de indexación para que el enlazador no
          necesite buscar en todos los módulos objeto en la librería -
          solamente mira en el índice. Cuando el enlazador encuentra una
          definición en una librería, el módulo objeto entero, no sólo
          la definición de la función, se enlaza al programa
          ejecutable. Dese cuenta que no se enlaza la librería completa,
          tan solo el módulo objeto de la librería que contiene la
          definición que se necesita (de otra forma los programas se
          volverían innecesariamente largos). Si se desea minimizar el
          tamaño del programa ejecutable, se debería considerar poner
          una única función en cada fichero fuente cuando se construyan
          librerías propias. Esto requiere más trabajo de edición,
	  <footnote>
	    <!--
	    [27] I would recommend using Perl or Python to automate this task as
	    part of your library-packaging process (see www.Perl.org or
	    www.Python.org).
	    -->
	    <para> 
	      Yo le recomendaría usar Perl o Python para automatizar
	      estas tareas como parte de su proceso de empaquetamiento de
	      librerías (ver <ulink
		url="http://www.perl.org">www.Perl.org</ulink> ó <ulink
		url="http://www.python.org">www.Python.org</ulink>).
	    </para> 
	  </footnote> pero puede ser muy útil para el usuario.
        </para>

        <!-- Because the linker searches files in the order you give
        them, you can pre-empt the use of a library function by
        inserting a file with your own function, using the same function
        name, into the list before the library name appears. Since the
        linker will resolve any references to this function by using
        your function before it searches the library, your function is
        used instead of the library function. Note that this can also be
        a bug, and the kind of thing C++ namespaces prevent.  -->
        <para>
          Debido a que el enlazador busca los ficheros en el orden que
          se le dan, se puede prevenir el uso de una función de una
          librería insertando un fichero con su propia función, usando
          el mismo nombre de función, en la lista antes de que aparezca
          el nombre de la librería. Cuando el enlazador resuelva
          cualquier referencia a esa función encontrando la función
          antes de buscar en la librería, se utilizará su función en
          lugar de la que se encuentra en la librería. Eso también puede
          ser una fuente de errores, y es la clase de cosas que se puede
          evitar usando los espacios de nombres
          (<foreignphrase>namespaces</foreignphrase>) de C++.
        </para>
      </sect3>
      


      <sect3>
        <!-- Secret additions -->
        <title>Añadidos ocultos</title>

        <!--
        When a C or C++ executable program is created, certain items are
        secretly linked in. One of these is the startup module, which contains
        initialization routines that must be run any time a C or C++ program
        begins to execute. These routines set up the stack and initialize
        certain variables in the program.
        -->
        <para>
          Cuando se crea un programa ejecutable en C/C++, ciertos
          elementos se enlazan en secreto. Uno de estos elementos es el
          módulo de arranque, que contiene rutinas de inicialización que
          deben ejecutarse cada vez que arranca un programa C o
          C++. Estas rutinas preparan la pila e inicializan ciertas
          variables del programa.
        </para>

        <!--
        The linker always searches the standard library for the compiled
        versions of any ??standard?? functions called in the program. Because
        the standard library is always searched, you can use anything in that
        library by simply including the appropriate header file in your program;
        you don??t have to tell it to search the standard library. The iostream
        functions, for example, are in the Standard C++ library. To use them,
        you just include the <iostream> header file.
        -->
        <para>
          El enlazador siempre busca la librería estándar para las versiones
          compiladas de cualquier función <quote>estándar</quote> llamada en el
          programa. Debido a que se busca siempre en la librería estándar, se
          puede usar cualquier cosa de esta librería simplemente añadiendo a su
          programa la cabecera apropiada; no necesita indicar dónde hay que
          buscar la librería estándar. Las funciones de flujo de entrada-salida
          (iostream), por ejemplo, están en la Librería Estándar de C++. Para
          usarla, sólo debe incluir el fichero de cabecera
          <filename>&lt;iostream&gt;</filename>.
        </para>

        <!--
        If you are using an add-on library, you must explicitly add the library
        name to the list of files handed to the linker.
        -->
        <para>
          Si se está usando una librería, se debe añadir explícitamente
          su nombre de ésta a la lista de ficheros manejados por el
          enlazador.
        </para>
      </sect3>
      
<!-- FIXME: me quedé aquí: magmax -->

      <sect3>
        <!-- Using plain C libraries -->
        <title>Uso de librerías C plano</title>

        <!--
        Just because you are writing code in C++, you are not prevented from
        using C library functions. In fact, the entire C library is included by
        default into Standard C++. There has been a tremendous amount of work
        done for you in these functions, so they can save you a lot of time.
        -->
        <para>
          Aunque esté escribiendo código en C++, nada le impide usar
          librerías de C. De hecho, toda la librería de C está incluida
          por defecto en el C++ Estándar. Hay una cantidad tremenda de
          trabajo ya realizado en esas librerías que le pueden ahorrar
          un montón de tiempo.
        </para>

        <!--
        This book will use Standard C++ (and thus also Standard C) library
        functions when convenient, but only standard library functions will be
        used, to ensure the portability of programs. In the few cases in which
        library functions must be used that are not in the C++ standard, all
        attempts will be made to use POSIX-compliant functions. POSIX is a
        standard based on a Unix standardization effort that includes functions
        that go beyond the scope of the C++ library. You can generally expect to
        find POSIX functions on Unix (in particular, Linux) platforms, and often
        under DOS/Windows. For example, if you??re using multithreading you are
        better off using the POSIX thread library because your code will then be
        easier to understand, port and maintain (and the POSIX thread library
        will usually just use the underlying thread facilities of the operating
        system, if these are provided).
        -->
        <para>
          Este libro usará la librería Estándar de C++ cuando sea
          necesario (y por lo tanto la de C), pero sólo se utilizarán
          funciones de la librería <emphasis>estándar</emphasis>, para
          asegurar la portabilidad de los programas. En los pocos casos
          en los que las funciones no sean de C++ estándar, se intentará
          que sean funciones compatibles con POSIX. POSIX es un estándar
          basado en el esfuerzo por conseguir la estandarización de
          Unix, que incluye funciones que van más allá del ámbito de las
          librerías de C++. Normalmente puede esperar encontrar
          funciones POSIX en plataformas Unix (en particular,
          GNU/Linux), y a menudo en sistemas DOS/Windows. Por ejemplo,
          si está usando hilos (<foreignphrase>threads</foreignphrase>)
          será mejor usar la librería de hilos compatible con POSIX ya
          que su código será más fácil de entender, portar y mantener (y
          la librería de hilos usará los servicios que ofrece el sistema
          operativo, si es que están soportados).
	</para>
      </sect3>
    </sect2>
  </sect1>
  
  <sect1>
    <!-- Your first C++ program -->
    <title>Su primer programa en C++</title>

    <!--
    You now know almost enough of the basics to create and compile a
    program. The program will use the Standard C++ iostream classes. These
    read from and write to files and ??standard?? input and output (which
    normally comes from and goes to the console, but may be redirected to
    files or devices). In this simple program, a stream object will be used
    to print a message on the screen.
    -->
    <para>
      Ahora ya tiene suficientes conocimientos para crear y compilar un
      programa. Este programa usará las clases de <emphasis>flujo de
      entrada-salida</emphasis> (<filename>iostream</filename>) del C++
      estándar. <filename>iostream</filename> es capaz de leer y
      escribir en ficheros o en la entrada y salida estándar (que suele
      ser la consola, pero que puede ser redirigida a ficheros o
      dispositivos). En este programa simple, se usa un objeto
      <classname>stream</classname> (flujo) para imprimir un mensaje en
      pantalla.
    </para>


    <sect2>
      <!-- Using the iostreams class -->
      <title>Uso de las clases <classname>iostream</classname></title>

      <!--
      To declare the functions and external data in the iostreams class,
      include the header file with the statement
      -->
      <para>
	Para declarar las funciones y los datos externos que contenga la
	clase <filename>iostream</filename> hay que incluir el fichero
	de cabecera de la siguiente manera:
      </para>


<programlisting>
#include &lt;iostream&gt;
</programlisting>


      <!--
      The first program uses the concept of standard output, which means ??a
      general-purpose place to send output.?? You will see other examples
      using standard output in different ways, but here it will just go to the
      console. The iostream package automatically defines a variable (an
      object) called cout that accepts all data bound for standard output.
      -->
      <para>
	El primer programa usa el concepto de salida estándar, que
	significa <quote>un lugar de propósito general, al que se le
	pueden enviar cosas</quote>. Verá otros ejemplos que utilizan la
	salida estándar de otras formas, pero aquí simplemente usaremos
	la consola. El paquete <filename>iostream</filename> define una
	variable (un objeto) llamado <varname>cout</varname> de forma
	automática que es capaz de enviar todo tipo de datos a la salida
	estándar.
      </para>

      <!--
      To send data to standard output, you use the operator <<. C programmers
      know this operator as the ??bitwise left shift,?? which will be
      described in the next chapter. Suffice it to say that a bitwise left
      shift has nothing to do with output. However, C++ allows operators to be
      overloaded. When you overload an operator, you give it a new meaning
      when that operator is used with an object of a particular type. With
      iostream objects, the operator << means ??send to.?? For example:
      -->
      <para>
	Para enviar datos a la salida estándar, se usa el operador
	<oper>&lt;&lt;</oper>.Los programadores de C lo conocen como
	operador de <quote>desplazamiento a la izquierda</quote>, que se
	explicará en el siguiente capítulo. Baste decir que el
	desplazamiento a la izquierda no tiene nada que ver con la
	salida. Sin embargo, C++ permite que los operadores sean
	<emphasis>sobrecargados</emphasis>. Cuando se sobrecarga un
	operador, se le da un nuevo significado siempre que dicho
	operador se use con un objeto de determinado tipo. Con los
	objetos de <filename>iostream</filename>, el operador
	<oper>&lt;&lt;</oper> significa <quote>enviar a</quote>. Por
	ejemplo:
      </para>


<programlisting>
cout &lt;&lt; "¿Qué tal?";
</programlisting>


      <!--
      sends the string ??howdy!?? to the object called cout (which is short
      for ??console output??).
      -->
      <para>
	envía la cadena <quote>¿Qué tal?</quote> al objeto llamado
	<varname>cout</varname> (que es un diminutivo de <quote>console
	output</quote> (salida por consola).
      </para>

      <!--
      That??s enough operator overloading to get you started. Chapter 12
      covers operator overloading in detail.
      -->
      <para>
	De momento ya hemos visto suficiente sobrecarga de operadores
	como para poder empezar. El <link linkend="C12">Capítulo
	12</link> cubre la sobrecarga de operadores con detalle.
      </para>
    </sect2>
    
    <sect2>
      <!-- Namespaces -->
      <title>Espacios de nombres</title>

      <!--
      As mentioned in Chapter 1, one of the problems encountered in the C
      language is that you ??run out of names?? for functions and identifiers
      when your programs reach a certain size. Of course, you don??t really
      run out of names; it does, however, become harder to think of new ones
      after awhile. More importantly, when a program reaches a certain size it??
      s typically broken up into pieces, each of which is built and maintained
      by a different person or group. Since C effectively has a single arena
      where all the identifier and function names live, this means that all
      the developers must be careful not to accidentally use the same names in
      situations where they can conflict. This rapidly becomes tedious,
      time-wasting, and, ultimately, expensive.
      -->
      <para>
	Como se menciona en el <link linkend="C01">Capítulo 1</link>,
	uno de los problemas del lenguaje C es que <quote>nos quedamos
	sin nombres</quote> para funciones e identificadores cuando los
	programas llegan a ser de cierto tamaño. Por supuesto que
	realmente no nos quedamos sin nombres; aunque se hace más
	difícil pensar en nombres nuevos después de un rato. Y todavía
	más importante, cuando un programa alcanza cierto tamaño es
	normal fragmentarlo en trozos más pequeños cada uno de los
	cuales es mantenido por diferentes personas o grupos. Como C
	sólo tiene un ruedo para lidiar con todos los identificadores y
	nombres de función, trae como consecuencia que todos los
	desarrolladores deben tener cuidado de no usar accidentalmente
	los mismos nombres en situaciones en las que pueden ponerse en
	conflicto. Esto se convierte en una pérdida de tiempo, se hace
	tedioso y en último término, es más caro.
      </para>

      <!--
      Standard C++ has a mechanism to prevent this collision: the namespace
      keyword. Each set of C++ definitions in a library or program is
      ??wrapped?? in a namespace, and if some other definition has an
      identical name, but is in a different namespace, then there is no
      collision.
      -->
      <para>
	El C++ Estándar tiene un mecanismo para impedir estas
	colisiones: la palabra reservada <kw>namespace</kw> (espacio de
	nombres). Cada conjunto de definiciones de una librería o
	programa se <quote>envuelve</quote> en un espacio de nombres, y
	si otra definición tiene el mismo nombre, pero está en otro
	espacio de nombres, entonces no se produce colisión.
      </para>

      <!-- Namespaces are a convenient and helpful tool, but their
      presence means that you must be aware of them before you can write
      any programs. If you simply include a header file and use some
      functions or objects from that header, you??ll probably get
      strange-sounding errors when you try to compile the program, to
      the effect that the compiler cannot find any of the declarations
      for the items that you just included in the header file! After you
      see this message a few times you??ll become familiar with its
      meaning (which is ??You included the header file but all the
      declarations are within a namespace and you didn??t tell the
      compiler that you wanted to use the declarations in that
      namespace??).  -->
      <para>
	El espacio de nombres es una herramienta útil y conveniente,
	pero su presencia implica que debe saber usarla antes de
	escribir un programa. Si simplemente escribe un fichero de
	cabecera y usa algunas funciones u objetos de esa cabecera,
	probablemente reciba extraños mensajes cuando compile el
	programa, debido a que el compilador no pueda encontrar las
	declaraciones de los elementos del fichero de cabecera. Después
	de ver este mensaje un par de veces se le hará familiar su
	significado (que es: <emphasis>Usted ha incluido el fichero de
	cabecera pero todas las declaraciones están sin un espacio de
	nombres y no le dijo al compilador que quería usar las
	declaraciones en ese espacio de nombres</emphasis>).
      </para>

      <!--
      There??s a keyword that allows you to say ??I want to use the
      declarations and/or definitions in this namespace.?? This keyword,
      appropriately enough, is using. All of the Standard C++ libraries are
      wrapped in a single namespace, which is std (for ??standard??). As this
      book uses the standard libraries almost exclusively, you??ll see the
      following using directive in almost every program:
      -->
      <para>
	Hay una palabra reservada que le permite decir <quote>quiero
	usar las declaraciones y/o definiciones de este espacio de
	nombres</quote>. Esa palabra reservada, bastante apropiada por
	cierto, es <kw>using</kw>. Todas las librerías de C++ Estándar
	están incluidas en un único espacio de nombres, que es
	<literal>std</literal> (por <quote>standard</quote>). Como este
	libro usa la librería estándar casi exclusivamente, verá la
	siguiente <emphasis>directiva using</emphasis> en casi todos los
	programas.
      </para>


<programlisting>
using namespace std;
</programlisting>


      <!--
      This means that you want to expose all the elements from the namespace
      called std. After this statement, you don??t have to worry that your
      particular library component is inside a namespace, since the using
      directive makes that namespace available throughout the file where the
      using directive was written.
      -->
      <para>
	Esto significa que quiere usar todos los elementos del espacio
	de nombres llamado <literal>std</literal>. Después de esta
	sentencia, ya no hay que preocuparse de si su componente o
	librería particular pertenece a un espacio de nombres, porque la
	directiva <kw>using</kw> hace que el espacio de nombres esté
	disponible para todo el fichero donde se escribió la directiva
	<kw>using</kw>.
      </para>

      <!--
      Exposing all the elements from a namespace after someone has gone to the
      trouble to hide them may seem a bit counterproductive, and in fact you
      should be careful about thoughtlessly doing this (as you'll learn later
      in the book). However, the using directive exposes only those names for
      the current file, so it is not quite as drastic as it first sounds. (But
      think twice about doing it in a header file ? that is reckless.)
      -->
      <para>
	Exponer todos los elementos de un espacio de nombres después de
	que alguien se ha molestado en ocultarlos, parece
	contraproducente, y de hecho, el lector deberá tener cuidado si
	considera hacerlo (como aprenderá más tarde en este libro). Sin
	embargo, la directiva <kw>using</kw> expone solamente los
	nombres para el fichero actual, por lo que no es tan drástico
	como suena al principio. (pero pienselo dos veces antes de
	usarlo en un fichero cabecera, eso <emphasis>es</emphasis>
	temerario).
      </para>

      <!-- There??s a relationship between namespaces and the way header
      files are included. Before the modern header file inclusion was
      standardized (without the trailing ??.h??, as in <iostream>), the
      typical way to include a header file was with the
      FIXME:LETRA:??.h??, such as <iostream.h>. At that time, namespaces
      were not part of the language either. So to provide backward
      compatibility with existing code, if you say -->
      <para>
	Existe una relación entre los espacios de nombres y el modo en
	que se incluyes los ficheros de cabecera. Antes de que se
	estandarizara la nueva forma de inclusión de los ficheros
	cabecera (sin el <quote><literal>.h</literal></quote> como en
	<code>&lt;iostream&gt;</code>), la manera típica de incluir un
	fichero de cabecera era con el <quote><literal>.h</literal></quote>
	como en <filename>&lt;iostream.h&gt;</filename>. En esa época
	los espacios de nombres tampoco eran parte del lenguaje, por lo
	que para mantener una compatibilidad hacia atrás con el código
	existente, si se escribía:
      </para>

<programlisting>
#include &lt;iostream.h&gt;
</programlisting>


      <!-- it means -->
      <para>
	En realidad, significaba:
      </para>


<programlisting>
#include &lt;iostream&gt;
using namespace std;
</programlisting>


      <!--
      However, in this book the standard include format will be used (without
      the FIXME:LETRA:'.h') and so the using directive must be explicit.
      -->
      <para>
	Sin embargo en este libro se usará la forma estándar de
	inclusión (sin el <quote><literal>.h</literal></quote>) y
	haciendo explícita la directiva <kw>using</kw>. 
      </para>

      <!--
      For now, that??s all you need to know about namespaces, but in Chapter
      10 the subject is covered much more thoroughly.
      -->
      <para>
	Por ahora, esto es todo lo que necesita saber sobre los espacios
	de nombres, pero el <link linkend="C10">Capítulo 10</link> cubre
	esta materia en profundidad.
      </para>

    </sect2>

    <sect2>
      <!-- Fundamentals of program structure -->
      <title>Fundamentos de la estructura de los programa</title>

      <!--
      A C or C++ program is a collection of variables, function definitions,
      and function calls. When the program starts, it executes initialization
      code and calls a special function, ??main( ).?? You put the primary code
      for the program here.
      -->
      <para>
	Un programa C o C++ es una colección de variables, definiciones
	de función, y llamada a funciones. Cuando el programa arranca,
	ejecuta el código de inicialización y llama a una función
	especial, <quote><function>main()</function></quote>, que es
	donde debe colocarse el código principal del programa.
      </para>

      <!--
      As mentioned earlier, a function definition consists of a return type
      (which must be specified in C++), a function name, an argument list in
      parentheses, and the function code contained in braces. Here is a sample
      function definition:
      -->
      <para>
	Como se mencionó anteriormente, una definición de función
	consiste en un valor de retorno (que debe ser especificarse
	obligatoriamente C++), un nombre de función, una lista de
	argumentos, y el código de la función entre llaves. Aquí hay un
	ejemplo de definición de función:
      </para>


<programlisting>
int funcion() {
   // Código de la función aquí (esto es un comentario)
}
</programlisting>


      <!--
      The function above has an empty argument list and a body that contains
      only a comment.
      -->
      <para>
	La función de arriba tiene una lista vacía de argumentos y
	un cuerpo que contiene únicamente un comentario.
      </para>

      <!--
      There can be many sets of braces within a function definition, but there
      must always be at least one set surrounding the function body. Since
      main( ) is a function, it must follow these rules. In C++, main( )
      always has return type of int.
      -->
      <para>
	Puede haber varios pares de llaves en la definición de una
	función, pero siempre debe haber al menos dos que envuelvan todo
	el cuerpo de la función. Como <function>main()</function> es una
	función, debe seguir esas reglas. En C++,
	<function>main()</function> siempre devuelve un valor de tipo
	<type>int</type> (entero).
      </para>

      <!--
      C and C++ are free form languages. With few exceptions, the compiler
      ignores newlines and white space, so it must have some way to determine
      the end of a statement. Statements are delimited by semicolons.
      -->
      <para>
	C y C++ son lenguajes de formato libre. Con un par de
	excepciones, el compilador ignora los espacios en blanco y los
	saltos de línea, por lo que hay que determinar el final de una
	sentencia. Las sentencias están delimitadas por punto y coma.
      </para>

      <!--
      C comments start with /* and end with */. They can include newlines. C++
      uses C-style comments and has an additional type of comment: //. The //
      starts a comment that terminates with a newline. It is more convenient
      than /* */ for one-line comments, and is used extensively in this book.
      -->
      <para>
	Los comentarios en C empiezan con <literal>/*</literal> y
	finalizan con <literal>*/</literal>. Pueden incluir saltos de
	línea. C++ permite este estilo de comentarios y añade la doble
	barra inclinada: <literal>//</literal>. La <literal>//</literal>
	empieza un comentario que finaliza con el salto de línea. Es más
	útil que <literal>/* */</literal> y se usa ampliamente en este
	libro.
      </para>

    </sect2>
    
    <sect2>
      <!-- "Hello, world!" -->
      <title><quote>Hello, World!</quote></title>

      <!-- And now, finally, the first program: -->
      <para>
	Y por fin, el primer programa:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Hello.cpp"/>
</programlisting>

      <!--
      The cout object is handed a series of arguments via the ??<<??
      operators. It prints out these arguments in left-to-right order. The
      special iostream function endl outputs the line and a newline. With
      iostreams, you can string together a series of arguments like this,
      which makes the class easy to use.
      -->
      <para>
	El objeto <varname>cout</varname> maneja una serie de argumentos
	por medio de los operadores <oper>&lt;&lt;</oper>, que imprime
	los argumentos de izquierda a derecha. La función especial
	<function>endl</function> provoca un salto de línea. Con los
	iostreams se puede encadenar una serie de argumentos como aquí,
	lo que hace que se una clase fácil de usar.
      </para>

      <!--
      In C, text inside double quotes is traditionally called a ??string.??
      However, the Standard C++ library has a powerful class called string for
      manipulating text, and so I shall use the more precise term character
      array for text inside double quotes.
      -->
      <para>
	En C, el texto que se encuentra entre comillas dobles se
	denomina <quote>cadena</quote>
	(<foreignphrase>string</foreignphrase>). Sin embargo, la
	librería Estándar de C++ tiene una poderosa clase llamada
	<classname>string</classname> para manipulación de texto, por
	lo que usaremos el término más preciso <emphasis>array de
	caracteres</emphasis> para el texto que se encuentre entre
	dobles comillas.
      </para>

      <!--
      The compiler creates storage for character arrays and stores the ASCII
      equivalent for each character in this storage. The compiler
      automatically terminates this array of characters with an extra piece of
      storage containing the value 0 to indicate the end of the character
      array.
      -->
      <para>
	El compilador pide espacio de memoria para los arrays de
	caracteres y guarda el equivalente ASCII para cada caracter en
	este espacio. El compilador finaliza automáticamente este array
	de caracteres añadiendo el valor 0 para indicar el final.
      </para>

      <!--
      Inside a character array, you can insert special characters by using
      escape sequences. These consist of a backslash (\) followed by a special
      code. For example \n means newline. Your compiler manual or local C
      guide gives a complete set of escape sequences; others include \t (tab),
      \\ (backslash), and \b (backspace).
      -->
      <para>
	Dentro del array de caracteres, se pueden insertar caracteres
	especiales usando las <emphasis>secuencias de escape</emphasis>.
	Consisten en una barra invertida (<literal>\</literal>) seguida
	de un código especial. por ejemplo <literal>\n</literal>
	significa salto de línea. El manual del compilador o la guía
	concreta de C ofrece una lista completa de secuencia; entre
	otras se incluye: <literal>\t</literal> (tabulador),
	<literal>\\</literal> (barra invertida), y <literal>\b</literal>
	(retroceso).
      </para>

      <!--
      Notice that the statement can continue over multiple lines, and that the
      entire statement terminates with a semicolon
      -->
      <para>
	Tenga en cuenta que la sentencia puede continuar en otras
	líneas, y la sentencia completa termina con un punto y coma.
      </para>

      <!--
      Character array arguments and constant numbers are mixed together in the
      above cout statement. Because the operator << is overloaded with a
      variety of meanings when used with cout, you can send cout a variety of
      different arguments and it will ??figure out what to do with the
      message.??
      -->
      <para>
	Los argumentos de tipo array de caracteres y los números
	constantes están mezclados en la sentencia
	<varname>cout</varname> anterior. Como el operador
	<oper>&lt;&lt;</oper> está sobrecargado con varios significados
	cuando se usa con <varname>cout</varname>, se pueden enviar
	distintos argumentos y <varname>cout</varname> se encargará de
	mostrarlos.
      </para>

      <!-- Throughout this book you??ll notice that the first line of
      each file will be a comment that starts with the characters that
      start a comment (typically //), followed by a colon, and the last
      line of the listing will end with a comment followed by
      FIXME:LETRA:??/:~??. This is a technique I use to allow easy
      extraction of information from code files (the program to do this
      can be found in volume two of this book, at
      www.BruceEckel.com). The first line also has the name and location
      of the file, so it can be referred to in text and in other files,
      and so you can easily locate it in the source code for this book
      (which is downloadable from www.BruceEckel.com).  -->
      <para>
	A lo largo de este libro notará que la primera línea de cada
	fichero es un comentario (empezando normalmente con
	<literal>//</literal>), seguido de dos puntos, y la última línea
	de cada listado de código acaba con un comentario seguido de
	<quote>/-</quote>. Se trata de una una técnica que uso para
	extraer fácilmente información de los ficheros fuente (el
	programa que lo hace se puede encontrar en el Volumen 2 de este
	libro, en <ulink
	url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>). La
	primera línea también tiene el nombre y localización del
	fichero, por lo que se puede localizar fácilmente en los fichero
	de código fuente dele libro (que también se puede descargar de
	<ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>).
      </para>

    </sect2>
    

<!-- Revisando David Villa -->


    <sect2>
      <!-- Running the compiler -->
      <title>Ejecutar al compilador</title>

      <!--
      After downloading and unpacking the book??s source code, find the
      program in the subdirectory CO2. Invoke the compiler with Hello.cpp as
      the argument. For simple, one-file programs like this one, most
      compilers will take you all the way through the process. For example, to
      use the GNU C++ compiler (which is freely available on the Internet),
      you write:
      -->
      <para>
	Después de descargar y desempaquetar el código fuente del
	libro, encuentre el programa en el subdirectorio
	<filename>CO2</filename>. Invoque el compilador con
	<filename>Hello.cpp</filename> como parámetro. La mayoría de
	los compiladores le mantienen al margen de todo el proceso
	cuando los programas constan de un único fichero. Por
	ejemplo, para usar el compilador GNU C++ (que está
	disponible en Internet), escriba:
      </para>

      <para>
	<prompt>g++ Hello.cpp</prompt>
      </para>

      <!--
      Other compilers will have a similar syntax; consult your compiler??s
      documentation for details.
      -->
      <para>
	Otros compiladores tendrán una sintaxis similar aunque
	deberá consultar la documentación para los detalles
	particulares.
      </para>


    </sect2>
  </sect1>
  
  <sect1>
    <!-- More about iostreams -->
    <title>Más sobre iostream</title>

    <!--
    So far you have seen only the most rudimentary aspect of the iostreams
    class. The output formatting available with iostreams also includes
    features such as number formatting in decimal, octal, and
    hexadecimal. Here??s another example of the use of iostreams:
    -->
    <para>
      Hasta ahora sólo ha visto los aspectos más rudimentarios de la
      clase iostream. El formato de salida que está disponible con
      los iostreams también incluye características como el formateo
      de números en decimal, octal, y hexadecimal. Aquí tenemos otro
      ejemplo del uso de los iostreams:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Stream2.cpp"/>
</programlisting>

    <!--
    This example shows the iostreams class printing numbers in decimal,
    octal, and hexadecimal using iostream manipulators (which don??t print
    anything, but change the state of the output stream). The formatting of
    floating-point numbers is determined automatically by the compiler. In
    addition, any character can be sent to a stream object using a cast to a
    char (a char is a data type that holds single characters). This cast
    looks like a function call: char( ), along with the character??s ASCII
    value. In the program above, the char(27) sends an ??escape?? to cout.
    -->
    <para>
      Este ejemplo muestra cómo la clase iostream imprime números en
      decimal, octal, y hexadecimal usando
      <emphasis>manipuladores</emphasis> (los cuales no imprimen
      nada, pero cambian el estado del flujo de salida). El formato
      de los números en coma flotante es determinado automáticamente
      por el compilador. En suma, cualquier caracter puede ser
      enviado a un objeto stream usando un
      <foreignphrase>cast</foreignphrase> (molde) a
      <literal>char</literal> (un <literal>char</literal> es un tipo
      de datos que maneja un sólo caracter). Este
      <foreignphrase>cast</foreignphrase> se asemeja a una llamada a
      función: <literal>char()</literal>, que devuelve un valor
      ASCII. En el programa de arriba, el
      <function>char(27)</function> envía un <quote>escape</quote> a
      <function>cout</function>.
    </para>


    <sect2>
      <!-- Character array concatenation -->
      <title>Concatenar vectores de caracteres</title>

      <!--
      An important feature of the C preprocessor is character array
      concatenation. This feature is used in some of the examples in this
      book. If two quoted character arrays are adjacent, and no punctuation is
      between them, the compiler will paste the character arrays together into
      a single character array. This is particularly useful when code listings
      have width restrictions:
      -->
      <para>
	Una característica importante del preprocesador de C es la
	<emphasis>concatenación de arrays de caracteres</emphasis>.
	Esta característica es usada en algunos de los ejemplos de
	este libro. Si dos arrays de caracteres entrecomillados se
	encuentran adjuntos, sin signos de puntuación entre ellos,
	el compilador pegará los arrays en un único array de
	caracteres. Esto es particularmente útil cuando los listados
	de código tienen restricciones de anchura.
      </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Concat.cpp"/>
</programlisting>

      <!--
      At first, the code above can look like an error because there??s no
      familiar semicolon at the end of each line. Remember that C and C++ are
      free-form languages, and although you??ll usually see a semicolon at the
      end of each line, the actual requirement is for a semicolon at the end
      of each statement, and it??s possible for a statement to continue over
      several lines.
      -->
      <para>
	Al principio, el código de arriba puede parecer erróneo
	porque no está el ya familiar punto y coma al final de cada
	línea. Recuerde que C y C++ son lenguajes libres de forma, y
	aunque normalmente verá un punto y coma al final de cada
	línea, el requisito actual es que se encuentre un punto y
	coma al final de cada sentencia, por lo que es posible
	encontrarse con una sentencia que ocupe varias líneas.
      </para>
    </sect2>
    
    <sect2>
      <!-- Reading input -->
      <title>Leer de la entrada</title>

      <!--
      The iostreams classes provide the ability to read input. The object used
      for standard input is cin (for ??console input??). cin normally expects
      input from the console, but this input can be redirected from other
      sources. An example of redirection is shown later in this chapter.
      -->
      <para>
	Las clases iostream nos proporcionan la habilidad de leer de
	la entrada. El objeto usado para la entrada estándar es
	<literal>cin</literal> (de <quote><foreignphrase>console
	    input</foreignphrase></quote>). <literal>cin</literal>
	normalmente espera la entrada de la consola, pero esta
	entrada puede ser redirigida a otras fuentes. Un ejemplo de
	redirección se muestra más tarde en este capítulo.
      </para>

      <!--
      The iostreams operator used with cin is >>. This operator waits for the
      same kind of input as its argument. For example, if you give it an
      integer argument, it waits for an integer from the console. Here??s an
      example:
      -->
      <para>
	El operador que usa iostream con el objeto
	<literal>cin</literal> es &gt;&gt;. Este operador espera
	como parámetro alguna tipo de entrada. Por ejemplo, si
	introduce un parámetro entero, espera un entero de la
	consola. Aquí hay un ejemplo:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Numconv.cpp"/>
</programlisting>

      <!--
      This program converts a number typed in by the user into octal and
      hexadecimal representations.
      -->
      <para>
	Este programa convierte un número introducido por el usuario
	en su representación octal y hexadecimal.
      </para>


    </sect2>
    
    <sect2>
      <!-- Calling other programs -->
      <title>Llamar a otros programas</title>

      <!--
      While the typical way to use a program that reads from standard input
      and writes to standard output is within a Unix shell script or DOS batch
      file, any program can be called from inside a C or C++ program using the
      Standard C system( ) function, which is declared in the header file
      -->
      <para>
	Mientras que el modo típico de usar un programa que lee de
	la entrada estándar y escribe en la salida estándar es
	dentro de un shell script Unix o en un fichero batch de DOS,
	cualquier programa puede ser llamado desde dentro de un
	programa C o C++ usando la llamada a la función estándar
	<function>system()</function> que debe ser declarada  en el
	fichero cabecera <filename>&lt;cstdlib&gt;:</filename>.
      </para>

<programlisting>
<xi:include parse="text" href="./code/C02/CallHello.cpp"/>
</programlisting>

      <!--
      To use the system( ) function, you give it a character array that you
      would normally type at the operating system command prompt. This can
      also include command-line arguments, and the character array can be one
      that you fabricate at run time (instead of just using a static character
      array as shown above). The command executes and control returns to the
      program.
      -->
      <para>
	Para usar la función <function>system()</function>, hay que
	dar el array de caracteres que desearía que se ejecutara en
	el prompt del sistema operativo. Puede incluir los
	parámetros que utilizaría en la línea de comandos, y el
	array de caracteres puede ser fabricado en tiempo de
	ejecución (en vez de usar un array de caracteres estático
	como se mostraba arriba). El comando se ejecuta y el control
	vuelve al programa.
      </para>

      <!--
      This program shows you how easy it is to use plain C library functions
      in C++; just include the header file and call the function. This upward
      compatibility from C to C++ is a big advantage if you are learning the
      language starting from a background in C.
      -->
      <para>
	Este programa le muestra lo fácil que es usar C plano en
	C++; sólo incluya la cabecera y utilice la función. Esta
	compatibilidad ascendente entre el C y el C++ es una gran
	ventaja si está aprendiendo C++ y ya tenía conocimientos de
	C.
      </para>

    </sect2>
  </sect1>
  
  <sect1>
    <!-- Introducing strings -->
    <title>Introducir cadenas</title>

        <!--
    While a character array can be fairly useful, it is quite limited. It??s
    simply a group of characters in memory, but if you want to do anything
    with it you must manage all the little details. For example, the size of
    a quoted character array is fixed at compile time. If you have a
    character array and you want to add some more characters to it, you??ll
    need to understand quite a lot (including dynamic memory management,
    character array copying, and concatenation) before you can get your
    wish. This is exactly the kind of thing we??d like to have an object do
    for us.
    -->
    <para>
      Un array de caracteres puede ser bastante útil, aunque está
      bastante limitado. Simplemente son un grupo de caracteres en
      memoria, pero si quiere hacer algo útil, debe manejar todos
      los pequeños detalles. Por ejemplo, el tamaño un array de
      caracteres es fijo en tiempo de compilación. Si tiene un array
      de caracteres y quiere añadirle más caracteres, necesitará
      saber un montón (incluso manejo dinámico de memoria, copia de
      array de caracteres, y concatenación) antes de conseguir lo
      que desea. Esto es exactamente la clase de cosas que
      desearíamos que hiciera un objeto por nosotros.
    </para>

    <!--
    The Standard C++ string class is designed to take care of (and hide) all
    the low-level manipulations of character arrays that were previously
    required of the C programmer. These manipulations have been a constant
    source of time-wasting and errors since the inception of the C
    language. So, although an entire chapter is devoted to the string class
    in Volume 2 of this book, the string is so important and it makes life
    so much easier that it will be introduced here and used in much of the
    early part of the book.
    -->
    <para>
      La clase <classname>string</classname> (cadena) del C++
      Estándar ha sido diseñada para que se encargue y oculte las
      manipulaciones a bajo nivel de los arrays de caracteres que
      antes tenía que realizar el programador de C. Estas
      manipulaciones han sido una fuente de constantes pérdidas de
      tiempo y errores desde los orígenes del lenguaje C. Aunque hay
      un capítulo entero dedicado a la clase
      <classname>string</classname> en el Volumen 2 de este libro,
      las cadenas <command>(string)</command> son demasiado
      importantes y facilitan mucho la vida por lo que serán
      introducidas aquí y usadas posteriormente a lo largo de todo
      el libro.
    </para>

    <!--
    To use strings you include the C++ header file <string>. The string
    class is in the namespace std so a using directive is necessary. Because
    of operator overloading, the syntax for using strings is quite
    intuitive:
    -->
    <para>
      Para usar las cadenas debe incluir el fichero de cabecera
      <command>&lt;string&gt;</command>. La clase
      <classname>string</classname> se encuentra en el espacio de
      nombres <literal>std</literal> por lo que el uso de la
      directiva <kw>using</kw> es necesario. Gracias a la
      sobrecarga de operadores, la sintaxis del uso de las cadenas
      es muy intuitiva:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/HelloStrings.cpp"/>
</programlisting>

    <!--
    The first two strings, s1 and s2, start out empty, while s3 and s4 show
    two equivalent ways to initialize string objects from character arrays
    (you can just as easily initialize string objects from other string
    objects).
    -->
    <para>
      Las primeras dos cadenas, <varname>s1</varname> y
      <varname>s2</varname> comienzan vacías, mientras que
      <varname>s3</varname> y <varname>s4</varname> nos muestran dos
      formas de inicializar los objetos
      <classname>string</classname> con arrays de caracteres (puede
      inicializar objetos <classname>string</classname> con otros
      objetos <classname>string</classname>).
    </para>

    <!--
    You can assign to any string object using ??=??. This replaces the
    previous contents of the string with whatever is on the right-hand side,
    and you don??t have to worry about what happens to the previous contents
    ? that??s handled automatically for you. To combine strings you simply
    use the ??+?? operator, which also allows you to combine character
    arrays with strings. If you want to append either a string or a
    character array to another string, you can use the operator ??+=??.
    Finally, note that iostreams already know what to do with strings, so
    you can just send a string (or an expression that produces a string,
    which happens with s1 + s2 + "!") directly to cout in order to print it.
    -->
    <para>
      Usted puede asignar a los objetos <classname>string</classname>
      usando el símbolo <quote>=</quote>. Esto sustituye el contenido
      previo de la cadena con lo que se encuentra en el lado derecho de
      la igualdad, y usted no debe preocuparse de lo que ocurre con el
      contenido anterior porque es controlado automáticamente. Para
      combinar las cadenas simplemente debe usar el operador de suma
      <quote>+</quote>, que tambien le permite concatenar cadenas
      (<classname>strings</classname>) con arrays de caracteres. Si
      quiere añadir una cadena o un array de caracteres a otra cadena,
      puede usar el operador <quote>+=</quote>. Finalmente, dése cuenta
      que iostream sabe como tratar las cadenas, por lo que usted puede
      enviar una cadena (o una expresión que produzca un
      <classname>string</classname>, que es lo que sucede con <code>s1 +
      s2 + "!"</code>>) directamente a <function>cout</function> para
      imprimirla.
    </para>


  </sect1>
  

  <sect1>
    <!-- Reading and writing files -->
    <title>Lectura y escritura de ficheros</title>

    <!--
    In C, the process of opening and manipulating files requires a lot of
    language background to prepare you for the complexity of the
    operations. However, the C++ iostream library provides a simple way to
    manipulate files, and so this functionality can be introduced much
    earlier than it would be in C.
    -->
    <para>
      En C, el proceso de abrir y manipular ficheros requieren un
      gran transfondo del lenguaje para prepararle para la
      complejidad de las operaciones. Sin embargo, la librería
      iostream de C++ proporciona una forma simple de manejar
      ficheros por lo que puede ser introducido mucho antes que lo
      sería en C.
    </para>

    <!--
    To open files for reading and writing, you must include
    generally prudent to explicitly include <iostream> if you??re planning
    to use cin, cout, etc.
    -->
    <para>
      Hay que incluir la librería <classname>fstream</classname> para
      poder manejar ficheros. Aunque esto implica la automática
      inclusión de la librería <classname>iostream</classname>, es
      prudente incluir <classname>iostream</classname> si usted planea
      usar <function>cin</function>, <function>cout</function>, etc.
    </para>

    <!--
    To open a file for reading, you create an ifstream object, which then
    behaves like cin. To open a file for writing, you create an ofstream
    object, which then behaves like cout. Once you??ve opened the file, you
    can read from it or write to it just as you would with any other
    iostream object. It??s that simple (which is, of course, the whole
    point).
    -->
    <para>
      Para abrir un fichero para lectura, usted debe crear un objeto
      ifstream que será usado como el <function>cin</function>. Para
      crear un fichero de escritura, se genera un objeto
      <classname>ofstream</classname> que se comporta como el
      <function>cout</function>. Una vez que tiene abierto el fichero
      puede leer o escribir en él como si usara otro objeto
      <classname>iostream</classname>. Así de simple, lo cual es, por
      supuesto, el objetivo.
    </para>

    <!--
    One of the most useful functions in the iostream library is getline( ),
    which allows you to read one line (terminated by a newline) into a
    string object[28]. The first argument is the ifstream object you??re
    reading from and the second argument is the string object. When the
    function call is finished, the string object will contain the line.
    -->
    <para>
      Una de las más útiles funciones que se encuentran en la
      librería <classname>iostream</classname> es
      <function>getline()</function>, que permite leer una línea
      (terminada en nueva línea) y guardarla en un objeto
      <classname>string</classname> 
      <footnote>
	<!--
	[28] There are actually a number of variants of getline( ),
	which will be discussed thoroughly in the iostreams chapter in
	Volume 2.
	-->
	<para>
	  Actualmente existen variantes de
	  <function>getline()</function>, las cuales serán profusamente
	  discutidas en el capítulo de iostreams en el Volumen 2
	</para>
      </footnote>. El primer argumento es el objeto
      <classname>ifstream</classname> que es de donde se está leyendo la
      información y el segundo argumento es el objeto
      <classname>string</classname>. Cuando la llamada a la función se
      ha terminado, el objeto <classname>string</classname> contendrá la
      línea capturada.
    </para>

    <!--
    Here??s a simple example, which copies the contents of one file into
    another:
    -->
    <para>
      Aquí hay un ejemplo que copia el contenido de un fichero en
      fichero nuevo.
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Scopy.cpp"/>
</programlisting>

    <!--
    To open the files, you just hand the ifstream and ofstream objects the
    file names you want to create, as seen above.
    -->
    <para>
      Para abrir los ficheros, simplemente debe controlar los
      nombres de fichero que se usan en la creación de los objetos
      <classname>ifstream</classname> y
      <classname>ofstream</classname>.
    </para>

    <!--
    There is a new concept introduced here, which is the while
    loop. Although this will be explained in detail in the next chapter, the
    basic idea is that the expression in parentheses following the while
    controls the execution of the subsequent statement (which can also be
    multiple statements, wrapped inside curly braces). As long as the
    expression in parentheses (in this case, getline(in, s)) produces a
    ??true?? result, then the statement controlled by the while will
    continue to execute. It turns out that getline( ) will return a value
    that can be interpreted as ??true?? if another line has been read
    successfully, and ??false?? upon reaching the end of the input. Thus,
    the above while loop reads every line in the input file and sends each
    line to the output file.
    -->
    <para>
      Aquí se introduce un nuevo concepto: el bucle
      <kw>while</kw>. Aunque será explicado en detalle en
      el siguiente capítulo, la idea básica consiste en que la
      expresión entre paréntesis que sigue al
      <kw>while</kw> controla la ejecución de la sentencia
      siguiente (pueden ser múltiples sentencias encerradas entre
      llaves). Mientras la expresión entre paréntesis (en este caso
      <function>getline(in,s)</function> produzca un resultado
      <quote>verdadero</quote>, entonces las sentencias controladas
      por el <kw>while</kw> se
      ejecutarán. <function>getline()</function> devolverá un valor
      que puede ser interpretado como <quote>verdadero</quote> si se
      ha leido otra línea de forma satisfactoria, y
      <quote>falso</quote> cuando se alcance el final de la
      entrada. Lo que quiere decir que el <kw>while</kw>
      de arriba lee todas las líneas del fichero de entrada y las
      envía al fichero de salida.
    </para>

    <!--
    getline( ) reads in the characters of each line until it discovers a
    newline (the termination character can be changed, but that won??t be an
    issue until the iostreams chapter in Volume 2). However, it discards the
    newline and doesn??t store it in the resulting string object. Thus, if
    we want the copied file to look just like the source file, we must add
    the newline back in, as shown.
    -->
    <para>
      <function>getline()</function> lee los caracteres de cada
      línea hasta que descubre una nueva línea. (el caracter de
      terminación puede ser cambiado pero no será tratado hasta el
      capítulo sobre iostreams en el Volumen 2). Sin embargo,
      desecha el caracter de nueva línea y no lo almacena en el
      objeto <classname>string</classname>. Por lo que si queremos
      copiar el fichero de forma idéntica al fichero original,
      debemos añadir el caracter de nueva línea como se muestra
      arriba.
    </para>

    <!--
    Another interesting example is to copy the entire file into a single
    string object:
    -->
    <para>
      Otro interesante ejemplo es copiar el fichero entero en un
      único objeto <classname>string</classname>:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/FillString.cpp"/>
</programlisting>

    <!--
    Because of the dynamic nature of strings, you don??t have to worry about
    how much storage to allocate for a string; you can just keep adding
    things and the string will keep expanding to hold whatever you put into
    it.
    -->
    <para>
      Debido a la naturaleza dinámica de los
      <classname>strings</classname>, no nos tenemos que preocupar
      de la cantidad de almacenamiento a reservar para el
      <literal>string</literal>. Usted sólo tiene que añadir cosas y
      el <literal>string</literal> irá expandiéndose para manejar lo
      que le introduzca.
    </para>

    <!--
    One of the nice things about putting an entire file into a string is
    that the string class has many functions for searching and manipulation
    that would then allow you to modify the file as a single
    string. However, this has its limitations. For one thing, it is often
    convenient to treat a file as a collection of lines instead of just a
    big blob of text. For example, if you want to add line numbering it??s
    much easier if you have each line as a separate string object. To
    accomplish this, we??ll need another approach.
    -->
    <para>
      Una de las cosas agradables de poner el fichero entero en una
      cadena es que la clase <classname>string</classname> nos
      proporciona funciones para la búsqueda y manipulación que le
      permiten modificar el fichero como si fuera una simple
      línea. Sin embargo, tiene sus limitaciones. Por un lado, a
      menudo, es conveniente tratar un fichero como una colección de
      líneas en vez de un gran bloque de texto. Por ejemplo, si
      usted quiere añadir numeración de líneas es mucho más fácil
      si ya tiene cada línea en un objeto <classname>string</classname>
      por separado. Para realizarlo, necesitamos otro concepto.
    </para>

  </sect1>
  
  <sect1>
    <!-- Introducing vector -->
    <title>Introducción a los vectores</title>

    <!--
    With strings, we can fill up a string object without knowing how much
    storage we??re going to need. The problem with reading lines from a file
    into individual string objects is that you don??t know up front how many
    strings you??re going to need ? you only know after you??ve read the
    entire file. To solve this problem, we need some sort of holder that
    will automatically expand to contain as many string objects as we care
    to put into it.
    -->
    <para>
      Con las cadenas, podemos rellenar un objeto
      <classname>string</classname> sin saber cuanto espacio vamos a
      necesitar. El problema de introducir líneas de un fichero en
      objetos <classname>string</classname> es que no conocemos cuántas
      cadenas vamos a necesitar - sólamente lo sabemos cuando ya
      hemos leido el fichero entero. Para resolver este problema
      necesitamos un nuevo tipo de datos que pueda crecer
      automáticamente para contener las cadenas que le vayamos
      introduciendo.
    </para>

    <!--
    In fact, why limit ourselves to holding string objects? It turns out
    that this kind of problem ? not knowing how many of something you have
    while you??re writing a program ? happens a lot. And this ??container??
    object sounds like it would be more useful if it would hold any kind of
    object at all! Fortunately, the Standard C++ Library has a ready-made
    solution: the standard container classes. The container classes are one
    of the real powerhouses of Standard C++.
    -->
    <para>
      De hecho, ¿por qué limitarnos a manejar objetos
      <classname>string</classname>? Parece que este tipo de
      problema - no saber la cantidad de cosas a manejar mientras
      está escribiendo el problema - sucede un montón de veces. Y
      este objeto <quote>contenedor</quote> parecería más útil si
      pudiera manejar <emphasis>cualquier clase de
	objeto</emphasis>. Afortunadamente, la librería estándar de
      C++ tiene una solución: las clases
      <classname>container</classname> (contenedores). Las clases
      contenedor son un de los puntos fuertes del C++ estándar.
    </para>

    <!--
    There is often a bit of confusion between the containers and algorithms
    in the Standard C++ Library, and the entity known as the STL. The
    Standard Template Library was the name Alex Stepanov (who was working at
    Hewlett-Packard at the time) used when he presented his library to the
    C++ Standards Committee at the meeting in San Diego, California in
    Spring 1994. The name stuck, especially after HP decided to make it
    available for public downloads. Meanwhile, the committee integrated it
    into the Standard C++ Library, making a large number of changes. STL's
    development continues at Silicon Graphics (SGI; see
    http://www.sgi.com/Technology/STL). The SGI STL diverges from the
    Standard C++ Library on many subtle points. So although it's a popular
    misconception, the C++ Standard does not ??include?? the STL. It can be
    a bit confusing since the containers and algorithms in the Standard C++
    Library have the same root (and usually the same names) as the SGI
    STL. In this book, I will say ??The Standard C++ Library?? or ??The
    Standard Library containers,?? or something similar and will avoid the
    term ??STL.??
    -->
    <para>
      A menudo existe un poco de confusión entre los contenedores y
      los algoritmos en la librería estándar de C++, y la STL. La
      Standard Template Library fue el nombre que usó Alex Stepanov
      (que en aquella época estaba trabajando en Hewlett-Packard)
      cuando presentó su librería al Comité del C++ Estándar en el
      encuentro en San Diego, California, en la primavera de
      1994. El nombre sobrevivió, especialmente después de que HP
      decidiera dejarlo disponible para la descarga
      pública. Posteriormente el comité integró las STL en la
      librería estándar de C++ haciendo un gran número de
      cambios. El desarrollo de las STL continuan en Silicon
      Graphics (SGI; ver
      <ulink url="http://www.sgi.com/Technology/STL">http://www.sgi.com/Technology/STL)</ulink>. Las SGI STL
      divergen de la librería estándar de C++ en muchos sutiles
      puntos. Aunque es una creencia ampliamente generalizada, el
      C++ estándar no "incluye" las STL. Puede ser confuso debido a
      que los contenedores y los algoritmos en el C++ estándar
      tienen la misma raiz (y a menudo el mismo nombre) que en el
      SGI STL. En este libro, intentaré decir <quote>la librería
	estándar de C++</quote> o <quote>la librería estándar de
	contenedores</quote>, o algo similar y eludiré usar el término
      STL.
    </para>

    <!--
    Even though the implementation of the Standard C++ Library containers
    and algorithms uses some advanced concepts and the full coverage takes
    two large chapters in Volume 2 of this book, this library can also be
    potent without knowing a lot about it. It??s so useful that the most
    basic of the standard containers, the vector, is introduced in this
    early chapter and used throughout the book. You??ll find that you can do
    a tremendous amount just by using the basics of vector and not worrying
    about the underlying implementation (again, an important goal of
    OOP). Since you??ll learn much more about this and the other containers
    when you reach the Standard Library chapters in Volume 2, it seems
    forgivable if the programs that use vector in the early portion of the
    book aren??t exactly what an experienced C++ programmer would do. You??
    ll find that in most cases, the usage shown here is adequate.
    -->
    <para>
      A pesar de que la implementación de los contenedores y
      algoritmos de la librería estándar de C++ usan algunos
      conceptos avanzados, que son ampliamente cubiertos en dos
      largos capítulos en el segundo volumen de este libro, esta
      librería puede ser potente sin saber mucho sobre ella. Es tan
      útil que el más básico de los contenedores estándar, el
      <classname>vector</classname>, es introducido en este capítulo
      y será usado a lo largo de todo el libro. Verá que puede hacer
      muchas cosas con el <classname>vector</classname> y no saber
      cómo está implementado (de nuevo, una de las metas de la
      POO). Debe ser perdonable si los programas que usan
      <classname>vector</classname> en estos primeros capítulos del
      libro no son exactamente como un experimentado programador los
      haría, como comprobará en el volumen 2. Aún así, encontrará
      que en la mayoría de los casos el uso mostrado aquí es
      adecuado.
    </para>

    <!--
    The vector class is a template, which means that it can be efficiently
    applied to different types. That is, we can create a vector of shapes, a
    vector of cats, a vector of strings, etc. Basically, with a template you
    can create a ??class of anything.?? To tell the compiler what it is that
    the class will work with (in this case, what the vector will hold), you
    put the name of the desired type in ??angle brackets,?? which means ??<??
    and ??>??. So a vector of string would be denoted vector<string>. When
    you do this, you end up with a customized vector that will hold only
    string objects, and you??ll get an error message from the compiler if
    you try to put anything else into it.
    -->
    <para>
      La clase <classname>vector</classname> es una
      <emphasis>plantilla</emphasis>, lo que significa que puede ser
      aplicada a tipos de datos diferentes. Es decir, podemos crear
      un <classname>vector</classname> de
      <classname>figuras</classname>, un
      <classname>vector</classname> de <classname>gatos</classname>,
      un <classname>vector</classname> de
      <classname>strings</classname>, etc. Básicamente, con un
      template usted puede crear un vector de "cualquier
      clase". Para decirle al compilador con qué clase trabajará (en
      este caso que va a manejar el vector), hay que poner el nombre
      del tipo deseado entre <quote>llaves angulares</quote>. Por lo
      que un <classname>vector</classname> de
      <classname>strings</classname> será denotado como
      <classname>vector&lt;string&gt;</classname>. Cuando hace esto,
      crea un vector a medida que solamente contendrá objetos
      <classname>string</classname>, y recibirá un mensaje de error del
      compilador si intenta poner otra cosa en él.
    </para>

    <!--
    Since vector expresses the concept of a ??container,?? there must be a
    way to put things into the container and get things back out of the
    container. To add a brand-new element on the end of a vector, you use
    the member function push_back( ). (Remember that, since it??s a member
    function, you use a ??.?? to call it for a particular object.) The
    reason the name of this member function might seem a bit verbose ?
    push_back( ) instead of something simpler like ??put?? ? is because
    there are other containers and other member functions for putting new
    elements into containers. For example, there is an insert( ) member
    function to put something in the middle of a container. vector supports
    this but its use is more complicated and we won??t need to explore it
    until Volume 2 of the book. There??s also a push_front( ) (not part of
    vector) to put things at the beginning. There are many more member
    functions in vector and many more containers in the Standard C++
    Library, but you??ll be surprised at how much you can do just knowing
    about a few simple features.
    -->
    <para>
      Como el <classname>vector</classname> expresa el concepto de
      <quote>contenedor</quote>, debe existir una manera de meter
      cosas en él y sacar cosas de él. Para añadir un nuevo elemento
      al final del vector, usamos la función miembro
      <function>push_back()</function>. Recuerde que, como es una
      función miembro, hay que usar un '.' para llamarla desde un
      objeto particular. La razón de que el nombre de la función
      parezca un poco extraño - <function>push_back()</function> en
      vez de algo más simple como <function>put</function> - es
      porque existen otros contenedores y otras funciones miembro
      para poner nuevos elementos en los contenedores. Por ejemplo,
      hay una función <function>insert()</function> para poner algo
      en medio de un contenedor. <classname>vector</classname> la
      soporta pero su uso es más complicado y no necesitamos
      explorarla hasta el segundo volumen del libro. También hay un
      <function>push_front()</function> (que no es parte de
      <classname>vector</classname>) para poner cosas al
      principio. Hay muchas más funciones miembro en
      <classname>vector</classname> y muchos más contenedores en la
      librería estándar, pero le sorprenderá ver la de cosas que se
      pueden hacer con sólo un par de características básicas.
    </para>

    <!--
    So you can put new elements into a vector with push_back( ), but how do
    you get these elements back out again? This solution is more clever and
    elegant ? operator overloading is used to make the vector look like an
    array. The array (which will be described more fully in the next
    chapter) is a data type that is available in virtually every programming
    language so you should already be somewhat familiar with it. Arrays are
    aggregates, which mean they consist of a number of elements clumped
    together. The distinguishing characteristic of an array is that these
    elements are the same size and are arranged to be one right after the
    other. Most importantly, these elements can be selected by ??indexing,??
    which means you can say ??I want element number n?? and that element
    will be produced, usually quickly. Although there are exceptions in
    programming languages, the indexing is normally achieved using square
    brackets, so if you have an array a and you want to produce element
    five, you say a[4] (note that indexing always starts at zero).
    -->
    <para>
      Entonces usted puede introducir elementos en un
      <classname>vector</classname> con
      <function>push_back()</function> pero ¿cómo puede sacar esos
      elementos? La solución es inteligente y elegante: se usa la
      sobrecarga de operadores para que el
      <classname>vector</classname> se parezca a un
      <literal>array</literal>. El array (que será descrito de forma
      más completa en el siguiente capítulo) es un tipo de datos que
      está disponible en virtualmente cualquier lenguaje de
      programación por lo que debería estar familiarizado con él.Los
      arrays son <emphasis>agregados</emphasis> lo que significa que
      consisten en un número de elementos agrupados juntos. La
      característica distintiva de un array es que estos elementos
      tienen el mismo tamaño y están organizados uno junto a
      otro. Todavía es más importante, que pueden ser seleccionados
      mediante un índice, lo que significa que puede decir:
      <quote>Quiero el elemento número n</quote> y el elemento será
      producido, normalmente de forma rápida. A pesar de que existen
      excepciones en los lenguajes de programación, normalmente se
      indica la "indexación" mediante corchetes, de tal forma que si
      usted tiene un array <varname>a</varname> y quiere obtener el
      quinto elemento, sólo tiene que decir <varname>a[4]</varname>
      (note que la indexación siempre empieza en cero).
    </para>

    <!--
    This very compact and powerful indexing notation is incorporated into
    the vector using operator overloading, just like ??<<?? and ??>>?? were
    incorporated into iostreams. Again, you don??t need to know how the
    overloading was implemented ? that??s saved for a later chapter ? but it??
    s helpful if you??re aware that there??s some magic going on under the
    covers in order to make the [ ] work with vector.
    -->
    <para>
      Esta forma compacta y poderosa de notación indexada ha sido
      incorporada al <classname>vector</classname> mediante la
      sobrecarga de operadores como el <quote>&lt;&lt;</quote> y el
      <quote>&gt;&gt;</quote> que pertenecían a los iostreams. De
      nuevo, usted no necesita saber como se ha implementado la
      sobrecarga de operadores - lo dejamos para un capítulo
      posterior - pero es útil que sea consciente que hay algo de
      magia detrás de todo esto para conseguir que los corchetes
      funcionen con el <classname>vector</classname>.
    </para>

    <!--
    With that in mind, you can now see a program that uses vector. To use a
    vector, you include the header file <vector>:
    -->
    <para>
      Con todo esto en mente, usted puede ver un programa que usa la
      clase <classname>vector</classname>. Para usar un vector, hay
      que incluir el fichero de cabecera
      <filename>&lt;vector&gt;:</filename>
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Fillvector.cpp"/>
</programlisting>


    <!--
    Much of this program is similar to the previous one; a file is opened
    and lines are read into string objects one at a time. However, these
    string objects are pushed onto the back of the vector v. Once the while
    loop completes, the entire file is resident in memory, inside v.
    -->
    <para>
      Casi todo este programa es similar al anterior; un fichero es
      abierto y las líneas son leidas en objetos
      <classname>string</classname> (uno cada vez). Sin embargo,
      estos objetos <classname>string</classname> son introducidos
      al final del <classname>vector</classname>
      <varname>v</varname>. Una vez que el bucle
      <kw>while</kw> ha terminado, el fichero entero se
      encuentra en memoria dentro de <varname>v</varname>.
    </para>


    <!--
    The next statement in the program is called a for loop. It is similar to
    a while loop except that it adds some extra control. After the for,
    there is a ??control expression?? inside of parentheses, just like the
    while loop. However, this control expression is in three parts: a part
    which initializes, one that tests to see if we should exit the loop, and
    one that changes something, typically to step through a sequence of
    items. This program shows the for loop in the way you??ll see it most
    commonly used: the initialization part int i = 0 creates an integer i to
    use as a loop counter and gives it an initial value of zero. The testing
    portion says that to stay in the loop, i should be less than the number
    of elements in the vector v. (This is produced using the member function
    size( ), which I just sort of slipped in here, but you must admit it has
    a fairly obvious meaning.) The final portion uses a shorthand for C and
    C++, the ??auto-increment?? operator, to add one to the value of
    i. Effectively, i++ says ??get the value of i, add one to it, and put
    the result back into i. Thus, the total effect of the for loop is to
    take a variable i and march it through the values from zero to one less
    than the size of the vector. For each value of i, the cout statement is
    executed and this builds a line that consists of the value of i
    (magically converted to a character array by cout), a colon and a space,
    the line from the file, and a newline provided by endl. When you compile
    and run it you??ll see the effect is to add line numbers to the file.
    -->
    <para>
      La siguiente sentencia en el programa es un bucle <kw>for</kw>. Es
      parecido a un bucle <kw>while</kw> aunque añade un control
      extra. Como en el bucle <kw>while</kw> después del <kw>for</kw>
      hay una <quote>expresión de control</quote> dentro del
      paréntesis. Sin embargo, esta expresión está dividida en tres
      partes: una parte que inicializa, una que comprueba si hay que
      salir del bucle, y otra que cambia algo, normalmente da un paso en
      una secuencia de elementos. Este programa muestra el bucle
      <kw>for</kw> de la manera más frecuentemente utilizada: la parte
      de inicialización <code>int i = 0</code> crea un
      entero <varname>i</varname> para usarlo como contador y le da el
      valor inicial de cero. La comprobación consiste en ver si
      <varname>i</varname> es menor que el número de elementos en el
      <classname>vector</classname> <varname>v</varname>. Esto se
      consigue usando la función miembro <function>size()</function>,es
      decir, tamaño (que se debe reconocer que tiene un significado
      obvio) El útimo trozo, usa el operador de
      <quote>autoincremento</quote> para aumentar en uno el valor de
      <varname>i</varname>. Efectivamente,
      <code>i++</code> dice <quote>Coge el valor de
      <varname>i</varname> añádele uno y guarda el resultado en
      <varname>i</varname></quote>. Conclusión: el efecto del bucle
      <kw>for</kw> es aumentar la variable <varname>i</varname> desde
      cero hasta el tamaño del <literal>vector</literal> menos uno. Por
      cada nuevo valor de <varname>i</varname> se ejecuta la sentencia
      del <function>cout</function>, que construye un linea con el valor
      de <varname>i</varname> (mágicamente convertida a un array de
      caracteres por <function>cout</function>), dos puntos, un espacio,
      la línea del fichero y el carácter de nueva línea que nos
      proporciona <function>endl</function>. Cuando lo compile y lo
      ejecute verá el efecto de numeración de líneas del fichero.
    </para>

    <!--
    Because of the way that the ??>>?? operator works with iostreams, you
    can easily modify the program above so that it breaks up the input into
    whitespace-separated words instead of lines:
    -->
    <para>
      Debido a que el operador <quote>&gt;&gt;</quote> funciona con
      iostreams, se puede fácilmente modificar el anterior programa
      para que convierta la entrada en palabras separadas por
      espacios, en vez de líneas:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/GetWords.cpp"/>
</programlisting>


    <!-- The expression -->
    <para>
      La expresión:
    </para>

<programlisting>
while (in >> word)
</programlisting>


    <!--
    is what gets the input one ??word?? at a time, and when this expression
    evaluates to ??false?? it means the end of the file has been reached. Of
    course, delimiting words by whitespace is quite crude, but it makes for
    a simple example. Later in the book you??ll see more sophisticated
    examples that let you break up input just about any way you??d like.
    -->
    <para>
      es la que consigue transformar la entrada en una
      <quote>palabra</quote> cada vez, y cuando la expresión sea
      evaluada como <quote>falsa</quote> significará que se ha
      llegado al final del fichero. De acuerdo, delimitar una
      palabra mediante caracteres en blanco es un poco tosco, pero
      sirve como ejemplo sencillo. Más tarde, en este libro, verá
      ejemplos más sofisticados que le permiten romper la entrada de
      la forma en que usted desee.
    </para>

    <!--
    To demonstrate how easy it is to use a vector with any type, here??s an
    example that creates a vector<int>:
    -->
    <para>
      Para demostrar lo fácil que es usar un
      <classname>vector</classname> con cualquier tipo, aquí tiene
      un ejemplo que crea un vector de enteros:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C02/Intvector.cpp"/>
</programlisting>

    <!--
    To create a vector that holds a different type, you just put that type
    in as the template argument (the argument in angle brackets). Templates
    and well-designed template libraries are intended to be exactly this
    easy to use.
    -->
    <para>
      Para crear un <classname>vector</classname> que maneje a un tipo
      diferente basta con poner el tipo entre las llaves angulares
      (el argumento de los templates). Los templates y las librerías
      de templates pretenden ofrecer esta facilidad de uso.
    </para>

    <!--
    This example goes on to demonstrate another essential feature of
    vector. In the expression
    -->
    <para>
      Además este ejemplo nos demuestra otra característica esencial
      del <classname>vector</classname> en la expresión
    </para>

<programlisting>
v[i] = v[i] * 10;
</programlisting>

    <!--
    you can see that the vector is not limited to only putting things in and
    getting things out. You also have the ability to assign (and thus to
    change) to any element of a vector, also through the use of the
    square-brackets indexing operator. This means that vector is a
    general-purpose, flexible ??scratchpad?? for working with collections of
    objects, and we will definitely make use of it in coming chapters.
    -->
    <para>
      Puede observar que el <classname>vector</classname> no está
      limitado a meter cosas y sacarlas. También puede "asignar" (es
      decir, cambiar) cualquier elemento del vector mediante el uso
      de los corchetes. Esto significa que el
      <classname>vector</classname> es un objeto útil, flexible y de
      propósito general para trabajar con colecciones de objetos, y
      haremos uso de él en los siguientes capítulos.
    </para>

  </sect1>
  
  <sect1>
    <!-- Summary -->
    <title>Resumen</title>

    <!--
    The intent of this chapter is to show you how easy object-oriented
    programming can be ? if someone else has gone to the work of defining
    the objects for you. In that case, you include a header file, create the
    objects, and send messages to them. If the types you are using are
    powerful and well-designed, then you won??t have to do much work and
    your resulting program will also be powerful.
    -->
    <para>
      Este capítulo pretendía mostrarle lo fácil que la programación
      orientada a objetos puede llegar a ser - si alguien ha hecho
      el trabajo de definir los objetos por usted. En este caso,
      sólo hay que incluir el fichero de cabecera, crear los objetos
      y enviarles mensajes. Si los tipos que está usando están bien
      diseñados y son potentes, entonces no tendrá mucho trabajo y
      su programa resultante también será potente.
    </para>

    <!--
    In the process of showing the ease of OOP when using library classes,
    this chapter also introduced some of the most basic and useful types in
    the Standard C++ library: the family of iostreams (in particular, those
    that read from and write to the console and files), the string class,
    and the vector template. You??ve seen how straightforward it is to use
    these and can now probably imagine many things you can accomplish with
    them, but there??s actually a lot more that they??re capable
    of[29]. Even though we??ll only be using a limited subset of the
    functionality of these tools in the early part of the book, they
    nonetheless provide a large step up from the primitiveness of learning a
    low-level language like C. and while learning the low-level aspects of C
    is educational, it??s also time consuming. In the end, you??ll be much
    more productive if you??ve got objects to manage the low-level
    issues. After all, the whole point of OOP is to hide the details so you
    can ??paint with a bigger brush.??
    -->
    <para>
      En el proceso para mostrar la sencillez de la POO cuando se usan
      librerías de clases, este capítulo, también le introduce algunos
      de los más básicos y útiles tipos de datos de la librería estándar
      de C++: La familia de los iostreams (en particular aquellos que
      leen y escriben en consola y ficheros), la clase
      <classname>string</classname>, y el template
      <classname>vector</classname>. Ha visto lo sencillo que es usarlos
      y ahora es probable que se imagine la de cosas que se pueden
      realizar con ellos, pero hay muchas más cosas que son capaces de
      realizar<footnote><para> Si está especialmente interesado en ver
      todas las cosas que se pueden hacer con los componentes de la
      librería estándar, vea el Volumen 2 de este libro en
      www.BruceEckel.com y también en <ulink
      url="http://www.dinkumware.com"> www.dinkumware.com
      </ulink></para> </footnote>. A pesar de estar usando un pequeño
      subconjunto de la funcionalidad de éstas herramientas en este
      principio del libro, da un gran paso frente a los rudimentarios
      comienzos en el aprendizaje de un lenguaje de bajo nivel como el
      C. Y mientras que aprender los aspectos de bajo nivel de C es
      educativo también es una pérdida de tiempo. Al final usted será
      mucho más productivo si tiene objetos que manejen las
      características de bajo nivel. Después de todo, el principal
      objetivo de la POO es esconder los detalles para que usted pueda
      <quote>pintar con una brocha más gorda</quote>.
    </para>

    <!--
    However, as high-level as OOP tries to be, there are some fundamental
    aspects of C that you can??t avoid knowing, and these will be covered in
    the next chapter.
    -->
  </sect1>
  
  <sect1>
    <!-- Exercises -->
    <title>Ejercicios</title>
    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>    
	<!--
    1. Modify Hello.cpp so that it prints out your name and age (or shoe
    size, or your dog??s age, if that makes you feel better). Compile and
    run the program.
    -->

	<para>
	  Modifique <filename>Hello.cpp</filename> para que imprima
	  su nombre y edad (o tamaño de pie, o la edad de su perro,
	  si le gusta más). Compile y ejecute el programa.
	</para>
      </listitem>
      <listitem>   
	<!--
    2. Using Stream2.cpp and Numconv.cpp as guidelines, create a program
    that asks for the radius of a circle and prints the area of that
    circle. You can just use the ??*?? operator to square the radius. Do
    not try to print out the value as octal or hex (these only work with
    integral types).
    -->

	<para>
	  Usando <filename>Stream2.cpp</filename> y
	  <filename>Numconv.cpp</filename> como guías, cree un
	  programa que le pida el radio de un círculo y le muestre
	  el área del mismo. Puede usar el operador '*' para elevar
	  al cuadrado el radio. No intente imprimir el valor en
	  octal o en hexadecimal (sólo funcionan con tipos enteros).
	</para>
      </listitem>
      <listitem>
    <!--
    3. Create a program that opens a file and counts the
    whitespace-separated words in that file.
    -->
	<para>
	  Cree un programa que abra un fichero y cuente las palabras
	  separadas por espacios en blanco que tiene.
	</para>
      </listitem>
      <listitem>
    <!--
    4. Create a program that counts the occurrence of a particular word
    in a file (use the string class?? operator ??==?? to find the word).
    -->
	<para>
	  Cree un programa que cuente el número de ocurrencias de
	  una palabra en concreto en un fichero (use el operador
	  '==' de la clase <classname>string</classname> para
	  encontrar la palabra)
	</para>
      </listitem>
      <listitem>
    <!--
    5. Change Fillvector.cpp so that it prints the lines (backwards) from
    last to first.
    -->
	<para>
	  Cambie <filename>Fillvector.cpp</filename> para que imprima
	  las líneas al revés (de la última a la primera).
	</para>
      </listitem>
      <listitem>
    <!--
    6. Change Fillvector.cpp so that it concatenates all the elements in
    the vector into a single string before printing it out, but don??t
    try to add line numbering.
    -->
	<para>
	  Cambie <filename>Fillvector.cpp</filename> para que
	  concatene todos los elementos en la clase
	  <classname>vector</classname> en un único
	  <classname>string</classname> antes de imprimirlo, pero no
	  añada numeración de líneas
	</para>
      </listitem>
      <listitem>
    <!--
    7. Display a file a line at a time, waiting for the user to press the
    ??Enter?? key after each line.
    -->
	<para>
	  Muestre una línea de fichero cada vez esperando a que el
	  usuario pulse 'Enter'.
	</para>
      </listitem>
      <listitem>
    <!--
    8. Create a vector<float> and put 25 floating-point numbers into it
    using a for loop. Display the vector.
    -->
	<para>
	  Cree un <classname>vector&lt;float&gt;</classname> e
	  introduzca 25 números en coma flotante en él usando un
	  bucle <kw>for</kw> Muestre el vector.
	</para>
      </listitem>
      <listitem>
    <!--
    9. Create three vector<float> objects and fill the first two as in
    the previous exercise. Write a for loop that adds each corresponding
    element in the first two vectors and puts the result in the
    corresponding element of the third vector. Display all three vectors.
    -->
	<para>
	  Cree tres objetos
	  <classname>vector&lt;float&gt;</classname> y rellene los
	  dos primeros como en el ejercicio anterior. Escriba un
	  bucle for que sume los correspondientes elementos y los
	  añada al tercer vector. Muestre los tres vectores.
	</para>
      </listitem>
      <listitem>
    <!--
    10. Create a vector<float> and put 25 numbers into it as in the
    previous exercises. Now square each number and put the result back
    into the same location in the vector. Display the vector before and
    after the multiplication.
    -->
	<para>
	  Cree un <classname>vector&lt;float&gt;</classname> e
	  introduzca 25 números en él como en el ejercicio
	  anterior. Eleve cada número al cuadrado y ponga su
	  resultado en la misma posición del vector. Muestre el
	  vector antes y después de la multiplicación.
	</para>
      </listitem>
    </orderedlist>

  </sect1>
</chapter>

