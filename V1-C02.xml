<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Jesús López Mollo <i302154@correo.unnet.es> (pre-LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C02">

  <title>Construir y usar objetos</title>

  <!--
  This chapter will introduce enough C++ syntax and program construction
  concepts to allow you to write and run some simple object-oriented
  programs. In the subsequent chapter we will cover the basic syntax of C
  and C++ in detail.
  -->

  <highlights>
    <para>
      Este capítulo presenta la suficiente sintaxis y
      los conceptos de construcción de programas de C++ como para
      permitirle crear y ejecutar algunos programas simples orientados a
      objetos. El siguiente capítulo cubre la sintaxis
      básica de C y C++ en detalle.
    </para>
  </highlights>


  <!--
  By reading this chapter first, you??ll get the basic flavor of what it
  is like to program with objects in C++, and you??ll also discover some
  of the reasons for the enthusiasm surrounding this language. This should
  be enough to carry you through Chapter 3, which can be a bit exhausting
  since it contains most of the details of the C language.
  -->
  <para>
    Leyendo primero este capítulo, le cogerá el gustillo a lo que
    supone programar con objetos en C++, y también descubrirá
    algunas de las razones por las que hay tanto entusiasmo
    alrededor de este lenguaje. Debería ser suficiente para
    pasar al <link linkend="C03">Capítulo 3</link>, que puede ser un poco
    agotador debido a que contiene la mayoría de los detalles del
    lenguaje C.
  </para>

  <!--
  The user-defined data type, or class, is what distinguishes C++
  from traditional procedural languages. A class is a new data type
  that you or someone else creates to solve a particular kind of
  problem. Once a class is created, anyone can use it without knowing
  the specifics of how it works, or even how classes are built. This
  chapter treats classes as if they are just another built-in data
  type available for use in programs.
  -->

  <para>
    Los tipos de datos definidos por el usuario, o
    <emphasis>clases</emphasis> es lo que diferencia a C++ de los
    lenguajes procedimentales tradicionales.  Una clase es un nuevo tipo
    de datos que usted o alguna otra persona crea para resolver un
    problema particular. Una vez que se ha creado una clase, cualquiera
    puede utilizarla sin conocer los detalles de su funcionamiento, o
    incluso de la forma en que se han construído.  Este capítulo trata
    las clases como si sólo fueran otro tipo de datos predefinido
    disponible para su uso en programas.
  </para>


  <!--
  Classes that someone else has created are typically packaged
  into a library. This chapter uses several of the class libraries
  that come with all C++ implementations. An especially important
  standard library is iostreams, which (among other things) allow you
  to read from files and the keyboard, and to write to files and the
  display. You'll also see the very handy string class, and the
  vector container from the Standard C++ Library. By the end of the
  chapter, you'll see how easy it is to use a pre-defined library
  of classes.
  -->
  <para>
    Las clases creadas por terceras personas se suelen empaquetar en
    librerías.  Este capítulo usa algunas de las librerías que vienen en
    todas las implementaciones de C++. Una librería especialmente
    importante es FIXME:iostreams, que le permite (entre otras cosas)
    leer desde ficheros o teclado, y escribir a ficheros o
    pantalla. También verá la clase <classname>string</classname>, que
    es muy práctica, y el contenedor <classname>vector</classname> de la
    Libreria Estándar de C++. Al final del capítulo, verá lo sencillo
    que resulta utilizar una librería de clases predefinida.
  </para>

  <!--
  In order to create your first program you must understand the tools used
  to build applications.
  -->
  <para>
    Para que pueda crear su primer programa debe conocer primero las
    herramientas utilizadas para construir aplicaciones.
  </para>


  <sect1>
    <!-- The process of language translation -->
    <title>El proceso de traducción del lenguaje</title>

    <!--
    All computer languages are translated from something that tends to be
    easy for a human to understand (source code) into something that is
    executed on a computer (machine instructions). Traditionally,
    translators fall into two classes: interpreters and compilers.
    -->
    <para>
      Todos los lenguajes de programación se traducen de algo que
      suele ser fácilmente entendible por una persona
      (<emphasis>código fuente</emphasis>) a algo que es ejecutado
      por una computadora (<emphasis>código máquina</emphasis>). Los
      traductores se dividen tradicionalmente en dos
      categorías: <emphasis>intérpretes</emphasis> y
      <emphasis>compiladores</emphasis>.
    </para>

    <sect2>
      <!-- Interpreters -->
      <title>Intérpretes</title>

      <!--
      An interpreter translates source code into activities (which may
      comprise groups of machine instructions) and immediately executes those
      activities. BASIC, for example, has been a popular interpreted
      language. Traditional BASIC interpreters translate and execute one line
      at a time, and then forget that the line has been translated. This makes
      them slow, since they must re-translate any repeated code. BASIC has
      also been compiled, for speed. More modern interpreters, such as those
      for the Python language, translate the entire program into an
      intermediate language that is then executed by a much faster
      interpreter[25].
      -->
      <para>
	Un intérprete traduce el código fuente en actividades (las
	cuales pueden comprender grupos de instrucciones máquina) y
	ejecuta inmediatamente estas actividades.  El BASIC, por
	ejemplo, fue un lenguaje interpretado bastante popular. Los
	intérpretes de BASIC tradicionales traducen y ejecutan una línea
	cada vez, y después olvidan la línea traducida. Esto los hace
	lentos debido a que deben volver a traducir cualquier código que
	se repita. BASIC también ha sido compilado para ganar en
	velocidad. La mayoría de los intérpretes modernos, como los de
	Python, traducen el programa entero en un lenguaje intermedio
	que es ejecutable por un intérprete mucho más
	rápido
	<footnote>
	  <!-- [25] The boundary between compilers and interpreters can
	  tend to become a bit fuzzy, especially with Python, which has
	  many of the features and power of a compiled language but the
	  quick turnaround of an interpreted language.  -->
	  <para>
	    Los límites entre los compiladores y los intérpretes tienden
	    a ser difusos, especialmente con Python, que tiene muchas de
	    las caractéristicas y el poder de un lenguaje compilado pero
	    también tiene parte de las ventajas de los lenguajes
	    interpretados.
	  </para>
	</footnote>.
      </para>

      <!--
      Interpreters have many advantages. The transition from writing code to
      executing code is almost immediate, and the source code is always
      available so the interpreter can be much more specific when an error
      occurs. The benefits often cited for interpreters are ease of
      interaction and rapid development (but not necessarily execution) of
      programs.
      -->
      <para>
	Los intérpretes tienen muchas ventajas. La transición del
	código escrito al código ejecutable es casi inmediata, y el
	código fuente está siempre disponible, por lo que el intérprete
	puede ser mucho más específico cuando ocurre un error. Los
	beneficios que se suelen mencionar de los intérpretes es la
	facilidad de interacción y el rápido desarrollo (pero no
	necesariamente ejecución) de los programas.
      </para>

      <!--
      Interpreted languages often have severe limitations when building large
      projects (Python seems to be an exception to this). The interpreter (or
      a reduced version) must always be in memory to execute the code, and
      even the fastest interpreter may introduce unacceptable speed
      restrictions. Most interpreters require that the complete source code be
      brought into the interpreter all at once. Not only does this introduce a
      space limitation, it can also cause more difficult bugs if the language
      doesn??t provide facilities to localize the effect of different pieces
      of code.
      -->
      <para>
	Los lenguajes interpretados a menudo tienen severas limitaciones
	cuando se construyen grandes proyectos (Python parece ser una
	excepción). El intérprete (o una versión reducida) debe estar
	siempre en memoria para ejecutar el código e incluso el
	intérprete más rápido puede introducir restricciones de
	velocidad inaceptables. La mayoría de los intérpretes requieren
	que todo el código fuente se les envíe de una sola vez. Esto no
	sólo introduce limitaciones de espacio, sino que puede causar
	errores difíciles de detectar si el lenguaje no incluye
	facilidades para localizar el efecto de las diferentes porciones
	de código.
      </para>
    </sect2>

    <sect2>
      <!-- Compilers -->
      <title>Compiladores</title>

      <!--
      A compiler translates source code directly into assembly language or
      machine instructions. The eventual end product is a file or files
      containing machine code. This is an involved process, and usually takes
      several steps. The transition from writing code to executing code is
      significantly longer with a compiler.
      -->
      <para>
	Un compilador traduce el código fuente directamente a
	lenguaje ensamblador o instrucciones máquina. El producto final
	suele ser uno o varios ficheros que contienen código
	máquina. La forma de realizarlo suele ser un proceso que
	consta de varios pasos. La transición del código escrito al
	código ejecutable es significativamente más larga con un
	compilador.
      </para>

      <!--
      Depending on the acumen of the compiler writer, programs generated
      by a compiler tend to require much less space to run, and they run
      much more quickly. Although size and speed are probably the most
      often cited reasons for using a compiler, in many situations they
      aren't the most important reasons. Some languages (such as C) are
      designed to allow pieces of a program to be compiled
      independently. These pieces are eventually combined into a final
      executable program by a tool called the linker. This process is
      called separate compilation
      -->

      <para>
        Dependiendo de la perspicacia del escritor del compilador, los
        programas generados por un compilador tienden a requerir mucho
        menos espacio para ser ejecutados, y se ejecutan mucho más
        rápido. Aunque el tamaño y la velocidad son probablemente las
        razones más citadas para usar un compilador, en muchas
        situaciones no son las más importantes. Algunos lenguajes (como
        el C) están diseñados para admitir trozos de programas
        compilados independientemente. Estas partes terminan combinando
        en un programa <emphasis>ejecutable</emphasis> final mediante
        una herramienta llamada <emphasis>enlazador</emphasis>
        (<foreignphrase>linker</foreignphrase>). Este proceso se
        conoce como <emphasis>compilación separada</emphasis>.
      </para>

      <!--
      Separate compilation has many benefits. A program that, taken all at
      once, would exceed the limits of the compiler or the compiling
      environment can be compiled in pieces. Programs can be built and tested
      one piece at a time. Once a piece is working, it can be saved and
      treated as a building block. Collections of tested and working pieces
      can be combined into libraries for use by other programmers. As each
      piece is created, the complexity of the other pieces is hidden. All
      these features support the creation of large programs[26].
      -->

      <para>
	La compilación separada tiene muchos beneficios. Un programa
	que, tomado de una vez, excedería los límites del compilador o
	del entorno de compilación puede ser compilado por piezas. Los
	programas se pueden ser construir y probar pieza a pieza.  Una
	vez que una parte funciona, se puede guardar y tratarse como un
	bloque. Los conjuntos de piezas ya funcionales y probadas se
	pueden combinar en <emphasis>librerías</emphasis> para que otros
	programadores puedan usarlos. Como se crean piezas, la
	complejidad de las otras piezas se mantiene oculta.  Todas estas
	características ayudan a la creación de programas grandes,
	<footnote>
	  <!--
	  [26] Python is again an exception, since it also provides
	  separate compilation.
	  -->
	  <para>
	    Python vuelve a ser una excepción, debido a que permite
	    compilación separada.
	  </para>
	</footnote>.
      </para>


      <!--
      Compiler debugging features have improved significantly over time. Early
      compilers only generated machine code, and the programmer inserted print
      statements to see what was going on. This is not always
      effective. Modern compilers can insert information about the source code
      into the executable program. This information is used by powerful
      source-level debuggers to show exactly what is happening in a program by
      tracing its progress through the source code.
      -->
      <para>
	Las características de depuración del compilador han mejorado
	considerablemente con el tiempo. Los primeros compiladores
	simplemente generaban código máquina, y el programador insertaba
	sentencias de impresión para ver qué estaba ocurriendo, lo que
	no siempre era efectivo. Los compiladores modernos pueden
	insertar información sobre el código fuente en el programa
	ejecutable. Esta información se usa por poderosos
	<emphasis>depuradores a nivel de código</emphasis> que muestran
	exactamente lo que pasa en un programa rastreando su progreso
	mediante su código fuente.
      </para>

      <!--
      Some compilers tackle the compilation-speed problem by performing
      in-memory compilation. Most compilers work with files, reading and
      writing them in each step of the compilation process. In-memory
      compilers keep the compiler program in RAM. For small programs, this can
      seem as responsive as an interpreter.
      -->
      <para>
	Algunos compiladores solucionan el problema de la velocidad
	de compilación mediante <emphasis>compilación en
	  memoria</emphasis>. La mayoría de los compiladores trabajan
	con ficheros, leyéndolos y escribiéndolos en cada paso de
	los procesos de compilación. En la compilación en memoria el
	compilador se mantiene en RAM. Para programas pequeños,
	puede parecerse a un intérprete.
      </para>
    </sect2>

    <sect2>
      <title>El proceso de compilación</title>

      <!--
      To program in C and C++, you need to understand the steps and tools in
      the compilation process. Some languages (C and C++, in particular) start
      compilation by running a preprocessor on the source code. The
      preprocessor is a simple program that replaces patterns in the source
      code with other patterns the programmer has defined (using preprocessor
      directives). Preprocessor directives are used to save typing and to
      increase the readability of the code. (Later in the book, you??ll learn
      how the design of C++ is meant to discourage much of the use of the
      preprocessor, since it can cause subtle bugs.) The pre-processed code is
      often written to an intermediate file.
      -->
      <para>
	Para programar en C y en C++, es necesario entender los
	pasos y las herramientas del proceso de compilación. Algunos
	lenguajes (C y C++, en particular) empiezan la compilación
	ejecutando un <emphasis>preprocesador</emphasis> sobre el código
	fuente. El preprocesador es un programa simple que sustituye
	patrones que se encuentran en el código fuente con otros que
	ha definido el programador (usando las <emphasis>directivas
	  de preprocesado</emphasis>). Las directivas de
	preprocesado se utilizan para ahorrar escritura y para aumentar
	la legilibilidad del código (posteriormente en este libro,
	aprenderá cómo el diseño de C++ desaconseja en gran medida el uso
	del preprocesador, ya que puede causar errores sutiles). El
	código preprocesado se suele escribir en un fichero
	intermedio.
      </para>

      <!--
      Compilers usually do their work in two passes. The first pass parses the
      pre-processed code. The compiler breaks the source code into small units
      and organizes it into a structure called a tree. In the expression ??A +
      B?? the elements ??A??, ??+,?? and ??B?? are leaves on the parse tree.
      -->
      <para>
	Normalmente, los compiladores hacen su trabajo en dos
	pasadas. La primera pasada consiste en analizar sintácticamente
	el código generado por el preprocesador. El compilador trocea
	el código fuente en pequeñas partes y lo organiza en una
	estructura llamada <emphasis>árbol</emphasis>. En la
	expresión FIXME:<quote>A+B</quote>, los elementos
	<quote>A</quote>, <quote>+</quote>, <quote>B</quote> son
	hojas del árbol.
      </para>
    <!-- FIXME: en el párrafo anterior, las comillas de A+B son dobles
    y las de cada elemento por separado son simples. Además, todas van
    en negrita.
    -->

      <!--
      A global optimizer is sometimes used between the first and second passes
      to produce smaller, faster code.
      -->
      <para>
	A menudo se utiliza un <emphasis>optimizador global</emphasis>
	entre el primer y el segundo paso para producir código más
	pequeño y rápido.
      </para>

      <!--
      In the second pass, the code generator walks through the parse tree and
      generates either assembly language code or machine code for the nodes of
      the tree. If the code generator creates assembly code, the assembler
      must then be run. The end result in both cases is an object module (a
      file that typically has an extension of .o or .obj). A peephole
      optimizer is sometimes used in the second pass to look for pieces of
      code containing redundant assembly-language statements.
      -->
      <para>
	En la segunda pasada, el <emphasis>generador de código</emphasis>
	  recorre el árbol sintáctico y genera lenguaje ensamblador o
	  código máquina para los nodos del árbol. Si el generador de
	  código crea lenguaje ensamblador, entonces se debe ejecutar el
	  programa ensamblador. El resultado final en ambos casos es un
	  módulo objeto (un fichero que típicamente tiene una extensión
	  de <filename>.o</filename> o <filename>.obj</filename>. A
	  veces se utiliza un <emphasis>optimizador de
	  mirilla</emphasis> en esta segunda pasada para buscar trozos de
	  código que contengan sentencias redundantes de lenguaje
	  ensamblador.
      </para>

      <!--
      The use of the word ??object?? to describe chunks of machine code is an
      unfortunate artifact. The word came into use before object-oriented
      programming was in general use. ??Object?? is used in the same sense as
      ??goal?? when discussing compilation, while in object-oriented
      programming it means ??a thing with boundaries.??
      -->
      <para>
	Usar la palabra <quote>objeto</quote> para describir pedazos de
	código máquina es un hecho desafortunado. La palabra comenzó a
	usarse antes de que la programación orientada a objetos tuviera
	un uso generalizado. <quote>Objeto</quote> significa lo mismo
	que <quote>FIXME:meta</quote> en este contexto, mientras que en la
	programación orientada a objetos significa <quote>una cosa con
	límites</quote>.
      </para>

      <!--
      The linker combines a list of object modules into an executable program
      that can be loaded and run by the operating system. When a function in
      one object module makes a reference to a function or variable in another
      object module, the linker resolves these references; it makes sure that
      all the external functions and data you claimed existed during
      compilation do exist. The linker also adds a special object module to
      perform start-up activities.
      -->
      <para>
	El <emphasis>enlazador</emphasis> combina una lista de módulos
	objeto en un programa ejecutable que el sistema operativo puede
	cargar y ejecutar. Cuando una función en un módulo objeto hace
	una referencia a una función o variable en otro módulo objeto,
	el enlazador resuelve estas referencias; se asegura de que todas
	las funciones y los datos externos solicitados durante el
	proceso de compilación existen realmente. Además, el enlazador
	añade un módulo objeto especial para realizar las actividades de
	inicialización.
      </para>


      <!--
      The linker can search through special files called libraries in order to
      resolve all its references. A library contains a collection of object
      modules in a single file. A library is created and maintained by a
      program called a FIXME:librarian.
      -->
      <para>
	El enlazador puede buscar en unos archivos especiales llamados
	<emphasis>librerías</emphasis> para resolver todas sus
	referencias. Una librería contiene una colección de módulos
	objeto en un único fichero. Una librería se crea y mantiene por
	un programa conocido como <emphasis>bibliotecario</emphasis>
	(<foreignphrase>librarian</foreignphrase>).
      </para>

      <sect3>
        <!-- Static type checking -->
	<title>Comprobación estática de tipos</title>

        <!--
        The compiler performs type checking during the first pass. Type checking
        tests for the proper use of arguments in functions and prevents many
        kinds of programming errors. Since type checking occurs during
        compilation instead of when the program is running, it is called static
        type checking.
        -->
	<para>
	  El compilador realiza una <emphasis>comprobación de
	  tipos</emphasis> durante la primera pasada. La comprobación de
	  tipos asegura el correcto uso de los argumentos en las
	  funciones y previene muchos tipos de errores de
	  programación. Como esta comprobación de tipos ocurre se hace
	  la compilación y no cuando el programa se está ejecutado, se
	  conoce como <emphasis>comprobación estática de
	  tipos</emphasis>.
	</para>

        <!--
        Some object-oriented languages (notably Java) perform some type checking
        at runtime (dynamic type checking). If combined with static type
        checking, dynamic type checking is more powerful than static type
        checking alone. However, it also adds overhead to program execution.
        -->
	<para>
	  Algunos lenguajes orientados a objetos (Java por ejemplo)
	  realizan comprobaciones en tiempo de ejecución
	  (<emphasis>comprobación dinámica de tipos</emphasis>). Si se
	  combina con la estática, la comprobación dinámica es más
	  potente que sólo la estática. Sin embargo, añade una
	  sobrecarga a la ejecución del programa.
	</para>

        <!--
        C++ uses static type checking because the language cannot assume any
        particular runtime support for bad operations. Static type checking
        notifies the programmer about misuses of types during compilation, and
        thus maximizes execution speed. As you learn C++, you will see that most
        of the language design decisions favor the same kind of high-speed,
        production-oriented programming the C language is famous for.
        -->
	<para>
	  C++ usa la comprobación estática de tipos debido a que el
	  lenguaje no puede asumir ningún soporte particular durante la
	  ejecución. La comprobación estática de tipos notifica al
	  programador malos usos de los tipos durante la compilación, y
	  así maximiza la velocidad de ejecución. A medida que aprenda
	  C++, comprobará que la mayoría de las decisiones de diseño del
	  lenguaje están tomadas en favor de la mejora del rendimiento,
	  motivo por el cual C es famoso en la programación orientada a
	  la producción.
	</para>

        <!--
        You can disable static type checking in C++. You can also do your own
        dynamic type checking ? you just need to write the code.
        -->
	<para>
	  Se puede deshabilitar la comprobación estática de tipos en
	  C++, e incluso permite al programador usar su propia
	  comprobación dinámica de tipos - simplemente necesita escribir
	  el código.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <!-- Tools for separate compilation -->
    <title>Herramientas para compilación modular</title>

    <!--
    Separate compilation is particularly important when building large
    projects. In C and C++, a program can be created in small, manageable,
    independently tested pieces. The most fundamental tool for breaking a
    program up into pieces is the ability to create named subroutines or
    subprograms. In C and C++, a subprogram is called a function, and
    functions are the pieces of code that can be placed in different files,
    enabling separate compilation. Put another way, the function is the
    atomic unit of code, since you cannot have part of a function in one
    file and another part in a different file; the entire function must be
    placed in a single file (although files can and do contain more than one
    function).
    -->
    <para>
      La compilación modular es particularmente importante cuando se
      construyen grandes proyectos. En C y en C++, un programa se puede
      crear en pequeñas piezas, manejables y comprobables de forma
      independiente. La herramienta más importante para dividir un
      programa en piezas más pequeñas es la capacidad de crear
      subrutinas o subprogramas que tengan un nombre que las
      identifique. En C y en C++, estos subprogramas se llamana
      <emphasis>funciones</emphasis>, que son las piezas de código que
      se pueden almacenar en diferentes ficheros, permitiendo la
      compilación separada. Dicho de otra forma, una función es la
      unidad atómica de código, debido a que no se puede tener una parte
      de una función en un fichero y el resto en otro (aunque los
      ficheros pueden contener más de una función).
    </para>

    <!--
    When you call a function, you typically pass it some arguments, which
    are values you??d like the function to work with during its
    execution. When the function is finished, you typically get back a
    return value, a value that the function hands back to you as a
    result. It??s also possible to write functions that take no arguments
    and return no values.
    -->
    <para>
      Cuando se invoca una función, se le suelen pasar una serie de
      <emphasis>argumentos</emphasis>, que son valores que desea que la
      función utilice durante su ejecución. Cuando la función termina,
      normalmente devuelve un <emphasis>valor de retorno</emphasis>,
      que equivale al resultado. También es posible crear funciones que
      no tengan ni argumentos ni valor de retorno.
    </para>

    <!--
    To create a program with multiple files, functions in one file must
    access functions and data in other files. When compiling a file, the C
    or C++ compiler must know about the functions and data in the other
    files, in particular their names and proper usage. The compiler ensures
    that functions and data are used correctly. This process of ??telling
    the compiler?? the names of external functions and data and what they
    should look like is called declaration. Once you declare a function or
    variable, the compiler knows how to check to make sure it is used
    properly.
    -->
    <para>
      Para crear un programa con múltiples ficheros, las funciones de un
      fichero deben acceder a las funciones y los datos de otros
      ficheros. Cuando se compila un fichero, el compilador de C o C++
      debe conocer las funciones y los datos de los otros ficheros, en
      particular sus nombres y su uso apropiado. El compilador asegura
      que las funciones y los datos son usados correctamente. El proceso
      de "decirle al compilador" los nombres de las funciones externas y
      los datos que necesitan es conocido como
      <emphasis>declaración</emphasis>.  Una vez declarada una función o
      una variable, el compilador sabe cómo comprobar que la función se
      utiliza adecuadamente.
    </para>


    <sect2>
      <!-- Declarations vs. definitions -->
      <title>Declaraciones vs definiciones</title>

      <!--
      It??s important to understand the difference between declarations and
      definitions because these terms will be used precisely throughout the
      book. Essentially all C and C++ programs require declarations. Before
      you can write your first program, you need to understand the proper way
      to write a declaration.
      -->
      <para>
      	Es importante comprender la diferencia entre
        <emphasis>declaraciones</emphasis> y
        <emphasis>definiciones</emphasis> porque estos términos se
        usarán de forma precisa en todo el libro. Básicamente todos los
        programas escritos en C o en C++ requieren declaraciones. Antes
        de poder escribir su primer programa, necesita comprender la
        manera correcta de escribir una declaración.
      </para>

      <!--
      A declaration introduces a name - an identifier - to the compiler. It
      tells the compiler ??This function or this variable exists somewhere,
      and here is what it should look like.?? A definition, on the other hand,
      says: ??Make this variable here?? or ??Make this function here.?? It
      allocates storage for the name. This meaning works whether you??re
      talking about a variable or a function; in either case, at the point of
      definition the compiler allocates storage. For a variable, the compiler
      determines how big that variable is and causes space to be generated in
      memory to hold the data for that variable. For a function, the compiler
      generates code, which ends up occupying storage in memory.
      -->
      <para>
	Una <emphasis>declaración</emphasis> presenta un nombre
	-identificador- al compilador. Le dice al compilador <quote>Esta
	función o esta variable existe en algún lugar, y éste es el
	aspecto que debe tener</quote>. Una
	<emphasis>definición</emphasis>, sin embargo, dice: <quote>Crea
	esta variable aquí</quote> o <quote>Crea esta función
	aquí</quote>. Eso reserva memoria para el nombre. Este
	significado sirve tanto para una variable que para una función;
	en ambos casos, el compilador reserva espacio en el momento de
	la definición. Para una variable, el compilador determina su
	tamaño y reserva el espacio en memoria para contener los datos
	de la variable. Para una función, el compilador genera el código
	que finalmente ocupará un espacio en memoria.
      </para>

      <!--
      You can declare a variable or a function in many different places, but
      there must be only one definition in C and C++ (this is sometimes called
      the ODR: one-definition rule). When the linker is uniting all the object
      modules, it will usually complain if it finds more than one definition
      for the same function or variable.
      -->
      <para>
	Se puede declarar una variable o una función en muchos sitios
	diferentes, pero en C o en C++ sólo se puede definir una vez (a
	se conoce a veces como Regla de Definición Única (ODR)
	<footnote>
	  <para>
	    <foreignphrase>one definition rule</foreignphrase>
	  </para>
	</footnote>. Cuando el enlazador une todos los módulos objeto,
	normalmente se quejará si encuentra más de una definición para
	la misma función o variable.
      </para>

      <!--
      A definition can also be a declaration. If the compiler hasn??t seen the
      name x before and you define int x;, the compiler sees the name as a
      declaration and allocates storage for it all at once.
      -->
      <para>
	Una definición puede ser también una declaración. Si el
	compilador no ha visto antes el nombre <varname>x</varname> y
	hay una definición <code>int x;</code>, el compilador ve el
	nombre también como una declaración y asigna memoria al mismo
	tiempo.
      </para>

      <sect3>
        <!-- Function declaration syntax -->
	<title>Sintaxis de declaración de funciones</title>

        <!--
        A function declaration in C and C++ gives the function name, the
        argument types passed to the function, and the return value of the
        function. For example, here is a declaration for a function called
        func1( ) that takes two integer arguments (integers are denoted in C/C++
        with the keyword int) and returns an integer:
        -->
	<para>
	  La declaración de una función en C y en C++ consiste en
	  escribir el nombre de la función, los tipos de argumentos que
	  se pasan a la función, y el valor de retorno de la misma. Por
	  ejemplo, aquí tenemos la declaración de una función llamada
	  <function>func1()</function> que toma dos enteros como
	  argumentos (en C/C++ los enteros se denotan con la palabra
	  reservada <type>int</type>) y que devuelve un entero:
	</para>


<programlisting>
int func1(int, int);
</programlisting>


	<!--
        The first keyword you see is the return value all by itself: int. The
        arguments are enclosed in parentheses after the function name in the
        order they are used. The semicolon indicates the end of a statement; in
        this case, it tells the compiler ??that??s all ? there is no function
        definition here!??
        -->
	<para>
	  La primera palabra reservada es el valor de retorno:
	  <literal>int</literal>. Los argumentos están encerrados
	  entre paréntesis después del nombre de la función en el
	  orden en que se utilizan. El punto y coma indica el final
	  de la sentencia; en este caso le dice al compilador
	  <quote>esto es todo - ¡aquí no está la definición de la
	    función!</quote>.
	</para>

        <!--
        C and C++ declarations attempt to mimic the form of the item??s use. For
        example, if a is another integer the above function might be used this
        way:
        -->
	<para>
	  Las declaraciones en C y C++ tratan de mimetizar la forma en
	  que se utilizará ese elemento. Por ejemplo, si
	  <varname>a</varname> es otro entero la función de arriba se
	  debería usar de la siguiente manera:
	</para>


<programlisting>
a = func1(2, 3);
</programlisting>


        <!--
        Since func1( ) returns an integer, the C or C++ compiler will check the
        use of func1( ) to make sure that a can accept the return value and that
        the arguments are appropriate.
        -->
	<para>
	  Como <function>func1()</function> devuelve un entero, el
	  compilador de C/C++ comprobará el uso de
	  <function>func1()</function> para asegurarse que
	  <varname>a</varname> puede aceptar el valor devuelto y que
	  los argumentos son válidos.
	</para>

        <!--
        Arguments in function declarations may have names. The compiler ignores
        the names but they can be helpful as mnemonic devices for the user. For
        example, we can declare func1( ) in a different fashion that has the
        same meaning:
        -->
	<para>
	  Los argumentos de las declaraciones de funciones pueden tener
	  nombres. El compilador los ignora pero pueden ser útilies como
	  nemotécnicos para el usuario. Por ejemplo, se puede declarar
	  <function>func1()</function> con una apariencia diferente pero
	  con el mismo significado:
	</para>


<programlisting>
int func1(int length, int width);
</programlisting>
      </sect3>

      <sect3>
       <!-- A gotcha -->
	<title>Una puntualización</title>

        <!--
        There is a significant difference between C and C++ for functions with
        empty argument lists. In C, the declaration:
        -->
	<para>
	  Existe una diferencia significativa entre C y el C++
	  para las funciones con lista de argumentos vacía. En C, la
	  declaración:
	</para>


<programlisting>
int func2();
</programlisting>


        <!--
	means ??a function with any number and type of argument.??
        This prevents type-checking, so in C++ it means ??a function
        with no arguments.??  -->
	<para>
	  significa <quote>una funcion con cualquier número y tipo de
	  argumentos</quote>, lo cual anula la comprobación de tipos. En
	  C++, sin embargo, significa <quote>una función sin
	  argumentos</quote>.
	</para>
      </sect3>

      <sect3>
        <!-- : Function definitions -->
	<title>Definición de funciones</title>

        <!--
        Function definitions look like function declarations except that they
        have bodies. A body is a collection of statements enclosed in
        braces. Braces denote the beginning and ending of a block of code. To
        give func1( ) a definition that is an empty body (a body containing no
        code), write:
        -->
	<para>
	  La definición de funciones se parece a la declaración
	  excepto en que tienen cuerpo. Un cuerpo es un conjunto de
	  sentencias encerradas entre llaves. Las llaves indican el
	  comienzo y el final del código. Para dar a
	  <function>func1()</function> una definición con un cuerpo
	  vacío (un cuerpo que no contiene código), escriba:
	</para>


<programlisting>
int func1(int ancho, int largo) {}
</programlisting>


        <!--
        Notice that in the function definition, the braces replace the
        semicolon. Since braces surround a statement or group of statements, you
        don??t need a semicolon. Notice also that the arguments in the function
        definition must have names if you want to use the arguments in the
        function body (since they are never used here, they are optional).
        -->
	<para>
	  Note que en la definición de la función las llaves
	  sustituyen el punto y coma. Como las llaves contienen una
	  sentencia o grupo de sentencias, no es necesario un punto
	  y coma. Tenga en cuenta además que los argumentos en la
	  definición de la función deben nombres si los
	  quiere usar en el cuerpo de la función (como aquí no se
	  usan, son opcionales).
	</para>
      </sect3>



      <sect3>
        <!-- : Variable declaration syntax -->
	<title>Sintaxis de declaración de variables</title>

        <!--
        The meaning attributed to the phrase ??variable declaration?? has
        historically been confusing and contradictory, and it??s important that
        you understand the correct definition so you can read code properly. A
        variable declaration tells the compiler what a variable looks like. It
        says, ??I know you haven??t seen this name before, but I promise it
        exists someplace, and it??s a variable of X type.??
        -->
	<para>
	  El significado atribuido a la frase <quote>declaración de
	  variables</quote> históricamente ha sido confuso y
	  contradictorio, y es importante que entienda el significado
	  correcto para poder leer el código correctamente. Una
	  declaración de variable dice al compilador cómo es la
	  variable. Dice al compilador, <quote>Sé que no has visto este
	  nombre antes, pero te prometo que existe en algún lugar, y que
	  es una variable de tipo X</quote>.
	</para>

        <!--
	In a function declaration, you give a type (the return
        value), the function name, the argument list, and a
        semicolon. That??s enough for the compiler to figure out that
        it??s a declaration and what the function should look like. By
        inference, a variable declaration might be a type followed by a
        name. For example: -->
	<para>
	  En una declaración de función, se da un tipo (el valor de
	  retorno), el nombre de la función, la lista de argumentos, y
	  un punto y coma. Con esto el compilador ya tiene suficiente
	  información para saber cómo será la función. Por inferencia,
	  una declaración de variable consistirá en un tipo seguido por
	  un nombre. Por ejemplo:
	</para>


<programlisting>
int a;
</programlisting>

        <!--
        could declare the variable a as an integer, using the logic
        above. Here??  s the conflict: there is enough information in
        the code above for the compiler to create space for an integer
        called a, and that??s what happens. To resolve this dilemma, a
        keyword was necessary for C and C++ to say ??This is only a
        declaration; it??s defined elsewhere.?? The keyword is
        extern. It can mean the definition is external to the file, or
        that the definition occurs later in the file.  -->
	<para>
	  podría declarar la variable <varname>a</varname> como un
	  entero usando la lógica usada anteriormente. Pero aquí está el
	  conflicto: existe suficiente información en el código anterior
	  como para que el compilador pueda crear espacio para un entero
	  llamado <varname>a</varname> y es exactamente lo que
	  ocurre. Para resolver el dilema, fue necesaria una palabra
	  reservada en C y C++ para decir <quote>Esto es sólo una
	  declaración; esta variable estará definida en algún otro
	  lado</quote>. La palabra reservada es <kw>extern</kw> que
	  puede significar que la definición es externa al fichero, o
	  que la definición se encuentra después en este fichero.
	</para>

        <!--
        Declaring a variable without defining it means using the extern
        keyword before a description of the variable, like this: -->
	<para>
	  Declarar una variable sin definirla implica usar la palabra
	  reservada <kw>extern</kw> antes de una descripción de la
	  variable, como por ejemplo:
	</para>


<programlisting>
extern int a;
</programlisting>


        <!--
        extern can also apply to function declarations. For func1( ), it looks
        like this:
        -->
	<para>
	  <kw>extern</kw> también se puede aplicar a la declaración de
	  funciones. Para <function>func1()</function> sería algo así:
	</para>


<programlisting>
extern int func1(int length, int width);
</programlisting>


        <!--
        This statement is equivalent to the previous func1( )
        declarations. Since there is no function body, the compiler must treat
        it as a function declaration rather than a function definition. The
        extern keyword is thus superfluous and optional for function
        declarations. It is probably unfortunate that the designers of C did not
        require the use of extern for function declarations; it would have been
        more consistent and less confusing (but would have required more typing,
        which probably explains the decision).
        -->
	<para>
	  Esta sentencia es equivalente a las declaraciones anteriores
	  para <function>func1()</function> . Como no hay cuerpo de
	  función, el compilador debe tratarla como una declaración de
	  función en lugar de como definición. La palabra reservada
	  <kw>extern</kw> es bastante supérflua y opcional para la
	  declaración de funciones. Probablemente sea desafortunado que
	  los diseñadores de C no obligaran al uso de <kw>extern</kw>
	  para la declaración de funciones; hubiera sido más consistente
	  y menos confuso (pero hubiera requerido teclear más, lo cual
	  probablemente explica la decisión).
	</para>

        <!-- Here are some more examples of declarations: -->
	<para>
	  Aquí hay algunos ejemplos más de declaraciones:
	</para>


//: V1C02:Declare.cpp


        <!--
        In the function declarations, the argument identifiers are optional. In
        the definitions, they are required (the identifiers are required only in
        C, not C++).
        -->
        <para>
          En la declaración de funciones, los identificadores de los argumentos
          son opcionales. En la definición son necesarios (los identificadores
          se requieren solamente en C, no en C++).
        </para>
      </sect3>

      <sect3>
        <!-- Including headers -->
        <title>Incluir ficheros de cabecera</title>

        <!--
	Most libraries contain significant numbers of functions and
        variables. To save work and ensure consistency when making the
        external declarations for these items, C and C++ use a
        FIXME:device called the header file. A header file is a file
        containing the external declarations for a library; it
        conventionally has a file name extension of ??h??, such as
        headerfile.h. (You may also see some older code using different
        extensions, such as .hxx or .hpp, but this is becoming rare.)
        -->
        <para>
          La mayoría de las librerías contienen un número importante de
          funciones y variables. Para ahorrar trabajo y asegurar la
          consistencia cuando se hacen declaraciones externas para estos
          elementos, C y C++ utilizan un artefacto llamado
          <emphasis>fichero de cabecera</emphasis>. Un fichero de
          cabecera es un fichero que contiene las declaraciones externas
          de una librería; convencionalmente tiene un nombre de fichero
          con extensión <filename>.h</filename>, como
          <filename>headerfile.h</filename> (no es difícil encontrar
          código más antiguo con extensiones diferentes, como
          <filename>.hxx</filename> o <filename>.hpp</filename>, pero es
          cada vez más raro).
        </para>

        <!-- The programmer who creates the library provides the header
        file. To declare the functions and external variables in the
        library, the user simply includes the header file. To include a
        header file, use the #include preprocessor directive. This tells
        the preprocessor to open the named header file and insert its
        contents where the #include statement appears. A #include may
        name a file in two ways: in angle brackets (FIXME:< >) or in
        double quotes.  -->
        <para>
          El programador que crea la librería proporciona el fichero de
          cabecera. Para declarar las funciones y variables externas de
          la librería, el usuario simplemente incluye el fichero de
          cabecera. Para ello se utiliza la directiva de preprocesado
          <kw>#include</kw>. Eso le dice al preprocesador que abra el
          fichero de cabecera indicado e incluya el contenido en el
          lugar donde se encuentra la sentencia <kw>#include</kw>. Un
          <kw>#include</kw> puede indicar un fichero de dos maneras:
          mediante paréntesis angulares ( &lt; &gt; ) o comillas dobles.
	</para>

        <!-- File names in angle brackets, such as: -->
	<para>
          Los ficheros entre paréntesis angulares, como:
        </para>


<programlisting>
#include &lt;header&gt;
</programlisting>


        <!--
        cause the preprocessor to search for the file in a way that is
        particular to your implementation, but typically there??s some kind of
        ??include search path?? that you specify in your environment or on the
        compiler command line. The mechanism for setting the search path varies
        between machines, operating systems, and C++ implementations, and may
        require some investigation on your part.
        -->
	<para>
          hacen que el preprocesador busque el fichero como si fuera
          particular a un proyecto, aunque normalmente hay un camino de
          búsqueda que se especifica en el entorno o en la línea de
          comandos del compilador. El mecanismo para cambiar el camino
          de búsqueda (o ruta) varía entre maquinas, sistemas
          operativos, e implementaciones de C++ y puede que requiera un
          poco de investigación por parte del programador.
        </para>

        <!-- File names in double quotes, such as: -->
        <para>
          Los ficheros entre comillas dobles, como:
        </para>


<programlisting>
#include "header"
</programlisting>


        <!--
        tell the preprocessor to search for the file in (according to the
        specification) an ??implementation-defined way.?? What this typically
        means is to search for the file relative to the current directory. If
        the file is not found, then the include directive is reprocessed as if
        it had angle brackets instead of quotes.
        -->
        <para>
          le dicen al preprocesador que busque el fichero en (de acuerdo a la
          especificación) <quote>un medio de definición de
          implementación</quote>, que normalmente significa buscar el fichero de
          forma relativa al directorio actual. Si no lo encuentra, entonces la
          directiva se preprocesada como si tuviera paréntesis angulares
          en lugar de comillas.
        </para>

        <!-- To include the iostream header file, you write: -->
        <para>
          Para incluir el fichero de cabecera
          <filename>iostream</filename>, hay que escribir:
        </para>


<programlisting>
#include &lt;iostream&gt;
</programlisting>

        <!--
        The preprocessor will find the iostream header file (often in a
        subdirectory called ??include??) and insert it.
        -->
        <para>
          El preprocesador encontrará el fichero de cabecera
          <filename>iostream</filename> (a menudo en un subdirectorio llamado
          <quote>include</quote>) y lo incluirá.
        </para>
      </sect3>


      <sect3>
        <!-- Standard C++ include format -->
        <title>Formato de inclusión del estándar C++</title>

        <!-- As C++ evolved, different compiler vendors chose different
        extensions for file names. In addition, various operating
        systems have different restrictions on file names, in particular
        on name length. These issues caused source code portability
        problems. To smooth over these rough edges, the standard uses a
        format that allows file names longer than the notorious eight
        characters and eliminates the extension. For example, instead of
        the old style of including iostream.h, which looks like this:
        -->
	<para>
	  A medida que C++ evolucionaba, los diferentes fabricantes de
	  compiladores elegían diferentes extensiones para los nombres
	  de ficheros. Además, cada sistema operativo tiene sus propias
	  restricciones para los nombres de ficheros, en particular la
	  longitud. Estas características crearon problemas de
	  portabilidad del código fuente. Para limar estos problemas, el
	  estándar usa un formato que permite los nombres de ficheros
	  más largos que los famosos ocho caracteres y permite eliminar
	  la extensión. Por ejemplo en vez de escribir
	  <filename>iostream.h</filename> en el estilo antiguo, que se
	  asemejaría a algo así:
	</para>


<programlisting>
#include &lt;iostream.h&gt;
</programlisting>

        <!-- you can now write: -->
	<para>
	  ahora se puede escribir:
	</para>


<programlisting>
#include &lt;iostream&gt;
</programlisting>


        <!--
        The translator can implement the include statements in a way that suits
        the needs of that particular compiler and operating system, if necessary
        truncating the name and adding an extension. Of course, you can also
        copy the headers given you by your compiler vendor to ones without
        extensions if you want to use this style before a vendor has provided
        support for it.
        -->
	<para>
	  El traductor puede implementar la sentencia del
	  <kw>include</kw> de tal forma que se amolde a las necesidades
	  de un compilador y sistema operativo particular, aunque sea
	  necesario truncar el nombre y añadir una
	  extensión. Evidentemente, también puede copiar las cabeceras
	  que ofrece el fabricante de su compilador a otras sin
	  extensiones si quiere usar este nuevo estilo antes de que su
	  fabricante lo soporte.
	</para>

        <!-- The libraries that have been inherited from C are still
        available with the traditional ??.h?? extension. However, you
        can also use them with the more modern C++ include style by
        prepending a FIXME:LETRA:??c?? before the name. Thus: -->
	<para>
	  Las librerías heredadas de C aún están disponibles con la
	  extensión tradicional
	  <quote><filename>.h</filename></quote>. Sin embargo, se pueden
	  usar con el estilo de inclusión más moderno colocando una
	  <quote><emphasis>c</emphasis></quote> al nombre. Es decir:
	</para>


<programlisting>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</programlisting>

        <!-- become: -->
	<para>
	  Se transformaría en:
	</para>


<programlisting>
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
</programlisting>


        <!--
        And so on, for all the Standard C headers. This provides a nice
        distinction to the reader indicating when you??re using C versus C++
        libraries.
        -->
	<para>
          Y así para todas cabeceras del C Estándar. Eso proporciona al
          lector una distinción interesante entre el uso de librerías C
          versus C++.
	</para>


        <!-- The effect of the new include format is not identical to
        the old: using the .h gives you the older, non-template version,
        and omitting the FIXME:LETRA:.h gives you the new templatized
        version. You??ll usually have problems if you try to intermix
        the two forms in a single program.  -->
	<para>
          El efecto del nuevo formato de include no es idéntico al
          antiguo: usar el <quote><filename>.h</filename></quote> da
          como resultado una versión más antigua, sin plantillas, y
          omitiendo el <quote><filename>.h</filename></quote> le ofrece
          la nueva versión con plantillas. Normalmente podría tener
          problemas si intenta mezclar las dos formas de inclusión en un
          mismo programa.
        </para>
      </sect3>
    </sect2>

    <sect2>
      <!-- Linking -->
      <title>Enlazado</title>

      <!--
      The linker collects object modules (which often use file name extensions
      like .o or .obj), generated by the compiler, into an executable program
      the operating system can load and run. It is the last phase of the
      compilation process.
      -->
      <para>
        El enlazador (<foreignphrase>linker</foreignphrase>) agrupa los
        módulos objeto (que a menudo tienen extensiones como
        <filename>.o</filename> ó <filename>.obj</filename>), generados
        por el compilador, en un programa ejecutable que el sistema
        operativo puede cargar y ejecutar. Es la última fase del proceso
        de compilación.
      </para>

      <!--
      Linker characteristics vary from system to system. In general, you just
      tell the linker the names of the object modules and libraries you want
      linked together, and the name of the executable, and it goes to
      work. Some systems require you to invoke the linker yourself. With most
      C++ packages you invoke the linker through the C++ compiler. In many
      situations, the linker is invoked for you invisibly.
      -->
      <para>
        Las características del enlazador varían de un sistema a
        otro. En general, simplemente se indican al enlazador los
        nombres de los módulos objeto, las librerías que se desean
        enlazar y el nombre del ejecutable de salida. Algunos sistemas
        requieren que sea el programador el que invoque al enlazador,
        aunque en la mayoría de los paquetes de C++ se llama al
        enlazador a través del compilador. En muchas situaciones, de
        manera transparente.
      </para>

      <!--
      Some older linkers won??t search object files and libraries more than
      once, and they search through the list you give them from left to
      right. This means that the order of object files and libraries can be
      important. If you have a mysterious problem that doesn??t show up until
      link time, one possibility is the order in which the files are given to
      the linker.
      -->
      <para>
        Algunos enlazadores antiguos no buscaban ficheros objeto más de
        una vez y buscaban en la lista que se les pasaba de izquierda a
        derecha. Esto significa que el orden de los ficheros objeto y
        las librerías puede ser importante. Si se encuentra con algún
        problema misterioso que no aparece hasta el proceso de enlazado,
        una posible razón es el orden en el que se indican los ficheros
        al enlazador.
      </para>

    </sect2>

    <sect2>
      <!-- Using libraries -->
      <title>Uso de librerías</title>

      <!--
      Now that you know the basic terminology, you can understand how to use a
      library. To use a library:
      -->
      <para>
        Ahora que ya conoce la terminología básica, puede entender cómo
        utilizar una librería. Para usarla:
      </para>

      <!--
      1. Include the library??s header file.  2. Use the functions and
      variables in the library.  3. Link the library into the executable
      program.
      -->
      <orderedlist>
        <listitem>
          <para>
            Se incluye el fichero de cabecera de la librería.
          </para>
        </listitem>
        <listitem>
          <para>
            Se usan las funciones y las variables de la librería.
          </para>
        </listitem>
        <listitem>
          <para>
            Se enlaza la librería junto con el programa ejecutable.
          </para>
        </listitem>
      </orderedlist>

      <!--
      These steps also apply when the object modules aren??t combined into a
      library. Including a header file and linking the object modules are the
      basic steps for separate compilation in both C and C++.
      -->
      <para>
        Estos pasos también se aplican cuando los módulos objeto no se combinan
        para formar una librería. Incluir el fichero cabecera y enlazar los
        módulos objeto es la base para la compilación separada en C y en C++.
      </para>

      <sect3>
        <!-- How the linker searches a library -->
        <title>Cómo busca el enlazador una librería</title>

        <!--
        When you make an external reference to a function or variable in C or
        C++, the linker, upon encountering this reference, can do one of two
        things. If it has not already encountered the definition for the
        function or variable, it adds the identifier to its list of ??unresolved
        references.?? If the linker has already encountered the definition, the
        reference is resolved.
        -->
        <para>
          Cuando se hace una refencia externa a una función o una
          variable en C o C++, al enlazador, una vez encontrada esta
          referencia, puede hacer dos cosas. Si todavía no ha encontrado
          la definición de la función o variable, añade el identificador
          a su lista de <quote>referencias no resueltas</quote>. Si el
          enlazador ya había encontrado la definición, se resuelve la
          referencia.
        </para>

        <!--
        If the linker cannot find the definition in the list of object modules,
        it searches the libraries. Libraries have some sort of indexing so the
        linker doesn??t need to look through all the object modules in the
        library ? it just looks in the index. When the linker finds a definition
        in a library, the entire object module, not just the function
        definition, is linked into the executable program. Note that the whole
        library isn??t linked, just the object module in the library that
        contains the definition you want (otherwise programs would be
        unnecessarily large). If you want to minimize executable program size,
        you might consider putting a single function in each source code file
        when you build your own libraries. This requires more editing[27], but
        it can be helpful to the user.
        -->
        <para>
          Si el enlazador no puede encontrar la definición en la lista
          de módulos objeto, busca en las librerías. Las librerías
          tienen algún tipo de indexación para que el enlazador no
          necesite buscar en todos los módulos objeto en la librería -
          solamente mira en el índice. Cuando el enlazador encuentra una
          definición en una librería, el módulo objeto entero, no sólo
          la definición de la función, se enlaza al programa
          ejecutable. Dese cuenta que no se enlaza la librería completa,
          tan solo el módulo objeto de la librería que contiene la
          definición que se necesita (de otra forma los programas se
          volverían innecesariamente largos). Si se desea minimizar el
          tamaño del programa ejecutable, se debería considerar poner
          una única función en cada fichero fuente cuando se construyan
          librerías propias. Esto requiere más trabajo de edición,
	  <footnote>
	    <!--
	    [27] I would recommend using Perl or Python to automate this task as
	    part of your library-packaging process (see www.Perl.org or
	    www.Python.org).
	    -->
	    <para>
	      Yo le recomendaría usar Perl o Python para automatizar
	      estas tareas como parte de su proceso de empaquetamiento de
	      librerías (ver <ulink
		url="http://www.perl.org">www.Perl.org</ulink> ó <ulink
		url="http://www.python.org">www.Python.org</ulink>).
	    </para>
	  </footnote> pero puede ser muy útil para el usuario.
        </para>

        <!-- Because the linker searches files in the order you give
        them, you can pre-empt the use of a library function by
        inserting a file with your own function, using the same function
        name, into the list before the library name appears. Since the
        linker will resolve any references to this function by using
        your function before it searches the library, your function is
        used instead of the library function. Note that this can also be
        a bug, and the kind of thing C++ namespaces prevent.  -->
        <para>
          Debido a que el enlazador busca los ficheros en el orden que
          se le dan, se puede prevenir el uso de una función de una
          librería insertando un fichero con su propia función, usando
          el mismo nombre de función, en la lista antes de que aparezca
          el nombre de la librería. Cuando el enlazador resuelva
          cualquier referencia a esa función encontrando la función
          antes de buscar en la librería, se utilizará su función en
          lugar de la que se encuentra en la librería. Eso también puede
          ser una fuente de errores, y es la clase de cosas que se puede
          evitar usando los espacios de nombres
          (<foreignphrase>namespaces</foreignphrase>) de C++.
        </para>
      </sect3>



      <sect3>
        <!-- Secret additions -->
        <title>Añadidos ocultos</title>

        <!--
        When a C or C++ executable program is created, certain items are
        secretly linked in. One of these is the startup module, which contains
        initialization routines that must be run any time a C or C++ program
        begins to execute. These routines set up the stack and initialize
        certain variables in the program.
        -->
        <para>
          Cuando se crea un programa ejecutable en C/C++, ciertos
          elementos se enlazan en secreto. Uno de estos elementos es el
          módulo de arranque, que contiene rutinas de inicialización que
          deben ejecutarse cada vez que arranca un programa C o
          C++. Estas rutinas preparan la pila e inicializan ciertas
          variables del programa.
        </para>

        <!--
        The linker always searches the standard library for the compiled
        versions of any ??standard?? functions called in the program. Because
        the standard library is always searched, you can use anything in that
        library by simply including the appropriate header file in your program;
        you don??t have to tell it to search the standard library. The iostream
        functions, for example, are in the Standard C++ library. To use them,
        you just include the <iostream> header file.
        -->
        <para>
          El enlazador siempre busca la librería estándar para las versiones
          compiladas de cualquier función <quote>estándar</quote> llamada en el
          programa. Debido a que se busca siempre en la librería estándar, se
          puede usar cualquier cosa de esta librería simplemente añadiendo a su
          programa la cabecera apropiada; no necesita indicar dónde hay que
          buscar la librería estándar. Las funciones de flujo de entrada-salida
          (iostream), por ejemplo, están en la Librería Estándar de C++. Para
          usarla, sólo debe incluir el fichero de cabecera
          <filename>&lt;iostream&gt;</filename>.
        </para>

        <!--
        If you are using an add-on library, you must explicitly add the library
        name to the list of files handed to the linker.
        -->
        <para>
          Si se está usando una librería, se debe añadir explícitamente
          su nombre de ésta a la lista de ficheros manejados por el
          enlazador.
        </para>
      </sect3>

<!-- FIXME: me quedé aquí: magmax -->

      <sect3>
        <!-- Using plain C libraries -->
        <title>Uso de librerías C plano</title>

        <!--
        Just because you are writing code in C++, you are not prevented from
        using C library functions. In fact, the entire C library is included by
        default into Standard C++. There has been a tremendous amount of work
        done for you in these functions, so they can save you a lot of time.
        -->
        <para>
          Aunque esté escribiendo código en C++, nada le impide usar
          librerías de C. De hecho, toda la librería de C está incluida
          por defecto en el C++ Estándar. Hay una cantidad tremenda de
          trabajo ya realizado en esas librerías que le pueden ahorrar
          un montón de tiempo.
        </para>

        <!--
        This book will use Standard C++ (and thus also Standard C) library
        functions when convenient, but only standard library functions will be
        used, to ensure the portability of programs. In the few cases in which
        library functions must be used that are not in the C++ standard, all
        attempts will be made to use POSIX-compliant functions. POSIX is a
        standard based on a Unix standardization effort that includes functions
        that go beyond the scope of the C++ library. You can generally expect to
        find POSIX functions on Unix (in particular, Linux) platforms, and often
        under DOS/Windows. For example, if you??re using multithreading you are
        better off using the POSIX thread library because your code will then be
        easier to understand, port and maintain (and the POSIX thread library
        will usually just use the underlying thread facilities of the operating
        system, if these are provided).
        -->
        <para>
          Este libro usará la librería Estándar de C++ cuando sea
          necesario (y por lo tanto la de C), pero sólo se utilizarán
          funciones de la librería <emphasis>estándar</emphasis>, para
          asegurar la portabilidad de los programas. En los pocos casos
          en los que las funciones no sean de C++ estándar, se intentará
          que sean funciones compatibles con POSIX. POSIX es un estándar
          basado en el esfuerzo por conseguir la estandarización de
          Unix, que incluye funciones que van más allá del ámbito de las
          librerías de C++. Normalmente puede esperar encontrar
          funciones POSIX en plataformas Unix (en particular,
          GNU/Linux), y a menudo en sistemas DOS/Windows. Por ejemplo,
          si está usando hilos (<foreignphrase>threads</foreignphrase>)
          será mejor usar la librería de hilos compatible con POSIX ya
          que su código será más fácil de entender, portar y mantener (y
          la librería de hilos usará los servicios que ofrece el sistema
          operativo, si es que están soportados).
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <!-- Your first C++ program -->
    <title>Su primer programa en C++</title>

    <!--
    You now know almost enough of the basics to create and compile a
    program. The program will use the Standard C++ iostream classes. These
    read from and write to files and ??standard?? input and output (which
    normally comes from and goes to the console, but may be redirected to
    files or devices). In this simple program, a stream object will be used
    to print a message on the screen.
    -->
    <para>
      Ahora ya tiene suficientes conocimientos para crear y compilar un
      programa. Este programa usará las clases de <emphasis>flujo de
      entrada-salida</emphasis> (<filename>iostream</filename>) del C++
      estándar. <filename>iostream</filename> es capaz de leer y
      escribir en ficheros o en la entrada y salida estándar (que suele
      ser la consola, pero que puede ser redirigida a ficheros o
      dispositivos). En este programa simple, se usa un objeto
      <classname>stream</classname> (flujo) para imprimir un mensaje en
      pantalla.
    </para>


    <sect2>
      <!-- Using the iostreams class -->
      <title>Uso de las clases <classname>iostream</classname></title>

      <!--
      To declare the functions and external data in the iostreams class,
      include the header file with the statement
      -->
      <para>
	Para declarar las funciones y los datos externos que contenga la
	clase <filename>iostream</filename> hay que incluir el fichero
	de cabecera de la siguiente manera:
      </para>


<programlisting>
#include &lt;iostream&gt;
</programlisting>


      <!--
      The first program uses the concept of standard output, which means ??a
      general-purpose place to send output.?? You will see other examples
      using standard output in different ways, but here it will just go to the
      console. The iostream package automatically defines a variable (an
      object) called cout that accepts all data bound for standard output.
      -->
      <para>
	El primer programa usa el concepto de salida estándar, que
	significa <quote>un lugar de propósito general, al que se le
	pueden enviar cosas</quote>. Verá otros ejemplos que utilizan la
	salida estándar de otras formas, pero aquí simplemente usaremos
	la consola. El paquete <filename>iostream</filename> define una
	variable (un objeto) llamado <varname>cout</varname> de forma
	automática que es capaz de enviar todo tipo de datos a la salida
	estándar.
      </para>

      <!--
      To send data to standard output, you use the operator <<. C programmers
      know this operator as the ??bitwise left shift,?? which will be
      described in the next chapter. Suffice it to say that a bitwise left
      shift has nothing to do with output. However, C++ allows operators to be
      overloaded. When you overload an operator, you give it a new meaning
      when that operator is used with an object of a particular type. With
      iostream objects, the operator << means ??send to.?? For example:
      -->
      <para>
	Para enviar datos a la salida estándar, se usa el operador
	<oper>&lt;&lt;</oper>.Los programadores de C lo conocen como
	operador de <quote>desplazamiento a la izquierda</quote>, que se
	explicará en el siguiente capítulo. Baste decir que el
	desplazamiento a la izquierda no tiene nada que ver con la
	salida. Sin embargo, C++ permite que los operadores sean
	<emphasis>sobrecargados</emphasis>. Cuando se sobrecarga un
	operador, se le da un nuevo significado siempre que dicho
	operador se use con un objeto de determinado tipo. Con los
	objetos de <filename>iostream</filename>, el operador
	<oper>&lt;&lt;</oper> significa <quote>enviar a</quote>. Por
	ejemplo:
      </para>


<programlisting>
cout &lt;&lt; "¿Qué tal?";
</programlisting>


      <!--
      sends the string ??howdy!?? to the object called cout (which is short
      for ??console output??).
      -->
      <para>
	envía la cadena <quote>¿Qué tal?</quote> al objeto llamado
	<varname>cout</varname> (que es un diminutivo de <quote>console
	output</quote> (salida por consola).
      </para>

      <!--
      That??s enough operator overloading to get you started. Chapter 12
      covers operator overloading in detail.
      -->
      <para>
	De momento ya hemos visto suficiente sobrecarga de operadores
	como para poder empezar. El <link linkend="C12">Capítulo
	12</link> cubre la sobrecarga de operadores con detalle.
      </para>
    </sect2>

    <sect2>
      <!-- Namespaces -->
      <title>Espacios de nombres</title>

      <!--
      As mentioned in Chapter 1, one of the problems encountered in the C
      language is that you ??run out of names?? for functions and identifiers
      when your programs reach a certain size. Of course, you don??t really
      run out of names; it does, however, become harder to think of new ones
      after awhile. More importantly, when a program reaches a certain size it??
      s typically broken up into pieces, each of which is built and maintained
      by a different person or group. Since C effectively has a single arena
      where all the identifier and function names live, this means that all
      the developers must be careful not to accidentally use the same names in
      situations where they can conflict. This rapidly becomes tedious,
      time-wasting, and, ultimately, expensive.
      -->
      <para>
	Como se menciona en el <link linkend="C01">Capítulo 1</link>,
	uno de los problemas del lenguaje C es que <quote>nos quedamos
	sin nombres</quote> para funciones e identificadores cuando los
	programas llegan a ser de cierto tamaño. Por supuesto que
	realmente no nos quedamos sin nombres; aunque se hace más
	difícil pensar en nombres nuevos después de un rato. Y todavía
	más importante, cuando un programa alcanza cierto tamaño es
	normal fragmentarlo en trozos más pequeños cada uno de los
	cuales es mantenido por diferentes personas o grupos. Como C
	sólo tiene un ruedo para lidiar con todos los identificadores y
	nombres de función, trae como consecuencia que todos los
	desarrolladores deben tener cuidado de no usar accidentalmente
	los mismos nombres en situaciones en las que pueden ponerse en
	conflicto. Esto se convierte en una pérdida de tiempo, se hace
	tedioso y en último término, es más caro.
      </para>

      <!--
      Standard C++ has a mechanism to prevent this collision: the namespace
      keyword. Each set of C++ definitions in a library or program is
      ??wrapped?? in a namespace, and if some other definition has an
      identical name, but is in a different namespace, then there is no
      collision.
      -->
      <para>
	El C++ Estándar tiene un mecanismo para impedir estas
	colisiones: la palabra reservada <kw>namespace</kw> (espacio de
	nombres). Cada conjunto de definiciones de una librería o
	programa se <quote>envuelve</quote> en un espacio de nombres, y
	si otra definición tiene el mismo nombre, pero está en otro
	espacio de nombres, entonces no se produce colisión.
      </para>

      <!-- Namespaces are a convenient and helpful tool, but their
      presence means that you must be aware of them before you can write
      any programs. If you simply include a header file and use some
      functions or objects from that header, you??ll probably get
      strange-sounding errors when you try to compile the program, to
      the effect that the compiler cannot find any of the declarations
      for the items that you just included in the header file! After you
      see this message a few times you??ll become familiar with its
      meaning (which is ??You included the header file but all the
      declarations are within a namespace and you didn??t tell the
      compiler that you wanted to use the declarations in that
      namespace??).  -->
      <para>
	El espacio de nombres es una herramienta útil y conveniente,
	pero su presencia implica que debe saber usarla antes de
	escribir un programa. Si simplemente escribe un fichero de
	cabecera y usa algunas funciones u objetos de esa cabecera,
	probablemente reciba extraños mensajes cuando compile el
	programa, debido a que el compilador no pueda encontrar las
	declaraciones de los elementos del fichero de cabecera. Después
	de ver este mensaje un par de veces se le hará familiar su
	significado (que es: <emphasis>Usted ha incluido el fichero de
	cabecera pero todas las declaraciones están sin un espacio de
	nombres y no le dijo al compilador que quería usar las
	declaraciones en ese espacio de nombres</emphasis>).
      </para>

      <!--
      There??s a keyword that allows you to say ??I want to use the
      declarations and/or definitions in this namespace.?? This keyword,
      appropriately enough, is using. All of the Standard C++ libraries are
      wrapped in a single namespace, which is std (for ??standard??). As this
      book uses the standard libraries almost exclusively, you??ll see the
      following using directive in almost every program:
      -->
      <para>
	Hay una palabra reservada que le permite decir <quote>quiero
	usar las declaraciones y/o definiciones de este espacio de
	nombres</quote>. Esa palabra reservada, bastante apropiada por
	cierto, es <kw>using</kw>. Todas las librerías de C++ Estándar
	están incluidas en un único espacio de nombres, que es
	<literal>std</literal> (por <quote>standard</quote>). Como este
	libro usa la librería estándar casi exclusivamente, verá la
	siguiente <emphasis>directiva using</emphasis> en casi todos los
	programas.
      </para>


<programlisting>
using namespace std;
</programlisting>


      <!--
      This means that you want to expose all the elements from the namespace
      called std. After this statement, you don??t have to worry that your
      particular library component is inside a namespace, since the using
      directive makes that namespace available throughout the file where the
      using directive was written.
      -->
      <para>
	Esto significa que quiere usar todos los elementos del espacio
	de nombres llamado <literal>std</literal>. Después de esta
	sentencia, ya no hay que preocuparse de si su componente o
	librería particular pertenece a un espacio de nombres, porque la
	directiva <kw>using</kw> hace que el espacio de nombres esté
	disponible para todo el fichero donde se escribió la directiva
	<kw>using</kw>.
      </para>

      <!--
      Exposing all the elements from a namespace after someone has gone to the
      trouble to hide them may seem a bit counterproductive, and in fact you
      should be careful about thoughtlessly doing this (as you'll learn later
      in the book). However, the using directive exposes only those names for
      the current file, so it is not quite as drastic as it first sounds. (But
      think twice about doing it in a header file ? that is reckless.)
      -->
      <para>
	Exponer todos los elementos de un espacio de nombres después de
	que alguien se ha molestado en ocultarlos, parece
	contraproducente, y de hecho, el lector deberá tener cuidado si
	considera hacerlo (como aprenderá más tarde en este libro). Sin
	embargo, la directiva <kw>using</kw> expone solamente los
	nombres para el fichero actual, por lo que no es tan drástico
	como suena al principio. (pero pienselo dos veces antes de
	usarlo en un fichero cabecera, eso <emphasis>es</emphasis>
	temerario).
      </para>

      <!-- There??s a relationship between namespaces and the way header
      files are included. Before the modern header file inclusion was
      standardized (without the trailing ??.h??, as in <iostream>), the
      typical way to include a header file was with the
      FIXME:LETRA:??.h??, such as <iostream.h>. At that time, namespaces
      were not part of the language either. So to provide backward
      compatibility with existing code, if you say -->
      <para>
	Existe una relación entre los espacios de nombres y el modo en
	que se incluyes los ficheros de cabecera. Antes de que se
	estandarizara la nueva forma de inclusión de los ficheros
	cabecera (sin el <quote><literal>.h</literal></quote> como en
	<code>&lt;iostream&gt;</code>), la manera típica de incluir un
	fichero de cabecera era con el <quote><literal>.h</literal></quote>
	como en <filename>&lt;iostream.h&gt;</filename>. En esa época
	los espacios de nombres tampoco eran parte del lenguaje, por lo
	que para mantener una compatibilidad hacia atrás con el código
	existente, si se escribía:
      </para>

<programlisting>
#include &lt;iostream.h&gt;
</programlisting>


      <!-- it means -->
      <para>
	En realidad, significaba:
      </para>


<programlisting>
#include &lt;iostream&gt;
using namespace std;
</programlisting>


      <!--
      However, in this book the standard include format will be used (without
      the FIXME:LETRA:'.h') and so the using directive must be explicit.
      -->
      <para>
	Sin embargo en este libro se usará la forma estándar de
	inclusión (sin el <quote><literal>.h</literal></quote>) y
	haciendo explícita la directiva <kw>using</kw>.
      </para>

      <!--
      For now, that??s all you need to know about namespaces, but in Chapter
      10 the subject is covered much more thoroughly.
      -->
      <para>
	Por ahora, esto es todo lo que necesita saber sobre los espacios
	de nombres, pero el <link linkend="C10">Capítulo 10</link> cubre
	esta materia en profundidad.
      </para>

    </sect2>

    <sect2>
      <!-- Fundamentals of program structure -->
      <title>Fundamentos de la estructura de los programa</title>

      <!--
      A C or C++ program is a collection of variables, function definitions,
      and function calls. When the program starts, it executes initialization
      code and calls a special function, ??main( ).?? You put the primary code
      for the program here.
      -->
      <para>
	Un programa C o C++ es una colección de variables, definiciones
	de función, y llamada a funciones. Cuando el programa arranca,
	ejecuta el código de inicialización y llama a una función
	especial, <quote><function>main()</function></quote>, que es
	donde debe colocarse el código principal del programa.
      </para>

      <!--
      As mentioned earlier, a function definition consists of a return type
      (which must be specified in C++), a function name, an argument list in
      parentheses, and the function code contained in braces. Here is a sample
      function definition:
      -->
      <para>
	Como se mencionó anteriormente, una definición de función
	consiste en un valor de retorno (que debe ser especificarse
	obligatoriamente C++), un nombre de función, una lista de
	argumentos, y el código de la función entre llaves. Aquí hay un
	ejemplo de definición de función:
      </para>


<programlisting>
int funcion() {
   // Código de la función aquí (esto es un comentario)
}
</programlisting>


      <!--
      The function above has an empty argument list and a body that contains
      only a comment.
      -->
      <para>
	La función de arriba tiene una lista vacía de argumentos y
	un cuerpo que contiene únicamente un comentario.
      </para>

      <!--
      There can be many sets of braces within a function definition, but there
      must always be at least one set surrounding the function body. Since
      main( ) is a function, it must follow these rules. In C++, main( )
      always has return type of int.
      -->
      <para>
	Puede haber varios pares de llaves en la definición de una
	función, pero siempre debe haber al menos dos que envuelvan todo
	el cuerpo de la función. Como <function>main()</function> es una
	función, debe seguir esas reglas. En C++,
	<function>main()</function> siempre devuelve un valor de tipo
	<type>int</type> (entero).
      </para>

      <!--
      C and C++ are free form languages. With few exceptions, the compiler
      ignores newlines and white space, so it must have some way to determine
      the end of a statement. Statements are delimited by semicolons.
      -->
      <para>
	C y C++ son lenguajes de formato libre. Con un par de
	excepciones, el compilador ignora los espacios en blanco y los
	saltos de línea, por lo que hay que determinar el final de una
	sentencia. Las sentencias están delimitadas por punto y coma.
      </para>

      <!--
      C comments start with /* and end with */. They can include newlines. C++
      uses C-style comments and has an additional type of comment: //. The //
      starts a comment that terminates with a newline. It is more convenient
      than /* */ for one-line comments, and is used extensively in this book.
      -->
      <para>
	Los comentarios en C empiezan con <literal>/*</literal> y
	finalizan con <literal>*/</literal>. Pueden incluir saltos de
	línea. C++ permite este estilo de comentarios y añade la doble
	barra inclinada: <literal>//</literal>. La <literal>//</literal>
	empieza un comentario que finaliza con el salto de línea. Es más
	útil que <literal>/* */</literal> y se usa ampliamente en este
	libro.
      </para>

    </sect2>

    <sect2>
      <!-- "Hello, world!" -->
      <title><quote>Hello, World!</quote></title>

      <!-- And now, finally, the first program: -->
      <para>
	Y por fin, el primer programa:
      </para>


//: V1C02:Hello.cpp


      <!--
      The cout object is handed a series of arguments via the ??<<??
      operators. It prints out these arguments in left-to-right order. The
      special iostream function endl outputs the line and a newline. With
      iostreams, you can string together a series of arguments like this,
      which makes the class easy to use.
      -->
      <para>
	El objeto <varname>cout</varname> maneja una serie de argumentos
	por medio de los operadores <oper>&lt;&lt;</oper>, que imprime
	los argumentos de izquierda a derecha. La función especial
	<function>endl</function> provoca un salto de línea. Con los
	iostreams se puede encadenar una serie de argumentos como aquí,
	lo que hace que se una clase fácil de usar.
      </para>

      <!--
      In C, text inside double quotes is traditionally called a ??string.??
      However, the Standard C++ library has a powerful class called string for
      manipulating text, and so I shall use the more precise term character
      array for text inside double quotes.
      -->
      <para>
	En C, el texto que se encuentra entre comillas dobles se
	denomina <quote>cadena</quote>
	(<foreignphrase>string</foreignphrase>). Sin embargo, la
	librería Estándar de C++ tiene una poderosa clase llamada
	<classname>string</classname> para manipulación de texto, por
	lo que usaremos el término más preciso <emphasis>array de
	caracteres</emphasis> para el texto que se encuentre entre
	dobles comillas.
      </para>

      <!--
      The compiler creates storage for character arrays and stores the ASCII
      equivalent for each character in this storage. The compiler
      automatically terminates this array of characters with an extra piece of
      storage containing the value 0 to indicate the end of the character
      array.
      -->
      <para>
	El compilador pide espacio de memoria para los arrays de
	caracteres y guarda el equivalente ASCII para cada caracter en
	este espacio. El compilador finaliza automáticamente este array
	de caracteres añadiendo el valor 0 para indicar el final.
      </para>

      <!--
      Inside a character array, you can insert special characters by using
      escape sequences. These consist of a backslash (\) followed by a special
      code. For example \n means newline. Your compiler manual or local C
      guide gives a complete set of escape sequences; others include \t (tab),
      \\ (backslash), and \b (backspace).
      -->
      <para>
	Dentro del array de caracteres, se pueden insertar caracteres
	especiales usando las <emphasis>secuencias de escape</emphasis>.
	Consisten en una barra invertida (<literal>\</literal>) seguida
	de un código especial. por ejemplo <literal>\n</literal>
	significa salto de línea. El manual del compilador o la guía
	concreta de C ofrece una lista completa de secuencia; entre
	otras se incluye: <literal>\t</literal> (tabulador),
	<literal>\\</literal> (barra invertida), y <literal>\b</literal>
	(retroceso).
      </para>

      <!--
      Notice that the statement can continue over multiple lines, and that the
      entire statement terminates with a semicolon
      -->
      <para>
	Tenga en cuenta que la sentencia puede continuar en otras
	líneas, y la sentencia completa termina con un punto y coma.
      </para>

      <!--
      Character array arguments and constant numbers are mixed together in the
      above cout statement. Because the operator << is overloaded with a
      variety of meanings when used with cout, you can send cout a variety of
      different arguments and it will ??figure out what to do with the
      message.??
      -->
      <para>
	Los argumentos de tipo array de caracteres y los números
	constantes están mezclados en la sentencia
	<varname>cout</varname> anterior. Como el operador
	<oper>&lt;&lt;</oper> está sobrecargado con varios significados
	cuando se usa con <varname>cout</varname>, se pueden enviar
	distintos argumentos y <varname>cout</varname> se encargará de
	mostrarlos.
      </para>

      <!-- Throughout this book you??ll notice that the first line of
      each file will be a comment that starts with the characters that
      start a comment (typically //), followed by a colon, and the last
      line of the listing will end with a comment followed by
      FIXME:LETRA:??/:~??. This is a technique I use to allow easy
      extraction of information from code files (the program to do this
      can be found in volume two of this book, at
      www.BruceEckel.com). The first line also has the name and location
      of the file, so it can be referred to in text and in other files,
      and so you can easily locate it in the source code for this book
      (which is downloadable from www.BruceEckel.com).  -->
      <para>
	A lo largo de este libro notará que la primera línea de cada
	fichero es un comentario (empezando normalmente con
	<literal>//</literal>), seguido de dos puntos, y la última línea
	de cada listado de código acaba con un comentario seguido de
	<quote>/-</quote>. Se trata de una una técnica que uso para
	extraer fácilmente información de los ficheros fuente (el
	programa que lo hace se puede encontrar en el Volumen 2 de este
	libro, en <ulink
	url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>). La
	primera línea también tiene el nombre y localización del
	fichero, por lo que se puede localizar fácilmente en los fichero
	de código fuente dele libro (que también se puede descargar de
	<ulink
	url="http://www.BruceEckel.com">www.BruceEckel.com</ulink>).
      </para>
    </sect2>


    <sect2>
      <!-- Running the compiler -->
      <title>Utilizar el compilador</title>

      <!--
      After downloading and unpacking the book??s source code, find the
      program in the subdirectory CO2. Invoke the compiler with Hello.cpp as
      the argument. For simple, one-file programs like this one, most
      compilers will take you all the way through the process. For example, to
      use the GNU C++ compiler (which is freely available on the Internet),
      you write:
      -->
      <para>
	Después de descargar y desempaquetar el código fuente del libro,
	busque el programa en el subdirectorio
	<filename>CO2</filename>. Invoque el compilador con
	<filename>Hello.cpp</filename> como parámetro. La mayoría de los
	compiladores le abstraen de todo el proceso si el programa
	consta de un único fichero. Por ejemplo, para usar el compilador
	GNU C++ (que está disponible en Internet), escriba:
      </para>

<screen>
g++ Hello.cpp
</screen>

      <!--
      Other compilers will have a similar syntax; consult your compiler??s
      documentation for details.
      -->
      <para>
	Otros compiladores tendrán una sintaxis similar aunque tendrá
	que consultar la documentación para conocer los detalles
	particulares.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <!-- More about FIXME:iostreams -->
    <title>Más sobre iostreams</title>

    <!--
    So far you have seen only the most rudimentary aspect of the iostreams
    class. The output formatting available with iostreams also includes
    features such as number formatting in decimal, octal, and
    hexadecimal. Here??s another example of the use of iostreams:
    -->
    <para>
      Hasta ahora sólo ha visto los aspectos más rudimentarios de las
      clases <filename>iostream</filename>. El formateo de salida que
      permiten los iostreams también incluyen características como el
      formateo de números en decimal, octal, y hexadecimal. Aquí tiene
      otro ejemplo del uso de los iostreams:
    </para>


//: V1C02:Stream2.cpp


    <!--
    This example shows the iostreams class printing numbers in decimal,
    octal, and hexadecimal using iostream manipulators (which don??t print
    anything, but change the state of the output stream). The formatting of
    floating-point numbers is determined automatically by the compiler. In
    addition, any character can be sent to a stream object using a cast to a
    char (a char is a data type that holds single characters). This cast
    looks like a function call: char( ), along with the character??s ASCII
    value. In the program above, the char(27) sends an ??escape?? to cout.
    -->
    <para>
      Este ejemplo muestra cómo la clase
      <classname>iostreams</classname> imprime números en decimal,
      octal, y hexadecimal usando <emphasis>manipuladores</emphasis>
      (los cuales no imprimen nada, pero cambian el estado del flujo de
      salida). El formato de los números en punto flotante lo determina
      automáticamente el compilador. Además, cualquier se puede enviar
      cualquier caracter a un objeto <classname>stream</classname>
      usando un molde (<foreignphrase>cast</foreignphrase>) a
      <type>char</type> (un <type>char</type> es un tipo de datos que
      manipula un sólo caracter). Este molde parece una llamada a
      función: <code>char()</code>, devuelve un valor ASCII. En el
      programa de arriba, el <code>char(27)</code> envía un
      <quote>escape</quote> a <varname>cout</varname>.
    </para>


    <sect2>
      <!-- Character array concatenation -->
      <title>Concatenar vectores de caracteres</title>

      <!--
      An important feature of the C preprocessor is character array
      concatenation. This feature is used in some of the examples in this
      book. If two quoted character arrays are adjacent, and no punctuation is
      between them, the compiler will paste the character arrays together into
      a single character array. This is particularly useful when code listings
      have width restrictions:
      -->
      <para>
	Una característica importante del preprocesador de C es la
	<emphasis>concatenación de arrays de caracteres</emphasis>.
	Esta característica se usa en algunos de los ejemplos de este
	libro. Si se colocan juntos dos arrays de caracteres
	entrecomillados, sin signos de puntuación entre ellos, el
	compilador los pegará en un único array de caracteres. Esto es
	particularmente útil cuando los listados de código tienen
	restricciones de anchura.
      </para>


//: V1C02:Concat.cpp


      <!--
      At first, the code above can look like an error because there??s no
      familiar semicolon at the end of each line. Remember that C and C++ are
      free-form languages, and although you??ll usually see a semicolon at the
      end of each line, the actual requirement is for a semicolon at the end
      of each statement, and it??s possible for a statement to continue over
      several lines.
      -->
      <para>
	Al principio, el código de arriba puede parecer erróneo porque
	no está el ya familiar punto y coma al final de cada
	línea. Recuerde que C y C++ son lenguajes de formato libre, y
	aunque normalmente verá un punto y coma al final de cada línea,
	el requisito real es que haya un punto y coma al final de cada
	sentencia, por lo que es posible encontrar una sentencia que ocupe
	varias líneas.
      </para>
    </sect2>

    <sect2>
      <!-- Reading input -->
      <title>Leer de la entrada</title>

      <!--
      The iostreams classes provide the ability to read input. The object used
      for standard input is cin (for ??console input??). cin normally expects
      input from the console, but this input can be redirected from other
      sources. An example of redirection is shown later in this chapter.
      -->
      <para>
	Las clases <classname>iostream</classname> proporcionan la
	habilidad de leer de la entrada. El objeto usado para la entrada
	estándar es <varname>cin</varname> (de
	<quote><foreignphrase>console
	input</foreignphrase></quote>). <varname>cin</varname>
	normalmente espera la entrada de la consola, pero esta entrada
	se puede redirigir desde otras fuentes. Un ejemplo de
	redirección se muestra más adelante en este capítulo.
      </para>

      <!-- The iostreams operator used with cin is >>. This operator
      waits for the same kind of input as its argument. For example, if
      you give it an integer argument, it waits for an integer from the
      console. Here??s an example: -->
      <para>
	El operador que usa <classname>iostream</classname> con el
	objeto <varname>cin</varname> es <oper>&gt;&gt;</oper>. Este
	operador espera como parámetro algún tipo de entrada. Por
	ejemplo, si introduce un parámetro de tipo entero, él espera un
	entero de la consola. Aquí hay un ejemplo:
      </para>


//: V1C02:Numconv.cpp


      <!--
      This program converts a number typed in by the user into octal and
      hexadecimal representations.
      -->
      <para>
	Este programa convierte un número introducido por el usuario
	en su representación octal y hexadecimal.
      </para>
    </sect2>

    <sect2>
      <!-- Calling other programs -->
      <title>Llamar a otros programas</title>

      <!--
      While the typical way to use a program that reads from standard input
      and writes to standard output is within a Unix shell script or DOS batch
      file, any program can be called from inside a C or C++ program using the
      Standard C system( ) function, which is declared in the header file
      -->
      <para>
	Mientras que el modo típico de usar un programa que lee de la
	entrada estándar y escribe en la salida estándar es dentro de un
	<emphasis>shell script</emphasis>
	<productname>Unix</productname> o en un fichero
	<foreignphrase>batch</foreignphrase> de
	<productname>DOS</productname>, cualquier programa se puede
	llamar desde dentro de un programa C o C++ usando la llamada a
	la función estándar <function>system()</function> que está
	declarada en el fichero de cabecera
	<filename>&lt;cstdlib&gt;:</filename>.
      </para>


//: V1C02:CallHello.cpp


      <!--
      To use the system( ) function, you give it a character array that you
      would normally type at the operating system command prompt. This can
      also include command-line arguments, and the character array can be one
      that you fabricate at run time (instead of just using a static character
      array as shown above). The command executes and control returns to the
      program.
      -->
      <para>
	Para usar la función <function>system()</function>, hay que
	pasarle un array de caracteres con la línea de comandos que se
	quiere ejecutar en el prompt del sistema operativo. Puede
	incluir los parámetros que utilizaría en la línea de comandos, y
	el array de caracteres se puede fabricar en tiempo de
	ejecución (en vez de usar un array de caracteres estático como
	se mostraba arriba). El comando se ejecuta y el control vuelve
	al programa.
      </para>

      <!--
      This program shows you how easy it is to use plain C library functions
      in C++; just include the header file and call the function. This upward
      compatibility from C to C++ is a big advantage if you are learning the
      language starting from a background in C.
      -->
      <para>
	Este programa le muestra lo fácil que es usar C plano en
	C++; sólo incluya la cabecera y utilice la función. Esta
	compatibilidad ascendente entre el C y el C++ es una gran
	ventaja si está aprendiendo C++ y ya tenía conocimientos de
	C.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <!-- Introducing strings -->
    <title>Introdución a las cadenas</title>

    <!--
    While a character array can be fairly useful, it is quite limited. It??s
    simply a group of characters in memory, but if you want to do anything
    with it you must manage all the little details. For example, the size of
    a quoted character array is fixed at compile time. If you have a
    character array and you want to add some more characters to it, you??ll
    need to understand quite a lot (including dynamic memory management,
    character array copying, and concatenation) before you can get your
    wish. This is exactly the kind of thing we??d like to have an object do
    for us.
    -->
    <para>
      Un array de caracteres puede ser bastante útil, aunque está
      bastante limitado. Simplemente son un grupo de caracteres en
      memoria, pero si quiere hacer algo útil, debe manejar todos los
      pequeños detalles. Por ejemplo, el tamaño de un array de
      caracteres es fijo en tiempo de compilación. Si tiene un array de
      caracteres y quiere añadirle más caracteres, tendrá que saber
      mucho sobre ellos (incluso manejo dinámico de memoria, copia de
      array de caracteres, y concatenación) antes de conseguir lo que
      desea. Esta es exactamente la clase de cosas que desearíamos que
      hiciera un objeto por nosotros.
    </para>

    <!--
    The Standard C++ string class is designed to take care of (and hide) all
    the low-level manipulations of character arrays that were previously
    required of the C programmer. These manipulations have been a constant
    source of time-wasting and errors since the inception of the C
    language. So, although an entire chapter is devoted to the string class
    in Volume 2 of this book, the string is so important and it makes life
    so much easier that it will be introduced here and used in much of the
    early part of the book.
    -->
    <para>
      La clase <classname>string</classname> (cadena) del C++ Estándar
      ha sido diseñada para que se encargue y oculte las manipulaciones
      de bajo nivel de los arrays de caracteres que antes tenía que
      realizar el programador de C. Estas manipulaciones han sido una
      fuente de constantes pérdidas de tiempo y errores desde los
      orígenes del lenguaje C. Aunque hay un capítulo entero dedicado a
      la clase <classname>string</classname> en el Volumen 2 de este
      libro, las cadenas son tan importantes y facilitan tanto la vida
      que las presentaré aquí para usarlas lo antes posible en el libro.
    </para>

    <!--
    To use strings you include the C++ header file <string>. The string
    class is in the namespace std so a using directive is necessary. Because
    of operator overloading, the syntax for using strings is quite
    intuitive:
    -->
    <para>
      Para usar las cadenas debe incluir el fichero de cabecera
      <filename>&lt;string&gt;</filename>. La clase
      <classname>string</classname> se encuentra en el espacio de
      nombres <literal>std</literal> por lo que se necesita usar la
      directiva <kw>using</kw>. Gracias a la sobrecarga de operadores,
      la sintaxis del uso de las cadenas es muy intuitiva:
    </para>


//: V1C02:HelloStrings.cpp


    <!--
    The first two strings, s1 and s2, start out empty, while s3 and s4 show
    two equivalent ways to initialize string objects from character arrays
    (you can just as easily initialize string objects from other string
    objects).
    -->
    <para>
      Las dos primeras cadenas, <varname>s1</varname> y
      <varname>s2</varname> empiezan estando vacías, mientras que
      <varname>s3</varname> y <varname>s4</varname> muestran dos formas
      de inicializar los objetos <classname>string</classname> con
      arrays de caracteres (puede inicializar objetos
      <classname>string</classname> igual de fácil con otros objetos
      <classname>string</classname>).
    </para>

    <!--
    You can assign to any string object using ??=??. This replaces the
    previous contents of the string with whatever is on the right-hand side,
    and you don??t have to worry about what happens to the previous contents
    ? that??s handled automatically for you. To combine strings you simply
    use the ??+?? operator, which also allows you to combine character
    arrays with strings. If you want to append either a string or a
    character array to another string, you can use the operator ??+=??.
    Finally, note that iostreams already know what to do with strings, so
    you can just send a string (or an expression that produces a string,
    which happens with s1 + s2 + "!") directly to cout in order to print it.
    -->
    <para>
      Se puede asignar a un objeto <classname>string</classname> usando
      <oper>=</oper>. Eso sustituye el contenido previo de la cadena con
      lo que se encuentra en el lado derecho de la asignación, y no hay
      que preocuparse de lo que ocurre con el contenido anterior porque
      se controla automáticamente. Para combinar las cadenas simplemente
      debe usar el operador de suma <quote>+</quote>, que tambien le
      permite concatenar cadenas (<classname>strings</classname>) con
      arrays de caracteres. Si quiere añadir una cadena o un array de
      caracteres a otra cadena, puede usar el operador
      <oper>+=</oper>. Finalmente, dése cuenta que
      <classname>iostream</classname> sabe como tratar las cadenas, por
      lo que usted puede enviar una cadena (o una expresión que produzca
      un <classname>string</classname>, que es lo que sucede con
      <code>s1 + s2 + "!"</code>>) directamente a
      <varname>cout</varname> para imprimirla.
    </para>
  </sect1>

  <sect1>
    <!-- Reading and writing files -->
    <title>Lectura y escritura de ficheros</title>

    <!--
    In C, the process of opening and manipulating files requires a lot of
    language background to prepare you for the complexity of the
    operations. However, the C++ iostream library provides a simple way to
    manipulate files, and so this functionality can be introduced much
    earlier than it would be in C.
    -->
    <para>
      En C, el proceso de abrir y manipular ficheros requería un gran
      conocimiento del lenguaje para prepararle para la complejidad de
      las operaciones. Sin embargo, la librería
      <classname>iostream</classname> de C++ proporciona una forma
      simple de manejar ficheros, y por eso se puede presentar mucho
      antes de lo que se haría en C.
    </para>

    <!--
    To open files for reading and writing, you must include
    generally prudent to explicitly include <iostream> if you??re planning
    to use cin, cout, etc.
    -->
    <para>
      Para poder abrir un fichero para leer y escribir, debe incluir la
      librería <classname>fstream</classname>. Aunque eso implica la
      inclusión automática de la librería
      <classname>iostream</classname>, es prudente incluir
      <classname>iostream</classname> si planea usar
      <varname>cin</varname>, <varname>cout</varname>, etc.
    </para>

    <!--
    To open a file for reading, you create an ifstream object, which then
    behaves like cin. To open a file for writing, you create an ofstream
    object, which then behaves like cout. Once you??ve opened the file, you
    can read from it or write to it just as you would with any other
    iostream object. It??s that simple (which is, of course, the whole
    point).
    -->
    <para>
      Para abrir un fichero para lectura, debe crear un objeto
      <classname>ifstream</classname> que se usará como
      <varname>cin</varname>. Para crear un fichero de escritura, se
      crea un objeto <classname>ofstream</classname> que se comporta
      como <varname>cout</varname>. Una vez que tiene abierto el fichero
      puede leer o escribir en él como si usara cualquier objeto
      <classname>iostream</classname>. Así de simple, que es el objetivo, por
      supuesto.
    </para>

    <!--
    One of the most useful functions in the iostream library is getline( ),
    which allows you to read one line (terminated by a newline) into a
    string object[28]. The first argument is the ifstream object you??re
    reading from and the second argument is the string object. When the
    function call is finished, the string object will contain the line.
    -->
    <para>
      Una de funciones las más útiles de la librería
      <classname>iostream</classname> es <function>getline()</function>,
      que permite leer una línea (terminada en nueva línea) y guardarla
      en un objeto <classname>string</classname>
      <footnote>
	<!--
	[28] There are actually a number of variants of getline( ),
	which will be discussed thoroughly in the iostreams chapter in
	Volume 2.
	-->
	<para>
	  Actualmente existen variantes de
	  <function>getline()</function>, que se discutirán profusamente
	  en el capítulo de <classname>iostreams</classname> en el
	  Volumen 2
	</para>
      </footnote>. El primer argumento es el objeto
      <classname>ifstream</classname> del que se va a leer la
      información y el segundo argumento es el objeto
      <classname>string</classname>. Cuando termina la llamada a la
      función, el objeto <classname>string</classname> contiene la
      línea capturada.
    </para>

    <!--
    Here??s a simple example, which copies the contents of one file into
    another:
    -->
    <para>
      Aquí hay un ejemplo que copia el contenido de un fichero en otro.
    </para>



//: V1C02:Scopy.cpp


    <!--
    To open the files, you just hand the ifstream and ofstream objects the
    file names you want to create, as seen above.
    -->
    <para>
      Para abrir los ficheros, únicamente debe controlar los
      nombres de fichero que se usan en la creación de los objetos
      <classname>ifstream</classname> y
      <classname>ofstream</classname>.
    </para>


    <!--
    There is a new concept introduced here, which is the while
    loop. Although this will be explained in detail in the next chapter, the
    basic idea is that the expression in parentheses following the while
    controls the execution of the subsequent statement (which can also be
    multiple statements, wrapped inside curly braces). As long as the
    expression in parentheses (in this case, getline(in, s)) produces a
    ??true?? result, then the statement controlled by the while will
    continue to execute. It turns out that getline( ) will return a value
    that can be interpreted as ??true?? if another line has been read
    successfully, and ??false?? upon reaching the end of the input. Thus,
    the above while loop reads every line in the input file and sends each
    line to the output file.
    -->
    <para>
      Aquí se presenta un nuevo concepto: el bucle
      <kw>while</kw>. Aunque será explicado en detalle en el siguiente
      capítulo, la idea básica consiste en que la expresión entre
      paréntesis que sigue al <kw>while</kw> controla la ejecución de la
      sentencia siguiente (pueden ser múltiples sentencias encerradas
      entre llaves). Mientras la expresión entre paréntesis (en este
      caso <code>getline(in, s)</code> produzca un resultado
      <quote>verdadero</quote>, las sentencias controladas por el
      <kw>while</kw> se ejecutarán. <function>getline()</function>
      devuelve un valor que se puede interprer como
      <quote>verdadero</quote> si se ha leido otra línea de forma
      satisfactoria, y <quote>falso</quote> cuando se llega al final de
      la entrada. Eso implica que el <kw>while</kw> anterior
      lee todas las líneas del fichero de entrada y las envía al fichero
      de salida.
    </para>

    <!--
    getline( ) reads in the characters of each line until it discovers a
    newline (the termination character can be changed, but that won??t be an
    issue until the iostreams chapter in Volume 2). However, it discards the
    newline and doesn??t store it in the resulting string object. Thus, if
    we want the copied file to look just like the source file, we must add
    the newline back in, as shown.
    -->
    <para>
      <function>getline()</function> lee los caracteres de cada línea
      hasta que descubre un salto de línea (el caracter de terminación
      se puede cambiar pero eso no se verá hasta el capítulo sobre
      <classname>iostreams</classname> del Volumen 2). Sin embargo,
      descarta el caracter de nueva línea y no lo almacena en el objeto
      <classname>string</classname>. Por lo que si queremos copiar el
      fichero de forma idéntica al original, debemos añadir el caracter
      de nueva línea como se muestra arriba.
    </para>

    <!--
    Another interesting example is to copy the entire file into a single
    string object:
    -->
    <para>
      Otro ejemplo interesante es copiar el fichero entero en un único
      objeto <classname>string</classname>:
    </para>


//: V1C02:FillString.cpp


    <!--
    Because of the dynamic nature of strings, you don??t have to worry about
    how much storage to allocate for a string; you can just keep adding
    things and the string will keep expanding to hold whatever you put into
    it.
    -->
    <para>
      Debido a la naturaleza dinámica de los
      <classname>strings</classname>, no hay que preocuparse de la
      cantidad de memoria que hay qye reservar para el
      <classname>string</classname>. Simplemente hay que añadir cosas y
      el <classname>string</classname> irá expandiéndose para dar cabida
      a lo que le introduzca.
    </para>

    <!--
    One of the nice things about putting an entire file into a string is
    that the string class has many functions for searching and manipulation
    that would then allow you to modify the file as a single
    string. However, this has its limitations. For one thing, it is often
    convenient to treat a file as a collection of lines instead of just a
    big blob of text. For example, if you want to add line numbering it??s
    much easier if you have each line as a separate string object. To
    accomplish this, we??ll need another approach.
    -->
    <para>
      Una de las cosas agradables de poner el fichero entero en una
      cadena es que la clase <classname>string</classname> proporciona
      funciones para la búsqueda y manipulación que le permiten
      modificar el fichero como si fuera una simple línea. Sin embargo,
      tiene sus limitaciones. Por un lado, a menudo, es conveniente
      tratar un fichero como una colección de líneas en vez de un gran
      bloque de texto. Por ejemplo, si quiere añadir numeración de
      líneas es mucho más fácil si tiene un objeto
      <classname>string</classname> distinto para cada línea. Para
      realizarlo, necesitamos otro concepto.
    </para>

  </sect1>

  <sect1>
    <!-- Introducing vector -->
    <title>Introducción a los vectores</title>

    <!--
    With strings, we can fill up a string object without knowing how much
    storage we??re going to need. The problem with reading lines from a file
    into individual string objects is that you don??t know up front how many
    strings you??re going to need ? you only know after you??ve read the
    entire file. To solve this problem, we need some sort of holder that
    will automatically expand to contain as many string objects as we care
    to put into it.
    -->
    <para>
      Con cadenas, podemos rellenar un objeto
      <classname>string</classname> sin saber cuanta memoria se va a
      necesitar. El problema de introducir líneas de un fichero en
      objetos <classname>string</classname> es que se sabe cuántas
      cadenas habrá - solamente lo sabemos cuando ya hemos leido el
      fichero entero. Para resolver este problema necesitamos un nuevo
      tipo de datos que pueda crecer automáticamente para contener las
      cadenas que le vayamos introduciendo.
    </para>

    <!--
    In fact, why limit ourselves to holding string objects? It turns out
    that this kind of problem ? not knowing how many of something you have
    while you??re writing a program ? happens a lot. And this ??container??
    object sounds like it would be more useful if it would hold any kind of
    object at all! Fortunately, the Standard C++ Library has a ready-made
    solution: the standard container classes. The container classes are one
    of the real powerhouses of Standard C++.
    -->
    <para>
      De hecho, ¿por qué limitarnos a manejar objetos
      <classname>string</classname>? Parece que este tipo de problema -
      no saber la cantidad de cosas a manejar mientras está escribiendo
      el problema - ocurre a menudo. Y este objeto
      <quote>contenedor</quote> podría resultar más útil si pudiera
      manejar <emphasis>cualquier clase de
      objeto</emphasis>. Afortunadamente, la Librería Estándar de C++
      tiene una solución: las clases contenedor
      (<foreignphrase>container</foreignphrase>). Las clases contenedor
      son uno de los puntos fuertes del Estándar C++.
    </para>

    <!--
    There is often a bit of confusion between the containers and algorithms
    in the Standard C++ Library, and the entity known as the STL. The
    Standard Template Library was the name Alex Stepanov (who was working at
    Hewlett-Packard at the time) used when he presented his library to the
    C++ Standards Committee at the meeting in San Diego, California in
    Spring 1994. The name stuck, especially after HP decided to make it
    available for public downloads. Meanwhile, the committee integrated it
    into the Standard C++ Library, making a large number of changes. STL's
    development continues at Silicon Graphics (SGI; see
    http://www.sgi.com/Technology/STL). The SGI STL diverges from the
    Standard C++ Library on many subtle points. So although it's a popular
    misconception, the C++ Standard does not ??include?? the STL. It can be
    a bit confusing since the containers and algorithms in the Standard C++
    Library have the same root (and usually the same names) as the SGI
    STL. In this book, I will say ??The Standard C++ Library?? or ??The
    Standard Library containers,?? or something similar and will avoid the
    term ??STL.??
    -->
    <para>
      A menudo existe un poco de confusión entre los contenedores y
      los algoritmos en la librería Estándar de C++, y la STL. La
      <foreignphrase>Standard Template Library</foreignphrase> fue el
      nombre que usó <personname><firstname> Alex</firstname>
      <surname>Stepanov</surname></personname> (que en aquella época
      estaba trabajando en Hewlett-Packard) cuando presentó su
      librería al Comité del Estándar C++ en el encuentro en San
      Diego, California, en la primavera de 1994. El nombre
      sobrevivió, especialmente después de que HP decidiera dejarlo
      disponible para la descarga pública. Posteriormente el comité
      integró las STL en la Librería Estándar de C++ haciendo un gran
      número de cambios. El desarrollo de las STL continúa en Silicon
      Graphics (SGI; ver <ulink
      url="http://www.sgi.com/Technology/STL">www.sgi.com/Technology/STL)</ulink>. Las
      SGI STL divergen de la Librería Estándar de C++ en muchos
      detalles sutiles. Aunque es una creencia ampliamente
      generalizada, el C++ Estándar no "incluye" las STL. Puede ser
      confuso debido a que los contenedores y los algoritmos en el C++
      Estándar tienen la misma raíz (y a menudo el mismo nombre) que
      en el SGI STL. En este libro, intentaré decir <quote>la librería
      Estándar de C++</quote> o <quote>Librería Estándar de
      contenedores</quote>, o algo similar y eludiré usar el término
      STL.
    </para>

    <!--
    Even though the implementation of the Standard C++ Library containers
    and algorithms uses some advanced concepts and the full coverage takes
    two large chapters in Volume 2 of this book, this library can also be
    potent without knowing a lot about it. It??s so useful that the most
    basic of the standard containers, the vector, is introduced in this
    early chapter and used throughout the book. You??ll find that you can do
    a tremendous amount just by using the basics of vector and not worrying
    about the underlying implementation (again, an important goal of
    OOP). Since you??ll learn much more about this and the other containers
    when you reach the Standard Library chapters in Volume 2, it seems
    forgivable if the programs that use vector in the early portion of the
    book aren??t exactly what an experienced C++ programmer would do. You??
    ll find that in most cases, the usage shown here is adequate.
    -->
    <para>
      A pesar de que la implementación de los contenedores y algoritmos
      de la Librería Estándar de C++ usa algunos conceptos avanzados,
      que se cubren ampliamente en dos largos capítulos en el segundo
      volumen de este libro, esta librería también puede ser potente sin
      saber mucho sobre ella. Es tan útil que el más básico de los
      contenedores estándar, el <classname>vector</classname>, se
      introduce en este capítulo y se usará a lo largo de todo el
      libro. Verá que puede hacer muchas cosas con el
      <classname>vector</classname> y no saber cómo está implementado
      (de nuevo, uno de los objetivos de la POO). Los programas que usan
      <classname>vector</classname> en estos primeros capítulos del
      libro no son exactamente como los haría un programador
      experimentado, como comprobará en el volumen 2. Aún así,
      encontrará que en la mayoría de los casos el uso que se hace es
      adecuado.
    </para>

    <!--
    The vector class is a template, which means that it can be efficiently
    applied to different types. That is, we can create a vector of shapes, a
    vector of cats, a vector of strings, etc. Basically, with a template you
    can create a ??class of anything.?? To tell the compiler what it is that
    the class will work with (in this case, what the vector will hold), you
    put the name of the desired type in ??angle brackets,?? which means ??<??
    and ??>??. So a vector of string would be denoted vector<string>. When
    you do this, you end up with a customized vector that will hold only
    string objects, and you??ll get an error message from the compiler if
    you try to put anything else into it.
    -->
    <para>
      La clase <classname>vector</classname> es una
      <emphasis>plantilla</emphasis>, lo que significa que se puede
      aplicar a tipos de datos diferentes. Es decir, se puede crear un
      <classname>vector</classname> de <classname>figuras</classname>,
      un <classname>vector</classname> de <classname>gatos</classname>,
      un <classname>vector</classname> de
      <classname>strings</classname>, etc. Básicamente, con una
      plantilla se puede crear un vector de <quote>cualquier
      clase</quote>. Para decirle al compilador con qué clase trabajará
      (en este caso que va a manejar el vector), hay que poner el nombre
      del tipo deseado entre <quote>llaves angulares</quote>. Por lo que
      un <classname>vector</classname> de <classname>string</classname>
      se denota como <code>vector&lt;string&gt;</code>. Con eso, se crea
      un vector a medida que solamente contendrá objetos
      <classname>string</classname>, y recibirá un mensaje de error del
      compilador si intenta poner otra cosa en él.
    </para>

    <!-- Since vector expresses the concept of a ??container,?? there
    must be a way to put things into the container and get things back
    out of the container. To add a brand-new element on the end of a
    vector, you use the member function push_back( ). (Remember that,
    since it??s a member function, you use a FIXME:LETRA'.' to call it
    for a particular object.) The reason the name of this member
    function might seem a bit verbose ?  push_back( ) instead of
    something simpler like ??put?? ? is because there are other
    containers and other member functions for putting new elements into
    containers. For example, there is an insert( ) member function to
    put something in the middle of a container. vector supports this but
    its use is more complicated and we won??t need to explore it until
    Volume 2 of the book. There??s also a push_front( ) (not part of
    vector) to put things at the beginning. There are many more member
    functions in vector and many more containers in the Standard C++
    Library, but you??ll be surprised at how much you can do just
    knowing about a few simple features.  -->
    <para>
      Como el <classname>vector</classname> expresa el concepto de
      <quote>contenedor</quote>, debe existir una manera de meter cosas
      en él y sacar cosas de él. Para añadir un nuevo elemento al final
      del vector, se una el método
      <function>push_back()</function>. Recuerde que, como es un método,
      hay que usar un '.' para invocarlo desde un objeto particular. La
      razón de que el nombre de la función parezca un poco verboso -
      <function>push_back()</function> en vez de algo más simple como
      <function>put</function> - es porque existen otros contenedores y
      otros métodos para poner nuevos elementos en los contenedores. Por
      ejemplo, hay un <function>insert()</function> para poner algo en
      medio de un contenedor. <classname>vector</classname> la soporta
      pero su uso es más complicado y no necesitamos explorarla hasta el
      segundo volumen del libro. También hay un
      <function>push_front()</function> (que no es parte de
      <classname>vector</classname>) para poner cosas al principio. Hay
      muchas más funciones miembro en <classname>vector</classname> y
      muchos más contenedores en la Librería Estándar, pero le
      sorprenderá ver la de cosas que se pueden hacer con sólo un par de
      características básicas.
    </para>

    <!--
    So you can put new elements into a vector with push_back( ), but how do
    you get these elements back out again? This solution is more clever and
    elegant ? operator overloading is used to make the vector look like an
    array. The array (which will be described more fully in the next
    chapter) is a data type that is available in virtually every programming
    language so you should already be somewhat familiar with it. Arrays are
    aggregates, which mean they consist of a number of elements clumped
    together. The distinguishing characteristic of an array is that these
    elements are the same size and are arranged to be one right after the
    other. Most importantly, these elements can be selected by ??indexing,??
    which means you can say ??I want element number n?? and that element
    will be produced, usually quickly. Although there are exceptions in
    programming languages, the indexing is normally achieved using square
    brackets, so if you have an array a and you want to produce element
    five, you say a[4] (note that indexing always starts at zero).
    -->
    <para>
      Así que se pueden introducir elementos en un
      <classname>vector</classname> con <function>push_back()</function>
      pero ¿cómo puede sacar esos elementos? La solución es inteligente
      y elegante: se usa la sobrecarga de operadores para que el
      <classname>vector</classname> se parezca a un
      <type>array</type>. El array (que será descrito de forma más
      completa en el siguiente capítulo) es un tipo de datos que está
      disponible prácticamente en cualquier lenguaje de programación por
      lo que debería estar familiarizado con él. Los arrays son
      <emphasis>agregados</emphasis> lo que significa que consisten en
      un número de elementos agrupados. La característica distintiva de
      un array es que estos elementos tienen el mismo tamaño y están
      organizados uno junto a otro. Y todavía más importante, que se
      pueden seleccionar mediante un índice, lo que significa que puede
      decir: <quote>Quiero el elemento número n</quote> y el elemento
      será producido, normalmente de forma rápida. A pesar de que
      existen excepciones en los lenguajes de programación, normalmente
      se indica la <quote>indexación</quote> mediante corchetes, de tal
      forma que si se tiene un array <varname>a</varname> y quiere
      obtener el quinto elemento, sólo tiene que escribir
      <varname>a[4]</varname> (fíjese en que la indexación siempre
      empieza en cero).
    </para>

    <!--
    This very compact and powerful indexing notation is incorporated into
    the vector using operator overloading, just like ??<<?? and ??>>?? were
    incorporated into iostreams. Again, you don??t need to know how the
    overloading was implemented ? that??s saved for a later chapter ? but it??
    s helpful if you??re aware that there??s some magic going on under the
    covers in order to make the [ ] work with vector.
    -->
    <para>
      Esta forma compacta y poderosa de notación indexada se ha
      incorporado al <classname>vector</classname> mediante la
      sobrecarga de operadores como el <oper>&lt;&lt;</oper> y el
      <oper>&gt;&gt;</oper> de los <classname>iostreams</classname>. De
      nuevo, no hay que saber cómo se ha implementado la
      sobrecarga de operadores - lo dejamos para un capítulo posterior -
      pero es útil que sea consciente que hay algo de magia detrás de
      todo esto para conseguir que los corchetes funcionen con el
      <classname>vector</classname>.
    </para>

    <!--
    With that in mind, you can now see a program that uses vector. To use a
    vector, you include the header file <vector>:
    -->
    <para>
      Con todo esto en mente, ya puede ver un programa que usa la clase
      <classname>vector</classname>. Para usar un vector, hay que
      incluir el fichero de cabecera
      <filename>&lt;vector&gt;:</filename>
    </para>


//: V1C02:Fillvector.cpp


    <!--
    Much of this program is similar to the previous one; a file is opened
    and lines are read into string objects one at a time. However, these
    string objects are pushed onto the back of the vector v. Once the while
    loop completes, the entire file is resident in memory, inside v.
    -->
    <para>
      Casi todo este programa es similar al anterior; se abre un fichero
      abierto y se leen las líneas en objetos
      <classname>string</classname> (uno cada vez). Sin embargo, estos
      objetos <classname>string</classname> se introducen al final
      del <classname>vector</classname> <varname>v</varname>. Una vez
      que el bucle <kw>while</kw> ha terminado, el fichero entero se
      encuentra en memoria dentro de <varname>v</varname>.
    </para>


    <!--
    The next statement in the program is called a for loop. It is similar to
    a while loop except that it adds some extra control. After the for,
    there is a ??control expression?? inside of parentheses, just like the
    while loop. However, this control expression is in three parts: a part
    which initializes, one that tests to see if we should exit the loop, and
    one that changes something, typically to step through a sequence of
    items. This program shows the for loop in the way you??ll see it most
    commonly used: the initialization part int i = 0 creates an integer i to
    use as a loop counter and gives it an initial value of zero. The testing
    portion says that to stay in the loop, i should be less than the number
    of elements in the vector v. (This is produced using the member function
    size( ), which I just sort of slipped in here, but you must admit it has
    a fairly obvious meaning.) The final portion uses a shorthand for C and
    C++, the ??auto-increment?? operator, to add one to the value of
    i. Effectively, i++ says ??get the value of i, add one to it, and put
    the result back into i. Thus, the total effect of the for loop is to
    take a variable i and march it through the values from zero to one less
    than the size of the vector. For each value of i, the cout statement is
    executed and this builds a line that consists of the value of i
    (magically converted to a character array by cout), a colon and a space,
    the line from the file, and a newline provided by endl. When you compile
    and run it you??ll see the effect is to add line numbers to the file.
    -->
    <para>
      La siguiente sentencia en el programa es un bucle <kw>for</kw>. Es
      parecido a un bucle <kw>while</kw> aunque añade un control
      extra. Como en el bucle <kw>while</kw>, en el <kw>for</kw> hay una
      <quote>expresión de control</quote> dentro del paréntesis. Sin
      embargo, esta expresión está dividida en tres partes: una parte
      que inicializa, una que comprueba si hay que salir del bucle, y
      otra que cambia algo, normalmente da un paso en una secuencia de
      elementos. Este programa muestra el bucle <kw>for</kw> de la
      manera más habitual: la parte de inicialización <code>int i =
      0</code> crea un entero <varname>i</varname> para usarlo como
      contador y le da el valor inicial de cero. La comprobación
      consiste en ver si <varname>i</varname> es menor que el número de
      elementos del <classname>vector</classname>
      <varname>v</varname>. (Esto se consigue usando la función miembro
      <function>size()</function> -tamaño- que hay que admitir que tiene
      un significado obvio) El último trozo, usa el operador de
      <quote>autoincremento</quote> para aumentar en uno el valor de
      <varname>i</varname>. Efectivamente, <code>i++</code> dice
      <quote>coge el valor de <varname>i</varname> añádele uno y guarad
      el resultado en <varname>i</varname></quote>. Conclusión: el
      efecto del bucle <kw>for</kw> es aumentar la variable
      <varname>i</varname> desde cero hasta el tamaño del
      <literal>vector</literal> menos uno. Por cada nuevo valor de
      <varname>i</varname> se ejecuta la sentencia del
      <varname>cout</varname>, que construye un linea con el valor de
      <varname>i</varname> (mágicamente convertida a un array de
      caracteres por <varname>cout</varname>), dos puntos, un espacio,
      la línea del fichero y el carácter de nueva línea que nos
      proporciona <function>endl</function>. Cuando lo compile y lo
      ejecute verá el efecto de numeración de líneas del fichero.
    </para>

    <!-- Because of the way that the FIXME:LETRA:??>>?? operator works
    with iostreams, you can easily modify the program above so that it
    breaks up the input into whitespace-separated words instead of
    lines: -->
    <para>
      Debido a que el operador <oper>&gt;&gt;</oper> funciona con
      <classname>iostreams</classname>, se puede modificar fácilmente el
      programa anterior para que convierta la entrada en palabras
      separadas por espacios, en vez de líneas:
    </para>


//: V1C02:GetWords.cpp


    <!-- The expression -->
    <para>
      La expresión:
    </para>


<programlisting>
while (in >> word)
</programlisting>


    <!--
    is what gets the input one ??word?? at a time, and when this expression
    evaluates to ??false?? it means the end of the file has been reached. Of
    course, delimiting words by whitespace is quite crude, but it makes for
    a simple example. Later in the book you??ll see more sophisticated
    examples that let you break up input just about any way you??d like.
    -->
    <para>
      es la que consigue que se lea una <quote>palabra</quote> cada vez,
      y cuando la expresión se evalúa como <quote>falsa</quote>
      significa que ha llegado al final del fichero. De acuerdo,
      delimitar una palabra mediante caracteres en blanco es un poco
      tosco, pero sirve como ejemplo sencillo. Más tarde, en este libro,
      verá ejemplos más sofisticados que le permiten dividir la entrada
      de la forma que quiera.
    </para>

    <!--
    To demonstrate how easy it is to use a vector with any type, here??s an
    example that creates a vector<int>:
    -->
    <para>
      Para demostrar lo fácil que es usar un
      <classname>vector</classname> con cualquier tipo, aquí tiene
      un ejemplo que crea un vector de enteros:
    </para>


//: V1C02:Intvector.cpp


    <!--
    To create a vector that holds a different type, you just put that type
    in as the template argument (the argument in angle brackets). Templates
    and well-designed template libraries are intended to be exactly this
    easy to use.
    -->
    <para>
      Para crear un <classname>vector</classname> que maneje un tipo
      diferente basta con poner el tipo entre las llaves angulares (el
      argumento de las plantillas). Las plantillas y las librerías de
      plantillas pretenden ofrecer precisamente esta facilidad de uso.
    </para>

    <!--
    This example goes on to demonstrate another essential feature of
    vector. In the expression
    -->
    <para>
      Además este ejemplo demuestra otra característica esencial
      del <classname>vector</classname> en la expresión
    </para>


<programlisting>
v[i] = v[i] * 10;
</programlisting>


    <!--
    you can see that the vector is not limited to only putting things in and
    getting things out. You also have the ability to assign (and thus to
    change) to any element of a vector, also through the use of the
    square-brackets indexing operator. This means that vector is a
    general-purpose, flexible ??scratchpad?? for working with collections of
    objects, and we will definitely make use of it in coming chapters.
    -->
    <para>
      Puede observar que el <classname>vector</classname> no está
      limitado a meter cosas y sacarlas. También puede
      <emphasis>asignar</emphasis> (es decir, cambiar) cualquier
      elemento del vector mediante el uso de los corchetes. Eso
      significa que el <classname>vector</classname> es un objeto útil,
      flexible y de propósito general para trabajar con colecciones de
      objetos, y haremos uso de él en los siguientes capítulos.
    </para>
  </sect1>


  <sect1>
    <!-- Summary -->
    <title>Resumen</title>

    <!--
    The intent of this chapter is to show you how easy object-oriented
    programming can be ? if someone else has gone to the work of defining
    the objects for you. In that case, you include a header file, create the
    objects, and send messages to them. If the types you are using are
    powerful and well-designed, then you won??t have to do much work and
    your resulting program will also be powerful.
    -->
    <para>
      Este capítulo pretende mostrarle lo fácil que puede llegar a ser
      la programación orientada a objetos - si alguien ha hecho el
      trabajo de definir los objetos por usted. En este caso, sólo hay
      que incluir el fichero de cabecera, crear los objetos y enviarles
      mensajes. Si los tipos que está usando están bien diseñados y son
      potentes, entonces no tendrá mucho trabajo y su programa
      resultante también será potente.
    </para>

    <!--
    In the process of showing the ease of OOP when using library classes,
    this chapter also introduced some of the most basic and useful types in
    the Standard C++ library: the family of iostreams (in particular, those
    that read from and write to the console and files), the string class,
    and the vector template. You??ve seen how straightforward it is to use
    these and can now probably imagine many things you can accomplish with
    them, but there??s actually a lot more that they??re capable
    of[29]. Even though we??ll only be using a limited subset of the
    functionality of these tools in the early part of the book, they
    nonetheless provide a large step up from the primitiveness of learning a
    low-level language like C. and while learning the low-level aspects of C
    is educational, it??s also time consuming. In the end, you??ll be much
    more productive if you??ve got objects to manage the low-level
    issues. After all, the whole point of OOP is to hide the details so you
    can ??paint with a bigger brush.??
    -->
    <para>
      En este proceso para mostrar la sencillez de la POO cuando se usan
      librerías de clases, este capítulo, también introduce algunos de
      los tipos de datos más básicos y útiles de la Librería Estándar de
      C++: La familia de los <classname>iostreams</classname> (en
      particular aquellos que leen y escriben en consola y ficheros), la
      clase <classname>string</classname>, y la plantilla
      <classname>vector</classname>. Ha visto lo sencillo que es usarlos
      y ahora es probable que se imagine la de cosas que se pueden hacer
      con ellos, pero hay muchas más cosas que son capaces de
      realizar
      <footnote>
	<para>
	  Si está especialmente interesado en ver todas las cosas
	  que se pueden hacer con los componentes de la Librería
	  Estándar, vea el Volumen 2 de este libro en <ulink
	  url="http://www.bruceeckel.com">www.BruceEckel.com</ulink> y
	  también en <ulink
	  url="http://www.dinkumware.com">www.dinkumware.com</ulink>
	</para>
      </footnote>.

      A pesar de estar usando un pequeño subconjunto de la funcionalidad
      de estas herramientas en este principio del libro, supone un gran
      avance frente a los rudimentarios comienzos en el aprendizaje de
      un lenguaje de bajo nivel como C. Y aunque aprender los aspectos
      de bajo nivel de C es educativo también lleva tiempo. Al final
      usted es mucho más productivo si tiene objetos que manejen las
      características de bajo nivel. Después de todo, el principal
      objetivo de la POO es esconder los detalles para que usted pueda
      <quote>pintar con una brocha más gorda</quote>.
    </para>

    <!--
    However, as high-level as OOP tries to be, there are some fundamental
    aspects of C that you can??t avoid knowing, and these will be covered in
    the next chapter.
    -->
    <para>
      Sin embargo, debido al alto nivel que la POO intenta tener, hay
      algunos aspectos fundamentales de C que no se pueden obviar, y de
      eso trata el siguiente capítulo.
    </para>
  </sect1>

  <sect1>
    <!-- Exercises -->
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>
	<!-- 1. Modify Hello.cpp so that it prints out your name and age
	(or shoe size, or your dog??s age, if that makes you feel
	better). Compile and run the program.  -->
	<para>
	  Modifique <filename>Hello.cpp</filename> para que imprima
	  su nombre y edad (o tamaño de pie, o la edad de su perro,
	  si le gusta más). Compile y ejecute el programa.
	</para>
      </listitem>
      <listitem>
	<!-- 2. Using Stream2.cpp and Numconv.cpp as guidelines, create
	a program that asks for the radius of a circle and prints the
	area of that circle. You can just use the FIXME:LETRA:'*'
	operator to square the radius. Do not try to print out the value
	as octal or hex (these only work with integral types).  -->
	<para>
	  Utilizando <filename>Stream2.cpp</filename> y
	  <filename>Numconv.cpp</filename> como guías, cree un programa
	  que le pida el radio de un círculo y le muestre el área del
	  mismo. Puede usar el operador <oper>*</oper> para elevar el
	  radio al cuadrado. No intente imprimir el valor en octal o en
	  hexadecimal (sólo funciona con tipos enteros).
	</para>
      </listitem>
      <listitem>
	<!-- 3. Create a program that opens a file and counts the
	whitespace-separated words in that file.  -->
	<para>
	  Cree un programa que abra un fichero y cuente las palabras
	  (separadas por espacios en blanco) que contiene.
	</para>
      </listitem>
      <listitem>
	<!-- 4. Create a program that counts the occurrence of a
	particular word in a file (use the string class?? operator
	FIXME'==' to find the word).  -->
	<para>
	  Cree un programa que cuente el número de ocurrencias de una
	  palabra en concreto en un fichero (use el operador
	  <oper>==</oper> de la clase <classname>string</classname> para
	  encontrar la palabra)
	</para>
      </listitem>
      <listitem>
	<!-- 5. Change Fillvector.cpp so that it prints the lines
	(backwards) from last to first.  -->
	<para>
	  Cambie <filename>Fillvector.cpp</filename> para que imprima
	  las líneas al revés (de la última a la primera).
	</para>
      </listitem>
      <listitem>
	<!-- 6. Change Fillvector.cpp so that it concatenates all the
	elements in the vector into a single string before printing it
	out, but don??t try to add line numbering.  -->
	<para>
	  Cambie <filename>Fillvector.cpp</filename> para que concatene
	  todos los elementos de la clase <classname>vector</classname>
	  en un único <classname>string</classname> antes de imprimirlo,
	  pero no añada numeración de líneas
	</para>
      </listitem>
      <listitem>
	<!-- 7. Display a file a line at a time, waiting for the user to
	press the ??Enter?? key after each line.  -->
	<para>
	  Muestre un fichero línea a línea, esperando que el usuario
	  pulse <keycap>Enter</keycap> después de cada línea.
	</para>
      </listitem>
      <listitem>
	<!-- 8. Create a vector<float> and put 25 floating-point numbers
	into it using a for loop. Display the vector.  -->
	<para>
	  Cree un <classname>vector&lt;float&gt;</classname> e
	  introduzca en él 25 números en punto flotante usando un bucle
	  <kw>for</kw>. Muestre el vector.
	</para>
      </listitem>
      <listitem>
	<!-- 9. Create three vector<float> objects and fill the first
	two as in the previous exercise. Write a for loop that adds each
	corresponding element in the first two vectors and puts the
	result in the corresponding element of the third vector. Display
	all three vectors.  -->
	<para>
	  Cree tres objetos <classname>vector&lt;float&gt;</classname> y
	  rellene los dos primeros como en el ejercicio
	  anterior. Escriba un bucle <kw>for</kw> que sume los elementos
	  correspondientes y los añada al tercer vector. Muestre los
	  tres vectores.
	</para>
      </listitem>
      <listitem>
	<!-- 10. Create a vector<float> and put 25 numbers into it as in
	the previous exercises. Now square each number and put the
	result back into the same location in the vector. Display the
	vector before and after the multiplication.  -->
	<para>
	  Cree un <classname>vector&lt;float&gt;</classname> e
	  introduzca 25 números en él como en el ejercicio
	  anterior. Eleve cada número al cuadrado y ponga su
	  resultado en la misma posición del vector. Muestre el
	  vector antes y después de la multiplicación.
	</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>
