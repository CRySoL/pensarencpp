<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>16.2. Un vistazo a las plantillas</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C16.html" title="16: Introducción a las Plantillas" />
    <link rel="prev" href="C16.html" title="16: Introducción a las Plantillas" />
    <link rel="next" href="ch16s03.html" title="16.3. Sintaxis del Template" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="C16.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="C16.html">16: Introducción a las Plantillas</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C16.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch16s03.html">16.3. Sintaxis del Template</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch16s03.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="16.2. Un vistazo a las plantillas">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp8453784"></a>16.2. Un vistazo a las plantillas</h2>
          </div>
        </div>
      </div>
      <p>
      Ahora surge un nuevo problema. Tenemos un
      <code class="classname">IntStack</code>, que maneja enteros. Pero
      queremos una pila que maneje formas, o flotas de aviones, o
      plantas o cualquier otra cosa.  Reinventar el código fuente cada
      vez no parece una aproximación muy inteligente con un lenguaje
      que propugna la reutilización. Debe haber un camino mejor.
    </p>
      <p>
      Hay tres técnicas para reutilizar código en esta situación: el modo
      de C, presentado aquí como contraste; la aproximación de
      Smalltalk, que afectó de forma significativa a C++, y la
      aproximación de C++: los templates.
    </p>
      <p>
      <span class="emphasis"><em>La solución de C</em></span>. Por supuesto hay que
      escapar de la aproximación de C porque es desordenada y provoca
      errores, al mismo tiempo que no es nada elegante. En esta
      aproximación, se copia el código de una <code class="classname">Stack
      </code> y se hacen modificaciones a mano, introduciendo
      nuevos errores en el proceso. Esta no es una técnica muy
      productiva.
    </p>
      <p>
      <span class="emphasis"><em>La solución de Smalltalk</em></span>. Smalltalk (y Java
      siguiendo su ejemplo) optó por una solución simple y directa: Se
      quiere reutilizar código, pues utilicese la herencia. Para
      implementarlo, cada clase contenedora maneja elementos de una
      clase base genérica llamada <code class="classname">Object </code> (similar
      al ejemplo del final del capítulo 15). Pero debido a que la
      librería de Smalltalk es fundamental, no se puede crear una
      clase desde la nada. En su lugar, siempre hay que heredar de una
      clase existente. Se encuentra una clase lo más cercana posible a
      lo que se desea, se hereda de ella, y se hacen un par de
      cambios. Obviamente, esto es un beneficio porque minimiza el
      trabajo (y explica porque se pierde un montón de tiempo
      aprendiendo la librería antes de ser un programador efectivo en
      Smalltalk).
    </p>
      <p>
      Pero también significa que todas las clases de Smalltalk acaban
      siendo parte de un único árbol de herencia. Hay que heredar de
      una rama de este árbol cuando se está creando una nueva
      clase. La mayoría del árbol ya esta allí (es la librería de
      clases de Smalltalk), y la raiz del árbol es una clase llamada
      <code class="classname">Object</code> - la misma clase que los contenedores
      de Smalltalk manejan.
    </p>
      <p>
      Es un truco ingenioso porque significa que cada clase en la
      jerarquía de herencia de Smalltalk (y Java<sup>[<a id="idp8460640" href="#ftn.idp8460640" class="footnote">80</a>]</sup>) se deriva de <code class="classname">Object</code>, por lo
      que cualquier clase puede ser almacenada en cualquier contenedor
      (incluyendo a los propios contenedores). Este tipo de jerarquía
      de árbol única basada en un tipo genérico fundamental (a menudo
      llamado <code class="classname">Object</code>, como también es el caso
      en Java) es conocido como "jerarquía basada en objectos". Se
      puede haber oido este témino y asumido que es un nuevo concepto
      fundamental de la POO, como el polimorfismo. Sin embargo,
      simplemente se refiere a la raíz de la jerarquía como
      <code class="classname">Object </code> (o algún témino similar) y a
      contenedores que almacenan <code class="classname">Object</code>s.
    </p>
      <p>
      Debido a que la librería de clases de Smalltalk tenía mucha más
      experiencia e historia detrás de la que tenía C++, y porque los
      compiladores de C++ originales no tenían librerías de clases
      contenedoras, parecía una buena idea duplicar la librería de
      Smalltalk en C++. Esto se hizo como experimento con una de las
      primeras implementaciónes de C++<sup>[<a id="idp8464400" href="#ftn.idp8464400" class="footnote">81</a>]</sup>, y como representaba un significativo ahorro de
      código mucha gente empezo a usarlo. En el proceso de intentar
      usar las clases contenedoras, descubrieron un problema.
    </p>
      <p>
      El problema es que en Smalltalk (y en la mayoría de los
      lenguajes de POO que yo conozco), todas las clases derivan
      automáticamente de la jerarquía única, pero esto no es cierto en
      C++. Se puede tener una magnifica jerarquía basada en objetos
      con sus clases contenedoras, pero entonces se compra un conjunto
      de clases de figuras, o de aviones de otro vendedor que no usa
      esa jerarquía. (Esto se debe a que usar una jerarquía supone
      sobrecarga, rechazada por los programadores de C). ¿Cómo se
      inserta un árbol de clases independientes en nuestra jerarquía?
      El problema se parece a lo siguiente:
    </p>
      <div class="figure">
        <a id="idp8466272"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_21.png" align="middle" alt="Contenedores" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 16.1. Contenedores</strong>
        </p>
      </div>
      <br class="figure-break" />
      <p>
      Debido a que C++ suporta múltiples jerarquías independientes, la
      jerarquía basada en objetos de Smalltalk no funciona tan bien.
    </p>
      <p>
      La solución parace obvia. Si se pueden tener múltiples
      jerarquías de herencia, entonces hay que ser capaces de heredar
      de más de una clase: La herencia múltiple resuelve el
      problema. Por lo que se puede hacer lo siguiente (un ejemplo
      similar se dió al final del Capítulo 15).
    </p>
      <div class="figure">
        <a id="idp8470032"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_22.png" align="middle" alt="Herencia múltiple" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 16.2. Herencia múltiple</strong>
        </p>
      </div>
      <br class="figure-break" />
      <p>
      Ahora <code class="classname">OShape</code> tiene las características y
      el comportamiento de <code class="classname">Shape</code>, pero como
      también está derivado de <code class="classname">Object</code> puede ser
      insertado en el contenedor. La herencia extra dada a
      <code class="classname">OCircle</code>, <code class="classname">OSquare</code>,
      etc. es necesaria para que esas clases puedan hacer upcast hacia
      <code class="classname">OShape </code> y puedan mantener el
      comportamiento correcto. Se puede ver como las cosas se están
      volviendo confusas rápidamente.
    </p>
      <p>
      Los vendedores de compiladores inventaron e incluyeron sus
      propias jerarquías y clases contenedoras, muchas de las cuales
      han sido reemplazadas desde entonces por versiones de templates.
      Se puede argumentar que la herencia múltiple es necesaria para
      resolver problemas de programación general, pero como se verá en
      el Volumen 2 de este libro es mejor evitar esta complejidad
      excepto en casos especiales.
    </p>
      <div class="sect2" title="16.2.1. La solución de la plantilla">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="idp8475600"></a>16.2.1. La solución de la plantilla</h3>
            </div>
          </div>
        </div>
        <p>
	Aunque una jerarquía basada en objetos con herencia múltiple
	es conceptualmente correcta, se vuelve difícil de usar. En su
	libro<sup>[<a id="idp8476392" href="#ftn.idp8476392" class="footnote">82</a>]</sup>, Stroustrup demostró
	lo que el consideraba una alternativa preferible a la
	jerarquía basada en objetos.  Clases contenedoras que fueran
	creadas como grandes macros del preprocesador con argumentos
	que pudieran ser sustituidos con el tipo deseado. Cuando se
	quiera crear un contenedor que maneje un tipo en concreto, se
	hacen un par de llamadas a macros.
      </p>
        <p>
	Desafortunadamente, esta aproximación era confusa para toda la
	literatura existente de Smalltalk y para la experiencia de
	programación, y era un poco inmanejable.  Básicamente, nadie
	la entendía.
      </p>
        <p>
	Mientras tanto, Stroustrup y el equipo de C++ de los
	Laboratorios Bell habían modificado su aproximación de las
	macros, simplificándola y moviéndola del dominio del
	preprocesador al compilador. Este nuevo dispositivo de
	sustitución de código se conoce como <code class="keyword">template</code>
	<sup>[<a id="idp8479568" href="#ftn.idp8479568" class="footnote">83</a>]</sup>
	(plantilla), y representa un modo completamente diferente de
	reutilizar el código. En vez de reutilizar código objeto, como
	en la herencia y en la composición, un template reutiliza
	<span class="emphasis"><em>código fuente</em></span>. El contenedor no maneja una
	clase base genérica llamada <code class="classname">Object</code>, si no
	que gestiona un parámetro no especificado. Cuando se usa un
	template, el parámetro es sustituido <span class="emphasis"><em>por el
	compilador</em></span>, parecido a la antigua aproximación de las
	macros, pero más claro y fácil de usar.
      </p>
        <p>
	Ahora, en vez de preocuparse por la herencia o la composición
	cuando se quiera usar una clase contenedora, se usa la versión
	en plantilla del contenedor y se crea una versión específica
	para el problema, como lo siguiente:
      </p>
        <div class="figure">
          <a id="idp8482928"></a>
          <div class="figure-contents">
            <div class="mediaobject" align="center">
              <img src="./images/V1_23.png" align="middle" alt="Contenedor de objetos Figura" />
            </div>
          </div>
          <p class="title">
            <strong>Figura 16.3. Contenedor de objetos <code class="classname">Figura</code></strong>
          </p>
        </div>
        <br class="figure-break" />
        <p>
	El compilador hace el trabajo por nosotros, y se obtiene el
	contenedor necesario para hacer el trabajo, en vez de una
	jerarquía de herencia inmanejable. En C++, el template
	implementa el concepto de <span class="emphasis"><em>tipo
	  parametrizado</em></span>. Otro beneficio de la aproximación de
	las plantillas es que el programador novato que no tenga
	familiaridad o esté incómodo con la herencia puede usar las
	clases contenedoras de manera adecuada (como se ha estado
	haciendo a lo largo del libro con el
	<code class="classname">vector</code>).

      </p>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp8460640" href="#idp8460640" class="para">80</a>] </sup>Con
	  la excepción, en Java, de los tipos de datos primitivos, que se
	  hicieron no <code class="classname">Object</code>s por eficiencia. </p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp8464400" href="#idp8464400" class="para">81</a>] </sup>La librería
	  OOPS, por Keith Gorlen, mientras estaba en el NIH.</p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp8476392" href="#idp8476392" class="para">82</a>] </sup><span class="emphasis"><em>The C++ Programming
	      Language</em></span> by Bjarne Stroustrup (1ª edición,
	    Addison-Wesley, 1986)</p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp8479568" href="#idp8479568" class="para">83</a>] </sup>
	    La inspiración de los templates parece venir de los
	    <code class="keyword">generics</code> de ADA</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="C16.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="C16.html">16: Introducción a las Plantillas</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C16.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch16s03.html">16.3. Sintaxis del Template</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch16s03.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
