<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Pensar en C++ (Volumen 1)</title><link rel="stylesheet" type="text/css" href="common.css" /><link rel="stylesheet" type="text/css" href="single.css" /><link rel="stylesheet" type="text/css" href="highlight.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div xml:lang="es" class="book" title="Pensar en C++ (Volumen 1)" lang="es"><div class="titlepage"><div><div><h1 class="title"><a id="pecpp"></a>Pensar en C++ <em class="parameter"><code>(Volumen 1)</code></em></h1></div><div><h2 class="subtitle">
      Traducción (cuasi-terminada) del libro <span class="emphasis"><em>Thinking in C++,
	Volumen 1</em></span>
    </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Bruce</span> <span class="surname">Eckel</span></h3><div class="affiliation"><span class="orgname">Mindview, Inc.<br /></span></div></div></div></div><div><p class="copyright">Copyright © 2000 Bruce Eckel</p></div><div><div class="legalnotice" title="Aviso Legal"><a id="idp1582152"></a><p></p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><strong>Historial de revisiones</strong></th></tr><tr><td align="left">Revisión $Revision$</td><td align="left">2010-04-03</td><td align="left"></td></tr><tr><td align="left">Revisión 13</td><td align="left">2001-09-27</td><td align="left">Bruce Eckel</td></tr></table></div></div></div><hr /></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="preface"><a href="#prologo">Prólogo a la traducción</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp96136">1. Licencia y normas de distribución</a></span></dt><dt><span class="sect1"><a href="#idp57096">2. Tecnicismos</a></span></dt><dt><span class="sect1"><a href="#idp60424">3. Código fuente</a></span></dt><dt><span class="sect1"><a href="#idp61040">4. Producción</a></span></dt><dt><span class="sect1"><a href="#idp34624">5. El equipo</a></span></dt><dt><span class="sect1"><a href="#idp3459888">6. Agradecimientos</a></span></dt><dt><span class="sect1"><a href="#idp3460544">7. Utilidades</a></span></dt></dl></dd><dt><span class="preface"><a href="#prefacio">Prefacio</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3466232">1. Material nuevo en la segunda edición</a></span></dt><dt><span class="sect1"><a href="#idp3474608">2. Requisitos</a></span></dt><dt><span class="sect1"><a href="#idp3476720">3. Aprender C++</a></span></dt><dt><span class="sect1"><a href="#idp3489120">4. Objetivos</a></span></dt><dt><span class="sect1"><a href="#idp3498664">5. Capítulos</a></span></dt><dt><span class="sect1"><a href="#idp3551048">6. Ejercicios</a></span></dt><dt><span class="sect1"><a href="#idp3554912">7. Código fuente</a></span></dt><dt><span class="sect1"><a href="#idp3561272">8. Estándares del lenguaje</a></span></dt><dt><span class="sect1"><a href="#idp3569808">9. El CD-ROM del libro</a></span></dt><dt><span class="sect1"><a href="#idp3574304">10. CD-ROMs, seminarios, y consultoría</a></span></dt><dt><span class="sect1"><a href="#idp3578920">11. Errores</a></span></dt><dt><span class="sect1"><a href="#idp3580416">12. Sobre la portada</a></span></dt><dt><span class="sect1"><a href="#idp3587000">13. Diseño del libro y producción</a></span></dt><dt><span class="sect1"><a href="#idp3595288">14. Agradecimientos</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C01">1. Introducción a los Objetos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3612568">1.1. El progreso de abstracción</a></span></dt><dt><span class="sect1"><a href="#idp3632576">1.2. Cada objeto tiene una interfaz</a></span></dt><dt><span class="sect1"><a href="#idp3657520">1.3. La implementación oculta</a></span></dt><dt><span class="sect1"><a href="#idp3669728">1.4. Reutilizar la implementación</a></span></dt><dt><span class="sect1"><a href="#idp3679560">1.5. Herencia: reutilización de interfaces</a></span></dt><dt><span class="sect1"><a href="#idp3718416">1.6. Objetos intercambiables gracias al polimorfismo</a></span></dt><dt><span class="sect1"><a href="#idp3761184">1.7. Creación y destrucción de objetos</a></span></dt><dt><span class="sect1"><a href="#idp3773112">1.8. Gestión de excepciones: tratamiento de errores</a></span></dt><dt><span class="sect1"><a href="#idp3780784">1.9. Análisis y diseño</a></span></dt><dt><span class="sect1"><a href="#idp3897048">1.10. Programación Extrema</a></span></dt><dt><span class="sect1"><a href="#idp3919120">1.11. Porqué triunfa C++</a></span></dt><dt><span class="sect1"><a href="#idp3946072">1.12. Estrategias de transición</a></span></dt><dt><span class="sect1"><a href="#idp116672">1.13. Resumen</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C02">2. Construir y usar objetos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4005800">2.1. El proceso de traducción del lenguaje</a></span></dt><dt><span class="sect1"><a href="#idp4035744">2.2. Herramientas para compilación modular</a></span></dt><dt><span class="sect1"><a href="#idp4114016">2.3. Su primer programa en C++</a></span></dt><dt><span class="sect1"><a href="#idp4165424">2.4. Más sobre iostreams</a></span></dt><dt><span class="sect1"><a href="#idp4187160">2.5. Introdución a las cadenas</a></span></dt><dt><span class="sect1"><a href="#idp4199360">2.6. Lectura y escritura de ficheros</a></span></dt><dt><span class="sect1"><a href="#idp4221360">2.7. Introducción a los vectores</a></span></dt><dt><span class="sect1"><a href="#idp4270736">2.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp4276664">2.9. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C03">3. C en C++</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4295608">3.1. Creación de funciones</a></span></dt><dt><span class="sect1"><a href="#idp4330040">3.2. Control de flujo</a></span></dt><dt><span class="sect1"><a href="#idp4424576">3.3. Introducción a los operadores</a></span></dt><dt><span class="sect1"><a href="#idp4439720">3.4. Introducción a los tipos de datos</a></span></dt><dt><span class="sect1"><a href="#idp4558336">3.5. Alcance</a></span></dt><dt><span class="sect1"><a href="#idp4585696">3.6.  Especificar la ubicación del espacio de almacenamiento</a></span></dt><dt><span class="sect1"><a href="#idp4668808">3.7. Los operadores y su uso</a></span></dt><dt><span class="sect1"><a href="#idp4844384">3.8. Creación de tipos compuestos</a></span></dt><dt><span class="sect1"><a href="#idp5000080">3.9. Consejos para depuración</a></span></dt><dt><span class="sect1"><a href="#C03-punteros-a-funcion">3.10. Direcciones de función</a></span></dt><dt><span class="sect1"><a href="#idp5067648">3.11. Make: cómo hacer compilación separada</a></span></dt><dt><span class="sect1"><a href="#idp5152080">3.12. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5155104">3.13. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C04">4. Abstracción de Datos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5230184">4.1. Una librería pequeña al estilo C</a></span></dt><dt><span class="sect1"><a href="#idp5325096">4.2. ¿Qué tiene de malo?</a></span></dt><dt><span class="sect1"><a href="#idp5335872">4.3. El objeto básico</a></span></dt><dt><span class="sect1"><a href="#idp5391952">4.4. ¿Qué es un objeto?</a></span></dt><dt><span class="sect1"><a href="#idp5398792">4.5. Tipos abstractos de datos</a></span></dt><dt><span class="sect1"><a href="#idp5411360">4.6. Detalles del objeto</a></span></dt><dt><span class="sect1"><a href="#idp5425000">4.7. Conveciones para los ficheros de cabecera</a></span></dt><dt><span class="sect1"><a href="#idp5488200">4.8. Estructuras anidadas</a></span></dt><dt><span class="sect1"><a href="#idp5530552">4.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5534768">4.10. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C05">5. Ocultar la implementación</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5590656">5.1. Establecer los límites</a></span></dt><dt><span class="sect1"><a href="#idp5596792">5.2. Control de acceso en C++</a></span></dt><dt><span class="sect1"><a href="#idp5614448">5.3. Amigos (friends)</a></span></dt><dt><span class="sect1"><a href="#idp5653936">5.4. Capa de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5661784">5.5. La clase</a></span></dt><dt><span class="sect1"><a href="#idp5692680">5.6. Manejo de clases</a></span></dt><dt><span class="sect1"><a href="#idp5713808">5.7. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5717448">5.8. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C06">6. Inicialización y limpieza</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5757608">6.1. Inicialización garantizada por el constructor</a></span></dt><dt><span class="sect1"><a href="#idp5772608">6.2. Limpieza garantizada por el destructor</a></span></dt><dt><span class="sect1"><a href="#idp5784800">6.3. Eliminación del bloque de definiciones</a></span></dt><dt><span class="sect1"><a href="#idp5816376">6.4. Stash con constructores y destructores</a></span></dt><dt><span class="sect1"><a href="#idp5837096">6.5. Stack con constructores y destructores</a></span></dt><dt><span class="sect1"><a href="#idp5856456">6.6. Inicialización de tipos agregados</a></span></dt><dt><span class="sect1"><a href="#idp5873720">6.7. Constructores por defecto</a></span></dt><dt><span class="sect1"><a href="#idp5885296">6.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5889272">6.9. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C07">7. Sobrecarga de funciones y argumentos por defecto</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5916920">7.1. Más decoración de nombres</a></span></dt><dt><span class="sect1"><a href="#idp5939928">7.2. Ejemplo de sobrecarga</a></span></dt><dt><span class="sect1"><a href="#idp5953928">7.3. Uniones</a></span></dt><dt><span class="sect1"><a href="#idp5973616">7.4. Argumentos por defecto</a></span></dt><dt><span class="sect1"><a href="#idp5989808">7.5. Elección entre sobrecarga y argumentos por defecto</a></span></dt><dt><span class="sect1"><a href="#idp6019224">7.6. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6022232">7.7. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C08">8. Constantes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp6052400">8.1. Sustitución de valores</a></span></dt><dt><span class="sect1"><a href="#idp6107968">8.2. Punteros</a></span></dt><dt><span class="sect1"><a href="#idp6138272">8.3. Argumentos de funciones y valores de retorno</a></span></dt><dt><span class="sect1"><a href="#idp6197520">8.4. Clases</a></span></dt><dt><span class="sect1"><a href="#idp6277896">8.5. Volatile</a></span></dt><dt><span class="sect1"><a href="#idp6293576">8.6. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6298544">8.7. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C09">9. Funciones <code class="keyword">inline</code></a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp6344008">9.1. Los peligros del preprocesador</a></span></dt><dt><span class="sect1"><a href="#idp6369288">9.2. Funciones <code class="keyword">inline</code></a></span></dt><dt><span class="sect1"><a href="#idp6417632">9.3. Stash y Stack con inlines</a></span></dt><dt><span class="sect1"><a href="#idp6437296">9.4. Funciones inline y el compilador</a></span></dt><dt><span class="sect1"><a href="#idp6459432">9.5. Reducir el desorden</a></span></dt><dt><span class="sect1"><a href="#idp6469312">9.6. Más características del preprocesador</a></span></dt><dt><span class="sect1"><a href="#idp6480720">9.7. Comprobación de errores mejorada</a></span></dt><dt><span class="sect1"><a href="#idp6500040">9.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6503368">9.9. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C10">10. Control de nombres</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp6543832">10.1. Los elementos estáticos de C</a></span></dt><dt><span class="sect1"><a href="#idp6619936">10.2. Espacios de nombres</a></span></dt><dt><span class="sect1"><a href="#idp6690960">10.3. Miembros estáticos en C++</a></span></dt><dt><span class="sect1"><a href="#idp6743440">10.4. Dependencia en la inicialización de variables
      estáticas</a></span></dt><dt><span class="sect1"><a href="#idp6811352">10.5. Especificaciones de enlazado alternativo</a></span></dt><dt><span class="sect1"><a href="#idp6821000">10.6. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6824328">10.7. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C11">11. Las referencias y el constructor de copia</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp6907720">11.1. Punteros en C++</a></span></dt><dt><span class="sect1"><a href="#idp6912048">11.2. Referencias en C++</a></span></dt><dt><span class="sect1"><a href="#idp6940384">11.3. El constructor de copia</a></span></dt><dt><span class="sect1"><a href="#idp7065616">11.4. Punteros a miembros</a></span></dt><dt><span class="sect1"><a href="#idp7099888">11.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp7104712">11.6. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C12">12. Sobrecarga de operadores</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7152320">12.1. Precaución y tranquilidad </a></span></dt><dt><span class="sect1"><a href="#idp7156592">12.2. Sintaxis</a></span></dt><dt><span class="sect1"><a href="#idp7167168">12.3. Operadores sobrecargables </a></span></dt><dt><span class="sect1"><a href="#idp7319424">12.4. Operadores no miembros</a></span></dt><dt><span class="sect1"><a href="#idp7339880">12.5. Sobrecargar la asignación</a></span></dt><dt><span class="sect1"><a href="#idp7414776">12.6. Conversión automática de tipos</a></span></dt><dt><span class="sect1"><a href="#idp7475640">12.7. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp7477136">12.8. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C13">13. Creación dinámica de objetos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7553248">13.1. Creación de objetos</a></span></dt><dt><span class="sect1"><a href="#idp7609552">13.2. Rediseño de los ejemplos anteriores</a></span></dt><dt><span class="sect1"><a href="#idp7672640">13.3. 
      <code class="keyword">new</code> y <code class="keyword">delete</code> para vectores
    </a></span></dt><dt><span class="sect1"><a href="#idp7828752">13.4. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp7832696">13.5. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C14">14. Herencia y Composición</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp7871472">14.1. Sintaxis de la composición</a></span></dt><dt><span class="sect1"><a href="#idp7879040">14.2. Sintaxis de la herencia</a></span></dt><dt><span class="sect1"><a href="#idp7888120">14.3. Lista de inicializadores de un constructor</a></span></dt><dt><span class="sect1"><a href="#idp7916760">14.4. Ocultación de nombres</a></span></dt><dt><span class="sect1"><a href="#idp7935528">14.5. Funciones que no heredan automáticamente</a></span></dt><dt><span class="sect1"><a href="#idp7978816">14.6. Protected</a></span></dt><dt><span class="sect1"><a href="#idp7985456">14.7. Herencia y sobrecarga de operadores</a></span></dt><dt><span class="sect1"><a href="#idp7991328">14.8. Herencia múltiple</a></span></dt><dt><span class="sect1"><a href="#idp7993504">14.9. Desarrollo incremental</a></span></dt><dt><span class="sect1"><a href="#idp7998760">14.10. Upcasting</a></span></dt><dt><span class="sect1"><a href="#idp8033168">14.11. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp8036048">14.12. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C15">15. Polimorfismo y Funciones virtuales</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8069376">15.1. Evolución de los programadores de C++</a></span></dt><dt><span class="sect1"><a href="#idp8075232">15.2. Upcasting</a></span></dt><dt><span class="sect1"><a href="#idp8085800">15.3. El problema</a></span></dt><dt><span class="sect1"><a href="#idp8094896">15.4. Funciones virtuales</a></span></dt><dt><span class="sect1"><a href="#idp8125576">15.5. Cómo implementa C++ la ligadura dinámica</a></span></dt><dt><span class="sect1"><a href="#idp8187008">15.6. ¿Por qué funciones virtuales?</a></span></dt><dt><span class="sect1"><a href="#idp8197152">15.7. Clases base abstractas y funciones virtuales puras</a></span></dt><dt><span class="sect1"><a href="#idp8224072">15.8. Herencia y la VTABLE</a></span></dt><dt><span class="sect1"><a href="#idp8267008">15.9. Sobrecargar y redefinir</a></span></dt><dt><span class="sect1"><a href="#idp8289328">15.10. funciones virtuales y constructores</a></span></dt><dt><span class="sect1"><a href="#idp8363912">15.11. Sobrecarga de operadores</a></span></dt><dt><span class="sect1"><a href="#idp8374520">15.12. Downcasting</a></span></dt><dt><span class="sect1"><a href="#idp8402424">15.13. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp8407888">15.14. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C16">16. Introducción a las Plantillas</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8472232">16.1. Contenedores</a></span></dt><dt><span class="sect1"><a href="#idp8493592">16.2. Un vistazo a las plantillas</a></span></dt><dt><span class="sect1"><a href="#idp8527032">16.3. Sintaxis del Template</a></span></dt><dt><span class="sect1"><a href="#idp8570088">16.4. Stack y Stash como Plantillas</a></span></dt><dt><span class="sect1"><a href="#idp8617896">16.5. Activando y desactivando la propiedad</a></span></dt><dt><span class="sect1"><a href="#idp8630184">16.6. Manejando objetos por valor</a></span></dt><dt><span class="sect1"><a href="#idp8642600">16.7. Introducción a los iteradores</a></span></dt><dt><span class="sect1"><a href="#idp8739008">16.8. Por qué usar iteradores</a></span></dt><dt><span class="sect1"><a href="#idp8764216">16.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp8769616">16.10. Ejercicios</a></span></dt></dl></dd><dt><span class="appendix"><a href="#ApendiceA">A. Estilo de codificación</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp8819896">A.1. General</a></span></dt><dt><span class="sect1"><a href="#idp8833216">A.2. Nombres de fichero</a></span></dt><dt><span class="sect1"><a href="#idp8839992">A.3. Marcas comentadas de inicio y fin</a></span></dt><dt><span class="sect1"><a href="#idp8848376">A.4. Paréntesis, llaves e indentación</a></span></dt><dt><span class="sect1"><a href="#idp8879240">A.5. Nombres para identificadores</a></span></dt><dt><span class="sect1"><a href="#idp8885584">A.6. Orden de los #includes</a></span></dt><dt><span class="sect1"><a href="#idp8891576">A.7. Guardas de inclusión en ficheros de cabecera</a></span></dt><dt><span class="sect1"><a href="#idp8895848">A.8. Uso de los espacios de nombres</a></span></dt><dt><span class="sect1"><a href="#idp8899928">A.9. 
      Utilización de <code class="function">require()</code> y <code class="function">assure()</code>
    </a></span></dt></dl></dd><dt><span class="appendix"><a href="#ApendiceB">B. Directrices de Programación</a></span></dt><dt><span class="appendix"><a href="#ApendiceC">C. Lecturas recomendadas</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp9014904">C.1. Sobre C</a></span></dt><dt><span class="sect1"><a href="#idp9017208">C.2. Sobre C++ en general</a></span></dt><dt><span class="sect1"><a href="#idp9033136">C.3. Los rincones oscuros</a></span></dt><dt><span class="sect1"><a href="#idp9039496">C.4. Sobre Análisis y Diseño</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><strong>Lista de figuras</strong></p><dl><dt>1.1. <a href="#idp3649016">Clase <code class="classname">Luz</code></a></dt><dt>1.2. <a href="#idp3673464">Un coche tiene un motor</a></dt><dt>1.3. <a href="#idp3684512">subclases</a></dt><dt>1.4. <a href="#idp3692152">Jerarquía de <code class="classname">Figura</code></a></dt><dt>1.5. <a href="#idp3700864">Especialización de <code class="classname">Figura</code></a></dt><dt>1.6. <a href="#idp3704752">Reescritura de métodos</a></dt><dt>1.7. <a href="#idp3713752">Relaciones</a></dt><dt>1.8. <a href="#idp3726184">Polimorfismo</a></dt><dt>1.9. <a href="#idp3748416">Upcasting</a></dt><dt>1.10. <a href="#idp3821896">Diagramas de casos de uso</a></dt><dt>1.11. <a href="#idp3826784">Un ejemplo de caso de uso</a></dt><dt>11.1. <a href="#idp6962320">Llamada a una función</a></dt><dt>14.1. <a href="#idp8006640">Upcasting</a></dt><dt>15.1. <a href="#idp8143288">Funciones virtuales</a></dt><dt>15.2. <a href="#idp8155288">Tabla de punteros virtuales</a></dt><dt>15.3. <a href="#idp8203224">Clase abstracta</a></dt><dt>15.4. <a href="#idp8231912">Una nueva función virtual</a></dt><dt>15.5. <a href="#idp8258272">Object slicing</a></dt><dt>16.1. <a href="#idp8506080">Contenedores</a></dt><dt>16.2. <a href="#idp8509840">Herencia múltiple</a></dt><dt>16.3. <a href="#idp8522736">Contenedor de objetos <code class="classname">Figura</code></a></dt></dl></div><div class="list-of-tables"><p><strong>Lista de tablas</strong></p><dl><dt>3.1. <a href="#idp4454920">Expresiones que utilizan booleanos</a></dt><dt>3.2. <a href="#idp4776976">Moldes explícitos de C++</a></dt><dt>3.3. <a href="#idp4831488">Nuevas palabras reservadas para operadores booleanos</a></dt><dt>12.1. <a href="#idp7335264">Directrices para elegir entre miembro y no-miembro</a></dt></dl></div><div class="list-of-examples"><p><strong>Índice de listados</strong></p><dl><dt>2.1. <a href="#idp4070272">C02/Declare.cpp</a></dt><dt>2.2. <a href="#idp4150256">C02/Hello.cpp</a></dt><dt>2.3. <a href="#idp4166936">C02/Stream2.cpp</a></dt><dt>2.4. <a href="#idp4173504">C02/Concat.cpp</a></dt><dt>2.5. <a href="#idp4179280">C02/Numconv.cpp</a></dt><dt>2.6. <a href="#idp4183760">C02/CallHello.cpp</a></dt><dt>2.7. <a href="#idp4191768">C02/HelloStrings.cpp</a></dt><dt>2.8. <a href="#idp4207776">C02/Scopy.cpp</a></dt><dt>2.9. <a href="#idp4217040">C02/FillString.cpp</a></dt><dt>2.10. <a href="#idp4247592">C02/Fillvector.cpp</a></dt><dt>2.11. <a href="#idp4261792">C02/GetWords.cpp</a></dt><dt>2.12. <a href="#idp4265752">C02/Intvector.cpp</a></dt><dt>3.1. <a href="#idp4315480">C03/Return.cpp</a></dt><dt>3.2. <a href="#idp4345040">C03/Ifthen.cpp</a></dt><dt>3.3. <a href="#idp4354192">C03/Guess.cpp</a></dt><dt>3.4. <a href="#idp4364760">C03/Guess2.cpp</a></dt><dt>3.5. <a href="#idp4373680">C03/Charlist.cpp</a></dt><dt>3.6. <a href="#idp4382528">C03/Menu.cpp</a></dt><dt>3.7. <a href="#idp4403264">C03/Menu2.cpp</a></dt><dt>3.8. <a href="#idp4413032">C03/gotoKeyword.cpp</a></dt><dt>3.9. <a href="#idp4419688">C03/CatsInHats.cpp</a></dt><dt>3.10. <a href="#idp4436816">C03/AutoIncrement.cpp</a></dt><dt>3.11. <a href="#idp4449288">C03/Basic.cpp</a></dt><dt>3.12. <a href="#idp4480232">C03/Specify.cpp</a></dt><dt>3.13. <a href="#idp4487864">C03/YourPets1.cpp</a></dt><dt>3.14. <a href="#idp4491952">C03/YourPets2.cpp</a></dt><dt>3.15. <a href="#idp4516112">C03/PassByValue.cpp</a></dt><dt>3.16. <a href="#idp4526136">C03/PassAddress.cpp</a></dt><dt>3.17. <a href="#idp4535024">C03/PassReference.cpp</a></dt><dt>3.18. <a href="#idp4546320">C03/AllDefinitions.cpp</a></dt><dt>3.19. <a href="#idp4550560">C03/VoidPointer.cpp</a></dt><dt>3.20. <a href="#idp4552520">C03/CastFromVoidPointer.cpp</a></dt><dt>3.21. <a href="#idp4559728">C03/Scope.cpp</a></dt><dt>3.22. <a href="#idp4571064">C03/OnTheFly.cpp</a></dt><dt>3.23. <a href="#idp4588816">C03/Global.cpp</a></dt><dt>3.24. <a href="#idp4590888">C03/Global2.cpp</a></dt><dt>3.25. <a href="#idp4611704">C03/Static.cpp</a></dt><dt>3.26. <a href="#idp4616928">C03/FileStatic.cpp</a></dt><dt>3.27. <a href="#idp4619912">C03/FileStatic2.cpp</a></dt><dt>3.28. <a href="#idp4623464">C03/Forward.cpp</a></dt><dt>3.29. <a href="#idp4680016">C03/Mathops.cpp</a></dt><dt>3.30. <a href="#idp4694864">C03/Boolean.cpp</a></dt><dt>3.31. <a href="#idp4712856">C03/printBinary.h</a></dt><dt>3.32. <a href="#idp4714120">C03/printBinary.cpp</a></dt><dt>3.33. <a href="#idp4718216">C03/Bitwise.cpp</a></dt><dt>3.34. <a href="#idp4727712">C03/Rotation.cpp</a></dt><dt>3.35. <a href="#idp4753680">C03/CommaOperator.cpp</a></dt><dt>3.36. <a href="#idp4757032">C03/Pitfall.cpp</a></dt><dt>3.37. <a href="#idp4768032">C03/SimpleCast.cpp</a></dt><dt>3.38. <a href="#idp4770664">C03/FunctionCallCast.cpp</a></dt><dt>3.39. <a href="#idp4788264">C03/static_cast.cpp</a></dt><dt>3.40. <a href="#idp4801968">C03/const_cast.cpp</a></dt><dt>3.41. <a href="#idp4809104">C03/reinterpret_cast.cpp</a></dt><dt>3.42. <a href="#idp4822400">C03/sizeof.cpp</a></dt><dt>3.43. <a href="#idp4826448">C03/sizeofOperator.cpp</a></dt><dt>3.44. <a href="#idp4861592">C03/SimpleStruct.cpp</a></dt><dt>3.45. <a href="#idp4869384">C03/SimpleStruct2.cpp</a></dt><dt>3.46. <a href="#idp4875656">C03/SelfReferential.cpp</a></dt><dt>3.47. <a href="#idp4882824">C03/SimpleStruct3.cpp</a></dt><dt>3.48. <a href="#idp4891976">C03/Enum.cpp</a></dt><dt>3.49. <a href="#idp4916424">C03/Union.cpp</a></dt><dt>3.50. <a href="#idp4925736">C03/Arrays.cpp</a></dt><dt>3.51. <a href="#idp4929216">C03/StructArray.cpp</a></dt><dt>3.52. <a href="#idp4932408">C03/ArrayAddresses.cpp</a></dt><dt>3.53. <a href="#idp4935632">C03/ArrayIdentifier.cpp</a></dt><dt>3.54. <a href="#idp4938328">C03/PointersAndBrackets.cpp</a></dt><dt>3.55. <a href="#idp4940960">C03/ArrayArguments.cpp</a></dt><dt>3.56. <a href="#idp4953656">C03/CommandLineArgs.cpp</a></dt><dt>3.57. <a href="#idp4962120">C03/ArgsToInts.cpp</a></dt><dt>3.58. <a href="#idp4968808">C03/FloatingAsBinary.cpp</a></dt><dt>3.59. <a href="#idp4978776">C03/PointerIncrement.cpp</a></dt><dt>3.60. <a href="#idp4984048">C03/PointerIncrement2.cpp</a></dt><dt>3.61. <a href="#idp4990176">C03/PointerArithmetic.cpp</a></dt><dt>3.62. <a href="#idp5012312">C03/DynamicDebugFlags.cpp</a></dt><dt>3.63. <a href="#idp5024664">C03/StringizingExpressions.cpp</a></dt><dt>3.64. <a href="#idp5029880">C03/Assert.cpp</a></dt><dt>3.65. <a href="#idp5058584">C03/PointerToFunction.cpp</a></dt><dt>3.66. <a href="#idp5064704">C03/FunctionTable.cpp</a></dt><dt>4.1. <a href="#idp5234288">C04/CLib.h</a></dt><dt>4.2. <a href="#idp5242736">C04/CLib.cpp</a></dt><dt>4.3. <a href="#idp5293336">C04/CLibTest.cpp</a></dt><dt>4.4. <a href="#idp5337640">C04/CppLib.h</a></dt><dt>4.5. <a href="#idp5352440">C04/CppLib.cpp</a></dt><dt>4.6. <a href="#idp5377304">C04/CppLibTest.cpp</a></dt><dt>4.7. <a href="#idp5418608">C04/Sizeof.cpp</a></dt><dt>4.8. <a href="#idp5475328">C04/Simple.h</a></dt><dt>4.9. <a href="#idp5489872">C04/Stack.h</a></dt><dt>4.10. <a href="#idp5500464">C04/Stack.cpp</a></dt><dt>4.11. <a href="#idp5515920">C04/StackTest.cpp</a></dt><dt>4.12. <a href="#idp5528112">C04/Scoperes.cpp</a></dt><dt>5.1. <a href="#idp5601456">C05/Public.cpp</a></dt><dt>5.2. <a href="#idp5605424">C05/Private.cpp</a></dt><dt>5.3. <a href="#idp5622152">C05/Friend.cpp</a></dt><dt>5.4. <a href="#idp5641256">C05/NestFriend.cpp</a></dt><dt>5.5. <a href="#idp5670728">C05/Class.cpp</a></dt><dt>5.6. <a href="#idp5683576">C05/Stash.h</a></dt><dt>5.7. <a href="#idp5689592">C05/Stack2.h</a></dt><dt>5.8. <a href="#idp5702344">C05/Handle.h</a></dt><dt>5.9. <a href="#idp5706064">C05/Handle.cpp</a></dt><dt>5.10. <a href="#idp5711824">C05/UseHandle.cpp</a></dt><dt>6.1. <a href="#idp5780704">C06/Constructor1.cpp</a></dt><dt>6.2. <a href="#idp5791376">C06/DefineInitialize.cpp</a></dt><dt>6.3. <a href="#idp5810880">C06/Nojump.cpp</a></dt><dt>6.4. <a href="#idp5818312">C06/Stash2.h</a></dt><dt>6.5. <a href="#idp5821384">C06/Stash2.cpp</a></dt><dt>6.6. <a href="#idp5830728">C06/Stash2Test.cpp</a></dt><dt>6.7. <a href="#idp5839216">C06/Stack3.h</a></dt><dt>6.8. <a href="#idp5841288">C06/Stack3.cpp</a></dt><dt>6.9. <a href="#idp5852976">C06/Stack3Test.cpp</a></dt><dt>6.10. <a href="#idp5871608">C06/Multiarg.cpp</a></dt><dt>6.11. <a href="#idp5881816">C06/AutoDefaultConstructor.cpp</a></dt><dt>7.1. <a href="#idp5933112">C07/Def.cpp</a></dt><dt>7.2. <a href="#idp5934768">C07/Use.cpp</a></dt><dt>7.3. <a href="#idp5941240">C07/Stash3.h</a></dt><dt>7.4. <a href="#idp5944872">C07/Stash3.cpp</a></dt><dt>7.5. <a href="#idp5949912">C07/Stash3Test.cpp</a></dt><dt>7.6. <a href="#idp5958752">C07/UnionClass.cpp</a></dt><dt>7.7. <a href="#idp5964272">C07/SuperVar.cpp</a></dt><dt>7.8. <a href="#idp5968408">C07/AnonymousUnion.cpp</a></dt><dt>7.9. <a href="#idp5991128">C07/Mem.h</a></dt><dt>7.10. <a href="#idp5997200">C07/Mem.cpp</a></dt><dt>7.11. <a href="#idp6003696">C07/MemTest.cpp</a></dt><dt>7.12. <a href="#idp6015672">C07/Mem2.h</a></dt><dt>8.1. <a href="#idp6076512">C08/Safecons.cpp</a></dt><dt>8.2. <a href="#idp6087416">C08/Constag.cpp</a></dt><dt>8.3. <a href="#idp6123784">C08/ConstPointers.cpp</a></dt><dt>8.4. <a href="#idp6131656">C08/PointerAssignment.cpp</a></dt><dt>8.5. <a href="#idp6152072">C08/Constval.cpp</a></dt><dt>8.6. <a href="#idp6156096">C08/ConstReturnValues.cpp</a></dt><dt>8.7. <a href="#idp6174992">C08/ConstPointer.cpp</a></dt><dt>8.8. <a href="#idp6192568">C08/ConstTemporary.cpp</a></dt><dt>8.9. <a href="#idp6209984">C08/ConstInitialization.cpp</a></dt><dt>8.10. <a href="#idp6213848">C08/BuiltInTypeConstructors.cpp</a></dt><dt>8.11. <a href="#idp6217112">C08/EncapsulatingTypes.cpp</a></dt><dt>8.12. <a href="#idp6228080">C08/StringStack.cpp</a></dt><dt>8.13. <a href="#idp6237144">C08/EnumHack.cpp</a></dt><dt>8.14. <a href="#idp6254272">C08/ConstMember.cpp</a></dt><dt>8.15. <a href="#idp6259160">C08/Quoter.cpp</a></dt><dt>8.16. <a href="#idp6268824">C08/Castaway.cpp</a></dt><dt>8.17. <a href="#idp6271736">C08/Mutable.cpp</a></dt><dt>8.18. <a href="#idp6285072">C08/Volatile.cpp</a></dt><dt>9.1. <a href="#idp6357448">C09/MacroSideEffects.cpp</a></dt><dt>9.2. <a href="#idp6379376">C09/Inline.cpp</a></dt><dt>9.3. <a href="#idp6385184">C09/Access.cpp</a></dt><dt>9.4. <a href="#idp6394352">C09/Rectangle.cpp</a></dt><dt>9.5. <a href="#idp6398856">C09/Rectangle2.cpp</a></dt><dt>9.6. <a href="#idp6401624">C09/Cpptime.h</a></dt><dt>9.7. <a href="#idp6415072">C09/Cpptime.cpp</a></dt><dt>9.8. <a href="#idp6418760">C09/Stash4.h</a></dt><dt>9.9. <a href="#idp6421688">C09/Stash4.cpp</a></dt><dt>9.10. <a href="#idp6424168">C09/Stash4Test.cpp</a></dt><dt>9.11. <a href="#idp6427784">C09/Stack4.h</a></dt><dt>9.12. <a href="#idp6434120">C09/Stack4Test.cpp</a></dt><dt>9.13. <a href="#idp6449152">C09/EvaluationOrder.cpp</a></dt><dt>9.14. <a href="#idp6455432">C09/Hidden.cpp</a></dt><dt>9.15. <a href="#idp6464384">C09/Noinsitu.cpp</a></dt><dt>9.16. <a href="#idp6494312">C09/ErrTest.cpp</a></dt><dt>10.1. <a href="#idp6551888">C10/StaticVariablesInfunctions.cpp</a></dt><dt>10.2. <a href="#idp6563888">C10/StaticObjectsInFunctions.cpp</a></dt><dt>10.3. <a href="#idp6575072">C10/StaticDestructors.cpp</a></dt><dt>10.4. <a href="#idp6606648">C10/LocalExtern.cpp</a></dt><dt>10.5. <a href="#idp6627856">C10/MyLib.cpp</a></dt><dt>10.6. <a href="#idp6633552">C10/Header1.h</a></dt><dt>10.7. <a href="#idp6635528">C10/BobsSuperDuperLibrary.cpp</a></dt><dt>10.8. <a href="#idp6641736">C10/FriendInjection.cpp</a></dt><dt>10.9. <a href="#idp6647888">C10/ScopeResolution.cpp</a></dt><dt>10.10. <a href="#idp6654616">C10/NamespaceInt.h</a></dt><dt>10.11. <a href="#idp6657056">C10/NamespaceMath.h</a></dt><dt>10.12. <a href="#idp6658880">C10/Arithmetic.cpp</a></dt><dt>10.13. <a href="#idp6663168">C10/NamespaceOverriding1.cpp</a></dt><dt>10.14. <a href="#idp6664832">C10/NamespaceOverriding2.h</a></dt><dt>10.15. <a href="#idp6667624">C10/OverridingAmbiguity.cpp</a></dt><dt>10.16. <a href="#idp6673392">C10/UsingDeclaration.h</a></dt><dt>10.17. <a href="#idp6680176">C10/UsingDeclaration2.cpp</a></dt><dt>10.18. <a href="#idp6706568">C10/Statinit.cpp</a></dt><dt>10.19. <a href="#idp6710544">C10/StaticArray.cpp</a></dt><dt>10.20. <a href="#idp6716568">C10/StaticObjectArrays.cpp</a></dt><dt>10.21. <a href="#idp6719944">C10/Local.cpp</a></dt><dt>10.22. <a href="#idp6724904">C10/SimpleStaticMemberFunction.cpp</a></dt><dt>10.23. <a href="#idp6732032">C10/StaticMemberFunctions.cpp</a></dt><dt>10.24. <a href="#idp6737672">C10/Singleton.cpp</a></dt><dt>10.25. <a href="#idp6745440">C10/Out.cpp</a></dt><dt>10.26. <a href="#idp6746880">C10/Oof.cpp</a></dt><dt>10.27. <a href="#idp6764224">C10/Initializer.h</a></dt><dt>10.28. <a href="#idp6770424">C10/InitializerDefs.cpp</a></dt><dt>10.29. <a href="#idp6772608">C10/Initializer.cpp</a></dt><dt>10.30. <a href="#idp6773792">C10/Initializer2.cpp</a></dt><dt>10.31. <a href="#idp6785104">C10/Dependency1.h</a></dt><dt>10.32. <a href="#idp6787304">C10/Dependency2.h</a></dt><dt>10.33. <a href="#idp6792112">C10/Technique2.cpp</a></dt><dt>10.34. <a href="#idp6797928">C10/Dependency1StatFun.h</a></dt><dt>10.35. <a href="#idp6799736">C10/Dependency2StatFun.h</a></dt><dt>10.36. <a href="#idp6801472">C10/Dependency1StatFun.cpp</a></dt><dt>10.37. <a href="#idp6802936">C10/Dependency2StatFun.cpp</a></dt><dt>10.38. <a href="#idp6804808">C10/Technique2b.cpp</a></dt><dt>11.1. <a href="#idp6913560">C11/FreeStandingReferences.cpp</a></dt><dt>11.2. <a href="#idp6923800">C11/Reference.cpp</a></dt><dt>11.3. <a href="#idp6930288">C11/ConstReferenceArguments.cpp</a></dt><dt>11.4. <a href="#idp6935728">C11/ReferenceToPointer.cpp</a></dt><dt>11.5. <a href="#idp6953448">C11/PassingBigStructures.cpp</a></dt><dt>11.6. <a href="#idp6978768">C11/HowMany.cpp</a></dt><dt>11.7. <a href="#idp6999696">C11/HowMany2.cpp</a></dt><dt>11.8. <a href="#idp7010240">C11/Linenum.cpp</a></dt><dt>11.9. <a href="#idp7035944">C11/DefaultCopyConstructor.cpp</a></dt><dt>11.10. <a href="#idp7056936">C11/NoCopyConstruction.cpp</a></dt><dt>11.11. <a href="#idp7068960">C11/SimpleStructure.cpp</a></dt><dt>11.12. <a href="#idp7077864">C11/PointerToMemberData.cpp</a></dt><dt>11.13. <a href="#idp7084200">C11/PmemFunDefinition.cpp</a></dt><dt>11.14. <a href="#idp7089112">C11/PointerToMemberFunction.cpp</a></dt><dt>11.15. <a href="#idp7092848">C11/PointerToMemberFunction2.cpp</a></dt><dt>12.1. <a href="#idp7161272">C12/OperatorOverloadingSyntax.cpp</a></dt><dt>12.2. <a href="#idp7171696">C12/OverloadingUnaryOperators.cpp</a></dt><dt>12.3. <a href="#idp7187288">C12/Integer.h</a></dt><dt>12.4. <a href="#idp7191744">C12/Integer.cpp</a></dt><dt>12.5. <a href="#idp7200752">C12/IntegerTest.cpp</a></dt><dt>12.6. <a href="#idp7203400">C12/Byte.h</a></dt><dt>12.7. <a href="#idp7208312">C12/ByteTest.cpp</a></dt><dt>12.8. <a href="#idp7260360">C12/OverloadingOperatorComma.cpp</a></dt><dt>12.9. <a href="#idp7267584">C12/SmartPointer.cpp</a></dt><dt>12.10. <a href="#idp7283096">C12/NestedSmartPointer.cpp</a></dt><dt>12.11. <a href="#idp7299832">C12/PointerToMemberOperator.cpp</a></dt><dt>12.12. <a href="#idp7322888">C12/IostreamOperatorOverloading.cpp</a></dt><dt>12.13. <a href="#idp7347400">C12/CopyingVsInitialization.cpp</a></dt><dt>12.14. <a href="#idp7358712">C12/SimpleAssignment.cpp</a></dt><dt>12.15. <a href="#idp7364112">C12/CopyingWithPointers.cpp</a></dt><dt>12.16. <a href="#idp7380560">C12/ReferenceCounting.cpp</a></dt><dt>12.17. <a href="#idp7409896">C12/AutomaticOperatorEquals.cpp</a></dt><dt>12.18. <a href="#idp7417080">C12/AutomaticTypeConversion.cpp</a></dt><dt>12.19. <a href="#idp7424648">C12/ExplicitKeyword.cpp</a></dt><dt>12.20. <a href="#idp7430640">C12/OperatorOverloadingConversion.cpp</a></dt><dt>12.21. <a href="#idp7434784">C12/ReflexivityInOverloading.cpp</a></dt><dt>12.22. <a href="#idp7451312">C12/Strings1.cpp</a></dt><dt>12.23. <a href="#idp7454520">C12/Strings2.cpp</a></dt><dt>12.24. <a href="#idp7460664">C12/TypeConversionAmbiguity.cpp</a></dt><dt>12.25. <a href="#idp7463112">C12/TypeConversionFanout.cpp</a></dt><dt>12.26. <a href="#idp7469560">C12/CopyingVsInitialization2.cpp</a></dt><dt>13.1. <a href="#idp7565368">C13/MallocClass.cpp</a></dt><dt>13.2. <a href="#idp7596416">C13/Tree.h</a></dt><dt>13.3. <a href="#idp7617544">C13/BadVoidPointerDeletion.cpp</a></dt><dt>13.4. <a href="#idp7638480">C13/PStash.h</a></dt><dt>13.5. <a href="#idp7645464">C13/PStash.cpp</a></dt><dt>13.6. <a href="#idp7658176">C13/PStashTest.cpp</a></dt><dt>13.7. <a href="#idp7695744">C13/NewHandler.cpp</a></dt><dt>13.8. <a href="#idp7732808">C13/GlobalOperatorNew.cpp</a></dt><dt>13.9. <a href="#idp7751576">C13/Framis.cpp</a></dt><dt>13.10. <a href="#idp7782024">C13/ArrayOperatorNew.cpp</a></dt><dt>13.11. <a href="#idp7799992">C13/NoMemory.cpp</a></dt><dt>13.12. <a href="#idp7817320">C13/PlacementOperatorNew.cpp</a></dt><dt>14.1. <a href="#idp7872872">C14/Useful.h</a></dt><dt>14.2. <a href="#idp7874616">C14/Composition.cpp</a></dt><dt>14.3. <a href="#idp7877216">C14/Composition2.cpp</a></dt><dt>14.4. <a href="#idp7880880">C14/Inheritance.cpp</a></dt><dt>14.5. <a href="#idp7899616">C14/PseudoConstructor.cpp</a></dt><dt>14.6. <a href="#idp7903832">C14/Combined.cpp</a></dt><dt>14.7. <a href="#idp7910392">C14/Order.cpp</a></dt><dt>14.8. <a href="#idp7918096">C14/NameHiding.cpp</a></dt><dt>14.9. <a href="#idp7926288">C14/InheritStack.cpp</a></dt><dt>14.10. <a href="#idp7938936">C14/SynthesizedFunctions.cpp</a></dt><dt>14.11. <a href="#idp7958464">C14/Car.cpp</a></dt><dt>14.12. <a href="#idp7962376">C14/FName1.cpp</a></dt><dt>14.13. <a href="#idp7968520">C14/FName2.cpp</a></dt><dt>14.14. <a href="#idp7975344">C14/PrivateInheritance.cpp</a></dt><dt>14.15. <a href="#idp7981048">C14/Protected.cpp</a></dt><dt>14.16. <a href="#idp7986384">C14/OperatorInheritance.cpp</a></dt><dt>14.17. <a href="#idp8002528">C14/Instrument.cpp</a></dt><dt>14.18. <a href="#idp8011584">C14/CopyConstructor.cpp</a></dt><dt>14.19. <a href="#idp8022968">C14/InheritStack2.cpp</a></dt><dt>15.1. <a href="#idp8078952">C15/Instrument2.cpp</a></dt><dt>15.2. <a href="#idp8105816">C15/Instrument3.cpp</a></dt><dt>15.3. <a href="#idp8112904">C15/Instrument4.cpp</a></dt><dt>15.4. <a href="#idp8134344">C15/Sizes.cpp</a></dt><dt>15.5. <a href="#idp8181384">C15/Early.cpp</a></dt><dt>15.6. <a href="#idp8213064">C15/Instrument5.cpp</a></dt><dt>15.7. <a href="#idp8220856">C15/PureVirtualDefinitions.cpp</a></dt><dt>15.8. <a href="#idp8226584">C15/AddingVirtuals.cpp</a></dt><dt>15.9. <a href="#idp8250624">C15/ObjectSlicing.cpp</a></dt><dt>15.10. <a href="#idp8268584">C15/NameHiding2.cpp</a></dt><dt>15.11. <a href="#idp8278656">C15/VariantReturn.cpp</a></dt><dt>15.12. <a href="#idp8317400">C15/VirtualDestructors.cpp</a></dt><dt>15.13. <a href="#idp8326256">C15/UnAbstract.cpp</a></dt><dt>15.14. <a href="#idp8332576">C15/PureVirtualDestructors.cpp</a></dt><dt>15.15. <a href="#idp8335984">C15/VirtualsInDestructors.cpp</a></dt><dt>15.16. <a href="#idp8350160">C15/OStack.h</a></dt><dt>15.17. <a href="#idp8357712">C15/OStackTest.cpp</a></dt><dt>15.18. <a href="#idp8366584">C15/OperatorPolymorphism.cpp</a></dt><dt>15.19. <a href="#idp8381136">C15/DynamicCast.cpp</a></dt><dt>15.20. <a href="#idp8388960">C15/StaticHierarchyNavigation.cpp</a></dt><dt>16.1. <a href="#idp8473112">C16/IntStack.cpp</a></dt><dt>16.2. <a href="#idp8477592">C16/fibonacci.h</a></dt><dt>16.3. <a href="#idp8478856">C16/fibonacci.cpp</a></dt><dt>16.4. <a href="#idp8529112">C16/Array.cpp</a></dt><dt>16.5. <a href="#idp8543408">C16/Array2.cpp</a></dt><dt>16.6. <a href="#idp8553888">C16/StackTemplate.h</a></dt><dt>16.7. <a href="#idp8560032">C16/StackTemplateTest.cpp</a></dt><dt>16.8. <a href="#idp8564872">C16/Array3.cpp</a></dt><dt>16.9. <a href="#idp8575816">C16/TStack.h</a></dt><dt>16.10. <a href="#idp8581096">C16/TStackTest.cpp</a></dt><dt>16.11. <a href="#idp8588720">C16/TPStash.h</a></dt><dt>16.12. <a href="#idp8594360">C16/AutoCounter.h</a></dt><dt>16.13. <a href="#idp8610760">C16/AutoCounter.cpp</a></dt><dt>16.14. <a href="#idp8613336">C16/TPStashTest.cpp</a></dt><dt>16.15. <a href="#idp8622552">C16/OwnerStack.h</a></dt><dt>16.16. <a href="#idp8625984">C16/OwnerStackTest.cpp</a></dt><dt>16.17. <a href="#idp8631352">C16/ValueStack.h</a></dt><dt>16.18. <a href="#idp8635192">C16/SelfCounter.h</a></dt><dt>16.19. <a href="#idp8637416">C16/SelfCounter.cpp</a></dt><dt>16.20. <a href="#idp8638400">C16/ValueStackTest.cpp</a></dt><dt>16.21. <a href="#idp8647392">C16/IterIntStack.cpp</a></dt><dt>16.22. <a href="#idp8660536">C16/NestedIterator.cpp</a></dt><dt>16.23. <a href="#idp8679664">C16/IterStackTemplate.h</a></dt><dt>16.24. <a href="#idp8688416">C16/IterStackTemplateTest.cpp</a></dt><dt>16.25. <a href="#idp8696712">C16/TStack2.h</a></dt><dt>16.26. <a href="#idp8710064">C16/TStack2Test.cpp</a></dt><dt>16.27. <a href="#idp8714552">C16/TPStash2.h</a></dt><dt>16.28. <a href="#idp8731120">C16/TPStash2Test.cpp</a></dt><dt>16.29. <a href="#idp8742496">C16/Shape.h</a></dt><dt>16.30. <a href="#idp8748736">C16/Drawing.cpp</a></dt></dl></div><div class="preface" title="Prólogo a la traducción"><div class="titlepage"><div><div><h2 class="title"><a id="prologo"></a>Prólogo a la traducción</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp96136">1. Licencia y normas de distribución</a></span></dt><dt><span class="sect1"><a href="#idp57096">2. Tecnicismos</a></span></dt><dt><span class="sect1"><a href="#idp60424">3. Código fuente</a></span></dt><dt><span class="sect1"><a href="#idp61040">4. Producción</a></span></dt><dt><span class="sect1"><a href="#idp34624">5. El equipo</a></span></dt><dt><span class="sect1"><a href="#idp3459888">6. Agradecimientos</a></span></dt><dt><span class="sect1"><a href="#idp3460544">7. Utilidades</a></span></dt></dl></div><p>
    Este trabajo de traducción ha sido realizado íntegramente por
    voluntarios. Le agradecemos que nos comunique cualquier error de
    traducción o transcripción en el texto. También será bienvenido si
    desea colaborar más activamente en la traducción. Ayúdenos a
    hacer de esta traducción un trabajo de calidad.
  </p><p>
    Si desea saber más sobre este proyecto, obtener el segundo
    volumen, colaborar enviando informes de fallos, traduciendo o
    revisando, etc. visite <a class="ulink" href="http://arco.inf-cr.uclm.es/~david.villa/pensarC++.html" target="_top">la
    página web</a><sup>[<a id="idp1584824" href="#ftn.idp1584824" class="footnote">1</a>]</sup>
    o nuestro <a class="ulink" href="http://groups.google.com/group/pensar-en-cpp" target="_top">grupo
    Google</a><sup>[<a id="idp93840" href="#ftn.idp93840" class="footnote">2</a>]</sup>.
  </p><p>
    El trabajo de traducción de este volumen prácticamente ha
    terminado, pero es posible que todavía queden muchos errores
    debido a que la revisión es trabajosa y contamos con pocos
    voluntarios. Le agradecemos su colaboración para corregir posibles
    erratas o fallos de cualquier tipo. En todo caso, el libro está
    completo y es perfectamente útil en su estado actual.
  </p><p>
    Este prólogo no forma parte del libro original y ha sido incluido
    como reseña y referencia de los trabajos de traducción que se han
    llevado a cabo. Este capítulo no lo daré por terminado hasta que
    concluya el proceso de traducción y revisión de este volumen al
    menos. La traducción del Volumen 2 ya está en marcha.
  </p><div class="sect1" title="1. Licencia y normas de distribución"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp96136"></a>1. Licencia y normas de distribución</h2></div></div></div><p>
    El equipo de traducción ha seguido al pié de la letra las
      directrices marcadas por Bruce Eckel, autor de
      <em class="citetitle">Thinking in C++</em> (el libro original), para
      la realización de traducciones y distribución de éstas.  Si
      utiliza o distribuye este texto debe cumplirlas y advertir de su
      existencia a los posibles lectores. El equipo de traducción
      elude toda responsabilidad por la violación (por parte de
      terceros) de las citadas directrices<sup>[<a id="idp97824" href="#ftn.idp97824" class="footnote">3</a>]</sup>.
    Se incluyen a continuación respetando el idioma original para
    evitar eventuales interpretaciones incorrectas:
  </p><div class="blockquote"><blockquote class="blockquote"><p>
      In my contract with the publisher, I maintain all electronic
      publishing rights to the book, including translation into foreign
      languages. This means that the publisher still handles
      negotiations for translations that are printed (and I have nothing
      directly to do with that) but I may grant translation rights for
      electronic versions of the book.
    </p><p>
      I have been granting such rights for «open-source»
      style translation projects. (Note that I still maintain the
      copyright on my material.)  That is:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	  You must provide a web site or other medium whereby people may
	  participate in the project (two easy possibilities are
	  http://www.egroups.com or http://www.topica.com).
    	</p></li><li class="listitem"><p>
	  You must maintain a downloadable version of the partially or
	  fully translated version of the book.
	</p></li><li class="listitem"><p>
	  Someone must be responsible for the organization of the
	  translation (I cannot be actively involved - I don't have the
	  time).
	</p></li><li class="listitem"><p>
	  There should only be one language translation project for each
	  book. We don't have the resources for a fork.
	</p></li><li class="listitem"><p>
	  As in an open-source project, there must be a way to pass
	  responsibility to someone else if the first person becomes too
	  busy.
	</p></li><li class="listitem"><p>
	  The book must be freely distributable.
	</p></li><li class="listitem"><p>
	  The book may be mirrored on other sites.
	</p></li><li class="listitem"><p>
	  Names of the translators should be included in the translated
	  book.
    	</p></li></ul></div></blockquote></div></div><div class="sect1" title="2. Tecnicismos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp57096"></a>2. Tecnicismos</h2></div></div></div><p>
      Se han traducido la mayor parte de los términos específicos
      tanto de orientación a objetos como de programación en
      general. Para evitar confusiones o ambigüedades a los lectores
      que manejen literatura en inglés hemos incluido entre paréntesis
      el término original la primera vez que aparece traducido.
    </p><p>
      Para traducir tecnicismos especialmente complicados hemos
      utilizado como referencia la segunda edición de <em class="citetitle">El
      lenguaje de Programación C++</em> (en castellano) así como
      la <a class="ulink" href="http://www.wikipedia.es" target="_top">Wikipedia</a>.
    </p><p>
      En contadas ocasiones se ha mantenido el término original en
      inglés. En beneficio de la legibilidad, hemos preferido no hacer
      traducciones demasiado forzadas ni utilizar expresiones que
      pudieran resultar desconocidas en el argot o en los libros
      especializados disponibles en castellano. Nuestro propósito es
      tener un libro que pueda ser comprendido por
      hispano-hablantes. Es a todas luces imposible realizar una
      traducción rigurosa acorde con las normas lingüísticas de la
      RAE, puesto que, en algunos casos, el autor incluso utiliza
      palabras de su propia invención.
    </p></div><div class="sect1" title="3. Código fuente"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp60424"></a>3. Código fuente</h2></div></div></div><p>
      Por hacer
    </p></div><div class="sect1" title="4. Producción"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp61040"></a>4. Producción</h2></div></div></div><p>
      Todo el proceso de traducción, edición, formato y tipografía ha
      sido realizado íntegramente con software libre. Todo el software
      utilizado está disponible en la distribución Debian GNU/Linux,
      que es la que se ha utilizado principalmente para la
      actualización y mantenimiento de los documentos obtenidos como
      resultado.
    </p><p>
      El texto ha sido escrito en el lenguaje de marcado DocBook versión
      4.5 en su variante XML. Cada capítulo está contenido en un fichero
      independiente y todos ellos se incluyen en un fichero
      «maestro» utilizando XInclude.
    </p><p>
      Debido a que muchos procesadores de DocBook no soportan
      adecuadamente la característica XInclude, se usa la herramienta
      <span class="application">xsltproc</span><sup>[<a id="idp125408" href="#ftn.idp125408" class="footnote">4</a>]</sup>
      para generar un único fichero XML que contiene el texto de todo
      el libro, y es ese fichero resultante el que se procesa.
    </p><div class="sect2" title="4.1. Código fuente"><div class="titlepage"><div><div><h3 class="title"><a id="idp126200"></a>4.1. Código fuente</h3></div></div></div><p>
	También se utiliza XInclude para añadir en su lugar el contenido
	de los ficheros de código fuente escritos en C++. De ese modo,
	el texto de los listados que aparecen en el libro es idéntico a
	los ficheros C++ que distribuye el autor. De ese modo, la
	edición es mucha más limpia y sobretodo se evitan posibles
	errores de transcripción de los listados.
      </p><p>
	Utilizando un pequeño programa escrito en lenguaje
	Python<sup>[<a id="idp127656" href="#ftn.idp127656" class="footnote">5</a>]</sup>,
	se substituyen los nombres etiquetados de los ficheros por la
	sentencia XInclude correspondiente:
      </p><pre class="programlisting">
<span class="hl slc">//: V1C02:Hello.cpp</span>
</pre><p>
	pasa a ser:
      </p><pre class="programlisting">
<span class="hl opt">&lt;</span>example<span class="hl opt">&gt;</span>
  <span class="hl opt">&lt;</span>title<span class="hl opt">&gt;</span>C02<span class="hl opt">/</span>Hello<span class="hl opt">.</span>cpp<span class="hl opt">&lt;/</span>title<span class="hl opt">&gt;</span>
  <span class="hl opt">&lt;</span>programlisting language<span class="hl opt">=</span><span class="hl str">&quot;C++&quot;</span><span class="hl opt">&gt;</span>
    <span class="hl opt">&lt;</span>xi<span class="hl opt">:</span>include parse<span class="hl opt">=</span><span class="hl str">&quot;text&quot;</span> href<span class="hl opt">=</span><span class="hl str">&quot;./code_v1/C02/Hello.cpp&quot;</span><span class="hl opt">/&gt;</span>
  <span class="hl opt">&lt;/</span>programlisting<span class="hl opt">&gt;</span>
<span class="hl opt">&lt;/</span>example<span class="hl opt">&gt;</span>
</pre><p>
	Una ver realizada esta substitución, se utiliza de nuevo
	<span class="command"><strong>xsltproc</strong></span> para montar tanto el texto como los
	listados en un único fichero XML.
      </p></div><div class="sect2" title="4.2. Convenciones tipográficas"><div class="titlepage"><div><div><h3 class="title"><a id="idp130336"></a>4.2. Convenciones tipográficas</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	    Palabras reservadas: <code class="keyword">struct</code>
	  </p></li><li class="listitem"><p>
	    Código fuente: <code class="code">printf("Hello world");</code>
	  </p></li><li class="listitem"><p>
	    Nombres de ficheros: <code class="filename">fichero.cpp</code>
	  </p></li><li class="listitem"><p>
	    Aplicación o fichero binario: <code class="code">make</code>
	  </p></li><li class="listitem"><p>
	    Entrecomillado: «upcasting»
	  </p></li></ul></div></div><div class="sect2" title="4.3. Esquemas y diagramas"><div class="titlepage"><div><div><h3 class="title"><a id="idp65784"></a>4.3. Esquemas y diagramas</h3></div></div></div><p>Los dibujos y diagramas originales se han rehecho en
	formato <code class="filename">.svg</code> usando la herramienta
	<span class="application">inkscape</span><sup>[<a id="idp66928" href="#ftn.idp66928" class="footnote">6</a>]</sup>. A
	partir del fichero fuente <code class="filename">.svg</code> se generan
	versiones en formato <code class="filename">.png</code> para la versión
	HTML y <code class="filename">.pdf</code> para la versión PDF.
      </p></div><div class="sect2" title="4.4. Generación de productos"><div class="titlepage"><div><div><h3 class="title"><a id="idp68656"></a>4.4. Generación de productos</h3></div></div></div><p>
	A partir del documento completo en formato DocBook se generan
	dos resultados distintos;
      </p><div class="variablelist"><dl><dt><span class="term"><a class="ulink" href="http://arco.esi.uclm.es/~david.villa/pensar_en_C++/products/vol1/vol1.html" target="_top">HTML
	  en una sola página</a></span></dt><dd><p>
	      Una página web XHTML. Para ello se utiliza también la
	      herramienta <span class="command"><strong>xsltproc</strong></span> aplicando hojas
	      de estilo XSLT que pueden encontrarse en el repositorio
	      de fuentes del proyecto. Estas plantillas son
	      modificaciones de las del proyecto de documentación del
	      programa «The Gimp», que tienen licencia
	      GPL.
	    </p><p>
	      Para el coloreado de los listados de código fuente se ha
	      utilizado el programa <span class="command"><strong>highlight</strong></span>. Para
	      ello, un pequeño programa Python marca los listados para su
	      extracción, a continuación se colorean y por último se vuelven
	      a insertar en la página HTML.
	    </p></dd><dt><span class="term"><a class="ulink" href="http://arco.inf-cr.uclm.es/~david.villa/pensar_en_C++/products/vol1/index.html" target="_top">HTML
	  (una página por sección)</a></span></dt><dd><p>
	      Un conjunto de páginas XHTML. Automáticamente se generan
	      enlaces para navegar por el documento y tablas de
	      contenidos.
	    </p></dd><dt><span class="term"><a class="ulink" href="http://arco.inf-cr.uclm.es/~david.villa/pensar_en_C++/products/Volumen1.pdf" target="_top">PDF</a></span></dt><dd><p>
	      Un documento en formato PDF utilizando la aplicación
	      <span class="application">dblatex</span><sup>[<a id="idp32768" href="#ftn.idp32768" class="footnote">7</a>]</sup>. Ha
	      sido necesario crear una hoja de estilo específicamente
	      para manipular el formato de página, títulos e
	      índices. Para el resalte de sintaxis de los listados se
	      ha utilizado el paquete LaTeX <a class="ulink" href="http://www.ctan.org/tex-archive/macros/latex/contrib/listings/" target="_top">listings</a>.
	    </p></dd></dl></div></div></div><div class="sect1" title="5. El equipo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp34624"></a>5. El equipo</h2></div></div></div><p>
      Las siguientes personas han colaborado en mayor o menor medida en
      algún momento desde el comienzo del proyecto de traducción de
      <em class="citetitle">Pensar en C++</em>:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
David Villa Alises (coordinador)  <code class="email">&lt;<a class="email" href="mailto:dvilla#gmx.net">dvilla#gmx.net</a>&gt;</code>
      </p></li><li class="listitem"><p>
Míguel Ángel García <code class="email">&lt;<a class="email" href="mailto:miguelangel.garcia#gmail.com">miguelangel.garcia#gmail.com</a>&gt;</code>
      </p></li><li class="listitem"><p>
Javier Corrales García <code class="email">&lt;<a class="email" href="mailto:jcg#damir.iem.csic.es">jcg#damir.iem.csic.es</a>&gt;</code>
      </p></li><li class="listitem"><p>
Bárbara Teruggi <code class="email">&lt;<a class="email" href="mailto:bwire.red#gmail.com">bwire.red#gmail.com</a>&gt;</code>
      </p></li><li class="listitem"><p>
Sebastián Gurin
      </p></li><li class="listitem"><p>
Gloria Barberán González  <code class="email">&lt;<a class="email" href="mailto:globargon#gmail.com">globargon#gmail.com</a>&gt;</code>
      </p></li><li class="listitem"><p>
Fernando Perfumo Velázquez  <code class="email">&lt;<a class="email" href="mailto:nperfumo#telefonica.net">nperfumo#telefonica.net</a>&gt;</code>
      </p></li><li class="listitem"><p>
José María Gómez <code class="email">&lt;<a class="email" href="mailto:josemaria.gomez#gmail.com">josemaria.gomez#gmail.com</a>&gt;</code>
      </p></li><li class="listitem"><p>
David Martínez Moreno <code class="email">&lt;<a class="email" href="mailto:ender#debian.org">ender#debian.org</a>&gt;</code>
      </p></li><li class="listitem"><p>
Cristóbal Tello <code class="email">&lt;<a class="email" href="mailto:ctg#tinet.org">ctg#tinet.org</a>&gt;</code>
      </p></li><li class="listitem"><p>
Jesús López Mollo (pre-Lucas)
      </p></li><li class="listitem"><p>
José María Requena López (pre-Lucas)
      </p></li><li class="listitem"><p>
Javier Fenoll Rejas (pre-Lucas)
      </p></li></ul></div></div><div class="sect1" title="6. Agradecimientos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3459888"></a>6. Agradecimientos</h2></div></div></div><p>
      Por hacer: LuCAS, spanglish@uma.es, docbook-ayuda@es.tldp.org
    </p></div><div class="sect1" title="7. Utilidades"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3460544"></a>7. Utilidades</h2></div></div></div><p class="html" title="Validación HTML/CSS"><strong>Validación HTML/CSS. </strong></p><div id="site-colophon"><ul><li><a href="http://validator.w3.org/check/referer" class="colophonIcon colophonIconXHTML" title="This site is valid XHTML"><span>Valid XHTML 1.0</span></a></li><li><a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" class="colophonIcon colophonIconCSS" title="This site was built with valid CSS"><span>Valid CSS</span></a></li></ul></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp1584824" href="#idp1584824" class="para">1</a>] </sup><a class="ulink" href="http://arco.esi.uclm.es/~david.villa/pensarC++.html" target="_top">http://arco.esi.uclm.es/~david.villa/pensarC++.html</a></p></div><div class="footnote"><p><sup>[<a id="ftn.idp93840" href="#idp93840" class="para">2</a>] </sup><a class="ulink" href="http://groups.google.com/group/pensar-en-cpp" target="_top">
    http://groups.google.com/group/pensar-en-cpp</a></p></div><div class="footnote"><p><sup>[<a id="ftn.idp97824" href="#idp97824" class="para">3</a>] </sup>
	El texto original de estas directrices está accesible en la
	<a class="ulink" href="http://mindview.net/Books/TIJ/Translations.html" target="_top">página web
	del autor</a>.
      </p></div><div class="footnote"><p><sup>[<a id="ftn.idp125408" href="#idp125408" class="para">4</a>] </sup><a class="ulink" href="http://xmlsoft.org/XSLT/xsltproc2.html" target="_top">http://xmlsoft.org/XSLT/xsltproc2.html</a></p></div><div class="footnote"><p><sup>[<a id="ftn.idp127656" href="#idp127656" class="para">5</a>] </sup><code class="filename">./utils/fix_includes.py</code></p></div><div class="footnote"><p><sup>[<a id="ftn.idp66928" href="#idp66928" class="para">6</a>] </sup><a class="ulink" href="http://inkscape.org/" target="_top">http://inkscape.org/</a></p></div><div class="footnote"><p><sup>[<a id="ftn.idp32768" href="#idp32768" class="para">7</a>] </sup><a class="ulink" href="http://dblatex.sourceforge.net/" target="_top">http://dblatex.sourceforge.net/</a></p></div></div></div><div class="preface" title="Prefacio"><div class="titlepage"><div><div><h2 class="title"><a id="prefacio"></a>Prefacio</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp3466232">1. Material nuevo en la segunda edición</a></span></dt><dt><span class="sect1"><a href="#idp3474608">2. Requisitos</a></span></dt><dt><span class="sect1"><a href="#idp3476720">3. Aprender C++</a></span></dt><dt><span class="sect1"><a href="#idp3489120">4. Objetivos</a></span></dt><dt><span class="sect1"><a href="#idp3498664">5. Capítulos</a></span></dt><dt><span class="sect1"><a href="#idp3551048">6. Ejercicios</a></span></dt><dt><span class="sect1"><a href="#idp3554912">7. Código fuente</a></span></dt><dt><span class="sect1"><a href="#idp3561272">8. Estándares del lenguaje</a></span></dt><dt><span class="sect1"><a href="#idp3569808">9. El CD-ROM del libro</a></span></dt><dt><span class="sect1"><a href="#idp3574304">10. CD-ROMs, seminarios, y consultoría</a></span></dt><dt><span class="sect1"><a href="#idp3578920">11. Errores</a></span></dt><dt><span class="sect1"><a href="#idp3580416">12. Sobre la portada</a></span></dt><dt><span class="sect1"><a href="#idp3587000">13. Diseño del libro y producción</a></span></dt><dt><span class="sect1"><a href="#idp3595288">14. Agradecimientos</a></span></dt></dl></div><div class="highlights"><p>
      Como cualquier lenguaje humano, C++ proporciona métodos para
      expresar conceptos. Si se utiliza de forma correcta, este medio de
      expresión será significativamente más sencillo y flexible que
      otras alternativas cuando los problemas aumentan en tamaño y
      complejidad.
    </p></div><p>
    No se puede ver C++ sólo como un conjunto de características, ya
    que algunas de esas características no tienen sentido por
    separado. Sólo se puede utilizar la suma de las partes si se está
    pensando en el diseño, no sólo en el código. Y para entender C++ de
    esta forma, se deben comprender los problemas existentes con C y con
    la programación en general. Este libro trata los problemas de
    programación, porque son problemas, y el enfoque que tiene C++ para
    solucionarlos.  Además, el conjunto de características que explico
    en cada capítulo se basará en la forma en que yo veo un tipo de
    problema en particular y cómo resolverlo con el lenguaje. De esta
    forma espero llevar al lector, poco a poco, de entender C al punto
    en el que C++ se convierta en su propia lengua.
  </p><p>
    Durante todo el libro, mi actitud será pensar que el lector desea
    construir en su cabeza un modelo que le permita comprender el
    lenguaje bajando hasta sus raíces; si se tropieza con un
    rompecabezas, será capaz de compararlo con su modelo mental y
    deducir la respuesta. Trataré de comunicarle las percepciones que
    han reorientado mi cerebro para «Pensar en C++».
  </p><div class="sect1" title="1. Material nuevo en la segunda edición"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3466232"></a>1. Material nuevo en la segunda edición</h2></div></div></div><p>
      Este libro es una minuciosa reescritura de la primera edición para
      reflejar todos los cambios que han aparecido en C++ tras la
      finalización del estándar que lo rige, y también para reflejar lo
      que he aprendido desde que escribí la primera edición. He
      examinado y reescrito el texto completo, en ocasiones quitando
      viejos ejemplos, a veces cambiándolos, y también añadiendo muchos
      ejercicios nuevos. La reorganización y reordenación del material
      tuvo lugar para reflejar la disponibilidad de mejores
      herramientas, así como mi mejor comprensión de cómo la gente
      aprende C++. He añadido un nuevo capítulo, como introducción al
      resto del libro, una introducción rápida a los conceptos de C y a
      las características básicas de C++ para aquellos que no tienen
      experiencia en C. El <acronym class="acronym">CD-ROM</acronym> incluido al final
      del libro en la edición en papel contiene un seminario: una
      introducción aún más ligera a los conceptos de C necesarios para
      comprender C++ (o Java). Chuck Allison lo escribió para mi empresa
      (MindView, Inc.), y se llama «Pensar en C: conceptos básicos
      de Java y C++». Presenta los aspectos de C que necesita
      conocer para poder cambiar a C++ o Java, abandonando los
      desagradables bits de bajo nivel con los que los programadores de
      C tratan a diario, pero que lenguajes como C++ y Java mantienen
      lejos (o incluso eliminan, en el caso de Java).
    </p><p>
      Así que la respuesta corta a la pregunta «¿Qué es diferente
      en la segunda edición?» sería que aquello que no es
      completamente nuevo se ha reescrito, a veces hasta el punto en el
      que no podría reconocer los ejemplos y el material original de la
      primera edición.
    </p><div class="sect2" title="1.1. ¿Qué contiene el volumen 2 de este libro?"><div class="titlepage"><div><div><h3 class="title"><a id="idp3471024"></a>1.1. ¿Qué contiene el volumen 2 de este libro?</h3></div></div></div><p>
	Con la conclusión del estándar de C++ también se añadieron
	algunas importantes bibliotecas nuevas, tales como string y
	los contenedores, y algoritmos de la Librería Estándar C++, y
	también se ha añadido complejidad a las plantillas. Éstos y
	otros temas más avanzados se han relegado al volumen 2 de este
	libro, incluyendo asuntos como la herencia múltiple, el manejo
	de excepciones, patrones de diseño, y material sobre la
	creación y depuración de sistemas estables.
      </p></div><div class="sect2" title="1.2. Cómo obtener el volumen 2"><div class="titlepage"><div><div><h3 class="title"><a id="idp3472288"></a>1.2. Cómo obtener el volumen 2</h3></div></div></div><p>
	Del mismo modo que el libro que lee en estos momentos,
	<em class="citetitle">Pensar en C++, Volumen 2</em> se puede
	descargar desde mi sitio web <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>. Puede
	encontrar información en el sitio web sobre la fecha prevista
	para la impresión del Volumen 2.
      </p><p>
	El sitio web también contiene el código fuente de los listados
	para ambos libros, junto con actualizaciones e información
	sobre otros seminarios en CD-ROM que ofrece MidView Inc.,
	seminarios públicos y formación interna, consultas, soporte y
	asistentes paso a paso.
      </p></div></div><div class="sect1" title="2. Requisitos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3474608"></a>2. Requisitos</h2></div></div></div><p>
      En la primera edición de este libro, decidí suponer que otra
      persona ya le había enseñado C y que el lector tenía, al menos,
      un nivel aceptable de lectura del mismo.  Mi primera intención
      fue hablar de lo que me resultó difícil: el lenguaje C++. En
      esta edición he añadido un capítulo como introducción rápida a
      C, acompañada del seminario en-CD
      <em class="citetitle">Thinking in C</em>, pero sigo asumiendo que el
      lector tiene algún tipo de experiencia en programación. Además,
      del mismo modo que se aprenden muchas palabras nuevas
      intuitivamente, viéndolas en el contexto de una novela, es
      posible aprender mucho sobre C por el contexto en el que se
      utiliza en el resto del libro.
    </p></div><div class="sect1" title="3. Aprender C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3476720"></a>3. Aprender C++</h2></div></div></div><p>
      Yo me adentré en C++ exactamente desde la misma posición en la que
      espero que se encuentren muchos de los lectores de este libro:
      como un programador con una actitud muy sensata y con muchos
      vicios de programación. Peor aún, mi experiencia era sobre
      porgramación de sistemas empotrados a nivel hardware, en la que a
      veces se considera a C como un <span class="emphasis"><em>lenguaje de alto
      nivel</em></span> y excesivamente ineficiente para ahorrar
      bits. Descubrí más tarde que nunca había sido un buen programador
      en C, camuflando así mi ignorancia sobre estructuras,
      <code class="function">malloc()</code> y <code class="function">free()</code>,
      <code class="function">setjmp()</code> y <code class="function">longjmp()</code>, y
      otros conceptos <span class="emphasis"><em>sofisticados</em></span>, y muriéndome de
      vergüenza cuando estos términos entraban en una conversación, en
      lugar de investigar su utilidad.
    </p><p>
      Cuando comencé mi lucha por aprender C++, el único libro decente
      era la auto-proclamada <span class="emphasis"><em>Guía de expertos</em></span> de
      Bjarne Stroustrup
      <sup>[<a id="idp3480704" href="#ftn.idp3480704" class="footnote">8</a>]</sup>
      así que simplifiqué los conceptos básicos por mí
      mismo. Esto se acabó convirtiendo en mi primer libro de C++
      <sup>[<a id="idp3481600" href="#ftn.idp3481600" class="footnote">9</a>]</sup>
      , que es esencialmente un reflejo de mi experiencia. Fue descrita
      como una guía de lectura para atraer a los programadores a C y C++
      al mismo tiempo. Ambas ediciones
      <sup>[<a id="idp3482568" href="#ftn.idp3482568" class="footnote">10</a>]</sup>
      del libro consiguieron una respuesta entusiasta.
    </p><p>
      Más o menos al mismo tiempo que aparecía <em class="citetitle">Using
      C++</em>, comencé a enseñar el lenguaje en seminarios y
      presentaciones. Enseñar C++ (y más tarde, Java) se convirtió en mi
      profesión; llevo viendo cabezas asintiendo, caras pálidas, y
      expresiones de perplejidad en audiencias por todo el mundo desde
      1989. Cuando comencé a dar formación interna a grupos más
      pequeños, descubrí algo durante los ejercicios. Incluso aquella
      gente que estaba sonriendo y asintiendo se encontraba equivocada
      en muchos aspectos. Creando y dirigiendo las pruebas de C++ y Java
      durante muchos años en la Conferencia de Desarrollo de Software,
      descubrí que tanto otros oradores como yo tendíamos a tocar
      demasiados temas, y todo demasiado rápido. Así que, de vez en
      cuando, a pesar de la variedad del nivel de la audiencia e
      independientemente de la forma en que se presentara el material,
      terminaría perdiendo alguna parte de mi público. Quizá sea pedir
      demasiado, pero como soy una de esas personas que se resisten a
      una conferencia tradicional (y para la mayoría de las personas,
      creo, esta resistencia está causada por el aburrimiento), quise
      intentar mantener a cada uno a su velocidad.
    </p><p>
      Durante un tiempo, estuve haciendo presentaciones en orden
      secuencial.  De ese modo, terminé por aprender experimentando
      e iterando (una técnica que también funciona
      bien en el diseño de programas en C++). Al final, desarrollé un
      curso usando todo lo que había aprendido de mi experiencia en la
      enseñanza. Así, el aprendizaje se realiza en pequeños pasos,
      fáciles de digerir, y de cara a un seminario práctico (la
      situación ideal para el aprendizaje) hay ejercicios al final de
      cada presentación. Puede encontrar mis seminarios públicos en
      <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>,
      y también puede aprender de los seminarios que he pasado a
      <acronym class="acronym">CD-ROM</acronym>.
    </p><p>
      La primera edición de este libro se gestó a lo largo de dos
      años, y el material de este libro se ha usado de muchas formas y
      en muchos seminarios diferentes. Las reacciones que he percibido
      de cada seminario me han ayudado a cambiar y reorientar el
      material hasta que he comprobado que funciona bien como un medio
      de enseñanza. Pero no es sólo un manual para dar seminarios; he
      tratado de recopilar tanta información como he podido en estas
      páginas, intentando estructurarlas para atraer al lector hasta
      la siguiente materia. Más que nada, el libro está diseñado para
      servir al lector solitario que lucha con un lenguaje de
      programación nuevo.
    </p></div><div class="sect1" title="4. Objetivos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3489120"></a>4. Objetivos</h2></div></div></div><p>
      
      Mis objetivos en este libro son:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Presentar el material paso a paso, de manera que el lector
	  pueda digerir cada concepto fácilmente antes de continuar.
	</p></li><li class="listitem"><p>
	  Usar ejemplos tan simples y cortos como sea posible. Esto a
	  veces me impide manejar problemas del <span class="emphasis"><em>mundo
	  real</em></span>, pero he descubierto que los principiantes
	  normalmente quedan más contentos cuando pueden comprender cada
	  detalle de un ejemplo que siendo impresionados por el ámbito
	  del problema que soluciona. Además, hay un límite en la
	  cantidad de código que se puede asimilar en una clase. Por
	  ello, a veces recibo críticas por usar <span class="emphasis"><em>ejemplos de
	  juguete</em></span>, pero tengo la buena voluntad de aceptarlas
	  en favor de producir algo pedagógicamente útil.
	</p></li><li class="listitem"><p>
	  La cuidadosa presentación secuencial de capacidades para
	  que no se vea algo que no ha sido explicado. De acuerdo,
	  esto no siempre es posible; en esos casos, se ofrece una
	  breve descripción introductoria.
	</p></li><li class="listitem"><p>
	  Indicarle lo que creo que es importante para que se comprenda
	  el lenguaje, más que todo lo que sé. Creo que hay una
	  "jerarquía de la importancia de la información", y hay algunos
	  hechos que el 95 por ciento de los programadores nunca
	  necesitará saber y que sólo podrían confundirles y afianzar su
	  percepción de la complejidad del lenguaje. Tomando un ejemplo
	  de C, si memoriza la tabla de precedencia de los operadores
	  (yo nunca lo hice), puede escribir código más corto. Pero si
	  lo piensa, esto confundirá al lector/mantenedor de ese
	  código. Así que olvide la precedencia, y utilice paréntesis
	  cuando las cosas no estén claras. Esta misma actitud la
	  utilizaré con alguna otra información del lenguaje C++, que
	  creo que es más importante para escritores de compiladores que
	  para programadores.
	</p></li><li class="listitem"><p>
	  Mantener cada sección suficientemente enfocada como para que
	  el tiempo de lectura -y el tiempo entre bloques de ejercicios-
	  sea razonable. Eso mantiene las mentes de la audiencia más
	  activas e involucradas durante un seminario práctico, y además
	  le da al lector una mayor sensación de avance.
	</p></li><li class="listitem"><p>
	  Ofrecer a los lectores una base sólida de manera que puedan
	  comprender las cuestiones lo suficientemente bien como para
	  pasar a otros cursos y libros más difíciles (en concreto,
	  el Volumen 2 de este libro).
	</p></li><li class="listitem"><p>
	  He tratado de no utilizar ninguna versión de C++ de ningún
	  proveedor en particular porque, para aprender el lenguaje, no
	  creo que los detalles de una implementación concreta sean tan
	  importantes como el lenguaje mismo. La documentación sobre las
	  especificaciones de implementación propia de cada proveedor
	  suele ser adecuada.
	</p></li></ol></div></div><div class="sect1" title="5. Capítulos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3498664"></a>5. Capítulos</h2></div></div></div><p>
      C++ es un lenguaje en el que se construyen características nuevas
      y diferentes sobre una sintaxis existente (por esta razón, nos
      referiremos a él como un lenguaje de programación orientado a
      objetos híbrido). Como mucha gente pasa por una curva de
      aprendizaje, hemos comenzado por adaptarnos a la forma en que los
      programadores pasan por las etapas de las cualidades del lenguaje
      C++. Como parece que la progresión natural es la de una mente
      entrenada de forma procedural, he decidido comprender y seguir el
      mismo camino y acelerar el proceso proponiendo y resolviendo las
      preguntas que se me ocurrieron cuando yo aprendía el lenguaje y
      también las que se les ocurrieron a la gente a la que lo enseñaba.
    </p><p>
      El curso fue diseñado con algo en mente: hacer más eficiente el
      proceso de aprender C++. La reacción de la audiencia me ayudó a
      comprender qué partes eran difíciles y necesitaban una aclaración
      extra. En las áreas en las que me volvía ambicioso e incluía
      demasiadas cosas de una vez, me dí cuenta -mediante la
      presentación de material- de que si incluyes demasiadas
      características, tendrás que explicarlas todas, y es fácil que la
      confusión de los estudiantes se agrave. Como resultado, he tenido
      muchos problemas para introducir las características tan
      lentamente como ha sido posible; idealmente, sólo un concepto
      importante a la vez por capítulo.
    </p><p>
      Así pues, el objetivo en cada capítulo es enseñar un concepto
      simple, o un pequeño grupo de conceptos asociados, en caso de que
      no haya más conceptos adicionales. De esa forma puede digerir cada
      parte en el contexto de su conocimiento actual antes de
      continuar. Para llevarlo a cabo, dejé algunas partes de C para más
      adelante de lo que me hubiese gustado. La ventaja es que se evita
      la confusión al no ver todas las características de C++ antes de
      que éstas sean explicadas, así su introducción al lenguaje será
      tranquila y reflejará la forma en que asimile las características
      que dejo en sus manos.
    </p><p>
      He aquí una breve descripción de los capítulos que contiene
      este libro:
    </p><p title="Capítulo 1: Introducción a los objetos."><strong><a class="link" href="#C01" title="1: Introducción a los Objetos">Capítulo 1: Introducción a los objetos.</a> </strong>
	Cuando los proyectos se vuelven demasiado grandes y difíciles de
	mantener, nace la «crisis del software», que es
	cuando los programadores dicen: «¡No podemos terminar los
	proyectos, y cuando podemos, son demasiado caros!». Eso
	provocó gran cantidad de reacciones, que se discuten en este
	capítulo mediante las ideas de Programación Orientada a Objetos
	(<acronym class="acronym">POO</acronym>) y cómo intenta ésta resolver la crisis
	del software. El capítulo le lleva a través de las
	características y conceptos básicos de la POO y también
	introduce los procesos de análisis y diseño. Además, aprenderá
	acerca de los beneficios y problemas de adaptar el lenguaje,
	y obtendrá sugerencias para adentrarse en el mundo de C++.
      </p><p title="Capítulo 2: Crear y usar objetos."><strong><a class="link" href="#C02" title="2: Construir y usar objetos">Capítulo 2: Crear y usar objetos.</a> </strong>
	Este capítulo explica el proceso de construir programas usando
	compiladores y librerías. Presenta el primer programa C++ del
	libro y muestra cómo se construyen y compilan los
	programas. Después se presentan algunas de las librerías de
	objetos básicas disponibles en C++ Estándar. Para
	cuando acabe el capítulo, dominará lo que se refiere a escribir
	un programa C++ utilizando las librerías de objetos
	predefinidas.
      </p><p title="Capítulo 3: El C de C++."><strong><a class="link" href="#C03" title="3: C en C++">Capítulo 3: El C de C++.</a> </strong>
	Este capítulo es una densa vista general de las
	características de C que se utilizan en C++, así como gran
	número de características básicas que sólo están disponibles
	en C++. Además introduce la utilidad
	<span class="application">make</span>, que es habitual en el
	desarrollo software de todo el mundo y que se utiliza para
	construir todos los ejemplos de este libro (el código fuente
	de los listados de este libro, que está disponible en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>,
	contiene los <code class="filename">makefiles</code> correspondientes a
	cada capítulo). En el capítulo 3 supongo que el lector tiene
	unos conocimientos básicos sólidos en algún lenguaje de
	programación procedural como Pascal, C, o incluso algún tipo
	de Basic (basta con que haya escrito algo de código en ese
	lenguaje, especialmente funciones). Si encuentra este capítulo
	demasiado difícil, debería mirar primero el seminario
	<em class="citetitle">Pensar en C</em> del CD que acompaña este
	libro (también disponible en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>).
      </p><p title="Capítulo 4: Abstracción de datos."><strong><a class="link" href="#C04" title="4: Abstracción de Datos">Capítulo 4: Abstracción de datos.</a> </strong>
	La mayor parte de las características de C++ giran entorno a la
	capacidad de crear nuevos tipos de datos. Esto no sólo ofrece
	una mayor organización del código, también es la base preliminar
	para las capacidades de POO más poderosas. Verá cómo esta idea
	es posible por el simple hecho de poner funciones dentro de las
	estructuras, los detalles de cómo hacerlo, y qué tipo de código
	se escribe. También aprenderá la mejor manera de organizar su
	código mediante archivos de cabecera y archivos de
	implementación.
      </p><p title="Capítulo 5: Ocultar la implementación."><strong><a class="link" href="#C05" title="5: Ocultar la implementación">Capítulo 5: Ocultar la implementación.</a> </strong>
	El programador puede decidir que algunos de los datos y
	funciones de su estructura no estén disponibles para el usuario
	del nuevo tipo haciéndolas <span class="emphasis"><em>privadas</em></span>. Eso
	significa que se puede separar la implementación principal de la
	interfaz que ve el programador cliente, y de este modo permitir
	que la implementación se pueda cambiar fácilmente sin afectar al
	código del cliente. La palabra clave <code class="keyword">class</code> también se
	presenta como una manera más elaborada de describir un tipo de
	datos nuevo, y se desmitifica el significado de la palabra
	«objeto» (es una variable elaborada).
      </p><p title="Capítulo 6: Inicialización y limpieza."><strong><a class="link" href="#C06" title="6: Inicialización y limpieza">Capítulo 6: Inicialización y limpieza.</a> </strong>
	Uno de los errores más comunes en C se debe a las variables no
	inicializadas. El <span class="emphasis"><em>constructor</em></span> de C++
	permite garantizar que las variables de su nuevo tipo de datos
	(«objetos de su clase») siempre se inicializarán
	correctamente. Si sus objetos también requieren algún tipo de
	reciclado, usted puede garantizar que ese reciclado se realice
	siempre mediante el <span class="emphasis"><em>destructor</em></span> C++.
      </p><p title="Capítulo 7: Sobrecarga de funciones y argumentos por defecto."><strong><a class="link" href="#C07" title="7: Sobrecarga de funciones y argumentos por defecto">Capítulo 7: Sobrecarga de funciones y
	  argumentos por defecto.</a> </strong>
	C++ está pensado para ayudar a construir proyectos grandes
	y complejos. Mientras lo hace, puede dar lugar a múltiples
	librerías que utilicen el mismo nombre de función, y también
	puede decidir utilizar un mismo nombre con diferentes
	significados en la misma biblioteca. Con C++ es sencillo gracias
	a la «sobrecarga de funciones», lo que le permite
	reutilizar el mismo nombre de función siempre que la lista de
	argumentos sea diferente. Los argumentos por defecto le permiten
	llamar a la misma función de diferentes maneras proporcionando,
	automáticamente, valores por defecto para algunos de sus
	argumentos.
      </p><p title="Capítulo 8: Constantes."><strong><a class="link" href="#C08" title="8: Constantes">Capítulo 8: Constantes.</a> </strong>
	Este capítulo cubre las palabras reservadas <code class="keyword">const</code>
	y <code class="keyword">volatile</code>, que en C++ tienen un significado adicional,
	especialmente dentro de las clases. Aprenderá lo que significa
	aplicar <code class="keyword">const</code> a una definición de puntero. El capítulo
	también muestra cómo varía el significado de <code class="keyword">const</code>
	según se utilice dentro o fuera de las clases y cómo crear
	constantes dentro de clases en tiempo de compilación.
      </p><p title="Capítulo 9: Funciones inline."><strong><a class="link" href="#C09" title="9: Funciones inline">Capítulo 9: Funciones inline.</a> </strong>
	Las macros del preprocesador eliminan la sobrecarga de
	llamada a función, pero el preprocesador también elimina la
	valiosa comprobación de tipos de C++. La función <code class="keyword">inline</code> le
	ofrece todos los beneficios de una macro de preprocesador
	además de los beneficios de una verdadera llamada a
	función. Este capítulo explora minuciosamente la implementación
	y uso de las funciones <code class="keyword">inline</code>.
      </p><p title="Capítulo 10: Control de nombres."><strong><a class="link" href="#C10" title="10: Control de nombres">Capítulo 10: Control de nombres.</a> </strong>
	La elección de nombres es una actividad fundamental en la
	programación y, cuando un proyecto se vuelve grande, el número
	de nombres puede ser arrollador. C++ le permite un gran control
	de los nombres en función de su creación, visibilidad, lugar de
	almacenamiento y enlazado. Este capítulo muestra cómo se
	controlan los nombres en C++ utilizando dos técnicas. Primero,
	la palabra reservada <code class="keyword">static</code> se utiliza para controlar
	la visibilidad y enlazado, y se explora su significado especial
	para clases. Una técnica mucho más útil para controlar los
	nombres a nivel global es el <code class="keyword">namespace</code> de C++, que le
	permite dividir el espacio de nombres global en distintas
	regiones.
      </p><p title="Capítulo 11: Las referencias y el constructor de copia."><strong><a class="link" href="#C11" title="11: Las referencias y el constructor de copia">Capítulo 11: Las referencias y el
	  constructor de copia.</a> </strong>
	Los punteros de C++ trabajan como los punteros de C con el
	beneficio adicional de la comprobación de tipos más fuerte de
	C++. C++ también proporciona un método adicional para manejar
	direcciones: C++ imita la <span class="emphasis"><em>referencia</em></span> de
	Algol y Pascal, que permite al compilador manipular las
	direcciones, pero utilizando la notación ordinaria. También
	encontrará el constructor-de-copia, que controla la manera en
	que los objetos se pasan por valor hacia o desde las
	funciones. Finalmente, se explica el puntero-a-miembro de C++.
      </p><p title="Capítulo 12: Sobrecarga de operadores."><strong><a class="link" href="#C12" title="12: Sobrecarga de operadores">Capítulo 12: Sobrecarga de
      operadores.</a> </strong>
	Esta característica se llama algunas veces «azúcar
	sintáctico»; permite dulcificar la sintaxis de uso de su
	tipo permitiendo operadores así como llamadas a funciones. En
	este capítulo aprenderá que la sobrecarga de operadores sólo es
	un tipo de llamada a función diferente y aprenderá cómo escribir
	sus propios operadores, manejando el -a veces confuso- uso de los
	argumentos, devolviendo tipos, y la decisión de si implementar
	el operador como método o función amiga.
      </p><p title="Capítulo 13: Creación dinámica de objetos."><strong><a class="link" href="#C13" title="13: Creación dinámica de objetos">Capítulo 13: Creación dinámica de
      objetos.</a> </strong>
	¿Cuántos aviones necesitará manejar un sistema de tráfico aéreo?
	¿Cuántas figuras requerirá un sistema CAD? En el problema de la
	programación genérica, no se puede saber la cantidad, tiempo de
	vida o el tipo de los objetos que necesitará el programa una vez
	lanzado. En este capítulo aprenderá cómo <code class="keyword">new</code> y
	<code class="keyword">delete</code> solventan de modo elegante este problema en C++
	creando objetos en el montón. También verá cómo <code class="keyword">new</code> y
	<code class="keyword">delete</code> se pueden sobrecargar de varias maneras, de
	forma que puedan controlar cómo se asigna y se recupera el
	espacio de almacenamiento.
      </p><p title="Capítulo 14: Herencia y composición."><strong><a class="link" href="#C14" title="14: Herencia y Composición">Capítulo 14: Herencia y
      composición.</a> </strong>
	La abstracción de datos le permite crear tipos nuevos de la
	nada, pero con composición y herencia, se puede crear tipos
	nuevos a partir de los ya existentes. Con la composición, se puede
	ensamblar un tipo nuevo utilizando otros tipos como piezas
	y, con la herencia, puede crear una versión más específica de un
	tipo existente. En este capítulo aprenderá la sintaxis, cómo
	redefinir funciones y la importancia de la construcción y
	destrucción para la herencia y la composición.
      </p><p title="Capítulo 15: Polimorfismo y funciones virtuales."><strong><a class="link" href="#C15" title="15: Polimorfismo y Funciones virtuales">Capítulo 15: Polimorfismo y
	  funciones virtuales.</a> </strong>
	Por su cuenta, podría llevarle nueve meses descubrir y
	comprender esta piedra angular de la POO. A través de ejercicios
	pequeños y simples, verá cómo crear una familia de tipos con
	herencia y manipular objetos de esa familia mediante su clase
	base común. La palabra reservada <code class="keyword">virtual</code> le permite
	tratar todos los objetos de su familia de forma genérica, lo que
	significa que el grueso del código no depende de información de
	tipo específica. Esto hace extensibles sus programas, de manera
	que construir programas y mantener el código sea más sencillo y
	más barato.
      </p><p title="Capítulo 16: Introducción a las plantillas."><strong><a class="link" href="#C16" title="16: Introducción a las Plantillas">Capítulo 16: Introducción a las
      plantillas.</a> </strong>
	La herencia y la composición permiten reutilizar el código
	objeto, pero eso no resuelve todas las necesidades de
	reutilización. Las plantillas permiten reutilizar el código
	fuente proporcionando al compilador un medio para sustituir el
	nombre de tipo en el cuerpo de una clase o función. Esto da
	soporte al uso de bibliotecas de <span class="emphasis"><em>clase
	contenedor</em></span>, que son herramientas importantes para el
	desarrollo rápido y robusto de programas orientados a objetos
	(la Biblioteca Estándar de C++ incluye una biblioteca
	significativa de clases contenedor). Este capítulo ofrece una
	profunda base en este tema esencial.
      </p><p>
      Temas adicionales (y materias más avanzadas) están disponibles en
      el Volumen 2 del libro, que se puede descargar del sitio web
      <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>.
    </p></div><div class="sect1" title="6. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3551048"></a>6. Ejercicios</h2></div></div></div><p>
      He descubierto que los ejercicios son excepcionalmente útiles
      durante un seminario para completar la comprensión de los
      estudiantes, así que encontrará algunos al final de cada
      capítulo. El número de ejercicios ha aumentado enormemente
      respecto a la primera edición.
    </p><p>
      Muchos de los ejercicios son suficientemente sencillos como para
      que puedan terminarse en una cantidad de tiempo razonable en una
      clase o apartado de laboratorio mientras el profesor observa,
      asegurándose de que todos los estudiantes asimilan el
      material. Algunos ejercicios son un poco más complejos para
      mantener entretenidos a los estudiantes avanzados. El grueso de
      los ejercicios están orientados para ser resueltos en poco tiempo
      y se intenta sólo probar y pulir sus conocimientos más que
      presentar retos importantes (seguramente ya los encontrará por su
      cuenta -o mejor dicho-, ellos lo encontrarán a usted).
    </p><div class="sect2" title="6.1. Soluciones a los ejercicios"><div class="titlepage"><div><div><h3 class="title"><a id="idp3553432"></a>6.1. Soluciones a los ejercicios</h3></div></div></div><p>
	Las soluciones a los ejercicios seleccionados pueden encontrarse
	en el documento electrónico <em class="citetitle">El Solucionario de Pensar
	en C++</em>, disponible por una pequeña cantidad en
	<a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>.
      </p></div></div><div class="sect1" title="7. Código fuente"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3554912"></a>7. Código fuente</h2></div></div></div><p>
      El código fuente de los listados de este libro está registrado
      como <span class="foreignphrase"><em class="foreignphrase">freeware</em></span>, distribuido mediante
      el sitio Web <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>. El
      copyright le impide publicar el código en un medio impreso sin
      permiso, pero se le otorga el derecho de usarlo de muchas otras
      maneras (ver más abajo).
    </p><p>
      El código está disponible en un fichero comprimido, destinado a
      extraerse desde cualquier plataforma que tenga una utilidad
      <span class="command"><strong>zip</strong></span> (puede buscar en Internet para encontrar
      una versión para su platarforma si aún no tiene una instalada). En
      el directorio inicial donde desempaquete el código encontrará la
      siguiente nota sobre derechos de copia:
    </p><div class="literallayout"><p><br />
Copyright (c) 2000, Bruce Eckel&#13;<br />
Source code file from the book "Thinking in C++"&#13;<br />
All rights reserved EXCEPT as allowed by the&#13;<br />
following statements: You can freely use this file&#13;<br />
for your own work (personal or commercial),&#13;<br />
including modifications and distribution in&#13;<br />
executable form only. Permission is granted to use&#13;<br />
this file in classroom situations, including its&#13;<br />
use in presentation materials, as long as the book&#13;<br />
"Thinking in C++" is cited as the source. &#13;<br />
Except in classroom situations, you cannot copy&#13;<br />
and distribute this code; instead, the sole&#13;<br />
distribution point is http://www.BruceEckel.com &#13;<br />
(and official mirror sites) where it is&#13;<br />
available for free. You cannot remove this&#13;<br />
copyright and notice. You cannot distribute&#13;<br />
modified versions of the source code in this&#13;<br />
package. You cannot use this file in printed&#13;<br />
media without the express permission of the&#13;<br />
author. Bruce Eckel makes no representation about&#13;<br />
the suitability of this software for any purpose.&#13;<br />
It is provided "as is" without express or implied&#13;<br />
warranty of any kind, including any implied&#13;<br />
warranty of merchantability, fitness for a&#13;<br />
particular purpose, or non-infringement. The entire&#13;<br />
risk as to the quality and performance of the&#13;<br />
software is with you. Bruce Eckel and the&#13;<br />
publisher shall not be liable for any damages&#13;<br />
suffered by you or any third party as a result of&#13;<br />
using or distributing this software. In no event &#13;<br />
will Bruce Eckel or the publisher be liable for &#13;<br />
any lost revenue, profit, or data, or for direct,&#13;<br />
indirect, special, consequential, incidental, or&#13;<br />
punitive damages, however caused and regardless of&#13;<br />
the theory of liability, arising out of the use of&#13;<br />
or inability to use software, even if Bruce Eckel&#13;<br />
and the publisher have been advised of the&#13;<br />
possibility of such damages. Should the software&#13;<br />
prove defective, you assume the cost of all&#13;<br />
necessary servicing, repair, or correction. If you&#13;<br />
think you've found an error, please submit the&#13;<br />
correction using the form you will find at&#13;<br />
www.BruceEckel.com. (Please use the same&#13;<br />
form for non-code errors found in the book.)&#13;<br />
<br />
</p></div><p>
      Se puede usar el código en proyectos y clases siempre y cuando
      se mantenga la nota de copyright.
    </p></div><div class="sect1" title="8. Estándares del lenguaje"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3561272"></a>8. Estándares del lenguaje</h2></div></div></div><p>
      Durante todo el libro, cuando se haga referencia al estándar
      de C ISO, generalmente se dirá «C». Sólo si se
      necesita distinguir entre C estándar y otros más viejos,
      versiones previas al estándar de C, se hará una distinción.
    </p><p>
      Cuando se escribió este libro, el Comité de Estándares de C++ ya
      había terminado de trabajar en el lenguaje. Por eso, se usará el
      término <span class="emphasis"><em>C++ Estándar</em></span> para referirse al
      lenguaje estandarizado. Si se hace referencia simplemente a C++,
      debería asumir que se quiere decir «C++ Estándar».
    </p><p>
      Hay alguna confusión sobre el nombre real del Comité de
      Estándares de C++ y el nombre del estándar mismo. Steve Clamage, el
      presidente del comité, clarificó esto:
    </p><div class="blockquote"><blockquote class="blockquote"><p>
	Hay dos comités de estandarización de C++: El comité NCITS
	(antiguamente X3) J16 y el comité ISO JTC1/SC22/WG14. ANSI
	alquila NCITS para crear comités técnicos para desarrollar
	estándares nacionales americanos.
      </p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>
	J16 fue alquilado en 1989 para crear un estándar
	americano para C++. Por el año 1991 se alquiló WG14 para crear
	un estándar internacional. El proyecto J16 se convirtió en un
	proyecto «Tipo I» (Internacional) y se subordinó
	al esfuerzo de estandarización de ISO.
      </p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>
	Los dos comités se encontraban al mismo tiempo en el mismo
	sitio, y el voto de J16 constituye el voto americano con
	WG14. WG14 delega el trabajo técnico a J16. WG14 vota por el
	trabajo técnico de J16.
    </p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>
	El estándar de C++ fue creado originalmente como un estándar
	ISO. ANSI votó más tarde (como recomendaba J16) para adoptar el
	estándar de C++ ISO como el estándar americano para C++.
    </p></blockquote></div><p>
      Por eso, «ISO» es la forma correcta de referirse al
      Estándar C++.
    </p><div class="sect2" title="8.1. Soporte del lenguaje"><div class="titlepage"><div><div><h3 class="title"><a id="idp3568440"></a>8.1. Soporte del lenguaje</h3></div></div></div><p>
	Puede que su compilador no disponga de todas las características
	discutidas en este libro, especialmente si no tiene la versión
	más recente del compilador. Implementar un lenguaje como C++ es
	una tarea hercúlea, y puede esperar que las características
	aparecerán poco a poco en lugar de todas a la vez. Pero si
	prueba uno de los ejemplos del libro y obtiene un montón de
	errores del compilador, no es necesariamente un error en el
	código o en el compilador; simplemente puede no estar implementado
	aún en su compilador particular.
      </p></div></div><div class="sect1" title="9. El CD-ROM del libro"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3569808"></a>9. El CD-ROM del libro</h2></div></div></div><p>
      El contenido principal del CD-ROM empaquetado al final de este
      libro es un «seminario en CD-ROM» titulado
      <em class="citetitle">Pensar en C: Fundamentos para Java y C++</em>
      obra de Chuck Allison (publicado por MindView, Inc., y también
      disponible en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>). Contiene
      muchas horas de grabaciones y transparencias, que pueden mostrarse
      en la mayoría de las computadoras que dispongan de lector de
      CD-ROM y sistema de sonido.
    </p><p>
      El objetivo de <em class="citetitle">Pensar en C</em> es llevarle
      cuidadosamente a través de los fundamentos del lenguaje C. Se
      centra en el conocimiento que necesita para poder pasarse a C++ o
      Java en lugar de intentar hacerle un experto en todos los
      recovecos de C (una de las razones de utilizar un lenguaje de alto
      nivel como C++ o Java es, precisamente, que se pueden evitar
      muchos de esos recovecos). También contiene ejercicios y
      soluciones guiadas. Téngalo en cuenta porque el <a class="link" href="#C03" title="3: C en C++">Capítulo 3</a> de este libro va más allá del CD de
      <em class="citetitle">Pensar en C</em>, el CD no es una alternativa a
      este capítulo, sino que debería utilizarse como preparación para
      este libro.
    </p><p>
      Por favor, tenga en cuenta que el CD-ROM está basado en navegador,
      por lo que debería tener un navegador Web instalado en su máquina
      antes de utilizarlo.
    </p></div><div class="sect1" title="10. CD-ROMs, seminarios, y consultoría"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3574304"></a>10. CD-ROMs, seminarios, y consultoría</h2></div></div></div><p>
      Hay seminarios en CD-ROM planeados para cubrir el Volumen 1 y el
      Volumen 2 de este libro.  Comprenden muchas horas de grabaciones
      mías que acompañan las transparencias que cubren el material
      seleccionado de cada capítulo del libro. Se pueden ver en la
      mayoría de las computadoras que disponen de lector de CDROM y
      sistema de sonido. Estos CDs pueden comprarse en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>, donde
      encontrará más información y lecturas de ejemplo.
    </p><p>
      Mi compañía, MindView, Inc., proporciona seminarios públicos de
      preparación práctica basados en el material de este libro y
      también en temas avanzados. El material seleccionado de cada
      capítulo representa una lección, que se continúa con un periodo de
      ejercicios monitorizados para que cada estudiante reciba atención
      personal. También proporcionamos preparación «in
      situ», consultoría, tutorización, diseño y asistentes de
      código. Puede encontrar la información y los formularios para los
      próximos seminarios, así como otra información de contacto, en
      <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>.
    </p><p>
      A veces me encuentro disponible para consultas de diseño,
      evaluación de procesos y asistencia. Cuando comencé a escribir
      sobre computadoras, mi motivación principal fue incrementar mis
      actividades de consultoría, porque encontraba que la consultoría
      era competitiva, educacional, y una de mis experiencias
      profesionales más valiosas. Así que haré todo lo que pueda para
      incluirle a usted en mi agenda, o para ofrecerle uno de mis
      socios (que son gente que conozco bien y con la que he tratado, y
      a menudo co-desarrollan e imparten seminarios conmigo).
    </p></div><div class="sect1" title="11. Errores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3578920"></a>11. Errores</h2></div></div></div><p>
      No importa cuántos trucos emplee un escritor para detectar los
      errores, algunos siempre se escapan y saltan del papel al
      lector atento. Si encuentra algo que crea que es un error, por
      favor, utilice el formulario de correcciones que encontrará
      en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>. Se
      agradece su ayuda.
    </p></div><div class="sect1" title="12. Sobre la portada"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3580416"></a>12. Sobre la portada</h2></div></div></div><p>
      La primera edición de este libro tenía mi cara en la portada, pero
      para la segunda edición yo quería desde el principio una portada
      que se pareciera más una obra de arte, como la portada de
      <em class="citetitle">Pensar en Java</em>. Por alguna razón, C++
      parece sugerirme Art Decó con sus curvas simples y pinceladas
      cromadas. Tenía en mente algo como esos carteles de barcos y
      aviones con cuerpos largos.
    </p><p>
      Mi amigo Daniel Will-Harris, (<a class="ulink" href="http://www.Will-Harris.com" target="_top">www.Will-Harris.com</a>) a
	quien conocí en las clases del coro del instituto, iba a llegar
	a ser un diseñador y escritor de talla mundial. Él ha hecho
	prácticamente todos mis diseños, incluída la portada para la
	primera edición de este libro. Durante el proceso de diseño de
	la portada, Daniel, insatisfecho con el progreso que
	realizábamos, siempre preguntaba: «¿Qué relación hay entre
	las personas y las computadoras?». Estábamos atascados.
    </p><p>
      Como capricho, sin nada en mente, me pidió que pusiera mi cara en
      el escáner. Daniel tenía uno de sus programas gráficos (Corel
      Xara, su favorito) que «autotrazó» mi cara
      escaneada. Él lo describe de la siguente manera: «El
      autotrazado es la forma en la que la computadora transforma
      un dibujo en los tipos de líneas y curvas que realmente le
      gustan». Entonces jugó con ello hasta que obtuvo algo que
      parecía un mapa topográfico de mi cara, una imagen que podría
      ser la manera en que la computadora ve a la gente.
    </p><p>
      Cogí esta imagen y la fotocopié en papel de acuarela (algunas
      copiadoras pueden manejar papeles gruesos), y entonces comenzó a
      realizar montones de experimentos añadiendo acuarela a la
      imagen. Seleccionamos las que nos gustaban más, entonces Daniel
      las volvió a escanear y las organizó en la portada, añadiendo el
      texto y otros elementos de diseño. El proceso total requirió
      varios meses, mayormente a causa del tiempo que me tomó hacer las
      acuarelas. Pero me he divertido especialmente porque conseguí
      participar en el arte de la portada, y porque me dio un incentivo
      para hacer más acuarelas (lo que dicen sobre la práctica realmente
      es cierto).
    </p></div><div class="sect1" title="13. Diseño del libro y producción"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3587000"></a>13. Diseño del libro y producción</h2></div></div></div><p>
      El diseño del interior del libro fue creado por Daniel
      Will-Harris, que solía jugar con letras (FIXME:rub-on) en el
      instituto mientras esperaba la invención de las computadoras y la
      publicación de escritorio. De todos modos, yo mismo produje las
      páginas para impresión
      (<span class="foreignphrase"><em class="foreignphrase">camera-ready</em></span>), por lo que los
      errores tipográficos son míos. Se utilizó <span class="trademark">Microsoft</span>® Word para Windows
      Versiones 8 y 9 para escribir el libro y crear la versión para
      impresión, incluyendo la generación de la tabla de contenidos y el
      índice (creé un servidor automatizado COM en Python, invocado
      desde las macros VBA de Word, para ayudarme en el marcado de los
      índices). Python (vea <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.python.com</a>) se utilizó
      para crear algunas de las herramientas para comprobar el código, y
      lo habría utilizado como herramienta de extracción de código si lo
      hubiese descubierto antes.
    </p><p>
      Creé los diagramas utilizando <span class="trademark">Visio</span>®. Gracias a <span class="orgname">Visio
	Corporation</span> por crear una herramienta tan útil.
    </p><p>
      El tipo de letra del cuerpo es Georgia y los títulos utilizan
      Verdana. La versión definitiva se creó con <span class="trademark">Adobe</span>® Acrobat 4 y el fichero
      generado se llevó directamente a la imprenta - muchas gracias a
      Adobe por crear una herramienta que permite enviar documentos
      listos para impresión por correo electrónico, así como permitir
      que se realicen múltiples revisiones en un único día en lugar de
      recaer sobre mi impresora láser y servicios rápidos 24 horas
      (probamos el proceso Acrobat por primera vez con <em class="citetitle">Pensar
      en Java</em>, y fui capaz de subir la versión final de ese
      libro a la imprenta de U.S. desde Sudáfrica).
    </p><p>
      La versión HTML se creó exportando el documento Word a RTF, y
      utilizando entonces RTF2HTML (ver <a class="ulink" href="http://www.sunpack.com/RTF/" target="_top">http://www.sunpack.com/RTF/</a>)
      para hacer la mayor parte del trabajo de la conversión HTML
      (gracias a Chris Hector por hacer una herramienta tan útil y
      especialmente fiable). Los ficheros resultantes se limpiaron
      utilizando un programa Python que truqué, y los WMFs se
      transformaron en GIFs utilizando el PaintShop Pro 6 de <span class="trademark">JASC</span>® y su herramienta de conversión
      por lotes (gracias a JASC por resolver tantos de mis problemas con
      su excelente producto). El realce del color de la sintaxis se
      añadió con un script Perl amablemente cedido por Zafir Anjum.
    </p></div><div class="sect1" title="14. Agradecimientos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3595288"></a>14. Agradecimientos</h2></div></div></div><p>
      Lo primero, agradecer a todo aquel que presentó correcciones y
      sugerencias desde Internet; han sido de tremenda ayuda para
      mejorar la calidad de este libro, y no podría haberlo hecho
      sin ustedes. Gracias en especial a John Cook.
    </p><p>
      Las ideas y comprensión de este libro han llegado de varias
      fuentes: amigos como Chuck Allison, Andrea Provaglio, Dans
      Sakx, Scott Meyers, Charles Petzold y Michael Wilk; pioneros
      del lenguaje como Bjarne Stroustrup, Andrew Koenig y Rob
      Murray; miembros del Comité de Estándares de C++ como Nathan
      Myers (que fue de particular ayuda y generosidad con sus
      percepciones), Bill Plauger, Reg Charney, Tom Penello, Tom
      Plum, Sam Druker y Uwe Steinmueller; gente que ha hablado en mis
      charlas de C++ en la Conferencia de Desarrollo de Software;
      y a menudo estudiantes de mis seminarios, que preguntan
      aquello que necesito oír para aclarar el material.
    </p><p>
      Enormes agradecimientos para mi amigo Gen Kiyooka, cuya
      compañía Digigami me proporcionó un servidor web.
    </p><p>
      Mi amigo Richard Hale Shaw y yo hemos enseñado C++ juntos; las
      percepciones de Richard y su apoyo han sido muy útiles (y las
      de Kim también). Gracias también a DoAnn Vikoren, Eric Faurot,
      Jennifer Jessup, Tara Arrowood, Marco Pardi, Nicole Freeman,
      Barbara Hanscome, Regina Ridley, Alex Dunne y el resto del
      reparto y plantilla de MFI.
    </p><p>
      Un agradecimiento especial para todos mis profesores y
      todos mis estudiantes (que también son profesores).
    </p><p>
      Y para mis escritores favoritos, mi más profundo aprecio y
      simpatía por vuestros esfuerzos: John Irving, Neal Stephenson,
      Robertson Davies (te echaremos de menos), Tom Robbins, William
      Gibson, Richard Bach, Carlos Castaneda y Gene Wolfe.
    </p><p>
      A Guido van Rossum, por inventar Python y donarlo
      desinteresadamente al mundo. Has enriquecido mi vida con tu
      contribución.
    </p><p>
      Gracias a la gente de Prentice Hall: Alan Apt, Ana Terry,
      Scott Disanno, Toni Holm y mi editora de copias electrónicas
      Stephanie English. En márqueting, Bryan Gambrel y Jennie
      Burger.
    </p><p>
      Sonda Donovan me ayudó con la producción del CD ROM. Daniel
      Will-Harris (por supuesto) creó el diseño de la portada que se
      encuentra en el propio CD.
    </p><p>
      Para todos los grandes amigos de Crested Butte, gracias por hacer
      de él un lugar mágico, especialmente a Al Smith (creador del
      maravilloso Camp4 Coffee Garden), mis vecinos Dave y Erika, Marsha
      de la librería Heg's Place, Pat y John de Teocalli Temale, Sam de
      Barkery Café, y a Tiller por su ayuda con la investigación en
      audio. Y a toda la gente fenomenal que anda por Camp4 y hace
      interesantes mis mañanas.
    </p><p>
      

      La lista de amigos que me han dado soporte incluye, pero no está
      limitada, a Zack Urlocker, Andrew Binstock, Neil Rubenking, Kraig
      Brocschmidt, Steve Sinofsky, JD Hildebrandt, Brian McElhinney,
      Brinkey Barr, Larry O'Brien, Bill Gates en <em class="citetitle">Midnight
      Engineering Magazine</em>, Larry Constantine, Lucy
      Lockwood, Tom Keffer, Dan Putterman, Gene Wang, Dave Mayer, David
      Intersimone, Claire Sawyers, los Italianos (Andrea Provaglio,
      Rossella Gioia, Laura Fallai, Marco &amp; Lella Cantu, Corrado,
      Ilsa y Christina Giustozzi), Chris y Laura Strand (y Parker), los
      Alquimistas, Brad Jerbic, Marilyn Cvitanic, el
      Mabrys, el Halflingers, los Pollocks, Peter Vinci, los Robbins,
      los Moelters, Dave Stoner, Laurie Adams, los Cranstons, Larry
      Fogg, Mike y karen Sequeira, Gary Entsminger y Allison Brody,
      Kevin, Sonda &amp; Ella Donovan, Chester y Shannon Andersen, Joe
      Lordi, Dave y Brenda Barlett, los Rentschlers, Lynn y Todd y sus
      familias. Y por supuesto, a Mamá y Papá.
    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp3480704" href="#idp3480704" class="para">8</a>] </sup>
	  Bjarne Stroustrup, <em class="citetitle">The C++ Programming
	  Language</em>, Addison-Wesley, 1986 (first edition).
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3481600" href="#idp3481600" class="para">9</a>] </sup>
	  <em class="citetitle">Using C++</em>, Osborne/McGraw-Hill 1989.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3482568" href="#idp3482568" class="para">10</a>] </sup>
	  <em class="citetitle">Using C++ and C++ Inside &amp; Out</em>,
	  Osborne/McGraw-Hill 1993.
	</p></div></div></div><div class="chapter" title="1: Introducción a los Objetos"><div class="titlepage"><div><div><h2 class="title"><a id="C01"></a>1: Introducción a los Objetos</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp3612568">1.1. El progreso de abstracción</a></span></dt><dt><span class="sect1"><a href="#idp3632576">1.2. Cada objeto tiene una interfaz</a></span></dt><dt><span class="sect1"><a href="#idp3657520">1.3. La implementación oculta</a></span></dt><dt><span class="sect1"><a href="#idp3669728">1.4. Reutilizar la implementación</a></span></dt><dt><span class="sect1"><a href="#idp3679560">1.5. Herencia: reutilización de interfaces</a></span></dt><dt><span class="sect1"><a href="#idp3718416">1.6. Objetos intercambiables gracias al polimorfismo</a></span></dt><dt><span class="sect1"><a href="#idp3761184">1.7. Creación y destrucción de objetos</a></span></dt><dt><span class="sect1"><a href="#idp3773112">1.8. Gestión de excepciones: tratamiento de errores</a></span></dt><dt><span class="sect1"><a href="#idp3780784">1.9. Análisis y diseño</a></span></dt><dt><span class="sect1"><a href="#idp3897048">1.10. Programación Extrema</a></span></dt><dt><span class="sect1"><a href="#idp3919120">1.11. Porqué triunfa C++</a></span></dt><dt><span class="sect1"><a href="#idp3946072">1.12. Estrategias de transición</a></span></dt><dt><span class="sect1"><a href="#idp116672">1.13. Resumen</a></span></dt></dl></div><div class="highlights"><p>
      El origen de la revolución informática ocurrió dentro de una
      máquina. Por tanto, el origen de nuestros lenguajes de
      programación tiende a parecerse a esa máquina.
    </p></div><p>
    Pero los ordenadores no son tanto máquinas como herramientas de
    amplificación de la mente («bicicletas para la mente»,
    como le gusta decir a <span class="personname"><span class="firstname">Steve</span> <span class="surname">Jobs</span></span>) y un medio de expresión
    diferente.  Como resultado, las herramientas empiezan a parecerse
    menos a las máquinas y más a partes de nuestra mente, y también a
    otros medios de expresión como la escritura, la pintura, la
    escultura, la animación y la cinematografía. La programación
    orientada a objetos es parte de este movimiento hacia un uso del
    ordenador como medio de expresión.
  </p><p>
    Este capítulo le servirá de introducción a los conceptos básicos de
    la programación orientada a objetos (POO), incluyendo un resumen de
    los métodos de desarrollo de la POO. Este capítulo, y este libro,
    presuponen que el lector ya tiene experiencia con un lenguaje de
    programación procedural, aunque no tiene porqué ser C. Si cree que
    necesita más preparación en programación y en la sintaxis de C antes
    de abordar este libro, debería leer el CD-ROM de entrenamiento
    <em class="citetitle">Thinking in C: Foundations for C++ and Java</em>,
    que acompaña a este libro, y está disponible también en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
  </p><p>
    Este capítulo contiene material básico y suplementario. Mucha gente
    no se siente cómoda adentrándose en la programación orientada a
    objetos sin tener antes una visión global. Por eso, aquí se
    introducen muchos conceptos que intentan darle una visión sólida de
    la POO. Sin embargo, muchas personas no captan los conceptos
    globales hasta que no han visto primero parte de la mecánica; puede
    que se atasquen o se pierdan si no hay ningún trozo de código al que
    ponerle las manos encima. Si usted pertenece a este último grupo, y
    está ansioso por llegar a las especificaciones del lenguaje,
    siéntase libre de saltar este capítulo; eso no le impedirá
    escribir programas o aprender el lenguaje. Sin embargo, quizá quiera
    volver a este capítulo para completar sus conocimientos y poder
    comprender porqué son importantes los objetos y cómo diseñar con
    ellos.
  </p><div class="sect1" title="1.1. El progreso de abstracción"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3612568"></a>1.1. El progreso de abstracción</h2></div></div></div><p>
      Todos los lenguajes de programación proporcionan abstracciones. Se
      puede afirmar que la complejidad de los problemas que se pueden
      resolver está directamente relacionada con el tipo y calidad de la
      abstracción. Por «tipo» me refiero a «¿Qué es
      lo que está abstrayendo?». El lenguaje ensamblador es una
      pequeña abstracción de la máquina subyacente. Muchos lenguajes
      llamados «imperativos» que siguieron (como Fortran,
      BASIC y C) eran abstracciones del lenguaje ensamblador. Estos
      lenguajes suponen grandes mejoras con respecto al lenguaje
      ensamblador, pero su abstracción primaria todavía requiere pensar
      en términos de la estructura del ordenador, en lugar de la
      estructura del problema que intenta resolver. El programador debe
      establecer la asociación entre el modelo de la máquina (en el
      «espacio de soluciones», que es el lugar donde está
      modelando ese problema, como un ordenador) y el modelo del
      problema que se está resolviendo (en el «espacio de
      problemas», que es el lugar donde existe el problema). El
      esfuerzo requerido para realizar esta correspondencia, y el hecho
      de que sea extrínseco al lenguaje de programación, produce
      programas difíciles de escribir y caros de mantener y, como efecto
      secundario, creó toda la industria de «métodos de
      programación».
    </p><p>
      La alternativa a modelar la máquina es modelar el problema que
      está intentando resolver. Los primeros lenguajes como LISP y
      APL eligieron concepciones del mundo particulares
      («Todos los problemas son listas en última
      instancia», o «Todos los problemas son
      algorítmicos»). PROLOG reduce todos los problemas a
      cadenas de decisiones. Se han creado lenguajes para programación
      basados en restricciones y para programar manipulando
      exclusivamente símbolos gráficos (lo último demostró ser
      demasiado restrictivo). Cada uno de estos métodos es una buena
      solución para el tipo particular de problema para el que fueron
      diseñados, pero cuando uno sale de ese dominio se hacen
      difíciles de usar.
    </p><p>
      El método orientado a objetos va un paso más allá, proporcionando
      herramientas para que el programador represente los elementos en
      el espacio del problema. Esta representación es lo suficientemente
      general como para que el programador no esté limitado a un tipo
      particular de problema. Nos referimos a los elementos en el
      espacio del problema, y a sus representaciones en el espacio de la
      solución, como «objetos» (por supuesto, necesitará
      otros objetos que no tengan analogías en el espacio del problema).
      La idea es que permita al programa adaptarse al lenguaje del
      problema añadiendo nuevos tipos de objetos de modo que cuando lea
      el código que describe la solución, esté leyendo palabras que
      además expresan el problema. Es un lenguaje de abstracción más
      flexible y potente que los que haya usado antes. De esta manera,
      la POO permite describir el problema en términos del problema, en
      lugar de usar términos de la computadora en la que se ejecutará la
      solución. Sin embargo, todavía existe una conexión con la
      computadora. Cada objeto se parece un poco a una pequeña
      computadora; tiene un estado y operaciones que se le puede pedir
      que haga. Sin embargo, no parece una mala analogía a los objetos
      en el mundo real; todos ellos tienen características y comportamientos.
    </p><p>
      Algunos diseñadores de lenguajes han decidido que la
      programación orientada a objetos en sí misma no es adecuada para
      resolver fácilmente todos los problemas de programación, y
      abogan por una combinación de varias aproximaciones en lenguajes
      de programación <span class="emphasis"><em>multiparadigma</em></span>.
      <sup>[<a id="idp3622872" href="#ftn.idp3622872" class="footnote">11</a>]</sup>
    </p><p>
      <span class="personname"><span class="firstname">Alan</span> <span class="surname">Kay</span></span> resumió las cinco
      características básicas de Smalltalk, el primer lenguaje
      orientado a objetos con éxito y uno de los lenguajes en los que
      está basado C++. Esas características representan una
      aproximación a la programación orientada a objetos:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Todo es un objeto. Piense en un objeto como una variable
	  elaborada; almacena datos, pero puede «hacer
	  peticiones» a este objeto, solicitando que realice
	  operaciones en sí mismo. En teoría, puede coger cualquier
	  componente conceptual del problema que está intentando
	  resolver (perros, edificios, servicios, etc.) y
	  representarlos como un objeto en su programa.
	</p></li><li class="listitem"><p>
	  Un programa es un grupo de objetos enviando mensajes a otros
	  para decirles qué hacer. Para hacer una petición a un
	  objeto, «envía un mensaje» a ese objeto. Más
	  concretamente, puede pensar en un mensaje como una petición
	  de invocación a una función que pertenece a un objeto
	  particular.
	</p></li><li class="listitem"><p>
	  Cada objeto tiene su propia memoria constituida por otros
	  objetos. Visto de otra manera, puede crear un nuevo tipo de
	  objeto haciendo un paquete que contenga objetos
	  existentes. Por consiguiente, puede hacer cosas complejas en
	  un programa ocultando la complejidad de los objetos.
	</p></li><li class="listitem"><p>
	  Cada objeto tiene un tipo. Usando el argot, cada objeto es
	  una instancia de una clase, en el que «clase»
	  es sinónimo de «tipo». La característica más
	  importante que lo distingue de una clase es «¿Qué
	  mensajes puede enviarle?»
	</p></li><li class="listitem"><p>
	  Todos los objetos de un tipo particular pueden recibir los
	  mismos mensajes. En realidad es una frase con doble sentido,
	  como verá más tarde. Como un objeto de tipo
	  <code class="classname">círculo</code> es también un objeto de tipo
	  <code class="classname">figura</code>, está garantizado que un círculo
	  aceptará los mensajes de figura. Esto significa que puede
	  escribir código que habla con objetos
	  <code class="classname">figura</code> y automáticamente funcionará con
	  cualquier otro objeto que coincida con la descripción de
	  <code class="classname">figura</code>. Esta
	  <span class="emphasis"><em>sustituibilidad</em></span> es uno de los conceptos
	  más poderosos en la POO.
	</p></li></ol></div></div><div class="sect1" title="1.2. Cada objeto tiene una interfaz"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3632576"></a>1.2. Cada objeto tiene una interfaz</h2></div></div></div><p>
      Aristóteles fue probablemente el primero en hacer un estudio
      minucioso del concepto de <span class="emphasis"><em>tipo</em></span>; él habló de
      «la clase de peces y la clase de pájaros». La idea
      de que todos los objetos, aún siendo únicos, también son parte
      de una clase de objetos que tienen características y
      comportamientos comunes se utilizó directamente en el primer
      lenguaje orientado a objetos, Simula-67, con su palabra
      reservada <code class="keyword">class</code> que introduce un nuevo tipo en un
      programa.
    </p><p>
      Simula, como su nombre indica, fue creado para desarrollar
      simulaciones como el clásico «problema del cajero»
      <sup>[<a id="idp3635480" href="#ftn.idp3635480" class="footnote">12</a>]</sup>.  Tiene un grupo de cajeros, clientes, cuentas,
      transacciones, y unidades de moneda - un montón de
      «objetos». Los objetos idénticos, exceptuando su
      estado durante la ejecución del programa, se agrupan en
      «clases de objetos» y de ahí viene la palabra
      reservada <code class="keyword">class</code>. Crear tipos de datos abstractos
      (clases) es un concepto fundamental en la programación orientada
      a objetos. Los tipos de datos abstractos trabajan casi
      exactamente como tipos predefinidos: puede crear variables de un
      tipo (llamadas <span class="emphasis"><em>objetos</em></span> o
      <span class="emphasis"><em>instancias</em></span> en el argot de la programación
      orientada a objetos) y manipular estas variables (llamado
      <span class="emphasis"><em>envío de mensajes</em></span> o
      <span class="emphasis"><em>peticiones</em></span>; envía un mensaje y el objeto
      decide qué hacer con él). Los miembros (elementos) de cada clase
      tienen algo en común: cada cuenta tiene un balance, cada
      cajero puede aceptar un depósito, etc. Al mismo tiempo, cada
      miembro tiene su propio estado, cada cuenta tiene un balance
      diferente, cada cajero tiene un nombre. De este modo, cada
      cajero, cliente, cuenta, transacción, etc., se puede
      representar con una única entidad en el programa de
      computador. Esta entidad es un objeto, y cada objeto pertenece a
      una clase particular que define sus características y
      comportamientos.
    </p><p>
      Por eso, lo que hace realmente un programa orientado a objetos es
      crear nuevos tipos de datos, prácticamente todos los lenguajes de
      programación orientados a objetos usan la palabra reservada
      <code class="keyword">class</code>. Cuando vea la palabra «type», piense
      en «class» y viceversa
      <sup>[<a id="idp3642152" href="#ftn.idp3642152" class="footnote">13</a>]</sup>.
    </p><p>
      Dado que una clase describe un conjunto de objetos que tienen
      idénticas características (elementos de datos) y comportamientos
      (funcionalidad), una clase es realmente un tipo de datos porque
      un número de punto flotante, por ejemplo, también tiene un
      conjunto de características y comportamientos. La diferencia
      está en que el programador define una clase para resolver un
      problema en lugar de estar obligado a usar un tipo de dato
      existente diseñado para representar una unidad de almacenamiento
      en una máquina. Amplía el lenguaje de programación añadiendo
      nuevos tipos de datos específicos según sus necesidades. El
      sistema de programación acoge las nuevas clases y les presta
      toda la atención y comprobación de tipo que da a los tipos
      predefinidos.
    </p><p>
      El enfoque orientado a objetos no está limitado a la
      construcción de simulaciones. Esté o no de acuerdo con que
      cualquier problema es una simulación del sistema que está
      diseñando, el uso de técnicas POO puede reducir fácilmente un
      amplio conjunto de problemas a una solución simple.
    </p><p>
      Una vez establecida una clase, puede hacer tantos objetos de esta
      clase como quiera, y manipularlos como si fueran elementos que
      existen en el problema que está intentando resolver. De hecho, uno
      de los desafíos de la programación orientada a objetos es crear
      una correspondencia unívoca entre los elementos en el espacio del
      problema y objetos en el espacio de la solución.
    </p><p>
      Pero, ¿cómo se consigue que un objeto haga algo útil por usted?
      Debe haber una forma de hacer una petición al objeto para que
      haga algo, como completar una transacción, dibujar algo en la
      pantalla o activar un interruptor. Y cada objeto puede
      satisfacer sólo ciertas peticiones. Las peticiones que puede
      hacer un objeto están definidas por
      su <span class="emphasis"><em>intefaz</em></span>, y es el tipo lo que determina
      la interfaz. Un ejemplo simple puede ser una representación de
      una bombilla:
    </p><div class="figure"><a id="idp3649016"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_03.png" align="middle" alt="Clase Luz" /></div></div><p class="title"><strong>Figura 1.1. Clase <code class="classname">Luz</code></strong></p></div><br class="figure-break" /><pre class="programlisting">
Luz luz1<span class="hl opt">;</span>
luz1<span class="hl opt">.</span><span class="hl kwd">encender</span><span class="hl opt">();</span>
</pre><p>
      La interfaz establece qué peticiones se pueden hacer a un objeto
      particular. Sin embargo, se debe codificar en algún sitio para
      satisfacer esta petición. Ésta, junto con los datos ocultos,
      constituyen la <span class="emphasis"><em>implementación</em></span>. Desde el punto
      de vista de la programación procedural, no es complicado. Un tipo
      tiene una función asociada para cada posible petición, y cuando se
      hace una petición particular a un objeto, se llama a esa
      función. Este proceso normalmente se resume diciendo que ha
      «enviado un mensaje» (ha hecho una petición) a un
      objeto, y el objeto sabe qué hacer con este mensaje (ejecuta
      código).
    </p><p>
      Aquí, el nombre del tipo/clase es <code class="classname">Luz</code>, el
      nombre de este objeto particular de <code class="classname">Luz</code> es
      <code class="varname">luz1</code>, y las peticiones que se le pueden hacer a
      un objeto <code class="classname">Luz</code> son encender, apagar,
      intensificar o atenuar. Puede crear un objeto
      <code class="classname">Luz</code> declarando un nombre
      (<code class="varname">luz1</code>) para ese objeto. Para enviar un mensaje
      al objeto, escriba el nombre del objeto y conéctelo al mensaje de
      petición con un punto. Desde el punto de vista del usuario de una
      clase predefinida, eso es prácticamente todo lo que necesita para
      programar con objetos.
    </p><p>
      El diagrama mostrado arriba sigue el formato del Lenguaje
      Unificado de Modelado (UML). Cada clase se representa con una
      caja, con el nombre del tipo en la parte de arriba, los atributos
      que necesite describir en la parte central de la caja, y los
      <span class="emphasis"><em>métodos</em></span> (las funciones que pertenecen a este
      objeto, que reciben cualquier mensaje que se envíe al objeto) en
      la parte inferior de la caja. A menudo, en los diagramas de diseño
      UML sólo se muestra el nombre de la clase y el nombre de los
      métodos públicos, y por eso la parte central no se muestra. Si
      sólo está interesado en el nombre de la clase, tampoco es
      necesario mostrar la parte inferior.
    </p></div><div class="sect1" title="1.3. La implementación oculta"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3657520"></a>1.3. La implementación oculta</h2></div></div></div><p>
      Es útil distinguir entre los <span class="emphasis"><em>creadores de
      clases</em></span> (aquellos que crean nuevos tipos de datos) y los
      <span class="emphasis"><em>programadores clientes</em></span>
      <sup>[<a id="idp3658552" href="#ftn.idp3658552" class="footnote">14</a>]</sup> (los consumidores de clases que usan los tipos de
      datos en sus aplicaciones). El objetivo del programador cliente es
      acumular una caja de herramientas llena de clases que poder usar
      para un desarrollo rápido de aplicaciones. El objetivo del creador
      de clases es construir una clase que exponga sólo lo necesario
      para el programador cliente y mantenga todo lo demás oculto. ¿Por
      qué?  Porque si está oculto, el programador cliente no puede
      usarlo, lo cual significa que el creador de clases puede cambiar
      la parte oculta sin preocuparse de las consecuencias sobre lo
      demás. La parte oculta suele representar las interioridades
      delicadas de un objeto que podría fácilmente corromperse por un
      programador cliente descuidado o desinformado, así que ocultando
      la implementación se reducen los errores de programación. No se
      debe abusar del concepto de implementación oculta.
    </p><p>
      En cualquier relación es importante poner límites que sean
      respetados por todas las partes involucradas. Cuando se crea una
      librería, se establece una relación con el programador cliente,
      quien también es programador, porque puede estar utilizando la
      librería para crear a su vez una librería mayor.
    </p><p>
      Si todos los miembros de una clase están disponibles para
      cualquiera, entonces el programador cliente puede hacer
      cualquier cosa con la clase y no hay forma de imponer las
      reglas. Incluso si quisiera que el programador cliente no
      manipulase directamente algunos de los miembros de su clase, sin
      control de acceso no hay forma de impedirlo. Nadie está a salvo.
    </p><p>
      Por eso la principal razón del control de acceso es impedir que
      el cliente toque las partes que no debería (partes que son
      necesarias para los mecanismos internos de los tipos de datos),
      pero no la parte de la interfaz que los usuarios necesitan para
      resolver sus problemas particulares. En realidad, ésto es un
      servicio para los usuarios porque pueden ver fácilmente lo qué
      es importante para ellos y qué pueden ignorar.
    </p><p>
      La segunda razón para el control de acceso es permitir al
      diseñador de la librería cambiar la implementación interna de la
      clase sin preocuparse de cómo afectará a los programadores
      clientes. Por ejemplo, podría implementar una clase particular
      de una manera sencilla para un desarrollo fácil, y más tarde
      descubrir que necesita reescribirla para hacerla más rápida. Si
      la interfaz y la implementación están claramente separadas y
      protegidas, puede lograrlo fácilmente y sólo requiere que el
      usuario vuelva a enlazar la aplicación.
    </p><p>
      C++ utiliza tres palabras reservadas explícitas para poner límites
      en una clase: <code class="keyword">public</code>, <code class="keyword">private</code>, y
      <code class="keyword">protected</code>. Su uso y significado son bastante
      sencillos. Estos <span class="emphasis"><em>especificadores de acceso</em></span>
      determinan quién puede usar las definiciones que
      siguen. <code class="keyword">public</code> significa que las definiciones posteriores
      están disponibles para cualquiera. La palabra reservada
      <code class="keyword">private</code>, por otro lado, significa que nadie puede acceder
      a estas definiciones excepto el creador del tipo, es decir, los
      métodos internos de la clase. <code class="keyword">private</code> es una pared entre
      el creador de la clase y el programador cliente. Si alguien
      intenta acceder a un miembro privado, obtendrá un error al
      compilar. <code class="keyword">protected</code> actúa como <code class="keyword">private</code>, con la
      excepción de que las clases derivadas tienen acceso a miembros
      protegidos, pero no a los privados. La herencia se explicará en
      breve.
    </p></div><div class="sect1" title="1.4. Reutilizar la implementación"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3669728"></a>1.4. Reutilizar la implementación</h2></div></div></div><p>
      Una vez que una clase se ha creado y probado, debería constituir
      (idealmente) una unidad útil de código. Sin embargo, esta
      reutilización no es tan fácil de conseguir como muchos
      esperarían; producir un buen diseño requiere experiencia y
      conocimientos. Pero una vez que lo tiene, pide ser
      reutilizado. El código reutilizado es una de las mejores
      ventajas de los lenguajes para programación orientada a objetos.
    </p><p>
      La forma más fácil de reutilizar una clase es precisamente
      utilizar un objeto de esa clase directamente, pero también puede
      colocar un objeto de esta clase dentro de una clase nueva. Podemos
      llamarlo «crear un objeto miembro». Su nueva clase
      puede estar compuesta de varios objetos de cualquier tipo, en
      cualquier combinación que necesite para conseguir la funcionalidad
      deseada en su nueva clase. Como está componiendo una nueva clase a
      partir de clases existentes, este concepto se llama
      <span class="emphasis"><em>composición</em></span> (o de forma más general,
      <span class="emphasis"><em>agregación</em></span>). A menudo nos referimos a la
      composición como una relación «tiene-un», como en
      «un coche tiene-un motor».
    </p><div class="figure"><a id="idp3673464"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_04.png" align="middle" alt="Un coche tiene un motor" /></div></div><p class="title"><strong>Figura 1.2. Un coche tiene un motor</strong></p></div><br class="figure-break" /><p>
      (El diagrama UML anterior indica composición con el rombo relleno,
      lo cual implica que hay un coche. Típicamente usaré una forma más
      simple: sólo una línea, sin el rombo, para indicar una asociación.
      <sup>[<a id="idp3676296" href="#ftn.idp3676296" class="footnote">15</a>]</sup>)
    </p><p>
      La composición es un mecanismo muy flexible. Los objetos miembro
      de su nueva clase normalmente son privados, haciéndolos
      inaccesibles para los programadores clientes que están usando la
      clase. Eso permite cambiar esos miembros sin perturbar al código
      cliente existente. También puede cambiar los miembros del objeto
      en tiempo de ejecución, para cambiar dinámicamente el
      comportamiento de su programa. La herencia, descrita más adelante,
      no tiene esta flexibilidad dado que el compilador debe imponer
      restricciones durante la compilación en clases creadas con
      herencia.
    </p><p>
      Como la herencia es tan importante en la programación orientada
      a objetos, se suele enfatizar mucho su uso, y puede que el
      programador novel tenga la idea de que la herencia se debe usar
      en todas partes. Eso puede dar como resultado diseños torpes y
      demasiado complicados. En lugar de eso, debería considerar
      primero la composición cuando tenga que crear nuevas clases, ya
      que es más simple y flexible. Si acepta este enfoque, sus
      diseños serán más limpios. Una vez que tenga experiencia, los
      casos en los que necesite la herencia resultarán evidentes.
    </p></div><div class="sect1" title="1.5. Herencia: reutilización de interfaces"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3679560"></a>1.5. Herencia: reutilización de interfaces</h2></div></div></div><p>
      En sí misma, la idea de objeto es una herramienta útil. Permite
      empaquetar datos y funcionalidad junto al propio
      concepto<span class="emphasis"><em></em></span>, además puede representar una idea
      apropiada del espacio del problema en vez de estar forzado a usar
      el vocabulario de la máquina subyacente. Esos conceptos se
      expresan como unidades fundamentales en el lenguaje de
      programación mediante la palabra reservada <code class="keyword">class</code>.
    </p><p>
      Sin embargo, es una pena tomarse tantas molestias en crear una
      clase y verse obligado a crear una más para un nuevo tipo que
      tiene una funcionalidad similar. Es más sencillo si se puede usar
      la clase existente, clonarla, y hacerle añadidos y modificaciones
      a ese clon. Esto es justamente lo que hace la
      <span class="emphasis"><em>herencia</em></span>, con la excepción de que si cambia
      la clase original (llamada clase <span class="emphasis"><em>base</em></span>,
      <span class="emphasis"><em>super</em></span> o <span class="emphasis"><em>padre</em></span>), el
      «clon» modificado (llamado clase
      <span class="emphasis"><em>derivada</em></span>, <span class="emphasis"><em>heredada</em></span>,
      <span class="emphasis"><em>sub</em></span> o <span class="emphasis"><em>hija</em></span>) también
      refleja esos cambios.
    </p><div class="figure"><a id="idp3684512"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_05.png" align="middle" alt="subclases" /></div></div><p class="title"><strong>Figura 1.3. subclases</strong></p></div><br class="figure-break" /><p>
      (En el diagrama UML anterior, la flecha apunta desde la clase
      derivada hacia la clase base. Como puede ver, puede haber más de una
      clase derivada.)
    </p><p>
      Un tipo hace algo más que describir las restricciones de un
      conjunto de objetos; también tiene una relación con otros
      tipos. Dos tipos pueden tener características y comportamientos en
      común, pero un tipo puede contener más características que otro y
      también puede manipular más mensajes (o hacerlo de forma
      diferente). La herencia lo expresa de forma similar entre tipos
      usando el concepto de tipos base y tipos derivados. Un tipo base
      contiene todas las características y comportamientos compartidos
      entre los tipos derivados de él. Cree un tipo base para
      representar lo esencial de sus ideas sobre algunos objetos en su
      sistema. A partir del tipo base, derive otros tipos para expresar
      caminos diferentes que puede realizar esa parte común.
    </p><p>
      Por ejemplo, una máquina de reciclado de basura clasifica piezas
      de basura. El tipo base es «basura», y cada pieza de
      basura tiene un peso, un valor, y también, se puede triturar,
      fundir o descomponer. A partir de ahí, se obtienen más tipos
      específicos de basura que pueden tener características adicionales
      (una botella tiene un color) o comportamientos (el aluminio puede
      ser aplastado, el acero puede ser magnético). Además, algunos
      comportamientos pueden ser diferentes (el valor del papel depende
      del tipo y condición). Usando la herencia, se puede construir una
      jerarquía de tipos que exprese el problema que se intenta resolver
      en términos de sus tipos.
    </p><p>
      Un segundo ejemplo es el clásico ejemplo «figura»,
      tal vez usado en un sistema de diseño asistido por computador o
      juegos de simulación. El tipo base es
      <code class="classname">figura</code>, y cada figura tiene un tamaño, un
      color, una posición y así sucesivamente. Cada figura se puede
      dibujar, borrar, mover, colorear, etc. A partir de ahí, los tipos
      específicos de figuras derivan (heredan) de ella: círculo,
      cuadrado, triángulo, y así sucesivamente, cada uno de ellos puede
      tener características y comportamientos adicionales. Ciertas
      figuras pueden ser, por ejemplo, rotadas. Algunos comportamientos
      pueden ser diferentes, como cuando se quiere calcular el área de
      una figura. La jerarquía de tipos expresa las similitudes y las
      diferencias entre las figuras.
    </p><div class="figure"><a id="idp3692152"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_06.png" align="middle" alt="Jerarquía de Figura" /></div></div><p class="title"><strong>Figura 1.4. Jerarquía de <code class="classname">Figura</code></strong></p></div><br class="figure-break" /><p>
      Modelar la solución en los mismos términos que el problema es
      tremendamente beneficioso porque no se necesitan un montón de
      modelos intermedios para transformar una descripción del problema
      en una descripción de la solución. Con objetos, la jerarquía de
      tipos es el principal modelo, lleva directamente desde la
      descripción del sistema en el mundo real a la descripción del
      sistema en código. Efectivamente, una de las dificultades que la
      gente tiene con el diseño orientado a objetos es que es demasiado
      fácil ir desde el principio hasta el final. Una mente entrenada
      para buscar soluciones complejas a menudo se confunde al principio
      a causa de la simplicidad.
    </p><p>
      Cuando se hereda de un tipo existente, se está creando un tipo
      nuevo. Este nuevo tipo contiene no sólo todos los miembros del
      tipo base (aunque los datos privados <code class="keyword">private</code> están
      ocultos e inaccesibles), sino que además, y lo que es más
      importante, duplica la interfaz de la clase base. Es decir,
      todos los mensajes que se pueden enviar a los objetos de la
      clase base se pueden enviar también a los objetos de la clase
      derivada. Dado que se conoce el tipo de una clase por los
      mensajes que se le pueden enviar, eso significa que la clase
      derivada <span class="emphasis"><em>es del mismo tipo que la clase
      base</em></span>. En el ejemplo anterior, «un círculo es
      una figura». Esta equivalencia de tipos vía herencia es
      uno de las claves fundamentales para comprender la programación
      orientada a objetos.
    </p><p>
      Por lo que tanto la clase base como la derivada tienen la misma
      interfaz, debe haber alguna implementación que corresponda a esa
      interfaz. Es decir, debe haber código para ejecutar cuando un
      objeto recibe un mensaje particular. Si simplemente hereda de una
      clase y no hace nada más, los métodos de la interfaz de la clase
      base están disponibles en la clase derivada. Esto significa que
      los objetos de la clase derivada no sólo tienen el mismo tipo,
      también tienen el mismo comportamiento, lo cual no es
      particularmente interesante.
    </p><p>
      Hay dos caminos para diferenciar la nueva clase derivada de la
      clase base original. El primero es bastante sencillo: simplemente
      hay que añadir nuevas funciones a la clase derivada. Estas nuevas
      funciones no son parte de la interfaz de la clase base. Eso
      significa que la clase base simplemente no hace todo lo que
      necesitamos, por lo que se añaden más funciones. Este uso simple y
      primitivo de la herencia es, a veces, la solución perfecta a
      muchos problemas. Sin embargo, quizá debería pensar en la
      posibilidad de que su clase base puede necesitar también funciones
      adicionales. Este proceso de descubrimiento e iteración de su
      diseño ocurre regularmente en la programación orientada a objetos.
    </p><div class="figure"><a id="idp3700864"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_07.png" align="middle" alt="Especialización de Figura" /></div></div><p class="title"><strong>Figura 1.5. Especialización de <code class="classname">Figura</code></strong></p></div><br class="figure-break" /><p>
      Aunque la herencia algunas veces supone que se van a añadir
      nuevas funciones a la interfaz, no es necesariamente cierto. El
      segundo y más importante camino para diferenciar su nueva clase
      es <span class="emphasis"><em>cambiar</em></span> el comportamiento respecto de
      una función de una clase base existente. A esto se le llama
      <span class="emphasis"><em>reescribir</em></span>
      (<span class="foreignphrase"><em class="foreignphrase">override</em></span>) una función.
    </p><div class="figure"><a id="idp3704752"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_08.png" align="middle" alt="Reescritura de métodos" /></div></div><p class="title"><strong>Figura 1.6. Reescritura de métodos</strong></p></div><br class="figure-break" /><p>
      Para reescribir una función, simplemente hay que crear una nueva
      definición para esa función en la clase derivada. Está diciendo,
      «Estoy usando la misma función de interfaz aquí, pero quiero
      hacer algo diferente para mi nuevo tipo».
    </p><div class="sect2" title="1.5.1. Relaciones es-un vs. es-como-un"><div class="titlepage"><div><div><h3 class="title"><a id="idp3708024"></a>1.5.1.  Relaciones es-un vs. es-como-un </h3></div></div></div><p>
	Hay cierta controversia que puede ocurrir con la herencia: ¿la
	herencia debería limitarse a anular <span class="emphasis"><em>sólo</em></span>
	funciones de la clase base (y no añadir nuevos métodos que no
	estén en la clase base)?  Esto puede significar que el tipo
	derivado es <span class="emphasis"><em>exactamente</em></span> el mismo tipo que
	la clase base dado que tiene exactamente la misma interfaz. Como
	resultado, se puede sustituir un objeto de una clase derivada
	por un objeto de la clase base. Se puede pensar como una
	<span class="emphasis"><em>sustitución pura</em></span>, y se suele llamar
	<span class="emphasis"><em>principio de sustitución</em></span>. En cierto modo,
	esta es la forma ideal de tratar la herencia. A menudo nos
	referimos a las relaciones entre la clase base y clases
	derivadas en este caso como una relación es-un, porque se dice
	«un círculo es una figura». Un modo de probar la
	herencia es determinar si se puede considerar la relación es-un
	sobre las clases y si tiene sentido.
    </p><p>
	Hay ocasiones en las que se deben añadir nuevos elementos a la
	interfaz de un tipo derivado, de esta manera se amplía la
	interfaz y se crea un tipo nuevo. El nuevo tipo todavía puede
	ser sustituido por el tipo base, pero la sustitución no es
	perfecta porque sus nuevas funciones no son accesibles desde el
	tipo base. Esta relación se conoce como
	<span class="emphasis"><em>es-como-un</em></span>; el nuevo tipo tiene la interfaz
	del viejo tipo, pero también contiene otras funciones, por lo
	que se puede decir que es exactamente el mismo. Por ejemplo,
	considere un aire acondicionado. Suponga que su casa está
	conectada con todos los controles para refrigerar; es decir,
	tiene una interfaz que le permite controlar la
	temperatura. Imagine que el aire acondicionado se avería y lo
	reemplaza por una bomba de calor, la cual puede dar calor y
	frío. La bomba de calor <span class="emphasis"><em>es-como-un</em></span> aire
	acondicionado, pero puede hacer más cosas. Como el sistema de
	control de su casa está diseñado sólo para controlar el frío,
	está rentringida a comunicarse sólo con la parte de frío del
	nuevo objeto. La interfaz del nuevo objeto se ha extendido, y el
	sistema existente no conoce nada excepto la interfaz original.
    </p><div class="figure"><a id="idp3713752"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_09.png" align="middle" alt="Relaciones" /></div></div><p class="title"><strong>Figura 1.7. Relaciones</strong></p></div><br class="figure-break" /><p>
	Por supuesto, una vez que vea este diseño queda claro que la
	clase base «sistema de frío» no es bastante
	general, y se debería renombrar a «sistema de control de
	temperatura», además también puede incluir calor, en
	este punto se aplica el principio de sustitución. Sin embargo,
	el diagrama de arriba es un ejemplo de lo que puede ocurrir en
	el diseño y en el mundo real.
      </p><p>
	Cuando se ve el principio de sustitución es fácil entender
	cómo este enfoque (sustitución pura) es la única forma de
	hacer las cosas, y de hecho es bueno para que sus diseños
	funcionen de esta forma. Pero verá que hay ocasiones en que
	está igualmente claro que se deben añadir nuevas funciones a
	la interfaz de la clase derivada. Con experiencia, ambos casos
	puede ser razonablemente obvios.
      </p></div></div><div class="sect1" title="1.6. Objetos intercambiables gracias al polimorfismo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3718416"></a>1.6. Objetos intercambiables gracias al polimorfismo</h2></div></div></div><p>
      Cuando se manejan jerarquías de tipos, se suele tratar un objeto
      no como el tipo específico si no como su tipo base. Esto le
      permite escribir código que no depende de los tipos
      específicos. En el ejemplo de la figura, las funciones manipulan
      figuras genéricas sin preocuparse de si son círculos, cuadrados,
      triángulos, etc. Todas las figuras se pueden dibujar, borrar y
      mover, pero estas funciones simplemente envían un mensaje a un
      objeto figura, sin preocuparse de cómo se las arregla el objeto
      con cada mensaje.
    </p><p>
      Semejante código no está afectado por la adición de nuevos
      tipos, y añadir nuevos tipos es la forma más común de extender
      un programa orientado a objetos para tratar nuevas
      situaciones. Por ejemplo, puede derivar un nuevo subtipo de
      figura llamado <code class="classname">pentágono</code> sin modificar
      las funciones que tratan sólo con figuras genéricas. Esta
      habilidad para extender un programa fácilmente derivando nuevos
      subtipos es importante porque mejora enormemente los diseños al
      mismo tiempo que reduce el coste del mantenimiento del software.
    </p><p>
      Hay un problema, no obstante, con intentar tratar un tipo
      derivado como sus tipos base genéricos (círculos como figuras,
      bicicletas como vehículos, cormoranes como pájaros, etc). Si una
      función va a indicar a una figura genérica que se dibuje a sí
      misma, o a un vehículo genérico que se conduzca, o a un pájaro
      genérico que se mueva, el compilador en el momento de la
      compilación no sabe con precisión qué pieza del código será
      ejecutada. Este es el punto clave - cuando el mensaje se envía,
      el programador no <span class="emphasis"><em>quiere</em></span> saber qué pieza de
      código será ejecutada; la función <code class="function">dibujar()</code>
      se puede aplicar a un círculo, un cuadrado, o un triángulo, y el
      objeto ejecutará el código correcto dependiendo de tipo
      específico. Si no sabe qué pieza del código se ejecuta, ¿qué
      hace? Por ejemplo, en el siguiente diagrama el objeto
      <code class="classname">ControladorDePájaro</code> trabaja con los
      objetos genéricos <code class="classname">Pájaro</code>, y no sabe de qué
      tipo son exactamente. Esto es conveniente desde la perspectiva
      del <code class="classname">ControladorDePájaro</code>, porque no hay
      que escribir código especial para determinar el tipo exacto de
      <code class="classname">Pájaro</code> con el que está trabajando, o el
      comportamiento del <code class="classname">Pájaro</code>. Entonces, ¿qué
      hace que cuando se invoca <code class="methodname">mover()</code>
      ignorando el tipo específico de <code class="classname">Pájaro</code>,
      puede ocurrir el comportamiento correcto (un
      <code class="classname">Ganso</code> corre, vuela, o nada, y un
      <code class="classname">Pingüino</code> corre o nada)?
    </p><div class="figure"><a id="idp3726184"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_10.png" align="middle" alt="Polimorfismo" /></div></div><p class="title"><strong>Figura 1.8. Polimorfismo</strong></p></div><br class="figure-break" /><p>
      La respuesta es el primer giro en programación orientada a
      objetos: el compilador no hace una llamada a la función en el
      sentido tradicional. La llamada a función generada por un
      compilador no-OO provoca lo que se llama una <span class="emphasis"><em>ligadura
      temprana</em></span> (<span class="foreignphrase"><em class="foreignphrase">early binding</em></span>),
      un término que quizá no haya oído antes porque nunca ha pensado en
      que hubiera ninguna otra forma. Significa que el compilador genera una
      llamada al nombre de la función específica, y el enlazador
      resuelve esta llamada con la dirección absoluta del código que se
      ejecutará. En POO, el programa no puede determinar la dirección
      del código hasta el momento de la ejecución, de modo que se
      necesita algún otro esquema cuando se envía un mensaje a un objeto
      genérico.
    </p><p>
      Para resolver el problema, los lenguajes orientados a objetos
      usan el concepto de <span class="emphasis"><em>ligadura tardía</em></span>
      (<span class="foreignphrase"><em class="foreignphrase">late binding</em></span>). Cuando envía un
      mensaje a un objeto, el código invocado no está determinado
      hasta el momento de la ejecución. El compilador se asegura de
      que la función existe y realiza una comprobación de tipo de los
      argumentos y el valor de retorno (el lenguaje que no realiza
      esta comprobación se dice que es <span class="emphasis"><em>débilmente
      tipado</em></span>), pero no sabe el código exacto a ejecutar.
    </p><p>
      Para llevar a cabo la ligadura tardía, el compilador de C++
      inserta un trozo especial de código en lugar de la llamada
      absoluta. Este código calcula la dirección del cuerpo de la
      función, usando información almacenada en el objeto (este proceso
      se trata con detalle en el <a class="link" href="#C15" title="15: Polimorfismo y Funciones virtuales">Capítulo
      15</a>). De este modo, cualquier objeto se puede comportar de
      forma diferente de acuerdo con el contenido de este trozo especial
      de código. Cuando envía un mensaje a un objeto, el objeto
      comprende realmente qué hacer con el mensaje.
    </p><p>
      Es posible disponer de una función que tenga la flexibilidad de
      las propiedades de la ligadura tardía usando la palabra reservada
      <code class="keyword">virtual</code>. No necesita entender el mecanismo de
      <code class="keyword">virtual</code> para usarla, pero sin ella no puede hacer
      programación orientada a objetos en C++. En C++, debe recordar
      añadir la palabra reservada <code class="keyword">virtual</code> porque, por defecto,
      los métodos <span class="emphasis"><em>no</em></span> se enlazan dinámicamente. Los
      métodos virtuales le permiten expresar las diferencias de
      comportamiento en clases de la misma familia. Estas diferencias
      son las que causan comportamientos polimórficos.
    </p><p>
      Considere el ejemplo de la figura. El diagrama de la familia de
      clases (todas basadas en la misma interfaz uniforme) apareció
      antes en este capítulo. Para demostrar el polimorfismo, queremos
      escribir una única pieza de código que ignore los detalles
      específicos de tipo y hable sólo con la clase base. Este código
      está <span class="emphasis"><em>desacoplado</em></span> de la información del tipo
      específico, y de esa manera es más simple de escribir y más fácil
      de entender. Y, si tiene un nuevo tipo - un
      <code class="classname">Hexágono</code>, por ejemplo - se añade a través
      de la herencia, el código que escriba funcionará igual de bien
      para el nuevo tipo de <code class="classname">Figura</code> como para los
      tipos anteriores. De esta manera, el programa es
      <span class="emphasis"><em>extensible</em></span>.
    </p><p>
      Si escribe una función C++ (podrá aprender dentro de poco cómo hacerlo):
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">hacerTarea</span><span class="hl opt">(</span>Figura<span class="hl opt">&amp;</span> f<span class="hl opt">) {</span>
    f<span class="hl opt">.</span><span class="hl kwd">borrar</span><span class="hl opt">();</span>
    <span class="hl slc">// ...</span>
    f<span class="hl opt">.</span><span class="hl kwd">dibujar</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
</pre><p>
      Esta función se puede aplicar a cualquier
      <code class="classname">Figura</code>, de modo que es independiente del
      tipo específico del objeto que se dibuja y borra (el
      «&amp;» significa «toma la dirección del
      objeto que se pasa a <code class="function">hacerTarea()</code>»,
      pero no es importante que entienda los detalles ahora). Si en
      alguna otra parte del programa usamos la función
      <code class="function">hacerTarea()</code>:
    </p><pre class="programlisting">
Circulo c<span class="hl opt">;</span>
Triangulo t<span class="hl opt">;</span>
Linea l<span class="hl opt">;</span>
<span class="hl kwd">hacerTarea</span><span class="hl opt">(</span>c<span class="hl opt">);</span>
<span class="hl kwd">hacerTarea</span><span class="hl opt">(</span>t<span class="hl opt">);</span>
<span class="hl kwd">hacerTarea</span><span class="hl opt">(</span>l<span class="hl opt">);</span>
</pre><p>
      Las llamadas a <code class="function">hacerTarea()</code> funcionan bien
      automáticamente, a pesar del tipo concreto del objeto.
    </p><p>
      En efecto es un truco bonito y asombroso. Considere la línea:
    </p><pre class="programlisting">
<span class="hl kwd">hacerTarea</span><span class="hl opt">(</span>c<span class="hl opt">);</span>
</pre><p>
      Lo que está ocurriendo aquí es que está pasando un
      <code class="classname">Círculo</code> a una función que espera una
      <code class="classname">Figura</code>. Como un
      <code class="classname">Círculo</code> es una
      <code class="classname">Figura</code> se puede tratar como tal por parte
      de <code class="function">hacerTarea()</code>. Es decir, cualquier
      mensaje que pueda enviar <code class="function">hacerTarea()</code> a una
      <code class="classname">Figura</code>, un <code class="classname">Círculo</code>
      puede aceptarlo. Por eso, es algo completamente lógico y seguro.
    </p><p>
      A este proceso de tratar un tipo derivado como si fuera su tipo
      base se le llama <span class="emphasis"><em>upcasting</em></span>
      (<span class="emphasis"><em>moldeado hacia arriba</em></span><sup>[<a id="idp3746744" href="#ftn.idp3746744" class="footnote">16</a>]</sup>).  El nombre <span class="emphasis"><em>cast</em></span> (molde) se usa
      en el sentido de adaptar a un molde y es <span class="emphasis"><em>hacia
      arriba</em></span> por la forma en que se dibujan los diagramas de
      clases para indicar la herencia, con el tipo base en la parte
      superior y las clases derivadas colgando debajo. De esta manera,
      moldear un tipo base es moverse hacia arriba por el diagrama de
      herencias: «upcasting»
    </p><div class="figure"><a id="idp3748416"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_11.png" align="middle" alt="Upcasting" /></div></div><p class="title"><strong>Figura 1.9. Upcasting</strong></p></div><br class="figure-break" /><p>
      Todo programa orientado a objetos tiene algún upcasting en alguna
      parte, porque así es como se despreocupa de tener que conocer  el tipo
      exacto con el que está trabajando. Mire el código de
      <code class="function">hacerTarea()</code>:
    </p><pre class="programlisting">
f<span class="hl opt">.</span><span class="hl kwd">borrar</span><span class="hl opt">();</span>
<span class="hl slc">// ...</span>
f<span class="hl opt">.</span><span class="hl kwd">dibujar</span><span class="hl opt">();</span>
</pre><p>
      Observe que no dice «Si es un
      <code class="classname">Círculo</code>, haz esto, si es un
      <code class="classname">Cuadrado</code>, haz esto otro, etc.». Si
      escribe un tipo de código que comprueba todos los posibles tipos
      que una <code class="classname">Figura</code> puede tener realmente,
      resultará sucio y tendrá que cambiarlo cada vez que añada un nuevo
      tipo de <code class="classname">Figura</code>. Aquí, sólo dice «Eres
      una figura, sé que te puedes <code class="function">borrar()</code> y
      <code class="function">dibujar()</code> a ti misma, hazlo, y preocúpate de
      los detalles».
    </p><p>
      Lo impresionante del código en <code class="function">hacerTarea()</code>
      es que, de alguna manera, funciona bien. Llamar a
      <code class="function">dibujar()</code> para un
      <code class="classname">Círculo</code> ejecuta diferente código que
      cuando llama a <code class="function">dibujar()</code> para un
      <code class="classname">Cuadrado</code> o una
      <code class="classname">Línea</code>, pero cuando se envía el mensaje
      <code class="function">dibujar()</code> a un
      <code class="classname">Figura</code> anónima, la conducta correcta
      sucede en base en el tipo real de
      <code class="classname">Figura</code>. Esto es asombroso porque, como se
      mencionó anteriormente, cuando el compilador C++ está compilando
      el código para <code class="function">hacerTarea()</code>, no sabe
      exactamente qué tipos está manipulando.

      Por eso normalmente, es de esperar que acabe invocando la versión
      de <code class="function">borrar()</code> y <code class="function">dibujar()</code>
      para <code class="classname">Figura</code>, y no para el
      <code class="classname">Círculo</code>, <code class="classname">Cuadrado</code>, o
      <code class="classname">Línea</code> específico. Y aún así ocurre del modo
      correcto a causa del polimorfismo. El compilador y el sistema se
      encargan de los detalles; todo lo que necesita saber es que esto
      ocurre y lo que es más importante, cómo utilizarlo en sus
      diseños. Si un método es <code class="keyword">virtual</code>, entonces cuando envíe
      el mensaje a un objeto, el objeto hará lo correcto, incluso cuando
      esté involucrado el upcasting.
    </p></div><div class="sect1" title="1.7. Creación y destrucción de objetos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3761184"></a>1.7. Creación y destrucción de objetos</h2></div></div></div><p>
      Técnicamente, el dominio de la POO son los tipos abstractos de
      datos, la herencia y el polimorfismo, pero otros asuntos pueden ser
      al menos igual de importantes. Esta sección ofrece una visión
      general de esos asuntos.
    </p><p>
      Es especialmente importante la forma en que se crean y se
      destruyen los objetos. ¿Dónde está el dato para un objeto y cómo
      se controla la vida de este objeto? Diferentes lenguajes de
      programación usan distintas filosofías al respecto. C++ adopta
      el enfoque de que el control de eficiencia es la cuestión más
      importante, pero eso delega la elección al programador. Para una
      velocidad máxima de ejecución, el almacenamiento y la vida se
      determinan mientras el programa se escribe, colocando los
      objetos en la pila o en almacenamiento estático. La pila es un
      área de memoria usada directamente por el microprocesador para
      almacenar datos durante la ejecución del programa. A veces las
      variables de la pila se llaman variables
      <span class="emphasis"><em>automáticas</em></span> o <span class="emphasis"><em>de
      ámbito</em></span> (<span class="foreignphrase"><em class="foreignphrase">scoped</em></span>). El
      área de almacenamiento estático es simplemente un parche fijo de
      memoria alojado antes de que el programa empiece a
      ejecutarse. Usar la pila o el área de almacenamiento estático
      fija una prioridad en la rapidez de asignación y liberación de
      memoria, que puede ser valioso en algunas situaciones. Sin
      embargo, se sacrifica flexibilidad porque se debe conocer la
      cantidad exacta, vida, y tipo de objetos
      <span class="emphasis"><em>mientras</em></span> el programador escribe el
      programa. Si está intentando resolver un problema más general,
      como un diseño asistido por computadora, gestión de almacén, o
      control de tráfico aéreo, eso también es restrictivo.
    </p><p>
      El segundo enfoque es crear objetos dinámicamente en un espacio de
      memoria llamado
      <span class="emphasis"><em>montículo</em></span> (<span class="foreignphrase"><em class="foreignphrase">heap</em></span>). En
      este enfoque no se sabe hasta el momento de la ejecución cuántos
      objetos se necesitan, cuál será su ciclo de vida, o su tipo
      exacto. Estas decisiones se toman de improviso mientras el
      programa está en ejecución. Si necesita un nuevo objeto,
      simplemente creelo en el montículo cuando lo necesite, usando la
      palabra reservada <code class="keyword">new</code>. Cuando ya no necesite ese espacio
      de almacenamiento, debe liberarlo usando la palabra reservada
      <code class="keyword">delete</code>.
    </p><p>
      Como la memoria se administra dinámicamente en tiempo de
      ejecución, la cantidad de tiempo requerido para reservar espacio
      en el montículo es considerablemente mayor que el tiempo para
      manipular la pila (reservar espacio en la pila a menudo es una
      única instrucción del microprocesador para mover el puntero de la
      pila hacia abajo, y otro para moverlo de nuevo hacia arriba). El
      enfoque dinámico asume que los objetos tienden a ser complicados,
      por eso la sobrecarga extra de encontrar espacio para alojarlos y
      después liberarlos, no tiene un impacto importante en la creación
      de un objeto. Además, el aumento de flexibilidad es esencial para
      resolver problemas generales de programación.
    </p><p>
      Hay otra cuestión, sin embargo, y es el tiempo de vida de un
      objeto. Si crea un objeto en la pila o en espacio estático, el
      compilador determina cuánto tiempo dura el objeto y puede
      destruirlo automáticamente. Pero si lo crea en el montículo, el
      compilador no tiene conocimiento de su tiempo de vida. En C++, el
      programador debe determinar programáticamente cuándo destruir el
      objeto, y entonces llevar a cabo la destrucción usando la palabra
      reservada <code class="keyword">delete</code>. Como alternativa, el entorno puede
      proporcionar una característica llamada <span class="emphasis"><em>recolector de
      basura</em></span> (<span class="foreignphrase"><em class="foreignphrase">garbage
      collector</em></span>) que automáticamente descubre qué
      objetos ya no se usan y los destruye. Naturalmente, escribir
      programas usando un recolector de basura es mucho más conveniente,
      pero requiere que todas las aplicaciones sean capaces de tolerar
      la existencia del recolector de basura y la sobrecarga que
      supone. Eso no encaja en los requisitos del diseño del lenguaje
      C++ por lo que no se incluye, aunque existen recolectores de
      basura para C++, creados por terceros.
    </p></div><div class="sect1" title="1.8. Gestión de excepciones: tratamiento de errores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3773112"></a>1.8. Gestión de excepciones: tratamiento de errores</h2></div></div></div><p>
      Desde los inicios de los lenguajes de programación, la gestión de
      errores ha sido uno de los asuntos más difíciles. Es tan
      complicado diseñar un buen esquema de gestión de errores, que
      muchos lenguajes simplemente lo ignoran, delegando el problema en
      los diseñadores de la librería, que lo resuelven a medias, de
      forma que puede funcionar en muchas situaciones, pero se pueden
      eludir, normalmente ignorándolos. El problema más importante de la
      mayoría de los esquemas de gestión de errores es que dependen de
      que el programador se preocupe en seguir un convenio que no está
      forzado por el lenguaje. Si los programadores no se preocupan,
      cosa que ocurre cuando se tiene prisa, esos esquemas se olvidan
      fácilmente.
    </p><p>
      <span class="emphasis"><em>La gestión de excepciones</em></span>
      «conecta» la gestión de errores directamente en el
      lenguaje de programación y a veces incluso en el sistema
      operativo. Una excepción es un objeto que se «lanza»
      desde el lugar del error y puede ser «capturado» por
      un <span class="emphasis"><em>manejador de excepción</em></span> apropiado diseñado
      para manipular este tipo particular de error. Es como si la
      gestión de errores fuera una ruta de ejecución diferente y
      paralela que se puede tomar cuando las cosas van mal. Y como usa
      un camino separado de ejecución, no necesita interferir con el
      código ejecutado normalmente. Eso hace que el código sea más
      simple de escribir ya que no se fuerza al programador a comprobar
      los errores constantemente. Además, una excepción no es lo mismo
      que un valor de error devuelto por una función o una bandera
      fijada por una función para indicar una condición de error, que se
      puede ignorar. Una excepción no se puede ignorar, de modo que está
      garantizado que habrá que tratarla en algún momento. Finalmente,
      las excepciones proporcionan una forma para recuperar una
      situación consistente. En lugar de salir simplemente del programa,
      a menudo es posible arreglar las cosas y restaurar la ejecución,
      lo que produce sistemas más robustos.
    </p><p>
      Merece la pena tener en cuenta que la gestión de excepciones no es
      una característica orientada a objetos, aunque en lenguajes
      orientados a objetos las excepciones normalmente se representan
      con objetos. La gestión de excepciones existía antes que los
      lenguajes orientados a objetos.
    </p><p>
      En este Volumen se usa y explica la gestión de excepciones sólo por
      encima; el Volúmen 2 (disponible en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>) cubre
      con más detalle la gestión de excepciones.
    </p></div><div class="sect1" title="1.9. Análisis y diseño"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3780784"></a>1.9. Análisis y diseño</h2></div></div></div><p>
      El paradigma orientado a objetos es una nueva forma de pensar
      sobre programación y mucha gente tiene problemas la primera vez
      que escucha cómo se aborda un proyecto POO. Una vez que se sabe
      que, supuestamente, todo es un objeto, y cómo aprender a pensar
      al estilo orientado a objetos, puede empezar a crear
      «buenos» diseños que aprovechen las ventajas de
      todos los beneficios que ofrece la POO.
    </p><p>
      Un <span class="emphasis"><em>método</em></span> (llamado a menudo
      <span class="emphasis"><em>metodología</em></span>) es un conjunto de procesos y
      heurísticas usados para tratar la complejidad de un problema de
      programación. Desde el comienzo de la programación orientada a
      objetos se han formulado muchos métodos. Esta sección le dará una
      idea de cuál es el objetivo que se intenta conseguir cuando se usa
      una metodología.
    </p><p>
      Especialmente en POO, la metodología es un campo de muchos
      experimentos, así que antes de elegir un método, es importante que
      comprenda cuál es el problema que resuelve. Eso es particularmente
      cierto con C++, en el que el lenguaje de programación pretende
      reducir la complejidad (comparado con C) que implica expresar un
      programa. De hecho, puede aliviar la necesidad de metodologías aún
      más complejas. En cambio, otras más simples podrían ser
      suficientes en C++ para muchos tipos de problemas grandes que
      podría manejar usando metodologías simples con lenguajes
      procedurales.
    </p><p>
      También es importante darse cuenta de que el término
      «metodología» a menudo es demasiado grande y
      prometedor. A partir de ahora, cuando diseñe y escriba un programa
      estará usando una metodología. Puede ser su propia metodología, y
      puede no ser consciente, pero es un proceso por el que pasa cuando
      crea un programa. Si es un proceso efectivo, puede que sólo necesite un
      pequeño ajuste para que funcione con C++. Si no está satisfecho
      con su productividad y con el camino que sus programas han tomado,
      puede considerar adoptar un método formal, o elegir trozos de
      entre muchos métodos formales.
    </p><p>
      Mientras pasa por el proceso de desarrollo, el uso más importante
      es éste: no perderse. Eso es fácil de hacer. La mayoría de los
      análisis y métodos de diseño pretenden resolver los problemas más
      grandes. Recuerde que la mayoría de los proyectos no encajan en
      esta categoría, normalmente puede tener un análisis y diseño
      exitoso con un subconjunto relativamente pequeño de lo que
      recomienda el método <sup>[<a id="idp3786776" href="#ftn.idp3786776" class="footnote">17</a>]</sup>
      . Pero muchos tipos de procesos, sin importar lo
      limitados que sean, generalmente le ofrecerán un camino mucho
      mejor que simplemente empezar a codificar.
    </p><p>
      También es fácil quedarse estancado, caer en
      <span class="emphasis"><em>análisis-parálisis</em></span>, donde sentirá que no
      puede avanzar porque en la plataforma que está usando no está
      especificado cada pequeño detalle. Recuerde, no importa cuánto
      análisis haga, hay algunas cosas sobre el sistema que no se
      revelan hasta el momento del diseño, y más cosas que no se
      revelarán hasta que esté codificando, o incluso hasta que el
      programa esté funcionando. Por eso, es crucial moverse bastante
      rápido durante del análisis y diseño, e implementar un test del
      sistema propuesto.
    </p><p>
      Este punto merece la pena enfatizarlo. Debido a nuestra
      experiencia con los lenguajes procedurales, es encomiable que un
      equipo quiera proceder con cuidado y entender cada pequeño detalle
      antes de pasar al diseño y a la implementación. Desde luego,
      cuando crea un SGBD (Sistema Gestor de Bases de Datos), conviene
      entender la necesidad de un cliente a fondo. Pero un SGBD está en
      una clase de problemas que son muy concretos y bien entendidos; en
      muchos programas semejantes, la estructura de la base de datos
      <span class="emphasis"><em>es</em></span> el problema que debe afrontarse. El tipo
      de problema de programación tratado en este capítulo es de la
      variedad «comodín» (con mis palabras), en el que la
      solución no es simplemente adaptar una solución bien conocida,
      en cambio involucra uno o más «factores
      comodín» -elementos para los que no hay solución previa
      bien entendida, y para los que es necesario investigar
      <sup>[<a id="idp3792104" href="#ftn.idp3792104" class="footnote">18</a>]</sup>
      . Intentar analizar minuciosamente un problema comodín
      antes de pasar al diseño y la implementación provoca un
      análisis-parálisis porque no se tiene suficiente información
      para resolver este tipo de problema durante la fase de
      análisis. Resolver estos problemas requiere interacción a través
      del ciclo completo, y eso requiere comportamientos arriesgados (lo
      cual tiene sentido, porque está intentando hacer algo nuevo y los
      beneficios potenciales son mayores). Puede parecer que el riesgo
      está compuesto por «prisas» en una implementación
      preliminar, pero en cambio puede reducir el riesgo en un proyecto
      comodín porque está descubriendo pronto si es viable un enfoque
      particular para el problema. El desarrollo del producto es gestión
      de riesgos.
    </p><p>
      A menudo se propone que «construya uno desechable».
      Con la POO, todavía debe andar <span class="emphasis"><em>parte</em></span> de
      este camino, pero debido a que el código está encapsulado en
      clases, durante la primera iteración inevitablemente producirá
      algunos diseños de clases útiles y desarrollará algunas ideas
      válidas sobre el diseño del sistema que no necesariamente son
      desechables. De esta manera, la primera pasada rápida al
      problema no produce sólo información crítica para la siguiente
      iteración de análisis, diseño, e implementación, sino que además
      crea el código base para esa iteración.
    </p><p>
      Es decir, si está buscando una metodología que contenga detalles
      tremendos y sugiera muchos pasos y documentos, es aún más difícil
      saber cuándo parar. Tenga presente lo que está intentando
      encontrar:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	 ¿Cuáles son los objetos? (¿Cómo divide su proyecto en sus
	 partes componentes?)
	</p></li><li class="listitem"><p>
	 ¿Cuáles son sus interfaces? (¿Qué mensajes necesita enviar a
	 otros objetos?)
	</p></li></ol></div><p>
      Si sólo cuenta con los objetos y sus interfaces, entonces puede
      escribir un programa. Por varias razones podría necesitar más
      descripciones y documentos, pero no puede hacerlo con menos.
    </p><p>
      El proceso se puede realizar en cinco fases, y una fase 0 que es
      simplemente el compromiso inicial de usar algún tipo de
      estructura.
    </p><div class="sect2" title="1.9.1. Fase 0: Hacer un plan"><div class="titlepage"><div><div><h3 class="title"><a id="idp3799296"></a>1.9.1.  Fase 0: Hacer un plan </h3></div></div></div><p>
	Primero debe decidir qué pasos va a dar en su proceso. Parece
	fácil (de hecho, todo esto parece fácil) y sin embargo la gente
	a menudo no toma esta decisión antes de ponerse a programar. Si
	su plan es «ponerse directamente a programar», de
	acuerdo (a veces es adecuado cuando es un problema bien
	conocido). Al menos estará de acuerdo en que eso es el plan.
      </p><p>
	También debe decidir en esta fase si necesita alguna estructura
	de proceso adicional, pero no las nueve yardas
	completas. Bastante comprensible, algunos programadores
	prefieren trabajar en «modo vacaciones» en cuyo
	caso no se impone ninguna estructura en el proceso de desarrollo
	de su trabajo; «Se hará cuando se haga». Eso puede
	resultar atractivo durante un tiempo, pero se ha descubierto que
	tener unos pocos hitos a lo largo del camino ayuda a enfocar e
	impulsar sus esfuerzos en torno a esos hitos en lugar de empezar
	a atascarse con el único objetivo de «finalizar el
	proyecto». Además, divide el proyecto en piezas más
	pequeñas y hace que dé menos miedo (y además los hitos ofrecen
	más oportunidades para celebraciones).
      </p><p>
	Cuando empecé a estudiar la estructura de la historia (por eso
	algún día escribiré una novela) inicialmente me resistía a la
	idea de una estructura, sentía que cuando escribía simplemente
	permitía que fluyera en la página. Pero más tarde me di cuenta
	de que cuando escribo sobre computadoras la estructura es
	bastante clara, pero no pienso mucho sobre ello. Pero aún así
	estructuro mi trabajo, aunque sólo semi-inconscientemente en mi
	cabeza. Si aún piensa que su plan es sólo ponerse a codificar,
	de algún modo, usted pasará por las posteriores fases mientras
	pregunta y responde ciertas cuestiones.
      </p><div class="sect3" title="Declaración de objetivos"><div class="titlepage"><div><div><h4 class="title"><a id="idp3804400"></a>Declaración de objetivos</h4></div></div></div><p>
	  Cualquier sistema construido, no importa cuan complicado
	  sea, tiene un propósito fundamental, el negocio que hay en
	  él, la necesidad básica que satisface. Si puede ver la
	  interfaz de usuario, el hardware o los detalles específicos
	  del sistema, los algoritmos de codificación y los problemas
	  de eficiencia, finalmente encontrará el núcleo de su
	  existencia, simple y sencillo. Como el así llamado
	  <span class="emphasis"><em>concepto de alto nivel</em></span> de una película
	  de Hollywood, puede describirlo en una o dos frases. Esta
	  descripción pura es el punto de partida.
	</p><p>
	  El concepto de alto nivel es bastante importante porque le da
	  el tono a su proyecto; es una declaración de principios. No
	  tiene porqué conseguirlo necesariamente la primera vez (podría
	  tener que llegar a una fase posterior del proyecto antes de
	  tenerlo completamente claro), pero siga intentándolo hasta que
	  lo consiga. Por ejemplo, en un sistema de control de tráfico
	  aéreo puede empezar con un concepto de alto nivel centrado en
	  el sistema que está construyendo: «El programa de la
	  torre sigue la pista a los aviones». Pero considere qué
	  ocurre cuando adapta el sistema para un pequeño aeropuerto;
	  quizá sólo haya un controlador humano o ninguno. Un modelo más
	  útil no se preocupará de la solución que está creando tanto
	  como la descripción del problema: «Llega un avión,
	  descarga, se revisa y recarga, y se marcha».
	</p></div></div><div class="sect2" title="1.9.2. Fase 1: ¿Qué estamos haciendo?"><div class="titlepage"><div><div><h3 class="title"><a id="idp3808448"></a>1.9.2.  Fase 1: ¿Qué estamos haciendo? </h3></div></div></div><p>
	En la generación previa de diseño de programas (llamado
	<span class="emphasis"><em>diseño procedural</em></span>), esto se llamaba
	«crear el <span class="emphasis"><em>análisis de requisitos</em></span> y
	<span class="emphasis"><em>especificación del sistema</em></span>». Éstos,
	por supuesto, eran lugares donde perderse; documentos con
	nombres intimidantes que podrían llegar a ser grandes proyectos
	en sí mismos. Sin embargo, su intención era buena. El análisis
	de requisitos dice: «Haga una lista de las directrices que
	usará para saber cuándo ha hecho su trabajo y el cliente estará
	satisfecho». La especificación del sistema dice:
	«Hay una descripción de <span class="emphasis"><em>lo que</em></span> hará
	el programa (no <span class="emphasis"><em>cómo</em></span>) por satisfacer los
	requisitos». El análisis de requisitos es realmente un
	contrato entre usted y el cliente (incluso si el cliente trabaja
	dentro de su compañía o es algún otro objeto o sistema). Las
	especificaciones del sistema son una exploración de alto nivel
	del problema y en algún sentido un descubrimiento de si se puede
	hacer y cuánto se tardará. Dado que ambos requerirán consenso
	entre la gente (y porque suelen cambiar todo el tiempo), creo
	que es mejor mantenerlos todo lo escueto posible -en el mejor
	de los casos, listas y diagramas básicos- para ahorrar
	tiempo. Podría tener otras restricciones que le exijan ampliarla
	en documentos más grandes, pero manteniendo el documento inicial
	pequeño y conciso, puede crearse en algunas sesiones de
	tormentas de ideas de grupo con un líder que cree la descripción
	dinámicamente. Esto no sólo solicita participación de todos,
	también fomenta aprobación inicial y llegar a acuerdos entre
	todos. Quizá lo más importante sea empezar el proyecto con
	mucho entusiasmo.
      </p><p>
	Es necesario no perder de vista lo que está intentando conseguir
	en esta fase: determinar el sistema que se supone que quiere
	hacer. La herramienta más valiosa para eso es una colección de
	los llamados «casos de uso». Los casos de uso
	identifican características clave en el sistema que pueden
	revelar algunas de las clases fundamentales que se usarán. En
	esencia son respuestas descriptivas a preguntas como:
	<sup>[<a id="idp3814744" href="#ftn.idp3814744" class="footnote">19</a>]</sup>:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    «¿Quién usará el sistema?»
	  </p></li><li class="listitem"><p>
	    «¿Qué pueden hacer estos actores con el sistema?»
	  </p></li><li class="listitem"><p>
	    «¿Cómo puede este actor hacer eso con este sistema?»
	  </p></li><li class="listitem"><p>
	    «¿Cómo podría alguien más hacer este trabajo si
	    alguien más estuviera haciéndolo, o si el mismo actor
	    tuviera un objetivo diferente?» (para revelar
	    variaciones).
	  </p></li><li class="listitem"><p>
	    «¿Qué problemas podrían ocurrir mientras hace esto
	    con el sistema?» (para revelar excepciones).
	  </p></li></ol></div><p>
	Si está diseñando un cajero automático, por ejemplo, el caso
	de uso para un aspecto particular de la funcionalidad del
	sistema es poder describir qué hace el contestador automático
	en todas las situaciones posibles. Cada una de esas
	«situaciones» se denomina
	<span class="emphasis"><em>escenario</em></span>, y se puede considerar que un
	caso de uso es una colección de escenarios. Puede pensar en un
	escenario como una pregunta que comienza con: «¿Qué hace
	el sistema si...?» Por ejemplo, «¿Qué hace el
	cajero automático si un cliente ingresa un cheque dentro de
	las 24 horas y no hay suficiente en la cuenta para
	proporcionar la nota para satisfacer el cargo?»
      </p><p>
	Los diagramas de caso de uso son intencionadamente simples para impedir que se
	atasque con los detalles de implementación del sistema demasiado pronto:
      </p><div class="figure"><a id="idp3821896"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_12.png" align="middle" alt="Diagramas de casos de uso" /></div></div><p class="title"><strong>Figura 1.10. Diagramas de casos de uso</strong></p></div><br class="figure-break" /><p>
	Cada monigote representa un «actor», que
	típicamente es un humano o algún otro tipo de agente
	libre. (Incluso puede ser otro sistema de computación, como es
	el caso del «ATM»). La caja representa el límite
	del sistema. Las elipses representan los casos de uso, los
	cuales son descripciones de trabajo válido que se puede llevar a
	cabo con el sistema. Las líneas entre los actores y los casos de
	uso representan las interacciones.
      </p><p>
	No importa cómo está implementado realmente el sistema, mientras
	se lo parezca al usuario.
      </p><p>
	Un caso de uso no necesita ser terriblemente complejo, incluso
	si el sistema subyacente es complejo. Lo único que se persigue
	es mostrar el sistema tal como aparece ante el usuario. Por
	ejemplo:
      </p><div class="figure"><a id="idp3826784"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_13.png" align="middle" alt="Un ejemplo de caso de uso" /></div></div><p class="title"><strong>Figura 1.11. Un ejemplo de caso de uso</strong></p></div><br class="figure-break" /><p>
	Los casos de uso producen las especificaciones de requisitos
	determinando todas las interacciones que el usuario puede tener
	con el sistema. Intente descubrir una serie completa de casos de
	uso para su sistema, y una vez que lo haya hecho tendrá lo
	esencial sobre lo que se supone que hace su sistema. Lo bueno de
	centrarse en casos de uso es que siempre le lleva de vuelta a lo
	esencial y le mantiene alejado de los asuntos no críticos para
	conseguir terminar el trabajo. Es decir, si tiene una serie
	completa de casos de uso puede describir su sistema y pasar a la
	siguiente fase. Probablemente no lo hará todo perfectamente en
	el primer intento, pero no pasa nada. Todo le será revelado en su
	momento, y si pide una especificación del sistema perfecta en
	este punto se atascará.
      </p><p>
	Si se ha atascado, puede reactivar esta fase usando una
	herramienta tosca de aproximación: describir el sistema en pocos
	párrafos y después buscar sustantivos y verbos. Los nombres
	pueden sugerir actores, contexto del caso de uso
	(ej. «lobby»), o artefactos manipulados en el caso
	de uso. Los verbos pueden sugerir interacción entre actores y
	casos de uso, y pasos específicos dentro del caso de uso. Además
	descubrirá que nombres y verbos producen objetos y mensajes
	durante la fase de diseño (y observe que los casos de uso
	describen interacciones entre subsistemas, así que la técnica
	«nombre y verbo» sólo se puede usar como una
	herramienta de lluvia de ideas puesto que no genera casos de uso)
	<sup>[<a id="idp3832320" href="#ftn.idp3832320" class="footnote">20</a>]</sup>.
      </p><p>
	El límite entre un caso de uso y un actor puede mostrar la
	existencia de una interfaz de usuario, pero no la define. Si le
	interesa el proceso de definición y creación de interfaces de
	usuario, vea <em class="citetitle">Software for Use</em> de
	<span class="personname"><span class="firstname">Larry</span> <span class="surname">Constantine</span></span> y
	<span class="personname"><span class="firstname">Lucy</span> <span class="surname">Lockwood</span></span>, (Addison Wesley
	Longman, 1999) o vaya a <a class="ulink" href="http://www.foruse.com" target="_top">www.ForUse.com</a>.
      </p><p>
	Aunque es un arte oscuro, en este punto es importante hacer
	algún tipo de estimación de tiempo básica. Ahora tiene una
	visión general de qué está construyendo así que probablemente
	será capaz de tener alguna idea de cuánto tiempo llevará. Aquí
	entran en juego muchos factores. Si hace una estimación a largo
	plazo entonces la compañía puede decidir no construirlo (y usar
	sus recursos en algo más razonable -eso es
	<span class="emphasis"><em>bueno</em></span>). O un gerente puede tener ya
	decidido cuánto puede durar un proyecto e intentar influir en su
	estimación. Pero es mejor tener una estimación honesta desde el
	principio y afrontar pronto las decisiones difíciles. Ha habido
	un montón de intentos de crear técnicas de estimación precisas
	(como técnicas para predecir la bolsa), pero probablemente la
	mejor aproximación es confiar en su experiencia e
	intuición. Utilice su instinto para predecir cuánto tiempo
	llevará tenerlo terminado, entonces multiplique por dos y añada
	un 10%. Su instinto visceral probablemente sea correcto;
	<span class="emphasis"><em>puede</em></span> conseguir algo contando con este
	tiempo. El «doble» le permitirá convertirlo en algo
	decente, y el 10% es para tratar los refinamientos y detalles
	finales
	<sup>[<a id="idp3838688" href="#ftn.idp3838688" class="footnote">21</a>]</sup>.
	Sin embargo, usted quiere explicarlo, y a pesar de
	quejas y manipulaciones que ocurren cuando publique la
	estimación, parece que esta regla funciona.
      </p></div><div class="sect2" title="1.9.3. Fase 2: ¿Cómo podemos construirlo?"><div class="titlepage"><div><div><h3 class="title"><a id="idp3840160"></a>1.9.3.  Fase 2: ¿Cómo podemos construirlo? </h3></div></div></div><p>
	En esta fase debe aparecer un diseño que describa qué clases hay
	y cómo interactúan. Una técnica excelente para determinar clases
	es la tarjeta
	<span class="emphasis"><em>Clase-Responsabilidad-Colaboración</em></span>
	(<span class="emphasis"><em>Class-Responsibility-Collaboration</em></span>) o
	CRC. Parte del valor de esta herramienta es que es
	baja-tecnología: empieza con una colección de 3
	a 5 tarjeta en blanco, y se escribe sobre
	ellas. Cada tarjeta representa una única clase, y en ella se escribe:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    El nombre de la clase. Es importante que el nombre refleje
	    la esencia de lo que hace la clase, así todo tiene sentido
	    con un simple vistazo.
	  </p></li><li class="listitem"><p>
	    Las «responsabilidades» de la clase: qué debe
	    hacer. Típicamente se puede resumir por la misma declaración
	    de las funciones miembro o métodos (ya que esos nombres
	    pueden ser descritos en un buen diseño), pero no descarte
	    otras notas. Si necesita hacer una selección previa, mire el
	    problema desde un punto de vista de programador perezoso:
	    ¿Qué objetos quiere que aparezcan por arte de magia para
	    resolver su problema?
	  </p></li><li class="listitem"><p>
	    Las «colaboraciones» de la clase: ¿qué otras
	    clases interactúan con ésta? «Interacción» es
	    un término amplio a propósito; puede significar agregación o
	    simplemente que algún otro objeto que lleva a cabo servicios
	    para un objeto de la clase. Las colaboraciones deberían
	    considerar también la audiencia para esta clase. Por
	    ejemplo, si crea una clase <code class="classname">Petardo</code>,
	    ¿quién va a observarlo, un <code class="classname">Químico</code> o
	    un <code class="classname">Espectador</code>? El primero puede
	    querer saber qué componentes químicos se han usado en su
	    construcción, y el último responderá a los colores y figuras
	    que aparezcan cuando explote.
	  </p></li></ol></div><p>
	Puede creer que las fichas pueden ser más grandes por toda la
	información que pondrá en ellas, pero son pequeñas a propósito,
	no sólo para que las clases se mantengan pequeñas también para
	evitar tener que manejar demasiados detalles demasiado
	pronto. Si no puede apuntar todo lo que necesita saber sobre una
	clase en una ficha pequeña, la clase es demasiado compleja (a
	está poniendo demasiados detalles, o debería crear más de una
	clase). La clase ideal se entiende con un vistazo. La idea de
	las fichas CRC es ayudarle a realizar un acercamiento con un
	primer corte del diseño y que pueda obtener una visión global y
	después refinar su diseño.
      </p><p>
	Uno de los mayores beneficios de las tarjetas CRC es la
	comunicación. Se hace mejor en tiempo-real, en grupo, sin
	computadores. Cada persona es responsable de varias clases (que
	al principio no tienen nombres ni otra información). Haga una
	simulación en vivo resolviendo un escenario cada vez, decidiendo
	qué mensajes envía a varios objetos para satisfacer las
	necesidades de cada escenario. Al pasar por este proceso,
	descubrirá las clases que necesita con sus responsabilidades y
	colaboraciones, rellene las tarjetas del mismo modo. Cuando haya
	pasado por todos los casos de uso, debería disponer de un primer
	corte bastante completo su diseño.
      </p><p>
	Antes de empezar a usar fichas CRC, las mayoría de las
	experiencias de consultoría exitosas las tuve cuando me
	enfrentaba con un diseño inicial complicado estando al frente de
	un equipo, que no había construido un proyecto POO antes, y
	dibujando objetos en un pizarra blanca. Hablábamos sobre cómo
	los objetos deberían comunicarse unos con otros, y borrábamos
	algunos de ellos para reemplazarlos por otros
	objetos. Efectivamente, yo gestionaba todas las«tarjetas
	CRC» en la pizarra. Realmente, el equipo (que conocía lo
	que el proyecto se suponía tenía que hacer) creó el diseño;
	ellos «poseían» el diseño en lugar de tener que
	dárselo. Todo lo que yo hacía era guiar el proceso haciendo las
	preguntas correctas, poniendo a prueba los suposiciones, y
	llevando la retroalimentación del equipo para modificar esas
	suposiciones. La verdadera belleza del proceso era que el equipo
	aprendía cómo hacer diseños orientado a objetos no revisando
	ejemplos abstractos, sino trabajando sobre un diseño que era más
	interesante para ellos en ese momento: los suyos.
      </p><p>
	Una vez que tenga con una serie de tarjetas CRC, quizá quiera
	crear una descripción más formal de su diseño usando UML
	<sup>[<a id="idp3851328" href="#ftn.idp3851328" class="footnote">22</a>]</sup>.
	No necesita usar UML, pero puede servirle de ayuda,
	especialmente si quiere poner un diagrama en la pared para que
	todo el mundo lo tenga en cuenta, lo cual es una buena idea. Una
	alternativa a UML es una descripción textual de los objetos y
	sus interfaces, o, dependiendo de su lenguaje de programación,
	el propio código
	<sup>[<a id="idp3852640" href="#ftn.idp3852640" class="footnote">23</a>]</sup>.
      </p><p>
	UML también proporciona una notación de diagramas adicional para
	describir el modelo dinámico de su sistema. Eso es útil en
	situaciones en las que las transiciones de estado de un sistema
	o subsistema son bastante más dominantes de lo que necesitan sus
	propios diagramas (como en un sistema de control). También puede
	necesitar describir las estructuras de datos, para sistemas o
	subsistemas en los que los propios datos son un factor dominante
	(como una base de datos).
      </p><p>
	Sabrá qué está haciendo con la fase 2 cuando haya descrito los
	objetos y sus interfaces. Bien, en muchos de ellos hay algunos
	que no se pueden conocer hasta la fase 3. Pero está bien. Todo
	lo que le preocupa es que eventualmente descubra todo sobre sus
	objetos. Es bueno descubrirlos pronto pero la POO proporciona
	suficiente estructura de modo que no es grave si los descubre
	más tarde. De hecho, el diseño de un objeto suele ocurrir en cinco
	etapas, durante todo el proceso de desarrollo del programa.
      </p><div class="sect3" title="Las cinco etapas del diseño de objetos"><div class="titlepage"><div><div><h4 class="title"><a id="idp3855328"></a>Las cinco etapas del diseño de objetos</h4></div></div></div><p>
	  La vida del diseño de un objeto no se limita a la escritura del programa. En
	  cambio, el diseño de un objeto ocurre en una secuencia de etapas. Es útil tener
	  esta perspectiva porque no debería esperar alcanzar la perfección enseguida; en
	  lugar de eso, se dará cuenta que entender lo que hace un objeto y a qué se
	  debería que ocurre con el tiempo. Esta vista también se aplica al diseño de
	  varios tipos de programas; el patrón para un tipo particular de programas surge
	  a fuerza de pelearse una y otra vez con ese problema (los <span class="emphasis"><em>Patrones de
	  Diseño</em></span> se desarrollan en el Volumen 2). Los objetos, también, tienen
	  sus patrones que surgen del entendimiento, uso y reutilización.
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	      Descubrimiento de objetos. Esta etapa ocurre durante el
	      análisis inicial de un programa. Los objetos pueden
	      descubrirse viendo los factores externos y los límites,
	      duplicación de elementos en el sistema, y las unidades
	      conceptuales más pequeñas. Algunos objetos son obvios si
	      se dispone de un conjunto de librerías de clases. Las
	      partes comunes entre clases pueden sugerir clases base y
	      herencia que pueden aparecer pronto, o más tarde en el
	      proceso de diseño.
	    </p></li><li class="listitem"><p>
	      Montaje de objetos. Si está construyendo un objeto
	      descubrirá la necesidad de nuevos miembros que no aparecen
	      durante la fase de descubrimiento. Las necesidades
	      internas del objeto pueden requerir otras clases que le
	      den soporte.
	    </p></li><li class="listitem"><p>
	      Construcción del sistema. Una vez más, pueden aparecer más
	      requisitos para un objeto a lo largo de esta
	      etapa. Conforme aprende, evoluciona sus objetos. La
	      necesidad de comunicación e interconexión con otros
	      objetos en el sistema puede cambiar las necesidades de sus
	      clases o requerir clases nuevas. Por ejemplo, puede
	      descubrir la necesidad de clases utilería o
	      ayudantes (<span class="foreignphrase"><em class="foreignphrase">helper</em></span>), como una
	      lista enlazada, que contienen o no una pequeña información
	      de estado y que simplemente ayudan a la función de otras
	      clases.
	    </p></li><li class="listitem"><p>
	      Extensión del sistema. Cuando añada nuevas características
	      a un sistema puede descubrir que su diseño previo no
	      soportaba extensiones sencillas del sistema. Con esta nueva
	      información, puede reestructurar partes del sistema,
	      posiblemente añadiendo nuevas clases o jerarquía de
	      clases.
	    </p></li><li class="listitem"><p>
	      Reutilización de objetos. Esta es la verdadera prueba de
	      estrés para una clase. Si alguien intenta reutilizarla en
	      una situación completamente nueva, probablemente
	      descubrirá algunos defectos. Si cambia una clase para
	      adaptarla a nuevos programas, los principios generales de
	      la clase se verán más claros, hasta que consiga un tipo
	      verdaderamente reutilizable. Sin embargo, no espere que
	      muchos objetos del diseño de un sistema sean reutilizables
	      -es perfectamente aceptable que la mayor parte de los
	      objetos sean específicos para el sistema. Los tipos
	      reutilizables tienden a ser menos comunes, y deben
	      resolver problemas más generales para ser reutilizables.
	    </p></li></ol></div></div><div class="sect3" title="Directrices para desarrollo de objetos"><div class="titlepage"><div><div><h4 class="title"><a id="idp3864200"></a>Directrices para desarrollo de objetos</h4></div></div></div><p>
	  Estas etapas sugieren algunas directrices cuando se piensa
	  sobre el desarrollo de clases:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	      Permita que un problema específico dé lugar a una clase,
	      después deje que la clase crezca y madure durante la
	      solución de otros problemas.
	    </p></li><li class="listitem"><p>
	      Recuerde, descubrir las clases que necesita (y sus
	      interfaces) supone la mayor parte del diseño del
	      sistema. Si ya tenía esas clases, será un proyecto fácil.
	    </p></li><li class="listitem"><p>
	      No se esfuerce por saber todo desde el principio; aprenda
	      conforme avanza. Ocurrirá así de todos modos.
	    </p></li><li class="listitem"><p>
	      Comience a programar; consiga tener algo funcionando
	      para poder aprobar o desaprobar su diseño. No tenga
	      miedo a que acabe haciendo código procedural espagueti
	      -las clases dividen el problema y ayudan a controlar la
	      anarquía y la entropía. Las clases malas no estropean
	      las buenas.
	    </p></li><li class="listitem"><p>
	      Manténgalo simple. Pequeños objetos claros con utilidades
	      obvias son mejores que grandes interfaces
	      complicadas. Cuando aparezcan los puntos de decisión,
	      aplique el principio de la Navaja de
	      <span class="personname"><span class="firstname">Occam</span></span>:
	      Considere las alternativas y elija la más simple, porque
	      las clases simples casi siempre son mejores. Empiece con
	      clases pequeñas y sencillas, y podrá ampliar la interfaz
	      cuando la entienda mejor, pero cuando esto ocurra, será
	      difícil eliminar elementos de la clase.
	    </p></li></ol></div></div></div><div class="sect2" title="1.9.4. Fase 3: Construir el núcleo"><div class="titlepage"><div><div><h3 class="title"><a id="idp3870392"></a>1.9.4. Fase 3: Construir el núcleo </h3></div></div></div><p>
	Esta es la conversión inicial desde el diseño rudo al cuerpo del
	código compilable y ejecutable que se puede probar, y que
	aprobará y desaprobará su arquitectura. No es un proceso en un
	solo paso, más bien es el principio de una serie de pasos que
	iterativamente construirán el sistema, como verá en la fase 4.
      </p><p>
	Su objetivo es encontrar el núcleo de la arquitectura de su
	sistema que hay que implementar para generar un sistema
	funcional, sin importar lo incompleto que esté el sistema en la
	pasada inicial. Está creando una estructura que se puede
	construir con más iteraciones. También está llevando a cabo la
	primera de muchas integraciones del sistema y pruebas, y dando a
	los clientes realimentación sobre cómo serán y cómo progresan
	sus sistemas. Idealmente, también expone algunos de los riesgos
	críticos. Probablemente descubrirá cambios y mejoras que se
	pueden hacer en la arquitectura original - cosas que podría no
	haber aprendido sin implementar el sistema.
      </p><p>
	Parte de la construcción del sistema es la dosis de realidad que
	se obtiene al probar su análisis de requisitos y su
	especificación del sistema (existe de cualquier
	forma). Asegúrese de que sus pruebas verifican los requisitos y
	los casos de uso. Cuando el núcleo de su sistema sea estable,
	estará preparado para progresar y añadir más funcionalidad.
      </p></div><div class="sect2" title="1.9.5. Fase 4: Iterar los casos de uso"><div class="titlepage"><div><div><h3 class="title"><a id="idp3874176"></a>1.9.5.  Fase 4: Iterar los casos de uso</h3></div></div></div><p>
	Una vez que la estructura del núcleo está funcionando, cada
	conjunto de características que añade es un pequeño proyecto en
	sí mismo. Añada una colección de características durante cada
	<span class="emphasis"><em>iteración</em></span>, un periodo razonablemente corto
	de desarrollo.
      </p><p>
	¿Cómo de grande es una iteración? Idealmente, cada iteración
	dura unas tres semanas (puede cambiar dependiendo del lenguaje
	de implementación). Al final de ese periodo, tendrá un sistema
	probado e integrado con más funcionalidades de las que tenía
	antes. Pero lo que es particularmente interesante son las bases
	de la iteración: un único caso de uso. Cada caso de uso es un
	paquete de funcionalidades relacionadas que se puede construir
	en su sistema de una vez, a lo largo de una iteración. No sólo
	le da una mejor idea de qué alcance debería tener, también le da
	más valor a la idea un caso de uso, ya que el concepto no se
	descarta después del análisis y diseño, sino que es una unidad
	fundamental de desarrollo durante el proceso de construcción de
	software.
      </p><p>
	Se deja de iterar cuando se consigue la funcionalidad deseada o
	se acaba el plazo impuesto y el cliente está satisfecho con la
	versión actual. (Recuerde, el software es una subscripción de
	negocios). Como el proceso es iterativo, tiene muchas
	oportunidades para enviar un producto en lugar de un simple
	punto final; los proyectos de software libre trabajan
	exclusivamente en un entorno iterativo con alta realimentación,
	que es precisamente la clave de su éxito.
      </p><p>
	Un proceso de desarrollo iterativo es valioso por muchas
	razones. Puede mostrar y resolver pronto riesgos críticos, los
	clientes tienen abundantes oportunidades de cambiar sus
	opiniones, la satisfacción del programador es más alta, y el
	proyecto puede dirigirse con más precisión. Pero un beneficio
	adicional importante es la realimentación para los clientes, los
	cuales pueden ver en el estado actual del producto exactamente
	donde se encuentra todo. Esto puede reducir o eliminar la
	necesidad de abrumadoras reuniones de control y aumentar la
	confianza y el apoyo de los clientes.
      </p></div><div class="sect2" title="1.9.6. Fase 5: Evolución"><div class="titlepage"><div><div><h3 class="title"><a id="idp3879320"></a>1.9.6. Fase 5: Evolución</h3></div></div></div><p>
	Este es el punto en el ciclo de desarrollo que se conoce
	tradicionalmente como «mantenimiento», un término
	amplio que puede significar de todo, desde «conseguir que
	funcione como se supone que debió hacerlo desde el
	principio» hasta «añadir características que el
	cliente olvidó mencionar» pasando por el tradicional
	«arreglar errores que han ido apareciendo» y
	«añadir nuevas características según se presentan las
	necesidades». Se han aplicado algunas ideas equivocadas
	al término «mantenimiento» que se ha tomado en
	calidad de pequeño engaño, en parte porque sugiere que realmente
	ha construido un programa primitivo y todo lo que necesita hacer
	es cambiar partes, engrasarlo, e impedir que se oxide. Quizá
	haya un término mejor para describir esa tarea.
      </p><p>
	Yo usaré el término <span class="emphasis"><em>evolución</em></span>
	<sup>[<a id="idp3882824" href="#ftn.idp3882824" class="footnote">24</a>]</sup>.  Es decir, «no podrá hacerlo bien la primera
	vez, pero le dará la oportunidad de aprender y volver atrás y
	hacer cambios». Puede que necesite hacer muchos cambios
	hasta que aprenda y entienda el problema con mayor
	profundidad. La elegancia que obtendrá si evoluciona hasta
	hacerlo bien valdrá la pena, tanto a corto como a largo
	plazo. La evolución es donde su programa pasa de bueno a
	fenomenal, y donde estos usos, que realmente no entiende en un
	primer momento, pasan a ser más claros después. Es también donde
	sus clases pueden evolucionar de un uso de único-proyecto a
	recursos reutilizables.
      </p><p>
	«Hacerlo bien» no significa sólo que el programa
	funcione según los requisitos y los casos de uso. Significa que
	la estructura interna del código tiene sentido, y parece que
	encaja bien, sin sintaxis difícil, objetos sobredimensionados, o
	pedazos de código desgarbados. Además, debe tener la
	sensación de que la estructura del programa sobrevivirá a los
	cambios que inevitablemente habrá durante su ciclo de vida, y
	estos cambios pueden hacerse fácil y limpiamente. No es una
	tarea sencilla. No sólo debe entender lo que está construyendo,
	sino también cómo evolucionará el programa (lo que yo llamo el
	<span class="emphasis"><em>vector de cambio</em></span>
	<sup>[<a id="idp3886792" href="#ftn.idp3886792" class="footnote">25</a>]</sup>.

	Afortunadamente, los lenguajes de programación orientados a
	objetos son particularmente adecuados para dar soporte a este
	tipo de modificaciones continuas - los límites creados por los
	objetos son los que tienden a conservar la estructura frente a
	roturas. También le permiten hacer cambios - algunos pueden
	parecer drásticos en un programa procedural - sin causar
	terremotos en todo su código. En realidad, el soporte para la
	evolución puede que sea el beneficio más importante de la POO.
      </p><p>
	Con la evolución, el programador crea algo que al menos se aproxima a lo que
	piensa que está construyendo, y luego busca defectos, lo compara con sus
	requisitos y ve lo que falta. Entonces puede volver y arreglarlo rediseñando y
	re-implementando las porciones del programa que no funcionen bien
	<sup>[<a id="idp3889048" href="#ftn.idp3889048" class="footnote">26</a>]</sup>.

	Realmente puede necesitar resolver el problema, o un aspecto del
	mismo, varias veces antes de dar con la solución correcta. (Un
	estudio de los <span class="emphasis"><em>Patrones de Diseño</em></span>, descrito
	en el Volumen 2, normalmente resulta útil aquí).
      </p><p>
	La evolución también ocurre cuando construye un sistema, ve que
	encaja con sus requisitos, y entonces descubre que no era
	realmente lo que buscaba. Cuando ve el sistema en
	funcionamiento, descubre que realmente quería resolver era
	problema diferente. Si piensa que este tipo de evolución le va a
	ocurrir, entonces debe construir su primera versión lo más
	rápidamente posible para que pueda darse cuenta de si es eso lo
	que quiere.
      </p><p>
	Quizás lo más importante a recordar es que por defecto -por
	definición, realmente- si modifica una clase entonces su
	superclase -y subclases- seguirán funcionando. Necesita perder el
	miedo a los cambios (especialmente si tiene un conjunto
	predefinido de pruebas unitarias para verificar la validez de
	sus cambios). La modificación no romperá necesariamente
	el programa, y ningún cambio en el resultado estará limitado a
	las subclases y/o colaboradores específicos de la clase que
	cambie.
      </p></div><div class="sect2" title="1.9.7. Los planes valen la pena"><div class="titlepage"><div><div><h3 class="title"><a id="idp3892856"></a>1.9.7. Los planes valen la pena</h3></div></div></div><p>
	Por supuesto, no construiría una casa sin un montón de planos
	cuidadosamente dibujados. Si construye un piso o una casa para
	el perro, sus planos no serán muy elaborados pero probablemente
	empezará con algún tipo de esbozo para guiarle en su camino. El
	desarrollo de software ha llegado a extremos. Durante mucho
	tiempo, la gente tenía poca estructura en sus desarrollos, pero
	entonces grandes proyectos empezaron a fracasar. Como resultado,
	se acabó utilizando metodologías que tenían una cantidad
	abrumadora de estructura y detalle, se intentó principalmente
	para esos grandes proyectos. Estas metodologías eran muy
	complicadas de usar - la sensación era que se estaba perdiendo
	todo el tiempo escribiendo documentos y no programando (a
	menudo era así). Espero haberle mostrado aquí sugerencias a
	medio camino - una escala proporcional. Usar una propuesta que
	se ajusta a sus necesidades (y a su personalidad). No importa lo
	pequeño que desee hacerlo, <span class="emphasis"><em>cualquier</em></span> tipo
	de plan supondrá una gran mejora en su proyecto respecto a no
	planear nada. Recuerde que, según la mayoría de las
	estimaciones, alrededor del 50% de proyectos fracasan (¡algunas
	estimaciones superan el 70%!).
      </p><p>
	Seguir un plan - preferiblemente uno simple y breve - y esbozar
	la estructura del diseño antes de empezar a codificar,
	descubrirá qué cosas caen juntas más fácilmente que si se lanza
	a programar, y también alcanzará un mayor grado de
	satisfacción. Mi experiencia me dice que llegar a una
	solución elegante es profundamente satisfactorio en un nivel
	completamente diferente; parece más arte que tecnología. Y la
	elegancia siempre vale la pena; no es una búsqueda frívola. No
	sólo le permite tener un programa fácil de construir y depurar,
	también es más fácil de comprender y mantener, y ahí es
	donde recae su valor económico.
      </p></div></div><div class="sect1" title="1.10. Programación Extrema"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3897048"></a>1.10. Programación Extrema</h2></div></div></div><p>
      He estudiado técnicas de análisis y diseño, por activa y por
      pasiva, desde mis estudios universitarios. El concepto de
      <span class="emphasis"><em>Programación Extrema</em></span> (XP) es el más radical y
      encantador que he visto nunca. Puede encontrar una crónica sobre
      el tema en <em class="citetitle">Extreme Programming Explained</em> de
      <span class="personname"><span class="firstname">Kent</span> <span class="surname">Beck</span></span> (Addison-Wesley 2000) y en la
      web <a class="ulink" href="http://www.xprogramming.com" target="_top">www.xprogramming.com</a>
    </p><p>
      XP es una filosofía sobre el trabajo de programación y también un
      conjunto de directrices para hacerlo. Alguna de estas directrices
      se reflejan en otras metodologías recientes, pero las dos
      contribuciones más importantes y destacables, en mi opinión, son
      «escribir primero las pruebas» y la
      «programación en parejas». Aunque defiende con fuerza
      el proceso completo,
      <span class="personname"><span class="surname">Benk</span></span> señala que si
      adopta únicamente estas dos prácticas mejorará sensiblemente su
      productividad y fiabilidad.
    </p><div class="sect2" title="1.10.1. Escriba primero las pruebas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3901336"></a>1.10.1. Escriba primero las pruebas</h3></div></div></div><p>
	El proceso de prueba se ha relegado tradicionalmente a la parte
	final del proyecto, después de que «consiga tener todo
	funcionando, pero necesite estar seguro». Implícitamente
	ha tenido una prioridad baja, y la gente que se especializa en
	ello nunca ha tenido estatus y suele trabajar en el sótano,
	lejos de los «programadores reales». Los equipos de
	pruebas han respondido al estereotipo, vistiendo trajes negros y
	hablando con regocijo siempre que encontraban algo (para ser
	honesto, yo tenía esa misma sensación cuando encontraba
	fallos en los compiladores de C++).
      </p><p>
	XP revoluciona completamente el concepto del proceso de prueba
	dándole la misma (o incluso mayor) prioridad que al código. De
	hecho, se escriben las pruebas <span class="emphasis"><em>antes</em></span> de
	escribir el código que está probando, y las pruebas permanecen
	con el código siempre. Las pruebas se deben ejecutar con éxito
	cada vez que hace una integración del proyecto (algo que ocurre
	a menudo, a veces más de una vez al día).
      </p><p>
	Escribir primero las pruebas tiene dos efectos extremadamente
	importantes.
      </p><p>
	Primero, fuerza una definición clara de la interfaz de la
	clase. A menudo sugiero que la gente «imagine la clase
	perfecta para resolver un problema particular» como una
	herramienta cuando intenta diseñar el sistema. La estrategia del
	proceso de prueba de XP va más lejos que eso - especifica
	exactamente cual es el aspecto de la clase, para el consumidor
	de esa clase, y exactamente cómo debe comportarse la clase. En
	ciertos términos. Puede escribir toda la prosa, o crear todos
	los diagramas donde quiera describir cómo debe comportarse una
	clase y qué aspecto debe tener, pero nada es tan real como un
	conjunto de pruebas. Lo primero es una lista de deseos, pero las
	pruebas son un contrato forzado por el compilador y el
	programa. Es difícil imaginar una descripción más concreta de
	una clase que las pruebas.
      </p><p>
	Mientras se crean las pruebas, el programador está completamente
	forzado a elaborar la clase y a menudo descubrirá necesidades de
	funcionalidad que habrían sido omitidas durante los experimentos
	de diagramas UML, tarjetas CRC, casos de uso, etc.
      </p><p>
	El segundo efecto importante de escribir las pruebas primero
	procede de la propia ejecución de las pruebas cada vez que hace
	una construcción del software. Esta actividad le ofrece la otra
	mitad del proceso de prueba que es efectuado por el
	compilador. Si mira la evolución de los lenguajes de
	programación desde esta perspectiva, verá que las mejoras reales
	en la tecnología giran realmente alrededor del proceso de
	prueba. El lenguaje ensamblador sólo se fija en la sintaxis,
	pero C impone algunas restricciones de semántica, y éstas le
	impiden cometer ciertos tipos de errores. Los lenguajes POO
	imponen incluso más restricciones semánticas, si lo piensa son
	realmente formas del proceso de prueba. «¿Se utiliza
	apropiadamente este tipo de datos?  ¿Se invoca esta función del
	modo correcto?» son el tipo de pruebas que se llevan a
	cabo por el compilador en tiempo de ejecución del sistema. Se
	han visto los resultados de tener estas pruebas incorporadas en
	el lenguaje: la gente ha sido capaz de escribir sistemas más
	complejos, y han funcionado, con mucho menos tiempo y
	esfuerzo. He tratado de comprender porqué ocurre eso, pero ahora
	me doy cuenta de que son las pruebas: el programador hace algo
	mal, y la red de seguridad de las pruebas incorporadas le dice
	que hay un problema y le indica dónde.
      </p><p>
	Pero las pruebas incorporadas que proporciona el diseño del
	lenguaje no pueden ir más lejos. En este punto, el
	programador<span class="emphasis"><em></em></span> debe intervenir y añadir el
	resto de las pruebas que producen un juego completo (en
	cooperación con el compilador y el tiempo de ejecución del
	sistema) que verifica el programa completo. Y, del mismo modo
	que tiene un compilador vigilando por encima de su hombro, ¿no
	querría que estas pruebas le ayudaran desde el principio? Por
	eso se escriben primero, y se ejecutan automáticamente con cada
	construcción del sistema. Sus pruebas se convierten en una
	extensión de la red de seguridad proporcionada por el lenguaje.
      </p><p>
	Una de las cosas que he descubierto sobre el uso de lenguajes de
	programación cada vez más poderosos es que estoy dispuesto a
	probar experimentos más descarados, porque sé que el lenguaje me
	ahorra la pérdida de tiempo que supone estar persiguiendo
	errores. El esquema de pruebas de XP hace lo mismo para el
	proyecto completo. Como el programador conoce sus pruebas
	siempre cazará cualquier problema que introduzca (y
	regularmente se añadirán nuevas pruebas), puede hacer grandes
	cambios cuando lo necesite sin preocuparse de causar un
	completo desastre. Eso es increíblemente poderoso.
      </p></div><div class="sect2" title="1.10.2. Programación en parejas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3911256"></a>1.10.2. Programación en parejas</h3></div></div></div><p>
	Programar en parejas va en contra del duro individualismo en el
	que hemos sido adoctrinados desde el principio, a través de la
	facultad (donde triunfábamos o fracasábamos por nosotros mismos,
	y trabajar con nuestros vecinos se consideraba
	«engañoso») y los medios de comunicación,
	especialmente las películas de Hollywood donde el héroe
	normalmente lucha contra la estúpida conformidad
	<sup>[<a id="idp3912752" href="#ftn.idp3912752" class="footnote">27</a>]</sup>.

	Los programadores también se consideran dechados de
	individualismo -«cowboy coders» como le gusta decir
	a <span class="personname"><span class="firstname">Larry</span> <span class="surname">Constantine</span></span>. XP, que es en si
	mismo una batalla contra el pensamiento convencional, dice que
	el código debería ser escrito por dos personas por estación de
	trabajo. Y eso se puede hacer en una área con un grupo de
	estaciones de trabajo, sin las barreras a las que la gente de
	diseño de infraestructuras tiene tanto cariño. De hecho,
	<span class="personname"><span class="firstname">Beck</span></span> dice que la
	primera tarea de pasarse a XP es llegar con destornilladores y
	llaves Allen y desmontar todas esas barreras
	<sup>[<a id="idp3915192" href="#ftn.idp3915192" class="footnote">28</a>]</sup>. (Esto requerirá un director que pueda
	afrontar la ira del departamento de infraestructuras).
      </p><p>
	El valor de la programación en parejas está en que mientras una
	persona escribe el código la otra está pensando. El pensador
	mantiene un visión global en su cabeza, no sólo la imagen del
	problema concreto, también las pautas de XP. Si dos personas
	están trabajando, es menos probable que uno de ellos acabe
	diciendo, «No quiero escribir las pruebas primero»,
	por ejemplo. Y si el programador se atasca, pueden cambiar los
	papeles. Si ambos se atascan, sus pensamientos pueden ser
	escuchados por otro en el área de trabajo que puede
	contribuir. Trabajar en parejas mantiene las cosas en movimiento
	y sobre la pista. Y probablemente más importante, hace que la
	programación sea mucho más social y divertida.
      </p><p>
	He empezado a usar programación en parejas durante los
	periodos de ejercicio en algunos de mis seminarios y parece
	mejorar considerablemente la experiencia de todo el mundo.
      </p></div></div><div class="sect1" title="1.11. Porqué triunfa C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3919120"></a>1.11. Porqué triunfa C++</h2></div></div></div><p>
      Parte de la razón por la que C++ ha tenido tanto éxito es que la
      meta no era precisamente convertir C en un lenguaje de POO (aunque
      comenzó de ese modo), sino también resolver muchos otros problemas
      orientados a los desarrolladores de hoy en día, especialmente
      aquellos que tienen grandes inversiones en C. Tradicionalmente,
      los lenguajes de POO han sufrido de la postura de que debería
      abandonar todo lo que sabe y empezar desde cero, con un nuevo
      conjunto de conceptos y una nueva sintaxis, argumentando que es
      mejor a largo plazo todo el viejo equipaje que viene con los
      lenguajes procedurales. Puede ser cierto, a largo plazo. Pero a
      corto plazo, mucho de este equipaje era valioso. Los elementos más
      valiosos podían no estar en el código base existente (el cual, con
      las herramientas adecuadas, se podría traducir), sino en el
      <span class="emphasis"><em>conocimiento adquirido</em></span>. Si usted es un
      programador C y tiene que tirar todo lo que sabe sobre C para
      adoptar un nuevo lenguaje, inmediatamente será mucho menos
      productivo durante muchos meses, hasta que su mente su ajuste al
      nuevo paradigma. Mientras que si puede apoyarse en su conocimiento
      actual de C y ampliarlo, puede continuar siendo productivo con lo
      que realmente sabe mientras se pasa al mundo de la programación
      orientada a objetos. Como todo el mundo tiene su propio modelo
      mental de la programación, este cambio es lo suficientemente
      turbio sin el gasto añadido de volver a empezar con un nuevo
      modelo de lenguaje. Por eso, la razón del éxito de C++, en dos
      palabras: es económico. Sigue costando cambiarse a la POO, pero
      con C++ puede costar menos
      <sup>[<a id="idp3922584" href="#ftn.idp3922584" class="footnote">29</a>]</sup>.
    </p><p>
      La meta de C++ es mejorar la productividad. Ésta viene por muchos
      caminos, pero el lenguaje está diseñado para ayudarle todo lo
      posible, y al mismo tiempo dificultarle lo menos posible con
      reglas arbitrarias o algún requisito que use un conjunto
      particular de características. C++ está diseñado para ser
      práctico; las decisiones de diseño del lenguaje C++ estaban
      basadas en proveer los beneficios máximos al programador (por lo
      menos, desde la visión del mundo de C).
    </p><div class="sect2" title="1.11.1. Un C mejor"><div class="titlepage"><div><div><h3 class="title"><a id="idp3924592"></a>1.11.1. Un C mejor</h3></div></div></div><p>
	Se obtiene una mejora incluso si continúa escribiendo código C
	porque C++ ha cerrado muchos agujeros en el lenguaje C y ofrece
	mejor control de tipos y análisis en tiempo de compilación. Está
	obligado a declarar funciones de modo que el compilador pueda
	controlar su uso. La necesidad del preprocesador ha sido
	prácticamente eliminada para sustitución de valores y macros,
	que eliminan muchas dificultades para encontrar errores. C++
	tiene una característica llamada <span class="emphasis"><em>referencias</em></span>
	que permite un manejo más conveniente de direcciones para
	argumentos de funciones y retorno de valores. El manejo de
	nombres se mejora a través de una característica llamada
	<span class="emphasis"><em>sobrecarga de funciones</em></span>, que le permite
	usar el mismo nombre para diferentes funciones. Una
	característica llamada <span class="emphasis"><em>namespaces</em></span> (espacios
	de nombres) también mejora la seguridad respecto a C.
      </p></div><div class="sect2" title="1.11.2. Usted ya está en la curva de aprendizaje"><div class="titlepage"><div><div><h3 class="title"><a id="idp3927160"></a>1.11.2. Usted ya está en la curva de aprendizaje</h3></div></div></div><p>
	El problema con el aprendizaje de un nuevo lenguaje es la
	productividad. Ninguna empresa puede permitirse de repente
	perder un ingeniero de software productivo porque está
	aprendiendo un nuevo lenguaje. C++ es una extensión de C, no una
	nueva sintaxis completa y un modelo de programación. Le permite
	continuar creando código útil, usando las características
	gradualmente según las va aprendiendo y entendiendo. Puede que
	ésta sea una de las razones más importantes del éxito de C++.
      </p><p>
	Además, todo su código C es todavía viable en C++, pero como el
	compilador de C++ es más delicado, a menudo encontrará errores
	ocultos de C cuando recompile su código con C++.
      </p></div><div class="sect2" title="1.11.3. Eficiencia"><div class="titlepage"><div><div><h3 class="title"><a id="idp3929368"></a>1.11.3. Eficiencia</h3></div></div></div><p>
	A veces es apropiado intercambiar velocidad de ejecución por
	productividad de programación. Un modelo económico, por ejemplo,
	puede ser útil sólo por un periodo corto de tiempo, pero es más
	importante crear el modelo rápidamente. No obstante, la mayoría
	de las aplicaciones requieren algún grado de eficiencia, de modo
	que C++ siempre yerra en la parte de mayor eficiencia. Como los
	programadores de C tienden a ser muy concienzudos con la
	eficiencia, ésta es también una forma de asegurar que no podrán
	argumentar que el lenguaje es demasiado pesado y lento. Algunas
	características en C++ intentan facilitar el afinado del
	rendimiento cuando el código generado no es lo suficientemente
	eficiente.
      </p><p>
	No sólo se puede conseguir el mismo bajo nivel de C (y la
	capacidad de escribir directamente lenguaje ensamblador dentro
	de un programa C++), además la experiencia práctica sugiere que
	la velocidad para un programa C++ orientado a objetos tiende a
	ser ±10% de un programa escrito en C, y a menudo mucho
	menos
	<sup>[<a id="idp3932216" href="#ftn.idp3932216" class="footnote">30</a>]</sup>.
	El diseño producido por un programa POO puede ser realmente más
	eficiente que el homólogo en C.
      </p></div><div class="sect2" title="1.11.4. Los sistemas son más fáciles de expresar y entender"><div class="titlepage"><div><div><h3 class="title"><a id="idp3933840"></a>1.11.4. Los sistemas son más fáciles de expresar y entender</h3></div></div></div><p>
	Las clases diseñadas para encajar en el problema tienden a
	expresarlo mejor. Esto significa que cuando escribe el código,
	está describiendo su solución en los términos del espacio del
	problema («ponga el FIXME:plástico en el cubo»)
	mejor que en los términos de la computadora, que están en el
	espacio de la solución («active el bit para cerrar el relé
	»). Usted maneja conceptos de alto nivel y puede hacer
	mucho más con una única línea de código.
      </p><p>
	El otro beneficio de esta facilidad de expresión es el
	mantenimiento, que (si informa se puede creer) implica una enorme
	parte del coste del tiempo de vida del programa. Si un
	programa es más fácil de entender, entonces es más fácil de
	mantener. También puede reducir el coste de crear y mantener la
	documentación.
      </p></div><div class="sect2" title="1.11.5. Aprovechamiento máximo con librerías"><div class="titlepage"><div><div><h3 class="title"><a id="idp3936776"></a>1.11.5. Aprovechamiento máximo con librerías</h3></div></div></div><p>
	El camino más rápido para crear un programa es usar código que
	ya está escrito: una librería. Un objetivo primordial de C++ es
	hacer más sencillo el uso de las librerías. Esto se consigue
	viendo las librerías como nuevos tipos de datos (clases), así
	que crear librerías significa añadir nuevos tipos al
	lenguaje. Como el compilador C++ se preocupa del modo en que se
	usa la librería - garantizando una inicialización y limpieza
	apropiadas, y asegurando que las funciones se llamen
	apropiadamente - puede centrarse en lo que hace la librería, no
	en cómo tiene que hacerlo.
      </p><p>
	Como los nombres están jerarquizados según las partes de su
	programa por medio de los espacios de nombres de C++, puede usar
	tantas librerías como quiera sin los conflictos de nombres
	típicos de C.
      </p></div><div class="sect2" title="1.11.6. Reutilización de código fuente con plantillas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3938696"></a>1.11.6. Reutilización de código fuente con plantillas</h3></div></div></div><p>
	Hay una categoría significativa de tipos que requiere
	modificaciones del código fuente para lograr una reutilización
	efectiva. Las plantillas de C++ llevan a cabo la modificación del
	código fuente automáticamente, convirtiéndola en una herramienta
	especialmente potente para la reutilización del código de las
	librerías. Si se diseña un tipo usando plantillas funcionará
	fácilmente con muchos otros tipos. Las plantillas son
	especialmente interesantes porque ocultan al programador cliente
	la complejidad de esta forma de reutilizar código.
      </p></div><div class="sect2" title="1.11.7. Manejo de errores"><div class="titlepage"><div><div><h3 class="title"><a id="idp3940016"></a>1.11.7. Manejo de errores</h3></div></div></div><p>
	La gestión de errores en C es un problema muy conocido, y a
	menudo ignorado - cruzando los dedos. Si está construyendo un
	programa complejo y grande, no hay nada peor que tener un error
	enterrado en cualquier lugar sin la menor idea de cómo llegó
	allí. La gestión de excepciones<span class="emphasis"><em></em></span> de C++
	(introducida en este volumen, y explicada en detalle en el
	Volumen 2, que se puede descargar de <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>) es
	un camino para garantizar que se notifica un error y que ocurre
	algo como consecuencia.
      </p></div><div class="sect2" title="1.11.8. Programar a lo grande"><div class="titlepage"><div><div><h3 class="title"><a id="idp3941848"></a>1.11.8. Programar a lo grande </h3></div></div></div><p>
	Muchos lenguajes tradicionales tienen limitaciones propias para
	hacer programas grandes y complejos. BASIC, por ejemplo, puede
	valer para solucionar ciertas clases de problemas rápidamente,
	pero si el programa tiene más de unas cuantas páginas o se sale
	del dominio de problemas de ese lenguaje, es como intentar nadar
	a través de un fluido cada vez más viscoso. C también tiene
	estas limitaciones. Por ejemplo, cuando un programa tiene más de
	50.000 líneas de código, los conflictos de nombres empiezan a
	ser un problema - efectivamente, se queda sin nombres de
	funciones o variables. Otro problema particularmente malo son
	los pequeños agujeros en el lenguaje C - errores enterrados en
	un programa grande que pueden ser extremadamente difíciles de
	encontrar.
      </p><p>
	No hay una línea clara que diga cuando un lenguaje está
	fallando, y si la hubiese, debería ignorarla. No diga: «Mi
	programa BASIC se ha hecho demasiado grande; ¡lo tendré que
	reescribir en C!» En su lugar, intente calzar unas
	cuantas líneas más para añadirle una nueva característica. De
	ese modo, el coste extra lo decide usted.
      </p><p>
	C++ está diseñado para ayudarle a <span class="emphasis"><em>programar a lo
	grande</em></span>, es decir, eliminar las diferencias de
	complejidad entre un programa pequeño y uno grande. Ciertamente
	no necesita usar POO, plantillas, espacios de nombres ni
	manejadores de excepciones cuando esté escribiendo un programa
	tipo «hola mundo», pero estas prestaciones están
	ahí para cuando las necesite. Y el compilador es agresivo en la
	detección de errores tanto para programas pequeños como grandes.
      </p></div></div><div class="sect1" title="1.12. Estrategias de transición"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3946072"></a>1.12. Estrategias de transición</h2></div></div></div><p>
      Si acepta la POO, su próxima pregunta seguramente será:
      «¿cómo puedo hacer que mi jefe, mis colegas, mi
      departamento, mis compañeros empiecen a utilizar objetos?»
      Piense sobre cómo usted -un programador independiente- puede ir
      aprendiendo a usar un nuevo lenguaje y un nuevo paradigma de
      programación. Ya lo ha hecho antes. Primero viene la educación y
      los ejemplos; entonces llega un proyecto de prueba que le permita
      manejar los conceptos básicos sin que se vuelva demasiado
      confuso. Después llega un proyecto del «mundo real»
      que realmente hace algo útil. Durante todos sus primeros proyectos
      continúa su educación leyendo, preguntando a expertos, e
      intercambiando consejos con amigos. Este es el acercamiento que
      sugieren muchos programadores experimentados para el cambio de C a
      C++. Por supuesto, cambiar una compañía entera introduce ciertas
      dinámicas de grupo, pero puede ayudar en cada paso recordar cómo
      lo haría una persona.
    </p><div class="sect2" title="1.12.1. Directrices"><div class="titlepage"><div><div><h3 class="title"><a id="idp3948624"></a>1.12.1. Directrices</h3></div></div></div><p>
	Aquí hay algunas pautas a considerar cuando se hace la
	transición a POO y C++:
      </p><div class="sect3" title="Entrenamiento"><div class="titlepage"><div><div><h4 class="title"><a id="idp3949328"></a>Entrenamiento</h4></div></div></div><p>
	  El primer paso es algún tipo de estudio. Recuerde la
	  inversión que la compañía tiene en código C, e intente no
	  tenerlo todo desorganizado durante seis o nueve meses mientras
	  todo el mundo alucina con la herencia múltiple. Elija un
	  pequeño grupo para formarlo, preferiblemente uno compuesto de
	  gente que sea curiosa, trabaje bien junta, y pueda funcionar
	  como su propia red de soporte mientras están aprendiendo C++.
	</p><p>
	  Un enfoque alternativo que se sugiere a veces es la enseñanza
	  a todos los niveles de la compañía a la vez, incluir una
	  visión general de los cursos para gerentes estratégicos es tan
	  bueno como cursos de diseño y programación para trabajadores
	  de proyectos. Es especialmente bueno para compañías más
	  pequeñas al hacer cambios fundamentales en la forma en la que
	  se hacen cosas, o en la división de niveles en compañías más
	  grandes. Como el coste es mayor, sin embargo, se puede
	  cambiar algo al empezar con entrenamiento de nivel de proyecto,
	  hacer un proyecto piloto (posiblemente con un mentor externo), y
	  dejar que el equipo de trabajo se convierta en los profesores
	  del resto de la compañía.
	</p></div><div class="sect3" title="Proyectos de bajo riesgo"><div class="titlepage"><div><div><h4 class="title"><a id="idp3952384"></a>Proyectos de bajo riesgo</h4></div></div></div><p>
	  Pruebe primero con un proyecto de bajo riesgo que permita
	  errores. Una vez que adquiera alguna experiencia, puede
	  acometer cualquier otro proyecto con miembros del primer
	  equipo o usar los miembros del equipo como una plantilla de
	  soporte técnico de POO. Este primer proyecto puede que no
	  funcione bien la primera vez, pero no debería ser una tarea
	  crítica para la compañía. Debería ser simple, auto-contenido,
	  e instructivo; eso significa que suele implicar la creación
	  de clases que serán significativas para otros programadores en
	  la compañía cuando les llegue el turno de aprender C++.
	</p></div><div class="sect3" title="Modelar desde el éxito"><div class="titlepage"><div><div><h4 class="title"><a id="idp3954080"></a>Modelar desde el éxito</h4></div></div></div><p>
	  Buscar ejemplos de un buen diseño orientado a objetos antes de
	  partir de cero. Hay una gran probabilidad de que alguien ya
	  haya resuelto su problema, y si ellos no lo han resuelto
	  probablemente puede aplicar lo que ha aprendido sobre
	  abstracción para modificar un diseño existente y adecuarlo a
	  sus necesidades. Este es el concepto general de los patrones
	  de diseño, tratado en el Volumen 2.
	</p></div><div class="sect3" title="Use librerías de clases existentes"><div class="titlepage"><div><div><h4 class="title"><a id="idp3955392"></a>Use librerías de clases existentes</h4></div></div></div><p>
	  La primera motivación económica para cambiar a POO es el fácil
	  uso de código existente en forma de librerías de clases (en
	  particular, las librerías Estándar de C++, explicadas en
	  profundidad en el Volumen 2 de este libro). El ciclo de
	  desarrollo de aplicación más corto ocurrirá cuando sólo tenga
	  que escribir la función <code class="function">main()</code>, creando y
	  usando objetos de las librerías de fábrica. No obstante,
	  algunos programadores nuevos no lo entienden, no son
	  conscientes de la existencia de librerías de clases, o, a
	  través de la fascinación con el lenguaje, desean escribir
	  clases que ya existen. Su éxito con POO y C++ se optimizará si
	  hace un esfuerzo por buscar y reutilizar código de otras
	  personas desde el principio del proceso de transición.
	</p></div><div class="sect3" title="No reescriba en C++ código que ya existe"><div class="titlepage"><div><div><h4 class="title"><a id="idp3957712"></a>No reescriba en C++ código que ya existe</h4></div></div></div><p>
	  Aunque compilar<span class="emphasis"><em></em></span> su código C con un
	  compilador de C++ normalmente produce (de vez en cuando
	  tremendos) beneficios encontrando problemas en el viejo
	  código, normalmente coger código funcional existente y
	  reescribirlo en C++ no es la mejor manera de aprovechar su
	  tiempo. (Si tiene que convertirlo en objetos, puede
	  «envolver» el código C en clases C++). Hay
	  beneficios incrementales, especialmente si es importante
	  reutilizar el código. Pero esos cambios no le van a mostrar
	  los espectaculares incrementos en productividad que espera
	  para sus primeros proyectos a menos que ese proyecto sea
	  nuevo. C++ y la POO destacan más cuando un proyecto pasa del
	  concepto a la realidad.
	</p></div></div><div class="sect2" title="1.12.2. Obstáculos de la gestión"><div class="titlepage"><div><div><h3 class="title"><a id="idp3959992"></a>1.12.2. Obstáculos de la gestión</h3></div></div></div><p>
	Si es gerente, su trabajo es adquirir recursos para su equipo,
	para superar las barreras en el camino del éxito de su equipo, y
	en general para intentar proporcionar el entorno más productivo
	y agradable de modo que sea más probable que su equipo realice
	esos milagros que se le piden siempre. Cambiar a C++ cae en tres
	de estas categorías, y puede ser maravilloso si no le costara
	nada. Aunque cambiar a C++ puede ser más económico - dependiendo
	de sus restricciones
	<sup>[<a id="idp3961328" href="#ftn.idp3961328" class="footnote">31</a>]</sup> - como las alternativas de la POO para un equipo de
	programadores de C (y probablemente para programadores en otros
	lenguajes procedurales), no es gratis, y hay obstáculos que
	debería conocer antes de intentar comunicar el cambio a C++
	dentro de su compañía y embarcarse en el cambio usted mismo.
      </p><div class="sect3" title="Costes iniciales"><div class="titlepage"><div><div><h4 class="title"><a id="idp3962608"></a>Costes iniciales</h4></div></div></div><p>
	  El coste del cambio a C++ es más que solamente la adquisición
	  de compiladores C++ (el compilador GNU de C++, uno de los
	  mejores, es libre y gratuito). Sus costes a medio y largo
	  plazo se minimizarán si invierte en formación (y posiblemente
	  un mentor para su primer proyecto) y también si identifica y
	  compra librerías de clases que resuelvan su problema más que
	  intentar construir las librerías usted mismo. Hay costes que
	  se deben proponer en un proyecto realista. Además, están los
	  costes ocultos en pérdidas de productividad mientras se
	  aprende el nuevo lenguaje y posiblemente un nuevo entorno de
	  programación. Formar y orientar puede minimizar ese efecto,
	  pero los miembros del equipo deben superar sus propios
	  problemas para entender la nueva tecnología. A lo largo del
	  proceso ellos cometerán más errores (esto es una ventaja,
	  porque los errores reconocidos son el modo más rápido para
	  aprender) y ser menos productivos. Incluso entonces, con
	  algunos tipos de problemas de programación, las clases
	  correctas y el entorno de programación adecuado, es posible
	  ser más productivo mientras se está aprendiendo C++ (incluso
	  considerando que está cometiendo más errores y escribiendo
	  menos líneas de código por día) que si estuviera usando C.
	</p></div><div class="sect3" title="Cuestiones de rendimiento"><div class="titlepage"><div><div><h4 class="title"><a id="idp3965128"></a>Cuestiones de rendimiento</h4></div></div></div><p>
	  Una pregunta común es, «¿La POO no hace automáticamente mis programas
	  mucho más grandes y lentos?» La respuesta es: «depende». Los
	  lenguajes de POO más tradicionales se diseñaron con experimentación y
	  prototipado rápido más que pensando en la eficiencia. De esta manera,
	  prácticamente garantiza un incremento significativo en tamaño y una disminución
	  en velocidad. C++ sin ambargo, está diseñado teniendo presente la producción de
	  programación. Cuando su objetivo es un prototipado rápido, puede lanzar
	  componentes juntos tan rápido como sea posible ignorando las cuestiones de
	  eficiencia. Si está usando una librerías de otros, normalmente ya están
	  optimizadas por sus vendedores; en cualquier caso no es un problema mientras
	  está en un modo de desarrollo rápido. Cuando tenga el sistema que quiere, si es
	  bastante pequeño y rápido, entonces ya está hecho. Si no, lo puede afinar con
	  una herramienta de perfilado, mire primero las mejoras que puede conseguir
	  aplicando las características que incorpora C++. Si esto no le ayuda, mire las
	  modificaciones que se pueden hacer en la implementación subyacente de modo que
	  no sea necesario cambiar ningún código que utilice una clase
	  particular. Únicamente si ninguna otra cosa soluciona el problema necesitará
	  cambiar el diseño. El hecho de que el rendimiento sea tan crítico en esta fase
	  del diseño es un indicador de que debe ser parte del criterio del diseño
	  principal. FIXME:Usar un desarrollo rápido tiene la ventaja de darse cuenta
	  rápidamente.
	</p><p>
	  Como se mencionó anteriormente, el número dado con más
	  frecuencia para la diferencia en tamaño y velocidad entre C y
	  C++ es 10%, y a menudo menor. Incluso podría conseguir una
	  mejora significativa en tamaño y velocidad cuando usa C++ más
	  que con C porque el diseño que hace para C++ puede ser
	  bastante diferente respecto al que hizo para C.
	</p><p>
	  La evidencia entre las comparaciones de tamaño y velocidad
	  entre C y C++ tienden a ser anecdóticas y es probable que
	  permanezcan así. A pesar de la cantidad de personas que
	  sugiere que una compañía intenta el mismo proyecto usando C y
	  C++, probablemente ninguna compañía quiere perder dinero en el
	  camino a no ser que sea muy grande y esté interesada en tales
	  proyectos de investigación. Incluso entonces, parece que el
	  dinero se puede gastar mejor. Casi universalmente, los
	  programadores que se han cambiado de C (o cualquier otro
	  lenguaje procedural) a C++ (o cualquier otro lenguaje de POO)
	  han tenido la experiencia personal de una gran mejora en su
	  productividad de programación, y es el argumento más
	  convincente que pueda encontrar.
	</p></div><div class="sect3" title="Errores comunes de diseño"><div class="titlepage"><div><div><h4 class="title"><a id="idp112184"></a>Errores comunes de diseño</h4></div></div></div><p>
	  Cuando su equipo empieza con la POO y C++, típicamente los
	  programadores pasan por una serie de errores de diseño
	  comunes. Esto ocurre a menudo porque hay poca realimentación
	  de expertos durante el diseño e implementación de los
	  proyectos iniciales, porque ningún experto ha sido
	  desarrollador dentro de la compañía y puede haber resistencia
	  a contratar consultores. Es fácil pensar que se entiende la
	  POO demasiado pronto en el ciclo y se va por el mal
	  camino. Algo que es obvio para alguien experimentado con el
	  lenguaje puede ser un tema de gran debate interno para un
	  novato. La mayor parte de este trauma se puede olvidar usando
	  un experto externo para enseñar y tutorizar.
	</p><p>
	  Por otro lado, el hecho de que estos errores de diseño son
	  fáciles de cometer, apunta al principal inconveniente de C++:
	  su compatibilidad con C (por supuesto, también es su principal
	  fortaleza). Para llevar a cabo la hazaña de ser capaz de
	  compilar código C, el lenguaje debe cumplir algunos
	  compromisos, lo que ha dado lugar a algunos «rincones
	  oscuros». Esto es una realidad, y comprende gran parte
	  de la curva de aprendizaje del lenguaje. En este libro y en el
	  volumen posterior (y en otros libros; ver el <a class="link" href="#ApendiceC" title="Apéndice C. Lecturas recomendadas">Apéndice C</a>), intento mostrar la
	  mayoría de los obstáculos que probablemente encontrará cuando
	  trabaje con C++. Debería ser consciente siempre de que hay
	  algunos agujeros en la red de seguridad.
	</p></div></div></div><div class="sect1" title="1.13. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp116672"></a>1.13. Resumen</h2></div></div></div><p>
      Este capítulo intenta darle sentido a los extensos usos de la
      programación orientada a objetos y C++, incluyendo el porqué de
      que la POO sea diferente, y porqué C++ en particular es diferente,
      conceptos de metodología de POO, y finalmente los tipos de
      cuestiones que encontrará cuando cambie su propia compañía a POO y
      C++.
    </p><p>
      La POO y C++ pueden no ser para todos. Es importante evaluar sus
      necesidades y decidir si C++ satisfará de forma óptima sus
      necesidades, o si podría ser mejor con otros sistemas de
      programación (incluido el que utiliza actualmente). Si sabe que
      sus necesidades serán muy especializadas en un futuro inmediato y
      tiene restricciones específicas que no se pueden satisfacer con
      C++, entonces debe investigar otras alternativas
      <sup>[<a id="idp118792" href="#ftn.idp118792" class="footnote">32</a>]</sup>.

      Incluso si finalmente elige C++ como su lenguaje, por lo menos
      entenderá qué opciones había y tendrá una visión clara de
      porqué tomó esa dirección.
    </p><p>
      El lector conoce el aspecto de un programa procedural:
      definiciones de datos y llamadas a funciones. Para encontrar el
      significado de un programa tiene que trabajar un poco, revisando
      las llamadas a función y los conceptos de bajo nivel para crear
      un modelo en su mente. Esta es la razón por la que necesitamos
      representaciones intermedias cuando diseñamos programas
      procedurales - por eso mismo, estos programas tienden a ser
      confusos porque los términos de expresión están orientados más
      hacia la computadora que a resolver el problema.
    </p><p>
      Como C++ añade muchos conceptos nuevos al lenguaje C, puede que su
      asunción natural sea que el <code class="function">main()</code> en un
      programa de C++ será mucho más complicado que el equivalente del
      programa en C. En eso, quedará gratamente sorprendido: un programa
      C++ bien escrito es generalmente mucho más simple y mucho más
      sencillo de entender que el programa equivalente en C. Lo que verá
      son las definiciones de los objetos que representan conceptos en
      el espacio de su problema (en lugar de cuestiones de la
      representación en el computador) y mensajes enviados a otros objetos
      para representar las actividades en este espacio. Ese es uno de
      los placeres de la programación orientada a objetos, con un
      programa bien diseñado, es fácil entender el código
      leyéndolo. Normalmente hay mucho menos código, en parte, porque
      muchos de sus problemas se resolverán utilizando código de
      librerías existentes.
    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp3622872" href="#idp3622872" class="para">11</a>] </sup>
	  Ver <em class="citetitle">Multiparadigm Programming in Leda</em>
	  de <span class="personname"><span class="firstname">Timothy</span> <span class="surname">Budd</span></span> (Addison-Wesley 1995).
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3635480" href="#idp3635480" class="para">12</a>] </sup>
          Puede encontrar una implementación interesante de este
          problema en el Volumen 2 de este libro, disponible en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>
        </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3642152" href="#idp3642152" class="para">13</a>] </sup>
          Hay quien hace una distinción, afirmando que <code class="keyword">type</code>
          determina la interfaz mientras <code class="keyword">class</code> es una
          implementación particular de esta interfaz.
        </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3658552" href="#idp3658552" class="para">14</a>] </sup>
	  Agradezco este término a mi amigo <span class="personname"><span class="firstname">Scott</span> <span class="surname">Meyers</span></span>.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3676296" href="#idp3676296" class="para">15</a>] </sup>
	  Normalmente esto es suficiente para la mayoría de los
	  diagramas y no necesita especificar si está usando agregación
	  o composición.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3746744" href="#idp3746744" class="para">16</a>] </sup>
	  N. de T: En el libro se utilizará el término original en
	  inglés debido a su uso común, incluso en la literatura en
	  castellano.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3786776" href="#idp3786776" class="para">17</a>] </sup>
	  Un ejemplo excelente es <em class="citetitle">UML Distilled</em>,
	  de <span class="personname"><span class="firstname">Martin</span> <span class="surname">Fowler</span></span> (Addison-Wesley 2000),
	  que reduce el, a menudo, insoportable proceso UML a un
	  subconjunto manejable.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3792104" href="#idp3792104" class="para">18</a>] </sup>
	  Mi regla general para el cálculo de semejantes proyectos: Si
	  hay más de un comodín, no intente planear cuánto tiempo le
	  llevará o cuánto costará hasta que haya creado un prototipo
	  funcional. También hay muchos grados de libertad.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3814744" href="#idp3814744" class="para">19</a>] </sup>
	   Gracias a <span class="personname"><span class="firstname">James</span> <span class="surname">H
	      Jarrett</span></span> por su ayuda.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3832320" href="#idp3832320" class="para">20</a>] </sup>
	    Puede encontar más información sobre casos de uso en
	    <em class="citetitle">Applying Use Cases</em> de
	    <span class="personname"><span class="surname">Schneider</span></span> &amp;
	    <span class="personname"><span class="surname">Winters</span></span>
	    (Addison-Wesley 1998) y <em class="citetitle">Use Case Driven Object
	    Modeling with UML</em> de
	    <span class="personname"><span class="surname">Rosenberg</span></span>
	    (Addison-Wesley 1999).
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3838688" href="#idp3838688" class="para">21</a>] </sup>
	    Últimamente mi idea respeto a esto ha cambiado. Doblar y
	    añadir un 10% puede darle una estimación bastante acertada
	    (asumiendo que no hay demasiados factores comodín), pero
	    debe trabajar con bastante diligencia para acabar a
	    tiempo. Si realmente quiere tiempo para hacerlo de forma
	    elegante y estar orgulloso del proceso, el multiplicador
	    correcto es más bien tres o cuatro veces, creo yo.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3851328" href="#idp3851328" class="para">22</a>] </sup>
	    Para novatos, recomiendo el mencionado <em class="citetitle">UML
	    Distilled</em>.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3852640" href="#idp3852640" class="para">23</a>] </sup>
	    Python (<a class="ulink" href="http://www.python.org" target="_top">www.python.org</a>) suele
	      utilizarse como «pseudocódigo ejecutable».
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3882824" href="#idp3882824" class="para">24</a>] </sup>
	    Por lo menos un aspecto de evolución se explica en el libro
	    <span class="emphasis"><em>Refactoring: improving the design of existing
	    code</em></span> (Addison-Wesley 1999) de <span class="personname"><span class="firstname">Martin</span> <span class="surname">Fowler</span></span>. Tenga presente que este libro usa
	    exlusivamente ejemplos en Java.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3886792" href="#idp3886792" class="para">25</a>] </sup>
	    Este término se explica en el capítulo <span class="emphasis"><em>Los
	    patrones de diseño</em></span> en el Volumen 2
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3889048" href="#idp3889048" class="para">26</a>] </sup>
	    Esto es algo como «prototipado rápido», donde
	    se propone construir un borrador de la versión rápida y
	    sucia que se puede utilizar para aprender sobre el sistema,
	    y entonces puede tirar su prototipo y construir el bueno. El
	    problema con el prototipado rápido es que la gente no tiró
	    el prototipo, y construyó sobre él. Combinado
	    con la falta de estructura en la programación procedural,
	    esto producía a menudo sistemas desordenados que eran
	    difíciles de mantener.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3912752" href="#idp3912752" class="para">27</a>] </sup>
	    Aunque esto puede ser una perspectiva americana, las
	    historias de Hollywood llegan a todas partes.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3915192" href="#idp3915192" class="para">28</a>] </sup>
	    Incluyendo (especialmente) el sistema PA. Una vez trabajé en
	    una compañía que insistía en anunciar públicamente cada
	    llamada de teléfono que llegaba a los ejecutivos, y
	    constantemente interrumpía nuestra productividad (pero los
	    directores no concebían el agobio como un servicio
	    importante de PA). Finalmente, cuando nadie miraba empecé a
	    cortar los cables de los altavoces.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3922584" href="#idp3922584" class="para">29</a>] </sup>
	  Dije «puede» porque, debido a la complejidad de
	  C++, realmente podría ser más económico cambiarse a Java. Pero
	  la decisión de qué lenguaje elegir tiene muchos factores, y en
	  este libro asumiré que el lector ha elegido C++.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3932216" href="#idp3932216" class="para">30</a>] </sup>
	    Sin embargo, mire en las columnas de
	    <span class="personname"><span class="firstname">Dan</span> <span class="surname">Saks</span></span> en <em class="citetitle">C/C++
	    User's Journal</em> sobre algunas investigaciones
	    importantes sobre el rendimiento de librerías C++.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3961328" href="#idp3961328" class="para">31</a>] </sup>
	    Para mejora de la productividad, debería considerar también
	    el lenguaje Java.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp118792" href="#idp118792" class="para">32</a>] </sup>
	  En particular, recomiendo mirar Java <a class="ulink" href="http://java.sun.com" target="_top">http://java.sun.com</a> y
	    Python <a class="ulink" href="http://www.python.org" target="_top">http://www.python.org</a>.
	</p></div></div></div><div class="chapter" title="2: Construir y usar objetos"><div class="titlepage"><div><div><h2 class="title"><a id="C02"></a>2: Construir y usar objetos</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp4005800">2.1. El proceso de traducción del lenguaje</a></span></dt><dt><span class="sect1"><a href="#idp4035744">2.2. Herramientas para compilación modular</a></span></dt><dt><span class="sect1"><a href="#idp4114016">2.3. Su primer programa en C++</a></span></dt><dt><span class="sect1"><a href="#idp4165424">2.4. Más sobre iostreams</a></span></dt><dt><span class="sect1"><a href="#idp4187160">2.5. Introdución a las cadenas</a></span></dt><dt><span class="sect1"><a href="#idp4199360">2.6. Lectura y escritura de ficheros</a></span></dt><dt><span class="sect1"><a href="#idp4221360">2.7. Introducción a los vectores</a></span></dt><dt><span class="sect1"><a href="#idp4270736">2.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp4276664">2.9. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Este capítulo presenta la suficiente sintaxis y
      los conceptos de construcción de programas de C++ como para
      permitirle crear y ejecutar algunos programas simples orientados a
      objetos. El siguiente capítulo cubre la sintaxis
      básica de C y C++ en detalle.
    </p></div><p>
    Leyendo primero este capítulo, le cogerá el gustillo a lo que
    supone programar con objetos en C++, y también descubrirá
    algunas de las razones por las que hay tanto entusiasmo
    alrededor de este lenguaje. Debería ser suficiente para
    pasar al <a class="link" href="#C03" title="3: C en C++">Capítulo 3</a>, que puede ser un poco
    agotador debido a que contiene la mayoría de los detalles del
    lenguaje C.
  </p><p>
    Los tipos de datos definidos por el usuario, o
    <span class="emphasis"><em>clases</em></span> es lo que diferencia a C++ de los
    lenguajes procedimentales tradicionales.  Una clase es un nuevo tipo
    de datos que usted o alguna otra persona crea para resolver un
    problema particular. Una vez que se ha creado una clase, cualquiera
    puede utilizarla sin conocer los detalles de su funcionamiento, o
    incluso de la forma en que se han construído.  Este capítulo trata
    las clases como si sólo fueran otro tipo de datos predefinido
    disponible para su uso en programas.
  </p><p>
    Las clases creadas por terceras personas se suelen empaquetar en
    librerías.  Este capítulo usa algunas de las librerías que vienen en
    todas las implementaciones de C++. Una librería especialmente
    importante es FIXME:iostreams, que le permite (entre otras cosas)
    leer desde ficheros o teclado, y escribir a ficheros o
    pantalla. También verá la clase <code class="classname">string</code>, que
    es muy práctica, y el contenedor <code class="classname">vector</code> de la
    Libreria Estándar de C++. Al final del capítulo, verá lo sencillo
    que resulta utilizar una librería de clases predefinida.
  </p><p>
    Para que pueda crear su primer programa debe conocer primero las
    herramientas utilizadas para construir aplicaciones.
  </p><div class="sect1" title="2.1. El proceso de traducción del lenguaje"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4005800"></a>2.1. El proceso de traducción del lenguaje</h2></div></div></div><p>
      Todos los lenguajes de programación se traducen de algo que
      suele ser fácilmente entendible por una persona
      (<span class="emphasis"><em>código fuente</em></span>) a algo que es ejecutado
      por una computadora (<span class="emphasis"><em>código máquina</em></span>). Los
      traductores se dividen tradicionalmente en dos
      categorías: <span class="emphasis"><em>intérpretes</em></span> y
      <span class="emphasis"><em>compiladores</em></span>.
    </p><div class="sect2" title="2.1.1. Intérpretes"><div class="titlepage"><div><div><h3 class="title"><a id="idp4007672"></a>2.1.1. Intérpretes</h3></div></div></div><p>
	Un intérprete traduce el código fuente en actividades (las
	cuales pueden comprender grupos de instrucciones máquina) y
	ejecuta inmediatamente estas actividades.  El BASIC, por
	ejemplo, fue un lenguaje interpretado bastante popular. Los
	intérpretes de BASIC tradicionales traducen y ejecutan una línea
	cada vez, y después olvidan la línea traducida. Esto los hace
	lentos debido a que deben volver a traducir cualquier código que
	se repita. BASIC también ha sido compilado para ganar en
	velocidad. La mayoría de los intérpretes modernos, como los de
	Python, traducen el programa entero en un lenguaje intermedio
	que es ejecutable por un intérprete mucho más
	rápido
	<sup>[<a id="idp4009528" href="#ftn.idp4009528" class="footnote">33</a>]</sup>.
      </p><p>
	Los intérpretes tienen muchas ventajas. La transición del
	código escrito al código ejecutable es casi inmediata, y el
	código fuente está siempre disponible, por lo que el intérprete
	puede ser mucho más específico cuando ocurre un error. Los
	beneficios que se suelen mencionar de los intérpretes es la
	facilidad de interacción y el rápido desarrollo (pero no
	necesariamente ejecución) de los programas.
      </p><p>
	Los lenguajes interpretados a menudo tienen severas limitaciones
	cuando se construyen grandes proyectos (Python parece ser una
	excepción). El intérprete (o una versión reducida) debe estar
	siempre en memoria para ejecutar el código e incluso el
	intérprete más rápido puede introducir restricciones de
	velocidad inaceptables. La mayoría de los intérpretes requieren
	que todo el código fuente se les envíe de una sola vez. Esto no
	sólo introduce limitaciones de espacio, sino que puede causar
	errores difíciles de detectar si el lenguaje no incluye
	facilidades para localizar el efecto de las diferentes porciones
	de código.
      </p></div><div class="sect2" title="2.1.2. Compiladores"><div class="titlepage"><div><div><h3 class="title"><a id="idp4012512"></a>2.1.2. Compiladores</h3></div></div></div><p>
	Un compilador traduce el código fuente directamente a
	lenguaje ensamblador o instrucciones máquina. El producto final
	suele ser uno o varios ficheros que contienen código
	máquina. La forma de realizarlo suele ser un proceso que
	consta de varios pasos. La transición del código escrito al
	código ejecutable es significativamente más larga con un
	compilador.
      </p><p>
        Dependiendo de la perspicacia del escritor del compilador, los
        programas generados por un compilador tienden a requerir mucho
        menos espacio para ser ejecutados, y se ejecutan mucho más
        rápido. Aunque el tamaño y la velocidad son probablemente las
        razones más citadas para usar un compilador, en muchas
        situaciones no son las más importantes. Algunos lenguajes (como
        el C) están diseñados para admitir trozos de programas
        compilados independientemente. Estas partes terminan combinando
        en un programa <span class="emphasis"><em>ejecutable</em></span> final mediante
        una herramienta llamada <span class="emphasis"><em>enlazador</em></span>
        (<span class="foreignphrase"><em class="foreignphrase">linker</em></span>). Este proceso se
        conoce como <span class="emphasis"><em>compilación separada</em></span>.
      </p><p>
	La compilación separada tiene muchos beneficios. Un programa
	que, tomado de una vez, excedería los límites del compilador o
	del entorno de compilación puede ser compilado por piezas. Los
	programas se pueden ser construir y probar pieza a pieza.  Una
	vez que una parte funciona, se puede guardar y tratarse como un
	bloque. Los conjuntos de piezas ya funcionales y probadas se
	pueden combinar en <span class="emphasis"><em>librerías</em></span> para que otros
	programadores puedan usarlos. Como se crean piezas, la
	complejidad de las otras piezas se mantiene oculta.  Todas estas
	características ayudan a la creación de programas grandes,
	<sup>[<a id="idp4017192" href="#ftn.idp4017192" class="footnote">34</a>]</sup>.
      </p><p>
	Las características de depuración del compilador han mejorado
	considerablemente con el tiempo. Los primeros compiladores
	simplemente generaban código máquina, y el programador insertaba
	sentencias de impresión para ver qué estaba ocurriendo, lo que
	no siempre era efectivo. Los compiladores modernos pueden
	insertar información sobre el código fuente en el programa
	ejecutable. Esta información se usa por poderosos
	<span class="emphasis"><em>depuradores a nivel de código</em></span> que muestran
	exactamente lo que pasa en un programa rastreando su progreso
	mediante su código fuente.
      </p><p>
	Algunos compiladores solucionan el problema de la velocidad
	de compilación mediante <span class="emphasis"><em>compilación en
	  memoria</em></span>. La mayoría de los compiladores trabajan
	con ficheros, leyéndolos y escribiéndolos en cada paso de
	los procesos de compilación. En la compilación en memoria el
	compilador se mantiene en RAM. Para programas pequeños,
	puede parecerse a un intérprete.
      </p></div><div class="sect2" title="2.1.3. El proceso de compilación"><div class="titlepage"><div><div><h3 class="title"><a id="idp4020408"></a>2.1.3. El proceso de compilación</h3></div></div></div><p>
	Para programar en C y en C++, es necesario entender los
	pasos y las herramientas del proceso de compilación. Algunos
	lenguajes (C y C++, en particular) empiezan la compilación
	ejecutando un <span class="emphasis"><em>preprocesador</em></span> sobre el código
	fuente. El preprocesador es un programa simple que sustituye
	patrones que se encuentran en el código fuente con otros que
	ha definido el programador (usando las <span class="emphasis"><em>directivas
	  de preprocesado</em></span>). Las directivas de
	preprocesado se utilizan para ahorrar escritura y para aumentar
	la legilibilidad del código (posteriormente en este libro,
	aprenderá cómo el diseño de C++ desaconseja en gran medida el uso
	del preprocesador, ya que puede causar errores sutiles). El
	código preprocesado se suele escribir en un fichero
	intermedio.
      </p><p>
	Normalmente, los compiladores hacen su trabajo en dos
	pasadas. La primera pasada consiste en analizar sintácticamente
	el código generado por el preprocesador. El compilador trocea
	el código fuente en pequeñas partes y lo organiza en una
	estructura llamada <span class="emphasis"><em>árbol</em></span>. En la
	expresión FIXME:«A+B», los elementos
	«A», «+», «B» son
	hojas del árbol.
      </p><p>
	A menudo se utiliza un <span class="emphasis"><em>optimizador global</em></span>
	entre el primer y el segundo paso para producir código más
	pequeño y rápido.
      </p><p>
	En la segunda pasada, el <span class="emphasis"><em>generador de código</em></span>
	  recorre el árbol sintáctico y genera lenguaje ensamblador o
	  código máquina para los nodos del árbol. Si el generador de
	  código crea lenguaje ensamblador, entonces se debe ejecutar el
	  programa ensamblador. El resultado final en ambos casos es un
	  módulo objeto (un fichero que típicamente tiene una extensión
	  de <code class="filename">.o</code> o <code class="filename">.obj</code>. A
	  veces se utiliza un <span class="emphasis"><em>optimizador de
	  mirilla</em></span> en esta segunda pasada para buscar trozos de
	  código que contengan sentencias redundantes de lenguaje
	  ensamblador.
      </p><p>
	Usar la palabra «objeto» para describir pedazos de
	código máquina es un hecho desafortunado. La palabra comenzó a
	usarse antes de que la programación orientada a objetos tuviera
	un uso generalizado. «Objeto» significa lo mismo
	que «FIXME:meta» en este contexto, mientras que en la
	programación orientada a objetos significa «una cosa con
	límites».
      </p><p>
	El <span class="emphasis"><em>enlazador</em></span> combina una lista de módulos
	objeto en un programa ejecutable que el sistema operativo puede
	cargar y ejecutar. Cuando una función en un módulo objeto hace
	una referencia a una función o variable en otro módulo objeto,
	el enlazador resuelve estas referencias; se asegura de que todas
	las funciones y los datos externos solicitados durante el
	proceso de compilación existen realmente. Además, el enlazador
	añade un módulo objeto especial para realizar las actividades de
	inicialización.
      </p><p>
	El enlazador puede buscar en unos archivos especiales llamados
	<span class="emphasis"><em>librerías</em></span> para resolver todas sus
	referencias. Una librería contiene una colección de módulos
	objeto en un único fichero. Una librería se crea y mantiene por
	un programa conocido como <span class="emphasis"><em>bibliotecario</em></span>
	(<span class="foreignphrase"><em class="foreignphrase">librarian</em></span>).
      </p><div class="sect3" title="Comprobación estática de tipos"><div class="titlepage"><div><div><h4 class="title"><a id="idp4031280"></a>Comprobación estática de tipos</h4></div></div></div><p>
	  El compilador realiza una <span class="emphasis"><em>comprobación de
	  tipos</em></span> durante la primera pasada. La comprobación de
	  tipos asegura el correcto uso de los argumentos en las
	  funciones y previene muchos tipos de errores de
	  programación. Como esta comprobación de tipos ocurre se hace
	  la compilación y no cuando el programa se está ejecutado, se
	  conoce como <span class="emphasis"><em>comprobación estática de
	  tipos</em></span>.
	</p><p>
	  Algunos lenguajes orientados a objetos (Java por ejemplo)
	  realizan comprobaciones en tiempo de ejecución
	  (<span class="emphasis"><em>comprobación dinámica de tipos</em></span>). Si se
	  combina con la estática, la comprobación dinámica es más
	  potente que sólo la estática. Sin embargo, añade una
	  sobrecarga a la ejecución del programa.
	</p><p>
	  C++ usa la comprobación estática de tipos debido a que el
	  lenguaje no puede asumir ningún soporte particular durante la
	  ejecución. La comprobación estática de tipos notifica al
	  programador malos usos de los tipos durante la compilación, y
	  así maximiza la velocidad de ejecución. A medida que aprenda
	  C++, comprobará que la mayoría de las decisiones de diseño del
	  lenguaje están tomadas en favor de la mejora del rendimiento,
	  motivo por el cual C es famoso en la programación orientada a
	  la producción.
	</p><p>
	  Se puede deshabilitar la comprobación estática de tipos en
	  C++, e incluso permite al programador usar su propia
	  comprobación dinámica de tipos - simplemente necesita escribir
	  el código.
	</p></div></div></div><div class="sect1" title="2.2. Herramientas para compilación modular"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4035744"></a>2.2. Herramientas para compilación modular</h2></div></div></div><p>
      La compilación modular es particularmente importante cuando se
      construyen grandes proyectos. En C y en C++, un programa se puede
      crear en pequeñas piezas, manejables y comprobables de forma
      independiente. La herramienta más importante para dividir un
      programa en piezas más pequeñas es la capacidad de crear
      subrutinas o subprogramas que tengan un nombre que las
      identifique. En C y en C++, estos subprogramas se llamana
      <span class="emphasis"><em>funciones</em></span>, que son las piezas de código que
      se pueden almacenar en diferentes ficheros, permitiendo la
      compilación separada. Dicho de otra forma, una función es la
      unidad atómica de código, debido a que no se puede tener una parte
      de una función en un fichero y el resto en otro (aunque los
      ficheros pueden contener más de una función).
    </p><p>
      Cuando se invoca una función, se le suelen pasar una serie de
      <span class="emphasis"><em>argumentos</em></span>, que son valores que desea que la
      función utilice durante su ejecución. Cuando la función termina,
      normalmente devuelve un <span class="emphasis"><em>valor de retorno</em></span>,
      que equivale al resultado. También es posible crear funciones que
      no tengan ni argumentos ni valor de retorno.
    </p><p>
      Para crear un programa con múltiples ficheros, las funciones de un
      fichero deben acceder a las funciones y los datos de otros
      ficheros. Cuando se compila un fichero, el compilador de C o C++
      debe conocer las funciones y los datos de los otros ficheros, en
      particular sus nombres y su uso apropiado. El compilador asegura
      que las funciones y los datos son usados correctamente. El proceso
      de "decirle al compilador" los nombres de las funciones externas y
      los datos que necesitan es conocido como
      <span class="emphasis"><em>declaración</em></span>.  Una vez declarada una función o
      una variable, el compilador sabe cómo comprobar que la función se
      utiliza adecuadamente.
    </p><div class="sect2" title="2.2.1. Declaraciones vs definiciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp4040496"></a>2.2.1. Declaraciones vs definiciones</h3></div></div></div><p>
      	Es importante comprender la diferencia entre
        <span class="emphasis"><em>declaraciones</em></span> y
        <span class="emphasis"><em>definiciones</em></span> porque estos términos se
        usarán de forma precisa en todo el libro. Básicamente todos los
        programas escritos en C o en C++ requieren declaraciones. Antes
        de poder escribir su primer programa, necesita comprender la
        manera correcta de escribir una declaración.
      </p><p>
	Una <span class="emphasis"><em>declaración</em></span> presenta un nombre
	-identificador- al compilador. Le dice al compilador «Esta
	función o esta variable existe en algún lugar, y éste es el
	aspecto que debe tener». Una
	<span class="emphasis"><em>definición</em></span>, sin embargo, dice: «Crea
	esta variable aquí» o «Crea esta función
	aquí». Eso reserva memoria para el nombre. Este
	significado sirve tanto para una variable que para una función;
	en ambos casos, el compilador reserva espacio en el momento de
	la definición. Para una variable, el compilador determina su
	tamaño y reserva el espacio en memoria para contener los datos
	de la variable. Para una función, el compilador genera el código
	que finalmente ocupará un espacio en memoria.
      </p><p>
	Se puede declarar una variable o una función en muchos sitios diferentes, pero en
	C o en C++ sólo se puede definir una vez (se conoce a veces como Regla de
	Definición Única (ODR)
	<sup>[<a id="idp4044984" href="#ftn.idp4044984" class="footnote">35</a>]</sup>). Cuando el enlazador une todos los módulos objeto,
	normalmente se quejará si encuentra más de una definición para
	la misma función o variable.
      </p><p>
	Una definición puede ser también una declaración. Si el
	compilador no ha visto antes el nombre <code class="varname">x</code> y
	hay una definición <code class="code">int x;</code>, el compilador ve el
	nombre también como una declaración y asigna memoria al mismo
	tiempo.
      </p><div class="sect3" title="Sintaxis de declaración de funciones"><div class="titlepage"><div><div><h4 class="title"><a id="idp4047008"></a>Sintaxis de declaración de funciones</h4></div></div></div><p>
	  La declaración de una función en C y en C++ consiste en
	  escribir el nombre de la función, los tipos de argumentos que
	  se pasan a la función, y el valor de retorno de la misma. Por
	  ejemplo, aquí tenemos la declaración de una función llamada
	  <code class="function">func1()</code> que toma dos enteros como
	  argumentos (en C/C++ los enteros se denotan con la palabra
	  reservada <code class="type">int</code>) y que devuelve un entero:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">);</span>
</pre><p>
	  La primera palabra reservada es el valor de retorno:
	  <code class="literal">int</code>. Los argumentos están encerrados
	  entre paréntesis después del nombre de la función en el
	  orden en que se utilizan. El punto y coma indica el final
	  de la sentencia; en este caso le dice al compilador
	  «esto es todo - ¡aquí no está la definición de la
	    función!».
	</p><p>
	  Las declaraciones en C y C++ tratan de mimetizar la forma en
	  que se utilizará ese elemento. Por ejemplo, si
	  <code class="varname">a</code> es otro entero la función de arriba se
	  debería usar de la siguiente manera:
	</p><pre class="programlisting">
a <span class="hl opt">=</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span>
</pre><p>
	  Como <code class="function">func1()</code> devuelve un entero, el
	  compilador de C/C++ comprobará el uso de
	  <code class="function">func1()</code> para asegurarse que
	  <code class="varname">a</code> puede aceptar el valor devuelto y que
	  los argumentos son válidos.
	</p><p>
	  Los argumentos de las declaraciones de funciones pueden tener
	  nombres. El compilador los ignora pero pueden ser útilies como
	  nemotécnicos para el usuario. Por ejemplo, se puede declarar
	  <code class="function">func1()</code> con una apariencia diferente pero
	  con el mismo significado:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> length<span class="hl opt">,</span> <span class="hl kwb">int</span> width<span class="hl opt">);</span>
</pre></div><div class="sect3" title="Una puntualización"><div class="titlepage"><div><div><h4 class="title"><a id="idp4054416"></a>Una puntualización</h4></div></div></div><p>
	  Existe una diferencia significativa entre C y el C++
	  para las funciones con lista de argumentos vacía. En C, la
	  declaración:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func2</span><span class="hl opt">();</span>
</pre><p>
	  significa «una funcion con cualquier número y tipo de
	  argumentos», lo cual anula la comprobación de tipos. En
	  C++, sin embargo, significa «una función sin
	  argumentos».
	</p></div><div class="sect3" title="Definición de funciones"><div class="titlepage"><div><div><h4 class="title"><a id="idp4056616"></a>Definición de funciones</h4></div></div></div><p>
	  La definición de funciones se parece a la declaración
	  excepto en que tienen cuerpo. Un cuerpo es un conjunto de
	  sentencias encerradas entre llaves. Las llaves indican el
	  comienzo y el final del código. Para dar a
	  <code class="function">func1()</code> una definición con un cuerpo
	  vacío (un cuerpo que no contiene código), escriba:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> ancho<span class="hl opt">,</span> <span class="hl kwb">int</span> largo<span class="hl opt">) {}</span>
</pre><p>
	  Note que en la definición de la función las llaves
	  sustituyen el punto y coma. Como las llaves contienen una
	  sentencia o grupo de sentencias, no es necesario un punto
	  y coma. Tenga en cuenta además que los argumentos en la
	  definición de la función deben nombres si los
	  quiere usar en el cuerpo de la función (como aquí no se
	  usan, son opcionales).
	</p></div><div class="sect3" title="Sintaxis de declaración de variables"><div class="titlepage"><div><div><h4 class="title"><a id="idp4059448"></a>Sintaxis de declaración de variables</h4></div></div></div><p>
	  El significado atribuido a la frase «declaración de
	  variables» históricamente ha sido confuso y
	  contradictorio, y es importante que entienda el significado
	  correcto para poder leer el código correctamente. Una
	  declaración de variable dice al compilador cómo es la
	  variable. Dice al compilador, «Sé que no has visto este
	  nombre antes, pero te prometo que existe en algún lugar, y que
	  es una variable de tipo X».
	</p><p>
	  En una declaración de función, se da un tipo (el valor de
	  retorno), el nombre de la función, la lista de argumentos, y
	  un punto y coma. Con esto el compilador ya tiene suficiente
	  información para saber cómo será la función. Por inferencia,
	  una declaración de variable consistirá en un tipo seguido por
	  un nombre. Por ejemplo:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> a<span class="hl opt">;</span>
</pre><p>
	  podría declarar la variable <code class="varname">a</code> como un
	  entero usando la lógica usada anteriormente. Pero aquí está el
	  conflicto: existe suficiente información en el código anterior
	  como para que el compilador pueda crear espacio para un entero
	  llamado <code class="varname">a</code> y es exactamente lo que
	  ocurre. Para resolver el dilema, fue necesaria una palabra
	  reservada en C y C++ para decir «Esto es sólo una
	  declaración; esta variable estará definida en algún otro
	  lado». La palabra reservada es <code class="keyword">extern</code> que
	  puede significar que la definición es externa al fichero, o
	  que la definición se encuentra después en este fichero.
	</p><p>
	  Declarar una variable sin definirla implica usar la palabra
	  reservada <code class="keyword">extern</code> antes de una descripción de la
	  variable, como por ejemplo:
	</p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> a<span class="hl opt">;</span>
</pre><p>
	  <code class="keyword">extern</code> también se puede aplicar a la declaración de
	  funciones. Para <code class="function">func1()</code> sería algo así:
	</p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> length<span class="hl opt">,</span> <span class="hl kwb">int</span> width<span class="hl opt">);</span>
</pre><p>
	  Esta sentencia es equivalente a las declaraciones anteriores
	  para <code class="function">func1()</code> . Como no hay cuerpo de
	  función, el compilador debe tratarla como una declaración de
	  función en lugar de como definición. La palabra reservada
	  <code class="keyword">extern</code> es bastante superflua y opcional para la
	  declaración de funciones. Probablemente sea desafortunado que
	  los diseñadores de C no obligaran al uso de <code class="keyword">extern</code>
	  para la declaración de funciones; hubiera sido más consistente
	  y menos confuso (pero hubiera requerido teclear más, lo cual
	  probablemente explica la decisión).
	</p><p>
	  Aquí hay algunos ejemplos más de declaraciones:
	</p><div class="example"><a id="idp4070272"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Declare.cpp</span>
<span class="hl slc">// Declaration &amp; definition examples</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> i<span class="hl opt">;</span> <span class="hl slc">// Declaration without definition</span>
<span class="hl kwc">extern</span> <span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">);</span> <span class="hl slc">// Function declaration</span>

<span class="hl kwb">float</span> b<span class="hl opt">;</span>  <span class="hl slc">// Declaration &amp; definition</span>
<span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">float</span> a<span class="hl opt">) {</span>  <span class="hl slc">// Definition</span>
  <span class="hl kwa">return</span> a <span class="hl opt">+</span> <span class="hl num">1.0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> i<span class="hl opt">;</span> <span class="hl slc">// Definition</span>
<span class="hl kwb">int</span> <span class="hl kwd">h</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl slc">// Declaration &amp; definition</span>
  <span class="hl kwa">return</span> x <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  b <span class="hl opt">=</span> <span class="hl num">1.0</span><span class="hl opt">;</span>
  i <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
  <span class="hl kwd">h</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.1. C02/Declare.cpp</strong></p></div><br class="example-break" /><p>
          En la declaración de funciones, los identificadores de los argumentos
          son opcionales. En la definición son necesarios (los identificadores
          se requieren solamente en C, no en C++).
        </p></div><div class="sect3" title="Incluir ficheros de cabecera"><div class="titlepage"><div><div><h4 class="title"><a id="idp4072280"></a>Incluir ficheros de cabecera</h4></div></div></div><p>
          La mayoría de las librerías contienen un número importante de
          funciones y variables. Para ahorrar trabajo y asegurar la
          consistencia cuando se hacen declaraciones externas para estos
          elementos, C y C++ utilizan un artefacto llamado
          <span class="emphasis"><em>fichero de cabecera</em></span>. Un fichero de
          cabecera es un fichero que contiene las declaraciones externas
          de una librería; convencionalmente tiene un nombre de fichero
          con extensión <code class="filename">.h</code>, como
          <code class="filename">headerfile.h</code> (no es difícil encontrar
          código más antiguo con extensiones diferentes, como
          <code class="filename">.hxx</code> o <code class="filename">.hpp</code>, pero es
          cada vez más raro).
        </p><p>
          El programador que crea la librería proporciona el fichero de
          cabecera. Para declarar las funciones y variables externas de
          la librería, el usuario simplemente incluye el fichero de
          cabecera. Para ello se utiliza la directiva de preprocesado
          <code class="keyword">#include</code>. Eso le dice al preprocesador que abra el
          fichero de cabecera indicado e incluya el contenido en el
          lugar donde se encuentra la sentencia <code class="keyword">#include</code>. Un
          <code class="keyword">#include</code> puede indicar un fichero de dos maneras:
          mediante paréntesis angulares ( &lt; &gt; ) o comillas dobles.
	</p><p>
          Los ficheros entre paréntesis angulares, como:
        </p><pre class="programlisting">
<span class="hl ppc">#include &lt;header&gt;</span>
</pre><p>
          hacen que el preprocesador busque el fichero como si fuera
          particular a un proyecto, aunque normalmente hay un camino de
          búsqueda que se especifica en el entorno o en la línea de
          comandos del compilador. El mecanismo para cambiar el camino
          de búsqueda (o ruta) varía entre maquinas, sistemas
          operativos, e implementaciones de C++ y puede que requiera un
          poco de investigación por parte del programador.
        </p><p>
          Los ficheros entre comillas dobles, como:
        </p><pre class="programlisting">
<span class="hl ppc">#include</span> <span class="hl pps">&quot;header&quot;</span><span class="hl ppc"></span>
</pre><p>
          le dicen al preprocesador que busque el fichero en (de acuerdo a la
          especificación) «un medio de definición de
          implementación», que normalmente significa buscar el fichero de
          forma relativa al directorio actual. Si no lo encuentra, entonces la
          directiva se preprocesada como si tuviera paréntesis angulares
          en lugar de comillas.
        </p><p>
          Para incluir el fichero de cabecera
          <code class="filename">iostream</code>, hay que escribir:
        </p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
</pre><p>
          El preprocesador encontrará el fichero de cabecera
          <code class="filename">iostream</code> (a menudo en un subdirectorio llamado
          «include») y lo incluirá.
        </p></div><div class="sect3" title="Formato de inclusión del estándar C++"><div class="titlepage"><div><div><h4 class="title"><a id="idp4083640"></a>Formato de inclusión del estándar C++</h4></div></div></div><p>
	  A medida que C++ evolucionaba, los diferentes fabricantes de
	  compiladores elegían diferentes extensiones para los nombres
	  de ficheros. Además, cada sistema operativo tiene sus propias
	  restricciones para los nombres de ficheros, en particular la
	  longitud. Estas características crearon problemas de
	  portabilidad del código fuente. Para limar estos problemas, el
	  estándar usa un formato que permite los nombres de ficheros
	  más largos que los famosos ocho caracteres y permite eliminar
	  la extensión. Por ejemplo en vez de escribir
	  <code class="filename">iostream.h</code> en el estilo antiguo, que se
	  asemejaría a algo así:
	</p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream.h&gt;</span>
</pre><p>
	  ahora se puede escribir:
	</p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
</pre><p>
	  El traductor puede implementar la sentencia del
	  <code class="keyword">include</code> de tal forma que se amolde a las necesidades
	  de un compilador y sistema operativo particular, aunque sea
	  necesario truncar el nombre y añadir una
	  extensión. Evidentemente, también puede copiar las cabeceras
	  que ofrece el fabricante de su compilador a otras sin
	  extensiones si quiere usar este nuevo estilo antes de que su
	  fabricante lo soporte.
	</p><p>
	  Las librerías heredadas de C aún están disponibles con la
	  extensión tradicional
	  «<code class="filename">.h</code>». Sin embargo, se pueden
	  usar con el estilo de inclusión más moderno colocando una
	  «<span class="emphasis"><em>c</em></span>» al nombre. Es decir:
	</p><pre class="programlisting">
<span class="hl ppc">#include &lt;stdio.h&gt;</span>
<span class="hl ppc">#include &lt;stdlib.h&gt;</span>
</pre><p>
	  Se transformaría en:
	</p><pre class="programlisting">
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
</pre><p>
          Y así para todas cabeceras del C Estándar. Eso proporciona al
          lector una distinción interesante entre el uso de librerías C
          versus C++.
	</p><p>
          El efecto del nuevo formato de include no es idéntico al
          antiguo: usar el «<code class="filename">.h</code>» da
          como resultado una versión más antigua, sin plantillas, y
          omitiendo el «<code class="filename">.h</code>» le ofrece
          la nueva versión con plantillas. Normalmente podría tener
          problemas si intenta mezclar las dos formas de inclusión en un
          mismo programa.
        </p></div></div><div class="sect2" title="2.2.2. Enlazado"><div class="titlepage"><div><div><h3 class="title"><a id="idp4092592"></a>2.2.2. Enlazado</h3></div></div></div><p>
        El enlazador (<span class="foreignphrase"><em class="foreignphrase">linker</em></span>) agrupa los
        módulos objeto (que a menudo tienen extensiones como
        <code class="filename">.o</code> ó <code class="filename">.obj</code>), generados
        por el compilador, en un programa ejecutable que el sistema
        operativo puede cargar y ejecutar. Es la última fase del proceso
        de compilación.
      </p><p>
        Las características del enlazador varían de un sistema a
        otro. En general, simplemente se indican al enlazador los
        nombres de los módulos objeto, las librerías que se desean
        enlazar y el nombre del ejecutable de salida. Algunos sistemas
        requieren que sea el programador el que invoque al enlazador,
        aunque en la mayoría de los paquetes de C++ se llama al
        enlazador a través del compilador. En muchas situaciones, de
        manera transparente.
      </p><p>
        Algunos enlazadores antiguos no buscaban ficheros objeto más de
        una vez y buscaban en la lista que se les pasaba de izquierda a
        derecha. Esto significa que el orden de los ficheros objeto y
        las librerías puede ser importante. Si se encuentra con algún
        problema misterioso que no aparece hasta el proceso de enlazado,
        una posible razón es el orden en el que se indican los ficheros
        al enlazador.
      </p></div><div class="sect2" title="2.2.3. Uso de librerías"><div class="titlepage"><div><div><h3 class="title"><a id="idp4096320"></a>2.2.3. Uso de librerías</h3></div></div></div><p>
        Ahora que ya conoce la terminología básica, puede entender cómo
        utilizar una librería. Para usarla:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            Se incluye el fichero de cabecera de la librería.
          </p></li><li class="listitem"><p>
            Se usan las funciones y las variables de la librería.
          </p></li><li class="listitem"><p>
            Se enlaza la librería junto con el programa ejecutable.
          </p></li></ol></div><p>
        Estos pasos también se aplican cuando los módulos objeto no se combinan
        para formar una librería. Incluir el fichero cabecera y enlazar los
        módulos objeto es la base para la compilación separada en C y en C++.
      </p><div class="sect3" title="Cómo busca el enlazador una librería"><div class="titlepage"><div><div><h4 class="title"><a id="idp4099912"></a>Cómo busca el enlazador una librería</h4></div></div></div><p>
          Cuando se hace una refencia externa a una función o una
          variable en C o C++, al enlazador, una vez encontrada esta
          referencia, puede hacer dos cosas. Si todavía no ha encontrado
          la definición de la función o variable, añade el identificador
          a su lista de «referencias no resueltas». Si el
          enlazador ya había encontrado la definición, se resuelve la
          referencia.
        </p><p>
          Si el enlazador no puede encontrar la definición en la lista
          de módulos objeto, busca en las librerías. Las librerías
          tienen algún tipo de indexación para que el enlazador no
          necesite buscar en todos los módulos objeto en la librería -
          solamente mira en el índice. Cuando el enlazador encuentra una
          definición en una librería, el módulo objeto entero, no sólo
          la definición de la función, se enlaza al programa
          ejecutable. Dese cuenta que no se enlaza la librería completa,
          tan solo el módulo objeto de la librería que contiene la
          definición que se necesita (de otra forma los programas se
          volverían innecesariamente largos). Si se desea minimizar el
          tamaño del programa ejecutable, se debería considerar poner
          una única función en cada fichero fuente cuando se construyan
          librerías propias. Esto requiere más trabajo de edición,
	  <sup>[<a id="idp4103736" href="#ftn.idp4103736" class="footnote">36</a>]</sup> pero puede ser muy útil para el usuario.
        </p><p>
          Debido a que el enlazador busca los ficheros en el orden que
          se le dan, se puede prevenir el uso de una función de una
          librería insertando un fichero con su propia función, usando
          el mismo nombre de función, en la lista antes de que aparezca
          el nombre de la librería. Cuando el enlazador resuelva
          cualquier referencia a esa función encontrando la función
          antes de buscar en la librería, se utilizará su función en
          lugar de la que se encuentra en la librería. Eso también puede
          ser una fuente de errores, y es la clase de cosas que se puede
          evitar usando los espacios de nombres
          (<span class="foreignphrase"><em class="foreignphrase">namespaces</em></span>) de C++.
        </p></div><div class="sect3" title="Añadidos ocultos"><div class="titlepage"><div><div><h4 class="title"><a id="idp4106560"></a>Añadidos ocultos</h4></div></div></div><p>
          Cuando se crea un programa ejecutable en C/C++, ciertos
          elementos se enlazan en secreto. Uno de estos elementos es el
          módulo de arranque, que contiene rutinas de inicialización que
          deben ejecutarse cada vez que arranca un programa C o
          C++. Estas rutinas preparan la pila e inicializan ciertas
          variables del programa.
        </p><p>
          El enlazador siempre busca la librería estándar para las versiones
          compiladas de cualquier función «estándar» llamada en el
          programa. Debido a que se busca siempre en la librería estándar, se
          puede usar cualquier cosa de esta librería simplemente añadiendo a su
          programa la cabecera apropiada; no necesita indicar dónde hay que
          buscar la librería estándar. Las funciones de flujo de entrada-salida
          (iostream), por ejemplo, están en la Librería Estándar de C++. Para
          usarla, sólo debe incluir el fichero de cabecera
          <code class="filename">&lt;iostream&gt;</code>.
        </p><p>
          Si se está usando una librería, se debe añadir explícitamente
          su nombre de ésta a la lista de ficheros manejados por el
          enlazador.
        </p></div><div class="sect3" title="Uso de librerías C plano"><div class="titlepage"><div><div><h4 class="title"><a id="idp4110224"></a>Uso de librerías C plano</h4></div></div></div><p>
          Aunque esté escribiendo código en C++, nada le impide usar
          librerías de C. De hecho, toda la librería de C está incluida
          por defecto en el C++ Estándar. Hay una cantidad tremenda de
          trabajo ya realizado en esas librerías que le pueden ahorrar
          un montón de tiempo.
        </p><p>
          Este libro usará la librería Estándar de C++ cuando sea
          necesario (y por lo tanto la de C), pero sólo se utilizarán
          funciones de la librería <span class="emphasis"><em>estándar</em></span>, para
          asegurar la portabilidad de los programas. En los pocos casos
          en los que las funciones no sean de C++ estándar, se intentará
          que sean funciones compatibles con POSIX. POSIX es un estándar
          basado en el esfuerzo por conseguir la estandarización de
          Unix, que incluye funciones que van más allá del ámbito de las
          librerías de C++. Normalmente puede esperar encontrar
          funciones POSIX en plataformas Unix (en particular,
          GNU/Linux), y a menudo en sistemas DOS/Windows. Por ejemplo,
          si está usando hilos (<span class="foreignphrase"><em class="foreignphrase">threads</em></span>)
          será mejor usar la librería de hilos compatible con POSIX ya
          que su código será más fácil de entender, portar y mantener (y
          la librería de hilos usará los servicios que ofrece el sistema
          operativo, si es que están soportados).
	</p></div></div></div><div class="sect1" title="2.3. Su primer programa en C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4114016"></a>2.3. Su primer programa en C++</h2></div></div></div><p>
      Ahora ya tiene suficientes conocimientos para crear y compilar un
      programa. Este programa usará las clases de <span class="emphasis"><em>flujo de
      entrada-salida</em></span> (<code class="filename">iostream</code>) del C++
      estándar. <code class="filename">iostream</code> es capaz de leer y
      escribir en ficheros o en la entrada y salida estándar (que suele
      ser la consola, pero que puede ser redirigida a ficheros o
      dispositivos). En este programa simple, se usa un objeto
      <code class="classname">stream</code> (flujo) para imprimir un mensaje en
      pantalla.
    </p><div class="sect2" title="2.3.1. Uso de las clases iostream"><div class="titlepage"><div><div><h3 class="title"><a id="idp4116424"></a>2.3.1. Uso de las clases <code class="classname">iostream</code></h3></div></div></div><p>
	Para declarar las funciones y los datos externos que contenga la
	clase <code class="filename">iostream</code> hay que incluir el fichero
	de cabecera de la siguiente manera:
      </p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
</pre><p>
	El primer programa usa el concepto de salida estándar, que
	significa «un lugar de propósito general, al que se le
	pueden enviar cosas». Verá otros ejemplos que utilizan la
	salida estándar de otras formas, pero aquí simplemente usaremos
	la consola. El paquete <code class="filename">iostream</code> define una
	variable (un objeto) llamado <code class="varname">cout</code> de forma
	automática que es capaz de enviar todo tipo de datos a la salida
	estándar.
      </p><p>
	Para enviar datos a la salida estándar, se usa el operador
	<code class="literal">&lt;&lt;</code>.Los programadores de C lo conocen como
	operador de «desplazamiento a la izquierda», que se
	explicará en el siguiente capítulo. Baste decir que el
	desplazamiento a la izquierda no tiene nada que ver con la
	salida. Sin embargo, C++ permite que los operadores sean
	<span class="emphasis"><em>sobrecargados</em></span>. Cuando se sobrecarga un
	operador, se le da un nuevo significado siempre que dicho
	operador se use con un objeto de determinado tipo. Con los
	objetos de <code class="filename">iostream</code>, el operador
	<code class="literal">&lt;&lt;</code> significa «enviar a». Por
	ejemplo:
      </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;howdy!&quot;</span><span class="hl opt">;</span>
</pre><p>
	envía la cadena «howdy!» al objeto llamado
	<code class="varname">cout</code> (que es un diminutivo de «console
	output» (salida por consola).
      </p><p>
	De momento ya hemos visto suficiente sobrecarga de operadores
	como para poder empezar. El <a class="link" href="#C12" title="12: Sobrecarga de operadores">Capítulo
	12</a> cubre la sobrecarga de operadores con detalle.
      </p></div><div class="sect2" title="2.3.2. Espacios de nombres"><div class="titlepage"><div><div><h3 class="title"><a id="idp4124368"></a>2.3.2. Espacios de nombres</h3></div></div></div><p>
	Como se menciona en el <a class="link" href="#C01" title="1: Introducción a los Objetos">Capítulo 1</a>,
	uno de los problemas del lenguaje C es que «nos quedamos
	sin nombres» para funciones e identificadores cuando los
	programas llegan a ser de cierto tamaño. Por supuesto que
	realmente no nos quedamos sin nombres; aunque se hace más
	difícil pensar en nombres nuevos después de un rato. Y todavía
	más importante, cuando un programa alcanza cierto tamaño es
	normal fragmentarlo en trozos más pequeños cada uno de los
	cuales es mantenido por diferentes personas o grupos. Como C
	sólo tiene un ruedo para lidiar con todos los identificadores y
	nombres de función, trae como consecuencia que todos los
	desarrolladores deben tener cuidado de no usar accidentalmente
	los mismos nombres en situaciones en las que pueden ponerse en
	conflicto. Esto se convierte en una pérdida de tiempo, se hace
	tedioso y en último término, es más caro.
      </p><p>
	El C++ Estándar tiene un mecanismo para impedir estas
	colisiones: la palabra reservada <code class="keyword">namespace</code> (espacio de
	nombres). Cada conjunto de definiciones de una librería o
	programa se «envuelve» en un espacio de nombres, y
	si otra definición tiene el mismo nombre, pero está en otro
	espacio de nombres, entonces no se produce colisión.
      </p><p>
	El espacio de nombres es una herramienta útil y conveniente,
	pero su presencia implica que debe saber usarla antes de
	escribir un programa. Si simplemente escribe un fichero de
	cabecera y usa algunas funciones u objetos de esa cabecera,
	probablemente reciba extraños mensajes cuando compile el
	programa, debido a que el compilador no pueda encontrar las
	declaraciones de los elementos del fichero de cabecera. Después
	de ver este mensaje un par de veces se le hará familiar su
	significado (que es: <span class="emphasis"><em>Usted ha incluido el fichero de
	cabecera pero todas las declaraciones están sin un espacio de
	nombres y no le dijo al compilador que quería usar las
	declaraciones en ese espacio de nombres</em></span>).
      </p><p>
	Hay una palabra reservada que le permite decir «quiero
	usar las declaraciones y/o definiciones de este espacio de
	nombres». Esa palabra reservada, bastante apropiada por
	cierto, es <code class="keyword">using</code>. Todas las librerías de C++ Estándar
	están incluidas en un único espacio de nombres, que es
	<code class="literal">std</code> (por «standard»). Como este
	libro usa la librería estándar casi exclusivamente, verá la
	siguiente <span class="emphasis"><em>directiva using</em></span> en casi todos los
	programas.
      </p><pre class="programlisting">
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
</pre><p>
	Esto significa que quiere usar todos los elementos del espacio
	de nombres llamado <code class="literal">std</code>. Después de esta
	sentencia, ya no hay que preocuparse de si su componente o
	librería particular pertenece a un espacio de nombres, porque la
	directiva <code class="keyword">using</code> hace que el espacio de nombres esté
	disponible para todo el fichero donde se escribió la directiva
	<code class="keyword">using</code>.
      </p><p>
	Exponer todos los elementos de un espacio de nombres después de
	que alguien se ha molestado en ocultarlos, parece
	contraproducente, y de hecho, el lector deberá tener cuidado si
	considera hacerlo (como aprenderá más tarde en este libro). Sin
	embargo, la directiva <code class="keyword">using</code> expone solamente los
	nombres para el fichero actual, por lo que no es tan drástico
	como suena al principio. (pero pienselo dos veces antes de
	usarlo en un fichero cabecera, eso <span class="emphasis"><em>es</em></span>
	temerario).
      </p><p>
	Existe una relación entre los espacios de nombres y el modo en
	que se incluyes los ficheros de cabecera. Antes de que se
	estandarizara la nueva forma de inclusión de los ficheros
	cabecera (sin el «<code class="literal">.h</code>» como en
	<code class="code">&lt;iostream&gt;</code>), la manera típica de incluir un
	fichero de cabecera era con el «<code class="literal">.h</code>»
	como en <code class="filename">&lt;iostream.h&gt;</code>. En esa época
	los espacios de nombres tampoco eran parte del lenguaje, por lo
	que para mantener una compatibilidad hacia atrás con el código
	existente, si se escribía:
      </p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream.h&gt;</span>
</pre><p>
	En realidad, significaba:
      </p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
</pre><p>
	Sin embargo en este libro se usará la forma estándar de
	inclusión (sin el «<code class="literal">.h</code>») y
	haciendo explícita la directiva <code class="keyword">using</code>.
      </p><p>
	Por ahora, esto es todo lo que necesita saber sobre los espacios
	de nombres, pero el <a class="link" href="#C10" title="10: Control de nombres">Capítulo 10</a> cubre
	esta materia en profundidad.
      </p></div><div class="sect2" title="2.3.3. Fundamentos de la estructura de los programa"><div class="titlepage"><div><div><h3 class="title"><a id="idp4141880"></a>2.3.3. Fundamentos de la estructura de los programa</h3></div></div></div><p>
	Un programa C o C++ es una colección de variables, definiciones
	de función, y llamada a funciones. Cuando el programa arranca,
	ejecuta el código de inicialización y llama a una función
	especial, «<code class="function">main()</code>», que es
	donde debe colocarse el código principal del programa.
      </p><p>
	Como se mencionó anteriormente, una definición de función consiste en un valor de
	retorno (que se debe especificar en C++), un nombre de función, una lista de
	argumentos, y el código de la función entre llaves. Aquí hay un ejemplo de
	definición de función:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">funcion</span><span class="hl opt">() {</span>
   <span class="hl slc">// Código de la función aquí (esto es un comentario)</span>
<span class="hl opt">}</span>
</pre><p>
	La función de arriba tiene una lista vacía de argumentos y
	un cuerpo que contiene únicamente un comentario.
      </p><p>
	Puede haber varios pares de llaves en la definición de una
	función, pero siempre debe haber al menos dos que envuelvan todo
	el cuerpo de la función. Como <code class="function">main()</code> es una
	función, debe seguir esas reglas. En C++,
	<code class="function">main()</code> siempre devuelve un valor de tipo
	<code class="type">int</code> (entero).
      </p><p>
	C y C++ son lenguajes de formato libre. Con un par de
	excepciones, el compilador ignora los espacios en blanco y los
	saltos de línea, por lo que hay que determinar el final de una
	sentencia. Las sentencias están delimitadas por punto y coma.
      </p><p>
	Los comentarios en C empiezan con <code class="literal">/*</code> y
	finalizan con <code class="literal">*/</code>. Pueden incluir saltos de
	línea. C++ permite este estilo de comentarios y añade la doble
	barra inclinada: <code class="literal">//</code>. La <code class="literal">//</code>
	empieza un comentario que finaliza con el salto de línea. Es más
	útil que <code class="literal">/* */</code> y se usa ampliamente en este
	libro.
      </p></div><div class="sect2" title="2.3.4. «Hello, World!»"><div class="titlepage"><div><div><h3 class="title"><a id="idp4149632"></a>2.3.4. «Hello, World!»</h3></div></div></div><p>
	Y por fin, el primer programa:
      </p><div class="example"><a id="idp4150256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Hello.cpp</span>
<span class="hl slc">// Saying Hello with C++</span>
<span class="hl ppc">#include &lt;iostream&gt;</span> <span class="hl slc">// Stream declarations</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Hello, World! I am &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl num">8</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; Today!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.2. C02/Hello.cpp</strong></p></div><br class="example-break" /><p>
	El objeto <code class="varname">cout</code> maneja una serie de argumentos
	por medio de los operadores <code class="literal">&lt;&lt;</code>, que imprime
	los argumentos de izquierda a derecha. La función especial
	<code class="function">endl</code> provoca un salto de línea. Con los
	iostreams se puede encadenar una serie de argumentos como aquí,
	lo que hace que sea una clase fácil de usar.
      </p><p>
	En C, el texto que se encuentra entre comillas dobles se
	denomina «cadena»
	(<span class="foreignphrase"><em class="foreignphrase">string</em></span>). Sin embargo, la
	librería Estándar de C++ tiene una poderosa clase llamada
	<code class="classname">string</code> para manipulación de texto, por
	lo que usaremos el término más preciso <span class="emphasis"><em>array de
	caracteres</em></span> para el texto que se encuentre entre
	dobles comillas.
      </p><p>
	El compilador pide espacio de memoria para los arrays de
	caracteres y guarda el equivalente ASCII para cada carácter en
	este espacio. El compilador finaliza automáticamente este array
	de caracteres añadiendo el valor 0 para indicar el final.
      </p><p>
	Dentro del array de caracteres, se pueden insertar caracteres
	especiales usando las <span class="emphasis"><em>secuencias de escape</em></span>.
	Consisten en una barra invertida (<code class="literal">\</code>) seguida
	de un código especial. por ejemplo <code class="literal">\n</code>
	significa salto de línea. El manual del compilador o la guía
	concreta de C ofrece una lista completa de secuencia; entre
	otras se incluye: <code class="literal">\t</code> (tabulador),
	<code class="literal">\\</code> (barra invertida), y <code class="literal">\b</code>
	(retroceso).
      </p><p>
	Tenga en cuenta que la sentencia puede continuar en otras
	líneas, y la sentencia completa termina con un punto y coma.
      </p><p>
	Los argumentos de tipo array de caracteres y los números
	constantes están mezclados en la sentencia
	<code class="varname">cout</code> anterior. Como el operador
	<code class="literal">&lt;&lt;</code> está sobrecargado con varios significados
	cuando se usa con <code class="varname">cout</code>, se pueden enviar
	distintos argumentos y <code class="varname">cout</code> se encargará de
	mostrarlos.
      </p><p>
	A lo largo de este libro notará que la primera línea de cada
	fichero es un comentario (empezando normalmente con
	<code class="literal">//</code>), seguido de dos puntos, y la última línea
	de cada listado de código acaba con un comentario seguido de
	«/-». Se trata de una una técnica que uso para
	extraer fácilmente información de los ficheros fuente (el
	programa que lo hace se puede encontrar en el Volumen 2 de este
	libro, en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>). La
	primera línea también tiene el nombre y localización del
	fichero, por lo que se puede localizar fácilmente en los ficheros
	de código fuente del libro (que también se puede descargar de
	<a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>).
      </p></div><div class="sect2" title="2.3.5. Utilizar el compilador"><div class="titlepage"><div><div><h3 class="title"><a id="idp4162624"></a>2.3.5. Utilizar el compilador</h3></div></div></div><p>
	Después de descargar y desempaquetar el código fuente del libro,
	busque el programa en el subdirectorio
	<code class="filename">CO2</code>. Invoque el compilador con
	<code class="filename">Hello.cpp</code> como parámetro. La mayoría de los
	compiladores le abstraen de todo el proceso si el programa
	consta de un único fichero. Por ejemplo, para usar el compilador
	GNU C++ (que está disponible en Internet), escriba:
      </p><pre class="screen">
g++ Hello.cpp
</pre><p>
	Otros compiladores tendrán una sintaxis similar aunque tendrá
	que consultar la documentación para conocer los detalles
	particulares.
      </p></div></div><div class="sect1" title="2.4. Más sobre iostreams"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4165424"></a>2.4. Más sobre iostreams</h2></div></div></div><p>
      Hasta ahora sólo ha visto los aspectos más rudimentarios de las
      clases <code class="filename">iostream</code>. El formateo de salida que
      permiten los iostreams también incluyen características como el
      formateo de números en decimal, octal, y hexadecimal. Aquí tiene
      otro ejemplo del uso de los iostreams:
    </p><div class="example"><a id="idp4166936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Stream2.cpp</span>
<span class="hl slc">// More streams features</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Specifying formats with manipulators:</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a number in decimal: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> dec <span class="hl opt">&lt;&lt;</span> <span class="hl num">15</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;in octal: &quot;</span> <span class="hl opt">&lt;&lt;</span> oct <span class="hl opt">&lt;&lt;</span> <span class="hl num">15</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;in hex: &quot;</span> <span class="hl opt">&lt;&lt;</span> hex <span class="hl opt">&lt;&lt;</span> <span class="hl num">15</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a floating-point number: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl num">3.14159</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;non-printing char (escape): &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwb">char</span><span class="hl opt">(</span><span class="hl num">27</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.3. C02/Stream2.cpp</strong></p></div><br class="example-break" /><p>
      Este ejemplo muestra cómo la clase
      <code class="classname">iostreams</code> imprime números en decimal,
      octal, y hexadecimal usando <span class="emphasis"><em>manipuladores</em></span>
      (los cuales no imprimen nada, pero cambian el estado del flujo de
      salida). El formato de los números en punto flotante lo determina
      automáticamente el compilador. Además, se puede enviar
      cualquier carácter a un objeto <code class="classname">stream</code>
      usando un molde (<span class="foreignphrase"><em class="foreignphrase">cast</em></span>) a
      <code class="type">char</code> (un <code class="type">char</code> es un tipo de datos que
      manipula un sólo carácter). Este molde parece una llamada a
      función: <code class="code">char()</code>, devuelve un valor ASCII. En el
      programa de arriba, el <code class="code">char(27)</code> envía un
      «escape» a <code class="varname">cout</code>.
    </p><div class="sect2" title="2.4.1. Concatenar vectores de caracteres"><div class="titlepage"><div><div><h3 class="title"><a id="idp4171896"></a>2.4.1. Concatenar vectores de caracteres</h3></div></div></div><p>
	Una característica importante del preprocesador de C es la
	<span class="emphasis"><em>concatenación de arrays de caracteres</em></span>.
	Esta característica se usa en algunos de los ejemplos de este
	libro. Si se colocan juntos dos arrays de caracteres
	entrecomillados, sin signos de puntuación entre ellos, el
	compilador los pegará en un único array de caracteres. Esto es
	particularmente útil cuando los listados de código tienen
	restricciones de anchura.
      </p><div class="example"><a id="idp4173504"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Concat.cpp</span>
<span class="hl slc">// Character array Concatenation</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;This is far too long to put on a &quot;</span>
    <span class="hl str">&quot;single line but it can be broken up with &quot;</span>
    <span class="hl str">&quot;no ill effects</span><span class="hl esc">\n</span><span class="hl str">as long as there is no &quot;</span>
    <span class="hl str">&quot;punctuation separating adjacent character &quot;</span>
    <span class="hl str">&quot;arrays.</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.4. C02/Concat.cpp</strong></p></div><br class="example-break" /><p>
	Al principio, el código de arriba puede parecer erróneo porque
	no está el ya familiar punto y coma al final de cada
	línea. Recuerde que C y C++ son lenguajes de formato libre, y
	aunque normalmente verá un punto y coma al final de cada línea,
	el requisito real es que haya un punto y coma al final de cada
	sentencia, por lo que es posible encontrar una sentencia que ocupe
	varias líneas.
      </p></div><div class="sect2" title="2.4.2. Leer de la entrada"><div class="titlepage"><div><div><h3 class="title"><a id="idp4175968"></a>2.4.2. Leer de la entrada</h3></div></div></div><p>
	Las clases <code class="classname">iostream</code> proporcionan la
	habilidad de leer de la entrada. El objeto usado para la entrada
	estándar es <code class="varname">cin</code> (de
	«<span class="foreignphrase"><em class="foreignphrase">console
	input</em></span>»). <code class="varname">cin</code>
	normalmente espera la entrada de la consola, pero esta entrada
	se puede redirigir desde otras fuentes. Un ejemplo de
	redirección se muestra más adelante en este capítulo.
      </p><p>
	El operador que usa <code class="classname">iostream</code> con el
	objeto <code class="varname">cin</code> es <code class="literal">&gt;&gt;</code>. Este
	operador espera como parámetro algún tipo de entrada. Por
	ejemplo, si introduce un parámetro de tipo entero, él espera un
	entero de la consola. Aquí hay un ejemplo:
      </p><div class="example"><a id="idp4179280"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Numconv.cpp</span>
<span class="hl slc">// Converts decimal to octal and hex</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> number<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter a decimal number: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> number<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;value in octal = 0&quot;</span> 
       <span class="hl opt">&lt;&lt;</span> oct <span class="hl opt">&lt;&lt;</span> number <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;value in hex = 0x&quot;</span> 
       <span class="hl opt">&lt;&lt;</span> hex <span class="hl opt">&lt;&lt;</span> number <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.5. C02/Numconv.cpp</strong></p></div><br class="example-break" /><p>
	Este programa convierte un número introducido por el usuario
	en su representación octal y hexadecimal.
      </p></div><div class="sect2" title="2.4.3. Llamar a otros programas"><div class="titlepage"><div><div><h3 class="title"><a id="idp4180992"></a>2.4.3. Llamar a otros programas</h3></div></div></div><p>
	Mientras que el modo típico de usar un programa que lee de la
	entrada estándar y escribe en la salida estándar es dentro de un
	<span class="emphasis"><em>shell script</em></span>
	<span class="productname">Unix</span>™ o en un fichero
	<span class="foreignphrase"><em class="foreignphrase">batch</em></span> de
	<span class="productname">DOS</span>™, cualquier programa se puede
	llamar desde dentro de un programa C o C++ usando la llamada a
	la función estándar <code class="function">system()</code> que está
	declarada en el fichero de cabecera
	<code class="filename">&lt;cstdlib&gt;:</code>.
      </p><div class="example"><a id="idp4183760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:CallHello.cpp</span>
<span class="hl slc">// Call another program</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span> <span class="hl slc">// Declare &quot;system()&quot;</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">system</span><span class="hl opt">(</span><span class="hl str">&quot;Hello&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.6. C02/CallHello.cpp</strong></p></div><br class="example-break" /><p>
	Para usar la función <code class="function">system()</code>, hay que
	pasarle un array de caracteres con la línea de comandos que se
	quiere ejecutar en el prompt del sistema operativo. Puede
	incluir los parámetros que utilizaría en la línea de comandos, y
	el array de caracteres se puede fabricar en tiempo de
	ejecución (en vez de usar un array de caracteres estático como
	se mostraba arriba). El comando se ejecuta y el control vuelve
	al programa.
      </p><p>
	Este programa le muestra lo fácil que es usar C plano en
	C++; sólo incluya la cabecera y utilice la función. Esta
	compatibilidad ascendente entre el C y el C++ es una gran
	ventaja si está aprendiendo C++ y ya tenía conocimientos de
	C.
      </p></div></div><div class="sect1" title="2.5. Introdución a las cadenas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4187160"></a>2.5. Introdución a las cadenas</h2></div></div></div><p>
      Un array de caracteres puede ser bastante útil, aunque está
      bastante limitado. Simplemente son un grupo de caracteres en
      memoria, pero si quiere hacer algo útil, debe manejar todos los
      pequeños detalles. Por ejemplo, el tamaño de un array de
      caracteres es fijo en tiempo de compilación. Si tiene un array de
      caracteres y quiere añadirle más caracteres, tendrá que saber
      mucho sobre ellos (incluso manejo dinámico de memoria, copia de
      array de caracteres, y concatenación) antes de conseguir lo que
      desea. Esta es exactamente la clase de cosas que desearíamos que
      hiciera un objeto por nosotros.
    </p><p>
      La clase <code class="classname">string</code> (cadena) del C++ Estándar
      ha sido diseñada para que se encargue y oculte las manipulaciones
      de bajo nivel de los arrays de caracteres que antes tenía que
      realizar el programador de C. Estas manipulaciones han sido una
      fuente de constantes pérdidas de tiempo y errores desde los
      orígenes del lenguaje C. Aunque hay un capítulo entero dedicado a
      la clase <code class="classname">string</code> en el Volumen 2 de este
      libro, las cadenas son tan importantes y facilitan tanto la vida
      que las presentaré aquí para usarlas lo antes posible en el libro.
    </p><p>
      Para usar las cadenas debe incluir el fichero de cabecera
      <code class="filename">&lt;string&gt;</code>. La clase
      <code class="classname">string</code> se encuentra en el espacio de
      nombres <code class="literal">std</code> por lo que se necesita usar la
      directiva <code class="keyword">using</code>. Gracias a la sobrecarga de operadores,
      la sintaxis del uso de las cadenas es muy intuitiva:
    </p><div class="example"><a id="idp4191768"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:HelloStrings.cpp</span>
<span class="hl slc">// The basics of the Standard C++ string class</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string s1<span class="hl opt">,</span> s2<span class="hl opt">;</span> <span class="hl slc">// Empty strings</span>
  string s3 <span class="hl opt">=</span> <span class="hl str">&quot;Hello, World.&quot;</span><span class="hl opt">;</span> <span class="hl slc">// Initialized</span>
  string <span class="hl kwd">s4</span><span class="hl opt">(</span><span class="hl str">&quot;I am&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Also initialized</span>
  s2 <span class="hl opt">=</span> <span class="hl str">&quot;Today&quot;</span><span class="hl opt">;</span> <span class="hl slc">// Assigning to a string</span>
  s1 <span class="hl opt">=</span> s3 <span class="hl opt">+</span> <span class="hl str">&quot; &quot;</span> <span class="hl opt">+</span> s4<span class="hl opt">;</span> <span class="hl slc">// Combining strings</span>
  s1 <span class="hl opt">+=</span> <span class="hl str">&quot; 8 &quot;</span><span class="hl opt">;</span> <span class="hl slc">// Appending to a string</span>
  cout <span class="hl opt">&lt;&lt;</span> s1 <span class="hl opt">+</span> s2 <span class="hl opt">+</span> <span class="hl str">&quot;!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.7. C02/HelloStrings.cpp</strong></p></div><br class="example-break" /><p>
      Las dos primeras cadenas, <code class="varname">s1</code> y
      <code class="varname">s2</code> empiezan estando vacías, mientras que
      <code class="varname">s3</code> y <code class="varname">s4</code> muestran dos formas
      de inicializar los objetos <code class="classname">string</code> con
      arrays de caracteres (puede inicializar objetos
      <code class="classname">string</code> igual de fácil con otros objetos
      <code class="classname">string</code>).
    </p><p>
      Se puede asignar a un objeto <code class="classname">string</code> usando
      <code class="literal">=</code>. Eso sustituye el contenido previo de la cadena con
      lo que se encuentra en el lado derecho de la asignación, y no hay
      que preocuparse de lo que ocurre con el contenido anterior porque
      se controla automáticamente. Para combinar las cadenas simplemente
      debe usar el operador de suma «+», que tambien le
      permite concatenar cadenas (<code class="classname">strings</code>) con
      arrays de caracteres. Si quiere añadir una cadena o un array de
      caracteres a otra cadena, puede usar el operador
      <code class="literal">+=</code>. Finalmente, dése cuenta que
      <code class="classname">iostream</code> sabe como tratar las cadenas, por
      lo que usted puede enviar una cadena (o una expresión que produzca
      un <code class="classname">string</code>, que es lo que sucede con
      <code class="code">s1 + s2 + "!"</code>&gt;) directamente a
      <code class="varname">cout</code> para imprimirla.
    </p></div><div class="sect1" title="2.6. Lectura y escritura de ficheros"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4199360"></a>2.6. Lectura y escritura de ficheros</h2></div></div></div><p>
      En C, el proceso de abrir y manipular ficheros requería un gran
      conocimiento del lenguaje para prepararle para la complejidad de
      las operaciones. Sin embargo, la librería
      <code class="classname">iostream</code> de C++ proporciona una forma
      simple de manejar ficheros, y por eso se puede presentar mucho
      antes de lo que se haría en C.
    </p><p>
      Para poder abrir un fichero para leer y escribir, debe incluir la
      librería <code class="classname">fstream</code>. Aunque eso implica la
      inclusión automática de la librería
      <code class="classname">iostream</code>, es prudente incluir
      <code class="classname">iostream</code> si planea usar
      <code class="varname">cin</code>, <code class="varname">cout</code>, etc.
    </p><p>
      Para abrir un fichero para lectura, debe crear un objeto
      <code class="classname">ifstream</code> que se usará como
      <code class="varname">cin</code>. Para crear un fichero de escritura, se
      crea un objeto <code class="classname">ofstream</code> que se comporta
      como <code class="varname">cout</code>. Una vez que tiene abierto el fichero
      puede leer o escribir en él como si usara cualquier objeto
      <code class="classname">iostream</code>. Así de simple, que es el objetivo, por
      supuesto.
    </p><p>
      Una de funciones las más útiles de la librería
      <code class="classname">iostream</code> es <code class="function">getline()</code>,
      que permite leer una línea (terminada en nueva línea) y guardarla
      en un objeto <code class="classname">string</code>
      <sup>[<a id="idp4205272" href="#ftn.idp4205272" class="footnote">37</a>]</sup>. El primer argumento es el objeto
      <code class="classname">ifstream</code> del que se va a leer la
      información y el segundo argumento es el objeto
      <code class="classname">string</code>. Cuando termina la llamada a la
      función, el objeto <code class="classname">string</code> contiene la
      línea capturada.
    </p><p>
      Aquí hay un ejemplo que copia el contenido de un fichero en otro.
    </p><div class="example"><a id="idp4207776"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Scopy.cpp</span>
<span class="hl slc">// Copy one file to another, a line at a time</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Scopy.cpp&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Open for reading</span>
  ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;Scopy2.cpp&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Open for writing</span>
  string s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> s<span class="hl opt">))</span> <span class="hl slc">// Discards newline char</span>
    out <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> <span class="hl slc">// ... must add it back</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.8. C02/Scopy.cpp</strong></p></div><br class="example-break" /><p>
      Para abrir los ficheros, únicamente debe controlar los
      nombres de fichero que se usan en la creación de los objetos
      <code class="classname">ifstream</code> y
      <code class="classname">ofstream</code>.
    </p><p>
      Aquí se presenta un nuevo concepto: el bucle
      <code class="keyword">while</code>. Aunque será explicado en detalle en el siguiente
      capítulo, la idea básica consiste en que la expresión entre
      paréntesis que sigue al <code class="keyword">while</code> controla la ejecución de la
      sentencia siguiente (pueden ser múltiples sentencias encerradas
      entre llaves). Mientras la expresión entre paréntesis (en este
      caso <code class="code">getline(in, s)</code> produzca un resultado
      «verdadero», las sentencias controladas por el
      <code class="keyword">while</code> se ejecutarán. <code class="function">getline()</code>
      devuelve un valor que se puede interprer como
      «verdadero» si se ha leido otra línea de forma
      satisfactoria, y «falso» cuando se llega al final de
      la entrada. Eso implica que el <code class="keyword">while</code> anterior
      lee todas las líneas del fichero de entrada y las envía al fichero
      de salida.
    </p><p>
      <code class="function">getline()</code> lee los caracteres de cada línea
      hasta que descubre un salto de línea (el carácter de terminación
      se puede cambiar pero eso no se verá hasta el capítulo sobre
      <code class="classname">iostreams</code> del Volumen 2). Sin embargo,
      descarta el carácter de nueva línea y no lo almacena en el objeto
      <code class="classname">string</code>. Por lo que si queremos copiar el
      fichero de forma idéntica al original, debemos añadir el carácter
      de nueva línea como se muestra arriba.
    </p><p>
      Otro ejemplo interesante es copiar el fichero entero en un único
      objeto <code class="classname">string</code>:
    </p><div class="example"><a id="idp4217040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:FillString.cpp</span>
<span class="hl slc">// Read an entire file into a single string</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;FillString.cpp&quot;</span><span class="hl opt">);</span>
  string s<span class="hl opt">,</span> line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    s <span class="hl opt">+=</span> line <span class="hl opt">+</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.9. C02/FillString.cpp</strong></p></div><br class="example-break" /><p>
      Debido a la naturaleza dinámica de los
      <code class="classname">strings</code>, no hay que preocuparse de la
      cantidad de memoria que hay que reservar para el
      <code class="classname">string</code>. Simplemente hay que añadir cosas y
      el <code class="classname">string</code> irá expandiéndose para dar cabida
      a lo que le introduzca.
    </p><p>
      Una de las cosas agradables de poner el fichero entero en una
      cadena es que la clase <code class="classname">string</code> proporciona
      funciones para la búsqueda y manipulación que le permiten
      modificar el fichero como si fuera una simple línea. Sin embargo,
      tiene sus limitaciones. Por un lado, a menudo, es conveniente
      tratar un fichero como una colección de líneas en vez de un gran
      bloque de texto. Por ejemplo, si quiere añadir numeración de
      líneas es mucho más fácil si tiene un objeto
      <code class="classname">string</code> distinto para cada línea. Para
      realizarlo, necesitamos otro concepto.
    </p></div><div class="sect1" title="2.7. Introducción a los vectores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4221360"></a>2.7. Introducción a los vectores</h2></div></div></div><p>
      Con cadenas, podemos rellenar un objeto
      <code class="classname">string</code> sin saber cuanta memoria se va a
      necesitar. El problema de introducir líneas de un fichero en
      objetos <code class="classname">string</code> es que se sabe cuántas
      cadenas habrá - solamente lo sabemos cuando ya hemos leido el
      fichero entero. Para resolver este problema necesitamos un nuevo
      tipo de datos que pueda crecer automáticamente para contener las
      cadenas que le vayamos introduciendo.
    </p><p>
      De hecho, ¿por qué limitarnos a manejar objetos
      <code class="classname">string</code>? Parece que este tipo de problema -
      no saber la cantidad de cosas a manejar mientras está escribiendo
      el problema - ocurre a menudo. Y este objeto
      «contenedor» podría resultar más útil si pudiera
      manejar <span class="emphasis"><em>cualquier clase de
      objeto</em></span>. Afortunadamente, la Librería Estándar de C++
      tiene una solución: las clases contenedor
      (<span class="foreignphrase"><em class="foreignphrase">container</em></span>). Las clases contenedor
      son uno de los puntos fuertes del Estándar C++.
    </p><p>
      A menudo existe un poco de confusión entre los contenedores y
      los algoritmos en la librería Estándar de C++, y la STL. La
      <span class="foreignphrase"><em class="foreignphrase">Standard Template Library</em></span> fue el
      nombre que usó <span class="personname"><span class="firstname"> Alex</span> <span class="surname">Stepanov</span></span> (que en aquella época
      estaba trabajando en Hewlett-Packard) cuando presentó su
      librería al Comité del Estándar C++ en el encuentro en San
      Diego, California, en la primavera de 1994. El nombre
      sobrevivió, especialmente después de que HP decidiera dejarlo
      disponible para la descarga pública. Posteriormente el comité
      integró las STL en la Librería Estándar de C++ haciendo un gran
      número de cambios. El desarrollo de las STL continúa en Silicon
      Graphics (SGI; ver <a class="ulink" href="http://www.sgi.com/Technology/STL" target="_top">www.sgi.com/Technology/STL)</a>. Las
      SGI STL divergen de la Librería Estándar de C++ en muchos
      detalles sutiles. Aunque es una creencia ampliamente
      generalizada, el C++ Estándar no "incluye" las STL. Puede ser
      confuso debido a que los contenedores y los algoritmos en el C++
      Estándar tienen la misma raíz (y a menudo el mismo nombre) que
      en el SGI STL. En este libro, intentaré decir «la librería
      Estándar de C++» o «Librería Estándar de
      contenedores», o algo similar y eludiré usar el término
      STL.
    </p><p>
      A pesar de que la implementación de los contenedores y algoritmos
      de la Librería Estándar de C++ usa algunos conceptos avanzados,
      que se cubren ampliamente en dos largos capítulos en el segundo
      volumen de este libro, esta librería también puede ser potente sin
      saber mucho sobre ella. Es tan útil que el más básico de los
      contenedores estándar, el <code class="classname">vector</code>, se
      introduce en este capítulo y se usará a lo largo de todo el
      libro. Verá que puede hacer muchas cosas con el
      <code class="classname">vector</code> y no saber cómo está implementado
      (de nuevo, uno de los objetivos de la POO). Los programas que usan
      <code class="classname">vector</code> en estos primeros capítulos del
      libro no son exactamente como los haría un programador
      experimentado, como comprobará en el volumen 2. Aún así,
      encontrará que en la mayoría de los casos el uso que se hace es
      adecuado.
    </p><p>
      La clase <code class="classname">vector</code> es una
      <span class="emphasis"><em>plantilla</em></span>, lo que significa que se puede
      aplicar a tipos de datos diferentes. Es decir, se puede crear un
      <code class="classname">vector</code> de <code class="classname">figuras</code>,
      un <code class="classname">vector</code> de <code class="classname">gatos</code>,
      un <code class="classname">vector</code> de
      <code class="classname">strings</code>, etc. Básicamente, con una
      plantilla se puede crear un vector de «cualquier
      clase». Para decirle al compilador con qué clase trabajará
      (en este caso que va a manejar el vector), hay que poner el nombre
      del tipo deseado entre «llaves angulares». Por lo que
      un <code class="classname">vector</code> de <code class="classname">string</code>
      se denota como <code class="code">vector&lt;string&gt;</code>. Con eso, se crea
      un vector a medida que solamente contendrá objetos
      <code class="classname">string</code>, y recibirá un mensaje de error del
      compilador si intenta poner otra cosa en él.
    </p><p>
      Como el <code class="classname">vector</code> expresa el concepto de
      «contenedor», debe existir una manera de meter cosas
      en él y sacar cosas de él. Para añadir un nuevo elemento al final
      del vector, se una el método
      <code class="function">push_back()</code>. Recuerde que, como es un método,
      hay que usar un '.' para invocarlo desde un objeto particular. La
      razón de que el nombre de la función parezca un poco verboso -
      <code class="function">push_back()</code> en vez de algo más simple como
      <code class="function">put</code> - es porque existen otros contenedores y
      otros métodos para poner nuevos elementos en los contenedores. Por
      ejemplo, hay un <code class="function">insert()</code> para poner algo en
      medio de un contenedor. <code class="classname">vector</code> la soporta
      pero su uso es más complicado y no necesitamos explorarla hasta el
      segundo volumen del libro. También hay un
      <code class="function">push_front()</code> (que no es parte de
      <code class="classname">vector</code>) para poner cosas al principio. Hay
      muchas más funciones miembro en <code class="classname">vector</code> y
      muchos más contenedores en la Librería Estándar, pero le
      sorprenderá ver la de cosas que se pueden hacer con sólo un par de
      características básicas.
    </p><p>
      Así que se pueden introducir elementos en un
      <code class="classname">vector</code> con <code class="function">push_back()</code>
      pero ¿cómo puede sacar esos elementos? La solución es inteligente
      y elegante: se usa la sobrecarga de operadores para que el
      <code class="classname">vector</code> se parezca a un
      <code class="type">array</code>. El array (que será descrito de forma más
      completa en el siguiente capítulo) es un tipo de datos que está
      disponible prácticamente en cualquier lenguaje de programación por
      lo que debería estar familiarizado con él. Los arrays son
      <span class="emphasis"><em>agregados</em></span> lo que significa que consisten en
      un número de elementos agrupados. La característica distintiva de
      un array es que estos elementos tienen el mismo tamaño y están
      organizados uno junto a otro. Y todavía más importante, que se
      pueden seleccionar mediante un índice, lo que significa que puede
      decir: «Quiero el elemento número n» y el elemento
      será producido, normalmente de forma rápida. A pesar de que
      existen excepciones en los lenguajes de programación, normalmente
      se indica la «indexación» mediante corchetes, de tal
      forma que si se tiene un array <code class="varname">a</code> y quiere
      obtener el quinto elemento, sólo tiene que escribir
      <code class="varname">a[4]</code> (fíjese en que la indexación siempre
      empieza en cero).
    </p><p>
      Esta forma compacta y poderosa de notación indexada se ha
      incorporado al <code class="classname">vector</code> mediante la
      sobrecarga de operadores como el <code class="literal">&lt;&lt;</code> y el
      <code class="literal">&gt;&gt;</code> de los <code class="classname">iostreams</code>. De
      nuevo, no hay que saber cómo se ha implementado la
      sobrecarga de operadores - lo dejamos para un capítulo posterior -
      pero es útil que sea consciente que hay algo de magia detrás de
      todo esto para conseguir que los corchetes funcionen con el
      <code class="classname">vector</code>.
    </p><p>
      Con todo esto en mente, ya puede ver un programa que usa la clase
      <code class="classname">vector</code>. Para usar un vector, hay que
      incluir el fichero de cabecera
      <code class="filename">&lt;vector&gt;:</code>
    </p><div class="example"><a id="idp4247592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Fillvector.cpp</span>
<span class="hl slc">// Copy an entire file into a vector of string</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Fillvector.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>line<span class="hl opt">);</span> <span class="hl slc">// Add the line to the end</span>
  <span class="hl slc">// Add line numbers:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.10. C02/Fillvector.cpp</strong></p></div><br class="example-break" /><p>
      Casi todo este programa es similar al anterior; se abre un fichero
      abierto y se leen las líneas en objetos
      <code class="classname">string</code> (uno cada vez). Sin embargo, estos
      objetos <code class="classname">string</code> se introducen al final
      del <code class="classname">vector</code> <code class="varname">v</code>. Una vez
      que el bucle <code class="keyword">while</code> ha terminado, el fichero entero se
      encuentra en memoria dentro de <code class="varname">v</code>.
    </p><p>
      La siguiente sentencia en el programa es un bucle <code class="keyword">for</code>. Es
      parecido a un bucle <code class="keyword">while</code> aunque añade un control
      extra. Como en el bucle <code class="keyword">while</code>, en el <code class="keyword">for</code> hay una
      «expresión de control» dentro del paréntesis. Sin
      embargo, esta expresión está dividida en tres partes: una parte
      que inicializa, una que comprueba si hay que salir del bucle, y
      otra que cambia algo, normalmente da un paso en una secuencia de
      elementos. Este programa muestra el bucle <code class="keyword">for</code> de la
      manera más habitual: la parte de inicialización <code class="code">int i =
      0</code> crea un entero <code class="varname">i</code> para usarlo como
      contador y le da el valor inicial de cero. La comprobación
      consiste en ver si <code class="varname">i</code> es menor que el número de
      elementos del <code class="classname">vector</code>
      <code class="varname">v</code>. (Esto se consigue usando la función miembro
      <code class="function">size()</code> -tamaño- que hay que admitir que tiene
      un significado obvio) El último trozo, usa el operador de
      «autoincremento» para aumentar en uno el valor de
      <code class="varname">i</code>. Efectivamente, <code class="code">i++</code> dice
      «coge el valor de <code class="varname">i</code> añádele uno y guarda
      el resultado en <code class="varname">i</code>». Conclusión: el
      efecto del bucle <code class="keyword">for</code> es aumentar la variable
      <code class="varname">i</code> desde cero hasta el tamaño del
      <code class="literal">vector</code> menos uno. Por cada nuevo valor de
      <code class="varname">i</code> se ejecuta la sentencia del
      <code class="varname">cout</code>, que construye un linea con el valor de
      <code class="varname">i</code> (mágicamente convertida a un array de
      caracteres por <code class="varname">cout</code>), dos puntos, un espacio,
      la línea del fichero y el carácter de nueva línea que nos
      proporciona <code class="function">endl</code>. Cuando lo compile y lo
      ejecute verá el efecto de numeración de líneas del fichero.
    </p><p>
      Debido a que el operador <code class="literal">&gt;&gt;</code> funciona con
      <code class="classname">iostreams</code>, se puede modificar fácilmente el
      programa anterior para que convierta la entrada en palabras
      separadas por espacios, en vez de líneas:
    </p><div class="example"><a id="idp4261792"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:GetWords.cpp</span>
<span class="hl slc">// Break a file into whitespace-separated words</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> words<span class="hl opt">;</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;GetWords.cpp&quot;</span><span class="hl opt">);</span>
  string word<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>in <span class="hl opt">&gt;&gt;</span> word<span class="hl opt">)</span>
    words<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>word<span class="hl opt">);</span> 
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> words<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> words<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.11. C02/GetWords.cpp</strong></p></div><br class="example-break" /><p>
      La expresión:
    </p><pre class="programlisting">
<span class="hl kwa">while</span> <span class="hl opt">(</span>in <span class="hl opt">&gt;&gt;</span> word<span class="hl opt">)</span>
</pre><p>
      es la que consigue que se lea una «palabra» cada vez,
      y cuando la expresión se evalúa como «falsa»
      significa que ha llegado al final del fichero. De acuerdo,
      delimitar una palabra mediante caracteres en blanco es un poco
      tosco, pero sirve como ejemplo sencillo. Más tarde, en este libro,
      verá ejemplos más sofisticados que le permiten dividir la entrada
      de la forma que quiera.
    </p><p>
      Para demostrar lo fácil que es usar un
      <code class="classname">vector</code> con cualquier tipo, aquí tiene
      un ejemplo que crea un vector de enteros:
    </p><div class="example"><a id="idp4265752"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Intvector.cpp</span>
<span class="hl slc">// Creating a vector that holds integers</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">&quot;, &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    v<span class="hl opt">[</span>i<span class="hl opt">] =</span> v<span class="hl opt">[</span>i<span class="hl opt">] *</span> <span class="hl num">10</span><span class="hl opt">;</span> <span class="hl slc">// Assignment  </span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">&quot;, &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.12. C02/Intvector.cpp</strong></p></div><br class="example-break" /><p>
      Para crear un <code class="classname">vector</code> que maneje un tipo
      diferente basta con poner el tipo entre las llaves angulares (el
      argumento de las plantillas). Las plantillas y las librerías de
      plantillas pretenden ofrecer precisamente esta facilidad de uso.
    </p><p>
      Además este ejemplo demuestra otra característica esencial
      del <code class="classname">vector</code> en la expresión
    </p><pre class="programlisting">
v<span class="hl opt">[</span>i<span class="hl opt">] =</span> v<span class="hl opt">[</span>i<span class="hl opt">] *</span> <span class="hl num">10</span><span class="hl opt">;</span>
</pre><p>
      Puede observar que el <code class="classname">vector</code> no está
      limitado a meter cosas y sacarlas. También puede
      <span class="emphasis"><em>asignar</em></span> (es decir, cambiar) cualquier
      elemento del vector mediante el uso de los corchetes. Eso
      significa que el <code class="classname">vector</code> es un objeto útil,
      flexible y de propósito general para trabajar con colecciones de
      objetos, y haremos uso de él en los siguientes capítulos.
    </p></div><div class="sect1" title="2.8. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4270736"></a>2.8. Resumen</h2></div></div></div><p>
      Este capítulo pretende mostrarle lo fácil que puede llegar a ser
      la programación orientada a objetos - si alguien ha hecho el
      trabajo de definir los objetos por usted. En este caso, sólo hay
      que incluir el fichero de cabecera, crear los objetos y enviarles
      mensajes. Si los tipos que está usando están bien diseñados y son
      potentes, entonces no tendrá mucho trabajo y su programa
      resultante también será potente.
    </p><p>
      En este proceso para mostrar la sencillez de la POO cuando se usan
      librerías de clases, este capítulo, también introduce algunos de
      los tipos de datos más básicos y útiles de la Librería Estándar de
      C++: La familia de los <code class="classname">iostreams</code> (en
      particular aquellos que leen y escriben en consola y ficheros), la
      clase <code class="classname">string</code>, y la plantilla
      <code class="classname">vector</code>. Ha visto lo sencillo que es usarlos
      y ahora es probable que se imagine la de cosas que se pueden hacer
      con ellos, pero hay muchas más cosas que son capaces de
      realizar
      <sup>[<a id="idp4273608" href="#ftn.idp4273608" class="footnote">38</a>]</sup>.

      A pesar de estar usando un pequeño subconjunto de la funcionalidad
      de estas herramientas en este principio del libro, supone un gran
      avance frente a los rudimentarios comienzos en el aprendizaje de
      un lenguaje de bajo nivel como C. Y aunque aprender los aspectos
      de bajo nivel de C es educativo también lleva tiempo. Al final
      usted es mucho más productivo si tiene objetos que manejen las
      características de bajo nivel. Después de todo, el principal
      objetivo de la POO es esconder los detalles para que usted pueda
      «pintar con una brocha más gorda».
    </p><p>
      Sin embargo, debido al alto nivel que la POO intenta tener, hay
      algunos aspectos fundamentales de C que no se pueden obviar, y de
      eso trata el siguiente capítulo.
    </p></div><div class="sect1" title="2.9. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4276664"></a>2.9. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Modifique <code class="filename">Hello.cpp</code> para que imprima
	  su nombre y edad (o tamaño de pie, o la edad de su perro,
	  si le gusta más). Compile y ejecute el programa.
	</p></li><li class="listitem"><p>
	  Utilizando <code class="filename">Stream2.cpp</code> y
	  <code class="filename">Numconv.cpp</code> como guías, cree un programa
	  que le pida el radio de un círculo y le muestre el área del
	  mismo. Puede usar el operador <code class="literal">*</code> para elevar el
	  radio al cuadrado. No intente imprimir el valor en octal o en
	  hexadecimal (sólo funciona con tipos enteros).
	</p></li><li class="listitem"><p>
	  Cree un programa que abra un fichero y cuente las palabras
	  (separadas por espacios en blanco) que contiene.
	</p></li><li class="listitem"><p>
	  Cree un programa que cuente el número de ocurrencias de una
	  palabra en concreto en un fichero (use el operador
	  <code class="literal">==</code> de la clase <code class="classname">string</code> para
	  encontrar la palabra)
	</p></li><li class="listitem"><p>
	  Cambie <code class="filename">Fillvector.cpp</code> para que imprima
	  las líneas al revés (de la última a la primera).
	</p></li><li class="listitem"><p>
	  Cambie <code class="filename">Fillvector.cpp</code> para que concatene
	  todos los elementos de la clase <code class="classname">vector</code>
	  en un único <code class="classname">string</code> antes de imprimirlo,
	  pero no añada numeración de líneas
	</p></li><li class="listitem"><p>
	  Muestre un fichero línea a línea, esperando que el usuario
	  pulse <span class="keycap"><strong>Enter</strong></span> después de cada línea.
	</p></li><li class="listitem"><p>
	  Cree un <code class="classname">vector&lt;float&gt;</code> e
	  introduzca en él 25 números en punto flotante usando un bucle
	  <code class="keyword">for</code>. Muestre el vector.
	</p></li><li class="listitem"><p>
	  Cree tres objetos <code class="classname">vector&lt;float&gt;</code> y
	  rellene los dos primeros como en el ejercicio
	  anterior. Escriba un bucle <code class="keyword">for</code> que sume los elementos
	  correspondientes y los añada al tercer vector. Muestre los
	  tres vectores.
	</p></li><li class="listitem"><p>
	  Cree un <code class="classname">vector&lt;float&gt;</code> e
	  introduzca 25 números en él como en el ejercicio
	  anterior. Eleve cada número al cuadrado y ponga su
	  resultado en la misma posición del vector. Muestre el
	  vector antes y después de la multiplicación.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp4009528" href="#idp4009528" class="para">33</a>] </sup>
	    Los límites entre los compiladores y los intérpretes tienden
	    a ser difusos, especialmente con Python, que tiene muchas de
	    las caractéristicas y el poder de un lenguaje compilado pero
	    también tiene parte de las ventajas de los lenguajes
	    interpretados.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4017192" href="#idp4017192" class="para">34</a>] </sup>
	    Python vuelve a ser una excepción, debido a que permite
	    compilación separada.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4044984" href="#idp4044984" class="para">35</a>] </sup>
	    <span class="foreignphrase"><em class="foreignphrase">One Definition Rule</em></span>
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4103736" href="#idp4103736" class="para">36</a>] </sup>
	      Yo le recomendaría usar Perl o Python para automatizar
	      estas tareas como parte de su proceso de empaquetamiento de
	      librerías (ver <a class="ulink" href="http://www.perl.org" target="_top">www.Perl.org</a> ó <a class="ulink" href="http://www.python.org" target="_top">www.Python.org</a>).
	    </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4205272" href="#idp4205272" class="para">37</a>] </sup>
	  Actualmente existen variantes de
	  <code class="function">getline()</code>, que se discutirán profusamente
	  en el capítulo de <code class="classname">iostreams</code> en el
	  Volumen 2
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp4273608" href="#idp4273608" class="para">38</a>] </sup>
	  Si está especialmente interesado en ver todas las cosas
	  que se pueden hacer con los componentes de la Librería
	  Estándar, vea el Volumen 2 de este libro en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a> y
	  también en <a class="ulink" href="http://www.dinkumware.com" target="_top">www.dinkumware.com</a>
	</p></div></div></div><div class="chapter" title="3: C en C++"><div class="titlepage"><div><div><h2 class="title"><a id="C03"></a>3: C en C++</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp4295608">3.1. Creación de funciones</a></span></dt><dt><span class="sect1"><a href="#idp4330040">3.2. Control de flujo</a></span></dt><dt><span class="sect1"><a href="#idp4424576">3.3. Introducción a los operadores</a></span></dt><dt><span class="sect1"><a href="#idp4439720">3.4. Introducción a los tipos de datos</a></span></dt><dt><span class="sect1"><a href="#idp4558336">3.5. Alcance</a></span></dt><dt><span class="sect1"><a href="#idp4585696">3.6.  Especificar la ubicación del espacio de almacenamiento</a></span></dt><dt><span class="sect1"><a href="#idp4668808">3.7. Los operadores y su uso</a></span></dt><dt><span class="sect1"><a href="#idp4844384">3.8. Creación de tipos compuestos</a></span></dt><dt><span class="sect1"><a href="#idp5000080">3.9. Consejos para depuración</a></span></dt><dt><span class="sect1"><a href="#C03-punteros-a-funcion">3.10. Direcciones de función</a></span></dt><dt><span class="sect1"><a href="#idp5067648">3.11. Make: cómo hacer compilación separada</a></span></dt><dt><span class="sect1"><a href="#idp5152080">3.12. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5155104">3.13. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Como C++ está basado en C, debería estar familiarizado con la
      sintaxis de C para poder programar en C++, del mismo modo que
      debería tener una fluidez razonable en álgebra para poder hacer
      cálculos.
    </p></div><p>
    Si nunca antes ha visto C, este capítulo le dará una buena base
    sobre el estilo de C usado en C++. Si está familiarizado con el
    estilo de C descrito en la primera edición de Kernighan &amp;
    Ritchie (también llamado K&amp;R) encontrará algunas
    características nuevas o diferentes tanto en C++ como en el
    estándar C. Si está familiarizado con el estándar C debería
    echar un vistazo al capítulo en busca de las características
    particulares de C++. Note que hay algunas características
    fundamentales de C++ que se introducen aquí, que son ideas
    básicas parecidas a características de C o a menudo
    modificaciones en el modo en que C hace las cosas. Las
    características más sofisticadas de C++ se explicarán en
    capítulos posteriores
  </p><p>
    Este capítulo trata por encima las construcciones de C e introduce
    algunas construcciones básicas de C++, suponiendo que tiene alguna
    experiencia programando en otro lenguaje. En el CD-ROM que acompaña
    a este libro hay una introducción más suave a C,
    titulada <em class="citetitle">Thinking in C: Foundations for Java &amp;
    C++</em> de Chuck Alison (publicada por MidView, Inc. y
    disponible también en <a class="ulink" href="http://www.MindView.net" target="_top">www.MindView.net</a>). Se trata de
    un seminario en CD-ROM cuyo objetivo es guiarle
    cuidadosamente a través de los fundamentos del lenguaje C. Se
    concentra en el conceptos necesarios para permitirle pasarse a C++
    o a Java, en lugar de intentar convertirle en un experto en todos los
    oscuros recovecos de C (una de las razones para usar un lenguaje de
    alto nivel como C++ o Java es precisamente evitar muchos de estos
    recovecos). También contiene ejercicios y soluciones guiadas. Tenga
    presente que este capítulo va después del CD <em class="citetitle">Thinking in
      C</em>, el CD no reemplaza a este capítulo, sino que debería
    tomarse como una preparación para este capítulo y para el libro.
  </p><div class="sect1" title="3.1. Creación de funciones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4295608"></a>3.1. Creación de funciones</h2></div></div></div><p>
      En el antiguo C (previo al estándar), se podía invocar una función
      con cualquier número y tipo de argumentos sin que el compilador se
      quejase. Todo parecía ir bien hasta que ejecutabas el programa. El
      programa acababa con resultados misteriosos (o peor, el programa
      fallaba) sin ninguna pista del motivo. La falta de ayuda
      acerca del paso de argumentos y los enigmáticos bugs que
      resultaban es, probablemente, la causa de que C se considerase
      «un lenguaje ensamblador de alto nivel». Los
      programadores de pre-Estándar C simplemente se adaptaron.
    </p><p>
      C y C++ Estándar usan una característica llamada
      <span class="emphasis"><em>prototipado de funciones</em></span>. Con esta
      herramienta se han de describir los tipos de argumentos al
      declarar y definir una función. Esta descripción es el
      «prototipo». Cuando la función es llamada, el
      compilador usa el prototipo para asegurar que los argumentos
      pasados son los apropiados, y que el valor retornado es tratado
      correctamente. Si el programador comete un error al llamar a la
      función, el compilador detecta el error.
    </p><p>
      Esencialmente, aprendió sobre prototipado de funciones
      (sin llamarlas de ese modo) en el capítulo previo, ya que la forma
      de declararlas en C++ requiere de un prototipado apropiado. En un
      prototipo de función, la lista de argumentos contiene los tipos de
      argumentos que se deben pasar a la función y (opcionalmente
      para la declaración), identificadores para los argumentos. El
      orden y tipo de los argumentos debe coincidir en la declaración,
      definición y llamada a la función. A continuación se muestra un
      ejemplo de un prototipo de función en una declaración:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">translate</span><span class="hl opt">(</span><span class="hl kwb">float</span> x<span class="hl opt">,</span> <span class="hl kwb">float</span> y<span class="hl opt">,</span> <span class="hl kwb">float</span> z<span class="hl opt">);</span>
</pre><p>
      No se puede usar la misma sintaxis para declarar los argumentos en
      el prototipo de una función que en las definiciones ordinarias de
      variables. Esto significa que no se puede escribir: <code class="code">float x, y,
      z.</code> Se debe indicar el tipo de cada argumento. En una declaración
      de función, lo siguiente también es correcto:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">translate</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">);</span>
</pre><p>
      Ya que el compilador no hace más que chequear los tipos cuando se
      invoca la función, los identificadores se incluyen solamente para
      mejorar la claridad del código cuando alguien lo está leyendo.
    </p><p>
      En la definición de la función, los nombres son necesarios ya que
      los argumentos son referenciados dentro de la función:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">translate</span><span class="hl opt">(</span><span class="hl kwb">float</span> x<span class="hl opt">,</span> <span class="hl kwb">float</span>  y<span class="hl opt">,</span> <span class="hl kwb">float</span> z<span class="hl opt">) {</span>
    x <span class="hl opt">=</span> y <span class="hl opt">=</span> z<span class="hl opt">;</span>
    <span class="hl slc">// ...</span>
<span class="hl opt">}</span>
</pre><p>
      Esta regla sólo se aplica a C. En C++, un argumento puede no tener
      nombrado en la lista de argumentos de la definición de la
      función. Como no tiene nombre, no se puede utilizar en el cuerpo
      de la función, por supuesto. Los argumentos sin nombre se permiten
      para dar al programador una manera de «reservar espacio en
      la lista de argumentos». De cualquier modo, la persona que
      crea la función aún así debe llamar a la función con los
      parámetros apropiados. Sin embargo, la persona que crea la función
      puede utilizar el argumento en el futuro sin forzar una
      modificación en el código que llama a la función. Esta opción de
      ignorar un argumento en la lista también es posible si se indica
      el nombre, pero siempre aparecería un molesto mensaje de
      advertencia, informando que el valor no se utiliza, cada vez que se
      compila la función. La advertencia desaparece si se quita el
      nombre del argumento.
    </p><p>
      C y C++ tienen otras dos maneras de declarar una lista de
      argumentos. Si se tiene una lista de argumentos vacía, se puede
      declarar esta como <code class="function">func()</code> en C++, lo que
      indica al compilador que hay exactamente cero argumentos. Hay que
      tener en cuenta que esto sólo significa una lista de argumentos
      vacía en C++. En C significa «un número indeterminado de
      argumentos» (lo que es un «agujero» en C ya
      que deshabilita la comprobación de tipos en ese caso). En ambos, C
      y C++, la declaración <code class="function">func(void);</code> significa
      una lista de argumentos vacía. La palabra clave <code class="type">void</code>
      significa «nada» en este caso (también puede
      significar «sin tipo» en el caso de los punteros,
      como se verá mas adelante en este capítulo).
    </p><p>
      La otra opción para las listas de argumentos se produce cuando no
      se sabe cuantos argumentos o qué tipos tendrán los argumentos;
      esto se conoce como <span class="emphasis"><em>lista de argumentos
      variable</em></span>. Esta «lista incierta de
      argumentos» se representada con puntos suspensivos
      (...). Definir una función con una lista de argumentos variable es
      significativamente más complicado que definir una función
      normal. Se puede utilizar una lista de argumentos variable para
      una función que tiene un grupo de argumentos fijos si (por alguna
      razón) se quiere deshabilitar la comprobación del prototipo
      de función. Por eso, se debe restringir el uso de listas
      de argumentos variables en C y evitarlas en C++ (en el cual, como
      aprenderá, hay alternativas mucho mejores). El manejo de listas
      de argumentos variables se describe en la sección de librerías de
      la documentación de su entorno C particular.
    </p><div class="sect2" title="3.1.1. Valores de retorno de las funciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp4309912"></a>3.1.1. Valores de retorno de las funciones</h3></div></div></div><p>
        Un prototipo de función C++ debe especificar el tipo de valor
        devuelto de la función (en C, si no se especifica será por
        defecto un <code class="type">int</code>). La especificación del tipo de
        retorno precede al nombre de la función. Para especificar que no
        se devolverá valor alguno, se utiliza la palabra reservada
        <code class="type">void</code>. Esto provocará un error si se intenta devolver
        un valor desde la función. A continuación hay algunos prototipos
        completos de funciones:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">f1</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span> <span class="hl slc">// Devuelve un entero, no tiene argumentos</span>
<span class="hl kwb">int</span> <span class="hl kwd">f2</span><span class="hl opt">();</span> <span class="hl slc">//  igual que f1() en C++ pero no en C Stantard</span>
<span class="hl kwb">float</span> <span class="hl kwd">f3</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">);</span> <span class="hl slc">// Devuelve un float</span>
<span class="hl kwb">void</span> <span class="hl kwd">f4</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span> <span class="hl slc">// No toma argumentos, no devuelve nada</span>
</pre><p>
        Para devolver un valor desde una función, se utiliza la
        sentencia <code class="keyword">return</code>. Esta sentencia termina la función y
        salta hasta la sentencia que se halla justo después de la
        llamada a la función. Si <code class="keyword">return</code> tiene un argumento, se
        convierte en el valor de retorno de la función. Si una función
        indica que retornara un tipo en particular, entonces cada
        sentencia <code class="keyword">return</code> debe retornar un valor de ese
        tipo. Puede haber más de una sentencia <code class="keyword">return</code> en una
        definición de función:
      </p><div class="example"><a id="idp4315480"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Return.cpp</span>
<span class="hl slc">// Use of &quot;return&quot;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">char</span> <span class="hl kwd">cfunc</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl str">'g'</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">5</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl str">'z'</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl str">'c'</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type an integer: &quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> val<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> val<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">cfunc</span><span class="hl opt">(</span>val<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.1. C03/Return.cpp</strong></p></div><br class="example-break" /><p>
        En <code class="function">cfunc()</code>, el primer <code class="keyword">if</code> que
        comprueba que la condición sea <code class="keyword">true</code> sale de la función
        con la sentencia <code class="keyword">return</code>. Fíjese que la declaración de
        la función no es necesaria puesto que la definición aparece
        antes de ser utilizada en <code class="function">main()</code>, de modo
        que el compilador sabe de su existencia desde dicha definición.
      </p></div><div class="sect2" title="3.1.2. Uso de funciones de librerías C"><div class="titlepage"><div><div><h3 class="title"><a id="idp4319728"></a>3.1.2. Uso de funciones de librerías C</h3></div></div></div><p>
        Todas las funciones en la librería local de funciones de C están
        disponibles cuando se programa en C++. Se debería buscar bien en
        la librería de funciones antes de definir una propia - hay muchas
        probabilidades de que alguien haya resuelto el problema antes, y
        probablemente haya dedicado más tiempo pensando y depurando.
      </p><p>
        Una advertencia, del mismo modo: muchos compiladores incluyen
        muchas funciones extra que hacen la vida mucho mas fácil y
        resultan tentadoras, pero no son parte de la Librería C
        Estándar. Si está seguro de que jamás deseará portar la
        aplicación a otra plataforma (¿y quién está seguro de eso?),
        adelante -utilice esas funciones y haga su vida más fácil. Si
        desea que la aplicación pueda ser portada, debería ceñirse
        únicamente al uso de funciones de la Librería Estándar. Si
        debe realizar actividades específicas de la plataforma,
        debería intentar aislar este código de tal modo que pueda
        cambiarse fácilmente al migrarlo a otra plataforma. En C++,
        las actividades de una plataforma específica a menudo se
        encapsulan en una clase, que es la solución ideal.
      </p><p>
        La fórmula para usar una librería de funciones es la siguiente:
        primero, encontrar la función en la referencia de programación
        (muchas referencias de programación ordenan las funciones por
        categoría además de alfabéticamente). La descripción de la
        función debería incluir una sección que demuestre la sintaxis
        del código. La parte superior de esta sección tiene al menos una
        línea <code class="keyword">#include</code>, mostrando el fichero principal que
        contiene el prototipo de función. Debe copiar este
        <code class="keyword">#include</code> en su fichero para que la función esté
        correctamente declarada. Ahora puede llamar la función de la
        misma manera que aparece en la sección de sintaxis. Si comete un
        error, el compilador lo descubrirá comparando la llamada a la
        función con el prototipo de la cabecera e informará de dicho
        error. El enlazador busca en la Librería Estándar por defecto,
        de modo que lo único que hay que hacer es: incluir el fichero de
        cabecera y llamar a la función.
      </p></div><div class="sect2" title="3.1.3. Creación de librerías propias"><div class="titlepage"><div><div><h3 class="title"><a id="idp4325896"></a>3.1.3. Creación de librerías propias</h3></div></div></div><p>
        Puede reunir funciones propias juntas en una librería. La
        mayoría de paquetes de programación vienen con un
        FIXME:bibliotecario que maneja grupos de módulos objeto. Cada
        FIXME:bibliotecario tiene sus propios comandos, pero la idea
        general es la siguiente: si se desea crear una librería, se debe
        hacer un fichero cabecera que contenga prototipos de todas las
        funciones de la librería. Hay que ubicar este fichero de
        cabecera en alguna parte de la ruta de búsqueda del
        preprocesador, ya sea en el directorio local (de modo que se
        podrá encontrar mediante <code class="code">#include "header"</code>) o bien
        en el directorio <code class="filename">include</code> (por lo que se
        podrá encontrar mediante <code class="code">#include
        &lt;header&gt;</code>). Luego se han de juntar todos los módulos
        objeto y pasarlos al FIXME:bibliotecario junto con un nombre
        para la librería recién construida (la mayoría de los
        bibliotecarios requieren una extensión común, como por ejemplo
        <code class="filename">.lib</code> o <code class="filename">.a</code>). Se ha de
        ubicar la librería completa donde residan todas las demás, de
        manera que el enlazador sabrá buscar esas funciones en dicha
        librería al ser invocadas. Pueden encontrar todos los detalles
        en su documentación particular, ya que pueden variar de un
        sistema a otro.
      </p></div></div><div class="sect1" title="3.2. Control de flujo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4330040"></a>3.2. Control de flujo</h2></div></div></div><p>
      Esta sección cubre las sentencias de control de flujo en C++. Debe
      familiarizarse con estas sentencias antes de que pueda leer o
      escribir código C o C++.
    </p><p>
      C++ usa todas las sentencias de control de ejecución de C. Esto
      incluye <code class="keyword">if-else</code>, <code class="keyword">do-while</code>, <code class="keyword">for</code>, y una
      sentencia de selección llamada <code class="keyword">switch</code>. C++ también admite
      el infame <code class="keyword">goto</code>, el cual será evitado en este libro.
    </p><div class="sect2" title="3.2.1. Verdadero y falso"><div class="titlepage"><div><div><h3 class="title"><a id="idp4333744"></a>3.2.1. Verdadero y falso</h3></div></div></div><p>
        Todas las sentencias condicionales utilizan la veracidad o la
        falsedad de una expresión condicional para determinar el camino
        de ejecución. Un ejemplo de expresión condicional es <code class="code">A ==
        B</code>. Esto utiliza el operador condicional <code class="literal">==</code>
        para saber si la variable <code class="varname">A</code> es equivalente a
        la variable <code class="varname">B</code>. La expresión produce un
        booleano <code class="keyword">true</code> o <code class="keyword">false</code> (estas son palabras
        reservadas sólo en C++; en C una expresión es
        verdadera(<span class="foreignphrase"><em class="foreignphrase">true</em></span>) si se evalúa con
        un valor diferente de cero). Otros operadores condicionales son
        <code class="literal">&gt;</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;=</code>,
        etc. Las sentencias condicional se tratarán a fondo más
        adelante en este capítulo.
      </p></div><div class="sect2" title="3.2.2. if-else"><div class="titlepage"><div><div><h3 class="title"><a id="idp4338976"></a>3.2.2. <code class="keyword">if</code>-<code class="keyword">else</code></h3></div></div></div><p>
        La sentencia <code class="keyword">if-else</code> puede existir de dos formas: con o
        sin el <code class="keyword">else</code>. Las dos formas son:
      </p><pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>expresión<span class="hl opt">)</span>
    sentencia
</pre><p>
        ó
      </p><pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>expresión<span class="hl opt">)</span>
    sentencia
<span class="hl kwa">else</span>
    sentencia
</pre><p>
        La «expresión» se evalúa como <code class="keyword">true</code> o
        <code class="keyword">false</code>. La «sentencia» puede ser una simple
        acabada en un punto y coma, o bien una compuesta, lo que no es
        más que un grupo de sentencias simples encerradas entre
        llaves. Siempre que se utiliza la palabra
        «sentencia», implica que la sentencia es simple o
        compuesta. Tenga en cuenta que dicha sentencia puede ser incluso
        otro <code class="keyword">if</code>, de modo que se pueden anidar.
      </p><div class="example"><a id="idp4345040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Ifthen.cpp</span>
<span class="hl slc">// Demonstration of if and if-else conditionals</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type a number and 'Enter'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> i<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&gt;</span> <span class="hl num">5</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;It's greater than 5&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">else</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">)</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;It's less than 5 &quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">else</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;It's equal to 5 &quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>

  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type a number and 'Enter'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> i<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">)</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&gt;</span> <span class="hl num">5</span><span class="hl opt">)</span>  <span class="hl slc">// &quot;if&quot; is just another statement</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;5 &lt; i &lt; 10&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">else</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &lt;= 5&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">else</span> <span class="hl slc">// Matches &quot;if(i &lt; 10)&quot;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &gt;= 10&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.2. C03/Ifthen.cpp</strong></p></div><br class="example-break" /><p>
        Por convenio se indenta el cuerpo de una sentencia de control de
        flujo, de modo que el lector puede determinar fácilmente donde
        comienza y dónde acaba
	<sup>[<a id="idp4347232" href="#ftn.idp4347232" class="footnote">39</a>]</sup>.
      </p></div><div class="sect2" title="3.2.3. while"><div class="titlepage"><div><div><h3 class="title"><a id="idp4348344"></a>3.2.3. <code class="keyword">while</code></h3></div></div></div><p>
        En los bucles de control <code class="keyword">while</code>, <code class="keyword">do-while</code>, y
        <code class="keyword">for</code>, una sentencia se repite hasta que la expresión de
        control sea <code class="keyword">false</code>. La estructura de un bucle
        <code class="keyword">while</code> es:
      </p><pre class="programlisting">
<span class="hl kwa">while</span><span class="hl opt">(</span>expresión<span class="hl opt">)</span> sentencia
</pre><p>
        La expresión se evalúa una vez al comienzo del bucle y cada
        vez antes de cada iteración de la sentencia.
      </p><p>
        Este ejemplo se mantiene en el cuerpo del bucle <code class="keyword">while</code>
        hasta que introduzca el número secreto o presione <span class="keycap"><strong>Control</strong></span>-<span class="keycap"><strong>C</strong></span>.
      </p><div class="example"><a id="idp4354192"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Guess.cpp</span>
<span class="hl slc">// Guess a number (demonstrates &quot;while&quot;)</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> secret <span class="hl opt">=</span> <span class="hl num">15</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> guess <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// &quot;!=&quot; is the &quot;not-equal&quot; conditional:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>guess <span class="hl opt">!=</span> secret<span class="hl opt">) {</span> <span class="hl slc">// Compound statement</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;guess the number: &quot;</span><span class="hl opt">;</span>
    cin <span class="hl opt">&gt;&gt;</span> guess<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;You guessed it!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.3. C03/Guess.cpp</strong></p></div><br class="example-break" /><p>
        La expresión condicional del <code class="keyword">while</code> no está restringida
        a una simple prueba como en el ejemplo anterior; puede ser tan
        complicada como se desee siempre y cuando se produzca un
        resultado <code class="keyword">true</code> o <code class="keyword">false</code>. También puede
        encontrar código en el que el bucle no tiene cuerpo, sólo un
        simple punto y coma:
      </p><pre class="programlisting">
<span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl com">/* hacer muchas cosas */</span><span class="hl opt">)</span>
<span class="hl opt">;</span>
</pre><p>
        En estos casos, el programador ha escrito la expresión
        condicional no sólo para realizar la evaluación, sino también
        para hacer el trabajo.
      </p></div><div class="sect2" title="3.2.4. do-while"><div class="titlepage"><div><div><h3 class="title"><a id="idp4358872"></a>3.2.4. <code class="keyword">do-while</code></h3></div></div></div><p>
        El aspecto de <code class="keyword">do-while</code> es
      </p><pre class="programlisting">
<span class="hl kwa">do</span>
    sentencia
<span class="hl kwa">while</span><span class="hl opt">(</span>expresión<span class="hl opt">);</span>
</pre><p>
        El <code class="keyword">do-while</code> es diferente del <code class="keyword">while</code> ya que la
        sentencia siempre se ejecuta al menos una vez, aún si la
        expresión resulta <code class="keyword">false</code> la primera vez. En un
        <code class="keyword">while</code> normal, si la condición es falsa la primera vez,
        la sentencia no se ejecuta nunca.
      </p><p>
        Si se utiliza un <code class="keyword">do-while</code> en
        <code class="filename">Guess.cpp</code>, la variable
        <code class="varname">guess</code> no necesitaría un valor ficticio
        inicial, ya que se inicializa por la sentencia <code class="keyword">cin</code>
        antes de que la variable sea evaluada:
      </p><div class="example"><a id="idp4364760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Guess2.cpp</span>
<span class="hl slc">// The guess program using do-while</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> secret <span class="hl opt">=</span> <span class="hl num">15</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> guess<span class="hl opt">;</span> <span class="hl slc">// No initialization needed here</span>
  <span class="hl kwa">do</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;guess the number: &quot;</span><span class="hl opt">;</span>
    cin <span class="hl opt">&gt;&gt;</span> guess<span class="hl opt">;</span> <span class="hl slc">// Initialization happens</span>
  <span class="hl opt">}</span>   <span class="hl kwa">while</span><span class="hl opt">(</span>guess <span class="hl opt">!=</span> secret<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;You got it!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.4. C03/Guess2.cpp</strong></p></div><br class="example-break" /><p>
        Por alguna razón, la mayoría de los programadores tienden a
        evitar el <code class="keyword">do-while</code> y se limitan a trabajar con
        <code class="keyword">while</code>.
      </p></div><div class="sect2" title="3.2.5. for"><div class="titlepage"><div><div><h3 class="title"><a id="idp4367488"></a>3.2.5. <code class="keyword">for</code></h3></div></div></div><p>
        Un bucle <code class="keyword">for</code> realiza una inicialización antes de la
        primera iteración. Luego ejecuta una evaluación condicional y,
        al final de cada iteración, efectúa algún tipo de
        «siguiente paso». La estructura del bucle
        <code class="keyword">for</code> es:
      </p><pre class="programlisting">
<span class="hl kwa">for</span><span class="hl opt">(</span>initialización<span class="hl opt">;</span> condición<span class="hl opt">;</span> paso<span class="hl opt">)</span>
    sentencia
</pre><p>
        Cualquiera de las expresiones de «inicialización»,
        «condición», o «paso» pueden estar
        vacías. El código de «inicialización» se ejecuta
        una única vez al principio. La expresión
        «condicional» se evalúa antes de cada iteración (si
        se evalúa a <code class="keyword">false</code> desde el principio, el cuerpo del
        bucle nunca llega a ejecutarse). Al final de cada iteración del
        bucle, se ejecuta «paso».
      </p><p>
        Los bucles <code class="keyword">for</code> se utilizan generalmente para tareas de
	«conteo»:
      </p><div class="example"><a id="idp4373680"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Charlist.cpp</span>
<span class="hl slc">// Display all the ASCII characters</span>
<span class="hl slc">// Demonstrates &quot;for&quot;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">128</span><span class="hl opt">;</span> i <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl kwa">if</span> <span class="hl opt">(</span>i <span class="hl opt">!=</span> <span class="hl num">26</span><span class="hl opt">)</span>  <span class="hl slc">// ANSI Terminal Clear screen</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; value: &quot;</span> <span class="hl opt">&lt;&lt;</span> i 
           <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; character: &quot;</span> 
           <span class="hl opt">&lt;&lt;</span> <span class="hl kwb">char</span><span class="hl opt">(</span>i<span class="hl opt">)</span> <span class="hl slc">// Type conversion</span>
           <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.5. C03/Charlist.cpp</strong></p></div><br class="example-break" /><p>
        Puede ocurrir que la variable <code class="varname">i</code> sea definida
        en el punto en el que se utiliza, en vez de al principio del
        bloque delimitado por la apertura de la llave
        <span class="token">{</span>. Esto difiere de los lenguajes procedurales
        tradicionales (incluyendo C), en los que se requiere que todas
        las variables se definan al principio del bloque. Esto se
        discutirá más adelante en este capítulo.
      </p></div><div class="sect2" title="3.2.6. Las palabras reservadas break y continue"><div class="titlepage"><div><div><h3 class="title"><a id="idp4376392"></a>3.2.6. Las palabras reservadas <code class="keyword">break</code> y <code class="keyword">continue</code></h3></div></div></div><p>
        Dentro del cuerpo de cualquiera de las estructuras de bucle
        <code class="keyword">while</code>, <code class="keyword">do-while</code>, o <code class="keyword">for</code>, se puede
        controlar el flujo del bucle utilizando <code class="keyword">break</code> y
        <code class="keyword">continue</code>. <code class="keyword">break</code> interrumpe el bucle sin
        ejecutar el resto de las sentencias de esa
        iteración. <code class="keyword">continue</code> detiene la ejecución de la
        iteración actual, vuelve al principio del bucle y comienza la
        siguiente iteración.
      </p><p>
        A modo de ejemplo de <code class="keyword">break</code> y <code class="keyword">continue</code>, este
        programa es un menu de sistema muy simple:
      </p><div class="example"><a id="idp4382528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Menu.cpp</span>
<span class="hl slc">// Simple menu program demonstrating</span>
<span class="hl slc">// the use of &quot;break&quot; and &quot;continue&quot;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span> <span class="hl slc">// To hold response</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;MAIN MENU:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;l: left, r: right, q: quit -&gt; &quot;</span><span class="hl opt">;</span>
    cin <span class="hl opt">&gt;&gt;</span> c<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'q'</span><span class="hl opt">)</span>
      <span class="hl kwa">break</span><span class="hl opt">;</span> <span class="hl slc">// Out of &quot;while(1)&quot;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'l'</span><span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;LEFT MENU:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;select a or b: &quot;</span><span class="hl opt">;</span>
      cin <span class="hl opt">&gt;&gt;</span> c<span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'a'</span><span class="hl opt">) {</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'a'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span> <span class="hl slc">// Back to main menu</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'b'</span><span class="hl opt">) {</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'b'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span> <span class="hl slc">// Back to main menu</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else</span> <span class="hl opt">{</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you didn't choose a or b!&quot;</span>
             <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span> <span class="hl slc">// Back to main menu</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'r'</span><span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;RIGHT MENU:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;select c or d: &quot;</span><span class="hl opt">;</span>
      cin <span class="hl opt">&gt;&gt;</span> c<span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'c'</span><span class="hl opt">) {</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'c'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span> <span class="hl slc">// Back to main menu</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">'d'</span><span class="hl opt">) {</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'd'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span> <span class="hl slc">// Back to main menu</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else</span> <span class="hl opt">{</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you didn't choose c or d!&quot;</span> 
             <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span> <span class="hl slc">// Back to main menu</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you must type l or r or q!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;quitting menu...&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.6. C03/Menu.cpp</strong></p></div><br class="example-break" /><p>
        Si el usuario selecciona <span class="token">q</span> en el menu principal,
        se utiliza la palabra reservada <code class="keyword">break</code> para salir, de
        otro modo, el programa continúa ejecutándose
        indefinidamente. Después de cada selección de sub-menu, se usa
        la palabra reservada <code class="keyword">continue</code> para volver atrás hasta
        el comienzo del bucle <code class="keyword">while</code>.
      </p><p>
        La sentencia <code class="keyword">while(true)</code> es el equivalente a decir
        «haz este bucle para siempre».  La sentencia
        <code class="keyword">break</code> permite romper este bucle infinito cuando el
        usuario teclea <span class="token">q</span>.
      </p></div><div class="sect2" title="3.2.7. switch"><div class="titlepage"><div><div><h3 class="title"><a id="idp4389520"></a>3.2.7. <code class="keyword">switch</code></h3></div></div></div><p>
        Una sentencia <code class="keyword">switch</code> selecciona un fragmento de código
        entre varios posibles en base al valor de una expresión
        entera. Su estructura es:
      </p><pre class="programlisting">
<span class="hl kwa">switch</span><span class="hl opt">(</span>selector<span class="hl opt">) {</span>
<span class="hl kwa">case</span> valor<span class="hl opt">-</span>entero1 <span class="hl opt">:</span> sentencia<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl kwa">case</span> valor<span class="hl opt">-</span>entero2 <span class="hl opt">:</span> sentencia<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl kwa">case</span> valor<span class="hl opt">-</span>entero3 <span class="hl opt">:</span> sentencia<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl kwa">case</span> valor<span class="hl opt">-</span>entero4 <span class="hl opt">:</span> sentencia<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
<span class="hl kwa">case</span> valor<span class="hl opt">-</span>entero5 <span class="hl opt">:</span> sentencia<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl opt">(...)</span>
<span class="hl kwa">default</span><span class="hl opt">:</span> sentencia<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>
        <code class="varname">selector</code> es una expresión que produce un
        valor entero. El <code class="keyword">switch</code> compara el resultado de
        <code class="varname">selector</code> para cada valor entero. Si encuentra
        una coincidencia, se ejecutará la sentencia correspondiente (sea
        simple o compuesta). Si no se encuentra ninguna coincidencia se
        ejecutará la sentencia <code class="keyword">default</code>.
      </p><p>
        Se puede observar en la definición anterior que cada
        <code class="keyword">case</code> acaba con un <code class="keyword">break</code>, lo que causa que la
        ejecución salte hasta el final del cuerpo del <code class="keyword">switch</code>
        (la llave final que cierra el <code class="keyword">switch</code>). Esta es la forma
        convencional de construir una sentencia <code class="keyword">switch</code>, pero la
        palabra <code class="keyword">break</code> es opcional. Si no se indica, el
        <code class="keyword">case</code> que se ha cumplido «cae» al siguiente
        de la lista. Esto significa, que el código del siguiente
        <code class="keyword">case</code>, se ejecutara hasta que se encuentre un
        <code class="keyword">break</code>. Aunque normalmente no se desea este tipo de
        comportamiento, puede ser de ayuda para un programador
        experimentado.
      </p><p>
        La sentencia <code class="keyword">switch</code> es una manera limpia de implementar
        una selección multi-modo (por ejemplo, seleccionando de entre un
        número de paths de ejecución), pero requiere un selector que
        pueda evaluarse como un entero en el momento de la
        compilación. Si quisiera utilizar, por ejemplo, un objeto
        <code class="keyword">string</code> como selector, no funcionará en una sentencia
        <code class="keyword">switch</code>. Para un selector de tipo <code class="keyword">string</code>, se
        debe utilizar una serie de sentencias <code class="keyword">if</code> y comparar el
        <code class="keyword">string</code> dentro de la condición.
      </p><p>
        El ejemplo del menu demostrado anteriormente proporciona un
        ejemplo particularmente interesante de un <code class="keyword">switch</code>:
      </p><div class="example"><a id="idp4403264"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Menu2.cpp</span>
<span class="hl slc">// A menu using a switch statement</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">bool</span> quit <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>  <span class="hl slc">// Flag for quitting</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>quit <span class="hl opt">==</span> <span class="hl kwa">false</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Select a, b, c or q to quit: &quot;</span><span class="hl opt">;</span>
    <span class="hl kwb">char</span> response<span class="hl opt">;</span>
    cin <span class="hl opt">&gt;&gt;</span> response<span class="hl opt">;</span>
    <span class="hl kwa">switch</span><span class="hl opt">(</span>response<span class="hl opt">) {</span>
      <span class="hl kwa">case</span> <span class="hl str">'a'</span> <span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'a'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
                 <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'b'</span> <span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'b'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
                 <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'c'</span> <span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;you chose 'c'&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
                 <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'q'</span> <span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;quitting menu&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
                 quit <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
                 <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">default</span>  <span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Please use a,b,c or q!&quot;</span>
                 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.7. C03/Menu2.cpp</strong></p></div><br class="example-break" /><p>
        El flag <code class="varname">quit</code> es un <code class="type">bool</code>,
        abreviatura para «booleano», que es un tipo que
        sólo se encuentra en C++. Puede tener únicamente los valores
        <code class="keyword">true</code> o <code class="keyword">false</code>. Seleccionando <span class="token">q</span>
        se asigna el valor <code class="keyword">true</code> al flag «quit». La
        próxima vez que el selector sea evaluado, <code class="code">quit ==
        false</code> retornará <code class="keyword">false</code> de modo que el cuerpo del
        bucle <code class="keyword">while</code> no se ejecutará.
      </p></div><div class="sect2" title="3.2.8. Uso y maluso de goto"><div class="titlepage"><div><div><h3 class="title"><a id="idp4409304"></a>3.2.8. Uso y maluso de <code class="keyword">goto</code></h3></div></div></div><p>
        La palabra clave <code class="keyword">goto</code> está soportada en C++, dado que
        existe en C. El uso de <code class="keyword">goto</code> a menudo es considerado
        como un estilo de programación pobre, y la mayor parte de las
        veces lo es. Siempre que se utilice <code class="keyword">goto</code>, se debe
        revisar bien el código para ver si hay alguna otra manera de
        hacerlo. En raras ocasiones, <code class="keyword">goto</code> puede resolver un
        problema que no puede ser resuelto de otra manera, pero, aún
        así, se debe considerar cuidadosamente. A continuación aparece
        un ejemplo que puede ser un candidato plausible:
      </p><div class="example"><a id="idp4413032"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:gotoKeyword.cpp</span>
<span class="hl slc">// The infamous goto is supported in C++</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">long</span> val <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">1000</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> j <span class="hl opt">+=</span> <span class="hl num">10</span><span class="hl opt">) {</span>
      val <span class="hl opt">=</span> i <span class="hl opt">*</span> j<span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>val <span class="hl opt">&gt;</span> <span class="hl num">47000</span><span class="hl opt">)</span>
        <span class="hl kwa">goto</span> bottom<span class="hl opt">;</span> 
        <span class="hl slc">// Break would only go to the outer 'for'</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  bottom<span class="hl opt">:</span> <span class="hl slc">// A label</span>
  cout <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.8. C03/gotoKeyword.cpp</strong></p></div><br class="example-break" /><p>
        La alternativa sería dar valor a un booleano que sea evaluado en
        el <code class="keyword">for</code> externo, y luego hacer un <code class="keyword">break</code> desde
        el <code class="keyword">for</code> interno. De todos modos, si hay demasiados
        niveles de <code class="keyword">for</code> o <code class="keyword">while</code> esto puede llegar a ser
        pesado.
      </p></div><div class="sect2" title="3.2.9. Recursividad"><div class="titlepage"><div><div><h3 class="title"><a id="idp4417008"></a>3.2.9. Recursividad</h3></div></div></div><p>
        La recursividad es una técnica de programación interesante y a
        veces útil, en donde se llama a la función desde el cuerpo de la
        propia función. Por supuesto, si eso es todo lo que hace, se
        estaría llamando a la función hasta que se acabase la memoria de
        ejecución, de modo que debe existir una manera de
        «escaparse» de la llamada recursiva. En el
        siguiente ejemplo, esta «escapada» se consigue
        simplemente indicando que la recursión sólo continuará hasta que
        <code class="varname">cat</code> exceda <span class="token">Z</span>:
	<sup>[<a id="idp4419168" href="#ftn.idp4419168" class="footnote">40</a>]</sup>
      </p><div class="example"><a id="idp4419688"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:CatsInHats.cpp</span>
<span class="hl slc">// Simple demonstration of recursion</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">removeHat</span><span class="hl opt">(</span><span class="hl kwb">char</span> cat<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">char</span> c <span class="hl opt">=</span> <span class="hl str">'A'</span><span class="hl opt">;</span> c <span class="hl opt">&lt;</span> cat<span class="hl opt">;</span> c<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;  &quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>cat <span class="hl opt">&lt;=</span> <span class="hl str">'Z'</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;cat &quot;</span> <span class="hl opt">&lt;&lt;</span> cat <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">removeHat</span><span class="hl opt">(</span>cat <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Recursive call</span>
  <span class="hl opt">}</span> <span class="hl kwa">else</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;VOOM!!!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">removeHat</span><span class="hl opt">(</span><span class="hl str">'A'</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.9. C03/CatsInHats.cpp</strong></p></div><br class="example-break" /><p>
        En <code class="function">removeHat()</code>, se puede ver que mientras
        <code class="varname">cat</code> sea menor que <span class="token">Z</span>,
        <code class="function">removeHat()</code> se llamará a sí misma,
        efectuando así la recursividad. Cada vez que se llama
        <code class="function">removeHat()</code>, su argumento crece en una
        unidad más que el <code class="varname">cat</code> actual de modo que el
        argumento continúa aumentando.
      </p><p>
        La recursividad a menudo se utiliza cuando se evalúa algún tipo
        de problema arbitrariamente complejo, ya que no se restringe la
        solución a ningún tamaño particular - la función puede
        simplemente efectuar la recursividad hasta que se haya alcanzado
        el final del problema.
      </p></div></div><div class="sect1" title="3.3. Introducción a los operadores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4424576"></a>3.3. Introducción a los operadores</h2></div></div></div><p>
      Se pueden ver los operadores como un tipo especial de función
      (aprenderá que en C++ la sobrecarga de operadores los trata
      precisamente de esa forma). Un operador recibe uno o más
      argumentos y produce un nuevo valor. Los argumentos se pasan de
      una manera diferente que en las llamadas a funciones normales,
      pero el efecto es el mismo.
    </p><p>
      Por su experiencia previa en programación, debe estar
      razonablemente cómodo con los operadores que se han
      utilizados. Los conceptos de adición (<code class="literal">+</code>),
      substracción y resta unaria (<code class="literal">-</code>), multiplicación
      (<code class="literal">*</code>), división (<code class="literal">/</code>), y asignación
      (<code class="literal">=</code>) tienen todos el mismo significado en cualquier
      lenguaje de programación. El grupo completo de operadores se
      enumera más adelante en este capítulo.
    </p><div class="sect2" title="3.3.1. Precedencia"><div class="titlepage"><div><div><h3 class="title"><a id="idp4429192"></a>3.3.1. Precedencia</h3></div></div></div><p>
	La precedencia de operadores define el orden en el que se evalúa
	una expresión con varios operadores diferentes. C y C++ tienen
	reglas específicas para determinar el orden de evaluación. Lo
	más fácil de recordar es que la multiplicación y la división se
	ejecutan antes que la suma y la resta. Luego, si una expresión
	no es transparente al programador que la escribe, probablemente
	tampoco lo será para nadie que lea el código, de modo que se
	deben usar paréntesis para hacer explícito el orden de la
	evaluación. Por ejemplo:
      </p><pre class="programlisting">
A <span class="hl opt">=</span> X <span class="hl opt">+</span> Y <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">/</span><span class="hl num">2</span> <span class="hl opt">+</span> Z<span class="hl opt">;</span>
</pre><p>
	Tiene un significado muy distinto de la misma expresión pero con
	un configuración de paréntesis particular:
      </p><pre class="programlisting">
A <span class="hl opt">=</span> X <span class="hl opt">+ (</span>Y <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">)/(</span><span class="hl num">2</span> <span class="hl opt">+</span> Z<span class="hl opt">);</span>
</pre><p>
	(Intente evaluar el resultado con X =1, Y = 2, y Z = 3.)
      </p></div><div class="sect2" title="3.3.2. Auto incremento y decremento"><div class="titlepage"><div><div><h3 class="title"><a id="idp4431944"></a>3.3.2. Auto incremento y decremento</h3></div></div></div><p>
	C, y por tanto C++, está lleno de atajos. Los atajos pueden hacer
	el código mucho mas fácil de escribir, y a veces más difícil de
	leer. Quizás los diseñadores del lenguaje C pensaron que sería
	más fácil entender un trozo de código  complicado si los ojos no
	tienen que leer una larga línea de letras.
      </p><p>
	Los operadores de auto-incremento y auto-decremento son de los
	mejores atajos. Se utilizan a menudo para modificar las
	variables que controlan el número de veces que se ejecuta un
	bucle.
      </p><p> El operador de auto-decremento es <code class="literal">--</code> que
	significa «decrementar de a una unidad». El
	operador de auto-incremento es <code class="literal">++</code> que significa
	«incrementar de a una unidad». Si es un entero, por
	ejemplo, la expresión <code class="code">++A</code> es equivalente a <code class="code">(A
	= A + 1)</code>. Los operadores de auto-incremento y
	auto-decremento producen el valor de la variable como
	resultado. Si el operador aparece antes de la variable (p.ej,
	<code class="code">++A</code>), la operación se ejecuta primero y después se
	produce el valor resultante. Si el operador aparece a
	continuación de la variable (p.ej, <code class="code">A++</code>), primero se
	produce el valor actual, y luego se realiza la operación. Por
	ejemplo:
      </p><div class="example"><a id="idp4436816"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:AutoIncrement.cpp</span>
<span class="hl slc">// Shows use of auto-increment</span>
<span class="hl slc">// and auto-decrement operators.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt; ++</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Pre-increment</span>
  cout <span class="hl opt">&lt;&lt;</span> j<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Post-increment</span>
  cout <span class="hl opt">&lt;&lt; --</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Pre-decrement</span>
  cout <span class="hl opt">&lt;&lt;</span> j<span class="hl opt">-- &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Post decrement</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.10. C03/AutoIncrement.cpp</strong></p></div><br class="example-break" /><p>
	Si se ha estado preguntando acerca del nombre
	«C++», ahora lo entenderá. Significa «un
	paso más allá de C»
	<sup>[<a id="idp4438856" href="#ftn.idp4438856" class="footnote">41</a>]</sup>
      </p></div></div><div class="sect1" title="3.4. Introducción a los tipos de datos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4439720"></a>3.4. Introducción a los tipos de datos</h2></div></div></div><p>
      Los <span class="emphasis"><em>tipos de datos</em></span> definen el modo en que se
      usa el espacio (memoria) en los programas.  Especificando un tipo
      de datos, está indicando al compilador como crear un espacio de
      almacenamiento en particular, y también como manipular este
      espacio.
    </p><p>
      Los tipos de datos pueden estar predefinidos o abstractos. Un tipo
      de dato predefinido es intrínsecamente comprendido por el
      compilador. Estos tipos de datos son casi idénticos en C y C++. En
      contraste, un tipo de datos definido por el usuario es aquel que
      usted o cualquier otro programador crea como una clase. Estos se
      denominan comúnmente tipos de datos abstractos. El compilador sabe
      como manejar tipos predefinidos por si mismo; y
      «aprende» como manejar tipos de datos abstractos
      leyendo los ficheros de cabeceras que contienen las declaraciones
      de las clases (esto se verá con más detalle en los siguientes
      capítulos).
    </p><div class="sect2" title="3.4.1. Tipos predefinidos básicos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4442648"></a>3.4.1. Tipos predefinidos básicos</h3></div></div></div><p>
        La especificación del Estándar C para los tipos predefinidos
        (que hereda C++) no indica cuantos bits debe contener cada uno
        de ellos. En vez de eso, estipula el mínimo y máximo valor que
        cada tipo es capaz de almacenar. Cuando una máquina se basa en
        sistema binario, este valor máximo puede ser directamente
        traducido a un numero mínimo necesario de bits para alojar ese
        valor. De todos modos, si una maquina usa, por ejemplo, el
        código binario decimal (BCD) para representar los números,
        entonces el espacio requerido para alojar el máximo número para
        cada tipo de datos será diferente. El mínimo y máximo valor que
        se puede almacenar en los distintos tipos de datos se define en
        los ficheros de cabeceras del sistema
        <code class="filename">limits.h</code> y <code class="filename">float.h</code> (en
        C++ normalmente será <code class="code">#include &lt;climits&gt;</code> y
        <code class="code">&lt;cfloat&gt;</code>).
      </p><p>
        C y C++ tienen cuatro tipos predefinidos básicos, descritos aquí
        para máquinas basadas en sistema binario. Un <code class="type">char</code>
        es para almacenar caracteres y utiliza un mínimo de 8 bits (un
        byte) de espacio, aunque puede ser mas largo. Un
        <code class="type">int</code> almacena un número entero y utiliza un mínimo
        de dos bytes de espacio. Los tipos <code class="type">float</code> y el
        <code class="type">double</code> almacenan números con coma flotante,
        usualmente en formato IEEE. el <code class="type">float</code> es para
        precisión simple y el <code class="type">double</code> es para doble
        precisión.
      </p><p>
        Como se ha mencionado previamente, se pueden definir variables
        en cualquier sitio en un ámbito determinado, y puede definirlas
        e inicializarlas al mismo tiempo.  A continuación se indica cómo
        definir variables utilizando los cuatro tipos básicos de datos:
      </p><div class="example"><a id="idp4449288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Basic.cpp</span>
<span class="hl slc">// Defining the four basic data</span>
<span class="hl slc">// types in C and C++</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Definition without initialization:</span>
  <span class="hl kwb">char</span> protein<span class="hl opt">;</span>
  <span class="hl kwb">int</span> carbohydrates<span class="hl opt">;</span>
  <span class="hl kwb">float</span> fiber<span class="hl opt">;</span>
  <span class="hl kwb">double</span> fat<span class="hl opt">;</span>
  <span class="hl slc">// Simultaneous definition &amp; initialization:</span>
  <span class="hl kwb">char</span> pizza <span class="hl opt">=</span> <span class="hl str">'A'</span><span class="hl opt">,</span> pop <span class="hl opt">=</span> <span class="hl str">'Z'</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> dongdings <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">,</span> twinkles <span class="hl opt">=</span> <span class="hl num">150</span><span class="hl opt">,</span> 
    heehos <span class="hl opt">=</span> <span class="hl num">200</span><span class="hl opt">;</span>
  <span class="hl kwb">float</span> chocolate <span class="hl opt">=</span> <span class="hl num">3.14159</span><span class="hl opt">;</span>
  <span class="hl slc">// Exponential notation:</span>
  <span class="hl kwb">double</span> fudge_ripple <span class="hl opt">=</span> <span class="hl num">6e-4</span><span class="hl opt">;</span> 
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.11. C03/Basic.cpp</strong></p></div><br class="example-break" /><p>
        La primera parte del programa define variables de los cuatro
        tipos básicos sin inicializarlas. Si no se inicializa una
        variable, el Estándar dice que su contenido es indefinido
        (normalmente, esto significa que contienen basura). La segunda
        parte del programa define e inicializa variables al mismo tiempo
        (siempre es mejor, si es posible, dar un valor inicial en el
        momento de la definición). Note que el uso de notación
        exponencial en la contante 6e-4, significa «6 por 10
        elevado a -4».
      </p></div><div class="sect2" title="3.4.2. booleano, verdadero y falso"><div class="titlepage"><div><div><h3 class="title"><a id="idp4451848"></a>3.4.2. booleano, verdadero y falso</h3></div></div></div><p>
        Antes de que <code class="type">bool</code> se convirtiese en parte del
        Estándar C++, todos tendían a utilizar diferentes técnicas para
        producir comportamientos similares a los booleanos. Esto produjo
        problemas de portabilidad y podían acarrear errores sutiles.
      </p><p>
        El tipo <code class="type">bool</code> del Estándar C++ puede tener dos
        estados expresados por las constantes predefinidas <code class="keyword">true</code>
        (lo que lo convierte en el entero 1) y <code class="keyword">false</code> (lo que lo
        convierte en el entero 0). Estos tres nombres son palabras
        reservadas. Además, algunos elementos del lenguaje han sido
        adaptados:
      </p><div class="table"><a id="idp4454920"></a><div class="table-contents"><table summary="Expresiones que utilizan booleanos" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Elemento</th><th>Uso con booleanos</th></tr></thead><tbody><tr><td>&amp;&amp; || !</td><td>
		Toman argumentos booleanos y producen valores
		<code class="type">bool</code>
	      </td></tr><tr><td>&lt; &gt; &lt;= &gt;= == !=</td><td>
		Producen resultados <code class="type">bool</code>
	      </td></tr><tr><td>
		<code class="keyword">if</code>, <code class="keyword">for</code>, <code class="keyword">while</code>, <code class="keyword">do</code>
	      </td><td>
		Las expresiones condicionales se convierten en
		valores <code class="type">bool</code>
	      </td></tr><tr><td>?:</td><td>
		El primer operando se convierte a un valor
		<code class="type">bool</code>
	      </td></tr></tbody></table></div><p class="title"><strong>Tabla 3.1. Expresiones que utilizan booleanos</strong></p></div><br class="table-break" /><p>
        Como hay mucho código existente que utiliza un <code class="type">int</code>
        para representar una bandera, el compilador lo convertirá
        implícitamente de <code class="type">int</code> a <code class="type">bool</code> (los
        valores diferentes de cero producirán <code class="keyword">true</code>, mientras
        que los valores cero, producirán <code class="keyword">false</code>). Idealmente, el
        compilador le dará un aviso como una sugerencia para corregir la
        situación.
      </p><p>
        Un modismo que se considera «estilo de programación
        pobre» es el uso de <code class="literal">++</code> para asignar a una
        bandera el valor <code class="keyword">true</code>. Esto aún se permite, pero está
        obsoleto, lo que implica que en el futuro será ilegal. El
        problema es que se está haciendo una conversión implícita de un
        <code class="type">bool</code> a un <code class="type">int</code>, incrementando el valor
        (quizá más allá del rango de valores booleanos cero y uno), y
        luego implícitamente convirtiéndolo otra vez a
        <code class="type">bool</code>.
      </p><p>
        Los punteros (que se describen más adelante en este capitulo)
        también se convierten automáticamente a <code class="type">bool</code> cuando
        es necesario.
      </p></div><div class="sect2" title="3.4.3. Especificadores"><div class="titlepage"><div><div><h3 class="title"><a id="idp4467496"></a>3.4.3. Especificadores</h3></div></div></div><p>
        Los especificadores modifican el significado de los tipos
        predefinidos básicos y los expanden a un conjunto más
        grande. Hay cuatro especificadores: <code class="keyword">long</code>,
        <code class="keyword">short</code>, <code class="keyword">signed</code> y <code class="keyword">unsigned</code>.
      </p><p>
        <code class="keyword">long</code> y <code class="keyword">short</code> modifican los valores máximos y
        mínimos que un tipo de datos puede almacenar. Un
        <code class="type">int</code> plano debe tener al menos el tamaño de un
        <code class="type">short</code>. La jerarquía de tamaños para tipos enteros
        es: <code class="type">short int</code>, <code class="type">int</code>, <code class="type">long
        int</code>.  Todos pueden ser del mismo tamaño, siempre y cuando
        satisfagan los requisitos de mínimo/máximo. En una maquina
        con una palabra de 64 bits, por defecto, todos los tipos de
        datos podrían ser de 64 bits.
      </p><p>
        La jerarquía de tamaño para los números en coma flotante es:
        <code class="type">float</code>, <code class="type">double</code> y <code class="type">long
        double</code>. «long float» no es un tipo
        válido. No hay números en coma flotantes de tamaño
        <code class="keyword">short</code>.
      </p><p>
        Los especificadores <code class="keyword">signed</code> y <code class="keyword">unsigned</code> indican
        al compilador cómo utilizar el bit del signo con los tipos
        enteros y los caracteres (los números de coma flotante siempre
        contienen un signo). Un número <code class="keyword">unsigned</code> no guarda el
        valor del signo y por eso tiene un bit extra disponible, de modo
        que puede guardar el doble de números positivos que pueden
        guardarse en un número <code class="keyword">signed</code>. <code class="keyword">signed</code> se
        supone por defecto y sólo es necesario con <code class="type">char</code>,
        <code class="type">char</code> puede ser o no por defecto un
        <code class="keyword">signed</code>. Especificando <code class="type">signed char</code>, se está
        forzando el uso del bit del signo.
      </p><p>
        El siguiente ejemplo muestra el tamaño de los tipos de datos en
        bytes utilizando el operador <code class="literal">sizeof</code>, descripto más
        adelante en ese capítulo:
      </p><div class="example"><a id="idp4480232"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Specify.cpp</span>
<span class="hl slc">// Demonstrates the use of specifiers</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span> cu<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">unsigned int</span> iu<span class="hl opt">;</span>
  <span class="hl kwb">short int</span> is<span class="hl opt">;</span>
  <span class="hl kwb">short</span> iis<span class="hl opt">;</span> <span class="hl slc">// Same as short int</span>
  <span class="hl kwb">unsigned short int</span> isu<span class="hl opt">;</span>
  <span class="hl kwb">unsigned short</span> iisu<span class="hl opt">;</span>
  <span class="hl kwb">long int</span> il<span class="hl opt">;</span>
  <span class="hl kwb">long</span> iil<span class="hl opt">;</span>  <span class="hl slc">// Same as long int</span>
  <span class="hl kwb">unsigned long int</span> ilu<span class="hl opt">;</span>
  <span class="hl kwb">unsigned long</span> iilu<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
  <span class="hl kwb">long double</span> ld<span class="hl opt">;</span>
  cout 
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">char= &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>c<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">unsigned char = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>cu<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">int = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>i<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">unsigned int = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>iu<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">short = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>is<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">unsigned short = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>isu<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">long = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>il<span class="hl opt">)</span> 
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">unsigned long = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>ilu<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">float = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>f<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">double = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>d<span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span> <span class="hl str">long double = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>ld<span class="hl opt">)</span> 
    <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.12. C03/Specify.cpp</strong></p></div><br class="example-break" /><p>
        Tenga en cuenta que es probable que los resultados que se
        consiguen ejecutando este programa sean diferentes de una
        maquina/sistema operativo/compilador a otro, ya que (como se
        mencionaba anteriormente) lo único que ha de ser consistente es
        que cada tipo diferente almacene los valores mínimos y máximos
        especificados en el Estándar.
      </p><p>
        Cuando se modifica un <code class="type">int</code> con <code class="keyword">short</code> o
        <code class="keyword">long</code>, la palabra reservada <code class="type">int</code> es
        opcional, como se muestra a continuación.
      </p></div><div class="sect2" title="3.4.4. Introducción a punteros"><div class="titlepage"><div><div><h3 class="title"><a id="idp4484720"></a>3.4.4. Introducción a punteros</h3></div></div></div><p>
        Siempre que se ejecuta un programa, se carga primero
        (típicamente desde disco) a la memoria del ordenador. De este
        modo, todos los elementos del programa se ubican en algún lugar
        de la memoria. La memoria se representa normalmente como series
        secuenciales de posiciones de memoria; normalmente se hace
        referencia a estas localizaciones como bytes de ocho bits, pero
        realmente el tamaño de cada espacio depende de la arquitectura
        de cada máquina particular y se llamada normalmente tamaño de
        palabra de la máquina. Cada espacio se puede distinguir
        unívocamente de todos los demás espacios por su dirección. Para
        este tema en particular, se establecerá que todas las máquinas
        usan bytes que tienen direcciones secuenciales, comenzando en
        cero y subiendo hasta la cantidad de memoria que posea la
        máquina.
      </p><p>
	Como el programa reside en memoria mientras se está ejecutando,
	cada elemento de dicho programa tiene una dirección. Suponga que
	empezamos con un programa simple:
      </p><div class="example"><a id="idp4487864"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:YourPets1.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> dog<span class="hl opt">,</span> cat<span class="hl opt">,</span> bird<span class="hl opt">,</span> fish<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> pet<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;pet id number: &quot;</span> <span class="hl opt">&lt;&lt;</span> pet <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.13. C03/YourPets1.cpp</strong></p></div><br class="example-break" /><p>
        Cada uno de los elementos de este programa tiene una
        localización en memoria mientras el programa se está
        ejecutando. Incluso las funciones ocupan espacio. Como verá,
        se da por sentado que el tipo de un elemento y la forma
        en que se define determina normalmente el área de memoria en la
        que se ubica dicho elemento.
      </p><p>
	Hay un operador en C y C++ que permite averiguar la dirección de
	un elemento. Se trata del operador <code class="literal">&amp;</code>. Sólo hay
	que anteponer el operador <code class="literal">&amp;</code> delante del nombre
	identificador y obtendrá la dirección de ese identificador. Se
	puede modificar <code class="filename">YourPets1.cpp</code> para mostrar
	las direcciones de todos sus elementos, del siguiente modo:
      </p><div class="example"><a id="idp4491952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:YourPets2.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> dog<span class="hl opt">,</span> cat<span class="hl opt">,</span> bird<span class="hl opt">,</span> fish<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> pet<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;pet id number: &quot;</span> <span class="hl opt">&lt;&lt;</span> pet <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;f(): &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;dog: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>dog <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;cat: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>cat <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;bird: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>bird <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fish: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>fish <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;j: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>j <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;k: &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>k <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.14. C03/YourPets2.cpp</strong></p></div><br class="example-break" /><p>
	El <code class="code">(long)</code> es una molde. Indica «No tratar
	como su tipo normal, sino como un <code class="type">long</code>». El
	molde no es esencial, pero si no existiese, las direcciones
	aparecerían en hexadecimal, de modo que el moldeado a
	<code class="type">long</code> hace las cosas más legibles.
      </p><p>
	Los resultados de este programa variarán dependiendo del
	computador, del sistema operativo, y de muchos otros tipos de
	factores, pero siempre darán un resultado interesante. Para una
	única ejecución en mi computador, los resultados son como estos:
      </p><pre class="programlisting">
<span class="hl kwd">f</span><span class="hl opt">():</span> <span class="hl num">4198736</span>
dog<span class="hl opt">:</span> <span class="hl num">4323632</span>
cat<span class="hl opt">:</span> <span class="hl num">4323636</span>
bird<span class="hl opt">:</span> <span class="hl num">4323640</span>
fish<span class="hl opt">:</span> <span class="hl num">4323644</span>
i<span class="hl opt">:</span> <span class="hl num">6684160</span>
j<span class="hl opt">:</span> <span class="hl num">6684156</span>
k<span class="hl opt">:</span> <span class="hl num">6684152</span>
</pre><p>
	Se puede apreciar como las variables que se han definido dentro
	de <code class="function">main()</code> están en un área distinta que las
	variables definidas fuera de <code class="function">main()</code>;
	entenderá el porque cuando se profundice más en el
	lenguaje. También, <code class="function">f()</code> parece estar en su
	propia área; el código normalmente se separa del resto de los
	datos en memoria.
      </p><p>
	Otra cosa a tener en cuenta es que las variables definidas una a
	continuación de la otra parecen estar ubicadas de manera
	contigua en memoria. Están separadas por el número de bytes
	requeridos por su tipo de dato. En este programa el único tipo
	de dato utilizado es el <code class="type">int</code>, y la variable
	<code class="varname">cat</code> está separada de <code class="varname">dog</code>
	por cuatro bytes, <code class="varname">bird</code> está separada por
	cuatro bytes de <code class="varname">cat</code>, etc. De modo que en el
	computador en que ha sido ejecutado el programa, un entero ocupa
	cuatro bytes.
      </p><p>
	¿Qué se puede hacer con las direcciones de memoria, además de
	este interesante experimento de mostrar cuanta memoria ocupan?
	Lo más importante que se puede hacer es guardar esas direcciones
	dentro de otras variables para su uso posterior. C y C++ tienen
	un tipo de variable especial para guardar una dirección. Esas
	variables se llaman <span class="emphasis"><em>punteros</em></span>.
      </p><p>
	El operador que define un puntero es el mismo que se utiliza
	para la multiplicación: <span class="token">*</span>. El compilador sabe que
	no es una multiplicación por el contexto en el que se usa, tal
	como podrá comprobar.
      </p><p>
	Cuando se define un puntero, se debe especificar el tipo de
	variable al que apunta. Se comienza dando el nombre de dicho
	tipo, después en lugar de escribir un identificador para la
	variable, usted dice «Espera, esto es un puntero»
	insertando un asterisco entre el tipo y el identificador. De
	modo que un puntero a <code class="type">int</code> tiene este aspecto:
      </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> ip<span class="hl opt">;</span> <span class="hl slc">// ip apunta a una variable int</span>
</pre><p>
	La asociación del <span class="token">*</span> con el tipo parece práctica y
	legible, pero puede ser un poco confusa. La tendencia podría ser
	decir «puntero-entero» como un si fuese un tipo
	simple. Sin embargo, con un <code class="type">int</code> u otro tipo de
	datos básico, se puede decir:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> a<span class="hl opt">,</span> b<span class="hl opt">,</span> c<span class="hl opt">;</span>
</pre><p>
	así que con un puntero, diría:
      </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> ipa<span class="hl opt">,</span> ipb<span class="hl opt">,</span> ipc<span class="hl opt">;</span>
</pre><p>
	La sintaxis de C (y por herencia, la de C++) no permite
	expresiones tan cómodas. En las definiciones anteriores, sólo
	<code class="varname">ipa</code> es un puntero, pero
	<code class="varname">ipb</code> e <code class="varname">ipc</code> son
	<code class="type">ints</code> normales (se puede decir que
	«<code class="literal">*</code> está mas unido al
	identificador»). Como consecuencia, los mejores resultados
	se pueden obtener utilizando sólo una definición por línea; y
	aún se conserva una sintaxis cómoda y sin la confusión:
      </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> ipa<span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> ipb<span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> ipc<span class="hl opt">;</span>
</pre><p>
	Ya que una pauta de programación de C++ es que siempre se debe
	inicializar una variable al definirla, realmente este modo
	funciona mejor. Por ejemplo, Las variables anteriores no se
	inicializan con ningún valor en particular; contienen basura. Es
	más fácil decir algo como:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> ipa <span class="hl opt">= &amp;</span>a<span class="hl opt">;</span>
</pre><p>
	Ahora tanto <code class="varname">a</code> como <code class="varname">ipa</code>
	están inicializadas, y <code class="varname">ipa</code> contiene la
	dirección de <code class="varname">a</code>.
      </p><p>
	Una vez que se inicializa un puntero, lo más básico que se puede
	hacer con Él es utilizarlo para modificar el valor de lo que
	apunta. Para acceder a la variable a través del puntero, se
	<span class="emphasis"><em>dereferencia</em></span> el puntero utilizando el mismo
	operador que se usó para definirlo, como sigue:
      </p><pre class="programlisting">
<span class="hl opt">*</span>ipa <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
</pre><p>
	Ahora <code class="varname">a</code> contiene el valor 100 en vez de 47.
      </p><p>
	Estas son las normas básicas de los punteros: se puede guardar
	una dirección, y se puede utilizar dicha dirección para
	modificar la variable original. Pero la pregunta aún
	permanece: ¿por qué se querría cambiar una variable utilizando
	otra variable como intermediario?
      </p><p>
	Para esta visión introductoria a los punteros, podemos dividir la
	respuesta en dos grandes categorías:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    Para cambiar «objetos externos» desde dentro de
	    una función. Esto es quizás el uso más básico de los
	    punteros, y se examinará más adelante.
	  </p></li><li class="listitem"><p>
	    Para conseguir otras muchas técnicas de programación
	    ingeniosas, sobre las que aprenderá en el resto del libro.
	  </p></li></ol></div></div><div class="sect2" title="3.4.5. Modificar objetos externos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4514992"></a>3.4.5. Modificar objetos externos</h3></div></div></div><p>
        Normalmente, cuando se pasa un argumento a una función, se hace
        una copia de dicho argumento dentro de la función. Esto se llama
        <span class="emphasis"><em>paso-por-valor</em></span>. Se puede ver el efecto de
        un paso-por-valor en el siguiente programa:
      </p><div class="example"><a id="idp4516112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PassByValue.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  a <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.15. C03/PassByValue.cpp</strong></p></div><br class="example-break" /><p>
	En <code class="function">f()</code>, <code class="varname">a</code> es una
	variable local, de modo que existe únicamente mientras dura la
	llamada a la función <code class="function">f()</code>. Como es un
	argumento de una función, el valor de <code class="varname">a</code> se
	inicializa mediante los argumentos que se pasan en la invocación
	de la función; en <code class="function">main()</code> el argumento es
	<code class="varname">x</code>, que tiene un valor 47, de modo que el
	valor es copiado en <code class="varname">a</code> cuando se llama a
	<code class="function">f()</code>.
      </p><p>
	Cuando ejecute el programa verá:
      </p><pre class="screen">
x = 47
a = 47
a = 5
x = 47
</pre><p>
	Por supuesto, inicialmente <code class="varname">x</code> es 47. Cuando se
	llama <code class="function">f()</code>, se crea un espacio temporal para
	alojar la variable <code class="varname">a</code> durante la ejecución de
	la función, y el valor de <code class="varname">x</code> se copia a
	<code class="varname">a</code>, el cual es verificado mostrándolo por
	pantalla. Se puede cambiar el valor de <code class="varname">a</code> y
	demostrar que ha cambiado. Pero cuando <code class="function">f()</code>
	termina, el espacio temporal que se había creado para
	<code class="varname">a</code> desaparece, y se puede observar que la
	única conexión que existía entre <code class="varname">a</code> y
	<code class="varname">x</code> ocurrió cuando el valor de
	<code class="varname">x</code> se copió en <code class="varname">a</code>.
      </p><p>
	Cuando está dentro de <code class="function">f()</code>,
	<code class="varname">x</code> es el <span class="emphasis"><em>objeto externo</em></span>
	(mi terminología), y cambiar el valor de la variable local no
	afecta al objeto externo, lo cual es bastante lógico, puesto que
	son dos ubicaciones separadas en la memoria. Pero ¿y si quiere
	modificar el objeto externo? Aquí es donde los punteros entran
	en acción. En cierto sentido, un puntero es un alias de otra
	variable. De modo que si a una función se le pasa un puntero en
	lugar de un valor ordinario, se está pasando de hecho un alias
	del objeto externo, dando la posibilidad a la función de que
	pueda modificar el objeto externo, tal como sigue:
      </p><div class="example"><a id="idp4526136"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PassAddress.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p = &quot;</span> <span class="hl opt">&lt;&lt;</span> p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;*p = &quot;</span> <span class="hl opt">&lt;&lt; *</span>p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">*</span>p <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p = &quot;</span> <span class="hl opt">&lt;&lt;</span> p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;x = &quot;</span> <span class="hl opt">&lt;&lt; &amp;</span>x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(&amp;</span>x<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.16. C03/PassAddress.cpp</strong></p></div><br class="example-break" /><p>
	Ahora <code class="function">f()</code> toma el puntero como un argumento
	y dereferencia el puntero durante la asignación, lo que modifica
	el objeto externo <code class="varname">x</code>. La salida es:
      </p><pre class="screen">
x = 47
&amp;x = 0065FE00
p = 0065FE00
*p = 47
p = 0065FE00
x = 5
</pre><p>
	Tenga en cuenta que el valor contenido en <code class="varname">p</code>
	es el mismo que la dirección de <code class="varname">x</code> - el
	puntero <code class="varname">p</code> de hecho apunta a
	<code class="varname">x</code>. Si esto no es suficientemente convincente,
	cuando <code class="varname">p</code> es dereferenciado para asignarle el
	valor 5, se ve que el valor de <code class="varname">x</code> cambia a 5
	también.
      </p><p>
	De ese modo, pasando un puntero a una función le permitirá a esa
	función modificar el objeto externo. Se verán muchos otros usos
	de los punteros más adelante, pero podría decirse que éste es el
	más básico y posiblemente el más común.
      </p></div><div class="sect2" title="3.4.6. Introducción a las referencias de C++"><div class="titlepage"><div><div><h3 class="title"><a id="idp4531408"></a>3.4.6. Introducción a las referencias de C++</h3></div></div></div><p>
	Los punteros funcionan más o menos igual en C y en C++, pero C++
	añade un modo adicional de pasar una dirección a una función. Se
	trata del <span class="emphasis"><em>paso-por-referencia</em></span> y existe en
	otros muchos lenguajes, de modo que no es una invención de C++.
      </p><p>
	La primera impresión que dan las referencias es que no son
	necesarias, que se pueden escribir cualquier programa sin
	referencias. En general, eso es verdad, con la excepción de unos
	pocos casos importantes que se tratarán más adelante en el
	libro, pero la idea básica es la misma que la demostración
	anterior con el puntero: se puede pasar la dirección de un
	argumento utilizando una referencia. La diferencia entre
	referencias y punteros es que <span class="emphasis"><em>invocar</em></span> a una
	función que recibe referencias es mas limpio, sintácticamente,
	que llamar a una función que recibe punteros (y es exactamente
	esa diferencia sintáctica la que hace a las referencias
	esenciales en ciertas situaciones). Si
	<code class="filename">PassAddress.cpp</code> se modifica para utilizar
	referencias, se puede ver la diferencia en la llamada a la
	función en <code class="function">main()</code>:
      </p><div class="example"><a id="idp4535024"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PassReference.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;r = &quot;</span> <span class="hl opt">&lt;&lt;</span> r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;r = &quot;</span> <span class="hl opt">&lt;&lt; &amp;</span>r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  r <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;r = &quot;</span> <span class="hl opt">&lt;&lt;</span> r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;x = &quot;</span> <span class="hl opt">&lt;&lt; &amp;</span>x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">);</span> <span class="hl slc">// Looks like pass-by-value, </span>
        <span class="hl slc">// is actually pass by reference</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.17. C03/PassReference.cpp</strong></p></div><br class="example-break" /><p>
        En la lista de argumentos de <code class="function">f()</code>, en lugar
        de escribir <code class="type">int*</code> para pasar un puntero, se escribe
        <code class="type">int&amp;</code> para pasar una referencia. Dentro de
        <code class="function">f()</code>, si dice simplemente
        <code class="varname">r</code> (lo que produciría la dirección si
        <code class="varname">r</code> fuese un puntero) se obtiene <span class="emphasis"><em>el
        valor en la variable que <code class="varname">r</code> está
        referenciando</em></span>. Si se asigna a <code class="varname">r</code>,
        en realidad se está asignado a la variable a la que que
        <code class="varname">r</code> referencia.  De hecho, la única manera de
        obtener la dirección que contiene <code class="varname">r</code> es con el
        operador <code class="literal">&amp;</code>.
      </p><p>
	En <code class="function">main()</code>, se puede ver el efecto clave de
	las referencias en la sintaxis de la llamada a
	<code class="function">f()</code>, que es simplemente
	<code class="code">f(x)</code>. Aunque eso parece un paso-por-valor
	ordinario, el efecto de la referencia es que en realidad toma la
	dirección y la pasa, en lugar de hacer una copia del valor. La
	salida es:
      </p><pre class="screen">
x = 47
&amp;x = 0065FE00
r = 47
&amp;r = 0065FE00
r = 5
x = 5
</pre><p>
	De manera que se puede ver que un paso-por-referencia permite a
	una función modificar el objeto externo, al igual que al pasar
	un puntero (también se puede observar que la referencia esconde
	el hecho de que se está pasando una dirección; esto se verá más
	adelante en el libro). Gracias a esta pequeña introducción se
	puede asumir que las referencias son sólo un modo
	sintácticamente distinto (a veces referido como «azúcar
	sintáctico») para conseguir lo mismo que los punteros:
	permitir a las funciones cambiar los objetos externos.
      </p></div><div class="sect2" title="3.4.7. Punteros y Referencias como modificadores"><div class="titlepage"><div><div><h3 class="title"><a id="idp4543480"></a>3.4.7.  Punteros y Referencias como modificadores </h3></div></div></div><p>
	Hasta ahora, se han visto los tipos básicos de datos
	<code class="type">char</code>, <code class="type">int</code>, <code class="type">float</code>, y
	<code class="type">double</code>, junto con los especificadores
	<code class="type">signed</code>, <code class="type">unsigned</code>, <code class="type">short</code>,
	y <code class="type">long</code>, que se pueden utilizar con los tipos
	básicos de datos en casi cualquier combinación. Ahora hemos
	añadido los punteros y las referencias, que son lo ortogonal a
	los tipos básicos de datos y los especificadores, de modo que
	las combinaciones posibles se acaban de triplicar:
      </p><div class="example"><a id="idp4546320"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:AllDefinitions.cpp</span>
<span class="hl slc">// All possible combinations of basic data types, </span>
<span class="hl slc">// specifiers, pointers and references</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f1</span><span class="hl opt">(</span><span class="hl kwb">char</span> c<span class="hl opt">,</span> <span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">float</span> f<span class="hl opt">,</span> <span class="hl kwb">double</span> d<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f2</span><span class="hl opt">(</span><span class="hl kwb">short int</span> si<span class="hl opt">,</span> <span class="hl kwb">long int</span> li<span class="hl opt">,</span> <span class="hl kwb">long double</span> ld<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f3</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span> uc<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span> ui<span class="hl opt">,</span> 
  <span class="hl kwb">unsigned short int</span> usi<span class="hl opt">,</span> <span class="hl kwb">unsigned long int</span> uli<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f4</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">*</span> ip<span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">*</span> fp<span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">*</span> dp<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f5</span><span class="hl opt">(</span><span class="hl kwb">short int</span><span class="hl opt">*</span> sip<span class="hl opt">,</span> <span class="hl kwb">long int</span><span class="hl opt">*</span> lip<span class="hl opt">,</span> 
  <span class="hl kwb">long double</span><span class="hl opt">*</span> ldp<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f6</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span><span class="hl opt">*</span> ucp<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span><span class="hl opt">*</span> uip<span class="hl opt">,</span> 
  <span class="hl kwb">unsigned short int</span><span class="hl opt">*</span> usip<span class="hl opt">,</span> 
  <span class="hl kwb">unsigned long int</span><span class="hl opt">*</span> ulip<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f7</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">&amp;</span> cr<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">&amp;</span> ir<span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">&amp;</span> fr<span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">&amp;</span> dr<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f8</span><span class="hl opt">(</span><span class="hl kwb">short int</span><span class="hl opt">&amp;</span> sir<span class="hl opt">,</span> <span class="hl kwb">long int</span><span class="hl opt">&amp;</span> lir<span class="hl opt">,</span> 
  <span class="hl kwb">long double</span><span class="hl opt">&amp;</span> ldr<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">f9</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span><span class="hl opt">&amp;</span> ucr<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span><span class="hl opt">&amp;</span> uir<span class="hl opt">,</span> 
  <span class="hl kwb">unsigned short int</span><span class="hl opt">&amp;</span> usir<span class="hl opt">,</span> 
  <span class="hl kwb">unsigned long int</span><span class="hl opt">&amp;</span> ulir<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.18. C03/AllDefinitions.cpp</strong></p></div><br class="example-break" /><p>
	Los punteros y las referencias entran en juego también cuando se
	pasan objetos dentro y fuera de las funciones; aprenderá sobre
	ello en un capítulo posterior.
      </p><p>
	Hay otro tipo que funciona con punteros: <code class="type">void</code>. Si
	se establece que un puntero es un <code class="type">void*</code>, significa
	que cualquier tipo de dirección se puede asignar a ese puntero
	(en cambio si tiene un <code class="type">int*</code>, sólo puede asignar la
	dirección de una variable <code class="type">int</code> a ese puntero). Por
	ejemplo:
      </p><div class="example"><a id="idp4550560"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:VoidPointer.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> vp<span class="hl opt">;</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
  <span class="hl slc">// The address of ANY type can be</span>
  <span class="hl slc">// assigned to a void pointer:</span>
  vp <span class="hl opt">= &amp;</span>c<span class="hl opt">;</span>
  vp <span class="hl opt">= &amp;</span>i<span class="hl opt">;</span>
  vp <span class="hl opt">= &amp;</span>f<span class="hl opt">;</span>
  vp <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.19. C03/VoidPointer.cpp</strong></p></div><br class="example-break" /><p>
	Una vez que se asigna a un <code class="type">void*</code> se pierde
	cualquier información sobre el tipo de la variables. Esto
	significa que antes de que se pueda utilizar el puntero, se debe
	moldear al tipo correcto:
      </p><div class="example"><a id="idp4552520"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:CastFromVoidPointer.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">99</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> vp <span class="hl opt">= &amp;</span>i<span class="hl opt">;</span>
  <span class="hl slc">// Can't dereference a void pointer:</span>
  <span class="hl slc">// *vp = 3; // Compile-time error</span>
  <span class="hl slc">// Must cast back to int before dereferencing:</span>
  <span class="hl opt">*((</span><span class="hl kwb">int</span><span class="hl opt">*)</span>vp<span class="hl opt">) =</span> <span class="hl num">3</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.20. C03/CastFromVoidPointer.cpp</strong></p></div><br class="example-break" /><p>
	El molde <code class="code">(int*)vp</code> toma el <code class="type">void*</code> y le
	dice al compilador que lo trate como un <code class="type">int*</code>, y de
	ese modo se puede dereferenciar correctamente.  Puede observar
	que esta sintaxis es horrible, y lo es, pero es peor que eso -
	el <code class="type">void*</code> introduce un agujero en el sistema de
	tipos del lenguaje.  Eso significa, que permite, o incluso
	promueve, el tratamiento de un tipo como si fuera otro tipo. En
	el ejemplo anterior, se trata un <code class="type">int</code> como un
	<code class="type">int</code> mediante el moldeado de <code class="varname">vp</code> a
	<code class="type">int*</code>, pero no hay nada que indique que no se lo
	puede moldear a <code class="type">char*</code> o <code class="type">double*</code>, lo
	que modificaría una cantidad diferente de espacio que ha sido
	asignada al <code class="type">int</code>, lo que posiblemente provocará que
	el programa falle.. En general, los punteros <code class="type">void</code>
	deberían ser evitados, y utilizados únicamente en raras
	ocasiones, que no se podrán considerar hasta bastante más
	adelante en el libro.
      </p><p>
	No se puede tener una referencia <code class="type">void</code>, por razones
	que se explicarán en el capítulo 11.
      </p></div></div><div class="sect1" title="3.5. Alcance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4558336"></a>3.5. Alcance</h2></div></div></div><p>
      Las reglas de ámbitos dicen cuando es válida una variable, dónde
      se crea, y cuándo se destruye (es decir, sale de ámbito).  El
      ámbito de una variable se extiende desde el punto donde se define
      hasta la primera llave que empareja con la llave de apertura antes
      de que la variable fuese definida. Eso quiere decir que un ámbito
      se define por su juego de llaves «más cercanas». Para
      ilustrarlo:
    </p><div class="example"><a id="idp4559728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Scope.cpp</span>
<span class="hl slc">// How variables are scoped</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> scp1<span class="hl opt">;</span>
  <span class="hl slc">// scp1 visible here</span>
  <span class="hl opt">{</span>
    <span class="hl slc">// scp1 still visible here</span>
    <span class="hl slc">//.....</span>
    <span class="hl kwb">int</span> scp2<span class="hl opt">;</span>
    <span class="hl slc">// scp2 visible here</span>
    <span class="hl slc">//.....</span>
    <span class="hl opt">{</span>
      <span class="hl slc">// scp1 &amp; scp2 still visible here</span>
      <span class="hl slc">//..</span>
      <span class="hl kwb">int</span> scp3<span class="hl opt">;</span>
      <span class="hl slc">// scp1, scp2 &amp; scp3 visible here</span>
      <span class="hl slc">// ...</span>
    <span class="hl opt">}</span> <span class="hl slc">// &lt;-- scp3 destroyed here</span>
    <span class="hl slc">// scp3 not available here</span>
    <span class="hl slc">// scp1 &amp; scp2 still visible here</span>
    <span class="hl slc">// ...</span>
  <span class="hl opt">}</span> <span class="hl slc">// &lt;-- scp2 destroyed here</span>
  <span class="hl slc">// scp3 &amp; scp2 not available here</span>
  <span class="hl slc">// scp1 still visible here</span>
  <span class="hl slc">//..</span>
<span class="hl opt">}</span> <span class="hl slc">// &lt;-- scp1 destroyed here</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.21. C03/Scope.cpp</strong></p></div><br class="example-break" /><p>
      El ejemplo anterior muestra cuándo las variables son visibles y
      cuando dejan de estar disponibles (es decir, cuando
      <span class="emphasis"><em>salen del ámbito</em></span>). Una variable se puede
      utilizar sólo cuando se está dentro de su ámbito. Los ámbitos
      pueden estar anidados, indicados por parejas de llaves dentro de
      otras parejas de llaves. El anidado significa que se puede acceder
      a una variable en un ámbito que incluye el ámbito en el que se
      está.  En el ejemplo anterior, la variable <code class="varname">scp1</code>
      está disponible dentro de todos los demás ámbitos, mientras que
      <code class="varname">scp3</code> sólo está disponible en el ámbito más
      interno.
    </p><div class="sect2" title="3.5.1. Definición de variables «al vuelo»"><div class="titlepage"><div><div><h3 class="title"><a id="idp4563608"></a>3.5.1. Definición de variables «al vuelo»</h3></div></div></div><p>
	Como se ha mencionado antes en este capítulo, hay una diferencia
	importante entre C y C++ al definir variables. Ambos lenguajes
	requieren que las variables estén definidas antes de utilizarse,
	pero C (y muchos otros lenguajes procedurales tradicionales)
	fuerzan a que se definan todas las variables al principio del
	bloque, de modo que cuando el compilador crea un bloque puede
	crear espacio para esas variables.
      </p><p>
	Cuando uno lee código C, normalmente lo primero que encuentra
	cuando empieza un ámbito, es un bloque de definiciones de
	variables.  Declarar todas las variables al comienzo de un
	bloque requiere que el programador escriba de un modo particular
	debido a los detalles de implementación del lenguaje.  La
	mayoría de las personas no conocen todas las variables que van a
	utilizar antes de escribir el código, de modo que siempre están
	volviendo al principio del bloque para insertar nuevas
	variables, lo cual resulta pesado y causa errores.  Normalmente
	estas definiciones de variables no significan demasiado para el
	lector, y de hecho tienden a ser confusas porque aparecen
	separadas del contexto en el cual se utilizan.
      </p><p>
	C++ (pero no C) permite definir variables en cualquier sitio
	dentro de un ámbito, de modo que se puede definir una variable
	justo antes de usarla.  Además, se puede inicializar la variable
	en el momento de la definición, lo que previene cierto tipo de
	errores. Definir las variables de este modo hace el código más
	fácil de escribir y reduce los errores que provoca estar
	forzado a volver atrás y adelante dentro de un ámbito. Hace el
	código más fácil de entender porque es una variable definida en
	el contexto de su utilización. Esto es especialmente importante
	cuando se está definiendo e inicializando una variable al mismo
	tiempo - se puede ver el significado del valor de inicialización
	por el modo en el que se usa la variable.
      </p><p>
	También se pueden definir variables dentro de expresiones de
	control tales como los bucles <code class="keyword">for</code> y <code class="keyword">while</code>,
	dentro de las sentencias de condiciones <code class="keyword">if</code>, y dentro de
	la sentencia de selección <code class="keyword">switch</code>. A continuación hay un
	ejemplo que muestra la definición de variables al-vuelo:
      </p><div class="example"><a id="idp4571064"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:OnTheFly.cpp</span>
<span class="hl slc">// On-the-fly variable definitions</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">//..</span>
  <span class="hl opt">{</span> <span class="hl slc">// Begin a new scope</span>
    <span class="hl kwb">int</span> q <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// C requires definitions here</span>
    <span class="hl slc">//..</span>
    <span class="hl slc">// Define at point of use:</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span> 
      q<span class="hl opt">++;</span> <span class="hl slc">// q comes from a larger scope</span>
      <span class="hl slc">// Definition at the end of the scope:</span>
      <span class="hl kwb">int</span> p <span class="hl opt">=</span> <span class="hl num">12</span><span class="hl opt">;</span> 
    <span class="hl opt">}</span>
    <span class="hl kwb">int</span> p <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>  <span class="hl slc">// A different p</span>
  <span class="hl opt">}</span> <span class="hl slc">// End scope containing q &amp; outer p</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Type characters:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwb">char</span> c <span class="hl opt">=</span> cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">() !=</span> <span class="hl str">'q'</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; wasn't it&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwb">char</span> x <span class="hl opt">=</span> c <span class="hl opt">==</span> <span class="hl str">'a'</span> <span class="hl opt">||</span> c <span class="hl opt">==</span> <span class="hl str">'b'</span><span class="hl opt">)</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;You typed a or b&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">else</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;You typed &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Type A, B, or C&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">switch</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">()) {</span>
    <span class="hl kwa">case</span> <span class="hl str">'A'</span><span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Snap&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> <span class="hl str">'B'</span><span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Crackle&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> <span class="hl str">'C'</span><span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Pop&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">default</span><span class="hl opt">:</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Not A, B or C!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.22. C03/OnTheFly.cpp</strong></p></div><br class="example-break" /><p>
	En el ámbito más interno, se define <code class="varname">p</code> antes
	de que acabe el ámbito, de modo que realmente es un gesto inútil
	(pero demuestra que se puede definir una variable en cualquier
	sitio).  La variable <code class="varname">p</code> en el ámbito exterior
	está en la misma situación.
      </p><p>
	La definición de <code class="varname">i</code> en la expresión de control
	del bucle <code class="keyword">for</code> es un ejemplo de que es posible definir
	una variable exactamente en el punto en el que se necesita (esto
	sólo se puede hacer en C++). El ámbito de <code class="varname">i</code>
	es el ámbito de la expresión controlada por el bucle
	<code class="keyword">for</code>, de modo que se puede re-utilizar
	<code class="varname">i</code> en el siguiente bucle <code class="keyword">for</code>. Se
	trata de un modismo conveniente y común en C++;
	<code class="varname">i</code> es el nombre habitual para el contador de
	un <code class="keyword">for</code> y así no hay que inventar nombres nuevos.
      </p><p>
	A pesar de que el ejemplo también muestra variables definidas
	dentro de las sentencias <code class="keyword">while</code>, <code class="keyword">if</code> y
	<code class="keyword">switch</code>, este tipo de definiciones es menos común que
	las de expresiones <code class="keyword">for</code>, quizás debido a que la sintaxis
	es más restrictiva.  Por ejemplo, no se puede tener ningún
	paréntesis. Es decir, que no se puede indicar:
      </p><pre class="programlisting">
<span class="hl kwa">while</span><span class="hl opt">((</span><span class="hl kwb">char</span> c <span class="hl opt">=</span> cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">()) !=</span> <span class="hl str">'q'</span><span class="hl opt">)</span>
</pre><p>
	Añadir los paréntesis extra parecería una acción inocente y
	útil, y debido a que no se pueden utilizar, los resultados no
	son los esperados. El problema ocurre porque <code class="literal">!=</code>
	tiene orden de precedencia mayor que <code class="literal">=</code>, de modo que
	el <code class="code">char c</code> acaba conteniendo un <code class="type">bool</code>
	convertido a <code class="type">char</code>. Cuando se muestra, en
	muchos terminales se vería el carácter de la cara sonriente.
      </p><p>
	En general, se puede considerar la posibilidad de definir
	variables dentro de las sentencias <code class="keyword">while</code>, <code class="keyword">if</code> y
	<code class="keyword">switch</code> por completitud, pero el único lugar donde se
	debería utilizar este tipo de definición de variables es en el
	bucle <code class="keyword">for</code> (dónde usted las utilizará más a menudo).
      </p></div></div><div class="sect1" title="3.6. Especificar la ubicación del espacio de almacenamiento"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4585696"></a>3.6.  Especificar la ubicación del espacio de almacenamiento</h2></div></div></div><p>
      Al crear una variable, hay varias alternativas para especificar
      la vida de dicha variable, la forma en que se decide la ubicación
      para esa variable y cómo la tratará el compilador.
    </p><div class="sect2" title="3.6.1. Variables globales"><div class="titlepage"><div><div><h3 class="title"><a id="idp4586752"></a>3.6.1.  Variables globales</h3></div></div></div><p>
	Las variables globales se definen fuera de todos los cuerpos de
	las funciones y están disponibles para todo el programa (incluso
	el código de otros ficheros). Las variables globales no están
	afectadas por ámbitos y están siempre disponibles (es decir, la
	vida de una variable global dura hasta la finalización del
	programa). Si la existencia de una variable global en un fichero
	se declara usando la palabra reservada <code class="keyword">extern</code> en otro
	fichero, la información está disponible para su utilización en
	el segundo fichero. A continuación, un ejemplo del uso de
	variables globales:
      </p><div class="example"><a id="idp4588816"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Global.cpp</span>
<span class="hl slc">//{L} Global2</span>
<span class="hl slc">// Demonstration of global variables</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> globe<span class="hl opt">;</span>
<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  globe <span class="hl opt">=</span> <span class="hl num">12</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> globe <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">func</span><span class="hl opt">();</span> <span class="hl slc">// Modifies globe</span>
  cout <span class="hl opt">&lt;&lt;</span> globe <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.23. C03/Global.cpp</strong></p></div><br class="example-break" /><p>
	Y el fichero que accede a <code class="varname">globe</code> como un
	<code class="keyword">extern</code>:
      </p><div class="example"><a id="idp4590888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Global2.cpp {O}</span>
<span class="hl slc">// Accessing external global variables</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> globe<span class="hl opt">;</span>  
<span class="hl slc">// (The linker resolves the reference)</span>
<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">() {</span>
  globe <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.24. C03/Global2.cpp</strong></p></div><br class="example-break" /><p>
	El espacio para la variable <code class="varname">globe</code> se crea
	mediante la definición en <code class="filename">Global.cpp</code>, y esa
	misma variable es accedida por el código de
	<code class="filename">Global2.cpp</code>. Ya que el código de
	<code class="filename">Global2.cpp</code> se compila separado del código
	de <code class="filename">Global.cpp</code>, se debe informar al
	compilador de que la variable existe en otro sitio mediante
	la declaración
      </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> globe<span class="hl opt">;</span>
</pre><p>
	Cuando ejecute el programa, observará que la llamada
	<code class="function">fun()</code> afecta efectivamente a la única
	instancia global de <code class="varname">globe</code>.
      </p><p>
	En <code class="filename">Global.cpp</code>, se puede ver el comentario
	con una marca especial (que es diseño mío):
      </p><pre class="programlisting">
<span class="hl slc">//{L} Global2</span>
</pre><p>
	Eso indica que para crear el programa final, el fichero objeto
	con el nombre <code class="filename">Global2</code> debe estar enlazado
	(no hay extensión ya que los nombres de las extensiones de los
	ficheros objeto difieren de un sistema a otro). En
	<code class="filename">Global2.cpp</code>, la primera línea tiene otra
	marca especial <code class="code">{O}</code>, que significa «No
	intentar crear un ejecutable de este fichero, se compila para
	que pueda enlazarse con otro fichero». El programa
	<code class="filename">ExtractCode.cpp</code> en el Volumen 2 de este
	libro (que se puede descargar de <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>) lee
	estas marcas y crea el <code class="filename">makefile</code> apropiado
	de modo que todo se compila correctamente (aprenderá sobre
	makefiles al final de este capítulo).
      </p></div><div class="sect2" title="3.6.2. Variables locales"><div class="titlepage"><div><div><h3 class="title"><a id="idp4599608"></a>3.6.2. Variables locales</h3></div></div></div><p>
	Las variables locales son las que se encuentran dentro de un
	ámbito; son «locales» a una función. A menudo se
	las llama variables automáticas porque aparecen automáticamente
	cuando se entra en un ámbito y desaparecen cuando el ámbito se
	acaba. La palabra reservada <code class="keyword">auto</code> lo enfatiza, pero las
	variables locales son <code class="keyword">auto</code> por defecto, de modo que
	nunca se necesita realmente declarar algo como <code class="keyword">auto</code>.
      </p><div class="sect3" title="Variables registro"><div class="titlepage"><div><div><h4 class="title"><a id="idp4602296"></a>Variables registro</h4></div></div></div><p>
	  Una variable registro es un tipo de variable local. La palabra
	  reservada <code class="keyword">register</code> indica al compilador «Haz
	  que los accesos a esta variable sean lo más rápidos
	  posible». Aumentar la velocidad de acceso depende de la
	  implementación, pero, tal como sugiere el nombre, a menudo se
	  hace situando la variable en un registro del
	  microprocesador. No hay garantía alguna de que la variable
	  pueda ser ubicada en un registro y tampoco de que la velocidad de
	  acceso aumente. Es una ayuda para el compilador.
        </p><p>
	  Hay restricciones a la hora de utilizar variables registro. No
	  se puede consular o calcular la dirección de una variable
	  registro. Una variable registro sólo se puede declarar
	  dentro de un bloque (no se pueden tener variables de registro
	  globales o estáticas). De todos modos, se pueden utilizar
	  como un argumento formal en una función (es decir, en la lista de
	  argumentos).
        </p><p>
	  En general, no se debería intentar influir sobre el
	  optimizador del compilador, ya que probablemente él hará mejor
	  el trabajo de lo que lo pueda hacer usted. Por eso, es mejor
	  evitar el uso de la palabra reservada <code class="keyword">register</code>.
        </p></div></div><div class="sect2" title="3.6.3. Static"><div class="titlepage"><div><div><h3 class="title"><a id="idp4606632"></a>3.6.3. Static</h3></div></div></div><p>
        La palabra reservada <code class="keyword">static</code> tiene varios
        significados. Normalmente, las variables definidas localmente a
        una función desaparecen al final del ámbito de ésta. Cuando se
        llama de nuevo a la función, el espacio de las variables se
        vuelve a pedir y las variables son re-inicializadas. Si se desea
        que el valor se conserve durante la vida de un programa, puede
        definir una variable local de una función como <code class="keyword">static</code> y
        darle un valor inicial.  La inicialización se realiza sólo la
        primera vez que se llama a la función, y la información se
        conserva entre invocaciones sucesivas de la función. De este
        modo, una función puede «recordar» cierta
        información entre una llamada y otra.
      </p><p>
        Puede surgir la duda de porqué no utilizar una variable global
        en este caso. El encanto de una variable <code class="keyword">static</code> es que
        no está disponible fuera del ámbito de la función, de modo que
        no se puede modificar accidentalmente. Esto facilita la
        localización de errores.
      </p><p>
        A continuación, un ejemplo del uso de variables <code class="keyword">static</code>:
      </p><div class="example"><a id="idp4611704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Static.cpp</span>
<span class="hl slc">// Using a static variable in a function</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">() {</span>
  <span class="hl kwb">static int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt; ++</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++)</span>
    <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.25. C03/Static.cpp</strong></p></div><br class="example-break" /><p>
        Cada vez que se llama a <code class="function">func()</code> dentro del
        bucle, se imprime un valor diferente. Si no se utilizara la
        palabra reservada <code class="keyword">static</code>, el valor mostrado sería
        siempre <code class="literal">1</code>.
      </p><p>
        El segundo significado de <code class="keyword">static</code> está relacionado con
        el primero en el sentido de que «no está disponible fuera
        de cierto ámbito». Cuando se aplica <code class="keyword">static</code> al
        nombre de una función o de una variable que está fuera de todas
        las funciones, significa «Este nombre no está disponible
        fuera de este fichero». El nombre de la función o de la
        variable es local al fichero; decimos que tiene ámbito de
        fichero. Como demostración, al compilar y enlazar los dos
        ficheros siguientes aparece un error en el enlazado:
      </p><div class="example"><a id="idp4616928"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:FileStatic.cpp</span>
<span class="hl slc">// File scope demonstration. Compiling and </span>
<span class="hl slc">// linking this file with FileStatic2.cpp</span>
<span class="hl slc">// will cause a linker error</span>

<span class="hl slc">// File scope means only available in this file:</span>
<span class="hl kwb">static int</span> fs<span class="hl opt">;</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  fs <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.26. C03/FileStatic.cpp</strong></p></div><br class="example-break" /><p>
        Aunque la variable <code class="varname">fs</code> está destinada a
        existir como un <code class="keyword">extern</code> en el siguiente fichero, el
        enlazador no la encontraría porque ha sido declarada
        <code class="keyword">static</code> en <code class="filename">FileStatic.cpp</code>.
      </p><div class="example"><a id="idp4619912"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:FileStatic2.cpp {O}</span>
<span class="hl slc">// Trying to reference fs</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> fs<span class="hl opt">;</span>
<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">() {</span>
  fs <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.27. C03/FileStatic2.cpp</strong></p></div><br class="example-break" /><p>
        El especificador <code class="keyword">static</code> también se puede usar dentro de
        una clase. Esta explicación se dará más adelante en este
        libro, cuando aprenda a crear clases.
      </p></div><div class="sect2" title="3.6.4. extern"><div class="titlepage"><div><div><h3 class="title"><a id="idp4621872"></a>3.6.4. extern</h3></div></div></div><p>
	La palabra reservada <code class="keyword">extern</code> ya ha sido brevemente
	descripta. Le dice al compilador que una variable o
	una función existe, incluso si el compilado aún no la ha visto
	en el fichero que está siendo compilado en ese momento. Esta
	variable o función puede definirse en otro fichero o más abajo
	en el fichero actual. A modo de ejemplo:
      </p><div class="example"><a id="idp4623464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Forward.cpp</span>
<span class="hl slc">// Forward function &amp; data declarations</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// This is not actually external, but the </span>
<span class="hl slc">// compiler must be told it exists somewhere:</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> i<span class="hl opt">;</span> 
<span class="hl kwc">extern</span> <span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> i<span class="hl opt">;</span> <span class="hl slc">// The data definition</span>
<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">() {</span>
  i<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.28. C03/Forward.cpp</strong></p></div><br class="example-break" /><p>
	Cuando el compilador encuentra la declaración <code class="code">extern int
	i</code> sabe que la definición para <code class="varname">i</code> debe
	existir en algún sitio como una variable global. Cuando el
	compilador alcanza la definición de <code class="varname">i</code>,
	ninguna otra declaración es visible, de modo que sabe que ha
	encontrado la misma <code class="varname">i</code> declarada anteriormente
	en el fichero. Si se hubiera definido <code class="varname">i</code> como
	<code class="keyword">static</code>, estaría indicando al compilador que
	<code class="varname">i</code> se define globalmente (por
	<code class="keyword">extern</code>), pero también que tiene el ámbito de fichero
	(por <code class="keyword">static</code>), de modo que el compilador generará un
	error.
      </p><div class="sect3" title="Enlazado"><div class="titlepage"><div><div><h4 class="title"><a id="idp4628640"></a>Enlazado</h4></div></div></div><p>
	  Para comprender el comportamiento de los programas C y C++, es
	  necesario saber sobre <span class="emphasis"><em>enlazado</em></span>. En un
	  programa en ejecución, un identificador se representa con
	  espacio en memoria que aloja una variable o un cuerpo de
	  función compilada. El enlazado describe este espacio tal como
	  lo ve el enlazador. Hay dos formas de enlazado:
	  <span class="emphasis"><em>enlace interno</em></span> y <span class="emphasis"><em>enlace
	  externo</em></span>.
        </p><p>
	  Enlace interno significa que el espacio se pide para
	  representar el identificador sólo durante la compilación del
	  fichero. Otros ficheros pueden utilizar el mismo nombre de
	  identificador con un enlace interno, o para una variable
	  global, y el enlazador no encontraría conflictos - se pide un
	  espacio separado para cada identificador. El enlace interno se
	  especifica mediante la palabra reservada <code class="keyword">static</code> en C
	  y C++.
        </p><p>
	  Enlace externo significa que se pide sólo un espacio para
	  representar el identificador para todos los ficheros que se
	  estén compilando. El espacio se pide una vez, y el enlazador
	  debe resolver todas las demás referencias a esa ubicación. Las
	  variables globales y los nombres de función tienen enlace
	  externo. Son accesibles desde otros ficheros declarándolas con
	  la palabra reservada <code class="keyword">extern</code>. Por defecto, las
	  variables definidas fuera de todas las funciones (con la
	  excepción de <code class="keyword">const</code> en C++) y las definiciones de las
	  funciones implican enlace externo. Se pueden forzar
	  específicamente a tener enlace interno utilizando
	  <code class="keyword">static</code>. Se puede establecer explícitamente que un
	  identificador tiene enlace externo definiéndolo como
	  <code class="keyword">extern</code>. No es necesario definir una variable o una
	  función como <code class="keyword">extern</code> en C, pero a veces es necesario
	  para <code class="keyword">const</code> en C++.
        </p><p>
	  Las variables automáticas (locales) existen sólo
	  temporalmente, en la pila, mientras se está ejecutando una
	  función. El enlazador no entiende de variables automáticas, de
	  modo que no tienen enlazado.
	</p></div></div><div class="sect2" title="3.6.5. Constantes"><div class="titlepage"><div><div><h3 class="title"><a id="idp4636912"></a>3.6.5. Constantes</h3></div></div></div><p>
	En el antiguo C (pre-Estándar), si se deseaba crear una
	constante, se debía utilizar el preprocesador:
      </p><pre class="programlisting">
<span class="hl ppc">#define PI 3.14159</span>
</pre><p>
	En cualquier sitio en el que utilizase PI, el preprocesador lo
	substituía por el valor 3.14159 (aún se puede utilizar este
	método en C y C++).
      </p><p>
	Cuando se utiliza el preprocesador para crear constantes, su
	control queda fuera del ámbito del compilador. No existe ninguna
	comprobación de tipo y no se puede obtener la dirección de PI
	(de modo que no se puede pasar un puntero o una referencia a
	PI). PI no puede ser una variable de un tipo definido por el
	usuario. El significado de PI dura desde el punto en que es
	definida, hasta el final del fichero; el preprocesador no
	entiende de ámbitos.
      </p><p>
	C++ introduce el concepto de constantes con nombre que es lo
	mismo que variable, excepto que su valor no puede cambiar. El
	modificador <code class="keyword">const</code> le indica al compilador que el nombre
	representa una constante. Cualquier tipo de datos predefinido o
	definido por el usuario, puede ser definido como
	<code class="keyword">const</code>. Si se define algo como <code class="keyword">const</code> y luego se
	intenta modificar, el compilador generará un error.
      </p><p>
	Se debe especificar el tipo de un <code class="keyword">const</code>, de este modo:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span> x <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
</pre><p>
	En C y C++ Estándar, se puede usar una constante en una lista de
	argumentos, incluso si el argumento que ocupa es un puntero o
	una referencia (p.e, se puede obtener la dirección de una
	constante). Las constantes tienen ámbito, al igual que una
	variable ordinaria, de modo que se puede «esconder»
	una constante dentro de una función y estar seguro de que ese
	nombre no afectará al resto del programa.
      </p><p>
	<code class="keyword">const</code> ha sido tomado de C++ e incorporado al C Estándar
	pero un modo un poco distinto. En C, el compilador trata a
	<code class="keyword">const</code> del mismo modo que a una variable que tuviera
	asociado una etiqueta que dice «No me
	cambies». Cuando se define un <code class="keyword">const</code> en C, el
	compilador pide espacio para él, de modo que si se define más de
	un <code class="keyword">const</code> con el mismo nombre en dos ficheros distintos
	(o se ubica la definición en un fichero de cabeceras), el
	enlazador generará mensajes de error sobre del conflicto. El
	concepto de <code class="keyword">const</code> en C es diferente de su utilización
	en C++ (en resumen, es más bonito en C++).
      </p><div class="sect3" title="Valores constantes"><div class="titlepage"><div><div><h4 class="title"><a id="idp4647312"></a>Valores constantes</h4></div></div></div><p>
	  En C++, una constante debe tener siempre un valor inicial (En
	  C, eso no es cierto). Los valores de las constantes para tipos
	  predefinidos se expresan en decimal, octal, hexadecimal, o
	  números con punto flotante (desgraciadamente, no se consideró
	  que los binarios fuesen importantes), o como caracteres.
	</p><p>
	  A falta de cualquier otra pista, el compilador assume que el
	  valor de una constante es un número decimal. Los números 47,
	  0 y 1101 se tratan como números decimales.
	</p><p>
	  Un valor constante con un cero al principio se trata como un
	  número octal (base 8). Los números con base 8 pueden contener
	  únicamente dígitos del 0 al 7; el compilador interpreta otros
	  dígitos como un error. Un número octal legítimo es 017 (15 en
	  base 10).
	</p><p>
	  Un valor constante con <code class="literal">0x</code> al principio se
	  trata como un número hexadecimal (base 16). Los números con
	  base 16 pueden contener dígitos del 0 al 9 y letras de la
	  <span class="token">a</span> a la <span class="token">f</span> o
	  <span class="token">A</span> a <span class="token">F</span>. Un número
	  hexadecimal legítimo es 0x1fe (510 en base 10).
	</p><p>
	  Los números en punto flotante pueden contener comas decimales
	  y potencias exponenciales (representadas mediante
	  <code class="literal">e</code>, lo que significa «10 elevado
	  a»). Tanto el punto decimal como la
	  <code class="literal">e</code> son opcionales. Si se asigna una
	  constante a una variable de punto flotante, el compilador
	  tomará el valor de la constante y la convertirá a un número en
	  punto flotante (este proceso es una forma de lo que se conoce
	  como conversión implícita de tipo). De todos modos, es una
	  buena idea el usar el punto decimal o una <code class="literal">e</code>
	  para recordar al lector que está utilizando un número en
	  punto flotante; algunos compiladores incluso necesitan esta
	  pista.
	</p><p>
	  Algunos valores válidos para una constante en punto flotante
	  son: 1e4, 1.0001, 47.0, 0.0 y 1.159e-77.  Se pueden añadir
	  sufijos para forzar el tipo de número de punto flotante:
	  <code class="literal">f</code> o <code class="literal">F</code> fuerza que sea
	  <code class="type">float</code>, <code class="literal">L</code> o
	  <code class="literal">l</code> fuerza que sea un <code class="type">long
	  double</code>; de lo contrario, el número será un
	  <code class="type">double</code>.
	</p><p>
	  Las constantes de tipo <code class="type">char</code> son caracteres entre
	  comillas simples, tales como: <code class="literal">'A'</code>,
	  <code class="literal">'o'</code>, <code class="literal">''</code>. Fíjese en que
	  hay una gran diferencia entre el carácter
	  <code class="literal">'o'</code> (ASCII 96) y el valor 0. Los caracteres
	  especiales se representan con la «barra
	  invertida»: <code class="literal">'\n'</code> (nueva línea),
	  <code class="literal">'\t'</code> (tabulación), <code class="literal">'\\'</code>
	  (barra invertida), <code class="literal">'\r'</code> (retorno de carro),
	  <code class="literal">'\"'</code> (comilla doble),
	  <code class="literal">'\''</code> (comilla simple), etc. Incluso se
	  puede expresar constantes de tipo <code class="type">char</code> en octal:
	  <code class="literal">'\17'</code> o hexadecimal:
	  <code class="literal">'\xff'</code>.
	</p></div></div><div class="sect2" title="3.6.6. Volatile"><div class="titlepage"><div><div><h3 class="title"><a id="idp4661720"></a>3.6.6. Volatile</h3></div></div></div><p>
	Mientras que el calificador <code class="keyword">const</code> indica al compilador
	«Esto nunca cambia» (lo que permite al compilador
	realizar optimizaciones extra), el calificador <code class="keyword">volatile</code>
	dice al compilador «Nunca se sabe cuando cambiará
	esto», y evita que el compilador realice optimizaciones
	basadas en la estabilidad de esa variable.  Se utiliza esta
	palabra reservada cuando se lee algún valor fuera del control
	del código, algo así como un registro en un hardware de
	comunicación. Una variable <code class="keyword">volatile</code> se lee siempre que
	su valor es requerido, incluso si se ha leído en la línea
	anterior.
      </p><p>
	Un caso especial de espacio que está «fuera del control
	del código» es en un programa multi-hilo. Si está
	comprobando una bandera particular que puede ser modificada por
	otro hilo o proceso, esta bandera debería ser <code class="keyword">volatile</code>
	de modo que el compilador no asuma que puede optimizar múltiples
	lecturas de la bandera.
      </p><p>
	Fíjese en que <code class="keyword">volatile</code> puede no tener efecto cuando el
	compilador no está optimizando, pero puede prevenir errores
	críticos cuando se comienza a optimizar el código (que es cuando
	el compilador empezará a buscar lecturas redundantes).
      </p><p>
	Las palabras reservadas <code class="keyword">const</code> y <code class="keyword">volatile</code> se
	verán con más detalle en un capítulo posterior.
      </p></div></div><div class="sect1" title="3.7. Los operadores y su uso"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4668808"></a>3.7. Los operadores y su uso</h2></div></div></div><p>
      Esta sección cubre todos los operadores de C y C++.
    </p><p>
      Todos los operadores producen un valor a partir de sus
      operandos. Esta operación se efectúa sin modificar los operandos,
      excepto con los operadores de asignación, incremento y
      decremento. El hecho de modificar un operando se denomina
      <span class="emphasis"><em>efecto colateral</em></span>. El uso más común de los
      operadores que modifican sus operandos es producir el efecto
      colateral, pero se debería tener en cuenta que el valor producido
      está disponible para su uso al igual que el de los operadores sin
      efectos colaterales.
    </p><div class="sect2" title="3.7.1. Asignación"><div class="titlepage"><div><div><h3 class="title"><a id="idp4670936"></a>3.7.1. Asignación</h3></div></div></div><p>
	La asignación se realiza mediante el operador
	<code class="literal">=</code>. Eso significa «Toma el valor de la derecha
	(a menudo llamado <span class="emphasis"><em>rvalue</em></span>) y cópialo en la
	variable de la izquierda (a menudo llamado
	<span class="emphasis"><em>lvalue</em></span>).» Un
	<span class="emphasis"><em>rvalue</em></span> es cualquier constante, variable o
	expresión que pueda producir un valor, pero un
	<span class="emphasis"><em>lvalue</em></span> debe ser una variable con un nombre
	distintivo y único (esto quiere decir que debe haber un espacio
	físico dónde guardar la información). De hecho, se puede asignar
	el valor de una constante a una variable (<code class="code">A = 4;</code>),
	pero no se puede asignar nada a una constante - es decir, una
	constante no puede ser un <span class="emphasis"><em>lvalue</em></span> (no se
	puede escribir <code class="code">4 = A;</code>).
      </p></div><div class="sect2" title="3.7.2. Operadores matemáticos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4674512"></a>3.7.2. Operadores matemáticos</h3></div></div></div><p>
	Los operadores matemáticos básicos son los mismos que están
	disponibles en la mayoría de los lenguajes de programación:
	adición (<code class="literal">+</code>), substracción (<code class="literal">-</code>),
	división (<code class="literal">/</code>), multiplicación (<code class="literal">*</code>), y
	módulo (<code class="literal">%</code>; que produce el resto de una división
	entera). La división entera trunca el resultado (no lo
	redondea). El operador módulo no se puede utilizar con
	números con punto flotante.
      </p><p>
	C y C++ también utilizan notaciones abreviadas para efectuar una
	operación y una asignación al mismo tiempo. Esto se denota por
	un operador seguido de un signo igual, y se puede aplicar a
	todos los operadores del lenguaje (siempre que tenga
	sentido). Por ejemplo, para añadir <code class="constant">4</code> a la
	variable <code class="varname">x</code> y asignar <code class="varname">x</code> al
	resultado, se escribe: <code class="code">x += 4;</code>.
      </p><p>
	Este ejemplo muestra el uso de los operadores matemáticos:
      </p><div class="example"><a id="idp4680016"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Mathops.cpp</span>
<span class="hl slc">// Mathematical operators</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A macro to display a string and a value.</span>
<span class="hl ppc">#define PRINT(STR, VAR) \</span>
<span class="hl ppc">  cout &lt;&lt; STR</span> <span class="hl pps">&quot; = &quot;</span><span class="hl ppc"> &lt;&lt; VAR &lt;&lt; endl</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
  <span class="hl kwb">float</span> u<span class="hl opt">,</span> v<span class="hl opt">,</span> w<span class="hl opt">;</span>  <span class="hl slc">// Applies to doubles, too</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;enter an integer: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> j<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;enter another integer: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> k<span class="hl opt">;</span>
  <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;j&quot;</span><span class="hl opt">,</span>j<span class="hl opt">);</span>  <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;k&quot;</span><span class="hl opt">,</span>k<span class="hl opt">);</span>
  i <span class="hl opt">=</span> j <span class="hl opt">+</span> k<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;j + k&quot;</span><span class="hl opt">,</span>i<span class="hl opt">);</span>
  i <span class="hl opt">=</span> j <span class="hl opt">-</span> k<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;j - k&quot;</span><span class="hl opt">,</span>i<span class="hl opt">);</span>
  i <span class="hl opt">=</span> k <span class="hl opt">/</span> j<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;k / j&quot;</span><span class="hl opt">,</span>i<span class="hl opt">);</span>
  i <span class="hl opt">=</span> k <span class="hl opt">*</span> j<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;k * j&quot;</span><span class="hl opt">,</span>i<span class="hl opt">);</span>
  i <span class="hl opt">=</span> k <span class="hl opt">%</span> j<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;k % j&quot;</span><span class="hl opt">,</span>i<span class="hl opt">);</span>
  <span class="hl slc">// The following only works with integers:</span>
  j <span class="hl opt">%=</span> k<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;j %= k&quot;</span><span class="hl opt">,</span> j<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter a floating-point number: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> v<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter another floating-point number:&quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> w<span class="hl opt">;</span>
  <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;v&quot;</span><span class="hl opt">,</span>v<span class="hl opt">);</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;w&quot;</span><span class="hl opt">,</span>w<span class="hl opt">);</span>
  u <span class="hl opt">=</span> v <span class="hl opt">+</span> w<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;v + w&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  u <span class="hl opt">=</span> v <span class="hl opt">-</span> w<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;v - w&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  u <span class="hl opt">=</span> v <span class="hl opt">*</span> w<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;v * w&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  u <span class="hl opt">=</span> v <span class="hl opt">/</span> w<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;v / w&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  <span class="hl slc">// The following works for ints, chars, </span>
  <span class="hl slc">// and doubles too:</span>
  <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;u&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;v&quot;</span><span class="hl opt">,</span> v<span class="hl opt">);</span>
  u <span class="hl opt">+=</span> v<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;u += v&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  u <span class="hl opt">-=</span> v<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;u -= v&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  u <span class="hl opt">*=</span> v<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;u *= v&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
  u <span class="hl opt">/=</span> v<span class="hl opt">;</span> <span class="hl kwd">PRINT</span><span class="hl opt">(</span><span class="hl str">&quot;u /= v&quot;</span><span class="hl opt">,</span> u<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.29. C03/Mathops.cpp</strong></p></div><br class="example-break" /><p>
	Los <span class="emphasis"><em>rvalues</em></span> de todas las asignaciones
	pueden ser, por supuesto, mucho mas complejos.
      </p><div class="sect3" title="Introducción a las macros del preprocesador"><div class="titlepage"><div><div><h4 class="title"><a id="idp4682816"></a>Introducción a las macros del preprocesador</h4></div></div></div><p>
	  Observe el uso de la macro <code class="function">PRINT()</code> para
	  ahorrar líneas (y errores de sintaxis!). Las macros de
	  preprocesador se nombran tradicionalmente con todas sus letras
	  en mayúsculas para que sea fácil distinguirlas - aprenderá más
	  adelante que las macros pueden ser peligrosas (y también
	  pueden ser muy útiles).
	</p><p>
	  Los argumentos de de la lista entre paréntesis que sigue al
	  nombre de la macro son sustituidos en todo el código que sigue
	  al paréntesis de cierre. El preprocesador elimina el nombre
	  <code class="function">PRINT</code> y sustituye el código donde se
	  invoca la macro, de modo que el compilador no puede generar
	  ningún mensaje de error al utilizar el nombre de la macro, y
	  no realiza ninguna comprobación de sintaxis sobre los
	  argumentos (esto lo último puede ser beneficioso, como se
	  muestra en las macros de depuración al final del capítulo).
	</p></div></div><div class="sect2" title="3.7.3. Operadores relacionales"><div class="titlepage"><div><div><h3 class="title"><a id="idp4686048"></a>3.7.3. Operadores relacionales</h3></div></div></div><p>
	Los operadores relacionales establecen una relación entre el
	valor de los operandos. Producen un valor booleano (especificado
	con la palabra reservada <code class="type">bool</code> en C++)
	<code class="constant">true</code> si la relación es verdadera, y
	<code class="constant">false</code> si la relación es falsa. Los
	operadores relacionales son: menor que (<code class="literal">&lt;</code>),
	mayor que (<code class="literal">&gt;</code>), menor o igual a
	(<code class="literal">&lt;=</code>), mayor o igual a (<code class="literal">&gt;=</code>),
	equivalente (<code class="literal">==</code>), y distinto (<code class="literal">!=</code>). Se
	pueden utilizar con todos los tipos de datos predefinidos en C y
	C++. Se pueden dar definiciones especiales para tipos definidos
	por el usuario en C++ (aprenderá más sobre el tema en el
	Capítulo 12, que cubre la sobrecarga de operadores).
      </p></div><div class="sect2" title="3.7.4. Operadores lógicos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4690872"></a>3.7.4. Operadores lógicos</h3></div></div></div><p>
	Los operadores lógicos <span class="emphasis"><em>and</em></span>
	(<code class="literal">&amp;&amp;</code>) y <span class="emphasis"><em>or</em></span>
	(<code class="literal">||</code>) producen <code class="constant">true</code> o
	<code class="constant">false</code> basándose en la relación lógica de
	sus argumentos. Recuerde que en C y C++, una condición es cierta
	si tiene un valor diferente de cero, y falsa si vale cero. Si se
	imprime un <code class="type">bool</code>, por lo general verá un
	<code class="constant">1</code>' para <code class="constant">true</code> y
	<code class="constant">0</code> para <code class="constant">false</code>.
      </p><p>
	Este ejemplo utiliza los operadores relacionales y lógicos:
      </p><div class="example"><a id="idp4694864"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Boolean.cpp</span>
<span class="hl slc">// Relational and logical operators.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span>j<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter an integer: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> i<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter another integer: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> j<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &gt; j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">&gt;</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &lt; j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">&lt;</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &gt;= j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">&gt;=</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &lt;= j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">&lt;=</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i == j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">==</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i != j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">!=</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i &amp;&amp; j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">&amp;&amp;</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i || j is &quot;</span> <span class="hl opt">&lt;&lt; (</span>i <span class="hl opt">||</span> j<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; (i &lt; 10) &amp;&amp; (j &lt; 10) is &quot;</span>
       <span class="hl opt">&lt;&lt; ((</span>i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">) &amp;&amp; (</span>j <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">))  &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.30. C03/Boolean.cpp</strong></p></div><br class="example-break" /><p>
	Se puede reemplazar la definición de <code class="type">int</code> con
	<code class="type">float</code> o <code class="type">double</code> en el programa
	anterior. De todos modos, dese cuenta de que la comparación de
	un número en punto flotante con el valor cero es estricta; un
	número que es la fracción más pequeña diferente de otro número
	aún se considera «distinto de». Un número en punto
	flotante que es poca mayor que cero se considera verdadero.
      </p></div><div class="sect2" title="3.7.5. Operadores para bits"><div class="titlepage"><div><div><h3 class="title"><a id="idp4698224"></a>3.7.5. Operadores para bits</h3></div></div></div><p>
	Los operadores de bits permiten manipular bits individuales y
	dar como salida un número (ya que los valores con punto flotante
	utilizan un formato interno especial, los operadores de bitS
	sólo funcionan con tipos enteros: <code class="type">char</code>,
	<code class="type">int</code> y <code class="type">long</code>). Los operadores de bitS
	efectúan álgebra booleana en los bits correspondientes de los
	argumentos para producir el resultado.
      </p><p>
	El operador <span class="emphasis"><em>and</em></span> (<code class="literal">&amp;</code>) para
	bits produce uno en la salida si ambos bits de entrada valen
	uno; de otro modo produce un cero. El operador
	<span class="emphasis"><em>or</em></span> (<code class="literal">|</code>) para bits produce un
	uno en la salida si cualquiera de los dos valores de entrada
	vale uno, y produce un cero sólo si ambos valores de entrada son
	cero. El operador <span class="emphasis"><em>or exclusivo</em></span> o
	<span class="emphasis"><em>xor</em></span> (<code class="literal">^</code>) para bits produce uno
	en la salida si uno de los valores de entrada es uno, pero no
	ambos. El operador <span class="emphasis"><em>not</em></span> (<code class="literal">~</code>)
	para bits (también llamado operador de <span class="emphasis"><em>complemento a
	uno</em></span>) es un operador unario - toma un único argumento
	(todos los demás operadores son binarios). El operador
	<span class="emphasis"><em>not</em></span> para bits produce el valor contrario a
	la entrada - uno si el bit de entrada es cero, y cero si el bit
	de entrada es uno.
      </p><p>
	Los operadores de bits pueden combinarse con el signo
	<code class="literal">=</code> para unir la operación y la asignación:
	<code class="literal">&amp;=</code>, <code class="literal">|=</code>, y <code class="literal">^=</code> son
	todas operaciones legales (dado que <code class="literal">~</code> es un
	operador unario no puede combinarse con el signo
	<code class="literal">=</code>).
      </p></div><div class="sect2" title="3.7.6. Operadores de desplazamiento"><div class="titlepage"><div><div><h3 class="title"><a id="idp4707488"></a>3.7.6. Operadores de desplazamiento</h3></div></div></div><p>
	Los operadores de desplazamiento también manipulan bits. El
	operador de desplazamiento a izquierda (<code class="literal">&lt;&lt;</code>)
	produce el desplazamiento del operando que aparece a la
	izquierda del operador tantos bits a la izquierda como indique
	el número a la derecha del operador. El operador de
	desplazamiento a derecha (<code class="literal">&gt;&gt;</code>) produce el
	desplazamiento del operando de la izquierda hacia la derecha
	tantos bits como indique el número a la derecha del operador. Si
	el valor que sigue al operador de desplazamiento es mayor que el
	número de bits del lado izquierdo, el resultado es
	indefinido. Si el operando de la izquierda no tiene signo, el
	desplazamiento a derecha es un desplazamiento lógico de modo que
	los bits del principio se rellenan con ceros. Si el operando de
	la izquierda tiene signo, el desplazamiento derecho puede ser un
	desplazamiento lógico (es decir, significa que el comportamiento
	es indeterminado).
      </p><p>
	Los desplazamientos pueden combinarse con el signo igual
	(<code class="literal">&lt;&lt;=</code> y <code class="literal">&gt;&gt;=</code>). El
	<span class="emphasis"><em>lvalue</em></span> se reemplaza por
	<span class="emphasis"><em>lvalue</em></span> desplazado por el
	<span class="emphasis"><em>rvalue</em></span>.
      </p><p>
	Lo que sigue a continuación es un ejemplo que demuestra el uso
	de todos los operadores que involucran bits. Primero, una
	función de propósito general que imprime un byte en formato
	binario, creada para que se pueda reutilizar fácilmente. El
	fichero de cabecera declara la función:
      </p><div class="example"><a id="idp4712856"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:printBinary.h</span>
<span class="hl slc">// Display a byte in binary</span>
<span class="hl kwb">void</span> <span class="hl kwd">printBinary</span><span class="hl opt">(</span><span class="hl kwb">const unsigned char</span> val<span class="hl opt">);</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.31. C03/printBinary.h</strong></p></div><br class="example-break" /><p>
	A continuación la implementación de la función:
      </p><div class="example"><a id="idp4714120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:printBinary.cpp {O}</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">printBinary</span><span class="hl opt">(</span><span class="hl kwb">const unsigned char</span> val<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">7</span><span class="hl opt">;</span> i <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">;</span> i<span class="hl opt">--)</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>val <span class="hl opt">&amp; (</span><span class="hl num">1</span> <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">))</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;1&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">else</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;0&quot;</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.32. C03/printBinary.cpp</strong></p></div><br class="example-break" /><p>
	La función <code class="function">printBinary()</code> toma un único
	byte y lo muestra bit a bit. La expresión:
      </p><pre class="programlisting">
<span class="hl opt">(</span><span class="hl num">1</span> <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">)</span>
</pre><p>
	produce un uno en cada posición sucesiva de bit; en binario:
	<code class="constant">00000001</code>, <code class="constant">00000010</code>,
	etc. Si se hace <span class="emphasis"><em>and</em></span> a este bit con
	<code class="varname">val</code> y el resultado es diferente de cero,
	significa que había un uno en esa posición de
	<code class="varname">val</code>.
      </p><p>
	Finalmente, se utiliza la función en el ejemplo que muestra los
	operadores de manipulación de bits:
      </p><div class="example"><a id="idp4718216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Bitwise.cpp</span>
<span class="hl slc">//{L} printBinary</span>
<span class="hl slc">// Demonstration of bit manipulation</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;printBinary.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A macro to save typing:</span>
<span class="hl ppc">#define PR(STR, EXPR) \</span>
<span class="hl ppc">  cout &lt;&lt; STR; printBinary(EXPR); cout &lt;&lt; endl;  </span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">unsigned int</span> getval<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span> a<span class="hl opt">,</span> b<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter a number between 0 and 255: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> getval<span class="hl opt">;</span> a <span class="hl opt">=</span> getval<span class="hl opt">;</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;a in binary: &quot;</span><span class="hl opt">,</span> a<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter a number between 0 and 255: &quot;</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> getval<span class="hl opt">;</span> b <span class="hl opt">=</span> getval<span class="hl opt">;</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;b in binary: &quot;</span><span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;a | b = &quot;</span><span class="hl opt">,</span> a <span class="hl opt">|</span> b<span class="hl opt">);</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;a &amp; b = &quot;</span><span class="hl opt">,</span> a <span class="hl opt">&amp;</span> b<span class="hl opt">);</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;a ^ b = &quot;</span><span class="hl opt">,</span> a ^ b<span class="hl opt">);</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;~a = &quot;</span><span class="hl opt">, ~</span>a<span class="hl opt">);</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;~b = &quot;</span><span class="hl opt">, ~</span>b<span class="hl opt">);</span>
  <span class="hl slc">// An interesting bit pattern:</span>
  <span class="hl kwb">unsigned char</span> c <span class="hl opt">=</span> <span class="hl num">0x5A</span><span class="hl opt">;</span> 
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;c in binary: &quot;</span><span class="hl opt">,</span> c<span class="hl opt">);</span>
  a <span class="hl opt">|=</span> c<span class="hl opt">;</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;a |= c; a = &quot;</span><span class="hl opt">,</span> a<span class="hl opt">);</span>
  b <span class="hl opt">&amp;=</span> c<span class="hl opt">;</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;b &amp;= c; b = &quot;</span><span class="hl opt">,</span> b<span class="hl opt">);</span>
  b ^<span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwd">PR</span><span class="hl opt">(</span><span class="hl str">&quot;b ^= a; b = &quot;</span><span class="hl opt">,</span> b<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.33. C03/Bitwise.cpp</strong></p></div><br class="example-break" /><p>
	Una vez más, se usa una macro de preprocesador para ahorrar
	líneas. Imprime la cadena elegida, luego la representación
	binaria de una expresión, y luego un salto de línea.
      </p><p>
	En <code class="function">main()</code>, las variables son
	<code class="type">unsigned</code>. Esto es porque, en general, no se desean
	signos cuando se trabaja con bytes. Se debe utilizar un
	<code class="type">int</code> en lugar de un <code class="type">char</code> para
	<code class="varname">getval</code> porque de otro modo la sentencia
	<code class="code">cin &gt;&gt;</code> trataría el primer dígito como un
	carácter. Asignando <code class="varname">getval</code> a
	<code class="varname">a</code> y <code class="varname">b</code>, se convierte el
	valor a un solo byte (truncándolo).
      </p><p>
	Los operadores <code class="literal">&lt;&lt;</code> y <code class="literal">&gt;&gt;</code>
	proporcionan un comportamiento de desplazamiento de bits, pero
	cuando desplazan bits que están al final del número, estos bits
	se pierden (comúnmente se dice que se caen en el mítico
	<span class="emphasis"><em>cubo de bits</em></span>, el lugar donde acaban los
	bits descartados, presumiblemente para que puedan ser
	utilizados...). Cuando se manipulan bits también se pueden
	realizar <span class="emphasis"><em>rotaciones</em></span>; es decir, que los bits
	que salen de uno de los extremos se pueden insertar por el otro
	extremo, como si estuviesen rotando en un bucle. Aunque la
	mayoría de los procesadores de ordenadores ofrecen un comando de
	rotación a nivel máquina (se puede ver en el lenguaje
	ensamblador de ese procesador), no hay un soporte directo para
	<span class="emphasis"><em>rotate</em></span> en C o C++. Se supone que a los
	diseñadores de C les pareció justificado el hecho de prescindir
	de <span class="emphasis"><em>rotate</em></span> (en pro, como dijeron, de un
	lenguaje minimalista) ya que el programador se puede construir
	su propio comando <span class="emphasis"><em>rotate</em></span>. Por ejemplo, a
	continuación hay funciones para realizar rotaciones a izquierda
	y derecha:
      </p><div class="example"><a id="idp4727712"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Rotation.cpp {O}</span>
<span class="hl slc">// Perform left and right rotations</span>

<span class="hl kwb">unsigned char</span> <span class="hl kwd">rol</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span> val<span class="hl opt">) {</span>
  <span class="hl kwb">int</span> highbit<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>val <span class="hl opt">&amp;</span> <span class="hl num">0x80</span><span class="hl opt">)</span> <span class="hl slc">// 0x80 is the high bit only</span>
    highbit <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwa">else</span>
    highbit <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Left shift (bottom bit becomes 0):</span>
  val <span class="hl opt">&lt;&lt;=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl slc">// Rotate the high bit onto the bottom:</span>
  val <span class="hl opt">|=</span> highbit<span class="hl opt">;</span>
  <span class="hl kwa">return</span> val<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">unsigned char</span> <span class="hl kwd">ror</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span> val<span class="hl opt">) {</span>
  <span class="hl kwb">int</span> lowbit<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>val <span class="hl opt">&amp;</span> <span class="hl num">1</span><span class="hl opt">)</span> <span class="hl slc">// Check the low bit</span>
    lowbit <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwa">else</span>
    lowbit <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  val <span class="hl opt">&gt;&gt;=</span> <span class="hl num">1</span><span class="hl opt">;</span> <span class="hl slc">// Right shift by one position</span>
  <span class="hl slc">// Rotate the low bit onto the top:</span>
  val <span class="hl opt">|= (</span>lowbit <span class="hl opt">&lt;&lt;</span> <span class="hl num">7</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> val<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.34. C03/Rotation.cpp</strong></p></div><br class="example-break" /><p>
	Al intentar utilizar estas funciones en
	<code class="filename">Bitwise.cpp</code>, advierta que las definiciones
	(o cuando menos las declaraciones) de <code class="function">rol()</code>
	y <code class="function">ror()</code> deben ser vistas por el compilador
	en <code class="filename">Bitwise.cpp</code> antes de que se puedan
	utilizar.
      </p><p>
	Las funciones de tratamiento de bits son por lo general
	extremadamente eficientes ya que traducen directamente las
	sentencias a lenguaje ensamblador. A veces una sentencia de C o
	C++ generará una única línea de código ensamblador.
      </p></div><div class="sect2" title="3.7.7. Operadores unarios"><div class="titlepage"><div><div><h3 class="title"><a id="idp4731808"></a>3.7.7. Operadores unarios</h3></div></div></div><p>
	El <span class="emphasis"><em>not</em></span> no es el único operador de bits que
	toma sólo un argumento. Su compañero, el
	<span class="emphasis"><em>not</em></span> lógico (<code class="literal">!</code>), toma un valor
	<code class="constant">true</code> y produce un valor
	<code class="constant">false</code>. El menos unario (<code class="literal">-</code>) y
	el más unario (<code class="literal">+</code>) son los mismos operadores que los
	binarios menos y más; el compilador deduce que uso se le
	pretende dar por el modo en el que se escribe la expresión. De
	hecho, la sentencia:
      </p><pre class="programlisting">
x <span class="hl opt">= -</span>a<span class="hl opt">;</span>
</pre><p>
	tiene un significado obvio. El compilador puede deducir:
      </p><pre class="programlisting">
x <span class="hl opt">=</span> a <span class="hl opt">* -</span>b<span class="hl opt">;</span>
</pre><p>
	pero el lector se puede confundir, de modo que es más seguro
	escribir:
      </p><pre class="programlisting">
x <span class="hl opt">=</span> a <span class="hl opt">* (-</span>b<span class="hl opt">);</span>
</pre><p>
	El menos unario produce el valor negativo. El más unario ofrece
	simetría con el menos unario, aunque en realidad no hace nada.
      </p><p>
	Los operadores de incremento y decremento (<code class="literal">++</code> y
	<code class="literal">--</code>) se comentaron ya en este capítulo. Son los
	únicos operadores, además de los que involucran asignación, que
	tienen efectos colaterales. Estos operadores incrementan o
	decrementan la variable en una unidad, aunque
	«unidad» puede tener diferentes significados
	dependiendo del tipo de dato - esto es especialmente importante en
	el caso de los punteros.
      </p><p>
	Los últimos operadores unarios son dirección-de
	(<code class="literal">&amp;</code>), indirección (<code class="literal">*</code> y
	<code class="literal">-&gt;</code>), los operadores de moldeado en C y C++, y
	<code class="literal">new</code> y <code class="literal">delete</code> en C++. La dirección-de y
	la indirección se utilizan con los punteros, descriptos en este
	capítulo. El moldeado se describe mas adelante en este capítulo,
	y <code class="literal">new</code> y <code class="literal">delete</code> se introducen en el
	Capítulo 4.
      </p></div><div class="sect2" title="3.7.8. El operador ternario"><div class="titlepage"><div><div><h3 class="title"><a id="idp4742984"></a>3.7.8. El operador ternario</h3></div></div></div><p>
	El <code class="keyword">if-else</code> ternario es inusual porque tiene tres
	operandos. Realmente es un operador porque produce un valor, al
	contrario de la sentencia ordinaria <code class="keyword">if-else</code>. Consta de
	tres expresiones: si la primera expresión (seguida de un
	<code class="literal">?</code>) se evalúa como cierto, se devuelve el
	resultado de evaluar la expresión que sigue al
	<code class="literal">?</code>. Si la primera expresión es falsa, se
	ejecuta la tercera expresión (que sigue a <code class="literal">:</code>)
	y su resultado se convierte en el valor producido por
	el operador.
      </p><p>
	El operador condicional se puede usar por sus efectos colaterales
	o por el valor que produce. A continuación, un fragmento de
	código que demuestra ambas cosas:
      </p><pre class="programlisting">
a <span class="hl opt">= --</span>b ? b <span class="hl opt">: (</span>b <span class="hl opt">= -</span><span class="hl num">99</span><span class="hl opt">);</span>
</pre><p>
	Aquí, el condicional produce el <span class="emphasis"><em>rvalue</em></span>. A
	<code class="varname">a</code> se le asigna el valor de
	<code class="varname">b</code> si el resultado de decrementar
	<code class="varname">b</code> es diferente de cero. Si
	<code class="varname">b</code> se queda a cero, <code class="varname">a</code> y
	<code class="varname">b</code> son ambas asignadas a
	-99. <code class="varname">b</code> siempre se decrementa, pero se asigna
	a -99 sólo si el decremento provoca que <code class="varname">b</code>
	valga 0. Se puede utilizar un sentencia similar sin el <code class="code">a
	=</code> sólo por sus efectos colaterales:
      </p><pre class="programlisting">
<span class="hl opt">--</span>b ? b <span class="hl opt">: (</span>b <span class="hl opt">= -</span><span class="hl num">99</span><span class="hl opt">);</span>
</pre><p>
	Aquí la segunda <code class="varname">b</code> es superflua, ya que no se
	utiliza el valor producido por el operador. Se requiere una
	expresión entre el <code class="literal">?</code> y
	<code class="literal">:</code>. En este caso, la expresión puede ser
	simplemente una constante, lo que haría que el código se ejecute
	un poco más rápido.
      </p></div><div class="sect2" title="3.7.9. El operador coma"><div class="titlepage"><div><div><h3 class="title"><a id="idp4751568"></a>3.7.9. El operador coma</h3></div></div></div><p>
	La coma no se limita a separar nombres de variables en
	definiciones múltiples, tales como
      </p><pre class="programlisting">
<span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
</pre><p>
	Por supuesto, también se usa en listas de argumentos de
	funciones. De todos modos, también se puede utilizar como un
	operador para separar expresiones - en este caso produce el
	valor de la última expresión. El resto de expresiones en la
	lista separada por comas se evalúa sólo por sus efectos
	colaterales. Este ejemplo incrementa una lista de variables y
	usa la última como el <span class="emphasis"><em>rvalue</em></span>:
      </p><div class="example"><a id="idp4753680"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:CommaOperator.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> b <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">,</span> c <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">,</span> d <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">,</span> e <span class="hl opt">=</span> <span class="hl num">4</span><span class="hl opt">;</span>
  a <span class="hl opt">= (</span>b<span class="hl opt">++,</span> c<span class="hl opt">++,</span> d<span class="hl opt">++,</span> e<span class="hl opt">++);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// The parentheses are critical here. Without</span>
  <span class="hl slc">// them, the statement will evaluate to:</span>
  <span class="hl opt">(</span>a <span class="hl opt">=</span> b<span class="hl opt">++),</span> c<span class="hl opt">++,</span> d<span class="hl opt">++,</span> e<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.35. C03/CommaOperator.cpp</strong></p></div><br class="example-break" /><p>
	En general, es mejor evitar el uso de la coma para cualquier
	otra cosa que no sea separar, ya que la gente no está acostumbrada
	a verla como un operador.
      </p></div><div class="sect2" title="3.7.10. Trampas habituales cuando se usan operadores"><div class="titlepage"><div><div><h3 class="title"><a id="idp4755520"></a>3.7.10. Trampas habituales cuando se usan operadores</h3></div></div></div><p>
	Como se ha ilustrado anteriormente, una de las trampas al usar
	operadores es tratar de trabajar sin paréntesis incluso cuando
	no se está seguro de la forma en la que se va a evaluar la
	expresión (consulte su propio manual de C para comprobar el
	orden de la evaluación de las expresiones).
      </p><p>
	Otro error extremadamente común se ve a continuación:
      </p><div class="example"><a id="idp4757032"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Pitfall.cpp</span>
<span class="hl slc">// Operator mistakes</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">,</span> b <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>a <span class="hl opt">=</span> b<span class="hl opt">) {</span>
    <span class="hl slc">// ....</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.36. C03/Pitfall.cpp</strong></p></div><br class="example-break" /><p>
	La sentencia <code class="code">a = b</code> siempre se va a evaluar como
	cierta cuando <code class="varname">b</code> es distinta de cero. La
	variable <code class="varname">a</code> obtiene el valor de
	<code class="varname">b</code>, y el valor de <code class="varname">b</code> también
	es producido por el operador <code class="literal">=</code>. En general, lo que
	se pretende es utilizar el operador de equivalencia
	(<code class="literal">==</code> dentro de una sentencia condicional, no la
	asignación. Esto le ocurre a muchos programadores (de todos
	modos, algunos compiladores advierten del problema, lo cual es
	una ayuda).
      </p><p>
	Un problema similar es usar los operadores
	<span class="emphasis"><em>and</em></span> y <span class="emphasis"><em>or</em></span> de bits en
	lugar de sus equivalentes lógicos. Los operadores
	<span class="emphasis"><em>and</em></span> y <span class="emphasis"><em>or</em></span> de bits usan
	uno de los caracteres (<code class="literal">&amp;</code> o <code class="literal">|</code>),
	mientras que los operadores lógicos utilizan dos
	(<code class="literal">&amp;&amp;</code> y <code class="literal">||</code>). Al igual que con
	<code class="literal">=</code> y <code class="literal">==</code>, es fácil escribir simplemente
	un carácter en vez de dos. Una forma muy fácil de recordarlo es
	que «los bits son mas pequeños, de modo que no necesitan
	tantos caracteres en sus operadores».
      </p></div><div class="sect2" title="3.7.11. Operadores de moldeado"><div class="titlepage"><div><div><h3 class="title"><a id="idp4765232"></a>3.7.11. Operadores de moldeado</h3></div></div></div><p>
	La palabra molde(<span class="emphasis"><em>cast</em></span>) se usa en el sentido
	de "colocar dentro de un molde". El compilador cambiará
	automáticamente un tipo de dato a otro si tiene sentido. De
	hecho, si se asigna un valor entero a una variable de punto
	flotante, el compilador llamará secretamente a una función (o
	más probablemente, insertará código) para convertir el
	<code class="type">int</code> a un <code class="type">float</code>. El molde permite
	hacer este tipo de conversión explicita, o forzarla cuando
	normalmente no pasaría.
      </p><p>
	Para realizar un molde, se debe situar el tipo deseado
	(incluyendo todos los modificadores) dentro de paréntesis a la
	izquierda del valor. Este valor puede ser una variable, una
	constante, el valor producido por una expresión, o el valor
	devulto por una función. A continuación, un ejemplo:
      </p><div class="example"><a id="idp4768032"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:SimpleCast.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> b <span class="hl opt">=</span> <span class="hl num">200</span><span class="hl opt">;</span>
  <span class="hl kwb">unsigned long</span> a <span class="hl opt">= (</span><span class="hl kwb">unsigned long int</span><span class="hl opt">)</span>b<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.37. C03/SimpleCast.cpp</strong></p></div><br class="example-break" /><p>
	El moldeado es poderoso, pero puede causar dolores de cabeza
	porque en algunas situaciones fuerza al compilador a tratar
	datos como si fuesen (por ejemplo) más largos de lo que
	realmente son, de modo que ocupará más espacio en memoria; lo
	que puede afectar a otros datos. Esto ocurre a menudo cuando se
	moldean punteros, no cuando se hacen moldes simples como los
	que ha visto anteriormente.
      </p><p>
	C++ tiene una sintaxis adicional para moldes, que sigue a la
	sintaxis de llamada a funciones. Esta sintaxis pone los
	paréntesis alrededor del argumento, como en una llamada a
	función, en lugar de a los lados del tipo:
      </p><div class="example"><a id="idp4770664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:FunctionCallCast.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">float</span> a <span class="hl opt">=</span> <span class="hl kwb">float</span><span class="hl opt">(</span><span class="hl num">200</span><span class="hl opt">);</span>
  <span class="hl slc">// This is equivalent to:</span>
  <span class="hl kwb">float</span> b <span class="hl opt">= (</span><span class="hl kwb">float</span><span class="hl opt">)</span><span class="hl num">200</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.38. C03/FunctionCallCast.cpp</strong></p></div><br class="example-break" /><p>
	Por supuesto, en el caso anterior, en realidad no se necesitaría
	un molde; simplemente se puede decir <code class="constant">200.f</code>
	o <code class="constant">200.0f</code> (en efecto, eso es típicamente lo
	que el compilador hará para la expresión anterior). Los moldes
	normalmente se utilizan con variables, en lugar de con constantes.
      </p></div><div class="sect2" title="3.7.12. Los moldes explícitos de C++"><div class="titlepage"><div><div><h3 class="title"><a id="idp4772864"></a>3.7.12. Los moldes explícitos de C++</h3></div></div></div><p>
        Los moldes se deben utilizar con cuidado, porque lo que está
        haciendo en realidad es decir al compilador «Olvida la
        comprobación de tipo - trátalo como si fuese de este otro
        tipo.» Esto significa, que está introduciendo un agujero
        en el sistema de tipos de C++ y evitando que el compilador
        informe de que está haciendo algo erróneo con un tipo. Lo que es
        peor, el compilador lo cree implícitamente y no realiza ninguna
        otra comprobación para buscar errores. Una vez ha comenzado a
        moldear, está expuesto a todo tipo de problemas. De hecho,
        cualquier programa que utilice muchos moldes se debe revisar con
        detenimiento, no importa cuanto haya dado por sentado que
        simplemente «debe» hacerse de esta manera. En
        general, los moldes deben ser pocos y aislados para solucionar
        problemas específicos.
      </p><p>
	Una vez se ha entendido esto y se presente un programa con
	errores, la primera impresión puede que sea mirar los moldes
	como si fuesen los culpables. Pero, ¿cómo encontrar los moldes
	estilo C? Son simplemente nombres de tipos entre paréntesis, y
	si se empieza a buscar estas cosas descubrirá que a menudo es
	difícil distinguirlos del resto del código.
      </p><p>
	El C++ Estándar incluye una sintaxis explícita de molde que se
	puede utilizar para reemplazar completamente los moldes del
	estilo antiguo de C (por supuesto, los moldes de estilo C no se
	pueden prohibir sin romper el código, pero los escritores de
	compiladores pueden advertir fácilmente acerca de los moldes
	antiguos). La sintaxis explícita de moldes está pensada para que
	sea fácil encontrarlos, tal como se puede observar por sus
	nombres:
      </p><div class="table"><a id="idp4776976"></a><div class="table-contents"><table summary="Moldes explícitos de C++" border="1"><colgroup><col /><col /></colgroup><tbody><tr><td><code class="keyword">static_cast</code></td><td>
                Para moldes que se <span class="emphasis"><em>comportan bien</em></span> o
                <span class="emphasis"><em>razonablemente bien</em></span>, incluyendo
                cosas que se podrían hacer sin un molde (como una
                conversión automática de tipo).
              </td></tr><tr><td><code class="keyword">const_cast</code></td><td>
                Para moldear <code class="keyword">const</code> y/o <code class="keyword">volatile</code>
              </td></tr><tr><td><code class="keyword">reinterpret_cast</code></td><td>
                Para moldear a un significado completamente
                diferente. La clave es que se necesitará volver a
                moldear al tipo original para poderlo usar con
                seguridad. El tipo al que moldee se usa típicamente sólo
                para jugar un poco o algún otro propósito
                misterioso. Éste es el más peligroso de todos los
                moldes.
              </td></tr><tr><td><code class="keyword">dynamic_cast</code></td><td>
                Para realizar un <span class="emphasis"><em>downcasting</em></span> seguro
                (este molde se describe en el Capítulo 15).
              </td></tr></tbody></table></div><p class="title"><strong>Tabla 3.2. Moldes explícitos de C++</strong></p></div><br class="table-break" /><p>
	Los primeros tres moldes explícitos se describirán completamente
	en las siguientes secciones, mientras que los últimos se
	explicarán después de que haya aprendido más en el Capítulo 15.
      </p><div class="sect3" title="static_cast"><div class="titlepage"><div><div><h4 class="title"><a id="idp4784928"></a><code class="keyword">static_cast</code></h4></div></div></div><p>
	  El <code class="keyword">static_cast</code> se utiliza para todas las conversiones
	  que están bien definidas. Esto incluye conversiones
	  «seguras» que el compilador permitiría sin
	  utilizar un molde, y conversiones menos seguras que están sin
	  embargo bien definidas. Los tipos de conversiones que cubre
	  <code class="keyword">static_cast</code> incluyen las conversiones típicas sin
	  molde, conversiones de estrechamiento (pérdida de
	  información), forzar una conversión de un <code class="type">void*</code>,
	  conversiones de tipo implícitas, y navegación estática de
	  jerarquías de clases (ya que no se han visto aún clases ni
	  herencias, este último apartado se pospone hasta el Capítulo
	  15):
        </p><div class="example"><a id="idp4788264"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:static_cast.cpp</span>
<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0x7fff</span><span class="hl opt">;</span> <span class="hl slc">// Max pos value = 32767</span>
  <span class="hl kwb">long</span> l<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl slc">// (1) Typical castless conversions:</span>
  l <span class="hl opt">=</span> i<span class="hl opt">;</span>
  f <span class="hl opt">=</span> i<span class="hl opt">;</span>
  <span class="hl slc">// Also works:</span>
  l <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">long</span><span class="hl opt">&gt;(</span>i<span class="hl opt">);</span>
  f <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;(</span>i<span class="hl opt">);</span>

  <span class="hl slc">// (2) Narrowing conversions:</span>
  i <span class="hl opt">=</span> l<span class="hl opt">;</span> <span class="hl slc">// May lose digits</span>
  i <span class="hl opt">=</span> f<span class="hl opt">;</span> <span class="hl slc">// May lose info</span>
  <span class="hl slc">// Says &quot;I know,&quot; eliminates warnings:</span>
  i <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>l<span class="hl opt">);</span>
  i <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>f<span class="hl opt">);</span>
  <span class="hl kwb">char</span> c <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;(</span>i<span class="hl opt">);</span>

  <span class="hl slc">// (3) Forcing a conversion from void* :</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> vp <span class="hl opt">= &amp;</span>i<span class="hl opt">;</span>
  <span class="hl slc">// Old way produces a dangerous conversion:</span>
  <span class="hl kwb">float</span><span class="hl opt">*</span> fp <span class="hl opt">= (</span><span class="hl kwb">float</span><span class="hl opt">*)</span>vp<span class="hl opt">;</span>
  <span class="hl slc">// The new way is equally dangerous:</span>
  fp <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">*&gt;(</span>vp<span class="hl opt">);</span>

  <span class="hl slc">// (4) Implicit type conversions, normally</span>
  <span class="hl slc">// performed by the compiler:</span>
  <span class="hl kwb">double</span> d <span class="hl opt">=</span> <span class="hl num">0.0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> d<span class="hl opt">;</span> <span class="hl slc">// Automatic type conversion</span>
  x <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>d<span class="hl opt">);</span> <span class="hl slc">// More explicit</span>
  <span class="hl kwd">func</span><span class="hl opt">(</span>d<span class="hl opt">);</span> <span class="hl slc">// Automatic type conversion</span>
  <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>d<span class="hl opt">));</span> <span class="hl slc">// More explicit</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.39. C03/static_cast.cpp</strong></p></div><br class="example-break" /><p>
          En la sección (FIXME:xref:1), se pueden ver tipos de
          conversiones que eran usuales en C, con o sin un
          molde. Promover un <code class="type">int</code> a <code class="type">long</code> o
          <code class="type">float</code> no es un problema porque el último puede
          albergar siempre cualquier valor que un <code class="type">int</code>
          pueda contener. Aunque es innecesario, se puede utilizar
          <code class="keyword">static_cast</code> para remarcar estas promociones.
        </p><p>
	  Se muestra en (2) como se convierte al revés. Aquí, se puede
	  perder información porque un <code class="type">int</code> no es tan
	  «ancho» como un <code class="type">long</code> o un
	  <code class="type">float</code>; no aloja números del mismo tamaño. De
	  cualquier modo, este tipo de conversión se llama conversión de
	  estrechamiento. El compilador no impedirá que ocurran, pero
	  normalmente dará una advertencia. Se puede eliminar esta
	  advertencia e indicar que realmente se pretendía esto
	  utilizando un molde.
        </p><p>
          Tomar el valor de un <code class="type">void*</code> no está permitido en
          C++ a menos que use un molde (al contrario de C), como se
          puede ver en (3). Esto es peligroso y requiere que los
          programadores sepan lo que están haciendo. El
          <code class="keyword">static_cast</code>, al menos, es mas fácil de localizar que
          los moldes antiguos cuando se trata de cazar fallos.
        </p><p>
          La sección (FIXME:xref:4) del programa muestra las
          conversiones de tipo implícitas que normalmente se realizan
          de manera automática por el compilador. Son automáticas y no
          requieren molde, pero el utilizar <code class="keyword">static_cast</code>
          acentúa dicha acción en caso de que se quiera reflejar
          claramente qué está ocurriendo, para poder localizarlo
          después.
        </p></div><div class="sect3" title="const_cast"><div class="titlepage"><div><div><h4 class="title"><a id="idp4798008"></a><code class="keyword">const_cast</code></h4></div></div></div><p>
          Si quiere convertir de un <code class="keyword">const</code> a un
          no-<code class="keyword">const</code> o de un <code class="keyword">volatile</code> a un
          no-<code class="keyword">volatile</code>, se utiliza <code class="keyword">const_cast</code>. Es la
          única conversión permitida con <code class="keyword">const_cast</code>; si está
          involucrada alguna conversión adicional se debe hacer
          utilizando una expresión separada o se obtendrá un error en
          tiempo de compilación.
        </p><div class="example"><a id="idp4801968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:const_cast.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> j <span class="hl opt">= (</span><span class="hl kwb">int</span><span class="hl opt">*)&amp;</span>i<span class="hl opt">;</span> <span class="hl slc">// Deprecated form</span>
  j  <span class="hl opt">=</span> <span class="hl kwa">const_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">*&gt;(&amp;</span>i<span class="hl opt">);</span> <span class="hl slc">// Preferred</span>
  <span class="hl slc">// Can't do simultaneous additional casting:</span>
<span class="hl slc">//! long* l = const_cast&lt;long*&gt;(&amp;i); // Error</span>
  <span class="hl kwc">volatile</span> <span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> u <span class="hl opt">=</span> <span class="hl kwa">const_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">*&gt;(&amp;</span>k<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.40. C03/const_cast.cpp</strong></p></div><br class="example-break" /><p>
          Si toma la dirección de un objeto <code class="keyword">const</code>, produce un
          puntero a <code class="keyword">const</code>, éste no se puede asignar a un
          puntero que no sea <code class="keyword">const</code> sin un molde. El molde al
          estilo antiguo lo puede hacer, pero el <code class="keyword">const_cast</code> es
          el más apropiado en este caso. Lo mismo ocurre con
          <code class="keyword">volatile</code>.
        </p></div><div class="sect3" title="reinterpret_cast"><div class="titlepage"><div><div><h4 class="title"><a id="idp4806256"></a><code class="keyword">reinterpret_cast</code></h4></div></div></div><p>
          Este es el menos seguro de los mecanismos de molde, y el más
          susceptible de crear fallos. Un <code class="keyword">reinterpret_cast</code>
          supone que un objeto es un patrón de bits que se puede
          tratar (para algún oscuro propósito) como si fuese de un
          tipo totalmente distinto. Ese es el jugueteo de bits a bajo
          nivel por el cual C es famoso. Prácticamente siempre
          necesitará hacer <code class="keyword">reinterpret_cast</code> para volver al
          tipo original (o de lo contrario tratar a la variable como
          su tipo original) antes de hacer nada más con ella.
        </p><div class="example"><a id="idp4809104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:reinterpret_cast.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">const int</span> sz <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

<span class="hl kwb">struct</span> X <span class="hl opt">{</span> <span class="hl kwb">int</span> a<span class="hl opt">[</span>sz<span class="hl opt">]; };</span>

<span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>X<span class="hl opt">*</span> x<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">-&gt;</span>a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;--------------------&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X x<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(&amp;</span>x<span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> xp <span class="hl opt">=</span> <span class="hl kwa">reinterpret_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">*&gt;(&amp;</span>x<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*</span> i <span class="hl opt">=</span> xp<span class="hl opt">;</span> i <span class="hl opt">&lt;</span> xp <span class="hl opt">+</span> sz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl opt">*</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Can't use xp as an X* at this point</span>
  <span class="hl slc">// unless you cast it back:</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwa">reinterpret_cast</span><span class="hl opt">&lt;</span>X<span class="hl opt">*&gt;(</span>xp<span class="hl opt">));</span>
  <span class="hl slc">// In this example, you can also just use</span>
  <span class="hl slc">// the original identifier:</span>
  <span class="hl kwd">print</span><span class="hl opt">(&amp;</span>x<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.41. C03/reinterpret_cast.cpp</strong></p></div><br class="example-break" /><p>
          En este ejemplo, <code class="code">struct X</code> contiene un array de
          <code class="type">int</code>, pero cuando se crea uno en la pila como en
          <code class="code">X x</code>, los valores de cada uno de los
          <code class="type">int</code>s tienen basura (esto se demuestra utilizando la
          función <code class="function">print()</code> para mostrar los
          contenidos de <code class="keyword">struct</code>). Para inicializarlas, la
          dirección del <code class="type">X</code> se toma y se moldea a un puntero
          <code class="type">int</code>, que es luego iterado a través del array para
          inicializar cada <code class="type">int</code> a cero. Fíjese como el
          límite superior de <code class="varname">i</code> se calcula
          «añadiendo» <code class="varname">sz</code> a
          <code class="varname">xp</code>; el compilador sabe que lo que usted
          quiere realmente son las direcciones de sz mayores que
          <code class="varname">xp</code> y él realiza el cálculo aritmético por
          usted. FIXME(Comprobar lo que dice este párrafo de acuerdo con
          el código)




        </p><p>
          La idea del uso de <code class="keyword">reinterpret_cast</code> es que cuando se
          utiliza, lo que se obtiene es tan extraño que no se puede
          utilizar para los propósitos del tipo original, a menos que se
          vuelva a moldear.  Aquí, vemos el molde otra vez a
          <code class="type">X*</code> en la llamada a <code class="function">print()</code>,
          pero por supuesto, dado que tiene el identificador original
          también se puede utilizar. Pero <code class="varname">xp</code> sólo es
          útil como un <code class="type">int*</code>, lo que es
          verdaderamente una «reinterpretación» del <code class="type">X</code>
          original.
        </p><p>
          Un <code class="keyword">reinterpret_cast</code> a menudo indica una programación
          desaconsejada y/o no portable, pero está disponible si decide
          que lo necesita.
        </p></div></div><div class="sect2" title="3.7.13. sizeof - un operador en si mismo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4819432"></a>3.7.13. <code class="literal">sizeof</code> - un operador en si mismo</h3></div></div></div><p>
        El operador <code class="literal">sizeof</code> es independiente porque
        satisface una necesidad inusual. <code class="literal">sizeof</code> proporciona
        información acerca de la cantidad de memoria ocupada por los
        elementos de datos. Como se ha indicado antes en este capítulo,
        <code class="literal">sizeof</code> indica el número de bytes utilizado por
        cualquier variable particular. También puede dar el tamaño de un
        tipo de datos (sin necesidad de un nombre de variable):
      </p><div class="example"><a id="idp4822400"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:sizeof.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(double) = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, sizeof(char) = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.42. C03/sizeof.cpp</strong></p></div><br class="example-break" /><p>
        Por definición, el <code class="literal">sizeof</code> de cualquier tipo de
        <code class="type">char</code> (<code class="type">signed</code>, <code class="type">unsigned</code> o
        simple) es siempre uno, sin tener en cuenta que el
        almacenamiento subyacente para un <code class="type">char</code> es realmente
        un byte. Para todos los demás tipos, el resultado es el tamaño
        en bytes.
      </p><p>
        Tenga en cuenta que <code class="literal">sizeof</code> es un operador, no una
        función. Si lo aplica a un tipo, se debe utilizar con la
        forma entre paréntesis mostrada anteriormente, pero si se aplica
        a una variable se puede utilizar sin paréntesis:
      </p><div class="example"><a id="idp4826448"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:sizeofOperator.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.43. C03/sizeofOperator.cpp</strong></p></div><br class="example-break" /><p>
        <code class="literal">sizeof</code> también puede informar de los tamaños de
        tipos definidos por el usuario. Se utilizará más adelante en el
        libro.
      </p></div><div class="sect2" title="3.7.14. La palabra reservada asm"><div class="titlepage"><div><div><h3 class="title"><a id="idp4828352"></a>3.7.14. La palabra reservada <code class="keyword">asm</code></h3></div></div></div><p>
        Este es un mecanismo de escape que permite escribir código
        ensamblador para el hardware dentro de un programa en C++. A
        menudo es capaz de referenciar variables C++ dentro del
        código ensamblador, lo que significa que se puede comunicar
        fácilmente con el código C++ y limitar el código ensamblador a
        lo necesario para ajustes eficientes o para utilizar
        instrucciones especiales del procesador. La sintaxis exacta que
        se debe usar cuando se escribe en lenguaje ensamblador es
        dependiente del compilador y se puede encontrar en la
        documentación del compilador.
      </p></div><div class="sect2" title="3.7.15. Operadores explícitos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4830032"></a>3.7.15. Operadores explícitos</h3></div></div></div><p>
        Son palabras reservadas para los operadores lógicos y
        binarios. Los programadores de fuera de los USA sin teclados con
        caracteres tales como &amp;, |, ^, y demás, estaban forzados a
        utilizar horribles <span class="emphasis"><em>trígrafos</em></span>, que no sólo
        eran insoportable de escribir, además eran difíciles de
        leer. Esto se ha paliado en C++ con palabras reservadas
        adicionales:
      </p><div class="table"><a id="idp4831488"></a><div class="table-contents"><table summary="Nuevas palabras reservadas para operadores booleanos" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Palabra reservada</th><th>Significado</th></tr></thead><tbody><tr><td><code class="keyword">and</code></td><td>&amp;&amp; ( «y» lógica)</td></tr><tr><td><code class="keyword">or</code></td><td>|| («o» lógica)</td></tr><tr><td><code class="keyword">not</code></td><td>! (negación lógica)</td></tr><tr><td><code class="keyword">not_eq</code></td><td>!= (no-equivalencia lógica)</td></tr><tr><td><code class="keyword">bitand</code></td><td>&amp; (and para bits)</td></tr><tr><td><code class="keyword">and_eq</code></td><td>&amp;= (asignación-and para bits)</td></tr><tr><td><code class="keyword">bitor</code></td><td>| (or para bits)</td></tr><tr><td><code class="keyword">or_eq</code></td><td>!= (asignación-or para bits)</td></tr><tr><td><code class="keyword">xor</code></td><td>^ («o» exclusiva para bits)</td></tr><tr><td><code class="keyword">xor_equ</code></td><td>^= (asignación xor para bits)</td></tr><tr><td><code class="keyword">compl</code></td><td>~ (complemento binario)</td></tr></tbody></table></div><p class="title"><strong>Tabla 3.3. Nuevas palabras reservadas para operadores booleanos</strong></p></div><br class="table-break" /><p>
        Si el compilador obedece al Estándar C++, soportará estas palabras
        reservadas.
      </p></div></div><div class="sect1" title="3.8. Creación de tipos compuestos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4844384"></a>3.8. Creación de tipos compuestos</h2></div></div></div><p>
      Los tipos de datos fundamentales y sus variantes son esenciales,
      pero más bien primitivos. C y C++ incorporan herramientas que
      permiten construir tipos de datos más sofisticados a partir de los
      tipos de datos fundamentales. Como se verá, el más importante de
      estos es <code class="keyword">struct</code>, que es el fundamento para las
      <code class="keyword">class</code> en C++.  Sin embargo, la manera más simple de crear
      tipos más sofisticados es simplemente poniendo un alias a otro nombre
      mediante <code class="keyword">typedef</code>.
    </p><div class="sect2" title="3.8.1. Creación de alias usando typedef"><div class="titlepage"><div><div><h3 class="title"><a id="idp4847224"></a>3.8.1. Creación de alias usando <code class="keyword">typedef</code></h3></div></div></div><p>
        Esta palabra reservada promete más de lo que da:
        <code class="keyword">typedef</code> sugiere «definición de tipo»
        cuando «alias» habría sido probablemente una
        descripción más acertada, ya que eso es lo que hace
        realmente. La sintaxis es:
      </p><p>
	<code class="keyword">typede</code>f descripción-de-tipo-existente nombre-alias
      </p><p>
	La gente a menudo utiliza <code class="keyword">typedef</code> cuando los tipos de
	datos se vuelven complicados, simplemente para evitar escribir
	más de lo necesario. A continuación, una forma común de utilizar
	typedef:
      </p><pre class="programlisting">
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned long</span> ulong<span class="hl opt">;</span>
</pre><p>
        Ahora si pone <code class="type">ulong</code>, el compilador sabe que se está
        refiriendo a <code class="type">unsigned long</code>. Puede pensar que esto
        se puede lograr fácilmente utilizando sustitución en el
        preprocesador, pero hay situaciones en las cuales el compilador
        debe estar advertido de que está tratando un nombre como si
        fuese un tipo, y por eso <code class="keyword">typedef</code> es esencial.
      </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> x<span class="hl opt">,</span> y<span class="hl opt">;</span>
</pre><p>
	Esto genera en realidad un <code class="type">int*</code> que es
	<code class="varname">x</code>, y un <code class="type">int</code> (no un
	<code class="type">int*</code>) que es <code class="varname">y</code>. Esto significa
	que el <span class="token">*</span> añade a la derecha, no a la
	izquierda. Pero, si utiliza un <code class="keyword">typedef</code>:
      </p><pre class="programlisting">
<span class="hl kwc">typedef</span> <span class="hl kwb">int</span><span class="hl opt">*</span> IntPtr<span class="hl opt">;</span>
IntPtr x<span class="hl opt">,</span> y<span class="hl opt">;</span>
</pre><p>
        Entonces ambos, <code class="varname">x</code> e <code class="varname">y</code> son
        del tipo <code class="type">int*</code>.
      </p><p>
        Se puede discutir sobre ello y decir que es más explícito y por
        consiguiente mas legible evitar <code class="keyword">typedef</code>s para los tipos
        primitivos, y de hecho los programas se vuelven difíciles de
        leer cuando se utilizan demasiados <code class="keyword">typedef</code>s. De todos
        modos, los <code class="keyword">typedef</code>s se vuelven especialmente
        importantes en C cuando se utilizan con <code class="keyword">struct</code>.
      </p></div><div class="sect2" title="3.8.2. Usar struct para combinar variables"><div class="titlepage"><div><div><h3 class="title"><a id="idp4859312"></a>3.8.2. 
        Usar <code class="keyword">struct</code> para combinar variables
      </h3></div></div></div><p>
        Un <code class="keyword">struct</code> es una manera de juntar un grupo de variables
        en una estructura. Cuando se crea un <code class="keyword">struct</code>, se pueden
        crear varias instancias de este «nuevo» tipo de
        variable que ha inventado. Por ejemplo:
      </p><div class="example"><a id="idp4861592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:SimpleStruct.cpp</span>
<span class="hl kwb">struct</span> Structure1 <span class="hl opt">{</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">struct</span> Structure1 s1<span class="hl opt">,</span> s2<span class="hl opt">;</span>
  s1<span class="hl opt">.</span>c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span> <span class="hl slc">// Select an element using a '.'</span>
  s1<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  s1<span class="hl opt">.</span>f <span class="hl opt">=</span> <span class="hl num">3.14</span><span class="hl opt">;</span>
  s1<span class="hl opt">.</span>d <span class="hl opt">=</span> <span class="hl num">0.00093</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>f <span class="hl opt">=</span> <span class="hl num">3.14</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>d <span class="hl opt">=</span> <span class="hl num">0.00093</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.44. C03/SimpleStruct.cpp</strong></p></div><br class="example-break" /><p>
        La declaración de <code class="keyword">struct</code> debe acabar con una llave. En
        <code class="function">main()</code>, se crean dos instancias de
        <code class="type">Structure1</code>: <code class="varname">s1</code> y
        <code class="varname">s2</code>.  Cada una de ellas tiene su versión
        propia y separada de <code class="varname">c</code>, <code class="varname">I</code>,
        <code class="varname">f</code> y <code class="varname">d</code>. De modo que
        <code class="varname">s1</code> y <code class="varname">s2</code> representan
        bloques de variables completamente independientes. Para
        seleccionar uno de estos elementos dentro de
        <code class="varname">s1</code> o <code class="varname">s2</code>, se utiliza un
        <span class="token">.</span>, sintaxis que se ha visto en el cápitulo
        previo cuando se utilizaban objetos <code class="keyword">class</code> de C++ - ya
        que las clases surgían de <code class="keyword">struct</code>s, de ahí proviene esta
        sintaxis.
      </p><p>
        Una cosa a tener en cuenta es la torpeza de usar
        <code class="type">Structure1</code> (como salta a la vista, eso sólo se
        requiere en C, y no en C++). En C, no se puede poner
        <code class="type">Structure1</code> cuando se definen variables, se debe
        poner <code class="type">struct Structure1</code>. Aquí es donde
        <code class="keyword">typedef</code> se vuelve especialmente útil en C:
      </p><div class="example"><a id="idp4869384"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:SimpleStruct2.cpp</span>
<span class="hl slc">// Using typedef with struct</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> <span class="hl opt">{</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
<span class="hl opt">}</span> Structure2<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Structure2 s1<span class="hl opt">,</span> s2<span class="hl opt">;</span>
  s1<span class="hl opt">.</span>c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  s1<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  s1<span class="hl opt">.</span>f <span class="hl opt">=</span> <span class="hl num">3.14</span><span class="hl opt">;</span>
  s1<span class="hl opt">.</span>d <span class="hl opt">=</span> <span class="hl num">0.00093</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>f <span class="hl opt">=</span> <span class="hl num">3.14</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span>d <span class="hl opt">=</span> <span class="hl num">0.00093</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.45. C03/SimpleStruct2.cpp</strong></p></div><br class="example-break" /><p>
        Usando <code class="keyword">typedef</code> de este modo, se puede simular (en C;
        intentar eliminar el <code class="keyword">typedef</code> para C++) que
        <code class="type">Structure2</code> es un tipo predefinido, como
        <code class="type">int</code> o <code class="type">float</code>, cuando define
        <code class="varname">s1</code> y <code class="varname">s2</code> (pero se ha de
        tener en cuenta de que sólo tiene información - características
        - y no incluye comportamiento, que es lo que se obtiene con
        objetos reales en C++). Observe que el <code class="keyword">struct</code> se ha
        declarado al principio, porque el objetivo es crear el
        <code class="keyword">typedef</code>. Sin embargo, hay veces en las que sería
        necesario referirse a <code class="keyword">struct</code> durante su definición. En
        esos casos, se puede repetir el nombre del <code class="keyword">struct</code> como
        tal y como <code class="keyword">typedef</code>.
      </p><div class="example"><a id="idp4875656"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:SelfReferential.cpp</span>
<span class="hl slc">// Allowing a struct to refer to itself</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> SelfReferential <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  SelfReferential<span class="hl opt">*</span> sr<span class="hl opt">;</span> <span class="hl slc">// Head spinning yet?</span>
<span class="hl opt">}</span> SelfReferential<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  SelfReferential sr1<span class="hl opt">,</span> sr2<span class="hl opt">;</span>
  sr1<span class="hl opt">.</span>sr <span class="hl opt">= &amp;</span>sr2<span class="hl opt">;</span>
  sr2<span class="hl opt">.</span>sr <span class="hl opt">= &amp;</span>sr1<span class="hl opt">;</span>
  sr1<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  sr2<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1024</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.46. C03/SelfReferential.cpp</strong></p></div><br class="example-break" /><p>
        Si lo observa detenidamente, puede ver que
        <code class="varname">sr1</code> y <code class="varname">sr2</code> apuntan el uno
        al otro, guardando cada uno una parte de la información.
     </p><p>
        En realidad, el nombre <code class="keyword">struct</code> no tiene que ser lo mismo
        que el nombre <code class="keyword">typedef</code>, pero normalmente se hace de esta
        manera ya que tiende a simplificar las cosas.
      </p><div class="sect3" title="Punteros y estructuras"><div class="titlepage"><div><div><h4 class="title"><a id="idp4879056"></a>Punteros y estructuras</h4></div></div></div><p>
          En los ejemplos anteriores, todos los <code class="keyword">structs</code> se
          manipulan como objetos. Sin embargo, como cualquier bloque de
          memoria, se puede obtener la dirección de un objeto
          <code class="keyword">struct</code> (tal como se ha visto en
          <code class="filename">SelfReferential.cpp</code>). Para seleccionar
          los elementos de un objeto <code class="keyword">struct</code> en particular, se
          utiliza un <span class="token">.</span>, como se ha visto
          anteriormente. No obstante, si tiene un puntero a un objeto
          <code class="keyword">struct</code>, debe seleccionar un elemento de dicho objeto
          utilizando un operador diferente: el <span class="token">-&gt;</span>. A
          continuación, un ejemplo:
        </p><div class="example"><a id="idp4882824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:SimpleStruct3.cpp</span>
<span class="hl slc">// Using pointers to structs</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> Structure3 <span class="hl opt">{</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
<span class="hl opt">}</span> Structure3<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Structure3 s1<span class="hl opt">,</span> s2<span class="hl opt">;</span>
  Structure3<span class="hl opt">*</span> sp <span class="hl opt">= &amp;</span>s1<span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>f <span class="hl opt">=</span> <span class="hl num">3.14</span><span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>d <span class="hl opt">=</span> <span class="hl num">0.00093</span><span class="hl opt">;</span>
  sp <span class="hl opt">= &amp;</span>s2<span class="hl opt">;</span> <span class="hl slc">// Point to a different struct object</span>
  sp<span class="hl opt">-&gt;</span>c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>f <span class="hl opt">=</span> <span class="hl num">3.14</span><span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>d <span class="hl opt">=</span> <span class="hl num">0.00093</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.47. C03/SimpleStruct3.cpp</strong></p></div><br class="example-break" /><p>
          En <code class="function">main()</code>, el puntero
          <code class="varname">sp</code> está apuntando inicialmente a
          <code class="varname">s1</code>, y los miembros de <code class="varname">s1</code>
          se inicializan seleccionándolos con el <span class="token">-&gt;</span>
          (y se utiliza este mismo operador para leerlos). Pero luego
          <code class="varname">sp</code> apunta a <code class="varname">s2</code>, y esas
          variables se inicializan del mismo modo. Como puede ver, otro
          beneficio en el uso de punteros es que pueden ser redirigidos
          dinámicamente para apuntar a objetos diferentes, eso proporciona
          más flexibilidad a sus programas, tal como verá.
        </p><p>
          De momento, es todo lo que debe saber sobre <code class="keyword">struct</code>,
          pero se sentirá mucho más cómodo con ellos (y especialmente
          con sus sucesores mas potentes, las clases) a medida que
          progrese en este libro.
        </p></div></div><div class="sect2" title="3.8.3. Programas más claros gracias a enum"><div class="titlepage"><div><div><h3 class="title"><a id="idp4887816"></a>3.8.3. Programas más claros gracias a <code class="keyword">enum</code></h3></div></div></div><p>
        Un tipo de datos enumerado es una manera de asociar nombres a
        números, y por consiguiente de ofrecer más significado a alguien
        que lea el código. La palabra reservada <code class="keyword">enum</code> (de C)
        enumera automáticamente cualquier lista de identificadores que
        se le pase, asignándoles valores de 0, 1, 2, etc. Se pueden
        declarar variables <code class="keyword">enum</code> (que se representan siempre
        como valores enteros). La declaración de un <code class="keyword">enum</code> se
        parece a la declaración de un <code class="keyword">struct</code>.
     </p><p>
        Un tipo de datos enumerado es útil cuando se quiere poder seguir
        la pista de alguna característica:
      </p><div class="example"><a id="idp4891976"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Enum.cpp</span>
<span class="hl slc">// Keeping track of shapes</span>

<span class="hl kwb">enum</span> ShapeType <span class="hl opt">{</span>
  circle<span class="hl opt">,</span>
  square<span class="hl opt">,</span>
  rectangle
<span class="hl opt">};</span>  <span class="hl slc">// Must end with a semicolon like a struct</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ShapeType shape <span class="hl opt">=</span> circle<span class="hl opt">;</span>
  <span class="hl slc">// Activities here....</span>
  <span class="hl slc">// Now do something based on what the shape is:</span>
  <span class="hl kwa">switch</span><span class="hl opt">(</span>shape<span class="hl opt">) {</span>
    <span class="hl kwa">case</span> circle<span class="hl opt">:</span>  <span class="hl com">/* circle stuff */</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> square<span class="hl opt">:</span>  <span class="hl com">/* square stuff */</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> rectangle<span class="hl opt">:</span>  <span class="hl com">/* rectangle stuff */</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.48. C03/Enum.cpp</strong></p></div><br class="example-break" /><p>
        <code class="varname">shape</code> es una variable del tipo de datos
        enumerado <code class="type">ShapeType</code>, y su valor se compara con el
        valor en la enumeración. Ya que <code class="varname">shape</code> es
        realmente un <code class="type">int</code>, puede albergar cualquier valor
        que corresponda a <code class="type">int</code> (incluyendo un número
        negativo). También se puede comparar una variable
        <code class="type">int</code> con un valor de una enumeración.
      </p><p>
        Se ha de tener en cuenta que el ejemplo anterior de intercambiar
        los tipos tiende a ser una manera problemática de programar. C++
        tiene un modo mucho mejor de codificar este tipo de cosas, cuya
        explicación se pospondrá para mucho mas adelante en este libro.
     </p><p>
        Si el modo en que el compilador asigna los valores no es de su
        agrado, puede hacerlo manualmente, como sigue:
      </p><pre class="programlisting">
<span class="hl kwb">enum</span> ShapeType <span class="hl opt">{</span>
  circle <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">,</span> square <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">,</span> rectangle <span class="hl opt">=</span> <span class="hl num">50</span>
<span class="hl opt">};</span>
</pre><p>
	Si da valores a algunos nombres y a otros no, el compilador
	utilizará el siguiente valor entero. Por ejemplo,
      </p><pre class="programlisting">
<span class="hl kwb">enum</span> snap <span class="hl opt">{</span> crackle <span class="hl opt">=</span> <span class="hl num">25</span><span class="hl opt">,</span> pop <span class="hl opt">};</span>
</pre><p>
        El compilador le da a <code class="varname">pop</code> el valor
        <code class="literal">26</code>.
     </p><p>
        Es fácil comprobar que el código es más legible cuando se
        utilizan tipos de datos enumerados. No obstante, en cierto
        grado esto sigue siendo un intento (en C) de lograr las cosas
        que se pueden lograr con una <code class="keyword">class</code> en C++, y por eso
        verá que <code class="keyword">enum</code> se utiliza menos en C++.
      </p><div class="sect3" title="Comprobación de tipos para enumerados"><div class="titlepage"><div><div><h4 class="title"><a id="idp4899920"></a>Comprobación de tipos para enumerados</h4></div></div></div><p>
          Las enumeraciones en C son bastante primitivas, simplemente
          asocian valores enteros a nombres, pero no aportan
          comprobación de tipos. En C++, como era de esperar a estas
          alturas, el concepto de tipos es fundamental, y eso se cumple
          con las enumeraciones. Cuando crea una enumeración nombrada,
          crea efectivamente un nuevo tipo, tal como se hace con una
          clase: El nombre de la enumeración se convierte en una palabra
          reservada durante esa unidad de traducción.
        </p><p>
          Además, hay una comprobación de tipos mas estricta para la
          enumeración en C++ que en C. En particular, resulta evidente
          si tiene una instancia de la enumeración <code class="type">color</code>
          llamada <code class="varname">a</code>. En C puede decir
          <code class="code">a++</code>, pero en C++ no es posible. Eso se debe a que
          el incrementar una enumeración se realizan dos conversiones de
          tipo, una de ellas es legal en C++ y la otra no. Primero, el
          valor de la enumeración se convierte del tipo
          <code class="type">color</code> a <code class="type">int</code>, luego el valor se
          incrementa, y finalmente el <code class="type">int</code> se vuelve a
          convertir a tipo <code class="type">color</code>. En C++ esto no está
          permitido, porque <code class="type">color</code> es un tipo diferente de
          <code class="type">int</code>. Eso tiene sentido, porque ¿cómo saber si el
          incremento de <code class="literal">blue</code> siquiera estará en la
          lista de colores?  Si quiere poder incrementar un
          <code class="type">color</code>, debería ser una clase (con una operación
          de incremento) y no un <code class="keyword">enum,</code> porque en la clase se
          puede hacer de modo que sea mucho más seguro. Siempre que
          escriba código que asuma una conversión implícita a un tipo
          <code class="keyword">enum</code>, el compilador alertará de que se trata de una
          actividad inherentemente peligrosa.
        </p><p>
          Las uniones (descriptas a continuación) tienen una comprobación
          adicional de tipo similar en C++.
        </p></div></div><div class="sect2" title="3.8.4. Cómo ahorrar memoria con union"><div class="titlepage"><div><div><h3 class="title"><a id="idp4907632"></a>3.8.4. Cómo ahorrar memoria con <code class="keyword">union</code></h3></div></div></div><p>
        A veces un programa manejará diferentes tipos de datos
        utilizando la misma variable. En esta situación, se tienen dos
        elecciones: se puede crear un <code class="keyword">struct</code> que contenga todos
        los posibles tipos que se puedan necesitar almacenar, o se puede
        utilizar una <code class="keyword">union</code>. Una <code class="keyword">union</code> amontona toda la
        información en un único espacio; calcula la cantidad de espacio
        necesaria para el elemento más grande, y hace de ese sea el
        tamaño de la <code class="keyword">union</code>. Utilice la <code class="keyword">union</code> para
        ahorrar memoria.
      </p><p>
        Cuando se coloca un valor en una <code class="keyword">union</code>, el valor
        siempre comienza en el mismo sitio al principio de la
        <code class="keyword">union</code>, pero sólo utiliza el espacio necesario. Por eso,
        se crea una «super-variable» capaz de alojar
        cualquiera de las variables de la <code class="keyword">union</code>. Las
        direcciones de todas las variables de la <code class="keyword">union</code> son la
        misma (en una clase o <code class="keyword">struct</code>, las direcciones son
        diferentes).
     </p><p>
        A continuación, un uso simple de una <code class="keyword">union</code>. Intente
        eliminar varios elementos y observe qué efecto tiene en el
        tamaño de la <code class="keyword">union</code>. Fíjese que no tiene sentido
        declarar más de una instancia de un sólo tipo de datos en una
        union (a menos que quiera darle un nombre distinto).
      </p><div class="example"><a id="idp4916424"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Union.cpp</span>
<span class="hl slc">// The size and simple use of a union</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">union</span> Packed <span class="hl opt">{</span> <span class="hl slc">// Declaration similar to a class</span>
  <span class="hl kwb">char</span> i<span class="hl opt">;</span>
  <span class="hl kwb">short</span> j<span class="hl opt">;</span>
  <span class="hl kwb">int</span> k<span class="hl opt">;</span>
  <span class="hl kwb">long</span> l<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>  
  <span class="hl slc">// The union will be the size of a </span>
  <span class="hl slc">// double, since that's the largest element</span>
<span class="hl opt">};</span>  <span class="hl slc">// Semicolon ends a union, like a struct</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(Packed) = &quot;</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Packed<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  Packed x<span class="hl opt">;</span>
  x<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl str">'c'</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  x<span class="hl opt">.</span>d <span class="hl opt">=</span> <span class="hl num">3.14159</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span>d <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.49. C03/Union.cpp</strong></p></div><br class="example-break" /><p>
        El compilador realiza la asignación apropiada para el miembro de
        la unión seleccionado.
     </p><p>
        Una vez que se realice una asignación, al compilador le da igual
        lo que se haga con la unión. En el ejemplo anterior, se puede
        asignar un valor en coma-flotante a <code class="varname">x</code>:
      </p><pre class="programlisting">
x<span class="hl opt">.</span>f <span class="hl opt">=</span> <span class="hl num">2.222</span><span class="hl opt">;</span>
</pre><p>
	Y luego enviarlo a la salida como si fuese un <code class="type">int</code>:
      </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span>i<span class="hl opt">;</span>
</pre><p>
        Eso produciría basura.
      </p></div><div class="sect2" title="3.8.5. Arrays"><div class="titlepage"><div><div><h3 class="title"><a id="idp4920848"></a>3.8.5. Arrays</h3></div></div></div><p>
	Los vectores son un tipo compuesto porque permiten
	agrupar muchas variables, una a continuación de la otra,
	bajo un identificador único. Si dice:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre><p>
        Se crea espacio para 10 variables <code class="type">int</code> colocadas una
        después de la otra, pero sin identificadores únicos para cada
        variable. En su lugar, todas están englobadas por el nombre
        <code class="varname">a</code>.
     </p><p>
        Para acceder a cualquiera de los <span class="emphasis"><em>elementos del
        vector</em></span>, se utiliza la misma sintaxis de corchetes que
        se utiliza para definir el vector:
      </p><pre class="programlisting">
a<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">] =</span> <span class="hl num">47</span><span class="hl opt">;</span>
</pre><p>
        Sin embargo, debe recordar que aunque el tamaño de
        <code class="varname">a</code> es <code class="literal">10</code>, se seleccionan
        los elementos del vector comenzando por cero (esto se llama a
        veces <span class="emphasis"><em>indexado a cero</em></span><sup>[<a id="idp4924944" href="#ftn.idp4924944" class="footnote">42</a>]</sup>, de modo que sólo se pueden seleccionar los
        elementos del vector de 0 a 9, como sigue:
      </p><div class="example"><a id="idp4925736"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Arrays.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> <span class="hl num">10</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> <span class="hl opt">&lt;&lt;</span> a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.50. C03/Arrays.cpp</strong></p></div><br class="example-break" /><p>
        Los accesos a vectores son extremadamente rápidos, Sin embargo,
        si se indexa más allá del final del vector, no hay ninguna red
        de seguridad - se entrará en otras variables. La otra desventaja
        es que se debe definir el tamaño del vector en tiempo de
        compilación; si se quiere cambiar el tamaño en tiempo de
        ejecución no se puede hacer con la sintaxis anterior (C tiene
        una manera de crear un vector dinámicamente, pero es
        significativamente más sucia). El <code class="classname">vector</code>
        de C++ presentado en el capítulo anterior, proporciona un objeto
        parecido al vector que se redimensiona automáticamente , de modo
        que es una solución mucho mejor si el tamaño del vector no puede
        conocer en tiempo de compilación.
     </p><p>
        Se puede hacer un vector de cualquier tipo, incluso de
        <code class="keyword">struct</code>s:
      </p><div class="example"><a id="idp4929216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StructArray.cpp</span>
<span class="hl slc">// An array of struct</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl opt">}</span> ThreeDpoint<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ThreeDpoint p<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    p<span class="hl opt">[</span>i<span class="hl opt">].</span>i <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
    p<span class="hl opt">[</span>i<span class="hl opt">].</span>j <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">;</span>
    p<span class="hl opt">[</span>i<span class="hl opt">].</span>k <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.51. C03/StructArray.cpp</strong></p></div><br class="example-break" /><p>
        Fíjese como el identificador de <code class="keyword">struct</code>
        <code class="varname">i</code> es independiente del <code class="varname">i</code>
        del bucle <code class="keyword">for</code>.
     </p><p>
        Para comprobar que cada elemento del vector es contiguo con el
        siguiente, puede imprimir la dirección de la siguiente manera:
      </p><div class="example"><a id="idp4932408"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ArrayAddresses.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(int) = &quot;</span><span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;a[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> 
         <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.52. C03/ArrayAddresses.cpp</strong></p></div><br class="example-break" /><p>
	Cuando se ejecuta este programa, se ve que cada elemento está
	separado por el tamaño de un <code class="type">int</code> del anterior. Esto
	significa, que están colocados uno a continuación del otro.
      </p><div class="sect3" title="Punteros y arrays"><div class="titlepage"><div><div><h4 class="title"><a id="idp4934312"></a>Punteros y arrays</h4></div></div></div><p>
	  El identificador de un vector es diferente de los
	  identificadores de las variables comunes. Un identificador de
	  un vector no es un <span class="emphasis"><em>lvalue</em></span>; no se le puede
	  asignar nada. En realidad es FIXME:gancho dentro de la
	  sintaxis de corchetes, y cuando se usa el nombre de un vector,
	  sin los corchetes, lo que se obtiene es la dirección inicial
	  del vector:
        </p><div class="example"><a id="idp4935632"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ArrayIdentifier.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;a[0] =&quot;</span> <span class="hl opt">&lt;&lt; &amp;</span>a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.53. C03/ArrayIdentifier.cpp</strong></p></div><br class="example-break" /><p>
          Cuando se ejecuta este programa, se ve que las dos direcciones
          (que se imprimen en hexadecimal, ya que no se moldea a
          <code class="type">long</code>) son las misma.
        </p><p>
          De modo que una manera de ver el identificador de un vector es
          como un puntero de sólo lectura al principio de éste. Y aunque
          no se pueda hacer que el identificador del vector apunte a
          cualquier otro sitio, se puede crear otro puntero y utilizarlo
          para moverse dentro del vector. De hecho, la sintaxis de
          corchetes también funciona con punteros convencionales:
        </p><div class="example"><a id="idp4938328"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PointersAndBrackets.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    ip<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> <span class="hl num">10</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.54. C03/PointersAndBrackets.cpp</strong></p></div><br class="example-break" /><p>
          El hecho de que el nombre de un vector produzca su dirección
          de inicio resulta bastante importante cuando hay que pasar un
          vector a una función. Si declara un vector como un argumento
          de una función, lo que realmente está declarando es un
          puntero. De modo que en el siguiente ejemplo,
          <code class="function">fun1()</code> y <code class="function">func2()</code>
          tienen la misma lista de argumentos:
        </p><div class="example"><a id="idp4940960"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ArrayArguments.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">[],</span> <span class="hl kwb">int</span> size<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> i <span class="hl opt">-</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">func2</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*</span> a<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> i <span class="hl opt">+</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">[],</span> string name<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> name <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> 
         <span class="hl opt">&lt;&lt;</span> a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">],</span> b<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">];</span>
  <span class="hl slc">// Probably garbage values:</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl slc">// Initialize the arrays:</span>
  <span class="hl kwd">func1</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">func1</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl slc">// Notice the arrays are always modified:</span>
  <span class="hl kwd">func2</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">func2</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.55. C03/ArrayArguments.cpp</strong></p></div><br class="example-break" /><p>
          A pesar de que <code class="function">func1()</code> y
          <code class="function">func2()</code> declaran sus argumentos de
          distinta forma, el uso es el mismo dentro de la función. Hay
          otros hechos que revela este ejemplo: los vectores no se pueden
          pasados por valor<sup>[<a id="idp4945120" href="#ftn.idp4945120" class="footnote">43</a>]</sup>, es decir, que nunca se puede obtener
          automáticamente una copia local del vector que se pasa a una
          función. Por eso, cuando se modifica un vector, siempre se
          está modificando el objeto externo. Eso puede resultar un poco
          confuso al principio, si lo que se espera es el paso-por-valor
          como en los argumentos ordinarios.
        </p><p>
          Fíjese que <code class="function">print()</code> utiliza la sintaxis de
          corchetes para los argumentos de tipo vector. Aunque la
          sintaxis de puntero y la sintaxis de corchetes efectivamente
          es la mismo cuando se están pasando vectores como argumentos,
          la sintaxis de corchetes deja más clara al lector que se
          pretende enfatizar que dicho argumento es un vector.
        </p><p>
          Observe también que el argumento <code class="varname">size</code> se
          pasa en cada caso. La dirección no es suficiente información
          al pasar un vector; siempre se debe ser posible obtener el
          tamaño del vector dentro de la función, de manera que no se
          salga de los límites de dicho vector.
        </p><p>
          Los vectores pueden ser de cualquier tipo, incluyendo vectores
          de punteros. De hecho, cuando se quieren pasar argumentos de
          tipo línea de comandos dentro del programa, C y C++ tienen una
          lista de argumentos especial para <code class="function">main()</code>,
          que tiene el siguiente aspecto:
        </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span> <span class="hl slc">// ...</span>
</pre><p>
          El primer argumento es el número de elementos en el vector,
          que es el segundo argumento. El segundo argumento es siempre
          un vector de <code class="type">char*</code>, porque los argumentos se
          pasan desde la línea de comandos como vectores de caracteres
          (y recuerde, un vector sólo se puede pasar como un
          puntero). Cada bloque de caracteres delimitado por un espacio
          en blanco en la línea de comandos se aloja en un elemento
          separado en el vector. El siguiente programa imprime todos los
          argumentos de línea de comandos recorriendo el vector:
        </p><div class="example"><a id="idp4953656"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:CommandLineArgs.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;argc = &quot;</span> <span class="hl opt">&lt;&lt;</span> argc <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> argc<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;argv[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> 
         <span class="hl opt">&lt;&lt;</span> argv<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.56. C03/CommandLineArgs.cpp</strong></p></div><br class="example-break" /><p>
          Observe que <code class="code">argv[0]</code> es la ruta y el nombre del
          programa en sí mismo. Eso permite al programa descubrir
          información de sí mismo. También añade un argumento más al
          vector de argumentos del programa, de modo que un error común
          al recoger argumentos de línea de comandos es tomar argv[0]
          como si fuera el primer argumento.
        </p><p>
          No es obligatorio utilizar <code class="varname">argc</code> y
          <code class="varname">argv</code> como identificadores de los parámetros
          de <code class="function">main()</code>; estos identificadores son sólo
          convenciones (pero puede confundir al lector si no se
          respeta). También, hay un modo alternativo de declarar argv:
        </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">**</span> argv<span class="hl opt">) {</span> <span class="hl slc">// ...</span>
</pre><p>
          Las dos formas son equivalentes, pero la versión utilizada en
          este libro es la más intuitiva al leer el código, ya que dice,
          directamente, «Esto es un vector de punteros a
          carácter».
        </p><p>
          Todo lo que se obtiene de la línea de comandos son vectores de
          caracteres; si quiere tratar un argumento como algún otro
          tipo, ha de convertirlos dentro del programa. Para facilitar
          la conversión a números, hay algunas funciones en la librería
          de C Estándar, declaradas en <code class="filename">&lt;cstdlib&gt;</code>. Las más fáciles de
          utilizar son <code class="function">atoi()</code>,
          <code class="function">atol()</code>, y <code class="function">atof()</code>
          para convertir un vector de caracteres ASCII a
          <code class="type">int</code>, <code class="type">long</code> y <code class="type">double</code>,
          respectivamente. A continuación, un ejemplo utilizando
          <code class="function">atoi()</code> (las otras dos funciones se
          invocan del mismo modo):
        </p><div class="example"><a id="idp4962120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ArgsToInts.cpp</span>
<span class="hl slc">// Converting command-line arguments to ints</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> argc<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">atoi</span><span class="hl opt">(</span>argv<span class="hl opt">[</span>i<span class="hl opt">]) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.57. C03/ArgsToInts.cpp</strong></p></div><br class="example-break" /><p>
          En este programa, se puede poner cualquier número de
          argumentos en la línea de comandos. Fíjese que el bucle
          <code class="keyword">for</code> comienza en el valor <code class="literal">1</code> para
          saltar el nombre del programa en
          <code class="code">argv[0]</code>. También, si se pone un número decimal
          que contenga un punto decimal en la línea de comandos,
          <code class="function">atoi()</code> sólo toma los dígitos hasta el
          punto decimal. Si pone valores no numéricos en la línea de
          comandos, <code class="function">atoi()</code> los devuelve como ceros.
        </p></div><div class="sect3" title="El formato de punto flotante"><div class="titlepage"><div><div><h4 class="title"><a id="idp4966184"></a>El formato de punto flotante</h4></div></div></div><p>
          La función <code class="function">printBinary()</code> presentada
          anteriormente en este capítulo es útil para indagar en la
          estructura interna de varios tipos de datos. El más
          interesante es el formato de punto-flotante que permite a C y
          C++ almacenar números que representan valores muy grandes y
          muy pequeños en un espacio limitado. Aunque los detalles no se
          pueden exponer completamente expuestos, los bits dentro de los
          <code class="type">float</code>s y <code class="type">double</code>s están divididos en
          tres regiones: el exponente, la mantisa, y el bit de signo;
          así almacena los valores utilizando notación científica. El
          siguiente programa permite jugar con ello imprimiendo los
          patrones binarios de varios números en punto-flotante de modo
          que usted mismo pueda deducir el esquema del formato de punto
          flotante de su compilador (normalmente es el estándar IEEE
          para números en punto-flotante, pero su compilador puede no
          seguirlo):
        </p><div class="example"><a id="idp4968808"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:FloatingAsBinary.cpp</span>
<span class="hl slc">//{L} printBinary</span>
<span class="hl slc">//{T} 3.14159</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;printBinary.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">!=</span> <span class="hl num">2</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Must provide a number&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">double</span> d <span class="hl opt">=</span> <span class="hl kwd">atof</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> cp <span class="hl opt">=</span> 
    <span class="hl kwa">reinterpret_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">unsigned char</span><span class="hl opt">*&gt;(&amp;</span>d<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">)-</span><span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">;</span> i <span class="hl opt">-=</span> <span class="hl num">2</span><span class="hl opt">){</span>
    <span class="hl kwd">printBinary</span><span class="hl opt">(</span>cp<span class="hl opt">[</span>i<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">]);</span>
    <span class="hl kwd">printBinary</span><span class="hl opt">(</span>cp<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.58. C03/FloatingAsBinary.cpp</strong></p></div><br class="example-break" /><p>
          Primero, el programa garantiza que se le haya pasado un
          argumento comprobando el valor de <code class="varname">argc</code>, que
          vale dos si hay un solo argumento (es uno si no hay
          argumentos, ya que el nombre del programa siempre es el primer
          elemento de <code class="varname">argv</code>). Si eso falla, imprime un
          mensaje e invoca la función <code class="function">exit()</code> de la
          librería Estándar de C para finalizar el programa.
        </p><p>
          El programa toma el argumento de la línea de comandos y
          convierte los caracteres a <code class="type">double</code> utilizando
          <code class="function">atof()</code>. Luego el <code class="type">double</code> se
          trata como un vector de bytes tomando la dirección y
          moldeándola a un <code class="type">unsigned char*</code>. Para cada uno de
          estos bytes se llama a <code class="function">printBinary()</code> para
          mostrarlos.
        </p><p>
          Este ejemplo se ha creado para imprimir los bytes en un orden
          tal que el bit de signo aparece al principio - en mi
          máquina. En otras máquinas puede ser diferente, por lo que
          puede querer re-organizar el modo en que se imprimen los
          bytes. También debería tener cuidado porque los formatos en
          punto-flotante no son tan triviales de entender; por ejemplo,
          el exponente y la mantisa no se alinean generalmente entre los
          límites de los bytes, en su lugar un número de bits se reserva
          para cada uno y se empaquetan en la memoria tan apretados como
          se pueda. Para ver lo que esta pasando, necesitaría averiguar
          el tamaño de cada parte del número (los bit de signo siempre
          son de un bit, pero los exponentes y las mantisas pueden ser
          de diferentes tamaños) e imprimir separados los bits de cada
          parte.
        </p></div><div class="sect3" title="Aritmética de punteros"><div class="titlepage"><div><div><h4 class="title"><a id="idp4976112"></a>Aritmética de punteros</h4></div></div></div><p>
          Si todo lo que se pudiese hacer con un puntero que apunta a un
          vector fuese tratarlo como si fuera un alias para ese vector,
          los punteros a vectores no tendrían mucho interés. Sin
          embargo, los punteros son mucho más flexibles que eso, ya que
          se pueden modificar para apuntar a cualquier otro sitio (pero
          recuerde, el identificador del vector no se puede modificar
          para apuntar a cualquier otro sitio).
        </p><p>
          La <span class="emphasis"><em>aritmética de punteros</em></span> se refiere a la
          aplicación de alguno de los operadores aritméticos a los
          punteros. Las razón por la cual la aritmética de punteros es
          un tema separado de la aritmética ordinaria es que los
          punteros deben ajustarse a cláusulas especiales de modo que se
          comporten apropiadamente. Por ejemplo, un operador común para
          utilizar con punteros es ++, lo que "añade uno al puntero." Lo
          que de hecho significa esto es que el puntero se cambia para
          moverse al "siguiente valor," Lo que sea que ello
          signifique. A continuación, un ejemplo:
        </p><div class="example"><a id="idp4978776"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PointerIncrement.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwb">double</span> d<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> i<span class="hl opt">;</span>
  <span class="hl kwb">double</span><span class="hl opt">*</span> dp <span class="hl opt">=</span> d<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ip = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>ip <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  ip<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ip = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>ip <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;dp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>dp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  dp<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;dp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>dp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.59. C03/PointerIncrement.cpp</strong></p></div><br class="example-break" /><p>
          Para una ejecución en mi máquina, la salida es:
        </p><pre class="programlisting">
ip <span class="hl opt">=</span> <span class="hl num">6684124</span>
ip <span class="hl opt">=</span> <span class="hl num">6684128</span>
dp <span class="hl opt">=</span> <span class="hl num">6684044</span>
dp <span class="hl opt">=</span> <span class="hl num">6684052</span>
</pre><p>
          Lo interesante aquí es que aunque la operación <code class="literal">++</code>
          parece la misma tanto para el <code class="type">int*</code> como para el
          <code class="type">double*</code>, se puede comprobar que el puntero de
          <code class="type">int*</code> ha cambiado 4 bytes mientras que para el
          <code class="type">double*</code> ha cambiado 8. No es coincidencia, que
          estos sean los tamaños de <code class="type">int</code> y
          <code class="type">double</code> en esta máquina. Y ese es el truco de la
          aritmética de punteros: el compilador calcula la cantidad
          apropiada para cambiar el puntero de modo que apunte al
          siguiente elemento en el vector (la aritmética de punteros
          sólo tiene sentido dentro de los vectores). Esto funciona incluso
          con vectores de <code class="keyword">struct</code>s:
        </p><div class="example"><a id="idp4984048"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PointerIncrement2.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> <span class="hl opt">{</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">short</span> s<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">long</span> l<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
  <span class="hl kwb">long double</span> ld<span class="hl opt">;</span>
<span class="hl opt">}</span> Primitives<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Primitives p<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  Primitives<span class="hl opt">*</span> pp <span class="hl opt">=</span> p<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(Primitives) = &quot;</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Primitives<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;pp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>pp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  pp<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;pp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>pp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.60. C03/PointerIncrement2.cpp</strong></p></div><br class="example-break" /><p>
          La salida en esta máquina es:
        </p><pre class="programlisting">
<span class="hl kwa">sizeof</span><span class="hl opt">(</span>Primitives<span class="hl opt">) =</span> <span class="hl num">40</span>
pp <span class="hl opt">=</span> <span class="hl num">6683764</span>
pp <span class="hl opt">=</span> <span class="hl num">6683804</span>
</pre><p>
          Como puede ver, el compilador también hace lo adecuado para
          punteros a <code class="keyword">struct</code>s (y con <code class="keyword">class</code> y
          <code class="keyword">union</code>).
        </p><p>
          La aritmética de punteros también funciona con los operadores
          <code class="literal">--</code>, <code class="literal">+</code> y <code class="literal">-</code>, pero los dos
          últimos están limitados: no se puede sumar dos punteros, y si
          se restan punteros el resultado es el número de elementos
          entre los dos punteros. Sin embargo, se puede sumar o restar
          un valor entero y un puntero. A continuación, un ejemplo
          demostrando el uso de la aritmética de punteros:
        </p><div class="example"><a id="idp4990176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PointerArithmetic.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define P(EX) cout &lt;&lt; #EX &lt;&lt;</span> <span class="hl pps">&quot;: &quot;</span><span class="hl ppc"> &lt;&lt; EX &lt;&lt; endl;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i<span class="hl opt">;</span> <span class="hl slc">// Give it index values</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwd">P</span><span class="hl opt">(*</span>ip<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(*++</span>ip<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(*(</span>ip <span class="hl opt">+</span> <span class="hl num">5</span><span class="hl opt">));</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip2 <span class="hl opt">=</span> ip <span class="hl opt">+</span> <span class="hl num">5</span><span class="hl opt">;</span>
  <span class="hl kwd">P</span><span class="hl opt">(*</span>ip2<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(*(</span>ip2 <span class="hl opt">-</span> <span class="hl num">4</span><span class="hl opt">));</span>
  <span class="hl kwd">P</span><span class="hl opt">(*--</span>ip2<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(</span>ip2 <span class="hl opt">-</span> ip<span class="hl opt">);</span> <span class="hl slc">// Yields number of elements</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.61. C03/PointerArithmetic.cpp</strong></p></div><br class="example-break" /><p>
          Comienza con otra macro, pero esta utiliza una característica
          del preprocesador llamada
          <span class="foreignphrase"><em class="foreignphrase">stringizing</em></span> (implementada
          mediante el signo <span class="token">#</span> antes de una expresión) que
          toma cualquier expresión y la convierte a un vector de
          caracteres. Esto es bastante conveniente, ya que permite
          imprimir la expresión seguida de dos puntos y del valor de la
          expresión. En <code class="function">main()</code> puede ver lo útil
          que resulta este atajo.
        </p><p>
          Aunque tanto la versión prefijo como sufijo de <code class="literal">++</code>
          y <code class="literal">--</code> son válidas para los punteros, en este
          ejemplo sólo se utilizan las versiones prefijo porque se
          aplican antes de referenciar el puntero en las expresiones
          anteriores, de modo que permite ver los efectos en las
          operaciones. Observe que se han sumado y restado valores
          enteros; si se combinasen de este modo dos punteros, el
          compilador no lo permitiría.
        </p><p>
          Aquí se ve la salida del programa anterior:
        </p><pre class="programlisting">
<span class="hl opt">*</span>ip<span class="hl opt">:</span> <span class="hl num">0</span>
<span class="hl opt">*++</span>ip<span class="hl opt">:</span> <span class="hl num">1</span>
<span class="hl opt">*(</span>ip <span class="hl opt">+</span> <span class="hl num">5</span><span class="hl opt">):</span> <span class="hl num">6</span>
<span class="hl opt">*</span>ip2<span class="hl opt">:</span> <span class="hl num">6</span>
<span class="hl opt">*(</span>ip2 <span class="hl opt">-</span> <span class="hl num">4</span><span class="hl opt">):</span> <span class="hl num">2</span>
<span class="hl opt">*--</span>ip2<span class="hl opt">:</span> <span class="hl num">5</span>
</pre><p>
          En todos los casos, el resultado de la aritmética de punteros
          es que el puntero se ajusta para apuntar al «sitio
          correcto», basándose en el tamaño del tipo de los
          elementos a los que está apuntado.
        </p><p>
          Si la aritmética de punteros le sobrepasa un poco al
          principio, no tiene porqué preocuparse. La mayoría de las
          veces sólo la necesitará para crear vectores e indexarlos con
          <code class="literal">[]</code>, y normalmente la aritmética de punteros más
          sofisticada que necesitará es <code class="literal">++</code> y
          <code class="literal">--</code> . La aritmética de punteros generalmente está
          reservada para programas más complejos e ingeniosos, y
          muchos de los contenedores en la librería de Estándar C++
          esconden muchos de estos inteligentes detalles, por lo que no
          tiene que preocuparse de ellos.
        </p></div></div></div><div class="sect1" title="3.9. Consejos para depuración"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5000080"></a>3.9. Consejos para depuración</h2></div></div></div><p>
      En un entorno ideal, habrá un depurador excelente disponible que
      hará que el comportamiento de su programa sea transparente y podrá
      descubrir cualquier error rápidamente. Sin embargo, muchos
      depuradores tienen puntos débiles, y eso puede requerir tenga que
      añadir trozos de código a su programa que le ayuden a entender que
      está pasando. Además, puede que para la plataforma para la que esté
      desarrollando (por ejemplo en sistemas empotrados, con lo que yo
      tuve que tratar durante mis años de formación) no haya ningún
      depurador disponible, y quizá tenga una realimentación muy
      limitada (por ejemplo, un display de LEDs de una línea). En esos
      casos debe ser creativo a la hora de descubrir y representar
      información acerca de la ejecución de su programa. Esta sección
      sugiere algunas técnicas para conseguirlo.
    </p><div class="sect2" title="3.9.1. Banderas para depuración"><div class="titlepage"><div><div><h3 class="title"><a id="idp5002552"></a>3.9.1. Banderas para depuración</h3></div></div></div><p>
        Si coloca el código de depuración mezclado con un programa,
        tendrá problemas. Empezará a tener demasiada información, que
        hará que los errores sean difíciles de aislar. Cuando cree que
        ha encontrado el error empieza a quitar el código de depuración,
        sólo para darse cuenta que necesita ponerlo de nuevo.  Puede
        resolver estos problemas con dos tipos de banderas: banderas de
        depuración del preprocesador y banderas de depuración en
        ejecución.
      </p><div class="sect3" title="Banderas de depuración para el preprocesador"><div class="titlepage"><div><div><h4 class="title"><a id="idp5003776"></a>Banderas de depuración para el preprocesador</h4></div></div></div><p>
	  Usando el preprocesador para definir (con <code class="keyword">#define</code>) una o más banderas
	  de depuración (preferiblemente en un fichero de cabecera), puede probar una
	  bandera usando una sentencia <code class="keyword">#ifdef</code> e incluir condicionalmente código
	  de depuración. Cuando crea que la depuración ha terminado, simplemente utilice
	  <code class="keyword">#undef</code> la bandera y el código quedará eliminado automáticamente (y
	  reducirá el tamaño y sobrecarga del fichero ejecutable).
	</p><p>
	  Es mejor decidir los nombres de las banderas de depuración
	  antes de empezar a contruir el proyecto para que los nombres
	  sean consistentes. Las banderas del preprocesador
	  tradicionalmente se distinguen de las variables porque se
	  escriben todo en mayúsculas. Un nombre habitual es simplemente
	  <code class="constant">DEBUG</code> (pero tenga cuidado de no usar
	  <code class="constant">NDEBUG</code>, que está reservado en C). La
	  secuencia de sentencias podrías ser:
	</p><pre class="programlisting">
<span class="hl ppc">#define DEBUG</span> <span class="hl slc">// Probably in a header file</span>
<span class="hl ppc"></span><span class="hl slc">//...</span>
<span class="hl ppc">#ifdef DEBUG</span> <span class="hl slc">// Check to see if flag is defined</span>
<span class="hl ppc"></span><span class="hl com">/* debugging code here */</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DEBUG</span><span class="hl ppc"></span>
</pre><p>
	  La mayoría de las implementaciones de C y C++ también le
	  permitirán definir y eliminar banderas (con <code class="keyword">#define</code> y
	  <code class="keyword">#undef</code>) desde línea de comandos, y de ese modo puede
	  recompilar código e insertar información de depuración con un
	  único comando (preferiblemente con un
	  <code class="filename">makefile</code>, una herramienta que será
	  descrita en breve). Compruebe la documentación de su entorno si
	  necesita más detalles.
	</p></div><div class="sect3" title="Banderas para depuración en tiempo de ejecución"><div class="titlepage"><div><div><h4 class="title"><a id="idp5010672"></a>Banderas para depuración en tiempo de ejecución</h4></div></div></div><p>
	  En algunas situaciones es más conveniente activar y desactivar
	  las banderas de depuración durante la ejecución del programa,
	  especialmente cuando el programa se ejecuta usando la línea de
	  comandos. Con programas grandes resulta pesado recompilar sólo
	  para insertar código de depuración.
	</p><p>
	  Para activar y desactivar código de depuración dinámicamente
	  cree banderas booleanas.
	</p><div class="example"><a id="idp5012312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:DynamicDebugFlags.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl slc">// Debug flags aren't necessarily global:</span>
<span class="hl kwb">bool</span> debug <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> argc<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">string</span><span class="hl opt">(</span>argv<span class="hl opt">[</span>i<span class="hl opt">]) ==</span> <span class="hl str">&quot;--debug=on&quot;</span><span class="hl opt">)</span>
      debug <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl kwb">bool</span> go <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>go<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>debug<span class="hl opt">) {</span>
      <span class="hl slc">// Debugging code here</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Debugger is now on!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Debugger is now off.&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>  
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Turn debugger [on/off/quit]: &quot;</span><span class="hl opt">;</span>
    string reply<span class="hl opt">;</span>
    cin <span class="hl opt">&gt;&gt;</span> reply<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>reply <span class="hl opt">==</span> <span class="hl str">&quot;on&quot;</span><span class="hl opt">)</span> debug <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span> <span class="hl slc">// Turn it on</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>reply <span class="hl opt">==</span> <span class="hl str">&quot;off&quot;</span><span class="hl opt">)</span> debug <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span> <span class="hl slc">// Off</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>reply <span class="hl opt">==</span> <span class="hl str">&quot;quit&quot;</span><span class="hl opt">)</span> <span class="hl kwa">break</span><span class="hl opt">;</span> <span class="hl slc">// Out of 'while'</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.62. C03/DynamicDebugFlags.cpp</strong></p></div><br class="example-break" /><p>
	  Este programa sigue permitiéndole activar y desactivar la bandera de depuración
	  hasta que escriba <strong class="userinput"><code>quit</code></strong> para indicarle que quiere
	  salir. Fíjese que es necesario escribir palabras completas, no solo letras
	  (puede abreviarlo a letras si lo desea). Opcionalmente, también se puede usar un
	  argumento en línea de comandos para comenzar la depuración - este argumento
	  puede aparecer en cualquier parte de la línea de comando, ya que el código de
	  activación en <code class="function">main()</code> busca en todos los argumentos. La
	  comprobación es bastante simple como se ve en la expresión:
	</p><pre class="programlisting">
<span class="hl kwd">string</span><span class="hl opt">(</span>argv<span class="hl opt">[</span>i<span class="hl opt">])</span>
</pre><p>
	  Esto toma la cadena <code class="varname">argv[i]</code> y crea un
	  <code class="classname">string</code>, el cual se puede comparar
	  fácilmente con lo que haya a la derecha de <code class="literal">==</code>. El
	  programa anterior busca la cadena completa
	  <code class="literal">--debug=on</code>. También puede buscar
	  <code class="literal">--debug=</code> y entonces ver que hay después,
	  para proporcionar más opciones. El Volumen 2 (disponible en
	  <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>)
	  contiene un capítulo dedicado a la clase
	  <code class="classname">string</code> Estándar de C++.
	</p><p>
	  Aunque una bandera de depuración es uno de los relativamente
	  pocos casos en los que tiene mucho sentido usar una variable
	  global, no hay nada que diga que debe ser así. Fíjese en que
	  la variable está escrita en minúsculas para recordar al lector
	  que no es una bandera del preprocesador.
	</p></div></div><div class="sect2" title="3.9.2. Convertir variables y expresiones en cadenas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5020272"></a>3.9.2. Convertir variables y expresiones en cadenas</h3></div></div></div><p>
	Cuando se escribe código de depuración, resulta pesado escribir
	expresiones print que consisten en una cadena que contiene el
	nombre de una variable, seguido de el valor de la
	variable. Afortunadamente, el C estándar incluye el operador de
	FIXME <span class="emphasis"><em>cadenización</em></span> <span class="token">#</span>, que ya
	se usó antes en este mismo capítulo. Cuando se coloca un # antes
	de una argumentos en una macro, el preprocesador convierte ese
	argumentos en una cadena. Esto, combinado con el hecho de que
	las cadenas no indexadas colocadas una a continuación de la otra
	se concatenan, permite crear macros muy adecuadas para imprimir
	los valores de las variables durante la depuración:
      </p><pre class="programlisting">
<span class="hl ppc">#define PR(x) cout &lt;&lt; #x</span> <span class="hl pps">&quot; = &quot;</span><span class="hl ppc"> &lt;&lt; x &lt;&lt;</span> <span class="hl pps">&quot;</span><span class="hl esc">\n</span><span class="hl pps">&quot;</span><span class="hl ppc">;</span>
</pre><p>
	Si se imprime la variable <code class="varname">a</code> invocando
	<code class="code">PR(a)</code>, tendrá el mismo efecto que este código:
      </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
</pre><p>
	Este mismo proceso funciona con expresiones completas. El
	siguiente programa usa una macro para crear un atajo que imprime
	la expresión cadenizadas y después evalúa la expresión e imprime
	el resultado:
      </p><div class="example"><a id="idp5024664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StringizingExpressions.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define P(A) cout &lt;&lt; #A &lt;&lt;</span> <span class="hl pps">&quot;: &quot;</span><span class="hl ppc"> &lt;&lt; (A) &lt;&lt; endl;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">,</span> b <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">,</span> c <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl kwd">P</span><span class="hl opt">(</span>a<span class="hl opt">);</span> <span class="hl kwd">P</span><span class="hl opt">(</span>b<span class="hl opt">);</span> <span class="hl kwd">P</span><span class="hl opt">(</span>c<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(</span>a <span class="hl opt">+</span> b<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">((</span>c <span class="hl opt">-</span> a<span class="hl opt">)/</span>b<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.63. C03/StringizingExpressions.cpp</strong></p></div><br class="example-break" /><p>
	Puede comprobar cómo una técnica como esta se puede convertir
	rápidamente en algo indispensable, especialmente si no tiene
	depurador (o debe usar múltiples entornos de
	desarrollo). También puede insertar un <code class="keyword">#ifdef</code> para
	conseguir que <code class="code">P(A)</code> se defina como
	«nada» cuando quiera eliminar el código de
	depuración.
      </p></div><div class="sect2" title="3.9.3. La macro C assert()"><div class="titlepage"><div><div><h3 class="title"><a id="idp5027416"></a>3.9.3. La macro C assert()</h3></div></div></div><p>
	En el fichero de cabecera estándar
	<code class="filename">&lt;cassert&gt;</code> aparece
	<code class="function">assert()</code>, que es una macro de
	depuración. Cuando se utiliza <code class="function">assert()</code>, se
	le debe dar un argumento que es una expresión que usted está
	«aseverando». El preprocesador genera código que
	comprueba la aserción. Si la aserción no es cierta, el programa
	parará después de imprimir un mensaje de error informando que la
	aserción falló. Este es un ejemplo trivial:
      </p><div class="example"><a id="idp5029880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Assert.cpp</span>
<span class="hl slc">// Use of the assert() debugging macro</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>  <span class="hl slc">// Contains the macro</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>i <span class="hl opt">!=</span> <span class="hl num">100</span><span class="hl opt">);</span> <span class="hl slc">// Fails</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.64. C03/Assert.cpp</strong></p></div><br class="example-break" /><p>
	La macro original es C Estándar, así que está disponible también
	en el fichero de cabecera <code class="filename">assert.h</code>.
      </p><p>
	Cuando haya terminado la depuración, puede eliminar el código
	generado por la macro escribiendo la siguiente línea:
      </p><pre class="programlisting">
<span class="hl ppc">#define NDEBUG</span>
</pre><p>
	en el programa, antes de la inclusión de
	<code class="filename">&lt;cassert&gt;</code>, o definiendo
	<code class="constant">NDEBUG</code> en la línea de comandos del
	compilador. <code class="constant">NDEBUG</code> es una bandera que se
	usa en <code class="filename">&lt;cassert&gt;</code> para cambiar el código
	generado por las macros.
      </p><p>
	Más adelante en este libro, verá algunas alternativas más
	sofisticadas a <code class="function">assert()</code>.
      </p></div></div><div class="sect1" title="3.10. Direcciones de función"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="C03-punteros-a-funcion"></a>3.10. Direcciones de función</h2></div></div></div><p>
      Una vez que una función es compilada y cargada en la computadora
      para ser ejecutada, ocupa un trozo de memoria. Esta memoria, y por
      tanto esa función, tiene una dirección.
    </p><p>
      C nunca ha sido un lenguaje [FIXME] donde otros temen pisar. Puede
      usar direcciones de función con punteros igual que puede usar
      direcciones variables. La declaración y uso de punteros a
      función parece un poco opaca al principio, pero sigue el formato
      del resto del lenguaje.
    </p><div class="sect2" title="3.10.1. Definición de un puntero a función"><div class="titlepage"><div><div><h3 class="title"><a id="idp5037080"></a>3.10.1. Definición de un puntero a función</h3></div></div></div><p>
	Para definir un puntero a una función que no tiene argumentos y
	no retorna nada, se dice:
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl opt">(*</span>funcPtr<span class="hl opt">)();</span>
</pre><p>
	Cuando se observa una definición compleja como esta, el mejor
	método para entenderla es empezar en el medio e ir hacia
	afuera. «Empezar en el medio» significa empezar con
	el nombre de la variable, que es
	<code class="varname">funPtr</code>. «Ir hacia afuera»
	significa mirar al elemento inmediatamente a la derecha (nada en
	este caso; el paréntesis derecho marca el fin de ese elemento),
	después mire a la izquierda (un puntero denotado por el
	asterisco), después mirar de nuevo a la derecha (una lista de
	argumentos vacía que indica que no función no toma argumentos),
	después a la izquierda (<code class="type">void</code>, que indica que la función no
	retorna nada). Este movimiento derecha-izquierda-derecha
	funciona con la mayoría de las declaraciones.
	<sup>[<a id="idp5040464" href="#ftn.idp5040464" class="footnote">44</a>]</sup>
      </p><p>
	Para repasar, «empezar en el medio»
	(«<code class="varname">funcPtr</code> es un ...», va a la
	derecha (nada aquí - pare en el paréntesis derecho), va a la
	izquierda y encuentra el <span class="token">*</span> («... puntero a
	...»), va a la derecha y encuentra la lista de argumentos
	vacía («... función que no tiene argumentos ...»)
	va a la izquierda y encuentra el <code class="type">void</code>
	(«<code class="varname">funcPtr</code> es un puntero a una función
	que no tiene argumentos y retorna <code class="type">void</code>»).
      </p><p>
	Quizá se pregunte porqué <code class="code">*funcPtr</code> necesita
	paréntesis. Si no los usara, el compilador podría ver:
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl opt">*</span><span class="hl kwd">funcPtr</span><span class="hl opt">();</span>
</pre><p>
	Lo que corresponde a la declaración de una función (que retorna
	un <code class="type">void*</code>) en lugar de definir una variable. Se
	podría pensar que el compilador sería capaz distinguir una
	declaración de una definición por lo que se supone que es. El
	compilador necesita los paréntesis para «tener contra qué
	chocar» cuando vaya hacia la izquierda y encuentre el
	<span class="token">*</span>, en lugar de continuar hacia la derecha y
	encontrar la lista de argumentos vacía.
      </p></div><div class="sect2" title="3.10.2. Declaraciones y definiciones complicadas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5046296"></a>3.10.2. Declaraciones y definiciones complicadas</h3></div></div></div><p>
	Al margen, una vez que entienda cómo funciona la sintáxis de
	declaración de C y C++ podrá crear elementos más
	complicados. Por ejemplo:
      </p><pre class="programlisting">
<span class="hl slc">//: V1C03:ComplicatedDefinitions.cpp</span>

<span class="hl com">/* 1. */</span>     <span class="hl kwb">void</span> <span class="hl opt">* (*(*</span>fp1<span class="hl opt">)(</span><span class="hl kwb">int</span><span class="hl opt">))[</span><span class="hl num">10</span><span class="hl opt">];</span>

<span class="hl com">/* 2. */</span>     <span class="hl kwb">float</span> <span class="hl opt">(*(*</span>fp2<span class="hl opt">)(</span><span class="hl kwb">int</span><span class="hl opt">,</span><span class="hl kwb">int</span><span class="hl opt">,</span><span class="hl kwb">float</span><span class="hl opt">))(</span><span class="hl kwb">int</span><span class="hl opt">);</span>

<span class="hl com">/* 3. */</span>     <span class="hl kwc">typedef</span> <span class="hl kwb">double</span> <span class="hl opt">(*(*(*</span>fp3<span class="hl opt">)())[</span><span class="hl num">10</span><span class="hl opt">])();</span>
             fp3 a<span class="hl opt">;</span>

<span class="hl com">/* 4. */</span>     <span class="hl kwb">int</span> <span class="hl opt">(*(*</span><span class="hl kwd">f4</span><span class="hl opt">())[</span><span class="hl num">10</span><span class="hl opt">])();</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span>
</pre><p>
	Estudie cada uno y use la regla derecha-izquierda para
	entenderlos. El número 1 dice «<code class="varname">fp1</code> es
	un puntero a una función que toma un entero como argumento y
	retorna un puntero a un array de 10 punteros
	<code class="type">void</code>».
      </p><p>
	El 2 dice «<code class="varname">fp2</code> es un puntero a función
	  que toma tres argumentos (<code class="type">int</code>, <code class="type">int</code> y
	  <code class="type">float</code>) de retorna un puntero a una función que
	  toma un entero como argumento y retorna un
	  <code class="type">float</code>»
      </p><p>
	Si necesita crear muchas definiciones complicadas, debería usar
	<code class="keyword">typedef</code>. El número 3 muestra cómo un <code class="keyword">typedef</code>
	ahorra tener que escribir una descripción complicada cada
	vez. Dice «Un <code class="type">fp3</code> es un puntero a una función
	que no tiene argumentos y que retorna un puntero a un array de
	10 punteros a funciones que no tienen argumentos y retornan
	<code class="type">doubles</code>». Después dice
	«<code class="varname">a</code> es una variable de ese tipo
	<code class="type">fp3</code>». <code class="keyword">typedef</code> es útil para
	construir descripciones complicadas a partir de otras simples.
      </p><p>
	El 4 es una declaración de función en lugar de una definición de
	variable. Dice «<code class="function">f4</code> es una función que
	retorna un puntero a un array de 10 punteros a funciones que
	retornan enteros».
      </p><p>
	Es poco habitual necesitar declaraciones y definiciones tan
	complicadas como éstas. Sin embargo, si se propone entenderlas,
	no le desconcertarán otras algo menos complicadas pero que si
	encontrará en la vida real.
      </p></div><div class="sect2" title="3.10.3. Uso de un puntero a función"><div class="titlepage"><div><div><h3 class="title"><a id="idp5055488"></a>3.10.3. Uso de un puntero a función</h3></div></div></div><p>
	Una vez que se ha definido un puntero a función, debe asignarle
	la dirección de una función antes de poder usarlo. Del mismo
	modo que la dirección de un array <code class="varname">arr[10]</code> se
	obtiene con el nombre del array sin corchetes
	(<code class="varname">arr</code>), la dirección de una función
	<code class="function">func()</code> se obtiene con el nombre de la
	función sin lista de argumentos
	(<code class="function">func</code>). También puede usar una sintáxis más
	explícita: <code class="code">&amp;func()</code>. Para invocar la función,
	debe dereferenciar el puntero de la misma forma que lo ha
	declarado (recuerde que C y C++ siempre intentan hacer que las
	definiciones se parezcan al modo en que se usan). El siguiente
	ejemplo muestra cómo se define y usa un puntero a función:
	</p><div class="example"><a id="idp5058584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:PointerToFunction.cpp</span>
<span class="hl slc">// Defining and using a pointer to a function</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;func() called...&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">void</span> <span class="hl opt">(*</span>fp<span class="hl opt">)();</span>  <span class="hl slc">// Define a function pointer</span>
  fp <span class="hl opt">=</span> func<span class="hl opt">;</span>  <span class="hl slc">// Initialize it</span>
  <span class="hl opt">(*</span>fp<span class="hl opt">)();</span>    <span class="hl slc">// Dereferencing calls the function</span>
  <span class="hl kwb">void</span> <span class="hl opt">(*</span>fp2<span class="hl opt">)() =</span> func<span class="hl opt">;</span>  <span class="hl slc">// Define and initialize</span>
  <span class="hl opt">(*</span>fp2<span class="hl opt">)();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.65. C03/PointerToFunction.cpp</strong></p></div><br class="example-break" /><p>
	Una vez definido el puntero a función <code class="varname">fp</code>, se
	le asigna la dirección de una función
	<code class="function">func()</code> usando <code class="code">fp = func</code>
	(fíjese que la lista de argumentos no aparece junto al nombre de
	la función). El segundo caso muestra una definición e
	inicialización simultánea.
      </p></div><div class="sect2" title="3.10.4. Arrays de punteros a funciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp5061736"></a>3.10.4. Arrays de punteros a funciones</h3></div></div></div><p>
	Una de las construcciones más interesantes que puede crear es
	un array de punteros a funciones. Para elegir una función,
	sólo indexe el array y dereferencie el puntero. Esto permite
	implementar el concepto de <span class="emphasis"><em>código dirigido por
	tabla</em></span>(<span class="foreignphrase"><em class="foreignphrase">table-driven
	code</em></span>); en lugar de usar estructuras
	condicionales o sentencias case, se elige la función a
	ejecutar en base a una variable (o una combinación de
	variables). Este tipo de diseño puede ser útil si añade y
	elimina funciones de la tabla con frecuencia (o si quiere
	crear o cambiar una tabla dinámicamente).
      </p><p>
	El siguiente ejemplo crea algunas funciones falsas usando una
	macro de preprocesador, después crea un array de punteros a esas
	funciones usando inicialización automática. Como puede ver, es
	fácil añadir y eliminar funciones de la table (y por tanto, la
	funcionalidad del programa) cambiando una pequeña porción de
	código.
      </p><div class="example"><a id="idp5064704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:FunctionTable.cpp</span>
<span class="hl slc">// Using an array of pointers to functions</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A macro to define dummy functions:</span>
<span class="hl ppc">#define DF(N) void N() { \</span>
<span class="hl ppc">   cout &lt;&lt;</span> <span class="hl pps">&quot;function &quot;</span><span class="hl ppc"> #N</span> <span class="hl pps">&quot; called...&quot;</span><span class="hl ppc"> &lt;&lt; endl; }</span>

<span class="hl kwd">DF</span><span class="hl opt">(</span>a<span class="hl opt">);</span> <span class="hl kwd">DF</span><span class="hl opt">(</span>b<span class="hl opt">);</span> <span class="hl kwd">DF</span><span class="hl opt">(</span>c<span class="hl opt">);</span> <span class="hl kwd">DF</span><span class="hl opt">(</span>d<span class="hl opt">);</span> <span class="hl kwd">DF</span><span class="hl opt">(</span>e<span class="hl opt">);</span> <span class="hl kwd">DF</span><span class="hl opt">(</span>f<span class="hl opt">);</span> <span class="hl kwd">DF</span><span class="hl opt">(</span>g<span class="hl opt">);</span>

<span class="hl kwb">void</span> <span class="hl opt">(*</span>func_table<span class="hl opt">[])() = {</span> a<span class="hl opt">,</span> b<span class="hl opt">,</span> c<span class="hl opt">,</span> d<span class="hl opt">,</span> e<span class="hl opt">,</span> f<span class="hl opt">,</span> g <span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;press a key from 'a' to 'g' &quot;</span>
      <span class="hl str">&quot;or q to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwb">char</span> c<span class="hl opt">,</span> cr<span class="hl opt">;</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">(</span>c<span class="hl opt">);</span> cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">(</span>cr<span class="hl opt">);</span> <span class="hl slc">// second one for CR</span>
    <span class="hl kwa">if</span> <span class="hl opt">(</span> c <span class="hl opt">==</span> <span class="hl str">'q'</span> <span class="hl opt">)</span> 
      <span class="hl kwa">break</span><span class="hl opt">;</span> <span class="hl slc">// ... out of while(1)</span>
    <span class="hl kwa">if</span> <span class="hl opt">(</span> c <span class="hl opt">&lt;</span> <span class="hl str">'a'</span> <span class="hl opt">||</span> c <span class="hl opt">&gt;</span> <span class="hl str">'g'</span> <span class="hl opt">)</span> 
      <span class="hl kwa">continue</span><span class="hl opt">;</span>
    <span class="hl opt">(*</span>func_table<span class="hl opt">[</span>c <span class="hl opt">-</span> <span class="hl str">'a'</span><span class="hl opt">])();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.66. C03/FunctionTable.cpp</strong></p></div><br class="example-break" /><p>
	A partir de este punto, debería ser capaz de imaginar cómo esta
	técnica podría resultarle útil cuando tenga que crear algún tipo
	de intérprete o programa para procesar listas.
      </p></div></div><div class="sect1" title="3.11. Make: cómo hacer compilación separada"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5067648"></a>3.11. Make: cómo hacer compilación separada</h2></div></div></div><p>
      Cuando se usa <span class="emphasis"><em>compilación separada</em></span>
      (dividiendo el código en varias unidades de traducción), aparece
      la <span class="emphasis"><em>necesidad</em></span> de un medio para compilar
      automáticamente cada fichero y decirle al enlazador como montar
      todas las piezas - con las librerías apropiadas y el código de
      inicio - en un fichero ejecutable. La mayoría de los compiladores
      le permiten hacerlo desde una sólo instrucción desde línea de
      comandos. Por ejemplo, para el compilador de C++ de <acronym class="acronym">GNU</acronym> se puede hacer:
    </p><pre class="screen">
$ g++ SourceFile1.cpp SourceFile2.cpp
</pre><p>
      En problema con este método es que el compilador compilará cada
      fichero individual tanto si el fichero
      <span class="emphasis"><em>necesita</em></span> ser recompilado como sino. Cuando un
      proyecto tiene muchos ficheros, puede resultar prohibitivo
      recompilar todo cada vez que se cambia una línea en un fichero.
    </p><p>
      La solución a este problema, desarrollada en Unix pero disponible
      de alún modo en todos los sistemas es un programa llamado
      <span class="command"><strong>make</strong></span>. La utilidad <span class="command"><strong>make</strong></span>
      maneja todos los ficheros individuales de un proyecto siguiendo
      las instrucciones escritas en un fichero de texto llamado
      <code class="filename">makefile</code>. Cuando edite alguno de los ficheros
      del proyecto y ejecute <span class="command"><strong>make</strong></span>, el programa
      <span class="command"><strong>make</strong></span> seguirá las directrices del
      <code class="filename">makefile</code> para comparar las fechas de los
      ficheros fuente con las de los ficheros resultantes
      correspondientes, y si una fichero fuente es más reciente que su
      fichero resultante, <span class="command"><strong>make</strong></span> recompila ese fichero
      fuente. <span class="command"><strong>make</strong></span> sólo recompila los ficheros fuente
      que han cambiado, y cualquier otro fichero que esté afectado por
      el fichero modificado. Usando <span class="command"><strong>make</strong></span> no tendrá
      que recompilar todos los ficheros de su proyecto cada vez que haga
      un cambio, ni tendrá que comprobar si todo se construye
      adecuadamente. El <code class="filename">makefile</code> contiene todas las
      instrucciones para montar el proyecto. Aprender a usar
      <span class="command"><strong>make</strong></span> le permitirá ahorrar mucho tiempo y
      frustraciones. También descubrirá que <span class="command"><strong>make</strong></span> es
      el método típico para instalar software nuevo en máquinas GNU o
      Unix<sup>[<a id="idp5077112" href="#ftn.idp5077112" class="footnote">45</a>]</sup>
      (aunque esos <code class="filename">makefiles</code> tienen a ser mucho más
      complicados que los que aparecen en este libro, y a menudo podrá
      generar automáticamente un <code class="filename">makefile</code> para su
      máquina particular como parte del proceso de instalación).
    </p><p>
      Como <span class="command"><strong>make</strong></span> está disponible de algún modo para
      prácticamente todos los compiladores de C++ (incluso si no lo
      está, puede usar <span class="command"><strong>makes</strong></span> libres con cualquier
      compilador), será la herramienta usada en este libro. Sin embargo,
      los fabricantes de compiladores crean también sus propias
      herramientas para construir proyectos. Estás herramientas
      preguntan qué ficheros hay en el proyecto y determinan las
      relaciones entre ellos. Estas herramientas utilizan algo similar a
      un <code class="filename">makefile</code>, normalmente llamado
      <span class="emphasis"><em>fichero de proyecto</em></span>, pero el entorno de
      programación mantiene este fichero para que el programador no
      tenga que preocuparse de él. La configuración y uso de los
      ficheros de proyecto varía de un entorno de desarrollo a otro, de
      modo que tendrá que buscar la documentación apropiada en cada caso
      (aunque esas herramientas proporcionadas por el fabricante
      normalmente son tan simples de usar que es fácil aprender a
      usarlas jugando un poco con ellas - mi método educativo favorito).
    </p><p>
      Los <code class="filename">makefiles</code> que acompañan a este libro
      deberían funcionar bien incluso si también usa una herramienta
      específica para construcción de proyectos.
    </p><div class="sect2" title="3.11.1. Las actividades de Make"><div class="titlepage"><div><div><h3 class="title"><a id="idp5083024"></a>3.11.1. Las actividades de Make</h3></div></div></div><p>
	Cuando escribe <span class="command"><strong>make</strong></span> (o cualquiera que sea el
	nombre del su programa <span class="command"><strong>make</strong></span>),
	<span class="command"><strong>make</strong></span> busca un fichero llamado
	<code class="filename">makefile</code> o <code class="filename">Makefile</code> en
	el directorio actual, que usted habrá creado para su
	proyecto. Este fichero contiene una lista de dependencias entre
	ficheros fuente, <span class="command"><strong>make</strong></span> comprueba las fechas de
	los ficheros. Si un fichero tiene una fecha más antigua que el
	fichero del que depende, <span class="command"><strong>make</strong></span> ejecuta la
	<span class="emphasis"><em>regla</em></span> indicada después de la dependencia.
      </p><p>
	Todos los comentarios de los <code class="filename">makefiles</code>
	empiezan con un <span class="token">#</span> y continúan hasta el fina
	de la línea.
      </p><p>
	Como un ejemplo sencillo, el <code class="filename">makefile</code> para
	una programa llamado «hello» podría contener:
      </p><pre class="programlisting">
<span class="hl ppc"># A comment</span>
hello<span class="hl opt">.</span>exe<span class="hl opt">:</span> hello<span class="hl opt">.</span>cpp
        mycompiler hello<span class="hl opt">.</span>cpp
</pre><p>
	Esto dice que <code class="filename">hello.exe</code> (el objetivo)
	depende de <code class="filename">hello.cpp</code>. Cuando
	<code class="filename">hello.cpp</code> tiene una fecha más reciente que
	<code class="filename">hello.exe</code>, <span class="command"><strong>make</strong></span> ejecuta
	la «regla» <span class="command"><strong>mycompiler
	hello.cpp</strong></span>. Puede haber múltiples dependencias y
	múltiples reglas. Muchas implementaciones de
	<span class="command"><strong>make</strong></span> requieren que todas las reglas empiecen
	con un tabulador. Para lo demás, por norma general los espacios
	en blanco se ignoran de modo que se pueden usar a efectos de
	legibilidad.
      </p><p>
	Las reglas no están restringidas a llamadas al compilador; puede
	llamar a cualquier programa que quiera. Creando grupos de reglas
	de dependencia, puede modificar sus ficheros fuentes, escribir
	<code class="filename">make</code> y estar seguro de que todos los
	fichero afectados serán re-construidos correctamente.
      </p><div class="sect3" title="Macros"><div class="titlepage"><div><div><h4 class="title"><a id="idp5093128"></a>Macros</h4></div></div></div><p>
	  Un <code class="filename">makefile</code> puede contener
	  <span class="emphasis"><em>macros</em></span> (tenga en cuenta que estas macros
	  no tienen nada que ver con las del preprocesador de C/C++). La
	  macros permiten reemplazar cadenas de texto. Los
	  <code class="filename">makefiles</code> del libro usan una macro para
	  invocar el compilador de C++. Por ejemplo,
	</p><pre class="programlisting">
CPP <span class="hl opt">=</span> mycompiler
hello<span class="hl opt">.</span>exe<span class="hl opt">:</span> hello<span class="hl opt">.</span>cpp
        $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> hello<span class="hl opt">.</span>cpp
</pre><p>
	  El <span class="token">=</span> se usa para indicar que
	  <code class="function">CPP</code> es una macro, y el
	  <span class="token">$</span> y los paréntesis expanden la macro. En
	  este caso, la expansión significa que la llamada a la macro
	  <code class="varname">$(CPP)</code> será reemplazada con la cadena
	  <code class="literal">mycompiler</code>. Con esta macro, si quiere
	  utilizar un compilador diferente llamado
	  <span class="command"><strong>cpp</strong></span>, sólo tiene que cambiar la macro a:
	</p><pre class="programlisting">
CPP <span class="hl opt">=</span> cpp
</pre><p>
	  También puede añadir a la macro opciones del compilador, etc.,
	  o usar otras macros para añadir dichas opciones.
	</p></div><div class="sect3" title="Reglas de sufijo"><div class="titlepage"><div><div><h4 class="title"><a id="idp5098320"></a>Reglas de sufijo</h4></div></div></div><p>
	  Es algo tedioso tener que decir a <span class="command"><strong>make</strong></span> que
	  invoque al compilador para cada fichero
	  <code class="filename">cpp</code> del proyecto, cuando se sabe que
	  básicamente siempre es el mismo proceso. Como
	  <span class="command"><strong>make</strong></span> está diseñado para ahorrar tiempo,
	  también tiene un modo de abreviar acciones, siempre que
	  dependan del sufijo de los ficheros. Estas abreviaturas se
	  llaman <span class="emphasis"><em>reglas de sufijo</em></span>. Una regla de
	  sufijo es la la forma de indicar a <span class="command"><strong>make</strong></span>
	  cómo convertir un fichero con cierta extensión
	  (<code class="filename">.cpp</code> por ejemplo) en un fichero con otra
	  extensión (<code class="filename">.obj</code> o
	  <code class="filename">.exe</code>). Una vez que le haya indicado a
	  <span class="command"><strong>make</strong></span> las reglas para producir un tipo de
	  fichero a partir de otro, lo único que tiene que hacer es
	  decirle a <span class="command"><strong>make</strong></span> cuales son las dependencias
	  respecto a otros ficheros. Cuando <span class="command"><strong>make</strong></span>
	  encuentra un fichero con una fecha previa a otro fichero del
	  que depende, usa la regla para crear la versión actualizada
	  del fichero objetivo.
	</p><p>
	  La regla de sufijo le dice a <span class="command"><strong>make</strong></span> que no se
	  necesitan reglas explícitas para construir cada cosa, en su
	  lugar le explica cómo construir cosas en base a la extensión
	  del fichero. En este caso dice «Para contruir un fichero
	  con extensión <code class="filename">.exe</code> a partir de uno con
	  extensión <code class="filename">.cpp</code>, invocar el siguiente
	  comando». Así sería para ese ejemplo:
	</p><pre class="programlisting">
CPP <span class="hl opt">=</span> mycompiler
<span class="hl opt">.</span>SUFFIXES<span class="hl opt">: .</span>exe <span class="hl opt">.</span>cpp
<span class="hl opt">.</span>cpp<span class="hl opt">.</span>exe<span class="hl opt">:</span>
        $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">&lt;</span>
</pre><p>
	  La directiva <code class="varname">.SUFFIXES</code> le dice a
	  <span class="command"><strong>make</strong></span> que debe vigilar las extensiones que
	  se indican porque tiene un significado especial para este
	  <code class="filename">makefile</code> en particular. Lo siguiente que
	  aparece es la regla de sufijo <code class="literal">.cpp.exe</code>, que
	  dice «cómo convertir cualquier fichero con extensión
	  <code class="filename">.cpp</code> a uno con extensión
	  <code class="filename">.exe</code>» (cuando el fichero
	  <code class="filename">.cpp</code> es más reciente que el fichero
	  .<code class="filename">.exe</code>). Como antes, se usa la macro
	  <code class="varname">$(CPP)</code>, pero aquí aparece algo nuevo:
	  <code class="varname">$&lt;</code>. Como empieza con un
	  <span class="token">$</span> es que es una macro, pero esta es una
	  de las macros especiales predefinidas por
	  <span class="command"><strong>make</strong></span>. El <code class="varname">$&lt;</code> se puede
	  usar sólo en reglas de sufijo y significa «cualquier
	  prerrequisito que dispare la regla» (a veces llamado
	  <span class="emphasis"><em>dependencia</em></span>), que en este caso se refiere
	  al «fichero <code class="filename">.cpp</code> que necesita ser
	  compilado».
	</p><p>
	  Una ver que las reglas de sufijo se han fijado, puede indicar
	  por ejemplo algo tan simple como <span class="command"><strong>make
	  Union.exe</strong></span> y se aplicará la regla sufijo, incluso
	  aunque no se mencione «Union» en ninguna parte
	  del <code class="filename">makefile</code>.
	</p></div><div class="sect3" title="Objetivos predeterminados"><div class="titlepage"><div><div><h4 class="title"><a id="idp5113264"></a>Objetivos predeterminados</h4></div></div></div><p>
	  Después de las macros y las reglas de sufijo,
	  <span class="command"><strong>make</strong></span> busca la primero «regla»
	  del fichero, y la ejecuta, a menos que se especifica una regla
	  diferente. Así que pare el siguiente
	  <code class="filename">makefile</code>:
	</p><pre class="programlisting">
CPP <span class="hl opt">=</span> mycompiler
<span class="hl opt">.</span>SUFFIXES<span class="hl opt">: .</span>exe <span class="hl opt">.</span>cpp
<span class="hl opt">.</span>cpp<span class="hl opt">.</span>exe<span class="hl opt">:</span>
        $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">&lt;</span>
target1<span class="hl opt">.</span>exe<span class="hl opt">:</span>
target2<span class="hl opt">.</span>exe<span class="hl opt">:</span>
</pre><p>
	  Si ejecuta simplemente <span class="command"><strong>make</strong></span>, se construirá
	  <code class="filename">target1.exe</code> (usando la regla de sufijo
	  predeterminada) porque ese es el primer objetivo que
	  <span class="command"><strong>make</strong></span> va a encontrar. Para construir
	  <code class="filename">target2.exe</code> se debe indicar
	  explícitamente diciendo <span class="command"><strong>make
	  target2.exe</strong></span>. Esto puede resultar tedioso de modo que
	  normalmente se crea un objetivo «dummy» por
	  defecto que depende del resto de objetivos, como éste:
	</p><pre class="programlisting">
CPP <span class="hl opt">=</span> mycompiler
<span class="hl opt">.</span>SUFFIXES<span class="hl opt">: .</span>exe <span class="hl opt">.</span>cpp
<span class="hl opt">.</span>cpp<span class="hl opt">.</span>exe<span class="hl opt">:</span>
        $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">&lt;</span>
all<span class="hl opt">:</span> target1<span class="hl opt">.</span>exe target2<span class="hl opt">.</span>exe
</pre><p>
	  Aquí, <code class="literal">all</code> no existe y no hay ningún
	  fichero llamada <code class="literal">all</code>, así que cada vez que
	  ejecute <span class="command"><strong>make</strong></span>, el programa verá que
	  <code class="literal">all</code> es el primer objetivo de la lista (y
	  por tanto el objetivo por defecto), entonces comprobará que
	  <code class="literal">all</code> no existe y analizará sus
	  dependencias. Comprueba <code class="filename">target1.exe</code> y
	  (usando la regla de sufijo) comprobará (1) que
	  <code class="filename">target1.exe</code> existe y (2) que
	  <code class="filename">target1.cpp</code> es más reciente que
	  <code class="filename">target1.exe</code> , y si es así ejecutará la
	  regla (si proporciona una regla explícita para un objetivo
	  concreto, se usará esa regla en su lugar). Después pasa a
	  analizar el siguiente fichero de la lista de objetivos por
	  defecto. De este modo, breando una lista de objetivos por
	  defecto (típicamente llamada <code class="literal">all</code> por convenio,
	  aunque se puede tener cualquier nombre) puede conseguir que se
	  construyan todos los ejecutables de su proyecto simplemente
	  escribiendo <span class="command"><strong>make</strong></span>. Además, puede tener otras
	  listas de objetivos para hacer otras cosas - por ejemplo,
	  podría hacer que escribiendo <span class="command"><strong>make debug</strong></span> se
	  reconstruyeran todos los ficheros pero incluyendo información
	  de depuración.
	</p></div></div><div class="sect2" title="3.11.2. Los Makefiles de este libro"><div class="titlepage"><div><div><h3 class="title"><a id="idp5124664"></a>3.11.2. Los Makefiles de este libro</h3></div></div></div><p>
	Usando el programa <code class="filename">ExtractCode.cpp</code> del
	Volumen 2 de este libro, se han extraido automáticamente todos
	los listado de código de este libro a partir de la versión en
	texto ASCII y se han colocado en subdirectorios de acuerdo a sus
	capítulos. Además, <code class="filename">ExtractCode.cpp</code> crea
	varios <code class="filename">makefiles</code> en cada subdirectorio (con
	nombres diferentes) para que pueda ir a cualquier subdirectorio
	y escribir <span class="command"><strong>make -f mycompiler.makefile</strong></span>
	(sustituyendo «mycompiler» por el nombre de su
	compilador, la opción <em class="parameter"><code>-f</code></em> dice
	«utiliza lo siguiente como un
	<code class="filename">makefile</code>»). Finalmente,
	<code class="filename">ExtractCode.cpp</code> crea un
	<code class="filename">makefile</code> «maestro» en el
	directorio raíz donde se hayan extraido los fichero del libro, y
	este <code class="filename">makefile</code> descienda a cada
	subdirectorio y llama a <span class="command"><strong>make</strong></span> con el
	<code class="filename">makefile</code> apropiado. De este modo, se puede
	compilar todo el código de los listados del libro invocando un
	único comando <span class="command"><strong>make</strong></span>, y el proceso parará cada
	vez que su compilador no pueda manejar un fichero particular
	(tenga presente que un compilador conforme al Estándar C++
	debería ser compatible con todos los ficheros de este
	libro). Como algunas implementaciones de <span class="command"><strong>make</strong></span>
	varían de un sistema a otro, en los
	<code class="filename">makefiles</code> generados se usan sólo las
	características más básicas y comunes.
      </p></div><div class="sect2" title="3.11.3. Un ejemplo de Makefile"><div class="titlepage"><div><div><h3 class="title"><a id="idp5132040"></a>3.11.3. Un ejemplo de Makefile</h3></div></div></div><p>
	Tal como se mencionaba, la herramienta de extracción de código
	<code class="filename">ExtractCode.cpp</code> genera automáticamente
	<code class="filename">makefiles</code> para cada capítulo. Por eso, los
	<code class="filename">makefiles</code> de cada capítulo no aparecen en
	el libro (todos los <code class="filename">makefiles</code> están
	empaquetados con el código fuente, que se puede descargar de
	<a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>).
	Sin embargo, es útil ver un ejemplo de un
	<code class="filename">makefile</code>. Lo siguiente es una versión
	recortada de uno de esos <code class="filename">makefiles</code>
	generados automáticamente para este capítulo. Encontrará más de
	un <code class="filename">makefile</code> en cada subdirectorio (tienen
	nombres diferentes; puede invocar uno concreto con <span class="command"><strong>make
	-f</strong></span>. Éste es para GNU C++:
      </p><pre class="programlisting">
CPP <span class="hl opt">=</span> g<span class="hl opt">++</span>
OFLAG <span class="hl opt">= -</span>o
<span class="hl opt">.</span>SUFFIXES <span class="hl opt">: .</span>o <span class="hl opt">.</span>cpp <span class="hl opt">.</span>c
<span class="hl opt">.</span>cpp<span class="hl opt">.</span>o <span class="hl opt">:</span>
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>CPPFLAGS<span class="hl opt">) -</span>c $<span class="hl opt">&lt;</span>
<span class="hl opt">.</span>c<span class="hl opt">.</span>o <span class="hl opt">:</span>
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>CPPFLAGS<span class="hl opt">) -</span>c $<span class="hl opt">&lt;</span>

all<span class="hl opt">:</span> \
  Return \
  Declare \
  Ifthen \
  Guess \
  Guess2
<span class="hl ppc"># Rest of the files for this chapter not shown</span>

Return<span class="hl opt">:</span> Return<span class="hl opt">.</span>o
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>OFLAG<span class="hl opt">)</span>Return Return<span class="hl opt">.</span>o

Declare<span class="hl opt">:</span> Declare<span class="hl opt">.</span>o
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>OFLAG<span class="hl opt">)</span>Declare Declare<span class="hl opt">.</span>o

Ifthen<span class="hl opt">:</span> Ifthen<span class="hl opt">.</span>o
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>OFLAG<span class="hl opt">)</span>Ifthen Ifthen<span class="hl opt">.</span>o

Guess<span class="hl opt">:</span> Guess<span class="hl opt">.</span>o
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>OFLAG<span class="hl opt">)</span>Guess Guess<span class="hl opt">.</span>o

Guess2<span class="hl opt">:</span> Guess2<span class="hl opt">.</span>o
  $<span class="hl opt">(</span>CPP<span class="hl opt">)</span> $<span class="hl opt">(</span>OFLAG<span class="hl opt">)</span>Guess2 Guess2<span class="hl opt">.</span>o

Return<span class="hl opt">.</span>o<span class="hl opt">:</span> Return<span class="hl opt">.</span>cpp
Declare<span class="hl opt">.</span>o<span class="hl opt">:</span> Declare<span class="hl opt">.</span>cpp
Ifthen<span class="hl opt">.</span>o<span class="hl opt">:</span> Ifthen<span class="hl opt">.</span>cpp
Guess<span class="hl opt">.</span>o<span class="hl opt">:</span> Guess<span class="hl opt">.</span>cpp
Guess2<span class="hl opt">.</span>o<span class="hl opt">:</span> Guess2<span class="hl opt">.</span>cpp
</pre><p>
	La macro CPP contiene el nombre del compilador. Para usar un
	compilador diferente, puede editar el
	<code class="filename">makefile</code> o cambiar el valor de la macro
	desde línea de comandos, algo como:
      </p><pre class="screen">
$ make CPP=cpp
</pre><p>
	Tenga en cuenta, sin embargo, que
	<code class="filename">ExtractCode.cpp</code> tiene un esquema automático
	para construir <code class="filename">makefiles</code> para compiladores
	adicionales.
      </p><p>
	La segunda macro <code class="varname">OFLAG</code> es la opción que se
	usa para indicar el nombre del fichero de salida. Aunque muchos
	compiladores asumen automáticamente que el fichero de salida
	tiene el mismo nombre base que el fichero de entrada, otros no
	(como los compiladores GNU/Unix, que por defecto crean un
	fichero llamado <code class="filename">a.out</code>).
      </p><p>
	Como ve, hay dos reglas de sufijo, una para ficheros
	<code class="filename">.cpp</code> y otra para fichero
	<code class="filename">.c</code> (en caso de que se necesite compilar
	algún fuente C). El objetivo por defecto es
	<code class="literal">all</code>, y cada línea de este objetivo está
	«continuada» usando la contrabarra, hasta
	<code class="filename">Guess2</code>, que el el último de la lista y por
	eso no tiene contrabarra. Hay muchos más fichero en este
	capítulo, pero (por brevedad) sólo se muestran algunos.
      </p><p>
	Las reglas de sufijo se ocupan de crear fichero objeto (con
	extensión <code class="filename">.o</code>) a partir de los fichero
	<code class="filename">.cpp</code>, pero en general se necesita escribir
	reglas explícitamente para crear el ejecutable, porque
	normalmente el ejecutable se crea enlazando muchos fichero
	objeto diferente y <span class="command"><strong>make</strong></span> no puede adivinar
	cuales son. También, en este caso (GNU/Unix) no se usan
	extensiones estándar para los ejecutables de modo que una regla
	de sufijo no sirve para esas situaciones. Por eso, verá que
	todas las reglas para construir el ejecutable final se indican
	explícitamente.
      </p><p>
	Este <code class="filename">makefile</code> toma el camino más seguro
	usando el mínimo de prestaciones de <span class="command"><strong>make</strong></span>;
	sólo usa los conceptos básicos de objetivos y dependencias, y
	también macros. De este modo está prácticamente asegurado que
	funcionará con la mayoría de las implementaciones de
	<span class="command"><strong>make</strong></span>. Eso implica que se producen fichero
	<code class="filename">makefile</code> más grandes, pero no es algo
	negativo ya que se generan automáticamente por
	<code class="filename">ExtractCode.cpp</code>.

      </p><p>
	Hay muchísimas otras prestaciones de <span class="command"><strong>make</strong></span> que
	no se usan en este libro, incluyendo las versiones más nuevas e
	inteligentes y las variaciones de <span class="command"><strong>make</strong></span> con
	atajos avanzados que permiten ahorrar mucho tiempo. La
	documentación propia de cada <span class="command"><strong>make</strong></span> particular
	describe en más profundidad sus características; puede aprender
	más sobre <span class="command"><strong>make</strong></span> en <em class="citetitle">Managing
	Projects with Make</em> de Oram y Taiboot (O'Reilly,
	1993). También, si el fabricante de su compilador no proporciona
	un <span class="command"><strong>make</strong></span> o usa uno que no es estándar, puede
	encontrar GNU Make para prácticamente todas las plataformas que
	existen buscado en los archivos de GNU en internet (hay muchos).
      </p></div></div><div class="sect1" title="3.12. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5152080"></a>3.12. Resumen</h2></div></div></div><p>
      Este capítulo ha sido un repaso bastante intenso a través de todas
      las características fundamentales de la sintaxis de C++, la
      mayoría heredada de C (y ello redunda la compatibilidad hacia
      atrás FIXME:vaunted de C++ con C). Aunque algunas características
      de C++ se han presentado aquí, este repaso está pensado
      principalmente para personas con experiencia en programación, y
      simplemente necesitan una introducción a la sintaxis básica de C y
      C++. Incluso si usted ya es un programador de C, puede que haya
      visto una o dos cosas de C que no conocía, aparte de todo lo
      referente a C++ que probablemente sean nuevas. Sin embargo, si
      este capítulo le ha sobrepasado un poco, debería leer el curso en
      CD ROM <em class="citetitle">Thinking in C: Foundations for C++ and
      Java</em> que contiene lecturas, ejercicios, y soluciones
      guiadas), que viene con este libro, y también está disponible en
      <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p></div><div class="sect1" title="3.13. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5155104"></a>3.13. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Cree un fichero de cabecera (con extensión
	  «.h»). En este fichero, declare un grupo de
	  funciones variando las listas de argumentos y valores de
	  retorno de entre los siguientes: <code class="keyword">void</code>, <code class="keyword">char</code>,
	  <code class="keyword">int</code> y <code class="keyword">float</code>. Ahora cree un fichero
	  <code class="filename">.cpp</code> que incluya su fichero de cabecera
	  y haga definiciones para todas esas funciones. Cada definición
	  simplemente debe imprimir en nombre de la función, la lista de
	  argumentos y el tipo de retorno para que se sepa que ha sido
	  llamada. Cree un segundo fichero <code class="filename">.cpp</code> que
	  incluya el fichero de cabecera y defina una <code class="code">int
	  main()</code>, que contenga llamadas a todas sus
	  funciones. Compile y ejecute su programa.
	</p></li><li class="listitem"><p>
	  Escriba un programa que use dos bucles <code class="keyword">for</code> anidados y
	  el operador módulo (<code class="literal">%</code>) para detectar e imprimir
	  números enteros (números enteros sólo divisibles entre si mismos
	  y entre 1).
	</p></li><li class="listitem"><p>
	  Escriba un programa que utilice un bucle <code class="keyword">while</code>
	  para leer palabras de la entrada estándar
	  (<code class="varname">cin</code>) y las guarde en un
	  <code class="type">string</code>. Este es un bucle <code class="keyword">while</code>
	  «infinito», que debe romper (y salir del
	  programa) usando la sentencia <code class="keyword">break</code>. Por cada palabra
	  que lea, evalúela primero usando una secuencia de sentencias
	  <code class="keyword">if</code> para «mapear» un valor entero de la
	  palabra, y después use una sentencia <code class="keyword">switch</code> que
	  utilice ese valor entero como selector (esta secuencia de
	  eventos no es un buen estilo de programación; solamente es un
	  supuesto para que practique con el control de flujo). Dentro
	  de cada <code class="keyword">case</code>, imprima algo con sentido. Debe decidir
	  cuales son las palabras interesantes y qué significan. También
	  debe decidir qué palabra significa el fin del programa. Pruebe
	  el programa redireccionando un fichero como entrada (si quiere
	  ahorrarse tener que escribir, ese fichero puede ser el propio
	  código fuente del programa).
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Menu.cpp</code> para usar sentencias
	  <code class="keyword">switch</code> en lugar de <code class="keyword">if</code>.
	</p></li><li class="listitem"><p>
	  Escriba un programa que evalúe las dos expresiones de la
	  sección llamada «precedencia».
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">YourPets2.cpp</code> para que use
	  varios tipos de datos distintos (<code class="type">char</code>,
	  <code class="type">int</code>, <code class="type">float</code>, <code class="type">double</code>, y
	  sus variantes). Ejecute el programa y cree un mapa del esquema
	  de memoria resultante. Si tiene acceso a más de un tipo de
	  máquina, sistema operativo, o compilador, intente este
	  experimento con tantas variaciones como pueda manejar.
	</p></li><li class="listitem"><p>
	  Cree dos funciones, una que tome un <code class="type">string*</code> y una
	  que tome un <code class="type">string&amp;</code>. Cada una de estas funciones
	  debería modificar el objeto <code class="type">externo</code> a su
	  manera. En <code class="function">main()</code>, cree e inicialice un
	  objeto <code class="type">string</code>, imprímalo, después páselo a cada
	  una de las dos funciones, imprimiendo los resultados.
	</p></li><li class="listitem"><p>
	  Escriba un programa que use todos los trígrafos para ver si su
	  compilador los soporta.
	</p></li><li class="listitem"><p>
	  Compile y ejecute <code class="filename">Static.cpp</code>. Elimine la
	  palabra reservada <code class="keyword">static</code> del código, compile y
	  ejecútelo de nuevo, y explique lo que ocurre.
	</p></li><li class="listitem"><p>
	  Intente compilar y enlazar <code class="filename">FileStatic.cpp</code>
	  con <code class="filename">FileStatic2.cpp</code>. ¿Qué significan los
	  mensajes de error que aparecen?
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Boolean.cpp</code> para que funcione
	  con valores <code class="type">double</code> en lugar de <code class="type">int</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Boolean.cpp</code> y
	  <code class="filename">Bitwise.cpp</code> de modo que usen los
	  operadores explícitos (si su compilador es conforme al
	  Estándar C++ los soportará).
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Bitwise.cpp</code> para usar las
	  funciones de <code class="filename">Rotation.cpp</code>. Asegúrese de
	  que muestra los resultados que deje claro qué ocurre durante
	  las rotaciones.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Ifthen.cpp</code> para usar el
	  operador <code class="keyword">if-else</code> ternario(<code class="literal">?:</code>).
	</p></li><li class="listitem"><p>
	  Cree una <code class="keyword">struct</code> que contenga dos objetos
	  <code class="classname">string</code> y uno <code class="type">int</code>. Use un
	  <code class="keyword">typedef</code> para el nombre de la <code class="keyword">struct</code>. Cree
	  una instancia de la <code class="keyword">struct</code>, inicialice los tres
	  valores de la instancia, y muestrelos en pantalla. Tome la
	  dirección de su instancia y asígnela a un puntero a tipo de la
	  <code class="keyword">struct</code>. Usando el puntero, Cambie los tres valores de
	  la instancia y muestrelos.
	</p></li><li class="listitem"><p>
	  Cree un programa que use un enumerado de colores. Cree una
	  variable de este tipo <code class="keyword">enum</code> y, utilizando un bucle,
	  muestre todos los números que corresponden a los nombres de
	  los colores.
	</p></li><li class="listitem"><p>
	  Experimente con <code class="filename">Union.cpp</code> eliminando
	  varios elementos de la <code class="keyword">union</code> para ver el efecto que
	  causa en el tamaño de la <code class="keyword">union</code> resultante. Intente
	  asignar un elemento (por tanto un tipo) de la <code class="keyword">union</code> y
	  muéstrelo por medio de un elemento diferente (por tanto, un
	  tipo diferente) para ver que ocurre.
	</p></li><li class="listitem"><p>
	  Cree un programa que defina dos arrays de <code class="type">int</code>,
	  uno a continuación del otro. Indexe el primer array más allá
	  de su tamaño para caer sobre el segundo, haga una
	  asignación. Muestre el segundo array para ver los cambios que
	  eso ha causado. Ahora intente definir una variable
	  <code class="type">char</code> entre las definiciones de los arrays, y
	  repita el experimento. Quizá quiera crear una función para
	  imprimir arrays y así simplificar el código.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ArrayAddresses.cpp</code> para que
	  funcione con los tipos de datos <code class="type">char</code>, <code class="type">long
	  int</code>, <code class="type">float</code> y <code class="type">double</code>.
	</p></li><li class="listitem"><p>
	  Aplique la técnica de <code class="filename">ArrayAddresses.cpp</code>
	  para mostrar el tamaño de la <code class="keyword">struct</code> y las direcciones
	  de los elementos del array de
	  <code class="filename">StructArray.cpp</code>.
	</p></li><li class="listitem"><p>
	  Cree un array de objetos <code class="type">string</code> y asigne una
	  cadena a cada elemento. Muestre el array usando un bucle
	  <code class="keyword">for</code>.
	</p></li><li class="listitem"><p>
	  Cree dos nuevos programas a partir de
	  <code class="filename">ArgsToInts.cpp</code> que usen
	  <code class="function">atol()</code> y <code class="function">atof()</code>
	  respectivamente.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">PointerIncrement2.cpp</code> de modo
	  que use una <code class="keyword">union</code> en lugar de una <code class="keyword">struct</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">PointerArithmetic.cpp</code> para que
	  funcione con <code class="type">long</code> y <code class="type">long double</code>.
	</p></li><li class="listitem"><p>
	  Defina una variable <code class="type">float</code>. Tome su dirección,
	  moldee esa dirección a un <code class="type">unsigned char</code>, y
	  asígnela a un puntero <code class="type">unsigned char</code>. Usando este
	  puntero y <code class="literal">[]</code>, indexe la variable
	  <code class="type">float</code> y use la función
	  <code class="function">printBinary()</code> definida en este capítulo
	  para mostrar un mapa de cada <code class="type">float</code> (vaya desde 0
	  hasta <code class="code">sizeof(float)</code>). Cambie el valor del
	  <code class="type">float</code> y compruebe si puede averiguar que hay en el
	  float (el <code class="type">float</code> contiene datos codificados).
	</p></li><li class="listitem"><p>
	  Defina un array de <code class="type">int</code>. Tome la dirección de
	  comienzo de ese array y utilice <code class="literal">static_cast</code> para
	  convertirlo a un <code class="type">void*</code>. Escriba una función que
	  tome un <code class="type">void*</code>, un número (que indica el número de
	  bytes), y un valor (indicando el valor que debería ser
	  asignado a cada byte) como argumentos. La función debería
	  asignar a cada byte en el rango especificado el valor dado
	  como argumento. Pruebe la función con su array de
	  <code class="type">int</code>.
	</p></li><li class="listitem"><p>
	  Cree un array <code class="keyword">const</code> de <code class="type">double</code> y un array
	  <code class="keyword">volatile</code> de <code class="type">double</code>. Indexe cada array y
	  utilice <code class="keyword">const_cast</code> para moldear cada elemento de
	  no-<code class="keyword">const</code> y no-<code class="keyword">volatile</code>, respectivamente, y
	  asigne un valor a cada elemento.
	</p></li><li class="listitem"><p>
	  Cree una función que tome un puntero a un array de
	  <code class="type">double</code> y un valor indicando el tamaño de ese
	  array. La función debería mostrar cada valor del array. Ahora
	  cree un array de <code class="type">double</code> y inicialice cada
	  elemento a cero, después utilice su función para mostrar el
	  array. Después use <code class="keyword">reinterpret_cast</code> para moldear la
	  dirección de comienzo de su array a un <code class="type">unsigned
	  char*</code>, y ponga a 1 cada byte del array (aviso:
	  necesitará usar <code class="literal">sizeof</code> para calcular el número de
	  bytes que tiene un <code class="type">double</code>). Ahora use su función
	  de impresión de arrays para mostrar los resultados. ¿Por qué
	  cree los elementos no tienen el valor 1.0?
	</p></li><li class="listitem"><p>
	  (Reto) Modifique <code class="filename">FloatingAsBinary.cpp</code>
	  para que muestra cada parte del <code class="type">double</code> como un
	  grupo separado de bits. Tendrá que reemplazar las llamadas a
	  <code class="function">printBinary()</code> con su propio código
	  específico (que puede derivar de
	  <code class="function">printBinary()</code>) para hacerlo, y también
	  tendrá que buscar y comprender el formato de punto flotante
	  incluyendo el ordenamiento de bytes para su compilador (esta
	  parte es el reto).
	</p></li><li class="listitem"><p>
	  Cree un <code class="filename">makefile</code> que no sólo compile
	  <code class="filename">YourPets1.cpp</code> y
	  <code class="filename">YourPets2.cpp</code> (para cada compilador
	  particular) sino que también ejecute ambos programas como
	  parte del comportamiento del objetivo
	  predeterminado. Asegúrese de usar las reglas de sufijo.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">StringizingExpressions.cpp</code> para
	  que <code class="code">P(A)</code> sea condicionalmente definida con
	  <code class="keyword">#ifdef</code> para permitir que el código de depuración sea
	  eliminado automáticamente por medio de una bandera en línea de
	  comandos. Necesitará consultar la documentación de su
	  compilador para ver cómo definir y eliminar valores del
	  preprocesador en el compilador de línea de comandos.
	</p></li><li class="listitem"><p>
	  Defina una función que tome un argumento <code class="type">double</code> y
	  retorne un <code class="type">int</code>. Cree e inicialice un puntero a
	  esta función, e invoque la función por medio del puntero.
	</p></li><li class="listitem"><p>
	  Declare un puntero a un función que toma un argumento
	  <code class="type">int</code> y retorna un puntero a una función que toma
	  un argumento <code class="type">char</code> y retorna un
	  <code class="type">float</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">FunctionTable.cpp</code> para que cada
	  función retorne un <code class="type">string</code> (en lugar de mostrar un
	  mensaje) de modo que este valor se imprima en
	  <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree un <code class="filename">makefile</code> para uno de los
	  ejercicios previos (a su elección) que le permita escribir
	  <span class="command"><strong>make</strong></span> para construir una versión en
	  producción del programa y <span class="command"><strong>make debug</strong></span> para
	  construir una versión del programa que incluye información de
	  depuración.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp4347232" href="#idp4347232" class="para">39</a>] </sup>
	    Fíjese en que todas las convenciones parecen acabar estando
	    de acuerdo en que hay que hacer algún tipo de
	    indentación. La pelea entre los estilos de formateo de
	    código no tiene fin. En el Apéndice A se explica el estilo
	    de codificación que se usa en este libro.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4419168" href="#idp4419168" class="para">40</a>] </sup>
	    Gracias a Kris C. Matson por proponer este ejercicio.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4438856" href="#idp4438856" class="para">41</a>] </sup>
	    (N. de T.) ...aunque se evalúa como «C».
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4924944" href="#idp4924944" class="para">42</a>] </sup>(N. de T.) <span class="emphasis"><em>zero indexing</em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.idp4945120" href="#idp4945120" class="para">43</a>] </sup>
	      A menos que tome la siguiente aproximación estricta:
	      «todos los argumentos pasado en C/C++ son por valor,
	      y el «valor» de un vector es el producido por
	      su identificador: su dirección». Eso puede parecer
	      correcto desde el punto de vista del lenguaje ensamblador,
	      pero yo no creo que ayude cuando se trabaja con conceptos
	      de alto nivel. La inclusión de referencias en C++ hace que
	      el argumento «todo se pasa por valor» sea más
	      confuso, hasta el punto de que siento que es más adecuado
	      pensar en términos de «paso por valor» vs
	      «paso por dirección».
	    </p></div><div class="footnote"><p><sup>[<a id="ftn.idp5040464" href="#idp5040464" class="para">44</a>] </sup>
	    (N. del T.) Otra forma similar de entenderlo es dibujar
	    mentalmente una espiral que empieza en el medio (el
	    identificador) y se va abriendo.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp5077112" href="#idp5077112" class="para">45</a>] </sup>
	  (N. de T.) El método del que habla el autor se refiere
	  normalmente a software instalado a partir de su código
	  fuente. La instalación de paquetes binarios es mucho más
	  simple y automatizada en la mayoría de las variantes actuales
	  del sistema operativo GNU.
	</p></div></div></div><div class="chapter" title="4: Abstracción de Datos"><div class="titlepage"><div><div><h2 class="title"><a id="C04"></a>4: Abstracción de Datos</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp5230184">4.1. Una librería pequeña al estilo C</a></span></dt><dt><span class="sect1"><a href="#idp5325096">4.2. ¿Qué tiene de malo?</a></span></dt><dt><span class="sect1"><a href="#idp5335872">4.3. El objeto básico</a></span></dt><dt><span class="sect1"><a href="#idp5391952">4.4. ¿Qué es un objeto?</a></span></dt><dt><span class="sect1"><a href="#idp5398792">4.5. Tipos abstractos de datos</a></span></dt><dt><span class="sect1"><a href="#idp5411360">4.6. Detalles del objeto</a></span></dt><dt><span class="sect1"><a href="#idp5425000">4.7. Conveciones para los ficheros de cabecera</a></span></dt><dt><span class="sect1"><a href="#idp5488200">4.8. Estructuras anidadas</a></span></dt><dt><span class="sect1"><a href="#idp5530552">4.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5534768">4.10. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      C++ es una herramienta de mejora de la productividad. ¿Por qué
      si no haría el esfuerzo (y es un esfuerzo, a pesar de lo fácil que
      intetemos hacer la transición)
    </p></div><p>
    de cambiar de algún lenguaje que ya conoce y con el cual ya es
    productivo a un nuevo lenguaje con el que será menos productivo
    durante un tiempo, hasta que se haga con él? Se debe a que está
    convencido de que conseguirá grandes ventajas usando esta nueva
    herramienta.
  </p><p>
    En términos de programación, productividad significa que menos
    personas, en menos tiempo, puedan realizar programas más complejos y
    significativos. Desde luego, hay otras cuestiones que nos deben
    importar a la hora de escoger un lenguaje de programación. Aspectos
    a tener en cuenta son la eficiencia (¿la naturaleza del lenguaje
    hace que nuestros programas sean lentos o demasiado grandes?), la
    seguridad (¿nos ayuda el lenguaje a asegurarnos de que nuestros
    programas hagan siempre lo que queremos?  ¿maneja el lenguaje los
    errores apropiadamente?)  y el mantenimiento (¿el lenguaje ayuda a
    crear código fácil de entender, modificar y extender?). Estos son,
    con certeza, factores importantes que se examinarán en este libro.
  </p><p>
    Pero la productividad real significa que un programa que para ser escrito, antes
    requería de tres personas trabajando una semana, ahora le lleve sólo un día o dos a
    una sola persona. Esto afecta a varios niveles de la esfera económica. A usted le
    agrada ver que es capaz de construir algo en menos tiempo, sus clientes (o jefe) están
    contentos porque los productos les llegan más rápido y utilizando menos mano
    de obra y finalmente los compradores se alegran porque pueden obtener productos más
    baratos. La única manera de obtener incrementos masivos en productividad es apoyándose
    en el código de otras personas; o sea, usando librerías.
  </p><p>
    Una librería es simplemente un montón de código que alguien ha
    escrito y empaquetado todo junto. Muchas veces, el paquete mínimo es
    tan sólo un archivo con una extensión especial como
    <code class="filename">lib</code> y uno o más archivos de cabecera que le
    dicen al compilador qué contiene la librería. El enlazador sabrá cómo
    buscar el archivo de la librería y extraer el código compilado
    correcto. Sin embargo, ésta es sólo una forma de entregar una
    librería. En plataformas que abarcan muchas arquitecturas, como
    GNU o Unix, el único modo sensato de entregar una libraría es con
    código fuente para que así pueda ser reconfigurado y reconstruido en
    el nuevo objetivo.
  </p><p>
    De esta forma, las librerías probablemente sean la forma más
    importante de progresar en términos de productividad y uno de los
    principales objetivos del diseño de C++ es hacer más fácil el uso de
    librerías. Esto implica entonces, que hay algo difícil al usar
    librerías en C. Entender este factor le dará una primera idea sobre
    el diseño de C++, y por lo tanto, de cómo usarlo.
  </p><div class="sect1" title="4.1. Una librería pequeña al estilo C"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5230184"></a>4.1. Una librería pequeña al estilo C</h2></div></div></div><p>
      Aunque muchas veces, una librería comienza como una colección de
      funciones, si ha usado alguna librería C de terceros habrá
      observado que la cosa no termina ahí porque hay más que
      comportamiento, acciones y funciones. También hay características
      (azul, libras, textura, luminiscencia), las cuales están
      representadas por datos. En C, cuando debemos representar
      características, es muy conveniente agruparlas todas juntas en una
      <span class="emphasis"><em>estructura</em></span>, especialmente cuando queremos
      representar más de un tipo de cosa en el problema. Así, se puede
      trabajar con una variable de esta
      <span class="emphasis"><em>estructuras</em></span> para representar cada cosa.
    </p><p>
      Por eso, la mayoría de las librerías en C están formadas por un
      conjunto de estructuras y funciones que actúan sobre las
      primeras. Como ejemplo de esta técnica, considere una herramienta
      de programación que se comporta como un array, pero cuyo tamaño se
      puede fijar en tiempo de ejecución, en el momento de su
      creación. La llamaremos <code class="type">CStash</code>
      <sup>[<a id="idp5233176" href="#ftn.idp5233176" class="footnote">46</a>]</sup>. Aunque está escrito en C++, tiene el estilo clásico
      de una librería escrita en C:
    </p><div class="example"><a id="idp5234288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:CLib.h</span>
<span class="hl slc">// Header file for a C-like library</span>
<span class="hl slc">// An array-like entity created at runtime</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> CStashTag <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
  <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
<span class="hl opt">}</span> CStash<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">);</span>
<span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">const void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> index<span class="hl opt">);</span>
<span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.1. C04/CLib.h</strong></p></div><br class="example-break" /><p>
      Normalmente se utiliza un «rótulo» como
      <code class="type">CStashTag</code> en aquellas estructuras que necesitan
      referenciarse dentro de si mismas. Ese es el caso de una
      <span class="emphasis"><em>lista enlazada</em></span> (cada elemento de la lista
      contiene un puntero al siguiente elemento) se necesita un puntero a
      la siguiente variable estructura, o sea, una manera de identificar
      el tipo de ese puntero dentro del cuerpo de la propia
      estructura. En la declaración de las estructuras de una librería
      escrita en C también es muy común ver el uso de <code class="keyword">typedef</code>
      como el del ejemplo anterior. Esto permite al programador tratar
      las estructuras como un nuevo tipo de dato y así definir nuevas
      variables (de esa estructura) del siguiente modo:
    </p><pre class="programlisting">
CStash A<span class="hl opt">,</span> B<span class="hl opt">,</span> C<span class="hl opt">;</span>
</pre><p>
      El puntero <code class="varname">storage</code> es un <code class="type">unsigned
      char*</code>. Un <code class="type">unsigned char</code> es la menor pieza de
      datos que permite un compilador C, aunque en algunas máquinas
      puede ser de igual tamaño que la mayor. Aunque es dependiente de
      la implementación, por lo general un <code class="type">unsigned char</code>
      tiene un tamaño de un byte. Dado que <code class="type">CStash</code> está
      diseñado para almacenar cualquier tipo de estructura, el lector se
      puede preguntar si no sería más apropiado un puntero <code class="type">void
      *</code>. Sin embargo, el objetivo no es tratar este puntero de
      almacenamiento como un bloque de datos de tipo desconocido, sino
      como un bloque de bytes contiguos.
    </p><p>
      El archivo de código fuente para la implementación (del que no se
      suele disponer si fuese una librería comercial —normalmente sólo
      dispondrá de un <code class="filename">.obj</code>,
      <code class="filename">.lib</code> o <code class="filename">.dll</code>, etc) tiene
      este aspecto:
    </p><div class="example"><a id="idp5242736"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:CLib.cpp {O}</span>
<span class="hl slc">// Implementation of example C-like library</span>
<span class="hl slc">// Declare structure and functions:</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt; </span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl slc">// Quantity of elements to add</span>
<span class="hl slc">// when increasing storage:</span>
<span class="hl kwb">const int</span> increment <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  s<span class="hl opt">-&gt;</span>size <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  s<span class="hl opt">-&gt;</span>storage <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  s<span class="hl opt">-&gt;</span>next <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">const void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>s<span class="hl opt">-&gt;</span>next <span class="hl opt">&gt;=</span> s<span class="hl opt">-&gt;</span>quantity<span class="hl opt">)</span> <span class="hl slc">//Enough space left?</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>s<span class="hl opt">,</span> increment<span class="hl opt">);</span>
  <span class="hl slc">// Copy element into storage,</span>
  <span class="hl slc">// starting at next empty space:</span>
  <span class="hl kwb">int</span> startBytes <span class="hl opt">=</span> s<span class="hl opt">-&gt;</span>next <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> e <span class="hl opt">= (</span><span class="hl kwb">unsigned char</span><span class="hl opt">*)</span>element<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    s<span class="hl opt">-&gt;</span>storage<span class="hl opt">[</span>startBytes <span class="hl opt">+</span> i<span class="hl opt">] =</span> e<span class="hl opt">[</span>i<span class="hl opt">];</span>
  s<span class="hl opt">-&gt;</span>next<span class="hl opt">++;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>s<span class="hl opt">-&gt;</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl slc">// Check index boundaries:</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> index<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> s<span class="hl opt">-&gt;</span>next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> <span class="hl opt">&amp;(</span>s<span class="hl opt">-&gt;</span>storage<span class="hl opt">[</span>index <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> s<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>  <span class="hl slc">// Elements in CStash</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>increase <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> newQuantity <span class="hl opt">=</span> s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">;</span>
  <span class="hl kwb">int</span> newBytes <span class="hl opt">=</span> newQuantity <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span>
  <span class="hl kwb">int</span> oldBytes <span class="hl opt">=</span> s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> oldBytes<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> s<span class="hl opt">-&gt;</span>storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Copy old to new</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[](</span>s<span class="hl opt">-&gt;</span>storage<span class="hl opt">);</span> <span class="hl slc">// Old storage</span>
  s<span class="hl opt">-&gt;</span>storage <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
  s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">=</span> newQuantity<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>s<span class="hl opt">-&gt;</span>storage <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
   cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;freeing storage&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
   <span class="hl kwa">delete</span> <span class="hl opt">[]</span>s<span class="hl opt">-&gt;</span>storage<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.2. C04/CLib.cpp</strong></p></div><br class="example-break" /><p>
      <code class="function">initialize()</code> realiza las operaciones
      iniciales necesarias para la <code class="type">struct CStash</code>, poniendo
      los valores apropiados en las variables internas. Inicialmente, el
      puntero <code class="varname">storage</code> tiene un cero dado que aún no
      se ha almacenado nada.
    </p><p>
      La función <code class="function">add()</code> inserta un elemento en el
      siguiente lugar disponible de la <code class="type">CStash</code>. Para
      lograrlo, primero verifica que haya suficiente espacio
      disponible. Si no lo hay, expande el espacio de almacenamiento
      (<code class="varname">storage</code>) usando la función
      <code class="function">inflate()</code> que se describe después.
    </p><p>
      Como el compilador no conoce el tipo específico de la variable que
      está siendo almacenada (todo lo que obtiene la función es un
      <code class="type">void*</code>), no se puede hacer una asignación simple, que
      sería lo más conveniente. En lugar de eso, la variable se copia
      byte a byte. La manera más directa de hacerlo es utilizando el
      indexado de arrays. Lo habitual es que en
      <code class="varname">storage</code> ya haya bytes almacenados, lo cual es
      indicado por el valor de <code class="varname">next</code>. Para obtener la
      posición de inserción correcta en el array, se multiplica
      <code class="varname">next</code> por el tamaño de cada elemento (en bytes)
      lo cual produce el valor de <code class="varname">startBytes</code>. Luego
      el argumento <code class="varname">element</code> se moldea a <code class="type">unsigned
      char*</code> para que se pueda direccionar y copiar byte a byte en
      el espacio disponible de <code class="varname">storage</code>. Se incrementa
      <code class="varname">next</code> de modo que indique el siguiente lugar de
      almacenamiento disponible y el «índice» en el que ha
      almacenado el elemento para que el valor se puede recuperar
      utilizando el índice con <code class="function">fetch()</code>.
    </p><p>
      <code class="function">fetch()</code> verifica que el índice tenga un valor
      correcto y devuelve la dirección de la variable deseada, que se
      calcula en función del argumento <code class="varname">index</code>. Dado
      que <code class="varname">index</code> es un desplazamiento desde el
      principio en la <code class="type">CStash</code>, se debe multiplicar por el
      tamaño en bytes que ocupa cada elemento para obtener dicho
      desplazamiento en bytes. Cuando utilizamos este desplazamiento
      como índice del array <code class="varname">storage</code> lo que obtenemos
      no es la dirección, sino el byte almacenado. Lo que hacemos
      entonces es utilizar el operador dirección-de <code class="literal">&amp;</code>.
    </p><p>
      <code class="function">count()</code> puede parecer un poco extraña a los
      programadores experimentados en C. Podría parecer demasiado
      complicada para una tarea que probablemente sea mucho más fácil de
      hacer a mano. Por ejemplo, si tenemos una <code class="type">CStash</code>
      llamada <code class="varname">intStash</code>, es mucho más directo
      preguntar por la cantidad de elementos utilizando
      <code class="varname">intStash.next</code>, que llamar a una función (que
      implica sobrecarga), como
      <code class="function">count(&amp;intStash)</code>. Sin embargo, la
      cantidad de elementos se calcula en función tanto del puntero
      <code class="varname">next</code> como del tamaño en bytes de cada elemento
      de la <code class="type">CStash</code>; por eso la interfaz de la función
      <code class="function">count()</code> permite la flexibilidad necesaria
      para no tener que preocuparnos por estas cosas. Pero, ¡ay!, la
      mayoría de los programadores no se preocuparán por descubrir lo
      que para nosotros es el «mejor» diseño para la
      librería. Probablemente lo que harán es mirar dentro de la
      estructura y obtener el valor de <code class="varname">next</code>
      directamente. Peor aún, podrían incluso cambiar el valor de
      <code class="varname">next</code> sin nuestro permiso. ¡Si hubiera alguna
      forma que permitiera al diseñador de la librería tener un mejor
      control sobre este tipo de cosas! (Sí, esto es un presagio).
    </p><div class="sect2" title="4.1.1. Asignación dinámica de memoria"><div class="titlepage"><div><div><h3 class="title"><a id="idp5261120"></a>4.1.1. Asignación dinámica de memoria</h3></div></div></div><p>
	Nunca se puede saber la cantidad máxima de almacenamiento que se
	necesitará para una <code class="type">CStash</code>, por eso la memoria a la
	que apuntan los elementos de <code class="varname">storage</code> se
	asigna desde el <span class="emphasis"><em>montículo</em></span>
	(<span class="foreignphrase"><em class="foreignphrase">heap</em></span>)
	<sup>[<a id="idp5262800" href="#ftn.idp5262800" class="footnote">47</a>]</sup>.

	El montículo es un gran bloque de memoria que se utiliza para
	asignar en pequeños trozos en tiempo de ejecución. Se usa el
	heap cuando no se conoce de antemano la cantidad de memoria que
	necesitará el programa que está escribiendo. Por ejemplo, eso
	ocurre en un programa en el que sólo en el momento de la
	ejecución se sabe si se necesia memoria para 200 variables
	<code class="type">Avión</code> o para 20. En C Estándar, las funciones para
	asignación dinámica de memoria incluyen
	<code class="function">malloc()</code>, <code class="function">calloc()</code>,
	<code class="function">realloc()</code> y <code class="function">free()</code>. En
	lugar de llamadas a librerías, C++ cuenta con una técnica más
	sofisticada (y por lo tanto más fácil de usar) para tratar la
	memoria dinámica. Esta técnica está integrada en el lenguaje por
	medio de las palabras reservadas <code class="keyword">new</code> y <code class="keyword">delete</code>.
      </p><p>
	La función <code class="function">inflate()</code> usa <code class="keyword">new</code> para
	obtener más memoria para la <code class="type">CStash</code>. En este caso el
	espacio de memoria sólo se amplia y nunca se
	reduce. <code class="function">assert()</code> garantiza que no se pase
	un número negativo como argumento a
	<code class="function">inflate()</code> como valor de incremento. La
	nueva cantidad de elmentos que se podrán almacenar (una vez se
	haya terminado <code class="function">inflate()</code>) se determina en la
	variable <code class="varname">newQuantity</code> que se multiplica por
	el número de bytes que ocupa cada elemento, para obtener el
	nuevo número total de bytes de la asignación en la variable
	<code class="varname">newBytes</code>. Dado que se sabe cuántos bytes hay
	que copiar desde la ubicación anterior,
	<code class="varname">oldBytes</code> se calcula usando la cantidad
	antigua de bytes (<code class="varname">quantity</code>).
      </p><p>
	La petición de memoria ocurre realmente en la
	<span class="emphasis"><em>expresión-new</em></span> que involucra la palabra
	reservada <code class="keyword">new</code>:
      </p><pre class="programlisting">
<span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
</pre><p>
	La forma general de una <span class="emphasis"><em>expresión-new</em></span>
	es:
      </p><pre class="programlisting">
<span class="hl kwa">new</span> Tipo<span class="hl opt">;</span>
</pre><p>
	donde <code class="type">Tipo</code> describe el tipo de variable para la
	cual se solicita memoria en el
	<span class="emphasis"><em>montículo</em></span>. Dado que en este caso, se desea
	asignar memoria para un array de <code class="type">unsigned char</code> de
	<code class="varname">newBytes</code> elementos, eso es lo que aparece como
	<code class="type">Tipo</code>. Del mismo modo, se puede asignar memoria para
	algo más simple como un <code class="type">int</code> con la expresión:
      </p><pre class="programlisting">
<span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">;</span>
</pre><p>
	y aunque esto se utiliza muy poco, demuestra que la sintaxis es
	consistente.
      </p><p>
	Una <span class="emphasis"><em>expresión-new</em></span> devuelve un
	<span class="emphasis"><em>puntero</em></span> a un objeto del tipo exacto que se
	le pidió. De modo que con <code class="code">new Tipo</code> se obtendrá un
	puntero a un objeto de tipo <code class="type">Tipo</code>, y con <code class="code">new
	int</code> obtendrá un puntero a un <code class="type">int</code>. Si quiere
	un nuevo array de <code class="type">unsigned char</code> la expresión
	devolverá un puntero al primer elemento de dicho array. El
	compilador verificará que se asigne lo que devuelve la
	<span class="emphasis"><em>expresión-new</em></span> a una variable puntero del
	tipo adecuado.
      </p><p>
	Por supuesto, es posible que al pedir memoria, la petición
	falle, por ejemplo, si no hay más memoria libre en el
	sistema. Como verá más adelante, C++ cuenta con mecanismos que
	entran en juego cuando la operación de asignación de memoria no
	se puede satisfacer.
      </p><p>
	Una vez que se ha obtenido un nuevo espacio de almacenamiento,
	los datos que estaban en el antiguo se deben copiar al
	nuevo. Esto se hace, nuevamente, en un bucle, utilizando la
	notación de índexado de arrays, copiando un byte en cada
	iteración del bucle. Una vez finalizada esta copia, ya no se
	necesitan los datos que están en el espacio de almacenamiento
	original por lo que se pueden liberar de la memoria para que
	otras partes del programa puedan usarlo cuando lo necesiten. La
	palabra reservada <code class="keyword">delete</code> es el complemento de
	<code class="keyword">new</code> y se debe utilizar sobre todas aquellas variables a
	las cuales se les haya asignado memoria con <code class="keyword">new</code>. (Si se
	olvida de utilizar <code class="keyword">delete</code> esa memoria queda
	in-utilizable. Si estas fugas de memoria (<span class="foreignphrase"><em class="foreignphrase">memory
	leak</em></span>) son demasiado abundantes, la memoria
	disponible se acabará.)  Existe una sintaxis especial cuando se
	libera un array. Es como si recordara al compilador que ese
	puntero no apunta sólo a un objeto, sino a un array de objetos;
	se deben poner un par de corchetes delante del puntero que se
	quiere liberar:
      </p><pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[]</span>myArray<span class="hl opt">;</span>
</pre><p>
	Una vez liberado el antiguo espacio de almacenamiento, se puede
        asignar el puntero del nuevo espacio de memoria al puntero
        <code class="varname">storage</code>, se actualiza
        <code class="varname">quantity</code> y con eso
        <code class="function">inflate()</code> ha terminado su trabajo.
      </p><p>
	En este punto es bueno notar que el administrador de memoria del
	montículo&gt; es bastante primitivo. Nos facilita trozos de memoria
	cuando se lo pedimos con <code class="keyword">new</code> y los libera cuando
	invocamos a <code class="keyword">delete</code>. Si un programa asigna y libera
	memoria muchas veces, terminaremos con un montículo
	<span class="emphasis"><em>fragmentado</em></span>, es decir un montículo en el
	que si bien puede haber memoria libre utilizable, los trozos de
	memoria están divididos de tal modo que no exista un trozo que
	sea lo suficientemente grande para las necesidades concretas en
	un momento dado. Lamentablemente no existe una capacidad
	inherente del lenguaje para efectuar <span class="emphasis"><em>defragmentaciones
	del montículo</em></span>. Un defragmentador del montículo
	complica las cosas dado que tiene que mover pedazos de memoria,
	y por lo tanto, hacer que los punteros dejen de apuntar a
	valores válidos. Algunos entornos operativos vienen con este
	tipo de facilidades pero obligan al programador a utilizar
	manejadores de memoria especiales en lugar de punteros (estos
	manipuladores se pueden convertir temporalmente en punteros una
	vez bloqueada la memoria para que el defragmentador del
	montículo no la modifique). También podemos construir nosotros
	mismos uno de estos artilugios, aunque no es una tarea sencilla.
      </p><p>
	Cuando creamos una variable en la pila en tiempo de compilación,
	el mismo compilador es quien se encarga de crearla y liberar la
	memoria ocupada por ella automáticamente. Conoce exactamente el
	tamaño y la duración de este tipo de variables dada por las
	reglas de ámbito. Sin embargo, en el caso de las variables
	almacenadas dinámicamente, el compilador no poseerá información
	ni del tamaño requerido por las mismas, ni de su duración. Esto
	significa que el compilador no puede encargarse de liberar
	automáticamente la memoria ocupada por este tipo de variables y
	de aquí que el responsable de esta tarea sea el programador (o
	sea usted). Para esto se debe utilizar <code class="keyword">delete</code>, lo cual
	le indica al administrador del montículo que ese espacio de
	memoria puede ser utilizado por próximas llamadas a
	<code class="keyword">new</code>. En nuestra librería de ejemplo, el lugar lógico
	para esta tarea es la función <code class="function">cleanup()</code>
	dado que allí es dónde se deben realizar todas las labores de
	finalización de uso del objeto.
      </p><p>
	Para probar la librería se crean dos <code class="type">Cstash</code>, uno
        que almacene enteros y otro para cadenas de 80 caracteres:
      </p><div class="example"><a id="idp5293336"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:CLibTest.cpp</span>
<span class="hl slc">//{L} CLib</span>
<span class="hl slc">// Test the C-like library</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Define variables at the beginning</span>
  <span class="hl slc">// of the block, as in C:</span>
  CStash intStash<span class="hl opt">,</span> stringStash<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">;</span>
  ifstream in<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">80</span><span class="hl opt">;</span>
  <span class="hl slc">// Now remember to initialize the variables:</span>
  <span class="hl kwd">initialize</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">,</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwd">add</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">, &amp;</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwd">count</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">);</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fetch(&amp;intStash, &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span><span class="hl kwd">fetch</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">,</span> i<span class="hl opt">)</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Holds 80-character strings:</span>
  <span class="hl kwd">initialize</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">)*</span>bufsize<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">(</span><span class="hl str">&quot;CLibTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>in<span class="hl opt">);</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    <span class="hl kwd">add</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span> line<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span><span class="hl kwd">fetch</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span>i<span class="hl opt">++))!=</span><span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fetch(&amp;stringStash, &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">cleanup</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">);</span>
  <span class="hl kwd">cleanup</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.3. C04/CLibTest.cpp</strong></p></div><br class="example-break" /><p>
	Dado que debemos respetar la sintaxis de C, todas las variables
        se deben declarar al comienzo de
        <code class="function">main()</code>. Obviamente, no nos podemos olvidar
        de inicializar todas las variables <code class="type">Cstash</code> más
        adelante en el bloque main(), pero antes de usarlas, llamando a
        <code class="function">initialize()</code>. Uno de los problemas con las
        librerías en C es que uno debe asegurarse de convencer al
        usuario de la importancia de las funciones de inicialización y
        destrucción.  ¡Habrá muchos problemas si estas funciones se
        omiten!  Lamentablemente el usuario no siempre se preguntará si
        la inicialización y el limpiado de los objetos son
        obligatorios. Ellos le darán importancia a lo que
        <span class="emphasis"><em>ellos</em></span> quieren hacer y no nos darán tanta
        importancia a nosotros (el programador de la librería) cuando
        les digamos «¡Hey! ¡espera un poco! ¡Debes hacer
        <span class="emphasis"><em>esto</em></span> primero!». Otro problema que
        puede presentarse es el hecho de que algunos usuarios quieran
        inicializar los elementos (datos internos) de una estructura por
        su cuenta. En C no hay un mecanismo para prevenir este tipo de
        conductas (más presagios de los temás que vendrán...).
      </p><p>
	La <code class="varname">intStash</code> se va llenando con enteros
        mientras que el <code class="varname">stringStash</code> se va llenando
        con arrays de caracteres. Estos arrays de caracteres son
        producidos leyendo el archivo fuente
        <code class="filename">CLibTest.cpp</code> y almacenando las líneas de
        este archivo en el <code class="type">string</code>
        <code class="varname">line</code>. Obtenemos la representación
        «puntero a carácter» de <code class="varname">line</code> con
        el método <code class="function">c_str()</code>. </p><p>
	Una vez cargados los <code class="type">Stash</code> ambos se muestran en
	pantalla. <code class="varname">intStash</code> se imprime usando un bucle
	<code class="keyword">for</code> en el cual se usa <code class="function">count()</code> para
	determinar la cantidad de elementos. El
	<code class="varname">stringStash</code> se muestra utilizando un bucle
	<code class="keyword">while</code> dentro del cual se va llamando a
	<code class="function">fetch()</code>. Cuando esta función devuelve cero
	se rompe el bucle ya que esto significará que se han sobrepasado
	los límites de la estructura.
      </p><p>
	El lector también pudo haber visto un molde adicional en la
	línea:
      </p><pre class="programlisting">
cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span><span class="hl kwd">fetch</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span> i<span class="hl opt">++)</span>
</pre><p>
	Esto se debe a la comprobación estricta de tipos en C++, que no
	permite asignar un <code class="type">void *</code> a una variable de
	cualquier tipo, mientras que C sí lo hubiera permitido.
      </p></div><div class="sect2" title="4.1.2. Malas suposiciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp5307168"></a>4.1.2. Malas suposiciones</h3></div></div></div><p>
	Antes de abordar los problemas generales de la creación de una
	librería C, discutiremos otro asunto importante que se debe
	tener claro. Fíjese que el archivo de cabecera
	<code class="filename">CLib.h</code> <span class="emphasis"><em>debe</em></span> incluirse
	en cada archivo fuente que haga referencia al tipo
	<code class="type">CStash</code> ya que el compilador no puede adivinar qué
	aspecto tiene la estructura. Sin embargo,
	<span class="emphasis"><em>sí</em></span> puede adivinar el aspecto de una
	función. Aunque eso pueda parecer una ventaja, veremos que en
	realidad, es un grave problema de C.
      </p><p>
	Aunque siempre debería declarar las funciones incluyendo un
	archivo de cabecera, en C las declaraciones de funciones no son
	esenciales. En este lenguaje (pero no en C++), es posible llamar
	a una función que no ha sido declarada. Un buen compilador
	seguramente avisará de que deberíamos declarar la función antes
	de usarla, pero nos permitirá seguir dado que no es obligatorio
	hacerlo en C estándar. Esta es una práctica peligrosa ya que el
	compilador puede asumir que una función que ha sido llamada con
	un <code class="type">int</code> como argumento, tenga un <code class="type">int</code>
	como argumento cuando, en realidad, es un
	<code class="type">float</code>. Como veremos, esto puede producir errores
	que pueden ser muy difíciles de depurar.
      </p><p>
	Se dice que cada archivo de implementación C (los archivos de
	extensión <code class="filename">.c</code>) es una unidad de traducción
	(<span class="foreignphrase"><em class="foreignphrase">translation unit</em></span>). El compilador
	se ejecuta independientemente sobre cada unidad de traducción
	ocupándose, en ese momento, solamente en ese archivo. Por eso,
	la información que le demos al compilador por medio de los
	archivos de cabecera es muy importante dado que determina la
	forma enq que ese archivo se relaciona con las demás partes del
	programa. Por eso motivo, las declaraciones en los archivos de
	cabecera son particularmente importantes dado que, en cada lugar
	que se incluyen, el compilador sabrá exactamente qué hacer. Por
	ejemplo, si en un archivo de cabecera tenemos la declaración
	<code class="function">void func(float) </code>, si llamamos a
	<code class="function">func()</code> con un <code class="type">int</code> como
	argumento, el compilador sabrá que deberá convertir el
	<code class="type">int</code> a <code class="type">float</code> antes de pasarle el valor
	a la función (a esto se le llama <span class="emphasis"><em>promoción</em></span>
	de tipos). Sin la declaración, el compilador asumiría que la
	función tiene la forma <code class="function">func(int)</code>, no
	realizaría la promoción y pasaría, por lo tanto, datos
	incorrectos a la función.
      </p><p>
	Para cada unidad de traducción, el compilador crea un archivo
	objeto, de extensión <code class="filename">.o</code>,
	<code class="filename">.obj</code> o algo por el estilo. Estos archivos
	objeto, junto con algo de código de arranque se unens por el
	enlazador(<span class="foreignphrase"><em class="foreignphrase">linker</em></span>) para crear el
	programa ejecutable. Todas las referencias externas se deben
	resolver en la fase de enlazado. En archivos como
	<code class="filename">CLibTest.cpp</code>, se declaran funciones como
	<code class="function">initialize()</code> y <code class="function">fetch()</code>
	(o sea, se le informa al compilador qué forma tienen estas
	funciones), pero no se definen. Están definidas en otro lugar,
	en este caso en el archivo <code class="filename">CLib.cpp</code>. De ese
	modo, las llamadas que se hacen en
	<code class="filename">CLibTest.cpp</code> a estas funciones son
	referencias externas. Cuando se unen los archivos objeto para
	formar el programa ejecutable, el enlazador debe, para cada
	referencia externa no resuelta, encontrar la dirección a la que
	hace referencia y reemplazar cada referencia externa con su
	dirección correspondiente.
      </p><p>
	Es importante señalar que en C, estas referencias externas que
	el enlazador busca son simples nombres de funciones,
	generalmente precedidos por un guión bajo. De esta forma, la
	única tarea del enlazador es hacer corresponder el nombre de la
	función que se llama, con el cuerpo (definición, código) de la
	función del archivo objeto, en el lugar exacto de la llamada a
	dicha función. Si, por ejemplo, accidentalmente hacemos una
	llamada a una función que el compilador interprete como
	<code class="function">func(int)</code> y existe una definición de
	función para <code class="function">func(float)</code> en algún archivo
	objeto, el enlazador verá <code class="function">_func</code> en un lugar
	y <code class="function">_func</code> en otro, por lo que
	<span class="emphasis"><em>pensará</em></span> que todo está bien. En la llamada a
	<code class="function">func()</code> se pasará un <code class="type">int</code> en la
	pila pero el cuerpo de la función <code class="function">func()</code>
	esperará que la pila tenga un <code class="type">float</code>. Si la función
	sólo lee el valor de este dato y no lo escribe, la pila no
	sufrirá datos. De hecho, el supuesto <code class="type">float</code> leído de
	la pila puede tener algo de sentido: la función seguirá
	funcionando aunque sobre basura, y es por eso que los fallos
	originadas por esta clase de errores son muy difíciles de
	encontrar.
      </p></div></div><div class="sect1" title="4.2. ¿Qué tiene de malo?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5325096"></a>4.2. ¿Qué tiene de malo?</h2></div></div></div><p>
      Somos seres realmente destinados a la adaptación, incluso a las
      que quizá <span class="emphasis"><em>no deberíamos</em></span> adaptarnos. El estilo
      de la librería <code class="type">CStash</code> ha sido un modelo a seguir para
      los programadores en C durante mucho tiempo. Sin embargo, si nos
      ponemos a examinarla por un momento, nos daremos cuenta de que
      utilizar esta librería puede resultar incómodo. Cuando la usamos
      debemos, por ejemplo, pasar la dirección de la estructura a cada
      función de la librería. Por eso, cuando leemos el código, los
      mecanismos de la librería se mezclan con el significado de las
      llamadas a las funciones, lo cual dificulta la comprecsión del
      programa.
    </p><p>
      Sin embargo, uno de los mayores obstáculos al trabajar con
      librerías en C es el problema llamado <span class="emphasis"><em>conflicto de
      nombres</em></span> (<span class="foreignphrase"><em class="foreignphrase">name
      clashes</em></span>). C trabaja con un único espacio de
      nombres de funciones. Esto significa que, cuando el enlazador
      busca por el nombre de una función, lo hace en una única lista de
      nombres maestra. Además, cuando el compilador trabaja sobre una
      unidad de traducción, un nombre de función sólo puede hacer
      referencia a una única función con ese nombre.
    </p><p>
      Supongamos que compramos dos librerías de diferentes proveedores y
      que cada librería consta de una estructura que debe inicializar y
      destruir. Supongamos que cada proveedor ha decidido nombrar a
      dichas operaciones <code class="function">initialize()</code> y
      <code class="function">cleanup()</code>. ¿Cómo se comportaría el compilador
      si incluyéramos los archivos de cabecera de ambas librerías en la
      misma unidad de traducción? Afortunadamente, el compilador C dará
      un mensaje de error diciéndonos que hay una incoherencia de tipos
      en las listas de argumentos de ambas declaraciones. No obstante,
      aunque no incluyamos los archivos de cabecera en la unidad de
      traducción igual tendremos problemas con el enlazador. Un buen
      enlazador detectará y avisará cuando se produzca uno de estos
      conflictos de nombres. Sin embargo, hay otros que simplemente
      tomarán el primer nombre de la función que encuentren, buscando en
      los archivos objeto en el orden en el que fueron pasados en la
      lista de enlazado. (Este comportamiento se puede considerar
      como una ventaja ya que permite reemplazar las funciones de
      las librerías ajenas con funciones propias.)
    </p><p>
      En cualquiera de los dos casos, llegamos a la conclusión de que en
      C es imposible usar dos bibliotecas en las cuales existan
      funciones con nombres idénticos. Para solucionar este problema,
      los proveedores de librerías en C ponen un prefijo único a todas
      las funciones de la librería. En nuestro ejemplo, las funciones
      <code class="function">initialize()</code> y <code class="function">cleanup()</code>
      habría que renombrarlas como
      <code class="function">CStash_initialize()</code> y
      <code class="function">CStash_cleanup()</code>. Esta es una técnica lógica:
      decoramos los nombres de las funciones con el nombre de la
      estructura sobre la cual trabajan.
    </p><p>
      Este es el momento de dirigir nuestros pasos a las primeras
      nociones de construcción de clases en C++. Como el lector ha de
      saber, las variables declaradas dentro de una estructura no tienen
      conflictos de nombres con las variables globales. ¿Por qué,
      entonces, no aprovechar esta característica de las variables para
      evitar los conflictos de nombres de funciones declarándolas dentro
      de la estructura sobre la cual operan? O sea, ¿por qué no hacer
      que las funciones sean también miembros de las estructuras?
    </p></div><div class="sect1" title="4.3. El objeto básico"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5335872"></a>4.3. El objeto básico</h2></div></div></div><p>
      Nuestro primer paso será exactamente ese.  Meter las funciones C++
      dentro de las estructuras como «funciones
      miembro». Éste es el aspecto que tiene la estructura una
      vez realizados estos cambios de la versión C de la <code class="type">CStash</code>
      a la versión en C++, a la que llamaremos <code class="type">Stash</code>:
    </p><div class="example"><a id="idp5337640"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:CppLib.h</span>
<span class="hl slc">// C-like library converted to C++</span>

<span class="hl kwb">struct</span> Stash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
   <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
  <span class="hl slc">// Functions!</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">const void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl opt">};</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.4. C04/CppLib.h</strong></p></div><br class="example-break" /><p>
      La primera diferencia que puede notarse es que no se usa
      <code class="keyword">typedef</code>. A diferencia de C que requiere el uso de
      <code class="keyword">typedef</code> para crear nuevos tipos de datos, el compilador
      de C++ hará que el nombre de la estructura sea un nuevo tipo de
      dato automáticamente en el programa (tal como los nombres de
      tipos de datos <code class="type">int</code>, <code class="type">char</code>,
      <code class="type">float</code> y <code class="type">double</code>).
    </p><p>
      Todos los datos miembros de la estructura están declarados igual
      que antes; sin embargo, ahora las funciones están declaradas
      dentro del cuerpo de la <code class="keyword">struct</code>. Más aún, fíjese que el primer
      argumento de todas las funciones ha sido eliminado. En C++,
      en lugar de forzar al usuario a que pase la dirección de la
      estructura sobre la que trabaja una función como primer argumento,
      el compilador hará este trabajo, secretamente. Ahora sólo
      debe preocuparse por los argumentos que le dan sentido a lo
      que la función <span class="emphasis"><em>hace</em></span> y no de los mecanismos
      internos de la función.
    </p><p>
      Es importante darse cuenta de que el código generado por estas
      funciones es el mismo que el de las funciones de la librería al
      estilo C. El número de argumentos es el mismo (aunque no se le
      pase la dirección de la estructura como primer argumento, en
      realidad sí se hace) y sigue existiendo un único cuerpo
      (definición) de cada función. Esto último quiere decir que, aunque
      declare múltiples variables
    </p><pre class="programlisting">
Stash A<span class="hl opt">,</span> B<span class="hl opt">,</span> C<span class="hl opt">;</span>
</pre><p>
      no existirán múltiples definiciones de, por ejemplo, la
      función <code class="function">add()</code>, una para cada variable.
    </p><p>
      De modo que el código generado es casi idéntico al que hubiese
      escrito para una versión en C de la librería, incluyendo la
      «decoración de nombres» ya mencionada para evitar los
      conflictos de nombres, nombrando a las funciones
      <code class="function">Stash_initialize()</code>,
      <code class="function">Stash_cleanup()</code> y demás. Cuando una función
      está dentro de una estructura, el compilador C++ hace lo mismo y
      por eso, una función llamada <code class="function">initialize()</code>
      dentro de una estructura no estará en conflicto con otra función
      <code class="function">initialize()</code> dentro de otra estructura o con
      una función <code class="function">initialize()</code> global. De este
      modo, en general no tendrá que preocuparse por los conflictos de
      nombres de funciones - use el nombre sin decoración. Sin embargo,
      habrá situaciones en las que deseará especificar, por ejemplo,
      esta <code class="function">initialize()</code> pertenece a la estructura
      <code class="type">Stash</code> y no a ninguna otra. En particular, cuando
      defina la función, necesita especificar a qué estructura pertenece
      para lo cual, en C++ cuenta con el operador <code class="literal">::</code>
      llamado operador de resolución de ámbito (ya que ahora un nombre
      puede estar en diferentes ámbitos: el del ámbito global o dentro
      del ámbito de una estructura. Por ejemplo, si quiere referirse
      a una función <code class="function">initialize()</code> que se encuentra
      dentro de la estructura <code class="type">Stash</code> lo podrá hacer con
      la expresión <code class="function">Stash::initialize(int size)</code>. A
      continuación podrá ver cómo se usa el operador de resolución de
      ámbito para definir funciones:
    </p><div class="example"><a id="idp5352440"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:CppLib.cpp {O}</span>
<span class="hl slc">// C library converted to C++</span>
<span class="hl slc">// Declare structure and functions:</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CppLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl slc">// Quantity of elements to add</span>
<span class="hl slc">// when increasing storage:</span>
<span class="hl kwb">const int</span> increment <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

<span class="hl kwb">void</span> Stash<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  size <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  quantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  storage <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  next <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">const void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span> <span class="hl slc">// Enough space left?</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>increment<span class="hl opt">);</span>
  <span class="hl slc">// Copy element into storage,</span>
  <span class="hl slc">// starting at next empty space:</span>
  <span class="hl kwb">int</span> startBytes <span class="hl opt">=</span> next <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> e <span class="hl opt">= (</span><span class="hl kwb">unsigned char</span><span class="hl opt">*)</span>element<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    storage<span class="hl opt">[</span>startBytes <span class="hl opt">+</span> i<span class="hl opt">] =</span> e<span class="hl opt">[</span>i<span class="hl opt">];</span>
  next<span class="hl opt">++;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stash<span class="hl opt">::</span><span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl slc">// Check index boundaries:</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> index<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> <span class="hl opt">&amp;(</span>storage<span class="hl opt">[</span>index <span class="hl opt">*</span> size<span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">count</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> next<span class="hl opt">;</span> <span class="hl slc">// Number of elements in CStash</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stash<span class="hl opt">::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>increase <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> newQuantity <span class="hl opt">=</span> quantity <span class="hl opt">+</span> increase<span class="hl opt">;</span>
  <span class="hl kwb">int</span> newBytes <span class="hl opt">=</span> newQuantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">int</span> oldBytes <span class="hl opt">=</span> quantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> oldBytes<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Copy old to new</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span> <span class="hl slc">// Old storage</span>
  storage <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
  quantity <span class="hl opt">=</span> newQuantity<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stash<span class="hl opt">::</span><span class="hl kwd">cleanup</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>storage <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;freeing storage&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.5. C04/CppLib.cpp</strong></p></div><br class="example-break" /><p>
      Hay muchas otras cosas que difieres entre C y C++. Para empezar,
      el compilador <span class="emphasis"><em>requiere</em></span> que declare las
      funciones en los archivos de cabecera: en C++ no podrá llamar a
      una función sin haberla declarado antes y si no se cumple esta
      regla el compilador dará un error. Esta es una forma importante de
      asegurar que las llamadas a una función son consistentes entre el
      punto en que se llama y el punto en que se define. Al forzar a
      declarar una función antes de usarla, el compilador de C++
      prácticamente se asegura de que realizará esa declaración por
      medio de la inclusión de un fichero de cabecera. Además, si
      también incluye el mismo fichero de cabecera en el mismo lugar
      donde se defines las funciones, el compilador verificará que las
      declaraciones del archivo cabecera y las definiciones
      coinciden. Puede decirse entonces que, de algún modo, los
      ficheros de cabecera se vuelven un repositorio de validación de
      funciones y permiten asegurar que las funciones se usan
      de modo consistente en todas las unidades de traducción del
      proyecto.
    </p><p>
      Obviamente, las funciones globales se pueden seguir declarando a
      mano en aquellos lugares en las que se definen y usan (Sin
      embargo, esta práctica es tan tediosa que está en desuso.)  De
      cualquier modo, las estructuras siempre se deben declarar antes de
      ser usadas y el mejor lugar para esto es un fichero de cabecera,
      exceptuando aquellas que queremos esconder intencionalmente en
      otro fichero.
    </p><p>
      Se puede ver que todas las funciones miembro (métodos) tienen casi
      la misma forma que sus versiones respectivas en C. Las únicas
      diferencias son su ámbito de resolución y el hecho de que el
      primer argumento ya no aparece explícito en el prototipo de la
      función. Por supuesto que sigue ahí ya que la función debe ser
      capaz de trabajar sobre una variable <code class="keyword">struct</code> en
      particular. Sin embargo, fíjese también que, dentro del método, la
      selección de esta estructura en particular también ha
      desaparecido! Así, en lugar de decir <code class="code">s-&gt;size = sz;</code>
      ahora dice <code class="code">size = sz;</code> eliminando el tedioso
      <code class="code">s-&gt;</code> que en realidad no aportaba nada al significado
      semántico de lo que estaba escribiendo. Aparentemente, el
      compilador de C++ está realizando estas tareas por el
      programador. De hecho, está tomando el primer argumento
      «secreto» (la dirección de la estructura que antes
      tenía que pasar a mano) y aplicándole el selector de miembro (-&gt;)
      siempre que escribe el nombre de uno de los datos miembro. Eso
      significa que, siempre y cuando esté dentro de la definición de
      una método de una estructura puede hacer referencia a cualquier
      otro miembro (incluyendo otro método) simplemente dando su
      nombre. El compilador buscará primero en los nombres locales de la
      estructura antes de buscar en versiones más globales de dichos
      nombres. El lector podrá descubrir que esta característica no sólo
      agiliza la escritura del código, sino que también hace la lectura
      del mismo mucho más sencilla.
    </p><p>
      Pero qué pasaría si, por alguna razón,
      <span class="emphasis"><em>quisiera</em></span> hacer referencia a la dirección de
      memoria de la estructura. En la versión en C de la librería ésta
      se podía obtener fácilmente del primer argumento de cualquier
      función. En C++ la cosa es más consistente: existe la palabra
      reservada <code class="literal">this</code> que produce la dirección de la
      variable <code class="keyword">struct</code> actual. Es el equivalente a la expresión
      <code class="varname">s</code> de la versión en C de la librería. De modo
      que, podremos volver al estilo de C escribiendo
    </p><pre class="programlisting">
<span class="hl kwa">this</span><span class="hl opt">-&gt;</span>size <span class="hl opt">=</span> Size<span class="hl opt">;</span>
</pre><p>
      El código generado por el compilador será exactamente el mismo por
      lo que no es necesario usar <code class="literal">this</code> en estos
      casos. Ocasionalmente, podrá ver por ahí código dónde la gente usa
      <code class="literal">this</code> en todos sitios sin agregar nada al
      significado del código (esta práctica es indicio de programadores
      inexpertos). Por lo general, <code class="literal">this</code> no se usa muy
      a menudo pero, cuando se necesite siempre estará allí (en
      ejemplos posteriores del libro verá más sobre su uso).
    </p><p>
      Queda aún un último tema que tocar. En C, se puede asignar un
      <code class="type">void *</code> a cualquier otro puntero, algo como esto:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> vp <span class="hl opt">= &amp;</span>i<span class="hl opt">;</span> <span class="hl slc">// OK tanto en C como en C++</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> vp<span class="hl opt">;</span> <span class="hl slc">// Sólo aceptable en C</span>
</pre><p>
      y no habrá ningún tipo de queja por parte de compilador. Sin
      embargo, en C++, lo anterior no está permitido. ¿Por qué? Porque C
      no es tan estricto con los tipos de datos y permite asignar un
      puntero sin un tipo específico a un puntero de un tipo bien
      determinado. No así C++, en el cual la verificación de tipos es
      crítica y el compilador se detendrá quejándose en cualquier
      conflicto de tipos. Esto siempre ha sido importante, pero es
      especialmente importante en C++ ya que dentro de las estructuras
      puede hacer métodos. Si en C++ estuviera permitido pasar punteros
      a estructuras con impunidad en cuanto a conflicto de tipos,
      ¡podría terminar llamando a un método de una estructura en la cual
      no existiera dicha función miembro! Una verdadera fórmula para el
      desastre. Así, mientras C++ sí deja asignar cualquier puntero a un
      <code class="type">void *</code> (en realidad este es el propósito original del
      puntero a <code class="type">void</code>: que sea suficientemente largo como
      para apuntar a cualquier tipo) no permite asignar un <code class="type">void
      *</code> a cualquier otro tipo de puntero. Para ello se requiere
      un molde que le indique tanto al lector como al compilador que
      realmente quiere tratarlo como el puntero destino.
    </p><p>
      Y esto nos lleva a discutir un asunto interesante. Uno de los
      objetivos importantes de C++ es poder compilar la mayor cantidad
      posible de código C para así, permitir una fácil transición al
      nuevo lenguaje. Sin embargo, eso no significa, como se ha visto
      que cualquier segmento de código que sea válido en C, será
      permitido automáticamente en C++. Hay varias cosas que un
      compilador de C permite hacer que son potencialmente peligrosas y
      propensas a generar errores (verá ejemplos de a lo largo de
      libro). El compilador de C++ genera errores y avisos en este tipo
      de situaciones y como verá eso es más una ventaja que un obstáculo
      a pesar de su naturaleza restrictiva. ¡De hecho, existen muchas
      situaciones en las cuales tratará de detectar sin éxito un error
      en C y cuando recompiles el programa con un compilador de C++ éste
      avisa exactamente de la causa del problema!. En C, muy a menudo
      ocurre que para que un programa funcione correctamente, además de
      compilarlo, luego debe <span class="emphasis"><em>hacer que ande</em></span>. ¡En
      C++, por el contrario, verá que muchas veces si un programa
      compila correctamente es probable que funcione bien!  Esto
      se debe a que este último lenguaje es mucho más estricto respecto
      a la comprobación de tipos.
    </p><p>
      En el siguiente programa de prueba podrá apreciar cosas nuevas con
      respecto a cómo se utiliza la nueva versión de la
      <code class="type">Stash</code>:
    </p><div class="example"><a id="idp5377304"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:CppLibTest.cpp</span>
<span class="hl slc">//{L} CppLib</span>
<span class="hl slc">// Test of C++ library</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CppLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stash intStash<span class="hl opt">;</span>
  intStash<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    intStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(&amp;</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> intStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;intStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span>intStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>j<span class="hl opt">)</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Holds 80-character strings:</span>
  Stash stringStash<span class="hl opt">;</span>
  <span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">80</span><span class="hl opt">;</span>
  stringStash<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">) *</span> bufsize<span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;CppLibTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;CppLibTest.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    stringStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span>line<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">=(</span><span class="hl kwb">char</span><span class="hl opt">*)</span>stringStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>k<span class="hl opt">++)) !=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;stringStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> k <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  intStash<span class="hl opt">.</span><span class="hl kwd">cleanup</span><span class="hl opt">();</span>
  stringStash<span class="hl opt">.</span><span class="hl kwd">cleanup</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.6. C04/CppLibTest.cpp</strong></p></div><br class="example-break" /><p>
      Una de las cosas que el lector habrá podido observar en el código
      anterior es que las variables se definen «al vuelo»,
      o sea (como se introdujo en el capítulo anterior) en cualquier
      parte de un bloque y no necesariamente -como en C- al comienzo
      de los mismos.
    </p><p>
      El código es bastante similar al visto en
      <code class="filename">CLibTest.cpp</code> con la diferencia de que, cuando
      se llama a un método, se utiliza el operador de selección de
      miembro '<code class="literal">.</code>' precedido por el nombre de la
      variable. Esta es una síntaxis conveniente ya que imita a la
      selección o acceso de un dato miembro de una estructura. La única
      diferencia es que, al ser un método, su llamada implica una lista
      de argumentos.
    </p><p>
      Tal y cómo se dijo antes, la llamada que el compilador hace genera
      <span class="emphasis"><em>realmente</em></span> es mucho más parecida a la llamada
      a la función de la librería en C. Considere la decoración de
      nombres y el paso del puntero <code class="varname">this</code>: la llamada
      en C++ de <code class="function">intStash.initialize(sizeof(int),
      100)</code> se transformará en algo parecido a
      <code class="function">Stash_initialize(&amp;intStash, sizeof(int),
      100)</code>. Si el lector se pregunta qué es lo que sucede
      realmente debajo del envoltorio, debería recordar que el
      compilador original de C++ <span class="application">cfront</span> de
      AT&amp;T producía código C como salida que luego debía ser
      compilada con un compilador de C para generar el ejecutable. Este
      método permitía a <span class="application">cfront</span> ser
      rápidamente portable a cualquier máquina que soportara un
      compilador estándar de C y ayudó a la rápida difusión de C++. Dado
      que los compiladores antiguos de C++ tenían que generar código C,
      sabemos que existe una manera de representar síntaxis C++ en C
      (algunos compiladores de hoy en día aún permiten generar código
      C).
    </p><p>
      Comparando con <code class="filename">CLibTest.cpp</code> observará un
      cambio: la introducción del fichero de cabecera
      <code class="filename">require.h</code>. He creado este fichero de cabecera
      para realizar una comprobación de errores más sofisticada que la
      que proporciona <code class="function">assert()</code>. Contiene varias
      funciones incluyendo la llamada en este último ejemplo,
      <code class="function">assure()</code> que se usa sobre ficheros. Esta
      función verifica que un fichero se ha abierto exitosamente y en
      caso contrario reporta un aviso a la salida de error estándar (por
      lo que también necesita el nombre del fichero como segundo
      argumento) y sale del programa. Las funciones de
      <code class="filename">require.h</code> se usan a lo largo de este libro
      especialmente para asegurar que se ha indicado la cantidad
      correcta de argumentos en la línea de comandos y para verificar
      que los ficheros se abren correctamente. Las funciones de
      <code class="filename">require.h</code> reemplazan el código de detección
      de errores repetitivo y que muchas veces es causa de distracciones
      y más aún, proporcionan mensajes útiles para la detección de
      posibles errores. Estas funciones se explican detalladamente más
      adelante.
    </p></div><div class="sect1" title="4.4. ¿Qué es un objeto?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5391952"></a>4.4. ¿Qué es un objeto?</h2></div></div></div><p>
      Ahora que ya se ha visto y discutido un ejemplo incial es hora
      de retroceder para definir la terminología. El acto de
      introducir funciones en las estructuras es el eje central del
      cambio que C++ propone sobre C, e eso introduce una nueva forma
      de ver las estructuras: como conceptos. En C, una estructura
      (<code class="keyword">struct</code>) es tan sólo una agrupación de datos: una
      manera de empaquetar datos para que se puedan tratar como un
      grupo. De esta forma, cuesta hacerse a la idea de que
      representan algo más que una mera conveniencia de programación.

      Las funciones que operan sobre esas estructuras están sueltas
      por ahí. Sin embargo, con las funciones dentro del mismo paquete
      que los datos, la estructura se convierte en una nueva criatura,
      capaz de representar las características (como hacen
      las <code class="keyword">struct</code>s de C) <span class="emphasis"><em>y</em></span> los
      comportamientos. El concepto de objeto, una entidad
      independiente y bien limitada que puede
      recordar <span class="emphasis"><em>y</em></span> actuar, se sugiere a si mismo
      como definición.
    </p><p>
    En C++, un objeto es simplemente una variable, y la definición más
    purista es «una región de almacenamiento» (que es una
    forma más específica para decir «un objeto debe tener un
    único identificador» el cual, en el caso de C++, es una
    dirección única de memoria). Es un lugar en el cual se pueden
    almacenar datos y eso implica también operaciones que pueden
    actuar sobre esos datos.
  </p><p>
    Desafortunadamente no existe una consistencia completa entre los
    distintos lenguajes cuando se habla de estos términos, aunque son
    aceptados bastante bien. También se podrán encontrar discrepancias
    sobre lo que es un lenguaje orientado a objetos, aunque parece
    haber un consenso razonable hoy en día. Hay
    lenguajes <span class="emphasis"><em>basados en objetos</em></span>, que cuentan con
    estructuras-con-funciones como las que ha visto aquí de C++. Sin
    embargo, esto es tan sólo una parte de lo que denomina
    un lenguaje <span class="emphasis"><em>orientado a objetos</em></span>, y los
    lenguajes que solamente llegan a empaquetar las funciones
    dentro de las estructuras son lenguajes basados en objetos y no
    orientados a objetos.
  </p></div><div class="sect1" title="4.5. Tipos abstractos de datos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5398792"></a>4.5. Tipos abstractos de datos</h2></div></div></div><p>
      La habilidad para empaquetar datos junto con funciones permite
      la creación de nuevos tipos de datos. Esto se llama a menudo
      <span class="emphasis"><em>encapsulación</em></span>

      <sup>[<a id="idp5399824" href="#ftn.idp5399824" class="footnote">48</a>]</sup>

      Un tipo de dato existente puede contener varias piezas de datos
      empaquetadas juntas. Por ejemplo, un <code class="type">float</code> tiene un
      exponente, una mantissa y un bit de signo. Le podemos pedir que
      haga varias cosas: sumarse a otro <code class="type">float</code> o a un
      <code class="type">int</code>, etc. Tiene características y comportamiento.
    </p><p>
    La definición de <code class="type">Stash</code> crea un nuevo tipo de dato. Se
    le pueden agregar nuevos elementos (<code class="function">add()</code>),
    sacar (<code class="function">fetch()</code>) y agrandarlo
    (<code class="function">inflate()</code>). Se puede crear uno escribiendo
    <code class="code">Stash s;</code> igual que cuando se crea un
    <code class="type">float</code> diciendo <code class="code">float x;</code>. Un
    <code class="type">Stash</code> también tiene características y un
    comportamiento bien determinado. Aunque actúe igual que un tipo de
    dato predefinido como <code class="type">float</code> se dice que
    <code class="type">Stash</code> es un <span class="emphasis"><em>tipo abstracto de
    dato</em></span> tal vez porque permite abstraer un concepto desde
    el espacio de los problemas al espacio de la solución. Además, el
    compilador de C++ lo tratará exactamente como a un nuevo tipo de
    dato y si, por ejemplo, declara una función que acepta un
    <code class="type">Stash</code> como argumento, el compilador se asegurará de
    que no se le pase otra cosa a la función.  De modo que se realiza
    el mismo nivel de comprobación de tipos tanto para los tipos
    abstractos de datos (a veces también llamados <span class="emphasis"><em>tipos
    definidos por el usuario</em></span>) como para los tipos
    predefinidos.
  </p><p>
      Sin embargo, notará inmediatamente una diferencia en la forma en
      que se realizan las operaciones sobre los objetos. Se hace
      <code class="code">objeto.funciónMiembro(listaArgumentos)</code> o sea,
      «se llama a un método de un objeto». Pero en la
      jerga de la orientación a objetos, eso también se denomina
      «enviar un mensaje a un objeto». De modo que para
      una <code class="varname">Stash s</code>, en esta jerga la sentencia
      <code class="code">s.add(&amp;i)</code> le «envía un mensaje a
      <code class="varname">s</code>» diciéndole «añadete
      (<code class="function">add()</code>) esto». De hecho, la
      programación orientada a objetos se puede resumir en la
      siguiente frase: <span class="emphasis"><em>enviar mensajes a
      objetos</em></span>. Realmente, ¿eso es todo lo que se hace?
      crear un montón de objetos y enviarles mensajes. El truco,
      obviamente, es entender qué <span class="emphasis"><em>son</em></span> en nuestro
      problema los objetos y los mensajes, pero una vez que se ha
      cumplido esa etapa, la implementación en C++ será
      sorprendentemente directa.
    </p></div><div class="sect1" title="4.6. Detalles del objeto"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5411360"></a>4.6. Detalles del objeto</h2></div></div></div><p>
      Una pregunta que surge a menudo en seminarios es «¿Cómo de
      grande es un objeto y qué pinta tiene?» La respuesta es
      «más o menos lo que esperas de un <code class="keyword">struct</code> en
      C». De hecho, el código que produce el compilador de C para
      un <code class="keyword">struct</code> C (sin adornos C++) normalmente es
      <span class="emphasis"><em>exactamente</em></span> el mismo que el producido por un
      compilador C++. Eso tranquiliza a aquellos programadores C que
      dependan de los detalles de tamaño y distribución de su código, y
      que por alguna razón accedan directamente a los bytes de la
      estructura en lugar de usar identificadores (confiar en un tamaño
      y distribución particular para una estructura no es portable).
    </p><p>
      El tamaño de una <code class="keyword">struct</code> es la combinación de los
      tamaños de todos sus miembros. A veces cuando el compilador crea
      una <code class="keyword">struct</code>, añade bytes extra para hacer que los
      límites encajen limpiamente - eso puede incrementar la
      eficiencia de la ejecución. En el <a class="link" href="#C14" title="14: Herencia y Composición">Capítulo
      14</a>, verá cómo en algunos casos se añaden punteros
      «secretos» a la estructura, pero no tiene que
      preocuparse de eso ahora.
    </p><p>
      Puede determinar el tamaño de una <code class="keyword">struct</code> usando
      el operador <code class="literal">sizeof</code>. Aquí tiene un pequeño ejemplo:
    </p><div class="example"><a id="idp5418608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Sizeof.cpp</span>
<span class="hl slc">// Sizes of structs</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CppLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">struct</span> A <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
<span class="hl opt">};</span>

<span class="hl kwb">struct</span> B <span class="hl opt">{</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> B<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">() {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof struct A = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>A<span class="hl opt">)</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; bytes&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof struct B = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>B<span class="hl opt">)</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; bytes&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof CStash in C = &quot;</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>CStash<span class="hl opt">) &lt;&lt;</span> <span class="hl str">&quot; bytes&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof Stash in C++ = &quot;</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Stash<span class="hl opt">) &lt;&lt;</span> <span class="hl str">&quot; bytes&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.7. C04/Sizeof.cpp</strong></p></div><br class="example-break" /><p>
      En mi máquina (los resultados pueden variar) el primer resultado
      produce 200 porque cada <code class="type">int</code> ocupa 2 bytes. La
      <code class="keyword">struct</code> <code class="type">B</code> es algo anómalo porque es una
      <code class="keyword">struct</code> sin atributos. En C, eso es ilegal, pero en C++
      necesitamos la posibilidad de crear una <code class="keyword">struct</code> cuya
      única tarea es ofrecer un ámbito a nombres de funciones, por eso
      está permitido. Aún asi, el segundo resultado es un sorprendente
      valor distinto de cero. En versiones anteriores del lenguage, el
      tamaño era cero, pero aparecia una situación incómoda cuando se
      creaban estos objetos: tenían la misma dirección que el objeto
      creado antes que él, y eran indistinguibles. Una de las reglas
      fundamentales de los objetos es que cada objeto debe tener una
      dirección única, así que las estructuras sin atributos siempre
      tendrán tamaño mínimo distinto de cero.
    </p><p>
      Las dos últimas sentencias <code class="literal">sizeof</code> muestran que el
      tamaño de la estructura en C++ es el mismo que en la versión en
      C. C++ intenta no añadir ninguna sobrecarga innecesaria.
    </p></div><div class="sect1" title="4.7. Conveciones para los ficheros de cabecera"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5425000"></a>4.7. Conveciones para los ficheros de cabecera</h2></div></div></div><p>
      Cuando se crea una <code class="keyword">struct</code> que contiene
      funciones miembro, se está creando un nuevo tipo de dato. En
      general, se intenta que ese tipo sea fácilmente accesible. En
      resumen, se quiere que la interfaz (la declaración) esté separada
      de la implmentación (la definición de los métodos) de
      modo que la implementación pueda cambiar sin obligar a recompilar
      el sistema completo. Eso se consigue poniendo la declaración
      del nuevo tipo en un fichero de cabecera.
    </p><p>
      Cuando yo aprendí a programar en C, el fichero de cabecera era
      un misterio para mi. Muchos libros de C no hacen hincapié, y el
      compilador no obliga a hacer la declaración de las funciones,
      así que parecía algo opcional la mayor parte de las veces,
      excepto cuando se declaraban estrucutras. En C++ el uso de los
      ficheros de cabecera se vuelve claro como el cristal. Son
      prácticamente obligatorios para el desarrollo de programas
      sencillos, y en ellos podrá información muy específica:
      declaraciones. El fichero de cabecera informa al compilador de
      lo que hay disponible en la librería. Puede usar la librería
      incluso si sólo se dispone del fichero de cabecera y el fichero
      objeto o el fichero de librería; no necesita disponer del código
      fuente del fichero <code class="filename">cpp</code>. En el fichero de
      cabecera es donde se guarda la especificación de la interfaz.
    </p><p>
      Aunque el compilador no lo obliga, el mejor modo de construir
      grandes proyectos en C es usar librerías; colecciones de
      funciones asociadas en un mismo módulo objeto o librería, y usar
      un fichero de cabecera para colocar todas las declaraciones de
      las funciones. Es <span class="emphasis"><em>de rigor</em></span> en C++, Podría
      meter cualquier función en una librería C, pero el tipo
      abstracto de dato C++ determina las funciones que están
      asociadas por medio del acceso común a los datos de una
      <code class="keyword">struct</code>. Cualquier función miembro debe ser declarada en
      la declaración de la <code class="keyword">struct</code>; no puede ponerse en otro
      lugar. El uso de librerías de funciones fue fomentado en C y
      institucionalizado en C++.
    </p><div class="sect2" title="4.7.1. Importancia de los ficheros de cabecera"><div class="titlepage"><div><div><h3 class="title"><a id="idp5432072"></a>4.7.1. Importancia de los ficheros de cabecera</h3></div></div></div><p>
	Cuando se usa función de una librería, C le permite la
	posibilidad de ignorar el fichero de cabecera y simplemente
	declarar la función a mano. En el pasado, la gente hacía eso a
	veces para acelerar un poquito la compilación evitando la
	tarea de abrir e incluir el fichero (eso no supone ventaja
	alguna con los compiladores modernos). Por ejemplo, la
	siguiente es una declaración extremadamente vaga de la función
	<code class="function">printf()</code> (de
	<code class="filename">&lt;stdio.h&gt;</code>):
      </p><pre class="programlisting">
<span class="hl kwd">printf</span><span class="hl opt">(...);</span>
</pre><p>
	Estos puntos suspensivos <sup>[<a id="idp5434552" href="#ftn.idp5434552" class="footnote">49</a>]</sup> especifican una <span class="emphasis"><em>lista de argumentos
	variable</em></span>
	<sup>[<a id="idp5435384" href="#ftn.idp5435384" class="footnote">50</a>]</sup>,

	que dice: la <code class="function">printf()</code> tiene algunos
	argumentos, cada uno con su tipo, pero no se sabe
	cuales. Simplemente, coge los argumentos que veas y
	aceptalos. Usando este tipo de declaración, se suspenden todas
	las comprobaciones de errores en los argumentos.
      </p><p>
	Esta práctica puede causar problemas sutiles. Si declara
	funciones «a mano», en un fichero puede cometer
	un error. Dado que el compilador sólo verá las declaraciones
	hechas a mano en ese fichero, se adaptará al error. El
	programa enlazará correctamente, pero el uso de la función en
	ese fichero será defectuoso. Se trata de un error difícil de
	encontrar, y que se puede evitar fácilmente usando el fichero
	de cabecera correspondiente.
      </p><p>
	Si se colocan todas las declaraciones de funciones en un fichero
	de cabecera, y se incluye ese fichero allí donde se use la
	función se asegurará una declaración consistente a través del
	sistema completo. También se asegurará de que la declaración y
	la definición corresponden incluyendo el fichero de cabecera en
	el fichero de definición.
      </p><p>
	Si declara una <code class="keyword">struct</code> en un fichero de cabecera en
	C++, <span class="emphasis"><em>debe</em></span> incluir ese fichero allí donde
	se use una <code class="keyword">struct</code> y también donde se definan los
	métodos de la <code class="keyword">struct</code>. El compilador de C++ devolverá
	un mensaje de error si intenta llamar a una función, o llamar
	o definir un método, sin declararla primero. Imponiendo el uso
	apropiado de los ficheros de cabecera, el lenguaje asegura la
	consistencia de las librerías, y reduce el número de error
	forzando que se use la misma interface en todas partes.
      </p><p>
	El fichero de cabecera es un contrato entre el programador de
	la librería y el que la usa. El contrato describe las
	estructuras de datos, expone los argumentos y valores de
	retorno para las funciones. Dice, «Esto es lo que hace
	mi librería». El usuario necesita parte de esta
	información para desarrollar la aplicación, y el compilador
	necesita toda ella para generar el código correcto. El usuario
	de la <code class="keyword">struct</code> simplemente incluye el fichero de
	cabecera, crea objetos (instancias) de esa <code class="keyword">struct</code>, y
	enlaza con el módulo objeto o librería (es decir, el código
	compilado)
      </p><p>
	El compilador impone el contrato obligando a declarar todas
	las estruturas y funciones antes que puedan ser usadas y, en
	el caso de métodos, antes de ser definidos. De ese modo, se le
	obliga a poner las declaraciones en el fichero de cabecera e
	incluirlo en el fichero en el que se definen los métodos y en
	los ficheros en los que se usen. Como se incluye un único
	fichero que describe la librería para todo el sistema, el
	compilador puede asegurar la consistencia y evitar errores.
      </p><p>
	Hay ciertos asuntos a los que debe prestar atención para
	organizar su código apropiadamente y escribir ficheros de
	cabecera eficaces. La regla básica es «únicamente
	declaraciones», es decir, sólo información para el
	compiladore pero nada que requiera alojamiento en memoria ya
	sea generando código o creando variables. Esto es así porque
	el fichero de cabecera normalmente se incluye en varias
	unidades de traducción en un mismo proyecto, y si el
	almacenamiento para un identificador se pide en más de un
	sitio, el enlazador indicará un error de definición múltiple
	(ésta es la <span class="emphasis"><em>regla de definición única</em></span> de
	C++: Se puede declarar tantas veces como se quiera, pero sólo
	puede haber una definición real para cada cosa).
      </p><p>
	Esta norma no es completamente estricta. Si se define una
	variable que es «file static» (que tiene
	visibilidad sólo en un fichero) dentro de un fichero de
	cabecera, habrá múltiples instancias de ese dato a lo largo
	del proyecto, pero no causará un colisión en el enlazador
	<sup>[<a id="idp5448848" href="#ftn.idp5448848" class="footnote">51</a>]</sup>. Básicamente, debe evitar cualquier cosa en los
	ficheros de cabecera que pueda causar una ambigüedad en tiempo
	de enlazado.
      </p></div><div class="sect2" title="4.7.2. El problema de la declaración múltiple"><div class="titlepage"><div><div><h3 class="title"><a id="idp5450024"></a>4.7.2. El problema de la declaración múltiple</h3></div></div></div><p>
	La segunda cuestión respecto a los ficheros de cabecera es ésta:
	cuando se pone una declaración de <code class="keyword">struct</code> en
	un fichero de cabecera, es posible que el fichero sea incluido
	más de una vez en un programa complicado. Los iostreams son un
	buen ejemplo. Cada vez que una <code class="keyword">struct</code> hace
	E/S debe incluir uno de los ficheros de cabecera iostream. Si el
	fichero <code class="filename">cpp</code> sobre el que se está trabajando
	utiliza más de un tipo de <code class="keyword">struct</code> (típicamente
	incluyendo un fichero de cabecera para cada una), se está
	corriendo el riesgo de incluir el fichero
	<code class="filename">&lt;isotream&gt;</code> más de una vez y re-declarar
	los iostreams.
      </p><p>
	El compilador considera que la redeclaración de una estructura
	(eso es aplicable tando a las <code class="keyword">struct</code> como a las
	<code class="keyword">class</code>) es un error, dado que de otro modo, debería
	permitir el uso del mismo nombre para tipos diferentes. Para
	evitar este error cuando se incluyen múltiples ficheros de
	cabecera, es necesario dar algo de inteligencia a los ficheros
	de cabecera usando el preprocesador (los ficheros de cabecera
	estándares como <code class="filename">&lt;iostream&gt;</code> también
	tienen esta «inteligencia»).
      </p><p>
	Tanto C como C++ permiten redeclarar una función, siempre que
	las dos declaraciones coincidan, pero ni en ese caso se
	permite la redeclaración de una estructura. En C++ esta regla
	es especialmente importante porque si el compilador permitiera
	la redeclaración de una estructura y las dos declaraciones
	difirieran, ¿cuál debería usar?
      </p><p>
	El problema de la redeclaración se agrava un poco en C++ porque
	cada tipo de dato (estructura con funciones) generalmente tiene
	su propio fichero de cabecera, y hay que incluir un fichero de
	cabecera en otro si se quiere crear otro tipo de dato que use al
	primero. Es probable que en algún fichero
	<code class="filename">cpp</code> de su proyecto, que se incluyan varios
	ficheros que incluyan al mismo fichero de cabecera. Durante una
	compilación simple, el compilador puede ver el mismo fichero de
	cabecera varias veces. A menos que se haga algo al respecto, el
	compilador verá la redeclaración de la estructura e informará un
	error en tiempo de compilación. Para resolver el problema,
	necesitará saber un poco más acerca del preprocesador.
      </p></div><div class="sect2" title="4.7.3. Las directivas del preprocesador #define, #ifndef y #endif"><div class="titlepage"><div><div><h3 class="title"><a id="idp5459480"></a>4.7.3. 
	Las directivas del preprocesador #define, #ifndef y #endif
      </h3></div></div></div><p>
	La directiva de preprocesador <code class="keyword">#define</code> se
	puede usar para crear banderas en tiempo de compilación. Tiene
	dos opciones: puede simplemente indicar al preprocesador que la
	bandera está definida, sin especificar un valor:
      </p><pre class="programlisting">
<span class="hl ppc">#define FLAG</span>
</pre><p>
	o puede darle un valor (que es la manera habitual en C para
	definir una constante):
      </p><pre class="programlisting">
<span class="hl ppc">#define PI 3.14159</span>
</pre><p>
	En cualquier caso, ahora el preprocesador puede comprobar si la
	etiqueta ha sido definida:
      </p><pre class="programlisting">
<span class="hl ppc">#ifdef FLAG</span>
</pre><p>
	Esto producirá un resultado verdadero, y el código que sigue
	al <code class="keyword">#ifdef</code> se incluirá en el paquete que se envía al
	compilador. Esta inclusión acaba cuando el preprocesador
	encuentra la sentencia:
      </p><pre class="programlisting">
<span class="hl ppc">#endif</span>
</pre><p>
	o
      </p><pre class="programlisting">
<span class="hl ppc">#endif</span> <span class="hl slc">// FLAG</span><span class="hl ppc"></span>
</pre><p>
	Cualquier cosa después de <code class="keyword">#endif</code> en la misma
	línea que no sea un comentario es ilegal, incluso aunque
	algunos compiladores lo acepten. Los pares
	<code class="keyword">#ifdef</code>/<code class="keyword">#endif</code> se pueden
	anidar.
      </p><p>
	El complementario de <code class="keyword">#define</code> es <code class="keyword">#undef</code>
	(abreviación de «un-define» que hará que una
	sentencia <code class="keyword">#ifdef</code> que use la misma variable produzca
	un resultado falso. <code class="keyword">#undef</code> también causará que el
	preprocesador deje de usar una macro. El complementario de
	<code class="keyword">#ifdef</code> es <code class="keyword">#ifndef</code>, que producirá verdadero
	si la etiqueta no ha sido definida (éste es el que usaremos en
	los ficheros de cabecera).
      </p><p>
	Hay otras características útiles en el preprocesador de
	C. Consulte la documentación de su preprocesador para ver todas
	ellas.
      </p></div><div class="sect2" title="4.7.4. Un estándar para los ficheros de cabecera"><div class="titlepage"><div><div><h3 class="title"><a id="idp5471272"></a>4.7.4. Un estándar para los ficheros de cabecera</h3></div></div></div><p>
	En cada fichero de cabecera que contiene una estructura,
	primero debería comprobar si ese fichero ya ha sido includo en
	este fichero <code class="filename">cpp</code> particular. Hágalo
	comprobando una bandera del preprocesador. Si la bandera no
	está definida, el fichero no se ha incluido aún, y se debería
	definir la bandera (de modo que la estructura no se pueda
	redeclarar) y declarar la estructura. Si la bandera estaba
	definida entonces el tipo ya ha sido declarado de modo que
	debería ignorar el código que la declara. Así es como debería
	ser un fichero de cabecera:
      </p><pre class="programlisting">
<span class="hl ppc">#ifndef HEADER_FLAG</span>
    <span class="hl ppc">#define HEADER_FLAG</span>
    <span class="hl slc">// Escriba la declaración aquí...</span>
    <span class="hl ppc">#endif</span> <span class="hl slc">// HEADER_FLAG</span><span class="hl ppc"></span>
</pre><p>
	Como puede ver, la primera vez que se incluye el fichero de
	cabecera, los contenidos del fichero (incluyendo la
	declaración del tipo) son incluidos por el preprocesador. Las
	demás veces que se incluya -en una única unidad de
	programación- la declaración del tipo será ignorada. El nombre
	<code class="varname">HEADER_FLAG</code> puede ser cualquier nombre
	único, pero un estándar fiable a seguir es poner el nombre del
	fichero de cabecera en mayúsculas y reemplazar los puntos por
	guiones bajos (sin embargo, el guión bajo al comienzo está
	reservado para nombres del sistema). Este es un ejemplo:
      </p><div class="example"><a id="idp5475328"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Simple.h</span>
<span class="hl slc">// Simple header that prevents re-definition</span>
<span class="hl ppc">#ifndef SIMPLE_H</span>
<span class="hl ppc">#define SIMPLE_H</span>

<span class="hl kwb">struct</span> Simple <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span>j<span class="hl opt">,</span>k<span class="hl opt">;</span>
  <span class="hl kwd">initialize</span><span class="hl opt">() {</span> i <span class="hl opt">=</span> j <span class="hl opt">=</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// SIMPLE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.8. C04/Simple.h</strong></p></div><br class="example-break" /><p>
	Aunque el <code class="varname">SIMPLE_H</code> después de
	<code class="keyword">#endif</code> está comentado y es ignorado por el
	preprocesador, es útil para documentación.
      </p><p>
	Estas sentencias del preprocesador que impiden inclusiones
	múltiples se denominan a menudo <span class="emphasis"><em>guardas de
	inclusión</em></span> (<span class="emphasis"><em>include guards</em></span>)
      </p></div><div class="sect2" title="4.7.5. Espacios de nombres en los ficheros de cabecera"><div class="titlepage"><div><div><h3 class="title"><a id="idp5478480"></a>4.7.5. Espacios de nombres en los ficheros de cabecera</h3></div></div></div><p>
	Notará que las <span class="emphasis"><em>directivas using</em></span> están
	presentes en casi todos los ficheros <code class="filename">cpp</code>
	de esto libro, normalmente en la forma:
      </p><pre class="programlisting">
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
</pre><p>
	Como <code class="classname">std</code> es el espacio
	de nombres que encierra la librería Estándar C++ al completo,
	esta directiva <code class="keyword">using</code> en particular permite
	que se puedan usar los nombres de la librería Estándar
	C++. Sin embargo, casi nunca verá una directiva
	<code class="keyword">using</code> en un fichero de cabecera (al menos,
	no fuera de un bloque). La razón es que la directiva
	<code class="keyword">using</code> elimina la protección de ese espacio
	de nombres en particular, y el efecto dura hasta que termina
	la unidad de compilación actual. Si pone una directiva
	<code class="keyword">using</code> (fuera de un bloque) en un fichero de
	cabecera, significa que esta perdida de «protección del
	espacio de nombres» ocurrirá con cualquier fichero que
	incluya este fichero de cabecera, lo que a menudo significa
	otros ficheros de cabecera, es muy fácil acabar
	«desactivando» los espacios de nombres en todos
	sitios, y por tanto, neutralizando los efectos beneficiosos de
	los espacios de nombres.
      </p><p>
	En resumen: no ponga directivas <code class="keyword">using</code> en
	ficheros de cabecera.
      </p></div><div class="sect2" title="4.7.6. Uso de los ficheros de cabecera en proyectos"><div class="titlepage"><div><div><h3 class="title"><a id="idp5485480"></a>4.7.6. Uso de los ficheros de cabecera en proyectos</h3></div></div></div><p>
	Cuando se construye un proyecto en C++, normalmente lo creará
	poniendo juntos un montón de tipos diferentes (estructuras de
	datos con funciones asociadas). Normalmente pondrá la
	declaración para cada tipo o grupo de tipos asociados en un
	fichero de cabecera separado, entonces definirá las funciones
	para ese tipo en una unidad de traducción. Cuando use ese tipo,
	deberá incluir el fichero de cabecera para efectuar las
	declaraciones apropiadamente.
      </p><p>
	A veces ese patrón se seguirá en este libro, pero más a menudo
	los ejemplos serán muy pequeños, así que todo - la declaración
	de las estructuras, la definición de las funciones, y la función
	<code class="function">main()</code> - pueden aparecer en un único
	fichero. Sin embargo, tenga presente que debería usar ficheros
	separados y ficheros de cabecera para aplicaciones reales.
      </p></div></div><div class="sect1" title="4.8. Estructuras anidadas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5488200"></a>4.8. Estructuras anidadas</h2></div></div></div><p>
      La conveniencia de coger nombres de funciones y datos fuera del
      espacio de nombre global es aplicable a las estructuras. Puede
      anidar una estructura dentro de otra estructura, y por tanto
      guardar juntos elementos asociados. La sintaxis de declaración
      es la que podría esperarse, tal como puede ver en la siguiente
      estructura, que implementa una pila como una lista enlazada
      simple de modo que «nunca» se queda sin memoria.
    </p><div class="example"><a id="idp5489872"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Stack.h</span>
<span class="hl slc">// Nested struct in linked list</span>
<span class="hl ppc">#ifndef STACK_H</span>
<span class="hl ppc">#define STACK_H</span>

<span class="hl kwb">struct</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    <span class="hl kwb">void</span><span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">);</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STACK_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.9. C04/Stack.h</strong></p></div><br class="example-break" /><p>
      La <code class="keyword">struck</code> anidada se llama <code class="type">Link</code>, y
      contiene un puntero al siguiente <code class="type">Link</code> en la lista y
      un puntero al dato almacenado en el <code class="type">Link</code>. Si el
      siguiente puntero es cero, significa que es el último elemento
      de la lista.
    </p><p>
      Fíjese que el puntero <code class="varname">head</code> está definido a la
      derecha después de la declaración de la <code class="keyword">struct</code>
      <code class="type">Link</code>, es lugar de una definición separada
      <code class="code">Link* head</code>. Se trata de una sintaxis que viene de
      C, pero que hace hincapié en la importancia del punto y coma
      después de la declaración de la estructura; el punto y coma
      indica el fin de una lista de definiciones separadas por comas
      de este tipo de estructura (Normalmente la lista está vacía.)
    </p><p>
      La estructura anidada tiene su propia función
      <code class="function">initialize()</code>, como todas las estructuras
      hasta el momento, para asegurar una inicialización
      adecuada. <code class="classname">Stack</code> tiene tanto función
      <code class="function">initialice()</code> como
      <code class="function">cleanup()</code>, además de
      <code class="function">push()</code>, que toma un puntero a los datos que
      se desean almacenar (asume que ha sido alojado en el montículo),
      y <code class="function">pop()</code>, que devuelve el puntero
      <code class="varname">data</code> de la cima de la
      <code class="classname">Stack</code> y elimina el elemento de la
      cima. (El que hace <code class="function">pop()</code> de un elemento se
      convierte en responsable de la destrucción del objeto apuntado
      por <code class="varname">data</code>.) La función
      <code class="function">peak()</code> también devuelve un puntero
      <code class="varname">data</code> a la cima de la pila, pero deja el
      elemento en la <code class="classname">Stack</code>.
    </p><p>
      Aquí se muestran las definiciones de los métodos:
    </p><div class="example"><a id="idp5500464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Stack.cpp {O}</span>
<span class="hl slc">// Linked list with nesting</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> 
Stack<span class="hl opt">::</span>Link<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">) {</span>
  data <span class="hl opt">=</span> dat<span class="hl opt">;</span>
  next <span class="hl opt">=</span> nxt<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stack<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">() {</span> head <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>

<span class="hl kwb">void</span> Stack<span class="hl opt">::</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">) {</span>
  Link<span class="hl opt">*</span> newLink <span class="hl opt">=</span> <span class="hl kwa">new</span> Link<span class="hl opt">;</span>
  newLink<span class="hl opt">-&gt;</span><span class="hl kwd">initialize</span><span class="hl opt">(</span>dat<span class="hl opt">,</span> head<span class="hl opt">);</span>
  head <span class="hl opt">=</span> newLink<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stack<span class="hl opt">::</span><span class="hl kwd">peek</span><span class="hl opt">() {</span> 
  <span class="hl kwd">require</span><span class="hl opt">(</span>head <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Stack empty&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stack<span class="hl opt">::</span><span class="hl kwd">pop</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
  Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
  head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
  <span class="hl kwa">return</span> result<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stack<span class="hl opt">::</span><span class="hl kwd">cleanup</span><span class="hl opt">() {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Stack not empty&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.10. C04/Stack.cpp</strong></p></div><br class="example-break" /><p>
      La primera definición es particularmente interesante porque
      muestra cómo se define un miembro de una estructura
      anidada. Simplemente se usa un nivel adicional de resolución de
      ámbito para especificar el nombre de la <code class="keyword">struct</code>
      interna. <code class="methodname">Stack::Link::initialize()</code> toma
      dos argumentos y los asigna a sus atributos.
    </p><p>
      <code class="methodname">Stack::initialize()</code> asgina cero a
      <code class="varname">head</code>, de modo que el objeto sabe que
      tiene una lista vacía.
    </p><p>
      <code class="methodname">Stack::push()</code> toma el argumento, que es
      un puntero a la variable a la que se quiere seguir la pista, y la
      apila en la <code class="classname">Stack</code>. Primero, usa
      <code class="keyword">new</code> para pedir alojamiento para el
      <code class="classname">Link</code> que se insertará en la cima. Entonces
      llama a la función <code class="methodname">initialize()</code> para
      asignar los valores apropiados a los miembres del
      <code class="classname">Link</code>. Fijese que el siguiente puntero se
      asigna al <code class="varname">head</code> actual; entonces
      <code class="varname">head</code> se asigna al nuevo puntero
      <code class="classname">Link</code>. Esto apila eficazmente el
      <code class="classname">Link</code> en la cima de la lista.
    </p><p>
      <code class="methodname">Stack::pop()</code> captura el puntero
      <code class="varname">data</code> en la cima actual de la
      <code class="classname">Stack</code>; entonces mueve el puntero
      <code class="varname">head</code> hacia abajo y borra la anterior cima de
      la <code class="classname">Stack</code>, finalmente devuelve el puntero
      capturado. Cuando <code class="methodname">pop()</code> elemina el último
      elemento, <code class="varname">head</code> vuelve a ser cero, indicando que
      la <code class="classname">Stack</code> está vacía.
    </p><p>
      <code class="methodname">Stack::cleanup()</code> realmente no hace
      ninguna limpieza. En su lugar, establece una política firme que
      dice «el programador cliente que use este objeto
      <code class="classname">Stack</code> es responsable de des-apilar todos
      los elementos y borrarlos». <code class="function">require()</code>
      se usa para indicar que ha ocurrido un error de programación si la
      <code class="classname">Stack</code> no está vacía.
    </p><p>
      ¿Por qué no puede el destructor de <code class="classname">Stack</code>
      responsabilizarse de todos los objetos que el programador
      cliente no des-apiló? El problema es que la
      <code class="classname">Stack</code> está usando punteros
      <code class="type">void</code>, y tal como se verá en el <a class="link" href="#C13" title="13: Creación dinámica de objetos">Capítulo 13</a> usar <code class="keyword">delete</code> para un
      <code class="type">void*</code> no libera correctamente. El asunto de
      «quién es el responsable de la memoria» no siempre
      es sencillo, tal como veremos en próximos capítulos.
    </p><p>
      Un ejemplo para probar la <code class="classname">Stack</code>:
    </p><div class="example"><a id="idp5515920"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:StackTest.cpp</span>
<span class="hl slc">//{L} Stack</span>
<span class="hl slc">//{T} StackTest.cpp</span>
<span class="hl slc">// Test of nested linked list</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// File name is argument</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  Stack textlines<span class="hl opt">;</span>
  textlines<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">();</span>
  string line<span class="hl opt">;</span>
  <span class="hl slc">// Read file and store lines in the Stack:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Pop the lines from the Stack and print them:</span>
  string<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>s <span class="hl opt">= (</span>string<span class="hl opt">*)</span>textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  textlines<span class="hl opt">.</span><span class="hl kwd">cleanup</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.11. C04/StackTest.cpp</strong></p></div><br class="example-break" /><p>
      Es similar al ejemplo anterior, pero en este se apilan líneas
      de un fichero (como punteros a cadena) en la
      <code class="classname">Stack</code> y después los des-apila, lo que
      provoca que el fichero sea imprimido en orden inverso. Fíjese que
      <code class="methodname">pop()</code> devuelve un <code class="type">void*</code>
      que debe ser moldeado a <code class="type">string*</code> antes de poderse
      usar. Para imprimir una cadena, el puntero es dereferenciado.
    </p><p>
      Como <code class="varname">textlines</code> se llena, el contenido de
      <code class="varname">line</code> se «clona» para cada
      <code class="methodname">push()</code> creando un <code class="code">new
      string(line)</code>. El valor devuelto por la expresión
      <code class="keyword">new</code> es un puntero al nuevo <code class="type">string</code> que fue
      creado y al que se ha copiado la información de la
      <code class="varname">line</code>. Si se hubiera pasado directamente la
      dirección de <code class="varname">line</code> a
      <code class="methodname">push()</code>, la <code class="classname">Stack</code>
      se llenaría con direcciones idénticas, todas apuntando a
      <code class="varname">line</code>. Más adelante en ese libro aprenderá más
      sobre este proceso de «clonación».
    </p><p>
      El nombre del fichero se toma de línea de comando. Para garantizar
      que hay suficientes argumentos en la línea de comando, se usa una
      segunda función del fichero de cabecera
      <code class="filename">require.h</code>: <code class="function">requireArgs()</code>
      que compara <code class="varname">argc</code> con el número de argumentos
      deseado e imprime un mensaje de error y termina el programa si no
      hay suficientes argumentos.
    </p><div class="sect2" title="4.8.1. Resolución de ámbito global"><div class="titlepage"><div><div><h3 class="title"><a id="idp5525848"></a>4.8.1. Resolución de ámbito global</h3></div></div></div><p>
	El operador de resolución de ámbito puede ayudar en situaciones
	en las que el nombre elegido por el compilador (el nombre
	«más cercano») no es el que se quiere. Por ejemplo,
	suponga que tiene una estructura con un identificador local
	<code class="varname">a</code>, y quiere seleccionar un identificador
	global <code class="varname">a</code> desde dentro de un método. El
	compilador, por defecto, elegirá el local, de modo que es
	necesario decirle que haga otra cosa. Cuando se quiere
	especificar un nombre global usando la resolución de ámbito,
	debe usar el operador sin poner nada delante de él. A
	continuación aparece un ejemplo que muestra la resolución de
	ámbito global tanto para una variable como para una función:
      </p><div class="example"><a id="idp5528112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Scoperes.cpp</span>
<span class="hl slc">// Global scope resolution</span>
<span class="hl kwb">int</span> a<span class="hl opt">;</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>

<span class="hl kwb">struct</span> S <span class="hl opt">{</span>
  <span class="hl kwb">int</span> a<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> S<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">() {</span>
  <span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">();</span>  <span class="hl slc">// Would be recursive otherwise!</span>
  <span class="hl opt">::</span>a<span class="hl opt">++;</span>  <span class="hl slc">// Select the global a</span>
  a<span class="hl opt">--;</span>    <span class="hl slc">// The a at struct scope</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span> S s<span class="hl opt">;</span> <span class="hl kwd">f</span><span class="hl opt">(); }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.12. C04/Scoperes.cpp</strong></p></div><br class="example-break" /><p>
	Sin resolución de ámbito en <code class="methodname">S::f()</code>, el
	compilador elegiría por defecto las versiones miembro para
	<code class="function">f()</code> y <code class="varname">a</code>.
      </p></div></div><div class="sect1" title="4.9. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5530552"></a>4.9. Resumen</h2></div></div></div><p>
      En este capítulo, ha aprendido lo fundamental de C++: que puede
      poner funciones dentro de las estructuras. Este nuevo tipo de
      estructura se llama <span class="emphasis"><em>tipo abstracto de dato</em></span>,
      y las variables que se crean usando esta estructura se llaman
      <span class="emphasis"><em>objetos</em></span>, o <span class="emphasis"><em>instancias</em></span>,
      de ese tipo. Invocar un método de una objeto se denomina
      <span class="emphasis"><em>enviar un mensaje</em></span> al objeto. La actividad
      principal en la programación orientada a objetos es el envío de
      mensajes a objetos.
    </p><p>
      Aunque empaquetar datos y funciones juntos es un benificio
      significativo para la organización del código y hace la librería
      sea más fácil de usar porque previene conflictos de nombres
      ocultando los nombres, hay mucho más que se puede hacer para
      tener programación más segura en C++. En el próximo capítulo,
      aprenderá cómo proteger algunos miembros de una <code class="keyword">struct</code>
      para que sólo el programador pueda manipularlos. Esto establece
      un límite claro entre lo que puede cambiar el usuario de la
      estructura y lo que sólo el programador puede cambiar.
    </p></div><div class="sect1" title="4.10. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5534768"></a>4.10. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  En la librería C estándar, la función
	  <code class="function">puts()</code> imprime un array de caracteres a
	  la consola (de modo que puede escribir
	  <code class="code">puts("Hola")</code>). Escriba un program C que use
	  <code class="function">puts()</code> pero que no incluya
	  <code class="filename">&lt;stdio.h&gt;</code> o de lo contrario declare
	  la función. Compile ese programa con su compilador de
	  C. (algunos compiladores de C++ no son programas distintos
	  de sus compiladores de C, es ese caso puede que necesite
	  averiguar que opción de línea de comando fuerza una
	  compilación C.)  Ahora compílelo con el compilador C++ y
	  preste atención a la diferencia.
	</p></li><li class="listitem"><p>
	  Cree una declaración de <code class="keyword">struct</code> con un único
	  método, entonces cree una definición para ese método. Cree un
	  objeto de su nuevo tipo de dato, e invoque el método.
	</p></li><li class="listitem"><p>
	  Cambie su solución al Ejercicio 2 para que la
	  <code class="keyword">struct</code> sea declarada en un fichero de
	  cabecera convenientemente «guardado», con la
	  definición en un fichero <code class="filename">cpp</code> y el
	  <code class="function">main()</code> en otro.
	</p></li><li class="listitem"><p>
	  Cree una <code class="keyword">struct</code> con un único atributo de
	  tipo entero, y dos funciones globales, cada una de las cuales
	  acepta un puntero a ese <code class="keyword">struct</code>. La primera
	  función tiene un segundo argumento de tipo entero y asigna
	  al entero de l  <code class="keyword">struct</code> el valor del
	  argumento, la segunda muestra el entero de la
	  <code class="keyword">struct</code>. Prueba las funciones.
	</p></li><li class="listitem"><p>
	  Repita el Ejercicio 4 pero mueva las función de modo que sean
	  métodos de la <code class="keyword">struct</code>, y pruebe de nuevo.
	</p></li><li class="listitem"><p>
	  Cree una clase que (de forma redundante) efectúe la
	  selección de atributos y una llamada a método usando la
	  palabra reservada <code class="keyword">this</code> (que indica a la dirección
	  del objeto actual)
	</p></li><li class="listitem"><p>
	  Cree una <code class="classname">Stach</code> que mantenga
	  <code class="type">doubles</code>. Rellénela con 25 valores
	  <code class="type">double</code>, después muéstrelos en consola.
	</p></li><li class="listitem"><p>
	  Repita el Ejercicio 7 con <code class="classname">Stack</code>.
	</p></li><li class="listitem"><p>
	  Cree un fichero que contenga una función
	  <code class="function">f()</code> que acepte un argumento entero y lo
	  imprima en consola usando la función
	  <code class="function">printf()</code> de
	  <code class="filename">&lt;stdio&gt;</code> escribiendo:
	  <code class="code">printf("%d\n", i)</code> donde <code class="varname">i</code> es
	  el entero que desea imprimir. Cree un fichero separado que
	  contenga <code class="function">main()</code>, y este fichero declare
	  <code class="function">f()</code> pero aceptando un argumento
	  <code class="type">float</code>. Invoque <code class="function">f()</code> desde
	  <code class="function">main()</code>. Intente compilar y enlazar el
	  programa con el compilador C++ y vea qué ocurre. Ahora
	  compile y enlace el programa usando el compilador C, y vea
	  que ocurre cuando se ejecuta. Explique el comportamiento.
	</p></li><li class="listitem"><p>
	  Averigüe cómo generar lenguaje ensamblador con su compilador C
	  y C++. Escriba una función en C y una
	  <code class="keyword">struct</code> con un único miembro en C++. Genere
	  la salida en lenguaje ensamblador para cada una de ellas y
	  encuentre los nombres de ambas funciones, de modo que pueda
	  ver qué tipo de «decoración» aplica el compilador
	  a dichos nombres.
	</p></li><li class="listitem"><p>
	  Escriba un programa con código condicionalmente-compilado en
	  <code class="function">main()</code>, para que cuando se defina un
	  valor del preprocesador, se muestre un mensaje, pero cuando no
	  se defina, se imprima otra mensaje distinto. Compile este
	  experimentando con un <code class="keyword">#define</code> en el
	  programa, después averigüe la forma de indicar al compilador
	  definiciones de preprocesador en la línea de comandos y
	  experimente con ello.
	</p></li><li class="listitem"><p>
	  Escriba un programa que use <code class="function">assert()</code> con
	  un argumento que siempre sea falso (cero) y vea que ocurre
	  cuando lo ejecuta. Ahora compílelo con <code class="code">#define
	  NDEBUG</code> y ejecútelo de nuevo para ver la
	  diferencia.
	</p></li><li class="listitem"><p>
	  Cree un tipo abstracto de dato que represente un cinta de
	  vídeo en una tienda de alquiler. Considere todos los datos y
	  operaciones que serían necesarias para que el tipo
	  <code class="classname">Video</code> funcione con el sistema de
	  gestión de la tienda. Incluya un método
	  <code class="methodname">print()</code> que muestre información sobre
	  el <code class="classname">Video</code>
	</p></li><li class="listitem"><p>
	  Cree un objeto <code class="classname">Pila</code> que almacene
	  objetos <code class="classname">Video</code> del Ejercicio 13. Cree
	  varios objetos <code class="classname">Video</code>, guárdelos en la
	  <code class="classname">Stack</code> y entonces muéstrelos usando
	  <code class="methodname">Video::print()</code>.
	</p></li><li class="listitem"><p>
	  Escriba un programa que muestre todos los tamaños de los tipos
	  de datos fundamentales de su computadora usando
	  <code class="literal">sizeof</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="classname">Stash</code> para usar
	  <code class="code">vector&lt;char&gt;</code> como
	  estructura de datos subyacente.
	</p></li><li class="listitem"><p>
	  Cree dinámicamente espacio de almacenamiento para los
	  siguiente tipos usando <code class="keyword">new</code>:
	  <code class="type">int</code>, <code class="type">long</code>, un array de 100
	  <code class="type">char</code>, un array de 100 <code class="type">float</code>. Muestre
	  sus direcciones y libérelos usando <code class="keyword">delete</code>.
	</p></li><li class="listitem"><p>
	  Escriba una función que tome un argumento
	  <code class="type">char*</code>. Usando <code class="keyword">new</code>, pida
	  alojamiento dinámico para un array de <code class="type">char</code> con un
	  tamaño igual al argumento pasado a la función. Usando
	  indexación de array, copie los caracteres del argumento al
	  array dinámico (no olvide el terminador nulo) y devuelva el
	  puntero a la copia. En su <code class="function">main()</code>, pruebe
	  la función pasando una cadena estática entre comillas, después
	  tome el resultado y páselo de nuevo a la función. Muestre
	  ambas cadenas y punteros para poder ver que tienen distinta
	  ubicación. Mediante <code class="keyword">delete</code> libere todo el
	  almacenamiento dinámico.
	</p></li><li class="listitem"><p>
	  Haga un ejemplo de estructura declarada con otra estructura
	  dentro (un estructura anidada). Declare atributos en ambas
	  <code class="keyword">structs</code>, y declare y defina métodos en
	  ambas <code class="keyword">structs</code>. Escriba un
	  <code class="function">main()</code> que pruebe los nuevos tipos.
	</p></li><li class="listitem"><p>
	  ¿Cómo de grande es una estructura? Escriba un trozo de código
	  que muestre el tamaño de varias estructuras. Cree estructuras
	  que tengan sólo atributos y otras que tengan atributos y
	  métodos. Después cree una estructura que no tenga ningún
	  miembro. Muestre los tamaños de todas ellas. Explique el
	  motivo del tamaño de la estructura que no tiene ningún
	  miembro.
	</p></li><li class="listitem"><p>
	  C++ crea automáticamente el equivalente de <code class="keyword">typedef</code>
	  para <code class="keyword">structs</code>, tal como ha visto en este
	  capítulo. También lo hace para las enumeraciones y las
	  uniones. Escriba un pequeño programa que lo demuestre.
	</p></li><li class="listitem"><p>
	  Cree una <code class="classname">Stack</code> que maneje
	  <code class="classname">Stash</code>es. Cada
	  <code class="classname">Stash</code> mantendrá cinco líneas
	  procedentes de un fichero. Cree las
	  <code class="classname">Stash</code> usando
	  <code class="keyword">new</code>. Lea un fichero en su
	  <code class="classname">Stack</code>, después muéstrelo en su forma
	  original extrayéndolo de la <code class="classname">Stack</code>.
	</p></li><li class="listitem"><p>
	  Modifique el Ejercicio 22 de modo que cree una estructura que
	  encapsule la <code class="classname">Stack</code> y las
	  <code class="classname">Stash</code>. El usuario sólo debería añadir y
	  pedir líneas a través de sus métodos, pero debajo de la
	  cubierta la estructura usa una
	  <code class="classname">Stack</code>(pila) de
	  <code class="classname">Stash</code>es.
	</p></li><li class="listitem"><p>
	  Cree una <code class="keyword">struct</code> que mantenga un
	  <code class="type">int</code> y un puntero a otra instancia de la misma
	  <code class="keyword">struct</code>. Escriba una función que acepte como
	  parámetro la dirección de una de estas
	  <code class="keyword">struct</code> y un <code class="type">int</code> indicando la
	  longitud de la lista que se desea crear. Esta función creará
	  una cadena completa de estas <code class="keyword">struct</code> (una
	  lista enlazada), empezando por el argumento (la cabeza de la
	  lista), con cada una apuntando a la siguiente. Cree las nuevas
	  <code class="keyword">struct</code> usando <code class="keyword">new</code>, y
	  ponga la posición (que número de objeto es) en el
	  <code class="type">int</code>. En la última <code class="keyword">struct</code> de la
	  lista, ponga un valor cero en el puntero para indicar que es
	  el último. Escriba una segunda función que acepte la cabeza de
	  la lista y la recorra hasta el final, mostrando los valores
	  del puntero y del <code class="type">int</code> para cada una.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 24, pero poniendo las funciones dentro de
	  una <code class="keyword">struct</code> en lugar de usar <code class="keyword">struct</code> y
	  funciones «crudas».
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp5233176" href="#idp5233176" class="para">46</a>] </sup>
          N de T:«Stash» se podría traducir como
          «Acumulador».
        </p></div><div class="footnote"><p><sup>[<a id="ftn.idp5262800" href="#idp5262800" class="para">47</a>] </sup>N. de T.: <span class="foreignphrase"><em class="foreignphrase">heap</em></span> se suele
	    traducir al castellano como «montón» o
	    «montículo».
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp5399824" href="#idp5399824" class="para">48</a>] </sup>
	  Este término puede causar debates. Algunas personas lo
          utilizan tal y como está definido aquí, aunque otras lo usan
          para describir el <span class="emphasis"><em>control de acceso</em></span>,
          término que se discutirá en el siguiente capítulo.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5434552" href="#idp5434552" class="para">49</a>] </sup>(N. de
	T. <span class="emphasis"><em>ellipsis</em></span>) en inglés)</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5435384" href="#idp5435384" class="para">50</a>] </sup>
	    Para escribir una definición de función que toma una lista
	    de argumentos realmente variable, debe usar
	    <span class="emphasis"><em>varargs</em></span>, aunque se debería evitar en
	    C++. Puede encontar información detallada sobre el uso de
	    <span class="emphasis"><em>varargs</em></span> en un manual de C.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp5448848" href="#idp5448848" class="para">51</a>] </sup>
	    Sin embargo, en C++ estándar «file static» es
	    una característica obsoleta.
	  </p></div></div></div><div class="chapter" title="5: Ocultar la implementación"><div class="titlepage"><div><div><h2 class="title"><a id="C05"></a>5: Ocultar la implementación</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp5590656">5.1. Establecer los límites</a></span></dt><dt><span class="sect1"><a href="#idp5596792">5.2. Control de acceso en C++</a></span></dt><dt><span class="sect1"><a href="#idp5614448">5.3. Amigos (friends)</a></span></dt><dt><span class="sect1"><a href="#idp5653936">5.4. Capa de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5661784">5.5. La clase</a></span></dt><dt><span class="sect1"><a href="#idp5692680">5.6. Manejo de clases</a></span></dt><dt><span class="sect1"><a href="#idp5713808">5.7. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5717448">5.8. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Una librería C típica contiene una estructura y una serie de
      funciones que actúan sobre esa estructura. Hasta ahora hemos visto
      cómo C++ toma funciones <span class="emphasis"><em>conceptualmente</em></span>
      asociadas y las asocia <span class="emphasis"><em>literalmente</em></span>
    </p></div><p>
    poniendo la declaración de la función dentro del dominio de la
    estructura, cambiando la forma en que se invoca a las funciones
    desde las estructuras, eliminando el paso de la dirección de la
    estructura como primer parámetro, y añadiendo un nuevo tipo al
    programa (de ese modo no es necesario crear un <code class="keyword">typedef</code>
    para la estructura).
  </p><p>
    Todo esto son mejoras, le ayuda a organizar su código haciéndolo
    más fácil de escribir y leer. Sin embargo, hay otros aspectos
    importantes a la hora de hacer que las librerías sean más
    sencillas en C++, especialmente los aspectos de seguridad y
    control. Este capítulo se centra en el tema de la frontera de las
    estructuras.
  </p><div class="sect1" title="5.1. Establecer los límites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5590656"></a>5.1. Establecer los límites</h2></div></div></div><p>
      En toda relación es importante tener fronteras que todas las
      partes respeten. Cuando crea una librería, establece una relación
      con el <span class="emphasis"><em>programador cliente</em></span> que la usa para
      crear un programa u otra librería.
    </p><p>
      En una estructura de C, como casi todo en C, no hay reglas. Los
      programadores cliente pueden hacer lo que quieran con esa
      estructura, y no hay forma de forzar un comportamiento
      particular. Por ejemplo, aunque vio en el capítulo anterior la
      importancia de las funciones llamadas
      <code class="function">initialize()</code> y <code class="function">cleanup()</code>, el
      programador cliente tiene la opción de no llamarlas. (Veremos una
      forma mejor de hacerlo en el capítulo siguiente.) Incluso si
      realmente prefiere que el programador cliente no manipule
      directamente algunos miembros de su estructura, en C no hay forma
      de evitarlo. Todo está expuesto al todo el mundo.
    </p><p>
      Hay dos razones para controlar el acceso a los miembros. La
      primera es no dejar que el programador cliente ponga las manos
      sobre herramientas que no debería tocar, herramientas que son
      necesarias para los entresijos del tipo definido, pero no parte
      del interfaz que el programador cliente necesita para resolver sus
      problemas particulares. Esto es realmente una ventaja para los
      programadores cliente porque así pueden ver lo que es realmente
      importante para ellos e ignorar el resto.
    </p><p>
      La segunda razón para el control de acceso es permitir al
      diseñador de la librería cambiar su funcionamiento interno sin
      preocuparse de como afectara al programador cliente. En el
      ejemplo <code class="classname">Stack</code> del capítulo anterior,
      podría querer solicitar espacio de almacenamiento en grandes
      trozos, para conseguir mayor velocidad, en vez de crear un nuevo
      espacio cada vez que un elemento es añadido. Si la interfaz y la
      implementación están claramente separadas y protegidas, puede
      hacerlo y forzar al programador cliente sólo a enlazar de
      nuevo sus programas.
    </p></div><div class="sect1" title="5.2. Control de acceso en C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5596792"></a>5.2. Control de acceso en C++</h2></div></div></div><p>
      C++ introduce tres nuevas palabras clave para establecer las
      fronteras de una estructura: <code class="keyword">public</code>, <code class="keyword">private</code> y
      <code class="keyword">protected.</code> Su uso y significado es bastante claro. Los
      <span class="emphasis"><em>especificadores de acceso</em></span> se usan solo en la
      declaración de las estructuras, y cambian las fronteras para todas
      las declaraciones que los siguen. Cuando use un especificador de
      acceso, debe ir seguido de «:»
    </p><p>
      <code class="keyword">public</code> significa que todas las declaraciones de
      miembros que siguen estarán accesibles para cualquiera. Los miembros
      <code class="keyword">public</code>son como miembros de una estructura. Por
      ejemplo, las siguientes declaraciones de estructuras son
      idénticas:
    </p><div class="example"><a id="idp5601456"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Public.cpp</span>
<span class="hl slc">// Public is just like C's struct</span>

<span class="hl kwb">struct</span> A <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">char</span> j<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> A<span class="hl opt">::</span><span class="hl kwd">func</span><span class="hl opt">() {}</span>

<span class="hl kwb">struct</span> B <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">char</span> j<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> B<span class="hl opt">::</span><span class="hl kwd">func</span><span class="hl opt">() {}</span>  

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  A a<span class="hl opt">;</span> B b<span class="hl opt">;</span>
  a<span class="hl opt">.</span>i <span class="hl opt">=</span> b<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span>j <span class="hl opt">=</span> b<span class="hl opt">.</span>j <span class="hl opt">=</span> <span class="hl str">'c'</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span>f <span class="hl opt">=</span> b<span class="hl opt">.</span>f <span class="hl opt">=</span> <span class="hl num">3.14159</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span><span class="hl kwd">func</span><span class="hl opt">();</span>
  b<span class="hl opt">.</span><span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.1. C05/Public.cpp</strong></p></div><br class="example-break" /><p>
      La palabra clave <code class="keyword">private</code>, por otro lado, significa que
      nadie podrá acceder a ese miembro excepto usted, el creador del
      tipo, dentro de los métodos de ese tipo. <code class="keyword">private</code> es una
      pared entre usted y el programador cliente; si alguien intenta
      acceder a un miembro <code class="keyword">private</code>, obtendrá un error en
      tiempo de compilación. En <code class="code">struct B</code> en el
      ejemplo anterior, podría querer hacer partes de la
      representación (es decir, los atributos) ocultos, accesibles
      solo a usted:
    </p><div class="example"><a id="idp5605424"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Private.cpp</span>
<span class="hl slc">// Setting the boundary</span>

<span class="hl kwb">struct</span> B <span class="hl opt">{</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  <span class="hl kwb">char</span> j<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> B<span class="hl opt">::</span><span class="hl kwd">func</span><span class="hl opt">() {</span>
  i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  j <span class="hl opt">=</span> <span class="hl str">'0'</span><span class="hl opt">;</span>
  f <span class="hl opt">=</span> <span class="hl num">0.0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  B b<span class="hl opt">;</span>
  b<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>    <span class="hl slc">// OK, public</span>
<span class="hl slc">//!  b.j = '1';  // Illegal, private</span>
<span class="hl slc">//!  b.f = 1.0;  // Illegal, private</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.2. C05/Private.cpp</strong></p></div><br class="example-break" /><p>
      Aunque <code class="function">func()</code> puede acceder a cualquier
      miembro de <code class="classname">B</code> (pues
      <code class="function">func()</code> en un miembro de
      <code class="classname">B</code>, garantizando así automáticamente el
      acceso), una función global ordinaria como
      <code class="function">main()</code> no puede. Por supuesto tampoco
      miembros de otras estructuras. Solo las funciones que
      pertenezcan a la declaración de la estructura (el
      «contrato») tendrán acceso a miembros
      <code class="keyword">private</code>.
    </p><p>
      No hay un orden fijo para los especificadores de acceso, y pueden
      aparecer más de una vez. Afectan a todos los miembros declarados
      después de ellos hasta el siguiente especificador.
    </p><div class="sect2" title="5.2.1. protected"><div class="titlepage"><div><div><h3 class="title"><a id="idp5610288"></a>5.2.1. <code class="keyword">protected</code></h3></div></div></div><p>
	Es el último que nos queda por ver, <code class="keyword">protected</code> actúa
	como <code class="keyword">private</code>, con una excepción de la que hablaremos
	más tarde: estructuras heredadas (que no pueden acceder a lo
	miembros privados) si tienen acceso a los miembros
	<code class="keyword">protected</code>. Todo esto se verá más claramente en el
	capítulo 14 cuando veamos la herencia. Con lo que sabe hasta
	ahora puede considerar <code class="keyword">protected</code> igual que
	<code class="keyword">private</code>.
      </p></div></div><div class="sect1" title="5.3. Amigos (friends)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5614448"></a>5.3. Amigos (friends)</h2></div></div></div><p>
      ¿Que pasa si explícitamente se quiere dar acceso a una función que
      no es miembro de la estructura? Esto se consigue declarando la
      función como <code class="keyword">friend</code> dentro de la declaración de
      la estructura. Es importante que la declaración de una función
      <code class="keyword">friend</code> se haga dentro de la declaración de la
      estructura pues usted (y el compilador) necesita ver la
      declaración de la estructura y todas las reglas sobre el tamaño y
      comportamiento de ese tipo de dato. Y una regla muy importante en
      toda relación es, «¿Quién puede acceder a mi parte
      privada?»
    </p><p>
      La clase controla que código tiene acceso a sus miembros. No hay
      ninguna manera mágica de «colarse» desde el
      exterior si no eres <code class="keyword">friend</code>; no puedes declarar una
      nueva clase y decir, «Hola, soy <code class="keyword">friend</code> de
      <code class="classname">Bob</code>» y esperar ver los miembros
      <code class="keyword">private</code> y <code class="keyword">protected</code> de
      <code class="classname">Bob</code>.
    </p><p>
      Puede declarar una función global como <code class="keyword">friend</code>, también
      puede declarar un método de otra estructura, o incluso una
      estructura completa, como <code class="keyword">friend</code>. Aquí hay un ejemplo:
    </p><div class="example"><a id="idp5622152"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Friend.cpp</span>
<span class="hl slc">// Friend allows special access</span>

<span class="hl slc">// Declaration (incomplete type specification):</span>
<span class="hl kwb">struct</span> X<span class="hl opt">;</span>

<span class="hl kwb">struct</span> Y <span class="hl opt">{</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>X<span class="hl opt">*);</span>
<span class="hl opt">};</span>

<span class="hl kwb">struct</span> X <span class="hl opt">{</span> <span class="hl slc">// Definition</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span>X<span class="hl opt">*,</span> <span class="hl kwb">int</span><span class="hl opt">);</span> <span class="hl slc">// Global friend</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">void</span> Y<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">(</span>X<span class="hl opt">*);</span>  <span class="hl slc">// Struct member friend</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">struct</span> Z<span class="hl opt">;</span> <span class="hl slc">// Entire struct is a friend</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> X<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">() {</span> 
  i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span>X<span class="hl opt">*</span> x<span class="hl opt">,</span> <span class="hl kwb">int</span> i<span class="hl opt">) {</span> 
  x<span class="hl opt">-&gt;</span>i <span class="hl opt">=</span> i<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Y<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">(</span>X<span class="hl opt">*</span> x<span class="hl opt">) {</span> 
  x<span class="hl opt">-&gt;</span>i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">struct</span> Z <span class="hl opt">{</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span>X<span class="hl opt">*</span> x<span class="hl opt">);</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> Z<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">() {</span> 
  j <span class="hl opt">=</span> <span class="hl num">99</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Z<span class="hl opt">::</span><span class="hl kwd">g</span><span class="hl opt">(</span>X<span class="hl opt">*</span> x<span class="hl opt">) {</span> 
  x<span class="hl opt">-&gt;</span>i <span class="hl opt">+=</span> j<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span>
  X x<span class="hl opt">;</span>
  x<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span> <span class="hl slc">// Direct data manipulation</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X x<span class="hl opt">;</span>
  Z z<span class="hl opt">;</span>
  z<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">(&amp;</span>x<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.3. C05/Friend.cpp</strong></p></div><br class="example-break" /><p>
      <code class="code">struct Y</code> tiene un método <code class="function">f()</code>
      que modifica un objeto de tipo <code class="classname">X</code>. Aquí
      hay un poco de lío pues en C++ el compilador necesita que usted
      declare todo antes de poder hacer referencia a ello, así
      <code class="code">struct Y</code> debe estar declarado antes de que su
      método <code class="function">Y::f(X*)</code> pueda ser declarado como
      <code class="keyword">friend</code> en <code class="code">struct X</code>. Pero para declarar
      <code class="function">Y::f(X*)</code>, <code class="code">struct X</code> debe estar
      declarada antes!
    </p><p>
      Aquí vemos la solución. Dese cuenta de que
      <code class="function">Y::f(X*)</code> toma como argumento la dirección
      de un objeto de tipo <code class="classname">X</code>. Esto es
      fundamental pues el compilador siempre sabe cómo pasar una
      dirección, que es de un tamaño fijo sin importar el tipo, aunque
      no tenga información del tamaño real. Si intenta pasar el objeto
      completo, el compilador necesita ver la definición completa de
      <code class="classname">X</code>, para saber el tamaño de lo que quiere
      pasar y cómo pasarlo, antes de que le permita declarar una
      función como <code class="function">Y::g(X)</code>.
    </p><p>
      Pasando la dirección de un <code class="classname">X</code>, el compilador le
      permite hacer una <span class="emphasis"><em>identificación de tipo
      incompleta</em></span> de <code class="classname">X</code> antes de declarar
      <code class="function">Y::f(X*)</code>. Esto se consigue con la declaración:
    </p><pre class="programlisting">
<span class="hl kwb">struct</span> X<span class="hl opt">;</span>
</pre><p>
      Esta declaración simplemente le dice al compilador que hay una
      estructura con ese nombre, así que es correcto referirse a ella
      siempre que sólo se necesite el nombre.
    </p><p>
      Ahora, en <code class="code">struct X</code>, la función
      <code class="function">Y::f(X*)</code> puede ser declarada como
      <code class="keyword">friend</code> sin problemas. Si intenta declararla antes de
      que el compilador haya visto la especificación completa de
      <code class="classname">Y</code>, habría dado un error. Esto es una
      restricción para asegurar consistencia y eliminar errores.
    </p><p>
      Fíjese en las otras dos funciones <code class="keyword">friend</code>. La
      primera declara una función global ordinaria
      <code class="function">g()</code> como <code class="keyword">friend</code>. Pero
      <code class="function">g()</code> no ha sido declarada antes como global!. Se
      puede usar <code class="keyword">friend</code> de esta forma para declarar
      la función y darle el estado de <code class="keyword">friend</code>
      simultáneamente. Esto se extiende a estructuras completas:
    </p><pre class="programlisting">
<span class="hl kwc">friend</span> <span class="hl kwb">struct</span> Z<span class="hl opt">;</span>
</pre><p>
      es una especificación incompleta del tipo <code class="classname">Z</code>, y
      da a toda la estructura el estado de <code class="keyword">friend</code>.
    </p><div class="sect2" title="5.3.1. Amigas anidadas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5638976"></a>5.3.1. Amigas anidadas</h3></div></div></div><p>
	Hacer una estructura anidada no le da acceso a los miembros
	privados. Para conseguir esto, se debe: primero, declarar (sin
	definir) la estructura anidada, después declararla como
	<code class="keyword">friend</code>, y finalmente definir la estructura. La
	definición de la estructura debe estar separada de su
	declaración como <code class="keyword">friend</code>, si no el compilador
	la vería como no miembro. Aquí hay un ejemplo:
      </p><div class="example"><a id="idp5641256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:NestFriend.cpp</span>
<span class="hl slc">// Nested friends</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span> <span class="hl slc">// memset()</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">const int</span> sz <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">;</span>

<span class="hl kwb">struct</span> Holder <span class="hl opt">{</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span>sz<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl kwb">struct</span> Pointer<span class="hl opt">;</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">struct</span> Pointer<span class="hl opt">;</span>
  <span class="hl kwb">struct</span> Pointer <span class="hl opt">{</span>
  <span class="hl kwc">private</span><span class="hl opt">:</span>
    Holder<span class="hl opt">*</span> h<span class="hl opt">;</span>
    <span class="hl kwb">int</span><span class="hl opt">*</span> p<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span>Holder<span class="hl opt">*</span> h<span class="hl opt">);</span>
    <span class="hl slc">// Move around in the array:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">next</span><span class="hl opt">();</span>
    <span class="hl kwb">void</span> <span class="hl kwd">previous</span><span class="hl opt">();</span>
    <span class="hl kwb">void</span> <span class="hl kwd">top</span><span class="hl opt">();</span>
    <span class="hl kwb">void</span> <span class="hl kwd">end</span><span class="hl opt">();</span>
    <span class="hl slc">// Access values:</span>
    <span class="hl kwb">int</span> <span class="hl kwd">read</span><span class="hl opt">();</span>
    <span class="hl kwb">void</span> <span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">);</span>
  <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">() {</span>
  <span class="hl kwd">memset</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> sz <span class="hl opt">*</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">(</span>Holder<span class="hl opt">*</span> rv<span class="hl opt">) {</span>
  h <span class="hl opt">=</span> rv<span class="hl opt">;</span>
  p <span class="hl opt">=</span> rv<span class="hl opt">-&gt;</span>a<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">next</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>p <span class="hl opt">&lt; &amp;(</span>h<span class="hl opt">-&gt;</span>a<span class="hl opt">[</span>sz <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">]))</span> p<span class="hl opt">++;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">previous</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>p <span class="hl opt">&gt; &amp;(</span>h<span class="hl opt">-&gt;</span>a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]))</span> p<span class="hl opt">--;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">top</span><span class="hl opt">() {</span>
  p <span class="hl opt">= &amp;(</span>h<span class="hl opt">-&gt;</span>a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">end</span><span class="hl opt">() {</span>
  p <span class="hl opt">= &amp;(</span>h<span class="hl opt">-&gt;</span>a<span class="hl opt">[</span>sz <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">read</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> <span class="hl opt">*</span>p<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Holder<span class="hl opt">::</span>Pointer<span class="hl opt">::</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
  <span class="hl opt">*</span>p <span class="hl opt">=</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Holder h<span class="hl opt">;</span>
  Holder<span class="hl opt">::</span>Pointer hp<span class="hl opt">,</span> hp2<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>

  h<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">();</span>
  hp<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">(&amp;</span>h<span class="hl opt">);</span>
  hp2<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">(&amp;</span>h<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    hp<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
    hp<span class="hl opt">.</span><span class="hl kwd">next</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  hp<span class="hl opt">.</span><span class="hl kwd">top</span><span class="hl opt">();</span>
  hp2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;hp = &quot;</span> <span class="hl opt">&lt;&lt;</span> hp<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">()</span>
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, hp2 = &quot;</span> <span class="hl opt">&lt;&lt;</span> hp2<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    hp<span class="hl opt">.</span><span class="hl kwd">next</span><span class="hl opt">();</span>
    hp2<span class="hl opt">.</span><span class="hl kwd">previous</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.4. C05/NestFriend.cpp</strong></p></div><br class="example-break" /><p>
	Una vez que <code class="classname">Pointer</code> está declarado, se
	le da acceso a los miembros privados de
	<code class="classname">Holder</code> con la sentencia:
      </p><pre class="programlisting">
<span class="hl kwc">friend</span> Pointer<span class="hl opt">;</span>
</pre><p>
	La estructura <code class="classname">Holder</code> contiene un array de
	enteros y <code class="classname">Pointer</code> le permite acceder a
	ellos. Como <code class="classname">Pointer</code> está fuertemente asociada
	con <code class="classname">Holder</code>, es comprensible que sea una
	estructura miembro de <code class="classname">Holder</code>. Pero como
	<code class="classname">Pointer</code> es una clase separada de
	<code class="classname">Holder</code>, puede crear más de una instancia en
	el <code class="function">main()</code> y usarlas para seleccionar
	diferentes partes del array. <code class="classname">Pointer</code> es una
	estructura en vez de un puntero de C, así que puede garantizar
	que siempre apuntará dentro de <code class="classname">Holder</code>.
      </p><p>
	La función de la librería estándar de C
	<code class="function">memset()</code> (en
	&lt;<code class="filename">cstring</code>&gt;) se usa en el programa
	por conveniencia. Hace que toda la memoria a partir de una
	determinada dirección (el primer argumento) se cargue con un
	valor particular (el segundo argumento) para
	<code class="varname">n</code> bytes a partir de la dirección donde se
	empezó (<code class="varname">n</code> es el tercer argumento). Por
	supuesto, se podría haber usado un bucle para hacer lo mismo,
	pero <code class="function">memset()</code> está disponible, bien
	probada (así que es más factible que produzca menos errores),
	y probablemente es más eficiente.
      </p></div><div class="sect2" title="5.3.2. ¿Es eso puro?"><div class="titlepage"><div><div><h3 class="title"><a id="idp5650440"></a>5.3.2. ¿Es eso puro?</h3></div></div></div><p>
	La definición de la clase le da la pista, mirando la clase se
	puede saber qué funciones tienen permiso para modificar su parte
	privada. Si una función es <code class="keyword">friend</code>, significa
	que no es miembro, pero que de todos modos se le quiere dar
	permiso para modificar la parte privada, y debe estar
	especificado en la definición de la clase para que todo el mundo
	pueda ver que esa es una de las funciones privilegiadas.
      </p><p>
	C++ es un lenguaje orientado a objetos híbrido, no es puro, y
	<code class="keyword">friend</code> fue añadido para solucionar algunos problemas
	que se presentaban en la práctica. Es bueno apuntar que esto
	hace al lenguaje menos «puro», pues C++ fue
	diseñado para ser pragmático, no para aspirar a un ideal
	abstracto.
      </p></div></div><div class="sect1" title="5.4. Capa de objetos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5653936"></a>5.4. Capa de objetos</h2></div></div></div><p>
      En el capítulo 4 se dijo que una <code class="keyword">struct</code> escrita para un
      compilador C y más tarde compilada en uno de C++ no
      cambiaría. Se refería básicamente a la estructura interna del
      objeto que surge de la <code class="keyword">struct</code>, es decir, la posición
      relativa en memoria donde se guardan los valores de las
      diferentes variables. Si el compilador C++ cambiase esta
      estructura interna, entonces el código escrito en C que hiciese
      uso del conocimiento de las posiciones de las variables
      fallaría.
    </p><p>
      Cuando se empiezan a usar los especificadores de acceso, se
      cambia al universo del C++, y las cosas cambian un poco. Dentro
      de un «bloque de acceso» (un grupo de declaraciones
      delimitado por especificadores de acceso), se garantiza que las
      variables se encontraran contiguas, como en C. Sin embargo, los
      bloques de acceso pueden no aparecer en el objeto en el mismo
      orden en que se declaran. Aunque el compilador normalmente
      colocará los bloques como los definió, no hay reglas sobre esto,
      pues una arquitectura hardware especifica y/o un sistema
      operativo puede tener soporte especifico para <code class="keyword">private</code> y
      <code class="keyword">protected</code> que puede requerir que estos bloques se
      coloquen en lugares específicos de la memoria. La especificación
      del lenguaje no quiere impedir este tipo de ventajas.
    </p><p>
      Los especificadores de acceso son parte de la estructura y no
      afectan a los objetos creados desde ésta. Toda la información de
      accesos desaparece antes de que el programa se ejecute; en
      general ocurre durante la compilación. En un programa en
      ejecución, los objetos son «zonas de
      almacenamiento» y nada más. Si realmente quiere, puede
      romper todas las reglas y acceder a la memoria directamente,
      como en C. C++ no está diseñado para prohibir hacer cosas
      salvajes. Solo le proporciona una alternativa mucho más fácil, y
      deseable.
    </p><p>
      En general, no es una buena idea hacer uso de nada que
      dependa de la implementación cuando se escribe un
      programa. Cuando necesite hacerlo, encapsúlelo en una
      estructura, así en caso de tener que portarlo se podrá
      concentrar en ella.
    </p></div><div class="sect1" title="5.5. La clase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5661784"></a>5.5. La clase</h2></div></div></div><p>
      El control de acceso se suele llamar también <span class="emphasis"><em>ocultación
      de la implementación</em></span>. Incluir funciones dentro de las
      estructuras (a menudo llamado encapsulación <sup>[<a id="idp5662816" href="#ftn.idp5662816" class="footnote">52</a>]</sup>) produce tipos de dato con
      características y comportamiento, pero el control de acceso pone
      fronteras en esos tipos, por dos razones importantes. La primera
      es para establecer lo que el programador cliente puede y no puede
      hacer. Puede construir los mecanismos internos de la estructura
      sin preocuparse de que el programador cliente pueda pensar que son
      parte de la interfaz que debe usar.
    </p><p>
      Esto nos lleva directamente a la segunda razón, que es separar
      la interfaz de la implementación. Si la estructura se usa en
      una serie de programas, y el programador cliente no puede hacer
      más que mandar mensajes a la interfaz pública, usted puede
      cambiar cualquier cosa privada sin que se deba modificar código
      cliente.
    </p><p>
      La encapsulación y el control de acceso, juntos, crean algo más
      que una estructura de C. Estamos ahora en el mundo de la
      programación orientada a objetos, donde una estructura describe
      una clase de objetos como describiría una clase de peces o
      pájaros: Cualquier objeto que pertenezca a esa clase compartirá
      esas características y comportamiento. En esto se ha convertido
      la declaración de una estructura, en una descripción de la forma
      en la que los objetos de este tipo serán y actuarán.
    </p><p>
      En el lenguaje OOP original, Simula-67, la palabra clave
      <code class="keyword">class</code> fue usada para describir un nuevo tipo
      de dato. Aparentemente esto inspiro a Stroustrup a elegir esa
      misma palabra en C++, para enfatizar que este era el punto clave
      de todo el lenguaje: la creación de nuevos tipos de dato que son
      más que solo estructuras de C con funciones. Esto parece
      suficiente justificación para una nueva palabra clave.
    </p><p>
      De todas formas, el uso de <code class="keyword">class</code> en C++ es
      casi innecesario. Es idéntico a <code class="keyword">struct</code> en
      todos los aspectos excepto en uno: <code class="keyword">class</code> pone
      por defecto <code class="keyword">private</code>, mientras que
      <code class="keyword">struct</code> lo hace a <code class="keyword">public</code>.
      Estas son dos formas de decir lo mismo:
    </p><div class="example"><a id="idp5670728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Class.cpp</span>
<span class="hl slc">// Similarity of struct and class</span>

<span class="hl kwb">struct</span> A <span class="hl opt">{</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> A<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">() {</span> 
  <span class="hl kwa">return</span> i <span class="hl opt">+</span> j <span class="hl opt">+</span> k<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span> A<span class="hl opt">::</span><span class="hl kwd">g</span><span class="hl opt">() {</span> 
  i <span class="hl opt">=</span> j <span class="hl opt">=</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl slc">// Identical results are produced with:</span>

<span class="hl kwc">class</span> B <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> B<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">() {</span> 
  <span class="hl kwa">return</span> i <span class="hl opt">+</span> j <span class="hl opt">+</span> k<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span> B<span class="hl opt">::</span><span class="hl kwd">g</span><span class="hl opt">() {</span> 
  i <span class="hl opt">=</span> j <span class="hl opt">=</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> 
<span class="hl opt">}</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  A a<span class="hl opt">;</span>
  B b<span class="hl opt">;</span>
  a<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> a<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">();</span>
  b<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> b<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.5. C05/Class.cpp</strong></p></div><br class="example-break" /><p>
      La clase (<code class="keyword">class</code>) en un concepto OOP fundamental en
      C++. Es una de la palabras clave que no se pondrán en negrita en
      este libro - es incomodo pues se repite mucho. El cambio a
      clases es tan importante que sospecho que Stroustrup hubiese
      preferido eliminar completamente <code class="keyword">struct</code>, pero la
      necesidad de compatibilidad con C no lo hubiese permitido.
    </p><p>
      Mucha gente prefiere crear clases a la manera <code class="keyword">struct</code> en
      vez de a la mánera <code class="keyword">class</code>, pues sustituye el
      «por-defecto-<code class="keyword">private</code>» de <code class="keyword">class</code>
      empezando con los elementos <code class="keyword">public</code>:
    </p><pre class="programlisting">
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">miembro_de_interfaz</span><span class="hl opt">();</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">miembro_privado</span><span class="hl opt">();</span>
    <span class="hl kwb">int</span> representacion_interna<span class="hl opt">;</span>
<span class="hl opt">};</span>
</pre><p>
      El porqué de esto es que tiene más sentido ver primero lo que
      más interesa, el programador cliente puede ignorar todo lo que
      dice <code class="keyword">private</code>. De hecho, la única razón de que
      todos los miembros deban ser declarados en la clase es que el
      compilador sepa como de grande son los objetos y pueda
      colocarlos correctamente, garantizando así la consistencia.
    </p><p>
      De todas formas, los ejemplos en este libro pondrán los miembros
      privados primero, así:
    </p><pre class="programlisting">
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
    <span class="hl kwb">void</span> <span class="hl kwd">private_function</span><span class="hl opt">();</span>
    <span class="hl kwb">int</span> internal_representation<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">interface_function</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
</pre><p>
	Alguna gente incluso decora sus nombres privados
      </p><pre class="programlisting">
<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
    <span class="hl kwb">int</span> mX<span class="hl opt">;</span>  <span class="hl slc">// &quot;Self-decorated&quot; name</span>
<span class="hl opt">};</span>
</pre><p>
      Como <code class="varname">mX</code> esta ya oculto para
      <code class="classname">Y</code>, la <span class="emphasis"><em>m</em></span> (de
      «miembro») es innecesaria. De todas formas, en
      proyectos con muchas variables globales (algo que debe evitar a
      toda costa, aunque a veces inevitable en proyectos existentes),
      es de ayuda poder distinguir variables globales de atributos en
      la definición de los métodos.
    </p><div class="sect2" title="5.5.1. Modificaciones en Stash para usar control de acceso"><div class="titlepage"><div><div><h3 class="title"><a id="idp5682112"></a>5.5.1. Modificaciones en <code class="classname">Stash</code> para usar
	control de acceso</h3></div></div></div><p>
	Tiene sentido coger el ejemplo del capítulo 4 y modificarlo
	para usar clases y control de acceso. Dese cuenta de cómo la
	parte de la interfaz a usar en la programación cliente está
	claramente diferenciada, así no hay posibilidad de que el
	programador cliente manipule accidentalmente parte de la clase
	que no debería.
      </p><div class="example"><a id="idp5683576"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Stash.h</span>
<span class="hl slc">// Converted to use access control</span>
<span class="hl ppc">#ifndef STASH_H</span>
<span class="hl ppc">#define STASH_H</span>

<span class="hl kwc">class</span> Stash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
  <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STASH_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 5.6. C05/Stash.h</strong></p></div><br class="example-break" /><p>
	La función <code class="function">inflate()</code> se ha hecho
	<code class="keyword">private</code> porque solo es usada por la función
	<code class="function">add()</code> y por tanto es parte de la
	implementación interna, no de la interfaz. Esto significa que,
	más tarde, puede cambiar la implementación interna para usar
	un sistema de gestión de memoria diferente.
      </p><p>
	Aparte del nombre del archivo include, la cabecera de antes es
	lo único que ha sido cambiado para este ejemplo. El fichero de
	implementación y de prueba son los mismos.
      </p></div><div class="sect2" title="5.5.2. Modificar Stack para usar control de acceso"><div class="titlepage"><div><div><h3 class="title"><a id="idp5687488"></a>5.5.2. Modificar <code class="classname">Stack</code> para usar control
	de acceso</h3></div></div></div><p>
	Como un segundo ejemplo, aquí está
	<code class="classname">Stack</code> convertido en clase. Ahora la
	estructura anidada es <code class="keyword">private</code>, lo que es bueno pues
	asegura que el programador cliente no tendrá que fijarse ni
	depender de la representación interna de
	<code class="classname">Stack</code>:
      </p><div class="example"><a id="idp5689592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Stack2.h</span>
<span class="hl slc">// Nested structs via linked list</span>
<span class="hl ppc">#ifndef STACK2_H</span>
<span class="hl ppc">#define STACK2_H</span>

<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    <span class="hl kwb">void</span><span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">);</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STACK2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 5.7. C05/Stack2.h</strong></p></div><br class="example-break" /><p>
	Como antes, la implementación no cambia por lo que no la
	repetimos aquí. El programa de prueba es también idéntico. La
	única cosa que ha cambiado es la robustez del interfaz de
	la clase. El valor real del control de acceso es prevenirle de
	traspasar las fronteras durante el desarrollo. De hecho, el
	compilador es el único que conoce los niveles de protección de
	los miembros de la clase. No hay información sobre el control
	de acceso añadida en el nombre del miembro que llega al
	enlazador. Todas las comprobaciones sobre protección son
	hechas por el compilador; han desaparecido al llegar a la
	ejecución.
      </p><p>
	Dese cuenta de que la interfaz presentada al programador
	cliente es ahora realmente la de una pila. Sucede que esta
	implementada como una lista enlazada, pero usted puede cambiar
	esto sin afectar a la forma en que los programas cliente
	interactúan con ella, o (más importante aun) sin afectar a una
	sola linea de su código.
      </p></div></div><div class="sect1" title="5.6. Manejo de clases"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5692680"></a>5.6. Manejo de clases</h2></div></div></div><p>
      El control de acceso en C++ le permite separar la interfaz de la
      implementación, pero la ocultación de la implementación es solo
      parcial. El compilador debe ver aún la declaración de todas las
      partes del objeto para poder crearlo y manipularlo
      correctamente. Podría imaginar un lenguaje de programación que
      requiriese solo la interfaz publica del objeto y permitiese que
      la implementación privada permaneciese oculta, pero C++ realiza
      comparación de tipos estáticamente (en tiempo de compilación)
      tanto como es posible. Esto significa que se dará cuenta lo
      antes posible de si hay un error. También significa que su
      programa será más eficiente. De todas formas, la inclusión de la
      implementación privada tiene dos efectos: la implementación es
      visible aunque no se pueda acceder a ella fácilmente, y puede
      causar recompilaciones innecesarias.
    </p><div class="sect2" title="5.6.1. Ocultar la implementación"><div class="titlepage"><div><div><h3 class="title"><a id="idp5695336"></a>5.6.1. Ocultar la implementación</h3></div></div></div><p>
	Algunos proyectos no pueden permitirse tener visible su
	implementación al publico. Puede dejar a la vista información
	estratégica en un fichero de cabecera de una librería que la
	compañía no quiere dejar disponible a los competidores. Puede
	estar trabajando en un sistema donde la seguridad sea clave -
	un algoritmo de encriptación, por ejemplo - y no quiere dejar
	ninguna pista en un archivo de cabecera que pueda ayudar a la
	gente a romper el código. O puede que su librería se encuentre
	en un ambiente «hostil», donde el programador
	accederá a los componentes privados de todas formas, usando
	punteros y conversiones. En todas estas situaciones, es de
	gran valor tener la estructura real compilada dentro de un
	fichero de implementación mejor que a la vista en un archivo
	de cabecera.
      </p></div><div class="sect2" title="5.6.2. Reducir la recompilación"><div class="titlepage"><div><div><h3 class="title"><a id="idp5697520"></a>5.6.2. Reducir la recompilación</h3></div></div></div><p>
	Su entorno de programación provocará una recompilación de un
	fichero si este se modifica, o si se modifica otro fichero del
	que depende, es decir, un archivo de cabecera que se haya
	incluido. Esto significa que cada vez que se haga un cambio
	en una clase, ya sea a la interfaz pública o a las
	declaraciones de los miembros privados, se provocará una
	recompilación de todo lo que incluya ese archivo de
	cabecera. Este efecto se conoce usualmente como <span class="emphasis"><em> el
	  problema de la clase-base frágil</em></span>. Para un proyecto
	grande en sus comienzos esto puede ser un gran problema pues
	la implementación suele cambiar a menudo; si el proyecto es
	muy grande, el tiempo de las compilaciones puede llegar a ser
	un gran problema.
      </p><p>
	La técnica para resolver esto se llama a veces
	<span class="emphasis"><em>clases manejador</em></span> o el «gato de
	Chesire» <sup>[<a id="idp5700192" href="#ftn.idp5700192" class="footnote">53</a>]</sup> - toda la información sobre
	la implementación desaparece excepto por un puntero, la
	"sonrisa".  El puntero apunta a una estructura cuya definición
	se encuentra en el fichero de implementación junto con todas
	las definiciones de las funciones miembro. Así, siempre que la
	interfaz no se cambie, el archivo de cabecera permanece
	inalterado. La implementación puede cambiar a su gusto, y sólo
	el fichero de implementación deberá ser recompilado y
	reenlazado con el proyecto.
      </p><p>
	Aquí hay un ejemplo que demuestra como usar esta técnica. El
	archivo de cabecera contiene solo la interfaz publica y un
	puntero de una clase especificada de forma incompleta:
      </p><div class="example"><a id="idp5702344"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Handle.h</span>
<span class="hl slc">// Handle classes</span>
<span class="hl ppc">#ifndef HANDLE_H</span>
<span class="hl ppc">#define HANDLE_H</span>

<span class="hl kwc">class</span> Handle <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Cheshire<span class="hl opt">;</span> <span class="hl slc">// Class declaration only</span>
  Cheshire<span class="hl opt">*</span> smile<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">read</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">change</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">);</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// HANDLE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 5.8. C05/Handle.h</strong></p></div><br class="example-break" /><p>
	Esto es todo lo que el programador cliente puede ver. La linea
      </p><pre class="programlisting">
<span class="hl kwb">struct</span> Cheshire<span class="hl opt">;</span>
</pre><p>
	es una <span class="emphasis"><em>especificación de tipo incompleta</em></span>
	o una <span class="emphasis"><em>declaración de clase</em></span> (una
	<span class="emphasis"><em>definición de clase</em></span> debe incluir el
	cuerpo de la clase). Le dice al compilador que
	<span class="emphasis"><em>Chesire</em></span> es el nombre de una estructura,
	pero no detalles sobre ella. Esta es información suficiente
	para crear un puntero a la estructura; no puede crear un
	objeto hasta que el cuerpo de la estructura quede definido. En
	esta técnica, el cuerpo de la estructura está escondido en el
	fichero de implementación:
      </p><div class="example"><a id="idp5706064"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Handle.cpp {O}</span>
<span class="hl slc">// Handle implementation</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Handle.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl slc">// Define Handle's implementation:</span>
<span class="hl kwb">struct</span> Handle<span class="hl opt">::</span>Cheshire <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> Handle<span class="hl opt">::</span><span class="hl kwd">initialize</span><span class="hl opt">() {</span>
  smile <span class="hl opt">=</span> <span class="hl kwa">new</span> Cheshire<span class="hl opt">;</span>
  smile<span class="hl opt">-&gt;</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Handle<span class="hl opt">::</span><span class="hl kwd">cleanup</span><span class="hl opt">() {</span>
  <span class="hl kwa">delete</span> smile<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Handle<span class="hl opt">::</span><span class="hl kwd">read</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> smile<span class="hl opt">-&gt;</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Handle<span class="hl opt">::</span><span class="hl kwd">change</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span>
  smile<span class="hl opt">-&gt;</span>i <span class="hl opt">=</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.9. C05/Handle.cpp</strong></p></div><br class="example-break" /><p>
	<span class="emphasis"><em>Chesire</em></span> es una estructura anidada, así
	que se debe ser definido con resolución de ámbito:
      </p><pre class="programlisting">
<span class="hl kwb">struct</span> Handle<span class="hl opt">::</span>Cheshire <span class="hl opt">{</span>
</pre><p>
	En <code class="function">Handle::initialize()</code>, se solicita
	espacio de almacenamiento para una estructura
	<code class="classname">Chesire</code>, y en
	<code class="function">Handle::cleanup()</code> se libera ese espacio.
	Este espacio se usa para almacenar todos los datos que
	estarían normalmente en la sección privada de la clase. Cuando
	compile <code class="filename">Handle.cpp</code>, esta definición de la
	estructura estará escondida en el fichero objeto donde nadie
	puede verla. Si cambia los elementos de
	<span class="emphasis"><em>Chesire</em></span>, el único archivo que debe ser
	recompilado es <code class="filename">Handle.cpp</code> pues el archivo
	de cabecera permanece inalterado.
      </p><p>
	El uso de <code class="classname">Handle</code> es como el uso de cualquier
	clase: incluir la cabecera, crear objetos, y mandar mensajes.
      </p><div class="example"><a id="idp5711824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:UseHandle.cpp</span>
<span class="hl slc">//{L} Handle</span>
<span class="hl slc">// Use the Handle class</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Handle.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Handle u<span class="hl opt">;</span>
  u<span class="hl opt">.</span><span class="hl kwd">initialize</span><span class="hl opt">();</span>
  u<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">();</span>
  u<span class="hl opt">.</span><span class="hl kwd">change</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  u<span class="hl opt">.</span><span class="hl kwd">cleanup</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.10. C05/UseHandle.cpp</strong></p></div><br class="example-break" /><p>
	La única cosa a la que el programador cliente puede
	acceder es a la interfaz publica, así que mientras la
	implementación sea lo único que cambie, el fichero anterior no
	necesita recompilarse. Así, aunque esto no es ocultación de
	implementación perfecta, es una gran mejora.
      </p></div></div><div class="sect1" title="5.7. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5713808"></a>5.7. Resumen</h2></div></div></div><p>
      El control de acceso en C++ ofrece un gran control al creador de
      la clase. Los usuarios de la clase pueden ver claramente lo que
      pueden usar y qué puede ignorar. Más importante aún es la
      posibilidad de asegurar que ningún programador cliente depende
      de ninguna parte de la implementación interna de la clase. Si
      sabe esto como creador de la clase, puede cambiar la
      implementación subyacente con la seguridad de que ningún
      programador cliente se verá afectado por los cambios, pues no
      pueden acceder a esa parte de la clase.
    </p><p>
      Cuando tenga la posibilidad de cambiar la implementación
      subyacente, no solo podrá mejorar su diseño más tarde, también
      tiene la libertad de cometer errores. No importa con qué cuidado
      planee su diseño, cometerá errores. Sabiendo que es
      relativamente seguro que cometerá esos errores, experimentará
      más, aprenderá más rápido, y acabará su proyecto antes.
    </p><p>
      La interfaz pública de una clase es lo que <span class="emphasis"><em>realmente
      ve</em></span> el programador cliente, así que es la parte de la
      clase más importante durante el análisis y diseño. Pero incluso
      esto le deja algo de libertad para el cambio. Si no consigue la
      interfaz correcta a la primera, puede añadir más funciones,
      mientras no quite ninguna que el programador cliente ya haya
      usado en su código.
    </p></div><div class="sect1" title="5.8. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5717448"></a>5.8. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Cree una clase con atributos y métodos <code class="keyword">public</code>,
	  <code class="keyword">private</code> y <code class="keyword">protected</code>. Cree un objeto de
	  esta clase y vea qué mensajes de compilación obtiene cuando
	  intenta acceder a los diferentes miembros de la clase.
	</p></li><li class="listitem"><p>
	  Escriba una estructura llamada <code class="classname">Lib</code>
	  que contenga tres objetos <code class="code">string a, b</code> y
	  <code class="varname">c</code>. En <code class="function">main()</code> cree un
	  objeto <code class="classname">Lib</code> llamado
	  <code class="varname">x</code> y asígnelo a <code class="code">x.a, x.b </code> y
	  <code class="code">x.c</code>. Imprima por pantalla sus valores. Ahora
	  reemplace <code class="varname">a, b </code> y <code class="varname">c</code>
	  con un array de cadenas <code class="code">s[3]</code>. Dese cuenta de
	  que su función <code class="function">main() </code> deja de
	  funcionar como resultado del cambio. Ahora cree una clase,
	  llámela <code class="classname">Libc</code> con tres cadenas como
	  datos miembro privados <code class="varname">a, b</code> y
	  <code class="varname">c</code>, y métodos <code class="function">seta()</code>,
	  <code class="function">geta()</code>, <code class="function">setb()</code>,
	  <code class="function">getb()</code>, <code class="function">setc()</code> y
	  <code class="function">getc()</code> para establecer y recuperar los
	  distintos valores. Escriba una función
	  <code class="function">main()</code> como antes. Ahora cambie las
	  cadenas privadas <code class="varname">a</code>, <code class="varname">b</code>
	  y <code class="varname">c</code> por un array de cadenas privado
	  <code class="code">s[3]</code>. Vea que ahora <code class="function">main()</code>
	  sigue funcionando.
	</p></li><li class="listitem"><p>
	  Cree una clase y una función <code class="keyword">friend</code>
	  global que manipule los datos privados de la clase.
	</p></li><li class="listitem"><p>
	  Escriba dos clases, cada una de ellas con un método que
	 reciba como argumento un puntero a un objeto de la otra
	 clase. Cree instancias de ambas clases en
	 <code class="function">main()</code> y llame a los métodos antes
	 mencionados de cada clase.
	</p></li><li class="listitem"><p>
	  Cree tres clases. La primera contiene miembros privados, y
	  declara como <code class="keyword">friend</code> a toda la segunda
	  estructura y a una función miembro de la tercera. En
	  <code class="function">main()</code> demuestre que todo esto funciona
	  correctamente.
	</p></li><li class="listitem"><p>
	  Cree una clase <code class="classname">Hen</code>. Dentro de ésta,
	  inserte una clase <code class="classname">Nest</code>. Y dentro de
	  ésta una clase <code class="classname">Egg</code>. Cada clase debe tener
	  un método <code class="function">display()</code>. En
	  <code class="function">main()</code>, cree una instancia de cada clase
	  y llame a la función <code class="function">display()</code> de cada
	  una.
	</p></li><li class="listitem"><p>
	  Modifique el ejercicio 6 para que
	  <code class="classname">Nest</code> y <code class="classname">Egg</code>
	  contengan datos privados. De acceso mediante <code class="keyword">friend</code>
	  para que las clases puedan acceder a los contenidos privados
	  de las clases que contienen.
	</p></li><li class="listitem"><p>
	  Cree una clase con atributos diseminados por numerosas
	  secciones <code class="keyword">public</code>, <code class="keyword">private</code> y
	  <code class="keyword">protected</code>. Añada el método
	  <code class="function">ShowMap()</code> que imprima por pantalla los
	  nombres de cada uno de esos atributos y su dirección de
	  memoria. Si es posible, compile y ejecute este programa con
	  más de un compilador y/o ordenador y/o sistema operativo
	  para ver si existen diferencias en las posiciones en
	  memoria.
	</p></li><li class="listitem"><p>
	  Copie la implementación y ficheros de prueba de
	  <code class="classname">Stash</code> del capítulo 4 para así poder
	  compilar y probar el <code class="filename">Stash.h</code> de este
	  capítulo.
	</p></li><li class="listitem"><p>
	  Ponga objetos de la clase <code class="classname">Hern</code>
	  definidos en el ejercicio 6 en un
	  <code class="classname">Stash</code>. Apunte a ellos e imprímalos
	  (si no lo ha hecho aún necesitará una función
	  <code class="function">Hen::print()</code>).
	</p></li><li class="listitem"><p>
	  Copie los ficheros de implementación y la prueba de
	  <code class="classname">Stack</code> del capítulo 4 y compile y
	  pruebe el <code class="filename">Stack2.h</code> de este capítulo.
	</p></li><li class="listitem"><p>
	  Ponga objetos de la clase <code class="classname">Hen</code> del
	  ejercicio 6 dentro de <code class="classname">Stack</code>. Apunte a
	  ellos e imprímalos (si no lo ha hecho aún, necesitara añadir
	  un <code class="function">Hen::print()</code>).
	</p></li><li class="listitem"><p>
	  Modifique <code class="classname">Chesire</code> en
	  <code class="filename">Handle.cpp</code>, y verifique que su entorno
	  de desarrollo recompila y reemplaza sólo este fichero, pero
	  no recompila <code class="filename">UseHandle.cpp</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase <code class="classname">StackOfInt</code> (una pila
	  que guarda enteros) usando la técnica «Gato de
	  Chesire» que esconda la estructura de datos de bajo
	  nivel que usa para guardar los elementos, en una clase
	  llamada <code class="classname">StackImp</code>. Implemente dos
	  versiones de <code class="classname">StackImp</code>: una que use un
	  array de longitud fija de enteros, y otra que use un
	  <code class="code">vector&lt;int&gt;</code>. Ponga un tamaño máximo para
	  la pila preestablecido, así no se tendrá que preocupar de
	  expandir el array en la primera versión. Fíjese que la clase
	  <code class="filename">StackOfInt.h</code> no tiene que cambiar con
	  <code class="classname">StackImp</code>.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp5662816" href="#idp5662816" class="para">52</a>] </sup>Como
      se dijo anteriormente, a veces el control de acceso se llama
      también encapsulación</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5700192" href="#idp5700192" class="para">53</a>] </sup>Este nombre se le atribuye a
	John Carolan, uno de los pioneros del C++, y por supuesto,
	Lewis Carroll. Esta técnica se puede ver también como una
	forma del tipo de diseño «puente», descrito en el
	segundo volumen.</p></div></div></div><div class="chapter" title="6: Inicialización y limpieza"><div class="titlepage"><div><div><h2 class="title"><a id="C06"></a>6: Inicialización y limpieza</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp5757608">6.1. Inicialización garantizada por el constructor</a></span></dt><dt><span class="sect1"><a href="#idp5772608">6.2. Limpieza garantizada por el destructor</a></span></dt><dt><span class="sect1"><a href="#idp5784800">6.3. Eliminación del bloque de definiciones</a></span></dt><dt><span class="sect1"><a href="#idp5816376">6.4. Stash con constructores y destructores</a></span></dt><dt><span class="sect1"><a href="#idp5837096">6.5. Stack con constructores y destructores</a></span></dt><dt><span class="sect1"><a href="#idp5856456">6.6. Inicialización de tipos agregados</a></span></dt><dt><span class="sect1"><a href="#idp5873720">6.7. Constructores por defecto</a></span></dt><dt><span class="sect1"><a href="#idp5885296">6.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5889272">6.9. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      El capitulo 4 constituye una mejora significativa en el uso de
      librerías tomando los diversos componentes de una librería C
      típica y encapsulándolos en una estructura (un tipo abstracto de
      dato, llamado <span class="emphasis"><em>clase</em></span> a partir de ahora).
    </p></div><p>
    Esto no sólo permite disponer de un único punto de entrada en un
    componente de librería, también oculta los nombres de las
    funciones con el nombre de la clase. Esto le da al diseñador de la
    clase la posibilidad de establecer límites claros que determinan
    qué cosas puede hacer el programador cliente y qué queda fuera de
    sus límites. Eso significa que los mecanismos internos de las
    operaciones sobre los tipos de datos están bajo el control y la
    discreción del diseñador de la clase, y deja claro a qué miembros
    puede y debe prestar atención el programador cliente.
  </p><p>
    Juntos, la encapsulación y el control de acceso representan un
    paso significativo para aumentar la sencillez de uso de las
    librerías. El concepto de «nuevo tipo de dato» que
    ofrecen es mejor en algunos sentidos que los tipos de datos que
    incorpora C. El compilador C++ ahora puede ofrecer garantías de
    comprobación de tipos para esos tipos de datos y así asegura un
    nivel de seguridad cuando se usan esos tipos de datos.
  </p><p>
    A parte de la seguridad, el compilador puede hacer mucho más por
    nosotros de lo que ofrece C. En éste y en próximos capítulos verá
    posibilidades adicionales que se han incluido en C++ y que hacen
    que los errores en sus programas casi salten del programa y le
    agarren, a veces antes incluso de compilar el programa, pero
    normalmente en forma de advertencias y errores en el proceso de
    compilación. Por este motivo, pronto se acostumbrará a la extraña
    situación en que un programa C++ que compila, funciona a la
    primera.
  </p><p>
    Dos de esas cuestiones de seguridad son la inicialización y la
    limpieza. Gran parte de los errores de C se deben a que el
    programador olvida inicializar o liberar una variable. Esto sucede
    especialmente con las librerías C, cuando el programador cliente
    no sabe como inicializar una estructura, o incluso si debe
    hacerlo. (A menudo las librerías no incluyen una función de
    inicialización, de modo que el programador cliente se ve forzado a
    inicializar la estructura a mano). La limpieza es un problema
    especial porque los programadores C se olvidan de las variables una
    vez que han terminado, de modo que omiten cualquier limpieza que
    pudiera ser necesaria en alguna estructura de la librería.
  </p><p>
    En C++. el concepto de inicialización y limpieza es esencial para
    facilitar el uso de las librerías y eliminar muchos de los errores
    sutiles que ocurren cuando el programador cliente olvida cumplir con
    sus actividades. Este capítulo examina las posibilidades de C++ que
    ayudan a garantizar una inicialización y limpieza apropiadas.
  </p><div class="sect1" title="6.1. Inicialización garantizada por el constructor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5757608"></a>6.1. Inicialización garantizada por el constructor</h2></div></div></div><p>
      Tanto la clase <code class="classname">Stash</code> como la
      <code class="classname">Stack</code> definidas previamente tienen una
      función llamada <code class="function">initialize()</code>. que como
      indica su nombre se debería llamar antes de usar el
      objeto. Desafortunadamente, esto significa que el programador
      cliente debe asegurar una inicialización apropiada. Los
      programadores cliente son propensos a olvidar detalles como la
      inicialización cuando tienen prisa por hacer que la librería
      resuelva sus problemas. En C++, la inicialización en demasiado
      importante como para dejársela al programador cliente. El
      diseñador de la clase puede garantizar la inicialización de cada
      objeto facilitando una función especial llamada
      <span class="emphasis"><em>constructor</em></span>. Si una clase tiene un constructor,
      el compilador hará que se llame automáticamente al constructor
      en el momento de la creación del objeto, antes de que el
      programador cliente pueda llegar a tocar el objeto. La
      invocación del constructor no es una opción para el programador
      cliente; es realizada por el compilador en el punto en el que se
      define el objeto.
    </p><p>
      El siguiente reto es cómo llamar a esta función. Hay dos
      cuestiones. La primera es que no debería ser ningún nombre que
      pueda querer usar para un miembro de la clase. La segunda es que
      dado que el compilador es el responsable de la invocación del
      constructor, siempre debe saber qué función llamar. La solución
      elegida por Stroustrup parece ser la más sencilla y lógica: el
      nombre del constructor es el mismo que el de la clase. Eso hace
      que tenga sentido que esa función sea invocada automáticamente en
      la inicialización.
    </p><p>
      Aquí se muestra un clase sencilla con un constructor:
    </p><pre class="programlisting">
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">();</span>  <span class="hl slc">// Constructor</span>
<span class="hl opt">};</span>
</pre><p>
      Ahora, se define un objeto,
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  X a<span class="hl opt">;</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span>
</pre><p>
      Lo mismo pasa si <code class="varname">a</code> fuese un entero: se pide
      alojamiento para el objeto. Pero cuando el programa llega al
      punto de ejecución en el que se define <code class="varname">a</code>, se
      invoca el constructor automáticamente. Es decir, el compilador
      inserta la llamada a <code class="methodname">X::X()</code> para el
      objeto <code class="varname">a</code> en el punto de la definición. Como
      cualquier método, el primer argumento (secreto) para el
      constructor es el puntero <code class="varname">this</code> - la dirección
      del objeto al que corresponde ese método. En el caso del
      constructor, sin embargo, <code class="varname">this</code> apunta a un
      bloque de memoria no inicializado, y el trabajo del constructor
      es inicializar esa memoria de forma adecuada.
    </p><p>
      Como cualquier función, el constructor puede tomar argumentos que
      permitan especificar cómo ha de crearse el objeto, dados unos
      valores de inicialización. Los argumentos del constructor son
      una especie de garantía de que todas las partes del objeto se
      inicializan con valores apropiados. Por ejemplo, si una clase
      <code class="classname">Tree</code><sup>[<a id="idp5766600" href="#ftn.idp5766600" class="footnote">54</a>]</sup> tiene un constructor que toma como argumento un único
      entero que indica la altura del árbol, entonces debe crear un
      objeto árbol como éste:
    </p><pre class="programlisting">
Tree <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl num">12</span><span class="hl opt">)</span>   <span class="hl slc">// árbol de 12 metros</span>
</pre><p>
      Si <code class="function">Tree(int)</code> es el único constructor, el
      compilador no le permitirá crear un objeto de otro modo. (En el
      próximo capítulo veremos cómo crear múltiples constructores y
      diferentes maneras para invocarlos.)
    </p><p>
      Y realmente un constructor no es más que eso; es una función
      con un nombre especial que se invoca automáticamente por el
      compilador para cada objeto en el momento de su creación. A pesar
      de su simplicidad, tiene un valor excepcional porque evita una
      gran cantidad de problemas y hace que el código sea más fácil de
      escribir y leer. En el fragmento de código anterior, por ejemplo,
      no hay una llamada explícita a ninguna función
      <code class="function">initilize()</code> que, conceptualmente es una
      función separada de la definición. En C++, la definición e
      inicialización son conceptos unificados - no se puede tener el uno
      si el otro.
    </p><p>
      Constructor y destructor son tipos de funciones muy inusuales:
      no tienen valor de retorno. Esto es distinto de tener valor de
      retorno <code class="type">void</code>, que indicaría que la función no
      retorna nada pero teniendo la posibilidad de hacer otra
      cosa. Constructores y destructores no retornan nada y no hay
      otra posibilidad. El acto de traer un objeto al programa, o
      sacarlo de él es algo especial, como el nacimiento o la muerte,
      y el compilador siempre hace que la función se llame a si misma,
      para asegurarse de que ocurre realmente. Si hubiera un valor de
      retorno, y usted pudiera elegir uno propio, el compilador no
      tendría forma de saber qué hacer con el valor retornado, o el
      programador cliente tendría que disponer de una invocación
      explícita del constructor o destructor, lo que eliminaría la
      seguridad.
    </p></div><div class="sect1" title="6.2. Limpieza garantizada por el destructor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5772608"></a>6.2. Limpieza garantizada por el destructor</h2></div></div></div><p>
      Como un programador C, a menudo pensará sobre lo importante de
      la inicialización, pero rara vez piensa en la limpieza. Después
      de todo, ¿qué hay que limpiar de un <code class="type">int</code>?
      Simplemente, olvidarlo. Sin embargo, con las librerías,
      «dejarlo pasar» en un objeto cuando ya no lo
      necesita no es seguro. Qué ocurre si ese objeto modifica algo en
      el hardware, o escribe algo en pantalla, o tiene asociado
      espacio en el montículo(heap). Si simplemente pasa de él, su
      objeto nunca logrará salir de este mundo. En C++, la limpieza es
      tan importante como la inicialización y por eso está garantizada
      por el destructor.
    </p><p>
      La sintaxis del destructor es similar a la del constructor: se
      usa el nombre de la clase como nombre para la función. Sin
      embargo, el destructor se distingue del constructor porque va
      precedido de una virgulilla (~). Además, el destructor nunca
      tiene argumentos porque la destrucción nunca necesita ninguna
      opción. Aquí hay una declaración de un destructor:
    </p><pre class="programlisting">
<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Y</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
</pre><p>
      El destructor se invoca automáticamente por el compilador cuando
      el objeto sale del ámbito. Puede ver dónde se invoca al constructor
      por el punto de la definición del objeto, pero la única evidencia
      de que el destructor fue invocado es la llave de cierre del ámbito
      al que pertenece el objeto. El constructor se invoca incluso
      aunque utilice <code class="keyword">goto</code> para saltar fuera del del
      ámbito (<code class="keyword">goto</code> sigue existiendo en C++ por
      compatibilidad con C.) Debería notar que un
      <code class="keyword">goto</code> no-local, implementado con las funciones
      <code class="function">setjmp</code> y <code class="function">longjmp()</code> de la
      librería estándar de C, evitan que el destructor sea
      invocado. (Eso es la especificación, incluso si su compilador no
      lo implementa de esa manera. Confiar un una característica que no
      está en la especificación significa que su código no será
      portable).
    </p><p>
      A continuación, un ejemplo que demuestra las características de
      constructores y destructores que se han mostrado hasta el momento.
    </p><div class="example"><a id="idp5780704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Constructor1.cpp</span>
<span class="hl slc">// Constructors &amp; destructors</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Tree <span class="hl opt">{</span>
  <span class="hl kwb">int</span> height<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Tree</span><span class="hl opt">(</span><span class="hl kwb">int</span> initialHeight<span class="hl opt">);</span>  <span class="hl slc">// Constructor</span>
  <span class="hl opt">~</span><span class="hl kwd">Tree</span><span class="hl opt">();</span>  <span class="hl slc">// Destructor</span>
  <span class="hl kwb">void</span> <span class="hl kwd">grow</span><span class="hl opt">(</span><span class="hl kwb">int</span> years<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">printsize</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

Tree<span class="hl opt">::</span><span class="hl kwd">Tree</span><span class="hl opt">(</span><span class="hl kwb">int</span> initialHeight<span class="hl opt">) {</span>
  height <span class="hl opt">=</span> initialHeight<span class="hl opt">;</span>
<span class="hl opt">}</span>

Tree<span class="hl opt">::~</span><span class="hl kwd">Tree</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside Tree destructor&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">printsize</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Tree<span class="hl opt">::</span><span class="hl kwd">grow</span><span class="hl opt">(</span><span class="hl kwb">int</span> years<span class="hl opt">) {</span>
  height <span class="hl opt">+=</span> years<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Tree<span class="hl opt">::</span><span class="hl kwd">printsize</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Tree height is &quot;</span> <span class="hl opt">&lt;&lt;</span> height <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;before opening brace&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">{</span>
    Tree <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl num">12</span><span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;after Tree creation&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    t<span class="hl opt">.</span><span class="hl kwd">printsize</span><span class="hl opt">();</span>
    t<span class="hl opt">.</span><span class="hl kwd">grow</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;before closing brace&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;after closing brace&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.1. C06/Constructor1.cpp</strong></p></div><br class="example-break" /><p>
      Y esta sería la salida del programa anterior:
    </p><pre class="screen">
antes de la llave de apertura
después de la creación de Tree
la altura del árbol es 12
antes de la llave de cierre
dentro del destructor de Tree
la altura del árbol es 16
después de la llave de cierre
</pre><p>
      Puede ver que el destructor se llama automáticamente al acabar el
      ámbito (llave de cierre) en el que está definido el objeto.
    </p></div><div class="sect1" title="6.3. Eliminación del bloque de definiciones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5784800"></a>6.3. Eliminación del bloque de definiciones</h2></div></div></div><p>
      En C, siempre se definen todas las variables al principio de cada
      bloque, justo después de la llave de apertura. Ése es un requisito
      habitual en los lenguajes de programación, y la razón que se da a
      menudo es que se considera «buenas prácticas de
      programación». En este tema, yo tengo mis sospechas. Eso
      siempre me pareció un inconveniente, como programador, volver al
      principio del bloque cada vez que necesitaba definir una nueva
      variable. También encuentro más legible el código cuando la
      definición de la variable está certa del punto donde se usa.
    </p><p>
      Quizá esos argumentos son estilísticos. En C++, sin embargo,
      existe un problema significativo si se fuerza a definir todos
      los objetos al comienzo un ámbito. Si existe un constructor,
      debe invocarse cuando el objeto se crea. Sin embargo, si el
      constructor toma uno o más argumentos, ¿cómo saber que se
      dispone de la información de inicialización al comienzo del
      ámbito? Generalmente no se dispone de esa información. Dado que
      C no tiene el concepto de privado, la separación entre
      definición e inicialización no es un problema. Además, C++
      garantiza que cuando se crea un objeto, es inicializado
      simultáneamente. Esto asegura que no se tendrán objetos no
      inicializados ejecutándose en el sistema. C no tiene cuidado, de
      hecho, C promueve esta práctica ya que obliga a que se definan
      las variables al comienzo de un bloque, antes de disponer de la
      información de inicialización necesaria <sup>[<a id="idp5788872" href="#ftn.idp5788872" class="footnote">55</a>]</sup>.
    </p><p>
      En general, C++ no permite crear un objeto antes de tener la
      información de inicialización para el constructor. Por eso, el
      lenguaje no sería factible si tuviera que definir variables al
      comienzo de un bloque. De hecho, el estilo del lenguaje parece
      promover la definición de un objeto tan cerca como sea posible
      del punto en el que se usa. En C++, cualquier regla que se
      aplica a un
      «objeto» automáticamente también se refiere a un
      objeto de un tipo básico. Esto significa que cualquier clase de
      objeto o variable de un tipo básico también se puede definir en
      cualquier punto del bloque. Eso también significa que puede
      esperar hasta disponer de la información para una variable antes
      de definirla, de modo que siempre puede definir e inicializar al
      mismo tiempo:
    </p><div class="example"><a id="idp5791376"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:DefineInitialize.cpp</span>
<span class="hl slc">// Defining variables anywhere</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> G <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">G</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">);</span>
<span class="hl opt">};</span>

G<span class="hl opt">::</span><span class="hl kwd">G</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;initialization value? &quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> retval <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> retval<span class="hl opt">;</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>retval <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> y <span class="hl opt">=</span> retval <span class="hl opt">+</span> <span class="hl num">3</span><span class="hl opt">;</span>
  G <span class="hl kwd">g</span><span class="hl opt">(</span>y<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.2. C06/DefineInitialize.cpp</strong></p></div><br class="example-break" /><p>
      Puede ver que se ejecuta parte del código, entonces se define
      <code class="varname">&gt;retval</code>, que se usa para capturar datos de la
      consola, y entonces se definen <code class="varname">y</code> y
      <code class="varname">g</code>. C, al contrario, no permite definir una
      variable en ningún sitio que no sea el comienzo de un bloque.
    </p><p>
      En general, debería definir las variables tan cerca como sea
      posible del punto en que se usa, e inicializarlas siempre cuando
      se definen. (Ésta es una sugerencia de estilo para tipos básicos,
      en los que la inicialización es opcional.) Es una cuestión de
      seguridad. Reduciendo la duración de disponibilidad al bloque,
      se reduce la posibilidad de que sea usada inapropiadamente en otra
      parte del bloque. En resumen, la legibilidad mejora porque el
      lector no teiene que volver al inicio del bloque para ver el tipo
      de una variable.
    </p><div class="sect2" title="6.3.1. Bucles for"><div class="titlepage"><div><div><h3 class="title"><a id="idp5795104"></a>6.3.1. Bucles <code class="keyword">for</code></h3></div></div></div><p>
	En C++, a menudo verá bucles <code class="keyword">for</code> con el
	contador definido dentro de la propia expresión.
      </p><pre class="programlisting">
<span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> j<span class="hl opt">++) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;j = &quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout  <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
</pre><p>
	Las sentencias anteriores son casos especiales importantes, que
	provocan confusión en los programadores novatos de C++.
      </p><p>
	Las variables <code class="varname">i</code> y <code class="varname">j</code> están
	definidas directamente dentro la expresión
	<code class="keyword">for</code> (algo que no se puede hacer en C). Esas
	variables están disponibles para usarlas en el bucle. Es una
	sintaxis muy conveniente porque el contexto disipa cualquier
	duda sobre el proposito de <code class="varname">i</code> y
	<code class="varname">j</code>, asi que no necesita utilizar nombres
	extraños como <code class="varname">contador_bucle_i</code> para quede
	más claro.
      </p><p>
	Sin embargo, podría resultar confuso si espera que la vida de
	las variables <code class="varname">i</code> y <code class="varname">j</code>
	continúe después del bucle - algo que no ocurre<sup>[<a id="idp5801016" href="#ftn.idp5801016" class="footnote">56</a>]</sup>
      </p><p>
	El capítulo 3 indica que las sentencias <code class="keyword">while</code>
	y <code class="keyword">switch</code> también permiten la definición de
	objetos en sus expresiones de control, aunque ese uso es menos
	importante que con el bucle <code class="keyword">for</code>.
      </p><p>
	Hay que tener cuidado con las variables locales que ocultan las
	variables del ámbito superior. En general, usar el mismo nombre
	para una variable anidada y una variable que es global en ese
	ámbito es confuso y propenso a errores<sup>[<a id="idp5805608" href="#ftn.idp5805608" class="footnote">57</a>]</sup>
      </p><p>
	Creo que los bloques pequeños son un indicador de un buen
	diseño. Si una sola función requiere varias páginas, quizá está
	intentando demasiadas cosas en esa función. Funciones de
	granularidad más fina no sólo son más útiles, tambíén facilitan
	la localización de errores.
      </p></div><div class="sect2" title="6.3.2. Alojamiento de memoria"><div class="titlepage"><div><div><h3 class="title"><a id="idp5807000"></a>6.3.2. Alojamiento de memoria</h3></div></div></div><p>
	Ahora una variable se puede definir en cualquier parte del
	bloque, podría parecer que el alojamiento para una variable no
	se puede llevar a cabo hasta el momento en que se define. En
	realidad, lo más probable es que el compilador siga la práctica
	de pedir todo el alojamiento para el bloque en la llave de
	apertura del bloque. No importa porque, como programador, no
	puede acceder al espacio asociado (es decir, el objeto) hasta
	que ha sido definido<sup>[<a id="idp5808240" href="#ftn.idp5808240" class="footnote">58</a>]</sup>. Aunque el espacio se pida al comienzo del bloque,
	la llamada al constructor no ocurre hasta el punto en el que
	se define el objeto ya que el identificador no está disponible
	hasta entonces. El compilador incluso comprueba que no ponga
	la definición del objeto (y por tanto la llamada al
	constructor) en un punto que dependa de una sentencia
	condicional, como en una sentencia <code class="keyword">switch</code> o algún
	lugar que pueda saltar un <code class="keyword">goto</code>. Descomentar las
	sentencias del siguiente código generará un error o aviso.
      </p><div class="example"><a id="idp5810880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Nojump.cpp</span>
<span class="hl slc">// Can't jump past constructors</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

X<span class="hl opt">::</span><span class="hl kwd">X</span><span class="hl opt">() {}</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">) {</span>
   <span class="hl slc">//! goto jump1; // Error: goto bypasses init</span>
  <span class="hl opt">}</span>
  X x1<span class="hl opt">;</span>  <span class="hl slc">// Constructor called here</span>
 jump1<span class="hl opt">:</span>
  <span class="hl kwa">switch</span><span class="hl opt">(</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">case</span> <span class="hl num">1</span> <span class="hl opt">:</span>
      X x2<span class="hl opt">;</span>  <span class="hl slc">// Constructor called here</span>
      <span class="hl kwa">break</span><span class="hl opt">;</span>
  <span class="hl slc">//! case 2 : // Error: case bypasses init</span>
      X x3<span class="hl opt">;</span>  <span class="hl slc">// Constructor called here</span>
      <span class="hl kwa">break</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">);</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">11</span><span class="hl opt">);</span>
<span class="hl opt">}</span><span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.3. C06/Nojump.cpp</strong></p></div><br class="example-break" /><p>
	En el código anterior, tanto el <code class="keyword">goto</code> como el
	<code class="keyword">switch</code> pueden saltar la sentencia en la que
	se invoca un constructor. Ese objeto corresponde al ámbito
	incluso si no se invoca el constructor, de modo que el compilador
	dará un mensaje de error. Esto garantiza de nuevo que un objeto
	no se puede crear si no se inicializa.
      </p><p>
	Todo el espacio de almacenamiento necesario se asigna en la
	pila, por supuesto. Ese espacio lo faciliza el compilador
	moviendo el puntero de pila «hacia abajo»
	(dependiendo de la máquina implica incrementar o decrementar el
	valor del puntero de pila). Los objetos también se pueden alojar
	en el montículo usando <code class="keyword">new</code>, algo que se verá
	en el capítulo 13. (FIXME:Ref C13)
      </p></div></div><div class="sect1" title="6.4. Stash con constructores y destructores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5816376"></a>6.4. Stash con constructores y destructores</h2></div></div></div><p>
      Los ejemplos de los capítulos anteriores tienen funciones que
      tienen correspondencia directa con constructores y destructores:
      <code class="function">initialize()</code> y
      <code class="function">cleanup()</code>. Éste es el fichero de cabecera
      de <code class="classname">Stash</code>, utilizando constructor y
      destructor:
    </p><div class="example"><a id="idp5818312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Stash2.h</span>
<span class="hl slc">// With constructors &amp; destructors</span>
<span class="hl ppc">#ifndef STASH2_H</span>
<span class="hl ppc">#define STASH2_H</span>

<span class="hl kwc">class</span> Stash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
  <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">Stash</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STASH2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.4. C06/Stash2.h</strong></p></div><br class="example-break" /><p>
      Las únicas definiciones de métodos que han cambiado son
      <code class="function">initialize()</code> y
      <code class="function">cleanup()</code>, que han sido reemplazadas con un
      constructor y un destructor.
    </p><div class="example"><a id="idp5821384"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Stash2.cpp {O}</span>
<span class="hl slc">// Constructors &amp; destructors</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stash2.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">const int</span> increment <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

Stash<span class="hl opt">::</span><span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  size <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  quantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  storage <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  next <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span> <span class="hl slc">// Enough space left?</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>increment<span class="hl opt">);</span>
  <span class="hl slc">// Copy element into storage,</span>
  <span class="hl slc">// starting at next empty space:</span>
  <span class="hl kwb">int</span> startBytes <span class="hl opt">=</span> next <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> e <span class="hl opt">= (</span><span class="hl kwb">unsigned char</span><span class="hl opt">*)</span>element<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    storage<span class="hl opt">[</span>startBytes <span class="hl opt">+</span> i<span class="hl opt">] =</span> e<span class="hl opt">[</span>i<span class="hl opt">];</span>
  next<span class="hl opt">++;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stash<span class="hl opt">::</span><span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> index<span class="hl opt">,</span> <span class="hl str">&quot;Stash::fetch (-)index&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> <span class="hl opt">&amp;(</span>storage<span class="hl opt">[</span>index <span class="hl opt">*</span> size<span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">count</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> next<span class="hl opt">;</span> <span class="hl slc">// Number of elements in CStash</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stash<span class="hl opt">::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>increase <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> 
    <span class="hl str">&quot;Stash::inflate zero or negative increase&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> newQuantity <span class="hl opt">=</span> quantity <span class="hl opt">+</span> increase<span class="hl opt">;</span>
  <span class="hl kwb">int</span> newBytes <span class="hl opt">=</span> newQuantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">int</span> oldBytes <span class="hl opt">=</span> quantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> oldBytes<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Copy old to new</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[](</span>storage<span class="hl opt">);</span> <span class="hl slc">// Old storage</span>
  storage <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
  quantity <span class="hl opt">=</span> newQuantity<span class="hl opt">;</span>
<span class="hl opt">}</span>

Stash<span class="hl opt">::~</span><span class="hl kwd">Stash</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>storage <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
   cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;freeing storage&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
   <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.5. C06/Stash2.cpp</strong></p></div><br class="example-break" /><p>
      Puede ver que las funciones de <code class="filename">require.h</code> se
      usan para vigilar errores del programador, en lugar de
      <code class="function">assert()</code>. La salida de un
      <code class="function">assert()</code> fallido no es tan útil como las
      funciones de <code class="filename">require.h</code> (que se verán más
      adelante en el libro).
    </p><p>
      Dado que <code class="methodname">inflate()</code> es privado, el único
      modo en que <code class="function">require()</code> podría fallar sería si
      uno de los otros miembros pasara accidentalmente un valor
      incorrecto a <code class="methodname">inflate()</code>. Si está seguro de
      que eso no puede pasar, debería considerar eliminar el
      <code class="function">require()</code>, pero debería tener en mente que
      hasta que la clase sea estable, siempre existe la posibilidad de
      que el código nuevo añadido a la clase podría provocar errores. El
      coste de <code class="function">require()</code> es bajo (y podría ser
      eliminado automáticamente por el preprocesador) mientras que la
      robustez del código es alta.
    </p><p>
      Fijese cómo en el siguiente programa de prueba la definición de los
      objetos <code class="classname">Stash</code> aparece justo antes de
      necesitarse, y cómo la inicialización aparece como parte de la
      definición, en la lista de argumentos del constructor.
    </p><div class="example"><a id="idp5830728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Stash2Test.cpp</span>
<span class="hl slc">//{L} Stash2</span>
<span class="hl slc">// Constructors &amp; destructors</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stash2.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stash <span class="hl kwd">intStash</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    intStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(&amp;</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> intStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;intStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span>intStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>j<span class="hl opt">)</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">80</span><span class="hl opt">;</span>
  Stash <span class="hl kwd">stringStash</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">) *</span> bufsize<span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Stash2Test.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot; Stash2Test.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    stringStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">((</span><span class="hl kwb">char</span><span class="hl opt">*)</span>line<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span>stringStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>k<span class="hl opt">++))!=</span><span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;stringStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> k <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.6. C06/Stash2Test.cpp</strong></p></div><br class="example-break" /><p>
      También observe que se han eliminado llamadas a
      <code class="function">cleanup()</code>, pero los destructores se llaman
      automáticamente cuando <code class="varname">intStash</code> y
      <code class="varname">stringStash</code> salen del ámbito.
    </p><p>
      Una cosa de la que debe ser consciente en los ejemplos con
      <code class="classname">Stash</code>: Tengo mucho cuidado usando sólo
      tipos básicos; es decir, aquellos sin destructores. Si intenta
      copiar objetos dentro de <code class="classname">Stash</code>,
      aparecerán todo tipo de problemas y no funcionará bien. En
      realidad la Librería Estándar de C++ puede hacer copias
      correctas de objetos en sus contenedores, pero es un proceso
      bastante sucio y complicado. En el siguiente ejemplo de
      <code class="classname">Stack</code>, verá que se utilizan punteros para
      esquivar esta cuestión, y en un capítulo posterior
      <code class="classname">Stash</code> también se convertirá para que use
      punteros.
    </p></div><div class="sect1" title="6.5. Stack con constructores y destructores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5837096"></a>6.5. Stack con constructores y destructores</h2></div></div></div><p>
      Reimplementar la lista enlazada (dentro de
      <code class="classname">Stack</code>) con constructores y destructores
      muestra claramente cómo costructores y destructores utilizan
      <code class="keyword">new</code> y <code class="keyword">delete</code>. Éste es el
      fichero de cabecera modficado:
    </p><div class="example"><a id="idp5839216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Stack3.h</span>
<span class="hl slc">// With constructors/destructors</span>
<span class="hl ppc">#ifndef STACK3_H</span>
<span class="hl ppc">#define STACK3_H</span>

<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    <span class="hl kwb">void</span><span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwd">Link</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">);</span>
    <span class="hl opt">~</span><span class="hl kwd">Link</span><span class="hl opt">();</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">();</span>
  <span class="hl opt">~</span><span class="hl kwd">Stack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STACK3_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.7. C06/Stack3.h</strong></p></div><br class="example-break" /><p>
      No sólo hace que <code class="classname">Stack</code> tenga un constructor
      y destructor, también aparece la clase anidada
      <code class="classname">Link</code>.
    </p><div class="example"><a id="idp5841288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Stack3.cpp {O}</span>
<span class="hl slc">// Constructors/destructors</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stack3.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

Stack<span class="hl opt">::</span>Link<span class="hl opt">::</span><span class="hl kwd">Link</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">) {</span>
  data <span class="hl opt">=</span> dat<span class="hl opt">;</span>
  next <span class="hl opt">=</span> nxt<span class="hl opt">;</span>
<span class="hl opt">}</span>

Stack<span class="hl opt">::</span>Link<span class="hl opt">::~</span><span class="hl kwd">Link</span><span class="hl opt">() { }</span>

Stack<span class="hl opt">::</span><span class="hl kwd">Stack</span><span class="hl opt">() {</span> head <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>

<span class="hl kwb">void</span> Stack<span class="hl opt">::</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">) {</span>
  head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span>head<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stack<span class="hl opt">::</span><span class="hl kwd">peek</span><span class="hl opt">() {</span> 
  <span class="hl kwd">require</span><span class="hl opt">(</span>head <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Stack empty&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stack<span class="hl opt">::</span><span class="hl kwd">pop</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
  Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
  head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
  <span class="hl kwa">return</span> result<span class="hl opt">;</span>
<span class="hl opt">}</span>

Stack<span class="hl opt">::~</span><span class="hl kwd">Stack</span><span class="hl opt">() {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Stack not empty&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.8. C06/Stack3.cpp</strong></p></div><br class="example-break" /><p>
      El constructor <code class="methodname">Link:Link()</code> simplemente
      inicializa los punteros <code class="varname">data</code> y
      <code class="varname">next</code>, así que en
      <code class="methodname">Stack::push()</code>, la línea:
    </p><pre class="programlisting">
head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span>head<span class="hl opt">);</span>
</pre><p>
      no sólo aloja un nuevo enlace (usando creación dinámica de objetos
      con la sentencia <code class="keyword">new</code>, vista en el capítulo 4),
      también inicializa los punteros para ese enlace.
    </p><p>
      Puede que le asombre que el destructor de
      <code class="classname">Link</code> no haga nada - en concreto, ¿por qué
      no elimina el puntero <code class="varname">data</code>? Hay dos
      problemas. En el capítulo 4, en el que apareció
      <code class="classname">Stack</code>, se decía que no puede eliminar un
      puntero <code class="type">void</code> si está apuntado a un objeto (una
      afirmación que se demostrará en el capítulo 13). Pero además, si
      el destructor de <code class="classname">Link</code> eliminara el
      puntero <code class="varname">data</code>, <code class="function">pop()</code>
      retornaría un puntero a un objeto borrado, que definitivamente
      supone un error. A veces esto se considera como una cuestión de
      <span class="emphasis"><em>propiedad</em></span>: <code class="classname">Link</code> y
      por consiguiente <code class="classname">Stack</code> sólo contienen los
      punteros, pero no son responsables de su limpieza. Eso significa
      que debe tener mucho cuidado para saber quién es el
      responsable. Por ejemplo, si no invoca
      <code class="methodname">pop()</code> y elimina todos los punteros de
      <code class="classname">Stack()</code>, no se limpiarán automáticamente
      por el destructor de <code class="classname">Stack</code>. Esto puede
      ser una cuestión engorrosa y llevar a fugas de memoria, de modo
      que saber quién es el responsable de la limpieza de un objeto
      puede suponer la diferencia entre un programa correcto y uno
      erroneo - es decir, porqué
      <code class="methodname">Stack::~Stack()</code> imprime un mensaje de
      error si el objeto <code class="classname">Stack</code> no está vacío en
      el momento su destrucción.
    </p><p>
      Dado que el alojamiento y limpieza de objetos
      <code class="classname">Link</code> está oculto dentro de
      <code class="classname">Stack</code> - es parte de la implementación
      subyacente - no verá este suceso en el programa de prueba, aunque
      será el responsable de eliminar los punteros que devuelva
      <code class="function">pop()</code>:
    </p><div class="example"><a id="idp5852976"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Stack3Test.cpp</span>
<span class="hl slc">//{L} Stack3</span>
<span class="hl slc">//{T} Stack3Test.cpp</span>
<span class="hl slc">// Constructors/destructors</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stack3.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// File name is argument</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  Stack textlines<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl slc">// Read file and store lines in the stack:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Pop the lines from the stack and print them:</span>
  string<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>s <span class="hl opt">= (</span>string<span class="hl opt">*)</span>textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.9. C06/Stack3Test.cpp</strong></p></div><br class="example-break" /><p>
      En este caso, todas las líneas de <code class="varname">textlines</code> son
      desapiladas y eliminadas, pero si no fuese así, obtendría un
      mensaje de <code class="function">require()</code> que indica que hubo una
      fuga de memoria.
    </p></div><div class="sect1" title="6.6. Inicialización de tipos agregados"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5856456"></a>6.6. Inicialización de tipos agregados</h2></div></div></div><p>
      Un agregado es justo lo que parece: un grupo de cosas agrupados
      juntos. Esta definición incluye agregados de tipos mixtos, como
      estructuras o clases. Un array es un agregado de un único tipo.
    </p><p>
      Inicializar agregados puede ser tedioso y propenso a errores. La
      inicialización de agregados en C++ lo hace mucho más
      seguro. Cuando crea un objeto agregado, todo lo que tiene que
      hacer es una asignación, y la inicialización la hará el
      compilador. Esta asignación tiene varias modalidades, dependiendo
      del tipo de agregado del que se trate, pero en cualquier caso los
      elementos en la asignación deben estar rodeadas de llaves. Para
      arrays de tipos básicos es bastante simple:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">};</span>
</pre><p>
      Si intenta escribir más valores que elementos tiene el
      array, el compilador dará un mensaje de error. Pero, ¿qué ocurre
      si escribe menos valores? Por ejemplo:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> b<span class="hl opt">[</span><span class="hl num">6</span><span class="hl opt">] = {</span><span class="hl num">0</span><span class="hl opt">};</span>
</pre><p>
      Aquí, el compilador usará el primer valor para el primer elemento
      del array, y después usará ceros para todos los elementos para los
      que no se tiene un valor. Fíjese en que este comportamiento en la
      inicialización no ocurre si define un array sin una lista de
      valores de inicialización. Así que la expresión anterior es una
      forma resumida de inicializar a cero un array sin usar un bucle
      <code class="keyword">for</code>, y sin ninguna posibilidad de un
      «error por uno» (Dependiendo del compilador, también
      puede ser más eficiente que un bucle <code class="keyword">for</code>).
    </p><p>
      Un segundo método para los arrays es el conteo automático, en el
      cual se permite que el compilador determine el tamaño del array
      basándose en el número de valores de inicialización.
    </p><pre class="programlisting">
<span class="hl kwb">int</span> c<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">};</span>
</pre><p>
      Ahora, si decide añadir otro elemento al array, simplemente debe
      añadir otro valor. Si puede hacer que su código necesite
      modificaciones en un único sítio, reducirá la posibilidad de
      introducir errores durante la modificación. Pero, ¿cómo
      determinar el tamaño del array? La expresión <code class="code">sizeof c /
      sizeof *c</code> (el tamaño del array completo dividido entre el
      tamaño del primer elemento) es un truco que hace que no sea
      necesario cambiarlo si cambia el tamaño del array <sup>[<a id="idp5864424" href="#ftn.idp5864424" class="footnote">59</a>]</sup>:
    </p><pre class="programlisting">
<span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwa">sizeof</span> c <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>c<span class="hl opt">;</span> i<span class="hl opt">++)</span>
  c<span class="hl opt">[</span>i<span class="hl opt">]++;</span>
</pre><p>
      Dado que las estructuras también son agregados, se pueden
      inicializar de un modo similar. Como en una estructura estilo-C
      todos sus miembros son públicos, se pueden asignar directamente:
    </p><pre class="programlisting">
<span class="hl kwb">struct</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
<span class="hl opt">};</span>

X x1 <span class="hl opt">= {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2.2</span><span class="hl opt">,</span> <span class="hl str">'c'</span><span class="hl opt">};</span>
</pre><p>
      Si tiene una array de esos objetos, puede inicializarlos usando un
      conjunto anidado de llaves para cada elemento:
    </p><pre class="programlisting">
X x2<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">] = { {</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1.1</span><span class="hl opt">,</span> <span class="hl str">'a'</span><span class="hl opt">}, {</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2.2</span><span class="hl opt">,</span> <span class="hl str">'b'</span><span class="hl opt">} };</span>
</pre><p>
      Aquí, el tercer objeto se inicializó a cero.
    </p><p>
      Si alguno de los atributos es privado (algo que ocurre típicamente
      en el caso de clases bien diseñadas en C++), o incluso si todos
      son públicos pero hay un constructor, las cosas son distintas. En
      el ejemplo anterior, los valores se han asignado directamente a
      los elementos del agregado, pero los constructores son una manera
      de forzar que la inicialización ocurra por medio de una interfaz
      formal. Aquí, los constructores deben ser invocados para realizar
      la inicialización. De modo, que si tiene un constructor parecido a
      éste,
    </p><pre class="programlisting">
<span class="hl kwb">struct</span> Y <span class="hl opt">{</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwd">Y</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">);</span>
<span class="hl opt">};</span>
</pre><p>
      Debe indicar la llamada al constructor. La mejor aproximación es
      una explícita como la siguiente:
    </p><pre class="programlisting">
Y y1<span class="hl opt">[] = {</span> <span class="hl kwd">Y</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">Y</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">Y</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">) };</span>
</pre><p>
      Obtendrá tres objetos y tres llamadas al constructor. Siempre que
      tenga un constructor, si es una estructura con todos sus miembros
      públicos o una clase con atributos privados, toda la
      inicialización debe ocurrir a través del constructor, incluso si
      está usando la inicialización de agregados.
    </p><p>
      Se muestra un segundo ejemplo con un constructor con múltiples
      argumentos.
    </p><div class="example"><a id="idp5871608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Multiarg.cpp</span>
<span class="hl slc">// Multiple constructor arguments</span>
<span class="hl slc">// with aggregate initialization</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Z <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">,</span> <span class="hl kwb">int</span> jj<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

Z<span class="hl opt">::</span><span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">,</span> <span class="hl kwb">int</span> jj<span class="hl opt">) {</span>
  i <span class="hl opt">=</span> ii<span class="hl opt">;</span>
  j <span class="hl opt">=</span> jj<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Z<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, j = &quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Z zz<span class="hl opt">[] = {</span> <span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">,</span><span class="hl num">4</span><span class="hl opt">),</span> <span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">,</span><span class="hl num">6</span><span class="hl opt">),</span> <span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl num">7</span><span class="hl opt">,</span><span class="hl num">8</span><span class="hl opt">) };</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwa">sizeof</span> zz <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>zz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    zz<span class="hl opt">[</span>i<span class="hl opt">].</span><span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.10. C06/Multiarg.cpp</strong></p></div><br class="example-break" /><p>
      Fíjese en cómo se invoca un constructor explícito para cada objeto
      de un array.
    </p></div><div class="sect1" title="6.7. Constructores por defecto"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5873720"></a>6.7. Constructores por defecto</h2></div></div></div><p>
      Un <span class="emphasis"><em>constructor por defecto</em></span> es uno que puede
      ser invocado sin argumentos. Un constructor por defecto se usa
      para crear un «objeto vainilla»<sup>[<a id="idp5874704" href="#ftn.idp5874704" class="footnote">60</a>]</sup> pero también es importante cuando el compilador debe
      crear un objeto pero no se dan detalles. Por ejemplo, si se toma
      la <code class="keyword">struct</code> <code class="varname">Y</code> definida previamente y
      se usa en una definición como ésta,
    </p><pre class="programlisting">
Y y2<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">] = {</span> <span class="hl kwd">Y</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) };</span>
</pre><p>
      el compilador se quejará porque no puede encontrar un constructor
      por defecto. El segundo objeto del array se creará sin argumentos,
      y es ahí donde el compilador busca un constructor por defecto. De
      hecho, si simplemente define un array de objetos
      <code class="classname">Y</code>,
    </p><pre class="programlisting">
Y y3<span class="hl opt">[</span><span class="hl num">7</span><span class="hl opt">];</span>
</pre><p>
      el compilador se quejará porque debería haber un constructor para
      inicializar cada objeto del array.
    </p><p>
      El mismo problema ocurre si crea un objeto individual como éste:
    </p><pre class="programlisting">
Y y4<span class="hl opt">;</span>
</pre><p>
      Recuerde, si tiene un constructor, el compilador asegura que
      siempre ocurrirá la construcción, sin tener en cuenta la situación.
    </p><p>
      El constructor por defecto es tan importante que si (y sólo si)
      una estructura (<code class="keyword">struct</code> o
      <code class="keyword">clase</code>) no tiene constructor, el compilador
      creará uno automáticamente. Por ello, lo siguiente funciona:
    </p><div class="example"><a id="idp5881816"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:AutoDefaultConstructor.cpp</span>
<span class="hl slc">// Automatically-generated default constructor</span>

<span class="hl kwc">class</span> V <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>  <span class="hl slc">// private</span>
<span class="hl opt">};</span> <span class="hl slc">// No constructor</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  V v<span class="hl opt">,</span> v2<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.11. C06/AutoDefaultConstructor.cpp</strong></p></div><br class="example-break" /><p>
      Si se han definido constructores, pero no hay constructor por
      defecto, las instancias anteriores de <code class="classname">V</code>
      provocarán errores durante la compilación.
    </p><p>
      Podría pensarse que el constructor sintetizado por el compilador
      debería hacer alguna inicialización inteligente, como poner a cero
      la memoria del objeto. Pero no lo hace - añadiría una sobrecarga
      que quedaría fuera del control del programador. Si quiere que la
      memoria sea inicializada a cero, debería hacerlo escribiendo un
      constructor por defecto explícito.
    </p><p>
      Aunque el compilador creará un constructor por defecto, el
      comportamiento de ese constructor raramente hará lo que se
      espera. Debería considerar esta característica como una red de
      seguridad, pero que debe usarse con moderación. En general,
      debería definir sus constructores explicitamente y no permitir que
      el compilador lo haga por usted.
    </p></div><div class="sect1" title="6.8. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5885296"></a>6.8. Resumen</h2></div></div></div><p>
      Los mecanismos aparentemente elaborados proporcionados por C++
      deberían darle una idea de la importancia crítica que tiene en
      el lenguaje la inicialización y limpieza. Como <span class="personname"><span class="surname">Stroustrup</span></span> fue quien diseño C++,
      una de las primeras observaciones que hizo sobre la
      productividad de C fue que una parte importante de los problemas
      de programación se deben a la inicialización inapropiada de las
      variables. Este tipo de errores son difíciles de encontrar, y
      otro tanto se puede decir de una limpieza inapropiada. Dado que
      constructores y destructores le permiten garantizar una
      inicialización y limpieza apropiada (el compilador no permitirá
      que un objeto sea creado o destruido sin la invocación del
      constructor y destructor correspondiente), conseguirá control y
      seguridad.
    </p><p>
      La inicialización de agregados está incluida de un modo similar -
      previene de errores de inicialización típicos con agregados de
      tipos básicos y hace que el código sea más corto.
    </p><p>
      La seguridad durante la codificación es una cuestión importante en
      C++. La inicialización y la limpieza son una parte importante,
      pero también verá otras cuestiones de seguridad más adelante en
      este libro.
    </p></div><div class="sect1" title="6.9. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5889272"></a>6.9. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Escriba una clase simple llamada <code class="classname">Simple</code>
	  con un constructor que imprima algo indicando que se ha
	  invocado. En <code class="function">main()</code> creae un objeto de
	  esa clase.
	</p></li><li class="listitem"><p>
	  Añada un destructor al Ejercicio 1 que imprima un mensaje
	  indicado que se ha llamado.
	</p></li><li class="listitem"><p>
	  Modifique el Ejercicio 2 de modo que la clase contenga un
	  miembro <code class="type">int</code>. Modifique el constructor para que
	  tome un argumento <code class="type">int</code> que se almacene en el
	  atributo. Tanto el constructor como el destructor deberán
	  imprimir el valor del entero como parte se su mensaje, de modo
	  que se pueda ver cómo se crean y destruyen los objetos.
	</p></li><li class="listitem"><p>
	  Demuestre que los destructores se invocan incluso cuando se
	  utiliza <code class="keyword">goto</code> para salir de un bucle.
	</p></li><li class="listitem"><p>
	  Escriba dos bucles <code class="keyword">for</code> que impriman los
	  valores de 0 a 10. En el primero, defina el contador del bucle
	  antes del bucle, y en el segundo, defina el contador en la
	  expresión de control del <code class="keyword">for</code>. En la segunda
	  parte del ejercicio, modifique el identificador del segundo
	  bucle para que tenga el mismo nombre del el contador del
	  primero y vea que hace el compilador.
	</p></li><li class="listitem"><p>
	  Modifique los ficheros <code class="filename">Handle.h</code>,
	  <code class="filename">Handle.cpp</code>, y
	  <code class="filename">UseHandle.cpp</code> del capítulo 5 para que
	  usen constructores y destructores.
	</p></li><li class="listitem"><p>
	  Use inicialización de agregados para crear un array de
	  <code class="type">double</code> en el que se indique el tamaño del array
	  pero no se den suficientes elementos. Imprima el array usando
	  <code class="literal">sizeof</code> para determinar el tamaño del
	  array. Ahora cree un array de <code class="type">double</code> usando
	  inicialización de agregados y conteo automático. Imprima el
	  array.
	</p></li><li class="listitem"><p>
	  Utilice inicialización de agregados para crear un array de
	  objetos <code class="type">string</code>. Cree una
	  <code class="classname">Stack</code> para guardar esas cadenas y
	  recorra el array, apilando cada cadena en la
	  pila. Finalmente, extraiga las cadenas de la pila e imprima
	  cada una de ellas.
	</p></li><li class="listitem"><p>
	  Demuestre el conteo automático e inicialización de agregados
	  con un array de objetos de la clase creada en el Ejercicio
	  3. Añada un método a la clase que imprima un mensaje. Calcule
	  el tamaño del array y recórralo, llamando al nuevo método.
	</p></li><li class="listitem"><p>
	  Cree una clase sin ningún constructor, y demuestre que puede
	  crear objetos con el constructor por defecto. Ahora cree un
	  constructor explícito (que tenga un argumento) para la clase,
	  e intente compilar de nuevo. Explique lo que ocurre.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp5766600" href="#idp5766600" class="para">54</a>] </sup>árbol</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5788872" href="#idp5788872" class="para">55</a>] </sup>C99, la versión actual del Estándar de C, permite definir
      variables en cualquier punto del bloque, como C++</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5801016" href="#idp5801016" class="para">56</a>] </sup>Un reciente borrador del estándar C++ dice que la vida de
	la variable se extiende hasta el final del ámbito que encierra
	el bucle <code class="keyword">for</code>. Algunos compiladores lo
	implementan, pero eso no es correcto de modo que su código sólo
	será portable si limita el ámbito al bucle
	<code class="keyword">for</code>.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5805608" href="#idp5805608" class="para">57</a>] </sup>El lenguaje Java considera esto una idea tan mala que lo
	considera un error.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5808240" href="#idp5808240" class="para">58</a>] </sup>De acuerdo, probablemente podría trucarlo usando
	punteros, pero sería muy, muy malo</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5864424" href="#idp5864424" class="para">59</a>] </sup>En el segundo volumen de este libro (disponible libremente
      en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>),
      verá una forma más corta de calcular el tamaño de un array
      usando plantillas.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp5874704" href="#idp5874704" class="para">60</a>] </sup>N.de.T: Para los anglosajones
      <span class="emphasis"><em>Vainilla</em></span> es el sabor más
      «sencillo», sin adornos ni sofisticaciones.</p></div></div></div><div class="chapter" title="7: Sobrecarga de funciones y argumentos por defecto"><div class="titlepage"><div><div><h2 class="title"><a id="C07"></a>7: Sobrecarga de funciones y argumentos por defecto</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp5916920">7.1. Más decoración de nombres</a></span></dt><dt><span class="sect1"><a href="#idp5939928">7.2. Ejemplo de sobrecarga</a></span></dt><dt><span class="sect1"><a href="#idp5953928">7.3. Uniones</a></span></dt><dt><span class="sect1"><a href="#idp5973616">7.4. Argumentos por defecto</a></span></dt><dt><span class="sect1"><a href="#idp5989808">7.5. Elección entre sobrecarga y argumentos por defecto</a></span></dt><dt><span class="sect1"><a href="#idp6019224">7.6. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6022232">7.7. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Una de las características más importantes en cualquier lenguaje
      de programación es la utilización adecuada de los nombres.
    </p></div><p>
    Cuando crea un objeto (una variable) le está asignando un nombre a
    una región de memoria. Una función es un nombre para una
    acción. El hecho de poner nombres adecuados a la hora de
    describir un sistema hace que un programa sea más fácil de
    entender y modificar. Es muy parecido a la prosa escrita, el
    objetivo es comunicarse con los lectores.
  </p><p>
    Cuando se trata de representar sutilezas del lenguaje humano en un
    lenguaje de programación aparecen los problemas. A menudo, la
    misma palabra expresa diversos significados dependiendo del
    contexto. Una palabra tiene múltiples significados, es decir, está
    sobrecargada (polisemia). Esto es muy útil, especialmente cuando
    las diferencias son obvias. Puede decir «lave la camiseta,
    lave el coche.» Sería estúpido forzar la expresión anterior
    para convertirla en «lavar_camiseta la camiseta, lavar_coche
    el coche» pues el oyente no tiene que hacer ninguna
    distinción sobre la acción realizada. Los lenguajes humanos son
    muy redundantes, así que incluso si pierde algunas palabras,
    todavía puede determinar el significado. Los identificadores
    únicos no son necesarios, pues se puede deducir el significado a
    partir del contexto.
  </p><p>
    Sin embargo, la mayoría de los lenguajes de programación requieren
    que se utilice un identificador único para cada función. Si tiene
    tres tipos diferentes de datos que desee imprimir en la salida:
    <code class="type">int</code>, <code class="type">char</code> y <code class="type">float</code>,
    generalmente tiene que crear tres funciones diferentes, como por
    ejemplo <code class="function">print_int()</code>,
    <code class="function">print_char()</code> y
    <code class="function">print_float()</code>. Esto constituye un trabajo
    extra tanto para el programador, al escribir el programa, como
    para el lector que trate de entenderlo.
  </p><p>
    En C++ hay otro factor que fuerza la sobrecarga de los nombres de
    función: el constructor. Como el nombre del constructor está
    predeterminado por el nombre de la clase, podría parecer que sólo
    puede haber un constructor.  Pero, ¿qué ocurre si desea crear un
    objeto de diferentes maneras? Por ejemplo, suponga que escribe una
    clase que puede inicializarse de una manera estándar o leyendo
    información de un fichero. Necesita dos constructores, uno que no
    tiene argumentos (el constructor por defecto) y otro que tiene un
    argumento de tipo <code class="type">string</code>, que es el nombre
    del fichero que inicializa el objeto. Ambos son constructores, así
    pues deben tener el mismo nombre: el nombre de la clase. Así, la
    sobrecarga de funciones es esencial para permitir el mismo nombre
    de función (el constructor en este caso) se utilice con diferentes
    argumentos.
  </p><p>
    Aunque la sobrecarga de funciones es algo imprescindible para los
    constructores, es también de utilidad general para cualquier
    función, incluso aquellas que no son métodos. Además, la
    sobrecarga de funciones significa que si tiene dos librerías que
    contienen funciones con el mismo nombre, no entrarán en conflicto
    siempre y cuando las listas de argumentos sean diferentes. A lo
    largo del capítulo se mostrarán todos los detalles.
  </p><p>
    El tema de este capítulo es la elección adecuada de los nombres de
    la funciones. La sobrecarga de funciones permite utilizar el mismo
    nombre para funciones diferentes, pero hay otra forma más adecuada
    de llamar a una función. ¿Qué ocurriría si le gustara llamar a la
    misma función de formas diferentes? Cuando las funciones tienen una
    larga lista de argumentos, puede resultar tediosa la escritura (y
    confusa la lectura) de las llamadas a la función cuando la mayoría
    de los argumentos son lo mismos para todas las llamadas. Una
    característica de C++ comúnmente utilizada se llama
    <span class="emphasis"><em>argumento por defecto</em></span>. Un argumento por defecto
    es aquel que el compilador inserta en caso de que no se especifique
    cuando se llama a la función.  Así, las llamadas
    <code class="code">f("hello")</code>, <code class="code">f("hi", 1)</code> y
    <code class="code">f("howdy", 2, 'c')</code> pueden ser llamadas a la
    misma función. También podrían ser llamadas a tres funciones
    sobrecargadas, pero cuando las listas de argumentos son tan
    similares, querrá que tengan un comportamiento similar, que le lleva
    a tener una única función.
  </p><p>
    La sobrecarga de funciones y los argumentos por defecto no son muy
    complicados. En el momento en que termine este capítulo, sabrá
    cuándo utilizarlos y entenderá los mecanismos internos que el
    compilador utiliza en tiempo de compilación y enlace.
  </p><div class="sect1" title="7.1. Más decoración de nombres"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5916920"></a>7.1. Más decoración de nombres</h2></div></div></div><p>
      En el Capítulo 4 se presentó el concepto de <span class="emphasis"><em>decoración de
      nombres</em></span>. En el código:
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl kwc">class</span> X <span class="hl opt">{</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(); };</span>
</pre><p>
      La función <code class="function">f()</code> dentro del ámbito de la
      clase <code class="classname">X</code> no entra en conflicto con la
      versión global de <code class="function">f()</code>. El compilador
      resuelve los ámbitos generando diferentes nombres internos tanto
      para la versión global de <code class="function">f()</code> como para
      <code class="methodname">X::f()</code>.  En el Capítulo 4 se sugirió
      que los nombres son simplemente el nombre de la clase junto con
      el nombre de la función. Un ejemplo podría ser que el compilador
      utilizara como nombres <code class="literal">_f</code> y
      <code class="literal">_X_f</code>. Sin embargo ahora se ve que la
      decoración del nombre de la función involucra algo más que el
      nombre de la clase.
    </p><p>
      He aquí el porqué. Suponga que quiere sobrecargar dos funciones
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">);</span>
</pre><p>
      No importa si son globales o están dentro de una clase. El
      compilador no puede generar identificadores internos únicos si
      sólo utiliza el ámbito de las funciones. Terminaría con
      <code class="literal">_print</code> en ambos casos. La idea de una función
      sobrecargada es que se utilice el mismo nombre de función, pero
      diferente lista de argumentos. Así pues, para que la sobrecarga
      funcione el compilador ha de decorar el nombre de la función con
      los nombres de los tipos de los argumentos.  Las funciones
      planteadas más arriba, definidas como globales, producen nombres
      internos que podrían parecerse a algo así como
      <code class="literal">_print_char</code> y
      <code class="literal">_print_float</code>.  Nótese que como no hay ningún
      estándar de decoración, podrá obtener resultados diferentes de
      un compilador a otro. (Puede ver lo que saldría diciéndole al
      compilador que genere código fuente en ensamblador). Esto, por
      supuesto, causa problemas si desea comprar unas librerías
      compiladas por un compilador y enlazador particulares, aunque si
      la decoración de nombres fuera estándar, habría otros obstáculos
      debido a las diferencias de generación de código máquina entre
      compiladores.
    </p><p>
      Esto es todo lo que hay para la sobrecarga de funciones: puede
      utilizar el mismo nombre de función siempre y cuando la lista de
      argumentos sea diferente. El compilador utiliza el nombre, el
      ámbito y la lista de argumentos para generar un nombre interno
      que el enlazador pueda utilizar.
    </p><div class="sect2" title="7.1.1. Sobrecarga en el valor de retorno"><div class="titlepage"><div><div><h3 class="title"><a id="idp5926376"></a>7.1.1. Sobrecarga en el valor de retorno</h3></div></div></div><p>
	Es muy común la pregunta «¿Por qué solamente el ámbito y
	la lista de argumentos? ¿Por qué no también el valor de
	retorno?». A primera vista parece que tendría sentido
	utilizar también el valor de retorno para la decoración del
	nombre interno. De esta manera, también podría sobrecargar con
	los valores de retorno:
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><p>
	Esto funciona bien cuando el compilador puede determinar sin
	ambigüedades a qué tipo de valor de retorno se refiere, como
	en <code class="code">int x = f();</code>. No obstante, en C se
	puede llamar a una función y hacer caso omiso del valor de
	retorno (esto es, puede querer llamar a la función debido a
	sus <span class="emphasis"><em>efectos laterales</em></span>). ¿Cómo puede el compilador
	distinguir a qué función se refiere en este caso? Peor es la
	dificultad que tiene el lector del código fuente para
	dilucidar a qué función se refiere. La sobrecarga mediante el
	valor de retorno solamente es demasiado sutil, por lo que C++
	no lo permite.
      </p></div><div class="sect2" title="7.1.2. Enlace con FIXME:tipos seguros"><div class="titlepage"><div><div><h3 class="title"><a id="idp5929984"></a>7.1.2. Enlace con FIXME:tipos seguros</h3></div></div></div><p>
	Existe un beneficio añadido a la decoración de nombres. En C
	hay un problema particularmente fastidioso cuando un
	programador cliente declara mal una función o, aún peor, se
	llama a una función sin haber sido previamente declarada, y el
	compilador infiere la declaración de la función mediante la
	forma en que se llama. Algunas veces la declaración de la
	función es correcta, pero cuando no lo es, suele resultar en
	un fallo difícil de encontrar.
      </p><p>
	A causa de que en C++ se <span class="emphasis"><em>deben</em></span> declarar todas las
	funciones antes de llamarlas, las probabilidades de que ocurra
	lo anteriormente expuesto se reducen drásticamente. El
	compilador de C++ rechaza declarar una función
	automáticamente, así que es probable que tenga que incluir la
	cabecera apropiada. Sin embargo, si por alguna razón se las
	apaña para declarar mal una función, o declararla a mano o
	incluir una cabecera incorrecta (quizá una que sea antigua),
	la decoración de nombres proporciona una seguridad que a
	menudo se denomina como <span class="emphasis"><em>enlace con tipos seguros</em></span>.
      </p><p>
	Considere el siguiente escenario. En un fichero está la
	definición de una función:
      </p><div class="example"><a id="idp5933112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Def.cpp {O}</span>
<span class="hl slc">// Function definition</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.1. C07/Def.cpp</strong></p></div><br class="example-break" /><p>
	En el segundo fichero, la función está mal declarada y en
	<code class="function">main</code> se le llama:
      </p><div class="example"><a id="idp5934768"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Use.cpp</span>
<span class="hl slc">//{L} Def</span>
<span class="hl slc">// Function misdeclaration</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
<span class="hl slc">//!  f(1); // Causes a linker error</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.2. C07/Use.cpp</strong></p></div><br class="example-break" /><p>
	Incluso aunque pueda ver que la función es realmente
	<code class="function">f(int)</code>, el compilador no lo sabe porque se
	le dijo, a través de una declaración explícita, que la función
	es <code class="function">f(char)</code>. Así pues, la compilación tiene
	éxito. En C, el enlazador podría tener también éxito, pero
	<span class="emphasis"><em>no</em></span> en C++. Como el compilador decora los
	nombres, la definición se convierte en algo así como
	<code class="literal">f_int</code>, mientras que se trata de utilizar
	<code class="literal">f_char</code>. Cuando el enlazador intenta
	resolver la referencia a <code class="literal">f_char</code>, sólo puede
	encontrar <code class="literal">f_int</code>, y da un mensaje de
	error. Éste es el enlace de tipos seguro. Aunque el problema no
	ocurre muy a menudo, cuando ocurre puede ser increíblemente
	difícil de encontrar, especialmente en proyectos grandes. Éste
	método puede utilizarse para encontrar un error en C simplemente
	intentando compilarlo en C++.
      </p></div></div><div class="sect1" title="7.2. Ejemplo de sobrecarga"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5939928"></a>7.2. Ejemplo de sobrecarga</h2></div></div></div><p>
      Ahora puede modificar ejemplos anteriores para utilizar la
      sobrecarga de funciones. Como ya se dijo, el lugar
      inmediatamente más útil para la sobrecarga es en los
      constructores. Puede comprobarlo en la siguiente versión de la
      clase <code class="classname">Stash</code>:
    </p><div class="example"><a id="idp5941240"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Stash3.h</span>
<span class="hl slc">// Function overloading</span>
<span class="hl ppc">#ifndef STASH3_H</span>
<span class="hl ppc">#define STASH3_H</span>

<span class="hl kwc">class</span> Stash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
  <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">);</span> <span class="hl slc">// Zero quantity</span>
  <span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">,</span> <span class="hl kwb">int</span> initQuantity<span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">Stash</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STASH3_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.3. C07/Stash3.h</strong></p></div><br class="example-break" /><p>
      El primer constructor de <code class="classname">Stash</code> es el
      mismo que antes, pero el segundo tiene un argumento
      <code class="varname">Quantity</code> que indica el número inicial de
      espacios de memoria que podrán ser asignados. En la
      definición, puede observar que el valor interno de
      <code class="varname">quantity</code> se pone a cero, al igual que el
      puntero <code class="varname">storage</code>.  En el segundo
      constructor, la llamada a
      <code class="function">inflate(initQuantity)</code> incrementa
      <code class="varname">quantity</code> al tamaño asignado:
    </p><div class="example"><a id="idp5944872"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Stash3.cpp {O}</span>
<span class="hl slc">// Function overloading</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stash3.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">const int</span> increment <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

Stash<span class="hl opt">::</span><span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  size <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  quantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  next <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  storage <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

Stash<span class="hl opt">::</span><span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">,</span> <span class="hl kwb">int</span> initQuantity<span class="hl opt">) {</span>
  size <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  quantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  next <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  storage <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">inflate</span><span class="hl opt">(</span>initQuantity<span class="hl opt">);</span>
<span class="hl opt">}</span>

Stash<span class="hl opt">::~</span><span class="hl kwd">Stash</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>storage <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;freeing storage&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span> <span class="hl slc">// Enough space left?</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>increment<span class="hl opt">);</span>
  <span class="hl slc">// Copy element into storage,</span>
  <span class="hl slc">// starting at next empty space:</span>
  <span class="hl kwb">int</span> startBytes <span class="hl opt">=</span> next <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> e <span class="hl opt">= (</span><span class="hl kwb">unsigned char</span><span class="hl opt">*)</span>element<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    storage<span class="hl opt">[</span>startBytes <span class="hl opt">+</span> i<span class="hl opt">] =</span> e<span class="hl opt">[</span>i<span class="hl opt">];</span>
  next<span class="hl opt">++;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> Stash<span class="hl opt">::</span><span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> index<span class="hl opt">,</span> <span class="hl str">&quot;Stash::fetch (-)index&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> <span class="hl opt">&amp;(</span>storage<span class="hl opt">[</span>index <span class="hl opt">*</span> size<span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">count</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> next<span class="hl opt">;</span> <span class="hl slc">// Number of elements in CStash</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stash<span class="hl opt">::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>increase <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>increase <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> newQuantity <span class="hl opt">=</span> quantity <span class="hl opt">+</span> increase<span class="hl opt">;</span>
  <span class="hl kwb">int</span> newBytes <span class="hl opt">=</span> newQuantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">int</span> oldBytes <span class="hl opt">=</span> quantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> oldBytes<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Copy old to new</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[](</span>storage<span class="hl opt">);</span> <span class="hl slc">// Release old storage</span>
  storage <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
  quantity <span class="hl opt">=</span> newQuantity<span class="hl opt">;</span> <span class="hl slc">// Adjust the size</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.4. C07/Stash3.cpp</strong></p></div><br class="example-break" /><p>
      Cuando utiliza el primer constructor no se asigna memoria alguna para
      <code class="varname">storage</code>. La asignación ocurre la primera vez que
      trata de añadir (con <code class="function">add()</code>) un objeto y en
      cualquier momento en el que el bloque de memoria actual se exceda
      en <code class="function">add()</code>.
    </p><p>
      Ambos constructores se prueban en este programa de ejemplo:
    </p><div class="example"><a id="idp5949912"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Stash3Test.cpp</span>
<span class="hl slc">//{L} Stash3</span>
<span class="hl slc">// Function overloading</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stash3.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stash <span class="hl kwd">intStash</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    intStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(&amp;</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> intStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;intStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span>intStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>j<span class="hl opt">)</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">80</span><span class="hl opt">;</span>
  Stash <span class="hl kwd">stringStash</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">) *</span> bufsize<span class="hl opt">,</span> <span class="hl num">100</span><span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Stash3Test.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Stash3Test.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    stringStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">((</span><span class="hl kwb">char</span><span class="hl opt">*)</span>line<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span>stringStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>k<span class="hl opt">++))!=</span><span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;stringStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> k <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.5. C07/Stash3Test.cpp</strong></p></div><br class="example-break" /><p>
      La llamada al constructor para la variable
      <code class="varname">stringStash</code> utiliza un segundo argumento;
      se presume que conoce algo especial sobre el problema
      específico que usted está resolviendo que le permite elegir un
      tamaño inicial para el <code class="classname">Stash</code>.
    </p></div><div class="sect1" title="7.3. Uniones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5953928"></a>7.3. Uniones</h2></div></div></div><p>
      Como ya ha visto, la única diferencia en C++ entre
      <code class="keyword">struct</code> y <code class="keyword">class</code> es que <code class="keyword">struct</code> pone
      todo por defecto a <code class="keyword">public</code> y la clase pone todo por
      defecto a <code class="keyword">private</code>. Una <code class="keyword">struct</code>  también puede
      tener constructores y destructores, como cabía esperar.  Pero
      resulta que el tipo <code class="keyword">union</code> también puede tener
      constructores, destructores, métodos e incluso controles de
      acceso. Puede ver de nuevo la utilización y las ventajas de la
      sobrecarga de funciones en el siguiente ejemplo:
    </p><div class="example"><a id="idp5958752"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:UnionClass.cpp</span>
<span class="hl slc">// Unions with constructors and member functions</span>
<span class="hl ppc">#include&lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">union</span> U <span class="hl opt">{</span>
<span class="hl kwc">private</span><span class="hl opt">:</span> <span class="hl slc">// Access control too!</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>  
  <span class="hl kwd">U</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">);</span>
  <span class="hl kwd">U</span><span class="hl opt">(</span><span class="hl kwb">float</span> b<span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">U</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">read_int</span><span class="hl opt">();</span>
  <span class="hl kwb">float</span> <span class="hl kwd">read_float</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

U<span class="hl opt">::</span><span class="hl kwd">U</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span> i <span class="hl opt">=</span> a<span class="hl opt">; }</span>

U<span class="hl opt">::</span><span class="hl kwd">U</span><span class="hl opt">(</span><span class="hl kwb">float</span> b<span class="hl opt">) {</span> f <span class="hl opt">=</span> b<span class="hl opt">;}</span>

U<span class="hl opt">::~</span><span class="hl kwd">U</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;U::~U()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>

<span class="hl kwb">int</span> U<span class="hl opt">::</span><span class="hl kwd">read_int</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>

<span class="hl kwb">float</span> U<span class="hl opt">::</span><span class="hl kwd">read_float</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> f<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  U <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">12</span><span class="hl opt">),</span> <span class="hl kwd">Y</span><span class="hl opt">(</span><span class="hl num">1.9</span>F<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> X<span class="hl opt">.</span><span class="hl kwd">read_int</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> Y<span class="hl opt">.</span><span class="hl kwd">read_float</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.6. C07/UnionClass.cpp</strong></p></div><br class="example-break" /><p>
      Podría pensar que en el código anterior la única diferencia
      entre una unión y una clase es la forma en que los datos se
      almacenan en memoria (es decir, el <code class="keyword">int</code> y el
      <code class="keyword">float</code> están superpuestos). Sin embargo una unión no se
      puede utilizar como clase base durante la herencia, lo cual
      limita bastante desde el punto de vista del diseño orientado a
      objetos (veremos la herencia en el Capítulo 14).
    </p><p>
      Aunque los métodos civilizan ligeramente el tratamiento de
      uniones, sigue sin haber manera alguna de prevenir que el
      programador cliente seleccione el tipo de elemento equivocado
      una vez que la unión se ha inicializado. En el ejemplo anterior,
      podría escribir <code class="code">X.read_float()</code> incluso aunque sea
      inapropiado.  Sin embargo, una unión «segura» se
      puede encapsular en una clase. En el siguiente ejemplo, vea cómo
      la enumeración clarifica el código, y cómo la sobrecarga viene
      como anillo al dedo con los constructores:
    </p><div class="example"><a id="idp5964272"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:SuperVar.cpp</span>
<span class="hl slc">// A super-variable</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> SuperVar <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span>
    character<span class="hl opt">,</span>
    integer<span class="hl opt">,</span>
    floating_point
  <span class="hl opt">}</span> vartype<span class="hl opt">;</span>  <span class="hl slc">// Define one</span>
  <span class="hl kwb">union</span> <span class="hl opt">{</span>  <span class="hl slc">// Anonymous union</span>
    <span class="hl kwb">char</span> c<span class="hl opt">;</span>
    <span class="hl kwb">int</span> i<span class="hl opt">;</span>
    <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl opt">};</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">SuperVar</span><span class="hl opt">(</span><span class="hl kwb">char</span> ch<span class="hl opt">);</span>
  <span class="hl kwd">SuperVar</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">);</span>
  <span class="hl kwd">SuperVar</span><span class="hl opt">(</span><span class="hl kwb">float</span> ff<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

SuperVar<span class="hl opt">::</span><span class="hl kwd">SuperVar</span><span class="hl opt">(</span><span class="hl kwb">char</span> ch<span class="hl opt">) {</span>
  vartype <span class="hl opt">=</span> character<span class="hl opt">;</span>
  c <span class="hl opt">=</span> ch<span class="hl opt">;</span>
<span class="hl opt">}</span>

SuperVar<span class="hl opt">::</span><span class="hl kwd">SuperVar</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span>
  vartype <span class="hl opt">=</span> integer<span class="hl opt">;</span>
  i <span class="hl opt">=</span> ii<span class="hl opt">;</span>
<span class="hl opt">}</span>

SuperVar<span class="hl opt">::</span><span class="hl kwd">SuperVar</span><span class="hl opt">(</span><span class="hl kwb">float</span> ff<span class="hl opt">) {</span>
  vartype <span class="hl opt">=</span> floating_point<span class="hl opt">;</span>
  f <span class="hl opt">=</span> ff<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> SuperVar<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">() {</span>
  <span class="hl kwa">switch</span> <span class="hl opt">(</span>vartype<span class="hl opt">) {</span>
    <span class="hl kwa">case</span> character<span class="hl opt">:</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;character: &quot;</span> <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> integer<span class="hl opt">:</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;integer: &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> floating_point<span class="hl opt">:</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;float: &quot;</span> <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">break</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  SuperVar <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl str">'c'</span><span class="hl opt">),</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl num">12</span><span class="hl opt">),</span> <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl num">1.44</span>F<span class="hl opt">);</span>
  A<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span>
  B<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span>
  C<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.7. C07/SuperVar.cpp</strong></p></div><br class="example-break" /><p>
      En ese ejemplo la enumeración no tiene nombre de tipo (es una
      enumeración sin etiqueta). Esto es aceptable si va a definir
      inmediatamente un ejemplar de la enumeración, tal como se hace
      aquí.  No hay necesidad de indicar el nombre del tipo de la
      enumeración en el futuro, por lo que aquí el nombre de tipo es
      opcional.
    </p><p>
      La unión no tiene nombre de tipo ni nombre de variable. Esto se
      denomina <span class="emphasis"><em>unión anónima</em></span>, y crea espacio para
      la unión pero no requiere acceder a los elementos de la unión con
      el nombre de la variable y el operador punto. Por ejemplo, si su
      unión anónima es:
    </p><div class="example"><a id="idp5968408"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:AnonymousUnion.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">union</span> <span class="hl opt">{</span> 
    <span class="hl kwb">int</span> i<span class="hl opt">;</span> 
    <span class="hl kwb">float</span> f<span class="hl opt">;</span> 
  <span class="hl opt">};</span>
  <span class="hl slc">// Access members without using qualifiers:</span>
  i <span class="hl opt">=</span> <span class="hl num">12</span><span class="hl opt">;</span>
  f <span class="hl opt">=</span> <span class="hl num">1.22</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.8. C07/AnonymousUnion.cpp</strong></p></div><br class="example-break" /><p>
      Note que accede a los miembros de una unión anónima igual que si
      fueran variables normales. La única diferencia es que ambas
      variables ocupan el mismo espacio de memoria. Si la unión anónima
      está en el ámbito del fichero (fuera de todas las funciones y
      clases), entonces se ha de declarar estática para que tenga enlace
      interno.
    </p><p>
      Aunque ahora <code class="classname">SuperVar</code> es segura, su
      utilidad es un poco dudosa porque la razón de utilizar una unión
      principalmente es la de ahorrar memoria y la adición de
      <code class="varname">vartype</code> hace que ocupe bastante espacio en la
      unión (relativamente), por lo que la ventaja del ahorro
      desaparece. Hay un par de alternativas para que este esquema
      funcione. Si <code class="varname">vartype</code> controlara más de una
      unión (en el caso de que fueran del mismo tipo) entonces sólo
      necesitaría uno para el grupo y no ocuparía más memoria. Una
      aproximación más útil es tener <code class="keyword">#ifdef</code>s alrededor del
      código de <code class="varname">vartype</code>, el cual puede entonces
      garantizar que las cosas se utilizan correctamente durante el
      desarrollo y las pruebas. Si el código ha de entregarse, antes
      puede eliminar las sobrecargas de tiempo y memoria.
    </p></div><div class="sect1" title="7.4. Argumentos por defecto"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5973616"></a>7.4. Argumentos por defecto</h2></div></div></div><p>
      En <code class="filename">Stash3.h</code>, examine los dos constructores
      para <code class="classname">Stash</code>. No parecen muy diferentes,
      ¿verdad?. De hecho el primer constructor parece ser un caso especial
      del segundo pero con <code class="varname">size</code> inicializado a cero. Es
      un poco una pérdida de tiempo y esfuerzo crear y mantener dos
      versiones diferentes de una función similar.
    </p><p>
      C++ proporciona un remedio mediante los <span class="emphasis"><em>argumentos por
      defecto</em></span>. Un argumento por defecto es una valor que se
      da en la declaración para que el compilador lo inserte
      automáticamente en el caso de que no se proporcione en la
      llamada a la función. En el ejemplo de <code class="classname">Stash</code>,
      se puede reemplazar las dos funciones:
    </p><pre class="programlisting">
<span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">);</span> <span class="hl slc">// Zero quantity</span>
<span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">,</span> <span class="hl kwb">int</span> initQuantity<span class="hl opt">);</span>
</pre><p>
      por ésta otra:
    </p><pre class="programlisting">
<span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">,</span> <span class="hl kwb">int</span> initQuantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
</pre><p>
      La definición de <code class="function">Stash(int)</code> simplemente se
      quita; todo lo necesario está ahora en la definición de
      <code class="function">Stash(int, int)</code>.
    </p><p>
      Ahora, las definiciones de los dos objetos
    </p><pre class="programlisting">
Stash <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">),</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
</pre><p>
      producirán exactamente los mismos resultados. En ambos casos se
      llama al mismo constructor, aunque el compilador substituye el
      segundo argumento de <code class="varname">A</code> automáticamente cuando
      ve que que el primer argumento es un entero y no hay un segundo
      argumento.  El compilador ha detectado un argumento por defecto,
      así que sabe que todavía puede llamar a la función si substituye
      este segundo argumento, que es lo que usted le ha dicho que
      haga al no poner ese argumento.
    </p><p>
      Los argumentos por defecto, al igual que la sobrecarga de funciones,
      son muy convenientes. Ambas características le permiten utilizar un
      único nombre para una función en situaciones diferentes. La
      diferencia está en que el compilador substituye los argumentos por
      defecto cuando no se ponen. El ejemplo anterior en un buen
      ejemplo para utilizar argumentos por defecto en vez de la sobrecarga
      de funciones; de otra modo se encuentra con dos o más funciones
      que tienen signaturas y comportamientos similares. Si las funciones
      tienen comportamientos muy diferentes, normalmente no tiene sentido
      utilizar argumentos por defecto (de hecho, debería preguntarse
      si dos funciones con comportamientos muy diferentes deberían
      llamarse igual).
    </p><p>
      Hay dos reglas que se deben tener en cuenta cuando se utilizan
      argumentos por defecto. La primera es que sólo los últimos pueden
      ser por defecto, es decir, no puede poner un argumento por defecto
      seguido de otro que no lo es. La segunda es que una vez se empieza
      a utilizar los argumentos por defecto al realizar una llamada a
      una función, el resto de argumentos también serán por defecto (esto
      sigue a la primera regla).
    </p><p>
      Los argumentos por defecto sólo se colocan en la declaración de la
      función (normalmente en el fichero de cabecera). El compilador
      debe conocer el valor por defecto antes de utilizarlo. Hay gente
      que pone los valores por defecto comentados en la definición por
      motivos de documentación.
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">fn</span><span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl com">/* = 0 */</span><span class="hl opt">) {</span> <span class="hl slc">// ...</span>
</pre><div class="sect2" title="7.4.1. Argumentos de relleno"><div class="titlepage"><div><div><h3 class="title"><a id="idp5984344"></a>7.4.1. Argumentos de relleno</h3></div></div></div><p>
	Los argumentos de una función pueden declararse sin
	identificadores. Cuando esto se hace con argumentos por
	defecto, puede parecer gracioso. Puede encontrarse con
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">float</span> <span class="hl opt">=</span> <span class="hl num">1.1</span><span class="hl opt">);</span>
</pre><p>
	En C++, la definición de la función tampoco necesita
	identificadores:
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">float</span> flt<span class="hl opt">) {</span> <span class="hl com">/* ... */</span> <span class="hl opt">}</span>
</pre><p>
	En el cuerpo de la función, se puede hacer referencia a
	<em class="parameter"><code>x</code></em> y a <em class="parameter"><code>flt</code></em>, pero
	no al argumento de en medio puesto que no tiene nombre. A
	pesar de esto, las llamadas a función deben proporcionar un
	valor para este argumento de relleno: <code class="code">f(1)</code> ó
	<code class="code">f(1, 2, 3,0)</code>. Esta sintaxis permite poner el
	argumento como un argumento de relleno sin utilizarlo. La idea
	es que podría querer cambiar la definición de la función para
	utilizar el argumento de relleno más tarde, sin cambiar todo
	el código en que ya se invoca la función. Por supuesto, puede
	obtener el mismo resultado utilizando un argumento con nombre,
	pero en ese caso está definiendo el argumento para el cuerpo
	de la función sin que éste lo utilice, y la mayoría de los
	compiladores darán un mensaje de aviso, dando por hecho que
	usted ha cometido un error. Si deja el argumento sin nombre
	intencionadamente, evitará la advertencia.
      </p><p>
	Más importante, si empieza utilizando un argumento que más
	tarde decide dejar de utilizar, puede quitarlo sin generar
	avisos ni fastidiar al código cliente que esté utilizando la
	versión anterior de la función.
      </p></div></div><div class="sect1" title="7.5. Elección entre sobrecarga y argumentos por defecto"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5989808"></a>7.5. Elección entre sobrecarga y argumentos por defecto</h2></div></div></div><p>
      Tanto la sobrecarga de funciones como los argumentos por defecto
      resultan útiles para ponerle nombre a las funciones. Sin embargo, a
      veces puede resultar confuso saber qué técnica utilizar. Por ejemplo,
      estudie la siguiente herramienta que está diseñada para tratar
      automáticamente bloques de memoria:
    </p><div class="example"><a id="idp5991128"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Mem.h</span>
<span class="hl ppc">#ifndef MEM_H</span>
<span class="hl ppc">#define MEM_H</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned char</span> byte<span class="hl opt">;</span>

<span class="hl kwc">class</span> Mem <span class="hl opt">{</span>
  byte<span class="hl opt">*</span> mem<span class="hl opt">;</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">ensureMinSize</span><span class="hl opt">(</span><span class="hl kwb">int</span> minSize<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Mem</span><span class="hl opt">();</span>
  <span class="hl kwd">Mem</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">Mem</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">msize</span><span class="hl opt">();</span>
  byte<span class="hl opt">*</span> <span class="hl kwd">pointer</span><span class="hl opt">();</span>
  byte<span class="hl opt">*</span> <span class="hl kwd">pointer</span><span class="hl opt">(</span><span class="hl kwb">int</span> minSize<span class="hl opt">);</span>
<span class="hl opt">};</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// MEM_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.9. C07/Mem.h</strong></p></div><br class="example-break" /><p>
      El objeto <code class="classname">Mem</code> contiene un bloque de
      octetos y se asegura de que tiene suficiente memoria. El
      constructor por defecto no reserva memoria pero el segundo
      constructor se asegura de que hay <em class="parameter"><code>sz</code></em>
      octetos de memoria en el objeto <code class="classname">Mem</code>. El
      destructor libera la memoria, <code class="methodname">msize()</code>
      le dice cuántos octetos hay actualmente en
      <code class="classname">Mem</code> y
      <code class="methodname">pointer()</code> retorna un puntero al
      principio de la memoria reservada (<code class="classname">Mem</code>
      es una herramienta a bastante bajo nivel).  Hay una versión
      sobrecargada de <code class="methodname">pointer()</code> que los
      programadores clientes pueden utilizar para obtener un puntero
      que apunta a un bloque de memoria con al menos el tamaño
      <code class="varname">minSize</code>, y el método lo asegura.
    </p><p>
      El constructor y el método <code class="methodname">pointer()</code>
      utilizan el método privado
      <code class="methodname">ensureMinSize()</code> para incrementar el
      tamaño del bloque de memoria (note que no es seguro mantener el
      valor de retorno de <code class="methodname">pointer()</code> si se
      cambia el tamaño del bloque de memoria).
    </p><p>
      He aquí la implementación de la clase:
    </p><div class="example"><a id="idp5997200"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Mem.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Mem.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

Mem<span class="hl opt">::</span><span class="hl kwd">Mem</span><span class="hl opt">() {</span> mem <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> size <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>

Mem<span class="hl opt">::</span><span class="hl kwd">Mem</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  mem <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  size <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">ensureMinSize</span><span class="hl opt">(</span>sz<span class="hl opt">);</span> 
<span class="hl opt">}</span>

Mem<span class="hl opt">::~</span><span class="hl kwd">Mem</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> <span class="hl opt">[]</span>mem<span class="hl opt">; }</span>

<span class="hl kwb">int</span> Mem<span class="hl opt">::</span><span class="hl kwd">msize</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> size<span class="hl opt">; }</span>

<span class="hl kwb">void</span> Mem<span class="hl opt">::</span><span class="hl kwd">ensureMinSize</span><span class="hl opt">(</span><span class="hl kwb">int</span> minSize<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>size <span class="hl opt">&lt;</span> minSize<span class="hl opt">) {</span>
    byte<span class="hl opt">*</span> newmem <span class="hl opt">=</span> <span class="hl kwa">new</span> byte<span class="hl opt">[</span>minSize<span class="hl opt">];</span>
    <span class="hl kwd">memset</span><span class="hl opt">(</span>newmem <span class="hl opt">+</span> size<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> minSize <span class="hl opt">-</span> size<span class="hl opt">);</span>
    <span class="hl kwd">memcpy</span><span class="hl opt">(</span>newmem<span class="hl opt">,</span> mem<span class="hl opt">,</span> size<span class="hl opt">);</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span>mem<span class="hl opt">;</span>
    mem <span class="hl opt">=</span> newmem<span class="hl opt">;</span>
    size <span class="hl opt">=</span> minSize<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

byte<span class="hl opt">*</span> Mem<span class="hl opt">::</span><span class="hl kwd">pointer</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> mem<span class="hl opt">; }</span>

byte<span class="hl opt">*</span> Mem<span class="hl opt">::</span><span class="hl kwd">pointer</span><span class="hl opt">(</span><span class="hl kwb">int</span> minSize<span class="hl opt">) {</span>
  <span class="hl kwd">ensureMinSize</span><span class="hl opt">(</span>minSize<span class="hl opt">);</span>
  <span class="hl kwa">return</span> mem<span class="hl opt">;</span> 
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.10. C07/Mem.cpp</strong></p></div><br class="example-break" /><p>
      Puede observar que <code class="methodname">ensureMinSize()</code> es
      la única función responsable de reservar memoria y que la
      utilizan tanto el segundo constructor como la segunda versión
      sobrecargada de <code class="methodname">pointer()</code>. Dentro de
      <code class="methodname">ensureSize()</code> no se hace nada si el
      tamaño es lo suficientemente grande. Si se ha de reservar más
      memoria para que el bloque sea más grande (que es el mismo
      caso cuando el bloque tiene tamaño cero después del
      constructor por defecto), la nueva porción de más se pone a
      cero utilizando la función de la librería estándar de C
      <code class="function">memset()</code>, que fue presentada en el
      Capítulo 5. La siguiente llamada es a la función de la
      librería estándar de C <code class="function">memcpy()</code>, que en
      este caso copia los octetos existentes de
      <code class="varname">mem</code> a <code class="varname">newmem</code>
      (normalmente de una manera eficaz).  Finalmente, se libera la
      memoria antigua y se asignan a los atributos apropiados la
      nueva memoria y su tamaño.
    </p><p>
      La clase <code class="classname">Mem</code> se ha diseñado para su
      utilización como herramienta dentro de otras clases para
      simplificar su gestión de la memoria (también se podría
      utilizar para ocultar un sistema de gestión de memoria más
      avanzada proporcionado, por ejemplo, por el el sistema
      operativo). Esta clase se comprueba aquí con una simple
      clase de tipo <code class="type">string</code>:
    </p><div class="example"><a id="idp6003696"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:MemTest.cpp</span>
<span class="hl slc">// Testing the Mem class</span>
<span class="hl slc">//{L} Mem</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Mem.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> MyString <span class="hl opt">{</span>
  Mem<span class="hl opt">*</span> buf<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MyString</span><span class="hl opt">();</span>
  <span class="hl kwd">MyString</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> str<span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">MyString</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">concat</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> str<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">);</span>
<span class="hl opt">};</span>

MyString<span class="hl opt">::</span><span class="hl kwd">MyString</span><span class="hl opt">() {</span>  buf <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>

MyString<span class="hl opt">::</span><span class="hl kwd">MyString</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> str<span class="hl opt">) {</span>
  buf <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Mem</span><span class="hl opt">(</span><span class="hl kwd">strlen</span><span class="hl opt">(</span>str<span class="hl opt">) +</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">strcpy</span><span class="hl opt">((</span><span class="hl kwb">char</span><span class="hl opt">*)</span>buf<span class="hl opt">-&gt;</span><span class="hl kwd">pointer</span><span class="hl opt">(),</span> str<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> MyString<span class="hl opt">::</span><span class="hl kwd">concat</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>buf<span class="hl opt">)</span> buf <span class="hl opt">=</span> <span class="hl kwa">new</span> Mem<span class="hl opt">;</span>
  <span class="hl kwd">strcat</span><span class="hl opt">((</span><span class="hl kwb">char</span><span class="hl opt">*)</span>buf<span class="hl opt">-&gt;</span><span class="hl kwd">pointer</span><span class="hl opt">(</span>
    buf<span class="hl opt">-&gt;</span><span class="hl kwd">msize</span><span class="hl opt">() +</span> <span class="hl kwd">strlen</span><span class="hl opt">(</span>str<span class="hl opt">) +</span> <span class="hl num">1</span><span class="hl opt">),</span> str<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> MyString<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>buf<span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
  os <span class="hl opt">&lt;&lt;</span> buf<span class="hl opt">-&gt;</span><span class="hl kwd">pointer</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

MyString<span class="hl opt">::~</span><span class="hl kwd">MyString</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> buf<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  MyString <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;My test string&quot;</span><span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span>cout<span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">concat</span><span class="hl opt">(</span><span class="hl str">&quot; some additional stuff&quot;</span><span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span>cout<span class="hl opt">);</span>
  MyString s2<span class="hl opt">;</span>
  s2<span class="hl opt">.</span><span class="hl kwd">concat</span><span class="hl opt">(</span><span class="hl str">&quot;Using default constructor&quot;</span><span class="hl opt">);</span>
  s2<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span>cout<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.11. C07/MemTest.cpp</strong></p></div><br class="example-break" /><p>
      Todo lo que puede hacer con esta clase es crear un
      <code class="classname">MyString</code>, concatenar texto e imprimir a
      un <code class="classname">ostream</code>. La clase sólo contiene un
      puntero a un <code class="classname">Mem</code>, pero note la
      diferencia entre el constructor por defecto, que pone el
      puntero a cero, y el segundo constructor, que crea un
      <code class="classname">Mem</code> y copia los datos dentro del
      mismo. La ventaja del constructor por defecto es que puede
      crear, por ejemplo, un array grande de objetos
      <code class="classname">MyString</code> vacíos con pocos recursos,
      pues el tamaño de cada objeto es sólo un puntero y la única
      sobrecarga en el rendimiento del constructor por defecto es el
      de asignarlo a cero.  El coste de un
      <code class="classname">MyString</code> sólo empieza a aumentar cuando
      concatena datos; en ese momento el objeto
      <code class="classname">Mem</code> se crea si no ha sido creado todavía.
      Sin embargo, si utiliza el constructor por defecto y nunca
      concatena ningún dato, la llamada al destructor todavía es
      segura porque cuando se llama a <code class="keyword">delete</code>
      con un puntero a cero, el compilador no hace nada para no
      causar problemas.
    </p><p>
      Si mira los dos constructores, en principio, podría parecer que
      son candidatos para utilizar argumentos por defecto. Sin embargo,
      si elimina el constructor por defecto y escribe el constructor que
      queda con un argumento por defecto:
    </p><pre class="programlisting">
<span class="hl kwd">MyString</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> str <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
</pre><p>
      todo funcionará correctamente, pero perderá la eficacia anterior
      pues siempre se creará el objeto <code class="classname">Mem</code>. Para
      volver a tener la misma eficacia de antes, ha de modificar el
      constructor:
    </p><pre class="programlisting">
MyString<span class="hl opt">::</span><span class="hl kwd">MyString</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl kwa">if</span> <span class="hl opt">(!*</span>str<span class="hl opt">) {</span> <span class="hl slc">// Apunta a un string vacío</span>
    buf <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  buf <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Mem</span><span class="hl opt">(</span><span class="hl kwd">strlen</span><span class="hl opt">(</span>str<span class="hl opt">) +</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">strcpy</span><span class="hl opt">((</span><span class="hl kwb">char</span><span class="hl opt">*)</span>buf<span class="hl opt">-&gt;</span><span class="hl kwd">pointer</span><span class="hl opt">(),</span> str<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre><p>
      Esto significa, en efecto, que el valor por defecto es un caso que
      ha de tratarse separadamente de un valor que no lo es. Aunque
      parece algo inocente con un pequeño constructor como éste, en
      general esta práctica puede causar problemas. Si tiene que tratar
      por separado el valor por defecto en vez de tratarlo como un valor
      ordinario, debería ser una pista para que al final se implementen
      dos funciones diferentes dentro de una función: una versión para
      el caso normal y otra para el caso por defecto. Podría partirlo en
      dos cuerpos de función diferentes y dejar que el compilador
      elija. Esto resulta en un ligero (pero normalmente invisible)
      incremento de la eficacia porque el argumento extra no se pasa y
      por tanto el código extra debido a la condición condición no se
      ejecuta. Más importante es que está manteniendo el código
      <span class="emphasis"><em>en</em></span> dos funciones separadas en vez de
      combinarlas en una utilizando argumentos por defecto, lo que
      resultará en un mantenimiento más sencillo, sobre todo si las
      funciones son largas.
    </p><p>
      Por otro lado, considere la clase <code class="classname">Mem</code>. Si
      mira las definiciones de los dos constructores y las dos
      funciones <code class="methodname">pointer()</code>, puede ver que la
      utilización de argumentos por defecto en ambos casos no causará
      que los métodos cambien. Así, la clase podría ser fácilmente:
    </p><div class="example"><a id="idp6015672"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C07:Mem2.h</span>
<span class="hl ppc">#ifndef MEM2_H</span>
<span class="hl ppc">#define MEM2_H</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned char</span> byte<span class="hl opt">;</span>

<span class="hl kwc">class</span> Mem <span class="hl opt">{</span>
  byte<span class="hl opt">*</span> mem<span class="hl opt">;</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">ensureMinSize</span><span class="hl opt">(</span><span class="hl kwb">int</span> minSize<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Mem</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">Mem</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">msize</span><span class="hl opt">();</span>
  byte<span class="hl opt">*</span> <span class="hl kwd">pointer</span><span class="hl opt">(</span><span class="hl kwb">int</span> minSize <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">};</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// MEM2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.12. C07/Mem2.h</strong></p></div><br class="example-break" /><p>
      Note que la llamada a <code class="code">ensureMinSize(0)</code>
      siempre será bastante eficiente.
    </p><p>
      Aunque ambos casos se basan en decisiones por motivos de
      eficacia, debe tener cuidado para no caer en la trampa de pensar
      sólo en la eficacia (siempre fascinante). Lo más importante en
      el diseño de una clase es la interfaz de la clase (sus miembros
      públicos, que son las que el programador cliente tiene a su
      disposición). Si se implementa una clase fácil de utilizar y
      reutilizar, entonces ha tenido éxito; siempre puede realizar
      ajustes para mejorar la eficacia en caso necesario, pero el
      efecto de una clase mal diseñada porque el programador está
      obsesionado con la eficacia puede resultar grave. Su primera
      preocupación debería ser que la interfaz tenga sentido para
      aquéllos que la utilicen y para los que lean el código. Note que
      en <code class="filename">MemTest.cpp</code> el uso de
      <code class="classname">MyString</code> no cambia independientemente de
      si se utiliza el constructor por defecto o si la eficacia es
      buena o mala.
    </p></div><div class="sect1" title="7.6. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6019224"></a>7.6. Resumen</h2></div></div></div><p>
      Como norma, no debería utilizar argumentos por defecto si hay que
      incluir una condición en el código. En vez de eso debería partir la
      función en dos o más funciones sobrecargadas si puede. Un argumento
      por defecto debería ser un valor que normalmente pondría ahí. Es el
      valor que es más probable que ocurra, para que los programadores
      clientes puedan hacer caso omiso de él o sólo lo pongan cuando no
      quieran utilizar el valor por defecto.
    </p><p>
      El argumento por defecto se incluye para hacer más fáciles las
      llamadas a función, especialmente cuando esas funciones tiene muchos
      argumentos con valores típicos. No sólo es mucho más sencillo
      escribir las llamadas, sino que además son más sencillas de leer,
      especialmente si el creador de la clase ordena los argumentos de tal
      manera que aquéllos que menos cambian se ponen al final del todo.
    </p><p>
      Una utilización especialmente importante de los argumentos por
      defecto es cuando empieza con una función con un conjunto de
      argumentos, y después de utilizarla por un tiempo se da cuenta
      que necesita añadir más argumentos. Si pone los nuevos argumentos
      como por defecto, se asegura de que no se rompe el código cliente
      que utiliza la interfaz anterior.
    </p></div><div class="sect1" title="7.7. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6022232"></a>7.7. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Cree una clase <code class="classname">Text</code> que
	  contenga un objeto <code class="type">string</code> para que
	  guarde el texto de un fichero. Póngale dos constructores: un
	  constructor por defecto y un constructor que tome un
	  argumento de tipo <code class="type">string</code> que sea el
	  nombre del fichero que se vaya a abrir. Cuando se utilice el
	  segundo constructor, abra el fichero y ponga su contenido en
	  el atributo <code class="type">string</code>. Añada un método
	  llamado <code class="function">contents()</code> que retorne el
	  <code class="type">string</code> para que, por ejemplo, se pueda
	  imprimir. En <code class="function">main()</code> abra un fichero
	  utilizando <code class="classname">Text</code> e imprima el contenido
	  en pantalla.
	</p></li><li class="listitem"><p>
	  Cree una clase <code class="classname">Message</code> con un
	  constructor que tome un sólo <code class="type">string</code> con
	  un valor por defecto. Cree un atributo privado
	  <code class="type">string</code> y asigne en el constructor el
	  argumento <code class="type">string</code> al atributo
	  <code class="type">string</code>.  Cree dos métodos sobrecargados
	  llamados <code class="function">print()</code>: uno que no tome
	  argumentos y que imprima simplemente el mensaje guardado en
	  el objeto, y el otro que tome un argumento
	  <code class="type">string</code>, que imprima el mensaje interno
	  además del argumento. ¿Tiene sentido utilizar esta
	  aproximación en vez de la utilizada por el constructor?
	</p></li><li class="listitem"><p>
	  Descubra cómo generar código ensamblador con su compilador
	  y haga experimentos para deducir el esquema de decoración de
	  nombres.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga cuatro métodos con 0,
	  1, 2 y 3 argumentos de tipo <code class="keyword">int</code>
	  respectivamente. Cree un <code class="function">main()</code> que
	  haga un objeto de su clase y llame a cada método. Ahora
	  modifique la clase para que tenga sólo un método con todos
	  los argumentos por defecto. ¿Eso cambia su
	  <code class="function">main()</code>?
	</p></li><li class="listitem"><p>
	  Cree una función con dos argumentos y llámela desde
	  <code class="function">main()</code>. Ahora haga que uno de los
	  argumentos sea un argumento de relleno (sin identificador) y
	  compruebe si necesita hacer cambios en
	  <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Stash3.h</code> y
	  <code class="filename">Stash3.cpp</code> para que el constructor
	  utilice argumentos por defecto. Pruebe el constructor
	  haciendo dos versiones diferentes de un objeto
	  <code class="classname">Stash</code>.
	</p></li><li class="listitem"><p>
	  Cree una nueva versión de la clase <code class="classname">Stack</code>
	  (del Capítulo 6) que contenga el constructor por defecto al
	  igual que antes, y un segundo constructor que tome como
	  argumentos un array de punteros a objetos y el tamaño del
	  array. Este constructor debería recorrer el array y poner cada
	  puntero en la pila (<code class="classname">Stack</code>). Pruebe su
	  clase con un array de <code class="type">string</code>'s.
	</p></li><li class="listitem"><p>
	  Modifique <code class="classname">SuperVar</code> para que haya
	  <code class="keyword">#ifdef</code>'s que engloben el código de
	  <code class="varname">vartype</code> tal como se describe en la
	  sección sobre enumeraciones. Cambie
	  <code class="varname">vartype</code> como una enumeración pública (sin
	  ejemplares) y modifique <code class="function">print()</code> para
	  que requiera un argumento de tipo <code class="varname">vartype</code>
	  que le indique qué tiene qué hacer.
	</p></li><li class="listitem"><p>
	  Implemente <code class="filename">Mem2.h</code> y asegúrese
	  de que la clase modificada todavía funciona con
	  <code class="filename">MemTest.cpp</code>.
	</p></li><li class="listitem"><p>
	  Utilice la clase <code class="classname">Mem</code> para implementar
	  <code class="classname">Stash</code>. Note que debido a que la
	  implementación es privada y por tanto oculta al programador
	  cliente, no necesita modificar el código de prueba.
	</p></li><li class="listitem"><p>
	  Añada un método <span class="emphasis"><em>bool moved()</em></span> en la
	  clase <code class="classname">Mem</code> que tome el resultado de
	  una llamada a <code class="function">pointer()</code> y le diga si el
	  puntero ha cambiado (debido a una reasignación). Escriba una
	  función <code class="function">main()</code> que pruebe su método
	  <code class="function">moved()</code>. ¿Tiene más sentido utilizar
	  algo como <code class="function">moved()</code> o simplemente invocar
	  <code class="function">pointer()</code> cada vez que necesite acceder
	  a la memoria de <code class="classname">Mem</code>?
	</p></li></ol></div></div></div><div class="chapter" title="8: Constantes"><div class="titlepage"><div><div><h2 class="title"><a id="C08"></a>8: Constantes</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp6052400">8.1. Sustitución de valores</a></span></dt><dt><span class="sect1"><a href="#idp6107968">8.2. Punteros</a></span></dt><dt><span class="sect1"><a href="#idp6138272">8.3. Argumentos de funciones y valores de retorno</a></span></dt><dt><span class="sect1"><a href="#idp6197520">8.4. Clases</a></span></dt><dt><span class="sect1"><a href="#idp6277896">8.5. Volatile</a></span></dt><dt><span class="sect1"><a href="#idp6293576">8.6. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6298544">8.7. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      El concepto de constante (expresión con la palabra reservada
      <code class="keyword">const</code>) se creó para permitir a los programadores marcar
      la diferencia entre lo que puede cambiar y lo que no. Esto
      facilita el control y la seguridad en un proyecto de
      programación.
    </p></div><p>
    Desde su origen, <code class="keyword">const</code> ha sido utilizada para diferentes
    propósitos. Mientras tanto FIXME:it trickled back en el lenguaje C
    en el que su significado cambió. Todo esto puede parecer un poco
    confuso al principio, y en este capítulo aprenderá cuándo, porqué
    y cómo usar la palabra reservada <code class="keyword">const</code>. Hacia el final se
    expone una disertación sobre <span class="emphasis"><em>volatile</em></span>, que es
    familia de <code class="keyword">const</code> (ambos se refieren a los cambios) y su
    sintaxis es idéntica.
  </p><p>
    El primer motivo para la creación de <code class="keyword">const</code> parece que fue
    eliminar el uso de la directiva del preprocesador <code class="keyword">#define</code>
    para sustitución de valores. Desde entonces se usa para punteros,
    argumentos de funciones, tipos de retorno, objetos y funciones
    miembro. Todos ellos tienen pequeñas diferencias pero su
    significado es conceptualmente compatible. Se tratarán en las siguientes
    secciones de este capítulo.
  </p><div class="sect1" title="8.1. Sustitución de valores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6052400"></a>8.1. Sustitución de valores</h2></div></div></div><p>
      Cuando se programa en C, se usa libremente el preprocesador para
      crear macros y sustituir valores. El preprocesador simplemente
      hace un reemplazo textual y no realiza ninguna comprobación de
      tipo. Por ello, la sustitución de valores introduce pequeños
      problemas que se pueden evitar usando valores constantes.
    </p><p>
      El uso más frecuente del preprocesador es la sustitución de
      valores por nombres, en C es algo como:
    </p><pre class="programlisting">
<span class="hl ppc">#define BUFSIZE 100</span>
</pre><p>
      <code class="varname">BUFSIZE</code> es un nombre que sólo existe durante
      el preprocesado. Por tanto, no ocupa memoria y se puede colocar
      en un fichero de cabecera para ofrecer un valor único a todas
      las unidades que lo utilicen. Es muy importante para el
      mantenimiento del código el uso de sustitución de valores en
      lugar de los también llamados «números mágicos». Si
      usa números mágicos en su código. no solamente impedirá al
      lector conocer su procedencia o significado si no que complicará
      innecesariamente la edición del código si necesita cambiar
      dicho valor.
    </p><p>
      La mayor parte del tiempo, <code class="varname">BUFSIZE</code> se
      comportará como un valor ordinario, pero no siempre. No tiene
      información de tipo. Eso puede esconder errores difíciles de
      localizar. C++ utiliza <code class="keyword">const</code> para eliminar estos
      problemas llevando la sustitución de valores al terreno del
      compilador. Ahora, puede escribir:
    </p><pre class="programlisting">
<span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
</pre><p>
      Puede colocar <code class="varname">bufsize</code> en cualquier lugar
      donde se necesite conocer el valor en tiempo de compilación. El
      compilador utiliza <code class="varname">bufsize</code> para hacer
      <span class="emphasis"><em>propagación de constantes</em></span><sup>[<a id="idp6059224" href="#ftn.idp6059224" class="footnote">61</a>]</sup>, que significa que el
      compilador reduce una expresión constante complicada a un valor
      simple realizando los cálculos necesarios en tiempo de
      compilación. Esto es especialmente importante en las
      definiciones de vectores:
    </p><pre class="programlisting">
<span class="hl kwb">char</span> buf<span class="hl opt">[</span>bufsize<span class="hl opt">];</span>
</pre><p>
      Puede usar <code class="keyword">const</code> con todos los tipos
      básicos(<code class="type">char</code>, <code class="type">int</code>, <code class="type">float</code>
      y <code class="type">double</code>) y sus variantes (así como clases y todo
      lo que verá después en este capítulo). Debido a los problemas
      que introduce el preprocesador deberá utilizar siempre
      <code class="keyword">const</code> en lugar de <code class="keyword">#define</code> para la sustitución
      de valores.
    </p><div class="sect2" title="8.1.1. const en archivos de cabecera"><div class="titlepage"><div><div><h3 class="title"><a id="idp6063784"></a>8.1.1. <code class="keyword">const</code> en archivos de cabecera</h3></div></div></div><p>
	Para poder usar <code class="keyword">const</code> en lugar de <code class="keyword">#define</code>,
	debe ser posible colocar las definiciones <code class="keyword">const</code> en
	los archivos de cabecera como se hacía con los
	<code class="keyword">#define</code>.  De este modo, puede colocar la definición
	de una constante en un único lugar y distribuirla incluyendo
	el archivo de cabecera en las unidades del programa que la
	necesiten.  Una constante en C++ utiliza <span class="emphasis"><em>enlazado
	interno</em></span>, es decir, es visible sólo desde el archivo
	donde se define y no puede verse en tiempo de enlazado por
	otros módulos. Deberá asignar siempre un valor a las
	constantes cuando las defina, excepto cuando explícitamente
	use la declaración <code class="keyword">extern</code>:
      </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> bufsize<span class="hl opt">;</span>
</pre><p>
	Normalmente el compilador de C++ evita la asignación de
	memoria para las constantes, pero en su lugar ocupa una
	entrada en la tabla de símbolos.  Cuando se utiliza
	<code class="keyword">extern</code> con una constante, se fuerza el alojamiento en
	memoria (esto también ocurre en otros casos, como cuando se
	solicita la dirección de una constante). El uso de la memoria
	debe hacerse porque <code class="keyword">extern</code> dice «usa enlazado
	externo», es decir, que varios módulos deben ser
	capaces de hacer referencia al elemento, algo que requiere su
	almacenamiento en memoria.
      </p><p>
	Por lo general, cuando <code class="keyword">extern</code> no forma parte de
	la definición, no se pide memoria. Cuando la constante se utiliza
	simplemente se incorpora en tiempo de compilación.
      </p><p>
	El objetivo de no almacenar en memoria las constantes tampoco
	se cumple con estructuras complicadas. Cuando el compilador se
	ve obligado a pedir memoria no puede realizar
	<span class="emphasis"><em>propagación de constantes</em></span> (ya que el
	compilador no tiene forma de conocer con seguridad que valor
	debe almacenar; si lo conociese, no necesitaría pedir
	memoria).
      </p><p>
	Como el compilador no siempre puede impedir el almacenamiento
	para una constante, las definiciones de constantes utilizan
	enlace interno, es decir, se enlazan sólo con el módulo en que
	se definen. En caso contrario, los errores de enlace podrían
	ocurrir con las expresiones constantes complicadas ya que
	causarían petición de almacenamiento en diferentes
	módulos. Entonces, el enlazador vería la misma definición en
	múltiples archivos objeto, lo que causaría un error en el
	enlace. Como las constantes utilizan enlace interno, el
	enlazador no intenta enlazar esas definiciones a través de los
	módulos, y así no hay colisiones.  Con los tipos básicos, que
	son los se ven involucrados en la mayoría de los casos, el
	compilador siempre realiza propagación de constantes.
      </p></div><div class="sect2" title="8.1.2. constantes seguras"><div class="titlepage"><div><div><h3 class="title"><a id="idp6074488"></a>8.1.2. constantes seguras</h3></div></div></div><p>
        El uso de las constantes no está limitado a la sustitución de
        los <code class="keyword">#define</code> por expresiones constantes. Si inicializa
        una variable con un valor que se produce en tiempo de ejecución
        y sabe que no cambiará durante la
	 vida de la variable, es una buena práctica
        de programación hacerla constante para que de ese modo el
        compilador produzca un mensaje de error si accidentalmente
        alguien intenta modificar dicha variable. Aquí hay un ejemplo:
      </p><div class="example"><a id="idp6076512"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Safecons.cpp</span>
<span class="hl slc">// Using const for safety</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">const int</span> i <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>  <span class="hl slc">// Typical constant</span>
<span class="hl kwb">const int</span> j <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">;</span> <span class="hl slc">// Value from const expr</span>
<span class="hl kwb">long</span> address <span class="hl opt">= (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>j<span class="hl opt">;</span> <span class="hl slc">// Forces storage</span>
<span class="hl kwb">char</span> buf<span class="hl opt">[</span>j <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">];</span> <span class="hl slc">// Still a const expression</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type a character &amp; CR:&quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">const char</span> c <span class="hl opt">=</span> cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span> <span class="hl slc">// Can't change</span>
  <span class="hl kwb">const char</span> c2 <span class="hl opt">=</span> c <span class="hl opt">+</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> c2<span class="hl opt">;</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.1. C08/Safecons.cpp</strong></p></div><br class="example-break" /><p>
        Puede ver que <code class="constant">i</code> es una constante en
        tiempo de compilación, pero <code class="constant">j</code> se calcula
        a partir de <code class="constant">i</code>. Sin embargo, como
        <code class="constant">i</code> es una constante, el valor calculado
        para <code class="constant">j</code> es una expresión constante y es en
        si mismo otra constante en tiempo de compilación. En la
        siguiente línea se necesita la dirección de
        <code class="constant">j</code> y por lo tanto el compilador se ve
        obligado a pedir almacenamiento para
        <code class="constant">j</code>. Ni siquiera eso impide el uso de
        <code class="constant">j</code> para determinar el tamaño de
        <code class="varname">buf</code> porque el compilador sabe que
        <code class="constant">j</code> es una constante y que su valor es
        válido aunque se asigne almacenamiento, ya que eso se hace
        para mantener el valor en algún punto en el programa.
      </p><p>
        En <code class="function">main()</code>, aparece un tipo diferente de
        constante en el identificador <code class="constant">c</code>, porque el
        valor no puede ser conocido en tiempo de compilación. Eso
        significa que se requiere almacenamiento, y por eso el
        compilador no intenta mantener nada en la tabla de símbolos (el
        mismo comportamiento que en C). La inicialización debe ocurrir,
        aún así, en el punto de la definición, y una vez que ocurre la
        inicialización, el valor ya no puede ser cambiado. Puede ver que
        <code class="constant">c2</code> se calcula a partir de
        <code class="constant">c</code> y además las reglas de ámbito funcionan
        para las constantes igual que para cualquier otro tipo, otra
        ventaja respecto al uso de <code class="keyword">#define</code>.
      </p><p>
	En la práctica, si piensa que una variable no debería cambiar,
	debería hacer que fuese una constante. Esto no sólo da seguridad
	contra cambios inadvertidos, también permite al compilador
	generar código más eficiente ahorrando espacio de almacenamiento
	y lecturas de memoria en la ejecución del programa.
      </p></div><div class="sect2" title="8.1.3. Vectores"><div class="titlepage"><div><div><h3 class="title"><a id="idp6085048"></a>8.1.3. Vectores</h3></div></div></div><p>
	Es posible usar constantes para los vectores, pero
	prácticamente está dando por hecho que el compilador no será
	lo suficientemente sofisticado para mantener un vector en la
	tabla de símbolos, así que le asignará espacio de
	almacenamiento. En estas situaciones, <code class="keyword">const</code> significa
	«un conjunto de datos en memoria que no pueden
	modificarse». En cualquier caso, sus valores no puede
	usarse en tiempo de compilación porque el compilador no conoce
	en ese momento los contenidos de las variables que tienen
	espacio asignado. En el código siguiente puede ver algunas
	declaraciones incorrectas.
      </p><div class="example"><a id="idp6087416"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Constag.cpp</span>
<span class="hl slc">// Constants and aggregates</span>
<span class="hl kwb">const int</span> i<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">};</span>
<span class="hl slc">//! float f[i[3]]; // Illegal</span>
<span class="hl kwb">struct</span> S <span class="hl opt">{</span> <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">; };</span>
<span class="hl kwb">const</span> S s<span class="hl opt">[] = { {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span> <span class="hl opt">}, {</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">} };</span>
<span class="hl slc">//! double d[s[1].j]; // Illegal</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.2. C08/Constag.cpp</strong></p></div><br class="example-break" /><p>
	En la definición de un vector, el compilador debe ser capaz de
	generar código que mueva el puntero de pila para dar cabida al
	vector. En las definiciones incorrectas anteriores, el
	compilador se queja porque no puede encontrar una expresión
	constante en la definición del tamaño del vector.
      </p></div><div class="sect2" title="8.1.4. Diferencias con C"><div class="titlepage"><div><div><h3 class="title"><a id="idp6089416"></a>8.1.4. Diferencias con C</h3></div></div></div><p>
	Las constantes se introdujeron en las primeras versiones de
	C++ mientras la especificación del estándar C estaba siendo
	terminada. Aunque el comité a cargo de C decidió entonces
	incluir <code class="keyword">const</code> en C, por alguna razón, vino
	a significar para ellos «una variable ordinaria que no
	puede cambiarse». En C, una constante siempre ocupa
	espacio de almacenamiento y su ámbito es global. El compilador
	C no puede tratar <code class="keyword">const</code> como una constante
	en tiempo de compilación. En C, si escribe:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
<span class="hl kwb">char</span> buf<span class="hl opt">[</span>bufsize<span class="hl opt">];</span>
</pre><p>
	aparecerá un error, aunque parezca algo
	razonable. <code class="constant">bufsize</code> está guardado en algún
	sitio y el compilador no conoce su valor en tiempo de
	compilación. Opcionalmente puede escribir:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span> bufsize<span class="hl opt">;</span>
</pre><p>
	en C, pero no en C++, y el compilador C lo acepta como una
	declaración que indica que se almacenará en alguna parte. Como
	C utiliza enlace externo para las constantes, esa semántica
	tiene sentido. C++ utiliza normalmente enlace interno, así
	que, si quiere hacer lo mismo en C++, debe indicar
	expresamente que se use enlace externo usando <code class="keyword">extern</code>.
      </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> bufsize<span class="hl opt">;</span>  <span class="hl slc">// es declaración, no definición</span>
</pre><p>
        Esta declaración también es válida en C.
      </p><p>
        En C++, <code class="keyword">const</code> no implica necesariamente
        almacenamiento. En C, las constantes siempre necesitan
        almacenamiento. El hecho de que se necesite almacenamiento o no
        depende de cómo se use la constante. En general, si una
        constante se usa simplemente para reemplazar un número por un
        nombre (como hace <code class="keyword">#define</code>), entonces no requiere
        almacenamiento. Si es así (algo que depende de la complejidad
        del tipo de dato y de lo sofisticación del compilador) los
        valores pueden expandirse en el código para conseguir mayor
        eficiencia después de la comprobación de los tipos, no como con
        <code class="keyword">#define</code>. Si de todas formas, se necesita la dirección
        de una constante (aún desconocida, para pasarla a una función
        como argumento por referencia) o se declara como
        <code class="keyword">extern</code>, entonces se requiere asignar almacenamiento
        para la constante.
      </p><p>
        En C++, una constante que esté definida fuera de todas las
        funciones tiene ámbito de archivo (es decir, es inaccesible
        fuera del archivo). Esto significa que usa enlace
        interno. Esto es diferente para el resto de identificadores en
        C++ (y que las constantes en C) que utilizan siempre enlace
        externo. Por eso, si declara una constante con el mismo nombre
        en dos archivos diferentes y no toma sus
	
        direcciones ni los define como <code class="keyword">extern</code>, el compilador
        C++ ideal no asignará almacenamiento para la constante,
        simplemente la expandirá en el código. Como las constantes
        tienen implícito el ámbito a su archivo, puede ponerlas en un
        archivo de cabecera de C++ sin que origine conflictos en el
        enlace.
      </p><p>
	Dado que las constante en C++ utilizan por defecto enlace
	interno, no puede definir una constante en un archivo y
	utilizarla desde otro. Para conseguir enlace externo para la
	constante y así poder usarla desde otro archivo, debe
	definirla explícitamente como <code class="keyword">extern</code>, algo
	así:
      </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> x <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>  <span class="hl slc">// definición, no declaración</span>
</pre><p>
	Señalar que dado un identificador, si se dice que es
	<code class="keyword">extern</code>, se fuerza el almacenamiento para la
	constante (aunque el compilador tenga la opción de hacer la
	expansión en ese punto). La inicialización establece que la
	sentencia es una definición, no una declaración. La
	declaración:
      </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> x<span class="hl opt">;</span>
</pre><p>
	en C++ significa que la definición existe en algún sitio
	(mientras que en C no tiene porqué ocurrir así). Ahora puede
	ver porqué C++ requiere que las definiciones de constantes
	incluyan la inicialización: la inicialización diferencia una
	declaración de una definición (en C siempre es una definición,
	aunque no esté inicializada). Con una declaración <code class="keyword">const
	extern</code>, el compilador no hace expansión de la constante
	porque no conoce su valor.
      </p><p>
	La aproximación de C a las constantes es poco útil, y si quiere
	usar un valor simbólico en una expresión constante (que deba
	evaluarse en tiempo de compilación) casi está obligado a usar
	<code class="keyword">#define</code>.
      </p></div></div><div class="sect1" title="8.2. Punteros"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6107968"></a>8.2. Punteros</h2></div></div></div><p>
      Los punteros pueden ser constantes. El compilador pondrá más
      esfuerzo aún para evitar el almacenamiento y hacer expansión de
      constantes cuando se trata de punteros constantes, pero estas
      características parecen menos útiles en este caso.
      
      Lo más importante es que el compilador le avisará si intenta
      cambiar un puntero constante, lo que representa un buen elemento
      de seguridad. Cuando se usa <code class="keyword">const</code> con punteros tiene dos
      opciones: se pueden aplicar a lo que apunta el puntero o a la
      propia dirección almacenada en el puntero. La sintaxis es un poco
      confusa al principio pero se vuelve cómodo con la práctica.
    </p><div class="sect2" title="8.2.1. Puntero a constante"><div class="titlepage"><div><div><h3 class="title"><a id="idp6110192"></a>8.2.1. Puntero a constante</h3></div></div></div><p>
	El truco con la definición de un puntero, al igual que con una
	definición complicada, es leerla empezando por el
	identificador e ir analizando la definición hacia afuera. El
	especificador <code class="keyword">const</code> está ligado a la cosa
	«más cercana».  Así que si se quiere impedir
	cambios en el elemento apuntado, escribe una definición
	parecida a esta:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span><span class="hl opt">*</span> u<span class="hl opt">;</span>
</pre><p>
	Empezando por el identificador, se lee
	«<code class="varname">u</code> es un puntero, que apunta a un
	entero constante». En este caso no se requiere
	inicialización porque está diciendo que <code class="varname">u</code>
	puede apuntar a cualquier cosa (es decir, no es constante),
	pero la cosa a la que apunta no puede cambiar.
      </p><p>
	Ahora viene la parte confusa. Podría pensar que hacer el puntero
	inalterable en si mismo, es decir, impedir cualquier cambio en
	la dirección que contiene <code class="varname">u</code>, es tan simple
	como mover la palabra <code class="keyword">const</code> al otro lado de la
	palabra <code class="type">int</code>:
      </p><pre class="programlisting">
<span class="hl kwb">int const</span><span class="hl opt">*</span> v<span class="hl opt">;</span>
</pre><p>
	y pensar que esto debería leerse «<code class="varname">v</code>
	es un puntero constante a un entero». Sin embargo, la
	forma de leerlo es «<code class="varname">v</code> es un puntero
	ordinario a un entero que es constante». Es decir, la
	palabra <code class="keyword">const</code> se refiere de nuevo al
	<code class="type">entero</code> y el efecto es el mismo que en la
	definición previa.  El hecho de que estas definiciones sean
	equivalentes es confuso, para evitar esta confusión por parte
	del lector del código, debería ceñirse a la primera forma.
      </p></div><div class="sect2" title="8.2.2. Puntero constante"><div class="titlepage"><div><div><h3 class="title"><a id="idp6117856"></a>8.2.2. Puntero constante</h3></div></div></div><p>
	Para conseguir que el puntero sea inalterable, debe colocar el
	especificador <code class="keyword">const</code> a la derecha del *:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> d <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl opt">*</span> <span class="hl kwb">const</span> w <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span>
</pre><p>
	Ahora, se lee «<code class="constant">w</code> es un puntero
	constate, y apunta a un <code class="type">entero</code>». Como el
	puntero en sí es ahora una constante, el compilador obliga a
	darle un valor inicial que no podrá alterarse durante la vida
	del puntero. En cualquier caso, puede cambiar el valor de lo
	que apunta el puntero con algo como:
      </p><pre class="programlisting">
<span class="hl opt">*</span>w <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span>
</pre><p>
	También puede hacer un puntero constante a un elemento constante
	usando una de las formas siguientes:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> d <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwb">const int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> x <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span>  <span class="hl slc">// (1)</span>
<span class="hl kwb">int const</span><span class="hl opt">*</span> <span class="hl kwb">const</span> x2 <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span> <span class="hl slc">// (2)</span>
</pre><p>
        Ahora ni el puntero ni el elemento al que apunta pueden
        modificarse.
      </p><p>
	Algunos argumentan que la segunda forma es más consistente
	porque el <code class="keyword">const</code> se coloca siempre a la derecha de lo
	que afecta. Debe decidir que forma resulta más clara para su
	estilo de codificación particular.
      </p><p>
	Algunas líneas de un archivo susceptible de ser compilado.
      </p><div class="example"><a id="idp6123784"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:ConstPointers.cpp</span>
<span class="hl kwb">const int</span><span class="hl opt">*</span> u<span class="hl opt">;</span>
<span class="hl kwb">int const</span><span class="hl opt">*</span> v<span class="hl opt">;</span>
<span class="hl kwb">int</span> d <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> w <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span>
<span class="hl kwb">const int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> x <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span>  <span class="hl slc">// (1)</span>
<span class="hl kwb">int const</span><span class="hl opt">*</span> <span class="hl kwb">const</span> x2 <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span> <span class="hl slc">// (2)</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.3. C08/ConstPointers.cpp</strong></p></div><br class="example-break" /><div class="sect3" title="Formato"><div class="titlepage"><div><div><h4 class="title"><a id="idp6125120"></a>Formato</h4></div></div></div><p>
          Este libro sigue la norma de poner sólo una definición de
          puntero por línea, e inicializar cada puntero en el punto de
          definición siempre que sea posible. Por eso, el estilo es
          colocar el <span class="symbol">*</span> al lado del tipo:
        </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> u <span class="hl opt">= &amp;</span>i<span class="hl opt">;</span>
</pre><p>
	  como si <code class="type">int*</code> fuese un tipo de dato básico. Esto
	  hace que el código sea más fácil de leer, pero
	  desafortunadamente, esta no es la forma en que funciona. El
	  «<span class="symbol">*</span>» se refiere al
	  identificador no al tipo. Se puede colocar en cualquier
	  sitio entre el nombre del tipo y el identificador. De modo
	  que puede hacer esto:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl opt">*</span> u <span class="hl opt">= &amp;</span>i<span class="hl opt">,</span> v <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
</pre><p>
	  donde se crea un <code class="code">int* u</code> y después un <code class="code">int
	 v</code> (que no es puntero). Como esto puede parecer confuso
	 a los lectores, es mejor utilizar el estilo mostrado en este
	 libro.
	</p></div></div><div class="sect2" title="8.2.3. Asignación y comprobación de tipos"><div class="titlepage"><div><div><h3 class="title"><a id="idp6129240"></a>8.2.3. Asignación y comprobación de tipos</h3></div></div></div><p>
	C++ es muy exigente en lo referente a la comprobación de tipos
	y esto se extiende a la asignación de punteros. Puede asignar
	la dirección de una variable no constante a un puntero
	constante porque simplemente está prometiendo no cambiar algo
	que puede cambiarse. De todos modos, no puede asignar la
	dirección de una variable constante a un puntero no constante
	porque entonces está diciendo que podría modificar la variable
	a través del puntero. Por supuesto, siempre puede usar
	«un molde» para forzar la asignación, pero eso es
	siempre una mala práctica de programación ya que rompe la
	consistencia de la variable además del grado de seguridad que
	ofrece el especificador <code class="keyword">const</code>. Por ejemplo:
      </p><div class="example"><a id="idp6131656"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:PointerAssignment.cpp</span>
<span class="hl kwb">int</span> d <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwb">const int</span> e <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> u <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span> <span class="hl slc">// OK -- d not const</span>
<span class="hl slc">//! int* v = &amp;e; // Illegal -- e const</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> w <span class="hl opt">= (</span><span class="hl kwb">int</span><span class="hl opt">*)&amp;</span>e<span class="hl opt">;</span> <span class="hl slc">// Legal but bad practice</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.4. C08/PointerAssignment.cpp</strong></p></div><br class="example-break" /><p>
	Aunque C++ ayuda a evitar errores, no le protege de usted
	mismo si se empeña en romper los mecanismos de seguridad.
      </p><div class="sect3" title="Literales de cadena"><div class="titlepage"><div><div><h4 class="title"><a id="idp6133464"></a>Literales de cadena</h4></div></div></div><p>
	  C++ no es tan estricto con los literales en lo referente a
	  constantes. Puede escribir:
	</p><pre class="programlisting">
<span class="hl kwb">char</span> <span class="hl opt">*</span> cp <span class="hl opt">=</span> <span class="hl str">&quot;howdy&quot;</span><span class="hl opt">;</span>
</pre><p>
	  y el compilador lo aceptará sin objeción. Técnicamente esto
	  supone un error porque el literal de cadena
	  («<code class="literal">howdy</code>» en este caso) se crea
	  por el compilador como un vector de caracteres constante, y el
	  resultado del vector de caracteres entrecomillado es la
	  dirección de memoria del primer elemento. Si se modifica uno
	  de los caracteres del vector en tiempo de ejecución es un
	  error, aunque no todos los compiladores lo imponen
	  correctamente.
	</p><p>
	  Así que los literales de cadena son arrays de caracteres
	  constantes. Por supuesto, el compilador le permite tratarlos como
	  no constantes porque existe mucho código C que depende de ello. De
	  todas formas, si intenta cambiar los valores de un literal, el
	  resultado no está definido, y probablemente funcione en muchos
	  computadores.
	</p><p>
	  Si quiere poder modificar una cadena, debe ponerla en un vector:
	</p><pre class="programlisting">
<span class="hl kwb">char</span> cp<span class="hl opt">[] =</span> <span class="hl str">&quot;howdy&quot;</span><span class="hl opt">;</span>
</pre><p>
	  Como los compiladores a menudo no imponen la diferencia no
	  tiene porqué recordar que debe usar esta la última forma y
	  la cuestión pasa a ser algo bastante sutil.
	</p></div></div></div><div class="sect1" title="8.3. Argumentos de funciones y valores de retorno"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6138272"></a>8.3. Argumentos de funciones y valores de retorno</h2></div></div></div><p>
      El uso del especificador <code class="keyword">const</code> con argumentos de
      funciones y valores de retorno es otro lugar donde el concepto
      de constante puede resultar confuso.  Si está pasando variables
      por valor, utilizar <code class="keyword">const</code> no tiene significado para el
      cliente (significa que el argumento que se pasa no puede
      modificarse en la función). Si está devolviendo una variable de
      un tipo derivado y utiliza el especificador <code class="keyword">const</code>,
      significa que el valor de retorno no puede modificarse. Si pasa
      o devuelve direcciones, <code class="keyword">const</code> impide que el
      destinatario de la dirección pueda modificarse.
    </p><div class="sect2" title="8.3.1. Paso por valor constante"><div class="titlepage"><div><div><h3 class="title"><a id="idp6141888"></a>8.3.1. Paso por valor constante</h3></div></div></div><p>
	Puede indicar que los argumentos de funciones son constantes
	cuando se pasa por valor como:
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f1</span><span class="hl opt">(</span><span class="hl kwb">const int</span> i<span class="hl opt">) {</span>
    i<span class="hl opt">++;</span> <span class="hl slc">// ilegal</span>
<span class="hl opt">}</span>
</pre><p>
	pero, ¿qué significa esto? Está impidiendo que el valor de la
	variable original pueda ser cambiado en la función
	<code class="function">f1()</code>. De todos formas, como el
	argumento se pasa por valor, es sabido que inmediatamente se
	hace una copia de la variable original, así que dicha
	restricción se cumple implícitamente sin necesidad de usar
	el especificador <code class="keyword">const</code>.
      </p><p>
	Dentro de la función, <code class="keyword">const</code> si toma un significado:
	El argumento no se puede cambiar. Así que, en realidad, es una
	herramienta para el programador de la función, no para el que
	la usa.
      </p><p>
	Para evitar la confusión del usuario de la función, puede hacer
	que el argumento sea constante dentro de la función en lugar de en
	la lista de argumentos. Podría hacerlo con un puntero, pero la
	sintaxis más adecuada para lograrlo es la referencia, algo que se
	tratará en profundidad en el capitulo 11[FIXME:XREF].
      </p><p>
	Brevemente, una referencia es como un puntero constante que
	se dereferencia automáticamente, así que es como tener un
	alias de la variable. Para crear una referencia, debe usar
	el símbolo <span class="symbol">&amp;</span> en la definición. De ese
	modo se tiene una definición libre de confusiones.
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f2</span><span class="hl opt">(</span><span class="hl kwb">int</span> ic<span class="hl opt">) {</span>
    <span class="hl kwb">const int</span> <span class="hl opt">&amp;</span>i <span class="hl opt">=</span> ic<span class="hl opt">;</span>
    i<span class="hl opt">++;</span>  <span class="hl slc">// ilegal (error de compilación)</span>
<span class="hl opt">}</span>
</pre><p>
	De nuevo, aparece un mensaje de error, pero esta vez el
	especificador <code class="keyword">const</code> no forma parte de la
	cabecera de la función, solo tiene sentido en la
	implementación de la función y por la tanto es invisible para
	el cliente.
      </p></div><div class="sect2" title="8.3.2. Retorno por valor constante"><div class="titlepage"><div><div><h3 class="title"><a id="idp6149296"></a>8.3.2. Retorno por valor constante</h3></div></div></div><p>
	Algo similar ocurre con los valores de retorno. Si dice que el
	valor de retorno de una función es constante:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span> <span class="hl kwd">g</span><span class="hl opt">();</span>
</pre><p>
	está diciendo que el valor de la variable original (en el ámbito de
	la función) no se modificará. Y de nuevo, como lo está devolviendo
	por valor, es la copia lo que se retorna, de modo que el valor
	original nunca se podrá modificar.
      </p><p>
	En principio, esto puede hacer suponer que el especificador
	<code class="keyword">const</code> tiene poco significado. Puede ver la aparente
	falta de sentido de devolver constantes por valor en este
	ejemplo:
      </p><div class="example"><a id="idp6152072"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Constval.cpp</span>
<span class="hl slc">// Returning consts by value</span>
<span class="hl slc">// has no meaning for built-in types</span>

<span class="hl kwb">int</span> <span class="hl kwd">f3</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>
<span class="hl kwb">const int</span> <span class="hl kwd">f4</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> j <span class="hl opt">=</span> <span class="hl kwd">f3</span><span class="hl opt">();</span> <span class="hl slc">// Works fine</span>
  <span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl kwd">f4</span><span class="hl opt">();</span> <span class="hl slc">// But this works fine too!</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.5. C08/Constval.cpp</strong></p></div><br class="example-break" /><p>
	Para los tipos básicos, no importa si el retorno es
	constante, así que debería evitar la confusión para el
	programador cliente y no utilizar <code class="keyword">const</code>
	cuando se devuelven variables de tipos básicos por valor.
      </p><p>
	Devolver por valor como constante se vuelve importante cuando
	se trata con tipos definidos por el programador. Si una
	función devuelve un objeto por valor como constante, el valor
	de retorno de la función no puede ser un recipiente
	<sup>[<a id="idp6154944" href="#ftn.idp6154944" class="footnote">62</a>]</sup>
      </p><p>
	Por ejemplo:
      </p><div class="example"><a id="idp6156096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:ConstReturnValues.cpp</span>
<span class="hl slc">// Constant return by value</span>
<span class="hl slc">// Result cannot be used as an lvalue</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">modify</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

X<span class="hl opt">::</span><span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">; }</span>

<span class="hl kwb">void</span> X<span class="hl opt">::</span><span class="hl kwd">modify</span><span class="hl opt">() {</span> i<span class="hl opt">++; }</span>

X <span class="hl kwd">f5</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">X</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">const</span> X <span class="hl kwd">f6</span><span class="hl opt">() {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">X</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">f7</span><span class="hl opt">(</span>X<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span> <span class="hl slc">// Pass by non-const reference</span>
  x<span class="hl opt">.</span><span class="hl kwd">modify</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">f5</span><span class="hl opt">() =</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// OK -- non-const return value</span>
  <span class="hl kwd">f5</span><span class="hl opt">().</span><span class="hl kwd">modify</span><span class="hl opt">();</span> <span class="hl slc">// OK</span>
<span class="hl slc">//!  f7(f5()); // Causes warning or error</span>
<span class="hl slc">// Causes compile-time errors:</span>
<span class="hl slc">//!  f6() = X(1);</span>
<span class="hl slc">//!  f6().modify();</span>
<span class="hl slc">//!  f7(f6());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.6. C08/ConstReturnValues.cpp</strong></p></div><br class="example-break" /><p>
	<code class="function">f5()</code> devuelve un objeto de clase
	<code class="classname">X</code> no constante, mientras que
	<code class="function">f6()</code> devuelve un objeto de clase
	<code class="classname">X</code> pero constante. Solo el valor de
	retorno por valor no constante se puede usar como recipiente.
      </p><p>
	Por eso, es importante usar <code class="keyword">const</code> cuando se devuelve
	un objeto por valor si quiere impedir que se use como
	recipiente.
      </p><p>
	La razón por la que <code class="keyword">const</code> no tiene sentido cuando se
	usa para devolver por valor variables de tipos del lenguaje es
	que el compilador impide automáticamente el uso de dichos
	tipos como recipiente, ya que devuelve un valor, no una
	variable. Solo cuando se devuelven objetos por valor de tipos
	definidos por el programador esta funcionalidad toma
	sentido.
      </p><p>
	La función <code class="function">f7()</code> toma como argumento una
	referencia no constante (la referencia es una forma adicional
	para manejar direcciones en C++ y se trata en el
	[FIXME:XREF:capitulo 11]). Es parecido a tomar un puntero no
	constante, aunque la sintaxis es diferente. La razón por la
	que no compila es por la creación de un temporario.
      </p><div class="sect3" title="Temporarios"><div class="titlepage"><div><div><h4 class="title"><a id="idp6162536"></a>Temporarios</h4></div></div></div><p>
	  A veces, durante la evaluación de una expresión, el compilador
	  debe crear objetos temporales (temporarios). Son objetos como
	  cualquier otro: requieren espacio de almacenamiento y se deben
	  construir y destruir. La diferencia es que nunca se ven, el
	  compilador es el responsable de decidir si se necesitan y los
	  detalles de su existencia. Una particularidad importante de los
	  temporarios es que siempre son constantes. Como normalmente no
	  manejará objetos temporarios, hacer algo que cambie un temporario
	  es casi seguro un error porque no será capaz de usar esa
	  información. Para evitar esto, el compilador crea todos los
	  temporarios como objetos constantes, de modo que le avisará si
	  intenta modificarlos.
	</p><p>
	  En el ejemplo anterior, <code class="function">f5()</code> devuelve
	  un objeto no constante. Pero en la expresión:
	</p><pre class="programlisting">
<span class="hl kwd">f7</span><span class="hl opt">(</span><span class="hl kwd">f5</span><span class="hl opt">());</span>
</pre><p>
	  el compilador debe crear un temporario para albergar el
	  valor de retorno de <code class="function">f5()</code> para que pueda
	  ser pasado a <code class="function">f7()</code>. Esto funcionaría
	  bien si <code class="function">f7()</code> tomara su argumento por
	  valor; entonces el temporario se copiaría en
	  <code class="function">f7()</code> y no importaría lo que se pase al
	  temporario X.
	</p><p>
	  Sin embargo, <code class="function">f7()</code> toma su argumento por
	  referencia, lo que significa que toma la dirección del
	  temporario X. Como <code class="function">f7()</code> no toma su
	  argumento por referencia constante, tiene permiso para
	  modificar el objeto temporario. Pero el compilador sabe que
	  el temporario desaparecerá en cuanto se complete la
	  evaluación de la expresión, y por eso cualquier modificación
	  hecha en el temporario se perderá.  Haciendo que los objetos
	  temporarios sean constantes automáticamente, la situación
	  causa un error de compilación de modo que evitará cometer un
	  error muy difícil de localizar.
	</p><p>
	  En cualquier caso, tenga presente que las expresiones
	  siguientes son correctas:
	</p><pre class="programlisting">
<span class="hl kwd">f5</span><span class="hl opt">() =</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl kwd">f5</span><span class="hl opt">().</span><span class="hl kwd">modify</span><span class="hl opt">();</span>
</pre><p>
	  Aunque son aceptables para el compilador, en realidad son
	  problemáticas.  <code class="function">f5()</code> devuelve un
	  objeto de clase <code class="classname">X</code>, y para que el
	  compilador pueda satisfacer las expresiones anteriores
	  debe crear un temporario para albergar el valor de
	  retorno. De modo que en ambas expresiones el objeto
	  temporario se modifica y tan pronto como la expresión es
	  evaluada el temporario se elimina. Como resultado, las
	  modificaciones se pierden, así que probablemente este
	  código es erróneo, aunque el compilador no diga nada al
	  respecto. Las expresiones como éstas son suficientemente
	  simples como para detectar el problema, pero cuando las
	  cosas son más complejas los errores son más difíciles de
	  localizar.
	</p><p>
	  La forma de preservar la constancia de los objetos se
	  muestra más adelante en este capítulo.
	</p></div></div><div class="sect2" title="8.3.3. Paso y retorno de direcciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp6173056"></a>8.3.3. Paso y retorno de direcciones</h3></div></div></div><p>
	Si pasa o retorna una dirección (ya sea un puntero o una
	referencia), el programador cliente puede recoger y modificar
	el valor al que apunta. Si hace que el puntero o referencia
	sea constante, impedirá que esto suceda, lo que puede
	ahorrarle problemas. De hecho, cada vez que se pasa una
	dirección como parámetro a una función, debería hacerla
	constante siempre que sea posible. Si no lo hace, está
	excluyendo la posibilidad de usar la función con constantes.
      </p><p>
	La opción de devolver un puntero o referencia constante
	depende de lo que quiera permitir hacer al programador
	cliente. Aquí se muestra un ejemplo que demuestra el uso de
	punteros constantes como argumentos de funciones y valores de
	retorno.
      </p><div class="example"><a id="idp6174992"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:ConstPointer.cpp</span>
<span class="hl slc">// Constant pointer arg/return</span>

<span class="hl kwb">void</span> <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*) {}</span>

<span class="hl kwb">void</span> <span class="hl kwd">u</span><span class="hl opt">(</span><span class="hl kwb">const int</span><span class="hl opt">*</span> cip<span class="hl opt">) {</span>
<span class="hl slc">//!  *cip = 2; // Illegal -- modifies value</span>
  <span class="hl kwb">int</span> i <span class="hl opt">= *</span>cip<span class="hl opt">;</span> <span class="hl slc">// OK -- copies value</span>
<span class="hl slc">//!  int* ip2 = cip; // Illegal: non-const</span>
<span class="hl opt">}</span>

<span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwd">v</span><span class="hl opt">() {</span>
  <span class="hl slc">// Returns address of static character array:</span>
  <span class="hl kwa">return</span> <span class="hl str">&quot;result of function v()&quot;</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">const int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl kwd">w</span><span class="hl opt">() {</span>
  <span class="hl kwb">static int</span> i<span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl opt">&amp;</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">= &amp;</span>x<span class="hl opt">;</span>
  <span class="hl kwb">const int</span><span class="hl opt">*</span> cip <span class="hl opt">= &amp;</span>x<span class="hl opt">;</span>
  <span class="hl kwd">t</span><span class="hl opt">(</span>ip<span class="hl opt">);</span>  <span class="hl slc">// OK</span>
<span class="hl slc">//!  t(cip); // Not OK</span>
  <span class="hl kwd">u</span><span class="hl opt">(</span>ip<span class="hl opt">);</span>  <span class="hl slc">// OK</span>
  <span class="hl kwd">u</span><span class="hl opt">(</span>cip<span class="hl opt">);</span> <span class="hl slc">// Also OK</span>
<span class="hl slc">//!  char* cp = v(); // Not OK</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> ccp <span class="hl opt">=</span> <span class="hl kwd">v</span><span class="hl opt">();</span> <span class="hl slc">// OK</span>
<span class="hl slc">//!  int* ip2 = w(); // Not OK</span>
  <span class="hl kwb">const int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> ccip <span class="hl opt">=</span> <span class="hl kwd">w</span><span class="hl opt">();</span> <span class="hl slc">// OK</span>
  <span class="hl kwb">const int</span><span class="hl opt">*</span> cip2 <span class="hl opt">=</span> <span class="hl kwd">w</span><span class="hl opt">();</span> <span class="hl slc">// OK</span>
<span class="hl slc">//!  *w() = 1; // Not OK</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.7. C08/ConstPointer.cpp</strong></p></div><br class="example-break" /><p>
	La función <code class="function">t()</code> toma un puntero no-constante
	ordinario como argumento, y <code class="function">u()</code> toma un
	puntero constante. En el cuerpo de <code class="function">u()</code>
	puede ver un intento de modificar el valor de un puntero
	constante, algo incorrecto, pero puede copiar su valor en una
	variable no constante. El compilador también impide crear un
	puntero no constante y almacenar en él la dirección contenida en
	un puntero constante.
      </p><p>
	Las funciones <code class="function">v()</code> y
	<code class="function">w()</code> prueban las semánticas de retorno de
	valores. <code class="function">v()</code> devuelve un <code class="type">const
	char*</code> que se crea a partir de un literal de
	cadena. Esta sentencia en realidad genera la dirección del
	literal una vez que el compilador lo crea y almacena en área
	de almacenamiento estática. Como se ha dicho antes,
	técnicamente este vector de caracteres es una constante, como
	bien indica el tipo de retorno de <code class="function">v()</code>.
      </p><p>
	El valor de retorno de <code class="function">w()</code> requiere que
	tanto el puntero como lo que apunta sean constantes. Como en
	<code class="function">v()</code>, el valor devuelto por
	<code class="function">w()</code> es valido una vez terminada la
	función solo porque es estático. Nunca debe devolver un
	puntero a una variable local pues se almacenan en la pila y al
	terminar la función los datos de la pila desaparecen. Lo que
	si puede hacer es devolver punteros que apuntan a datos
	almacenados en el montón
	(<span class="foreignphrase"><em class="foreignphrase">heap</em></span>), pues siguen siendo
	validos después de terminar la función.
      </p><p>
	En <code class="function">main()</code> se prueban las funciones con
	varios argumentos. Puede ver que <code class="function">t()</code>
	aceptará como argumento un puntero ordinario, pero si
	intenta pasarle un puntero a una constante, no hay garantía
	de que no vaya a modificarse el valor de la variable
	apuntada; por ello el compilador lo indica con un mensaje de
	error. <code class="function">u()</code> toma un puntero a constante,
	así que puede aceptar los dos tipos de argumentos. Por eso
	una función que acepta un puntero a constante es más general
	que una que acepta un puntero ordinario.
      </p><p>
	Como es lógico, el valor de retorno de
	<code class="function">v()</code> sólo se puede asignar a un puntero a
	constante. También era de esperar que el compilador rehuse
	asignar el valor devuelto por <code class="function">w()</code> a un
	puntero ordinario, y que sí acepte un <code class="type">const int*
	const</code>, pero podría sorprender un poco que también
	acepta un <code class="type">const int*</code>, que no es exactamente el
	tipo de retorno declarado en la función. De nuevo, como el
	valor (que es la dirección contenida en el puntero) se copia,
	el requisito de que la variable original permanezca
	inalterable se cumple automáticamente. Por eso, el segundo
	<code class="keyword">const</code> en la declaración <code class="type">const int* const</code>
	sólo se aplica cuando lo use como recipiente, en cuyo caso el
	compilador lo impediría.
      </p><div class="sect3" title="Criterio de paso de argumentos"><div class="titlepage"><div><div><h4 class="title"><a id="idp6189048"></a>Criterio de paso de argumentos</h4></div></div></div><p>
	  En C es muy común el paso por valor, y cuando se quiere
	  pasar una dirección la única posibilidad es usar un
	  puntero<sup>[<a id="idp6189824" href="#ftn.idp6189824" class="footnote">63</a>]</sup>. Sin
	  embargo, ninguno de estos modos es el preferido en C++. En
	  su lugar, la primera opción cuando se pasa un parámetro es
	  hacerlo por referencia o mejor aún, por referencia
	  constante. Para el cliente de la función, la sintaxis es
	  idéntica que en el paso por valor, de ese modo no hay
	  confusión posible con los punteros, no hay que pensar en
	  términos de punteros. Para el creador de una función, pasar
	  una dirección es siempre más eficiente que pasar un objeto
	  completo, y si pasa por referencia constante significa que
	  la función no podrá cambiar lo almacenado en esa dirección,
	  así que el efecto desde el punto de vista del programador
	  cliente es lo mismo que el paso por valor (sin embargo es
	  más eficiente).
	</p><p>
	  A causa de la sintaxis de las referencias (para el cliente
	  es igual que el paso por valor) es posible pasar un objeto
	  temporario a una función que toma una referencia constante,
	  mientras que nunca puede pasarse un objeto temporario a una
	  función que toma un puntero (con un puntero, la dirección
	  debe darse explícitamente). Así que con el paso por
	  referencia se produce una nueva situación que nunca ocurre
	  en C: un temporario, que es siempre constante, puede pasar
	  su dirección a una función (una función puede tomar por
	  argumento la dirección de un temporario). Esto es así
	  porque, para permitir que los temporarios se pasen por
	  referencia, el argumento debe ser una referencia
	  constante. El siguiente ejemplo lo demuestra:
	</p><div class="example"><a id="idp6192568"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:ConstTemporary.cpp</span>
<span class="hl slc">// Temporaries are const</span>

<span class="hl kwc">class</span> X <span class="hl opt">{};</span>

X <span class="hl kwd">f</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">X</span><span class="hl opt">(); }</span> <span class="hl slc">// Return by value</span>

<span class="hl kwb">void</span> <span class="hl kwd">g1</span><span class="hl opt">(</span>X<span class="hl opt">&amp;) {}</span> <span class="hl slc">// Pass by non-const reference</span>
<span class="hl kwb">void</span> <span class="hl kwd">g2</span><span class="hl opt">(</span><span class="hl kwb">const</span> X<span class="hl opt">&amp;) {}</span> <span class="hl slc">// Pass by const reference</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Error: const temporary created by f():</span>
<span class="hl slc">//!  g1(f());</span>
  <span class="hl slc">// OK: g2 takes a const reference:</span>
  <span class="hl kwd">g2</span><span class="hl opt">(</span><span class="hl kwd">f</span><span class="hl opt">());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.8. C08/ConstTemporary.cpp</strong></p></div><br class="example-break" /><p>
	  <code class="function">f()</code> retorna un objeto de la clase
	  <code class="classname">X</code> por valor. Esto significa que
	  cuando tome el valor de retorno y lo pase inmediatamente a
	  otra función como en las llamadas a
	  <code class="function">g1()</code> y <code class="function">g2()</code>, se
	  crea un temporario y los temporarios son siempre
	  constantes. Por eso, la llamada a <code class="function">g1()</code>
	  es un error pues <code class="function">g1()</code> no acepta una
	  referencia constante, mientras que la llamada a
	  <code class="function">g2()</code> sí es correcta.
	</p></div></div></div><div class="sect1" title="8.4. Clases"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6197520"></a>8.4. Clases</h2></div></div></div><p>
      Esta sección muestra la forma en la que se puede usar el
      especificador <code class="keyword">const</code> con las clases. Puede ser
      interesante crear una constante local a una clase para usarla en
      expresiones constantes que serán evaluadas en tiempo de
      compilación. Sin embargo, el significado del especificador
      <code class="keyword">const</code> es diferente para las clases
      <sup>[<a id="idp6199640" href="#ftn.idp6199640" class="footnote">64</a>]</sup>, de modo que debe comprender las
      opciones adecuadas para crear miembros constantes en una clase.
    </p><p>
      También se puede hacer que un objeto completo sea constante (y
      como se ha visto, el compilador siempre hace constantes los
      objetos temporarios). Pero preservar la consistencia de un objeto
      constante es más complicado. El compilador puede asegurar la
      consistencia de las variables de los tipos del lenguaje pero no
      puede vigilar la complejidad de una clase. Para garantizar dicha
      consistencia se emplean las funciones miembro constantes; que son
      las únicas que un objeto constante puede invocar.
    </p><div class="sect2" title="8.4.1. const en las clases"><div class="titlepage"><div><div><h3 class="title"><a id="idp6200968"></a>8.4.1. <code class="keyword">const</code> en las clases</h3></div></div></div><p>
	Uno de los lugares donde interesa usar <code class="keyword">const</code> es para
	expresiones constantes dentro de las clases. El ejemplo típico
	es cuando se define un vector en una clase y se quiere usar
	<code class="keyword">const</code> en lugar de <code class="keyword">#define</code> para establecer el
	tamaño del vector y para usarlo al calcular datos
	concernientes al vector.  El tamaño del vector es algo que
	desea mantener oculto en la clase, así que si usa un nombre
	como <code class="varname">size</code>, por ejemplo, se podría usar el
	mismo nombre en otra clase sin que ocurra un conflicto. El
	preprocesador trata todos los <code class="keyword">#define</code> de forma global
	a partir del punto donde se definen, algo que <code class="keyword">const</code>
	permite corregir de forma adecuada consiguiendo el efecto
	deseado.
      </p><p>
	Se podría pensar que la elección lógica es colocar una
	constante dentro de la clase. Esto no produce el resultado
	esperado. Dentro de una clase <code class="keyword">const</code>
	recupera un poco su significado en C. Asigna espacio de
	almacenamiento para cada variable y representa un valor que
	es inicializado y ya no se puede cambiar. El uso de una
	constante dentro de una clase significa «Esto es constante
	  durante la vida del objeto». Por otra parte, en cada objeto
	la constante puede contener un valor diferente.
      </p><p>
	Por eso, cuando crea una constante ordinaria (no estática) dentro
	de una clase, no puede darle un valor inicial. Esta inicialización
	debe ocurrir en el constructor. Como la constante se debe
	inicializar en el punto en que se crea, en el cuerpo del
	constructor la constante debe estar ya inicializada. De otro modo,
	le quedaría la opción de esperar hasta algún punto posterior en el
	constructor, lo que significaría que la constante no tendría valor
	por un momento. Y nada impediría cambiar el valor de la constante
	en varios sitios del constructor.
      </p><div class="sect3" title="La lista de inicialización del constructor."><div class="titlepage"><div><div><h4 class="title"><a id="idp6208168"></a>La lista de inicialización del constructor.</h4></div></div></div><p>
	  Un punto especial de inicialización es la llamada
	    «lista de inicialización del constructor» y
	    fue pensada en un principio para su uso en herencia
	    (tratada en el [FIXME:XREF:capítulo 14]). La lista de
	    inicialización del constructor (que como su nombre indica,
	    sólo aparece en la definición del constructor) es una
	    lista de llamadas a constructores que aparece después de
	    la lista de argumentos del constructor y antes de abrir la
	    llave del cuerpo del constructor.

          

	  Se hace así para recordarle que las inicialización de la
	  lista sucede antes de ejecutarse el constructor. Ese es el lugar
	  donde poner las inicializaciones de todas las constantes de la
	  clase. El modo apropiado para colocar las constantes en una clase
	  se muestra a continuación:
	</p><div class="example"><a id="idp6209984"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:ConstInitialization.cpp</span>
<span class="hl slc">// Initializing const in classes</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Fred <span class="hl opt">{</span>
  <span class="hl kwb">const int</span> size<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Fred</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

Fred<span class="hl opt">::</span><span class="hl kwd">Fred</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) :</span> <span class="hl kwd">size</span><span class="hl opt">(</span>sz<span class="hl opt">) {}</span>
<span class="hl kwb">void</span> Fred<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> size <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Fred <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
  a<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(),</span> b<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(),</span> c<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.9. C08/ConstInitialization.cpp</strong></p></div><br class="example-break" /><p>
	  El aspecto de la lista de inicialización del constructor
	  mostrada arriba puede crear confusión al principio porque no
	  es usual tratar los tipos del lenguaje como si tuvieran
	  constructores.
	</p></div><div class="sect3" title="Constructores para los tipos del lenguaje"><div class="titlepage"><div><div><h4 class="title"><a id="idp6212208"></a>Constructores para los tipos del lenguaje</h4></div></div></div><p>
	  Durante el desarrollo del lenguaje se puso más esfuerzo en
	  hacer que los tipos definidos por el programador se
	  pareciesen a los tipos del lenguaje, pero a veces, cuando
	  se vio útil se hizo que los tipos predefinidos
	  (<span class="foreignphrase"><em class="foreignphrase">built-in</em></span> se pareciesen a
	  los definidos por el programador. En la lista de
	  inicialización del constructor, puede tratar a los tipos
	  del lenguaje como si tuvieran un constructor, como aquí:
	</p><div class="example"><a id="idp6213848"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:BuiltInTypeConstructors.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> B <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

B<span class="hl opt">::</span><span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
<span class="hl kwb">void</span> B<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  B <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwb">float</span> <span class="hl kwd">pi</span><span class="hl opt">(</span><span class="hl num">3.14159</span><span class="hl opt">);</span>
  a<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span> b<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> pi <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.10. C08/BuiltInTypeConstructors.cpp</strong></p></div><br class="example-break" /><p>
	  Esto es especialmente crítico cuando se inicializan
	  atributos constantes porque se deben inicializar antes de
	  entrar en el cuerpo de la función.  Tiene sentido extender
	  este «constructor» para los tipos del lenguaje
	  (que simplemente significan asignación) al caso general que
	  es por lo que la definición <code class="type">float</code> funciona en
	  el código anterior. A menudo es útil encapsular un tipo del
	  lenguaje en una clase para garantizar la inicialización con
	  el constructor. Por ejemplo, aquí hay una clase
	  <code class="classname">Integer</code>:
	</p><div class="example"><a id="idp6217112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:EncapsulatingTypes.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Integer <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Integer</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

Integer<span class="hl opt">::</span><span class="hl kwd">Integer</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
<span class="hl kwb">void</span> Integer<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Integer i<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> j<span class="hl opt">++)</span>
    i<span class="hl opt">[</span>j<span class="hl opt">].</span><span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.11. C08/EncapsulatingTypes.cpp</strong></p></div><br class="example-break" /><p>
	  El vector de enteros declarado en
	  <code class="function">main()</code> se inicializa automáticamente a
	  cero. Esta inicialización no es necesariamente más costosa
	  que un bucle <code class="keyword">for</code> o
	  <code class="function">memset()</code>. Muchos compiladores lo
	  optimizan fácilmente como un proceso muy rápido.
	</p></div></div><div class="sect2" title="8.4.2. Constantes en tiempo de compilación dentro de clases"><div class="titlepage"><div><div><h3 class="title"><a id="idp6220504"></a>8.4.2. Constantes en tiempo de compilación dentro de clases</h3></div></div></div><p>
	El uso anterior de <code class="keyword">const</code> es interesante y
	probablemente útil en muchos casos, pero no resuelve el
	programa original de «cómo hacer una constante en tiempo
	de compilación dentro de una clase». La respuesta
	requiere del uso de un especificador adicional que se
	explicará completamente en el [FIXME:capítulo 10]:
	<code class="keyword">static</code>. El especificador <code class="keyword">static</code>, en esta
	situación significa «hay sólo una instancia a pesar de
	que se creen varios objetos de la clase» que es
	precisamente lo que se necesita: un atributo de clase que es
	constante, y que no cambia de un objeto a otro de la misma
	clase. Por eso, una <code class="keyword">static const</code> de un tipo básico se
	puede tratar como una constante en tiempo de compilación.
      </p><p>
	Hay un característica de <code class="keyword">static const</code> cuando se usa
	dentro de clases que es un tanto inusual: se debe indicar el
	valor inicial en el punto en que se define. Esto sólo ocurre
	con <code class="keyword">static const</code> y no funciona en otras situaciones
	porque todos lo otros atributos deben inicializarse en el
	constructor o en otros métodos.
      </p><p>
	A continuación aparece un ejemplo que muestra la creación y
	uso de una <code class="keyword">static const</code> llamada
	<code class="varname">size</code> en una clase que representa una pila
	de punteros a cadenas<sup>[<a id="idp6227568" href="#ftn.idp6227568" class="footnote">65</a>]</sup>.
      </p><div class="example"><a id="idp6228080"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:StringStack.cpp</span>
<span class="hl slc">// Using static const to create a </span>
<span class="hl slc">// compile-time constant inside a class</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> StringStack <span class="hl opt">{</span>
  <span class="hl kwb">static const int</span> size <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
  <span class="hl kwb">const</span> string<span class="hl opt">*</span> stack<span class="hl opt">[</span>size<span class="hl opt">];</span>
  <span class="hl kwb">int</span> index<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">StringStack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">*</span> s<span class="hl opt">);</span>
  <span class="hl kwb">const</span> string<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

StringStack<span class="hl opt">::</span><span class="hl kwd">StringStack</span><span class="hl opt">() :</span> <span class="hl kwd">index</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {</span>
  <span class="hl kwd">memset</span><span class="hl opt">(</span>stack<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> size <span class="hl opt">*</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>string<span class="hl opt">*));</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> StringStack<span class="hl opt">::</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">*</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> size<span class="hl opt">)</span>
    stack<span class="hl opt">[</span>index<span class="hl opt">++] =</span> s<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">const</span> string<span class="hl opt">*</span> StringStack<span class="hl opt">::</span><span class="hl kwd">pop</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    <span class="hl kwb">const</span> string<span class="hl opt">*</span> rv <span class="hl opt">=</span> stack<span class="hl opt">[--</span>index<span class="hl opt">];</span>
    stack<span class="hl opt">[</span>index<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> rv<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

string iceCream<span class="hl opt">[] = {</span>
  <span class="hl str">&quot;pralines &amp; cream&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;fudge ripple&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;jamocha almond fudge&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;wild mountain blackberry&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;raspberry sorbet&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;lemon swirl&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;rocky road&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;deep chocolate fudge&quot;</span>
<span class="hl opt">};</span>

<span class="hl kwb">const int</span> iCsz <span class="hl opt">=</span> 
  <span class="hl kwa">sizeof</span> iceCream <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>iceCream<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  StringStack ss<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> iCsz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    ss<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(&amp;</span>iceCream<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl kwb">const</span> string<span class="hl opt">*</span> cp<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">=</span> ss<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.12. C08/StringStack.cpp</strong></p></div><br class="example-break" /><p>
	Como <code class="varname">size</code> se usa para determinar el tamaño
	del vector <code class="varname">stack</code>, es adecuado usar una
	constante en tiempo de compilación, pero que queda oculta
	dentro de la clase.
      </p><p>
	Fíjese en que <code class="function">push()</code> toma un <code class="type">const
	string*</code> como argumento, <code class="function">pop()</code>
	retorna un <code class="type">const string*</code> y
	<code class="classname">StringStack</code> contiene <code class="type">const
	string*</code>. Si no fuera así, no podría usar una
	<code class="classname">StringStack</code> para contener los punteros
	de <code class="varname">icecream</code>. En cualquier caso, también
	impide hacer algo que cambie los objetos contenidos en
	<code class="classname">StringStack</code>. Por supuesto, no todos los
	contenedores están diseñados con esta restricción.
      </p><div class="sect3" title="El enumerado en codigo antiguo"><div class="titlepage"><div><div><h4 class="title"><a id="idp6234080"></a>El enumerado en codigo antiguo</h4></div></div></div><p>
	  En versiones antiguas de C++ el tipo <code class="keyword">static const</code>
	  no se permitía dentro de las clases. Esto hacía que
	  <code class="keyword">const</code> no pudiese usarse para expresiones constantes
	  dentro de clases. Pero muchos programadores lo conseguían
	  con una solución típica (normalmente conocida como
	  «<span class="foreignphrase"><em class="foreignphrase">enum hack</em></span>») que
	  consiste en usar un <code class="type">enum</code> sin etiqueta y sin
	  instancias. Una enumeración debe tener establecidos sus
	  valores en tiempo de compilación, es local a una clase y sus
	  valores están disponibles para expresiones constantes. Por
	  eso, es habitual ver código como:
	</p><div class="example"><a id="idp6237144"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:EnumHack.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Bunch <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> size <span class="hl opt">=</span> <span class="hl num">1000</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span>size<span class="hl opt">];</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(Bunch) = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Bunch<span class="hl opt">)</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, sizeof(i[1000]) = &quot;</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">1000</span><span class="hl opt">]) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.13. C08/EnumHack.cpp</strong></p></div><br class="example-break" /><p>
	  Este uso de <code class="type">enum</code> garantiza que no se ocupa
	  almacenamiento en el objeto, y que todos los símbolos
	  definidos en la enumeración se evalúan en tiempo de
	  compilación. Además se puede establecer explícitamente el
	  valor de los símbolos:
	</p><pre class="programlisting">
<span class="hl kwb">enum</span> <span class="hl opt">{</span> one <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">,</span> two <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">,</span> three <span class="hl opt">};</span>
</pre><p>
	  utilizando tipos <code class="type">enum</code> enteros, el compilador
	  continuará contando a partir del último valor, así que el
	  símbolo <code class="constant">three</code> tendrá un valor 3.
	</p><p>
	  En el ejemplo StringStack anterior, la línea:
	</p><pre class="programlisting">
<span class="hl kwb">static const int</span> size <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
</pre><p>
	  podriá sustituirse por:
	</p><pre class="programlisting">
<span class="hl kwb">enum</span> <span class="hl opt">{</span> size <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
</pre><p>
	  Aunque es fácil ver esta técnica en código correcto, el uso
	  de <code class="keyword">static const</code> fue añadido al lenguaje
	  precisamente para resolver este problema.  En todo caso, no
	  existe ninguna razón abrumadora por la que deba usar
	  <code class="keyword">static const</code> en lugar de <code class="type">enum</code>, y en
	  este libro se utiliza <code class="type">enum</code> porque hay más
	  compiladores que le dan soporte en el momento en el momento
	  en que se escribió este libro.
	</p></div></div><div class="sect2" title="8.4.3. Objetos y métodos constantes"><div class="titlepage"><div><div><h3 class="title"><a id="idp6244432"></a>8.4.3. Objetos y métodos constantes</h3></div></div></div><p>
	Las funciones miembro (métodos) se pueden hacer
	constantes. ¿Qué significa eso? Para entenderlo, primero debe
	comprender el concepto de objeto constante.
      </p><p>
	Un objeto constante se define del mismo modo para un tipo
	definido por el usuario que para un tipo del lenguaje. Por
	ejemplo:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwb">const</span> blob <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
</pre><p>
        Aquí, <code class="varname">b</code> es un objeto constante de tipo
        <code class="type">blob</code>, su constructor se llama con un
        <code class="literal">2</code> como argumento. Para que el compilador
        imponga que el objeto sea constante, debe asegurar que el
        objeto no tiene atributos que vayan a cambiar durante el
        tiempo de vida del objeto. Puede asegurar fácilmente que los
        atributos no públicos no sean modificables, pero. ¿Cómo puede
        saber que métodos cambiarán los atributos y cuáles son seguros
        para un objeto constante?
      </p><p>
        Si declara un método como constante, le está diciendo que la
        función puede ser invocada por un objeto constante. Un método
        que no se declara constante se trata como uno que puede
        modificar los atributos del objeto, y el compilador no permitirá
        que un objeto constante lo utilice.
      </p><p>
        Pero la cosa no acaba ahí. Sólo porque un método afirme ser
        <code class="keyword">const</code> no garantiza que actuará del modo correcto, de
        modo que el compilador fuerza que en la definición del método
        se reitere el especificador <code class="keyword">const</code> (la palabra
        <code class="keyword">const</code> se convierte en parte del nombre de la función,
        así que tanto el compilador como el enlazador comprobarán que
        no se viole la constancia). De este modo, si durante la
        definición de la función se modifica algún miembro o se llama
        algún método no constante, el compilador emitirá un mensaje de
        error. Por eso, está garantizado que los miembros que declare
        <code class="keyword">const</code> se comportarán del modo esperado.
      </p><p>
	Para comprender la sintaxis para declarar métodos constantes,
	primero debe recordar que colocar <code class="keyword">const</code> delante de la
	declaración del método indica que el valor de retorno es
	constante, así que no produce el efecto deseado. Lo que hay
	que hacer es colocar el especificador <code class="keyword">const</code>
	<span class="emphasis"><em>después</em></span> de la lista de argumentos. Por
	ejemplo:
      </p><div class="example"><a id="idp6254272"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:ConstMember.cpp</span>
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

X<span class="hl opt">::</span><span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
<span class="hl kwb">int</span> X<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X <span class="hl kwd">x1</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwb">const</span> X <span class="hl kwd">x2</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">);</span>
  x1<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  x2<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.14. C08/ConstMember.cpp</strong></p></div><br class="example-break" /><p>
	La palabra <code class="keyword">const</code> debe incluirse tanto en la
	declaración como en la definición del método o de otro modo el
	compilador asumirá que es un método diferente. Como
	<code class="function">f()</code> es un método constante, si intenta
	modificar <code class="varname">i</code> de alguna forma o llamar a otro
	método que no sea constante, el compilador informará de un
	error.
      </p><p>
	Puede ver que un miembro constante puede llamarse tanto desde
	objetos constantes como desde no constantes de forma
	segura. Por ello, debe saber que esa es la forma más general
	para un método (a causa de esto, el hecho de que los métodos
	no sean <code class="keyword">const</code> por defecto resulta desafortunado). Un
	método que no modifica ningún atributo se debería escribir
	como constante y así se podría usar desde objetos constantes.
      </p><p>
	Aquí se muestra un ejemplo que compara métodos const y
	métodos ordinarios:
      </p><div class="example"><a id="idp6259160"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Quoter.cpp</span>
<span class="hl slc">// Random quote selection</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span> <span class="hl slc">// Random number generator</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;ctime&gt;</span> <span class="hl slc">// To seed random generator</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Quoter <span class="hl opt">{</span>
  <span class="hl kwb">int</span> lastquote<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Quoter</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">lastQuote</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwd">quote</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

Quoter<span class="hl opt">::</span><span class="hl kwd">Quoter</span><span class="hl opt">(){</span>
  lastquote <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed random number generator</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> Quoter<span class="hl opt">::</span><span class="hl kwd">lastQuote</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwa">return</span> lastquote<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">const char</span><span class="hl opt">*</span> Quoter<span class="hl opt">::</span><span class="hl kwd">quote</span><span class="hl opt">() {</span>
  <span class="hl kwb">static const char</span><span class="hl opt">*</span> quotes<span class="hl opt">[] = {</span>
    <span class="hl str">&quot;Are we having fun yet?&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;Doctors always know best&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;Is it ... Atomic?&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;Fear is obscene&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;There is no scientific evidence &quot;</span>
    <span class="hl str">&quot;to support the idea &quot;</span>
    <span class="hl str">&quot;that life is serious&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;Things that make us happy, make us wise&quot;</span><span class="hl opt">,</span>
  <span class="hl opt">};</span>
  <span class="hl kwb">const int</span> qsize <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> quotes<span class="hl opt">/</span><span class="hl kwa">sizeof</span> <span class="hl opt">*</span>quotes<span class="hl opt">;</span>
  <span class="hl kwb">int</span> qnum <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> qsize<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>lastquote <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp;</span> qnum <span class="hl opt">==</span> lastquote<span class="hl opt">)</span>
    qnum <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> qsize<span class="hl opt">;</span>
  <span class="hl kwa">return</span> quotes<span class="hl opt">[</span>lastquote <span class="hl opt">=</span> qnum<span class="hl opt">];</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Quoter q<span class="hl opt">;</span>
  <span class="hl kwb">const</span> Quoter cq<span class="hl opt">;</span>
  cq<span class="hl opt">.</span><span class="hl kwd">lastQuote</span><span class="hl opt">();</span> <span class="hl slc">// OK</span>
<span class="hl slc">//!  cq.quote(); // Not OK; non const function</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> q<span class="hl opt">.</span><span class="hl kwd">quote</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.15. C08/Quoter.cpp</strong></p></div><br class="example-break" /><p>
	Ni los constructores ni los destructores pueden ser métodos
	constantes porque prácticamente siempre realizan alguna
	modificación en el objeto durante la inicialización o la
	terminación. El miembro <code class="function">quote()</code> tampoco
	puede ser constante porque modifica el atributo
	<code class="varname">lastquote</code> (ver la sentencia de retorno).  Por
	otra parte <code class="function">lastQuote()</code> no hace
	modificaciones y por eso puede ser <code class="keyword">const</code> y
	puede ser llamado de forma segura por el objeto constante
	<code class="varname">cq</code>.
      </p><div class="sect3" title="mutable: constancia binaria vs. lógica"><div class="titlepage"><div><div><h4 class="title"><a id="idp6264480"></a>mutable: constancia binaria vs. lógica</h4></div></div></div><p>
	  ¿Qué ocurre si quiere crear un método constante, pero
	  necesita cambiar algún atributo del objeto? Esto se aplica a
	  veces a la diferencia entre constante binaria
	  (<span class="foreignphrase"><em class="foreignphrase">bitwise</em></span>) y constante lógica
	  (llamado también constante
	  <span class="foreignphrase"><em class="foreignphrase">memberwise</em></span>). Constante
	  binaria significa que todos los bits del objeto son
	  permanentes, así que la imagen binaria del objeto nunca
	  cambia.  Constante lógica significa que, aunque el objeto
	  completo es conceptualmente constante puede haber cambios a
	  nivel de miembro.  Si se informa al compilador que un objeto
	  es constante, cuidará celosamente el objeto para asegurar
	  constancia binaria. Para conseguir constancia lógica, hay
	  dos formas de cambiar los atributos con un método constante.
	</p><p>
	  La primera solución es la tradicional y se llama constancia
	  <span class="foreignphrase"><em class="foreignphrase">casting away</em></span>.  Esto se hace
	  de un modo bastante raro. Se toma <code class="varname">this</code>
	  (la palabra que inidica la dirección del objeto actual) y se
	  moldea el puntero a un puntero a objeto de la clase
	  actual. Parece que <code class="varname">this</code> ya es un puntero
	  válido. Sin embargo, dentro de un método constante,
	  <code class="varname">this</code> es en realidad un puntero constante,
	  así que moldeándolo a un puntero ordinario se elimina la
	  constancia del objeto para esta operación. Aquí hay un
	  ejemplo:
	</p><div class="example"><a id="idp6268824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Castaway.cpp</span>
<span class="hl slc">// &quot;Casting away&quot; constness</span>

<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Y</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

Y<span class="hl opt">::</span><span class="hl kwd">Y</span><span class="hl opt">() {</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>

<span class="hl kwb">void</span> Y<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
<span class="hl slc">//!  i++; // Error -- const member function</span>
  <span class="hl opt">((</span>Y<span class="hl opt">*)</span><span class="hl kwa">this</span><span class="hl opt">)-&gt;</span>i<span class="hl opt">++;</span> <span class="hl slc">// OK: cast away const-ness</span>
  <span class="hl slc">// Better: use C++ explicit cast syntax:</span>
  <span class="hl opt">(</span><span class="hl kwa">const_cast</span><span class="hl opt">&lt;</span>Y<span class="hl opt">*&gt;(</span><span class="hl kwa">this</span><span class="hl opt">))-&gt;</span>i<span class="hl opt">++;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const</span> Y yy<span class="hl opt">;</span>
  yy<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Actually changes it!</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.16. C08/Castaway.cpp</strong></p></div><br class="example-break" /><p>
	  Esta aproximación funciona y puede verse en código
	  correcto, pero no es la técnica ideal. El problema es que
	  esta falta de constancia está oculta en la definición de
	  un método y no hay ningún indicio en la interfaz de la
	  clase que haga sospechar que ese dato se modifica a menos
	  que puede accederse al código fuente (buscando el
	  molde). Para poner todo al descubierto se debe usar la
	  palabra <code class="keyword">mutable</code> en la declaración de la
	  clase para indicar que un atributo determinado se puede
	  cambiar aún perteneciendo a un objeto constante.
	</p><div class="example"><a id="idp6271736"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Mutable.cpp</span>
<span class="hl slc">// The &quot;mutable&quot; keyword</span>

<span class="hl kwc">class</span> Z <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwc">mutable</span> <span class="hl kwb">int</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Z</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

Z<span class="hl opt">::</span><span class="hl kwd">Z</span><span class="hl opt">() :</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">j</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>

<span class="hl kwb">void</span> Z<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
<span class="hl slc">//! i++; // Error -- const member function</span>
    j<span class="hl opt">++;</span> <span class="hl slc">// OK: mutable</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const</span> Z zz<span class="hl opt">;</span>
  zz<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Actually changes it!</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.17. C08/Mutable.cpp</strong></p></div><br class="example-break" /><p>
	  De este modo el usuario de la clase puede ver en la declaración
	  qué miembros tienen posibilidad de ser modificados por un método.
	</p></div><div class="sect3" title="ROMability"><div class="titlepage"><div><div><h4 class="title"><a id="idp6273480"></a>ROMability</h4></div></div></div><p>
	  Si un objeto se define como constante es un candidato para
	  ser almacenado en memoria de sólo lectura (ROM), que a
	  menudo es una consideración importante en programación de
	  sistemas empotrados. Para conseguirlo no es suficiente con
	  que el objeto sea constante, los requisitos son mucha más
	  estrictos. Por supuesto, el objeto debe ser una constante
	  binaria. Eso es fácil de comprobar si la constancia lógica
	  se implementa mediante el uso de <code class="keyword">mutable</code>, pero
	  probablemente el compilador no podrá detectarlo si se
	  utiliza la técnica del moldeado dentro de un método
	  constante. Además:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	      La clase o estructura no puede tener constructores o destructor
	      definidos por el usuario.
	    </p></li><li class="listitem"><p>
	      No pueden ser clases base (capitulo 14) u objetos
	      miembro con constructores o destructor definidos por el
	      usuario.
	    </p></li></ul></div><p>
	  El efecto de una operación de escritura en una parte del
	  objeto constante de un tipo <code class="type">ROMable</code> no está
	  definido. Aunque un objeto pueda ser colocado en ROM de
	  forma conveniente, no todos lo requieren.
	</p></div></div></div><div class="sect1" title="8.5. Volatile"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6277896"></a>8.5. Volatile</h2></div></div></div><p>
      La sintaxis de <code class="keyword">volatile</code> es idéntica a la de
      <code class="keyword">const</code>, pero <code class="keyword">volatile</code> significa «este
      dato puede cambiar sin que el compilador sea informado de
      ello». De algún modo, el entorno modifica el dato
      (posiblemente mediante multitarea, multihilo o interrupciones),
      y <code class="keyword">volatile</code> indica la compilador que no haga
      suposiciones sobre el dato, especialmente durante la
      optimización.
    </p><p>
      Si el compilador dice, «yo guardé este dato en un registro
      anteriormente, y no he tocado ese registro», normalmente
      no necesitará leer el dato de nuevo desde memoria. Pero si esa
      variable es <code class="keyword">volatile</code>, el compilador no debe hacer esa
      suposición porque el dato puede haber cambiado a causa de otro
      proceso, y debe releer el dato en vez de optimizar el código
      (dicha optimización consiste en eliminar la lectura redundante
      que se hace normalmente).
    </p><p>
      Pueden crearse objetos <code class="keyword">volatile</code> usando la misma
      sintaxis que se usa para crear objetos constantes. También puede
      crearse objetos <code class="keyword">volatile</code> constantes que no pueden
      cambiarse por el programador cliente pero se pueden modificar
      por una entidad ajena al programa. Aquí se muestra un ejemplo
      que representa una clase asociada con algún elemento físico de
      comunicación.
    </p><div class="example"><a id="idp6285072"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C08:Volatile.cpp</span>
<span class="hl slc">// The volatile keyword</span>

<span class="hl kwc">class</span> Comm <span class="hl opt">{</span>
  <span class="hl kwb">const</span> <span class="hl kwc">volatile</span> <span class="hl kwb">unsigned char</span> byte<span class="hl opt">;</span>
  <span class="hl kwc">volatile</span> <span class="hl kwb">unsigned char</span> flag<span class="hl opt">;</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> bufsize <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">unsigned char</span> buf<span class="hl opt">[</span>bufsize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> index<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Comm</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">isr</span><span class="hl opt">()</span> <span class="hl kwc">volatile</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span> <span class="hl kwd">read</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

Comm<span class="hl opt">::</span><span class="hl kwd">Comm</span><span class="hl opt">() :</span> <span class="hl kwd">index</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">byte</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">flag</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>

<span class="hl slc">// Only a demo; won't actually work</span>
<span class="hl slc">// as an interrupt service routine:</span>
<span class="hl kwb">void</span> Comm<span class="hl opt">::</span><span class="hl kwd">isr</span><span class="hl opt">()</span> <span class="hl kwc">volatile</span> <span class="hl opt">{</span>
  flag <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  buf<span class="hl opt">[</span>index<span class="hl opt">++] =</span> byte<span class="hl opt">;</span>
  <span class="hl slc">// Wrap to beginning of buffer:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> bufsize<span class="hl opt">)</span> index <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">char</span> Comm<span class="hl opt">::</span><span class="hl kwd">read</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> <span class="hl num">0</span> <span class="hl opt">||</span> index <span class="hl opt">&gt;=</span> bufsize<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> buf<span class="hl opt">[</span>index<span class="hl opt">];</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwc">volatile</span> Comm Port<span class="hl opt">;</span>
  Port<span class="hl opt">.</span><span class="hl kwd">isr</span><span class="hl opt">();</span> <span class="hl slc">// OK</span>
<span class="hl slc">//!  Port.read(0); // Error, read() not volatile</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.18. C08/Volatile.cpp</strong></p></div><br class="example-break" /><p>
      Como ocurre con <code class="keyword">const</code>, se puede usar <code class="keyword">volatile</code>
      para los atributos de la clase, los métodos y para los objetos
      en sí mismos. Sólo puede llamar a métodos <code class="keyword">volatile</code>
      desde objetos <code class="keyword">volatile</code>.
    </p><p>
      La razón por la que <code class="function">isr()</code> no se puede usar
      como una rutina de servicio de interrupción (ISR) es que en un
      método, la dirección del objeto actual (<code class="varname">this</code>)
      debe pasarse secretamente, y una ISR no requiere
      argumentos. Para resolver este problema se puede hacer que el
      método <code class="function">isr()</code> sea un método de clase
      (<code class="keyword">static</code>), un asunto que se trata en el [FIXME:capitulo
      10].
    </p><p>
      La sintaxis de <code class="keyword">volatile</code> es idéntica a la de
      <code class="keyword">const</code>, así que por eso se suelen tratar juntos. Cuando
      se usan combinados se conocen como cuantificador
      <span class="emphasis"><em>c-v</em></span> (const-volatile).
    </p></div><div class="sect1" title="8.6. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6293576"></a>8.6. Resumen</h2></div></div></div><p>
      La palabra <code class="keyword">const</code> permite la posibilidad de definir
      objetos, argumentos de función, valores de retorno y métodos
      como constantes y elimina el uso del preprocesador para la
      sustitución de valores sin perder ninguna de sus ventajas. Todo
      ello ofrece una forma adicional de comprobación de tipos y
      seguridad en la programación. El uso de la llamada
      «constancia exacta» (<span class="foreignphrase"><em class="foreignphrase">const
      correctness</em></span>) es decir, el uso de <code class="keyword">const</code>
      en todo lugar donde sea posible, puede ser un salvavidas para
      muchos proyectos.
    </p><p>
      Aunque ignore a <code class="keyword">const</code> y continue usando el estilo
      tradicional de C, <code class="keyword">const</code> existe para ayudarle. El
      [FIXME:capitulo 11] utiliza las referencias extensamente, y se
      verá más sobre la importancia del uso de <code class="keyword">const</code> en los
      argumentos de funciones.
    </p></div><div class="sect1" title="8.7. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6298544"></a>8.7. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Cree 3 valores enteros constantes, después súmelos todos
	  para producir un valor que determine el tamaño en la
	  definición de un vector. Intente compilar el mismo código
	  en C y vea qué sucede (generalmente se puede forzar al
	  compilador de C++ para que funcione como un compilador de
	  C utilizando alguna opción de linea de comandos).
	</p></li><li class="listitem"><p>
	  Probar que los compiladores de C y C++ realmente tratan las
	  constantes de modo diferente. Cree una constante global y
	  úsela en una expresión global constante, compile dicho
	  código en C y C++.
	</p></li><li class="listitem"><p>
	  Cree definiciones constantes para todos los tipos del
	  lenguaje y sus variantes. Úselos en expresiones con otras
	  constantes para hacer definiciones de constantes
	  nuevas. Compruebe que compilan correctamente.
	</p></li><li class="listitem"><p>
	  Cree una definición de constante en un archivo de cabecera,
	  incluya dicho archivo en dos archivos
	  <code class="filename">.cpp</code>, compílelos y enlácelos con el
	  compilador de C++. No deberían ocurrir errores. Ahora
	  intente el mismo experimento con el compilador de C.
	</p></li><li class="listitem"><p>
	  Cree una constante cuyo valor se determine en tiempo de
	  ejecución leyendo la hora en que comienza la ejecución del
	  programa (puede usar <code class="filename">&lt;ctime&gt;</code>). Después, en el
	  programa, intente leer un segundo valor de hora,
	  almacenarlo en la constante y vea qué sucede.
	</p></li><li class="listitem"><p>
	  Cree un vector de caracteres constante, después intente
	  cambiar uno de los caracteres.
	</p></li><li class="listitem"><p>
	  Cree una declaración de constante <code class="keyword">extern</code> en un
	  fichero y ponga un <code class="function">main()</code> en el que se
	  imprima el valor de dicha constante. Cree una definición de
	  constante <code class="keyword">extern</code> en un segundo fichero, compile y
	  enlace los dos ficheros.
	</p></li><li class="listitem"><p>
	  Defina dos punteros a <code class="type">const long</code> utilizando
	  las dos formas de definición. Apunte con uno de ellos a
	  un vector de <code class="type">long</code>. Demuestre que se puede
	  incrementar o decrementar el puntero, pero no se puede
	  cambiar el valor de lo que apunta.
	</p></li><li class="listitem"><p>
	  Defina un puntero constante a <code class="type">double</code>, y apunte
	  con él a un vector de <code class="type">double</code>. Demuestre que se
	  puede cambiar lo que apunta el puntero pero no se puede
	  incrementar ni decrementar el puntero.
	</p></li><li class="listitem"><p>
	  Defina un puntero constante a objeto constante. Pruebe que
	  solamente se puede leer el valor de lo que apunta el puntero,
	  pero no se puede cambiar el puntero ni lo que apunta.
	</p></li><li class="listitem"><p>
	  Elimine el comentario de la linea errónea en
	  <code class="filename">PointerAssignemt.cpp</code> para ver qué
	  mensaje de error muestra el compilador.
	</p></li><li class="listitem"><p>
	  Cree un literal de cadena y un puntero que apunte al
	  comienzo del literal. Ahora, use el puntero para
	  modificar los elementos del vector, ¿Informa el compilador
	  de algún error? ¿Debería? Si no lo hace, ¿Porqué piensa
	  que puede ser?
	</p></li><li class="listitem"><p>
	  Cree una función que tome un argumento por valor como constante,
	  después intente cambiar el argumento en el cuerpo de la
	  función.
	</p></li><li class="listitem"><p>
	  Cree una función que tome un <code class="type">float</code> por
	  valor. Dentro de la función vincule el argumento a un
	  <code class="type">const float&amp;</code> y use dicha referencia para
	  asegurar que el argumento no sea modificado
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ConstReturnValues.cpp</code>
	  eliminando los comentarios en las líneas erróneas una cada
	  vez para ver qué mensajes de error muestra el compilador.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ConsPointer.cpp</code> eliminando
	  los comentarios en las líneas erróneas para ver qué mensajes
	  de error muestra el compilador.
	</p></li><li class="listitem"><p>
	  Haga una nueva versión de
	  <code class="filename">ConstPointer.cpp</code> llamada
	  <code class="filename">ConstReference.cpp</code> que demuestre el
	  funcionamiento con referencias en lugar de con punteros.
	  (quizá necesite consultar el [FIXME:capítulo 11]).
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ConstTemporary.cpp</code>
	  eliminando el comentario en la línea errónea para ver el
	  mensaje de error que muestra el compilador.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un <code class="type">float</code> constante
	  y otro no constante. Inicialícelos usando la lista de
	  inicialización del constructor.
	  
	</p></li><li class="listitem"><p>
	  Cree una clase llamada <code class="classname">MyString</code>
	  que contenga una cadena y tenga un constructor que
	  inicialice la cadena y un método
	  <code class="function">print()</code>. Modifique
	  <code class="filename">StringStack.cpp</code> para que maneje
	  objetos <code class="classname">MyString</code> y
	  <code class="function">main()</code> para que los imprima.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un atributo constante que se
	  inicialice en la lista de inicialización del constructor y
	  una enumeración no etiquetada que se use para determinar
	  el tamaño de un vector.
	</p></li><li class="listitem"><p>
	  Elimine el especificador <code class="keyword">const</code> en la definición del
	  método de <code class="filename">ConstMember.cpp</code>, pero deje
	  el de la declaración para ver qué mensaje de error muestra
	  el compilador.
	</p></li><li class="listitem"><p>
	  Cree una clase con un método constante y otro
	  ordinario. Cree un objeto constante y otro no constante de
	  esa clase e intente invocar ambos métodos desde ambos
	  objetos.
	</p></li><li class="listitem"><p>
	  Cree una clase con un método constante y otro
	  ordinario. Intente llamar al método ordinario desde el
	  método constante para ver qué mensaje de error muestra el
	  compilador.
	</p></li><li class="listitem"><p>
	  Elimine el comentario de la línea errónea en
	  <code class="filename">mutable.cpp</code> para ver el mensaje de
	  error que muestra el compilador.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Quoter.cpp</code> haciendo que
	  <code class="function">quote()</code> sea un método constante y
	  <code class="varname">lastquote</code> sea <code class="keyword">mutable</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase con un atributo <code class="keyword">volatile</code>. Cree
	  métodos <code class="keyword">volatile</code> y no <code class="keyword">volatile</code> que
	  modifiquen el atributo <code class="keyword">volatile</code> y vea qué dice el
	  compilador.  Cree objetos <code class="keyword">volatile</code> y no
	  <code class="keyword">volatile</code> de esa clase e intente llamar a ambos
	  métodos para comprobar si funciona correctamente y ver qué
	  mensajes de error muestra el compilador en caso contrario.
	</p></li><li class="listitem"><p>
	  Cree una clase llamada <code class="classname">bird</code> que
	  pueda ejecutar <code class="function">fly()</code> y una clase
	  <code class="classname">rock</code> que no pueda. Crear un objeto
	  <code class="varname">rock</code>, tome su dirección y asigne a un
	  <code class="type">void*</code>. Ahora tome el <code class="type">void*</code>,
	  asígnelo a un <code class="type">bird*</code> (debe usar un molde) y
	  llame a <code class="function">fly()</code> a través de dicho
	  puntero. ¿Esto es posible porque la característica de C que
	  permite asignar a un <code class="type">void*</code> (sin un molde) es
	  un agujero del lenguaje, que no debería propagarse a C++?
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp6059224" href="#idp6059224" class="para">61</a>] </sup>N. del T.: del inglés <span class="foreignphrase"><em class="foreignphrase">constant
      folding</em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.idp6154944" href="#idp6154944" class="para">62</a>] </sup>N. del T.: «recipiente»
	corresponde con el término
	<span class="foreignphrase"><em class="foreignphrase">lvalue</em></span> que se refiere a una
	variable que puede ser modificada o a la que se le puede
	asignar un valor.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6189824" href="#idp6189824" class="para">63</a>] </sup> Algunos autores dicen que todo en C
	  se pasa por valor, ya que cuando se pasa un puntero se hace
	  también una copia (de modo que el puntero se pasa por
	  valor). En cualquier caso, hacer esta precisión puede, en
	  realidad, confundir la cuestión.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6199640" href="#idp6199640" class="para">64</a>] </sup>N. del T.: Esto se conoce como polisemia del
      lenguaje</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6227568" href="#idp6227568" class="para">65</a>] </sup>Al termino de este libro,
	no todos los compiladores permiten esta
	característica.</p></div></div></div><div class="chapter" title="9: Funciones inline"><div class="titlepage"><div><div><h2 class="title"><a id="C09"></a>9: Funciones <code class="keyword">inline</code></h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp6344008">9.1. Los peligros del preprocesador</a></span></dt><dt><span class="sect1"><a href="#idp6369288">9.2. Funciones <code class="keyword">inline</code></a></span></dt><dt><span class="sect1"><a href="#idp6417632">9.3. Stash y Stack con inlines</a></span></dt><dt><span class="sect1"><a href="#idp6437296">9.4. Funciones inline y el compilador</a></span></dt><dt><span class="sect1"><a href="#idp6459432">9.5. Reducir el desorden</a></span></dt><dt><span class="sect1"><a href="#idp6469312">9.6. Más características del preprocesador</a></span></dt><dt><span class="sect1"><a href="#idp6480720">9.7. Comprobación de errores mejorada</a></span></dt><dt><span class="sect1"><a href="#idp6500040">9.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6503368">9.9. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Una de las características más importantes que C++ hereda de C es
      la eficiencia. Si la eficiencia de C++ fuese dramáticamente menor
      que la de C, podría haber un contingente significativo de
      programadores que no podrían justificar su uso.
    </p></div><p>
    En C, una de las maneras de preservar la eficiencia es mediante el
    uso de macros, lo que permite hacer lo que parece una llamada a
    una función sin la sobrecarga habitual de la llamada a función.
    La macro está implementada con el preprocesador en vez del propio
    compilador, y el preprocesador reemplaza todas las llamadas a
    macros directamente con el código de la macro, de manera que no
    hay que complicarse pasando argumentos, escribiendo código de
    ensamblador para <code class="keyword">CALL</code>, retornando argumentos ni
    implementando código ensamblador para el <code class="keyword">RETURN</code>. Todo el
    trabajo lo realizar el preprocesador, de manera que se tiene la
    coherencia y legibilidad de una llamada a una función pero sin
    ningún coste.
  </p><p>
    Hay dos problemas respecto al uso del preprocesador con macros en
    C++. La primera también existe en C: una macro parece una llamada a
    función, pero no siempre actúa como tal. Esto puede acarrear
    dificultades para encontrar errores.  El segundo problema es
    específico de C++: el preprocesador no tiene permisos para acceder a
    la información de los miembros de una clase. Esto significa que las
    macros de preprocesador no pueden usarse como métodos de una clase.
  </p><p>
    Para mantener la eficiencia del uso del preprocesador con macros
    pero añadiendo la seguridad y la semántica de ámbito de verdaderas
    funciones en las clases. C++ tiene las funciones
    <code class="keyword">inline</code>. En este capítulo veremos los problemas del uso de
    las maros de preprocesador en C++, cómo se resuelven estos
    problemas con funciones <code class="keyword">inline</code>, y las directrices e
    incursiones en la forma en que trabajan las
    <span class="emphasis"><em></em></span>funciones inline.
  </p><div class="sect1" title="9.1. Los peligros del preprocesador"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6344008"></a>9.1. Los peligros del preprocesador</h2></div></div></div><p>
      La clave de los problemas con las macros de preprocesador radica
      en que puedes caer en el error de pensar que el comportamiento
      del preprocesador es igual que el del compilador. Por supuesto,
      la intención era que una macro se parezca y actúe como una
      llamada a una función, por eso es bastante fácil caer en este
      error. Las dificultades comienzan cuando las diferencias
      aparecen subyacentes.
    </p><p>
      Consideremos un ejemplo sencillo:
    </p><pre class="programlisting">
<span class="hl ppc">#define F (x) (x + 1)</span>
</pre><p>
      Ahora, si hacemos una llamada a <code class="function">F</code> de esta
      manera:
    </p><pre class="programlisting">
<span class="hl kwd">F</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">)</span>
</pre><p>
      El preprocesador la expande de manera inesperada:
    </p><pre class="programlisting">
<span class="hl opt">(</span>x<span class="hl opt">) (</span>x <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">)(</span><span class="hl num">1</span><span class="hl opt">)</span>
</pre><p>
      El problema se debe al espacio entre `F` y su paréntesis de
      apertura en la definición de la macro.  Cuando el espacio es
      eliminado en el código de la macro, puedes llamar a la función
      incluso incluyendo el espacio.
    </p><pre class="programlisting">
<span class="hl kwd">F</span> <span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">)</span>
</pre><p>
      Y se expandirá de manera correcta a lo siguiente:
    </p><pre class="programlisting">
<span class="hl opt">(</span><span class="hl num">1</span> <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">)</span>
</pre><p>
      El ejemplo anterior es un poco trivial y el problema es demasiado
      evidente. Las dificultades reales ocurren cuando se usan
      expresiones como argumentos en llamadas a macros.
    </p><p>
     Hay dos problemas. El primero es que las expresiones pueden
     expandirse dentro de la macro de modo que la precedencia de la
     evaluación es diferente a lo que cabría esperar. Por ejemplo:
    </p><pre class="programlisting">
<span class="hl ppc">#define FLOOR(x,b) x&gt;=b?0:1</span>
</pre><p>
      Ahora, si usamos expresiones como argumentos:
    </p><pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">FLOOR</span><span class="hl opt">(</span>a<span class="hl opt">&amp;</span><span class="hl num">0x0f</span><span class="hl opt">,</span><span class="hl num">0x07</span><span class="hl opt">))</span> <span class="hl slc">// ...</span>
</pre><p>
     La macro se expandiría a:
    </p><pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>a<span class="hl opt">&amp;</span><span class="hl num">0x0f</span><span class="hl opt">&gt;=</span><span class="hl num">0x07</span>?<span class="hl num">0</span><span class="hl opt">:</span><span class="hl num">1</span><span class="hl opt">)</span>
</pre><p>
      La precedencia del &amp; es menor que la del &gt;=, de modo que la
      evaluación de la macro te sorprenderá. Una vez hayas descubierto
      el problema, puedes solucionarlo insertando paréntesis a todo lo
      que hay dentro de la definición de la macro.  (Este es un buen
      método a seguir cuando defina macros de preprocesador), algo
      como:
    </p><pre class="programlisting">
<span class="hl ppc">#define FLOOR(x,b) ((x)&gt;=(b)?0:1)</span>
</pre><p>
      De cualquier manera, descubrir el problema puede ser difícil, y
      no dará con él hasta después de haber dado por sentado el
      comportamiento de la macro en sí misma. En la versión sin
      paréntesis de la macro anterior, la mayoría de las expresiones
      van a actuar de manera correcta a causa de la precedencia de &gt;=,
      que es menor que la mayoría de los operadores como +, /, --, e
      incluso los operadores de desplazamiento. Por lo que puede
      pensar que funciona con todas las expresiones, incluyendo
      aquellas que empleen operadores lógicos a nivel de bit.
    </p><p>
      El problema anterior puede solucionarse programando
      cuidadosamente: poner entre paréntesis todo lo que esté definido
      dentro de una macro. De todos modos el segundo problema es más
      sutil. Al contrario de una función normal, cada vez que usa
      argumentos en una macro, dicho argumento es evaluado. Mientras la
      macro sea llamada solo con variables corrientes, esta evaluación es
      benigna, pero si la evaluación de un argumento tiene efectos
      secundarios, entonces los resultados pueden ser inesperados y
      definitivamente no imitaran el comportamiento de una función.
    </p><p>
      Por ejemplo, esta macro determina si un argumento entra dentro de
      cierto rango:
    </p><pre class="programlisting">
<span class="hl ppc">#define BAND(x) (((x)&gt;5 &amp;&amp; (x)&lt;10) ? (x) : 0)</span>
</pre><p>
      Mientras use un argumento «ordinario» la macro
      trabajará de manera bastante similar a una función real. Pero en
      cuanto se relaje y comience a creer que realmente es una
      función, comenzarán los problemas. Así:
    </p><div class="example"><a id="idp6357448"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:MacroSideEffects.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define BAND(x) (((x)&gt;5 &amp;&amp; (x)&lt;10) ? (x) : 0)</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;macro.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>out<span class="hl opt">,</span> <span class="hl str">&quot;macro.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">4</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">11</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwb">int</span> a <span class="hl opt">=</span> i<span class="hl opt">;</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\t</span><span class="hl str">'</span><span class="hl opt">;</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;BAND(++a)=&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">BAND</span><span class="hl opt">(++</span>a<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span> <span class="hl str">a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.1. C09/MacroSideEffects.cpp</strong></p></div><br class="example-break" /><p>
      Observe el uso de caracteres en mayúscula en el nombre de la
      macro. Este es un buen recurso ya que advierte al lector que
      esto es una macro y no una función, entonces si hay algún
      problema, actúa como recordatorio.
    </p><p>
      A continuación se muestra la salida producida por el programa, que
      no es para nada lo que se esperaría de una auténtica función:
    </p><pre class="screen">
a = 4
  BAND(++a)=0
   a = 5
a = 5
  BAND(++a)=8
   a = 8
a = 6
  BAND(++a)=9
   a = 9
a = 7
  BAND(++a)=10
   a = 10
a = 8
  BAND(++a)=0
   a = 10
a = 9
  BAND(++a)=0
   a = 11
a = 10
  BAND(++a)=0
   a = 12
    </pre><p>
      Cuando <code class="varname">a</code> es cuatro, sólo ocurre la primera
      parte de la condición, de modo que la expresión es evaluada sólo
      una vez, y el efecto resultante de la llamada a la macro es que
      <code class="varname">a</code> será 5, que es lo que se esperaría de una
      llamada a función normal en la misma situación. De todos modos,
      cuando el número está dentro del rango, se evalúan ambas
      condiciones, lo que da como resultado un tercer incremento. Una
      vez que el número se sale del rango, ambas condiciones siguen
      siendo evaluadas de manera que se obtienen dos incrementos.  Los
      efectos colaterales son distintos, dependiendo del argumento.
    </p><p>
      Este no es desde luego el comportamiento que se quiere de una
      macro que se parece a una llamada a función.  En este caso, la
      solución obviamente es hacer una autentica función, lo que de
      hecho implica la cabecera extra y puede reducir la eficiencia si
      se llama demasiado a esa función. Desafortunadamente, el
      problema no siempre será tan obvio, y sin saberlo. puede estar
      utilizando una librería que contiene funciones y macros juntas,
      de modo que un problema como éste puede esconder errores
      difíciles de encontrar. Por ejemplo, la macro
      <code class="function">putc()</code> de <code class="filename">cstdio</code> puede
      llegar a evaluar dos veces su segundo argumento. Esto está
      especificado en el Estándar C. Además, la implementación
      descuidada de <code class="function">toupper()</code> como una macro
      puede llegar a evaluar el argumento más de una vez, lo que dará
      resultados inesperados con
      <code class="code">toupper(*p++)</code><sup>[<a id="idp6364968" href="#ftn.idp6364968" class="footnote">66</a>]</sup>.
    </p><div class="sect2" title="9.1.1. Macros y acceso"><div class="titlepage"><div><div><h3 class="title"><a id="idp6366120"></a>9.1.1. Macros y acceso</h3></div></div></div><p>
        Por supuesto, C requiere codificación cuidadosa y el uso de
        macros de preprocesador, y se podría hacer lo mismo en C++ si
        no fuese por un problema: las macros no poseen el concepto de
        ámbito requerido con los métodos. El preprocesador simplemente
        hace substitución de texto, de modo que no puede hacer algo
        como:
      </p><pre class="programlisting">
<span class="hl kwc">class</span> X<span class="hl opt">{</span>
          <span class="hl kwb">int</span> i<span class="hl opt">;</span>
        <span class="hl kwc">public</span><span class="hl opt">:</span>
        <span class="hl ppc">#define VAL(X::i)</span> <span class="hl slc">// Error</span><span class="hl ppc"></span>
</pre><p>
        ni nada parecido. Además, no habría ninguna indicación del
        objeto al que se está refiriendo.  Simplemente no hay ninguna
        forma de expresar el ámbito de clase en una macro. No habiendo
        ninguna alternativa diferente a macros de preprocesador, los
        programadores se sentirán tentados de crear algunos atributos
        públicos por el bien de la eficiencia, exponiendo así la
        implementación subyacente e impidiendo cambios en esa
        implementación, así como eliminando la protección que
        proporciona <code class="keyword">private</code>.
      </p></div></div><div class="sect1" title="9.2. Funciones inline"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6369288"></a>9.2. Funciones <code class="keyword">inline</code></h2></div></div></div><p>
      Al resolver el problema que había en C++ con las macros cuando
      acceden a miembros de clases privada, todos los problemas
      asociados con las macros de preprocesador fueron
      eliminados. Esto se ha hecho aplicando el concepto de macros
      bajo el control del compilador al cual pertenecen. C++
      implementa la macro como una función inline, lo que es una
      función real en todo sentido. Todo comportamiento esperado de
      una función ordinaria se obtiene con una función inline. La
      única diferencia es que una función inline se expande en el
      mismo sitio, como una macro de preprocesador, de modo que la
      cabecera de una llamada a función es eliminada. Por ello no
      debería usar macros (casi) nunca, solo funciones inline.
    </p><p>
      Cualquier función definida en el cuerpo de una clase es
      automáticamente inline, pero también puede hacer una función
      inline que no esté dentro del cuerpo de una clase, precediéndola
      con la palabra clave inline. De todos modos, para que esto tenga
      algún efecto, debe incluir el cuerpo de la función con la
      declaración, de otro modo el compilador tratará esa función como
      una declaración de una función ordinaria. Así:
    </p><pre class="programlisting">
<span class="hl kwc">inline</span> <span class="hl kwb">int</span> <span class="hl kwd">plusOne</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">);</span>
</pre><p>
      no tiene ningún otro efecto que declarar la función (que puede o
      no obtener una definición inline después).  La aproximación
      correcta proporciona el cuerpo de la función:
    </p><pre class="programlisting">
<span class="hl kwc">inline</span> <span class="hl kwb">int</span> <span class="hl kwd">plusOne</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl opt">++</span>x<span class="hl opt">; }</span>
</pre><p>
      Observe que el compilador revisará (como siempre lo hace), el
      uso apropiado de la lista de argumentos de la función y del
      valor de retorno (haciendo cualquier conversión necesaria), algo
      que el preprocesador es incapaz de hacer. Además, si intenta
      escribir lo anterior como una macro de preprocesador, obtendrá
      un efecto no deseado.
    </p><p>
      Casi siempre querrá poner las funciones inline en un fichero de
      cabecera. Cuando el compilador ve una definición como esa pone el
      tipo de la función (la firma combinada con el valor de retorno) y
      el cuerpo de la función en su tabla de símbolos. Cuando use la
      función, el compilador se asegura de que la llamada es correcta y
      el valor de retorno se está usando correctamente, y entonces
      sustituye el cuerpo de la función por la llamada a la función, y
      de ese modo elimina la sobrecarga. El código inline ocupa espacio,
      pero si la función es pequeña, realmente ocupará menos espacio que
      el código generado para una llamada a función ordinaria
      (colocando los argumentos en la pila y ejecutando el CALL).
    </p><p>
      Una función inline en un fichero de cabecera tiene un estado
      especial, dado que debe incluir el fichero de cabecera que
      contiene la función y su definición en cada fichero en donde se
      use la función, pero eso no provoca un error de definición
      múltiple (sin embargo, la definición debe ser idéntica en todos
      los sitios en los que se incluya la función inline).
    </p><div class="sect2" title="9.2.1. inline dentro de clases"><div class="titlepage"><div><div><h3 class="title"><a id="idp6377688"></a>9.2.1. inline dentro de clases</h3></div></div></div><p>
       Para definir una función inline, debe anteponer la palabra clave
       <code class="keyword">inline</code> al nombre de la función en el momento
       de definirla. Sin embargo, eso no es necesario cuando se
       define dentro de una clase. Cualquier función que defina dentro
       de una clase es inline automáticamente. Por ejemplo:
      </p><div class="example"><a id="idp6379376"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Inline.cpp</span>
<span class="hl slc">// Inlines inside classes</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Point <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Point</span><span class="hl opt">():</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">j</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">k</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwd">Point</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">,</span> <span class="hl kwb">int</span> jj<span class="hl opt">,</span> <span class="hl kwb">int</span> kk<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">),</span> <span class="hl kwd">j</span><span class="hl opt">(</span>jj<span class="hl opt">),</span> <span class="hl kwd">k</span><span class="hl opt">(</span>kk<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>msg<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() !=</span> <span class="hl num">0</span><span class="hl opt">)</span> cout <span class="hl opt">&lt;&lt;</span> msg <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span>
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;j = &quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span>
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;k = &quot;</span> <span class="hl opt">&lt;&lt;</span> k <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Point p<span class="hl opt">,</span> <span class="hl kwd">q</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span><span class="hl num">2</span><span class="hl opt">,</span><span class="hl num">3</span><span class="hl opt">);</span>
  p<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;value of p&quot;</span><span class="hl opt">);</span>
  q<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;value of q&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.2. C09/Inline.cpp</strong></p></div><br class="example-break" /><p>
	Aquí, los dos constructores y la función
	<code class="function">print()</code> son inline por defecto. Dese
	cuenta de que usar funciones inline es transparente en
	<code class="function">main()</code>, y así debe ser. El comportamiento
	lógico de una función debe ser idéntico aunque sea inline (de
	otro modo su compilador no funcionaría). La única diferencia
	visible es el rendimiento.
      </p><p>
	Por supuesto, la tentación es usar declaraciones
	<code class="keyword">inline</code> en cualquier parte dentro de la case porque
	ahorran el paso extra de hacer una definición de método
	externa. Sin embargo, debe tener presente, que la idea de una
	inline es dar al compilador mejores oportunidades de
	optimización. Pero, si declara inline una función grande
	provocará que el código se duplique allí donde se llame,
	produciendo código [FIXME:bloat] que anulará el beneficio de
	velocidad obtenido (la única manera de descubrir los efectos
	del uso de inline en su programa con su compilador es
	experimentar).
      </p></div><div class="sect2" title="9.2.2. Funciones de acceso"><div class="titlepage"><div><div><h3 class="title"><a id="idp6384000"></a>9.2.2. Funciones de acceso</h3></div></div></div><p>
	Uno de los usos más importantes de inline dentro de clases son
	las funciones de acceso. Se trata de pequeñas funciones que le
	permiten leer o cambiar parte del estado de un objeto, es decir,
	una o varias variables internas. La razón por la que inline
	es tan importante para las funciones de acceso se puede ver en
	el siguiente ejemplo:
      </p><div class="example"><a id="idp6385184"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Access.cpp</span>
<span class="hl slc">// Inline access functions</span>

<span class="hl kwc">class</span> Access <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">read</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Access A<span class="hl opt">;</span>
  A<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> A<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.3. C09/Access.cpp</strong></p></div><br class="example-break" /><p>
	Aquí, el usuario de la clase nunca tiene contacto directo con
	las variables de estado internas a la clase, y pueden mantenerse
	como privadas, bajo el control del diseñador de la clase. Todo
	el acceso a los atributos se puede controlar a través de los
	métodos de la interfaz. Además, el acceso es notablemente
	eficiente. Considere <code class="function">read()</code>, por
	ejemplo. Sin inline, el código generado para la llamada a
	<code class="function">read()</code> podría incluir colocarla en la pila
	y ejecutar la llamada CALL de ensamblador. En la mayoría de las
	arquitecturas, el tamaño de ese código sería mayor que el código
	creado para la variante inline, y el tiempo de ejecución sería
	mayor con toda certeza.
      </p><p>
	Sin las funciones inline, un diseñador de clases preocupado
	por la eficiencia estaría tentado de hacer que
	<code class="varname">i</code> fuese un atributo público, eliminado la
	sobrecarga y permitiendo al usuario acceder directamente a
	<code class="varname">i</code>. Desde el punto de vista del diseñador,
	eso resulta desastroso, <code class="varname">i</code> sería parte de la
	interfaz pública, lo cual significa que el diseñador de la
	clase no podrá cambiarlo en el futuro. Tendrá que cargar con
	un entero llamado <code class="varname">i</code>. Esto es un problema
	porque después puede que considere mejor usar un
	<code class="type">float</code> en lugar de un <code class="type">int</code> para
	representar el estado, pero como <code class="varname">i</code> es parte
	de la interfaz pública, no podrá cambiarlo. O puede que
	necesite realizar algún cálculo adicional como parte de la
	lectura o escritura de <code class="varname">i</code>, que no podrá
	hacer si es público. Si, por el contrario, siempre usa
	métodos para leer y cambiar la información de estado del
	objeto, podrá modificar la representación subyacente del
	objeto hasta estar totalmente convencido.
      </p><p>
	Además, el uso de métodos para controlar atributos le permite
	añadir código al método para detectar cuando cambia el valor,
	algo que puede ser muy útil durante la depuración. Si un
	atributo es público, cualquiera puede cambiarlo en cualquier
	momento sin que el programador lo sepa.
      </p><div class="sect3" title="Accesores y mutadores"><div class="titlepage"><div><div><h4 class="title"><a id="idp6392992"></a>Accesores y mutadores</h4></div></div></div><p>
	  Hay gente que divide el concepto de funciones de acceso en
	  dos: accesores (para leer la información de estado de un
	  objeto) y mutadores (para cambiar el estado de un
	  objeto). Además, se puede utilizar la sobrecarga de
	  funciones para tener métodos accesores y mutadores con el
	  mismo nombre; el modo en que se invoque el método determina
	  si se lee o modifica la información de estado. Así,
	</p><div class="example"><a id="idp6394352"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Rectangle.cpp</span>
<span class="hl slc">// Accessors &amp; mutators</span>

<span class="hl kwc">class</span> Rectangle <span class="hl opt">{</span>
  <span class="hl kwb">int</span> wide<span class="hl opt">,</span> high<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Rectangle</span><span class="hl opt">(</span><span class="hl kwb">int</span> w <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> h <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">wide</span><span class="hl opt">(</span>w<span class="hl opt">),</span> <span class="hl kwd">high</span><span class="hl opt">(</span>h<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">width</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> wide<span class="hl opt">; }</span> <span class="hl slc">// Read</span>
  <span class="hl kwb">void</span> <span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl kwb">int</span> w<span class="hl opt">) {</span> wide <span class="hl opt">=</span> w<span class="hl opt">; }</span> <span class="hl slc">// Set</span>
  <span class="hl kwb">int</span> <span class="hl kwd">height</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> high<span class="hl opt">; }</span> <span class="hl slc">// Read</span>
  <span class="hl kwb">void</span> <span class="hl kwd">height</span><span class="hl opt">(</span><span class="hl kwb">int</span> h<span class="hl opt">) {</span> high <span class="hl opt">=</span> h<span class="hl opt">; }</span> <span class="hl slc">// Set</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Rectangle <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">19</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl slc">// Change width &amp; height:</span>
  r<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">(</span><span class="hl num">2</span> <span class="hl opt">*</span> r<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">());</span>
  r<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">2</span> <span class="hl opt">*</span> r<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.4. C09/Rectangle.cpp</strong></p></div><br class="example-break" /><p>
	  El constructor usa la lista de inicialización (brevemente
	  introducida en el capítulo 8 y ampliamente cubierta en el
	  capitulo 14) para asignar valores a <code class="varname">wide</code>
	  y <code class="varname">high</code> (usando el formato de
	  pseudo-constructor para los tipos de datos básicos).
	</p><p>
	  No puede definir métodos que tengan el mismo nombre que los
	  atributos, de modo que puede que se sienta tentado de
	  distinguirlos con un guión bajo al final. Sin embargo, los
	  identificadores con guiones bajos finales están reservados y
	  el programador no debería usarlos.
	</p><p>
	  En su lugar, debería usar «set» y
	  «get» para indicar que los métodos son accesores
	  y mutadores.
	</p><div class="example"><a id="idp6398856"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Rectangle2.cpp</span>
<span class="hl slc">// Accessors &amp; mutators with &quot;get&quot; and &quot;set&quot;</span>

<span class="hl kwc">class</span> Rectangle <span class="hl opt">{</span>
  <span class="hl kwb">int</span> width<span class="hl opt">,</span> height<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Rectangle</span><span class="hl opt">(</span><span class="hl kwb">int</span> w <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> h <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">width</span><span class="hl opt">(</span>w<span class="hl opt">),</span> <span class="hl kwd">height</span><span class="hl opt">(</span>h<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getWidth</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> width<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setWidth</span><span class="hl opt">(</span><span class="hl kwb">int</span> w<span class="hl opt">) {</span> width <span class="hl opt">=</span> w<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getHeight</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> height<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setHeight</span><span class="hl opt">(</span><span class="hl kwb">int</span> h<span class="hl opt">) {</span> height <span class="hl opt">=</span> h<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Rectangle <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">19</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl slc">// Change width &amp; height:</span>
  r<span class="hl opt">.</span><span class="hl kwd">setHeight</span><span class="hl opt">(</span><span class="hl num">2</span> <span class="hl opt">*</span> r<span class="hl opt">.</span><span class="hl kwd">getWidth</span><span class="hl opt">());</span>
  r<span class="hl opt">.</span><span class="hl kwd">setWidth</span><span class="hl opt">(</span><span class="hl num">2</span> <span class="hl opt">*</span> r<span class="hl opt">.</span><span class="hl kwd">getHeight</span><span class="hl opt">());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.5. C09/Rectangle2.cpp</strong></p></div><br class="example-break" /><p>
	  Por supuesto, los accesores y mutadores no tienen porqué ser
	  simples tuberías hacia las variables internas. A veces,
	  pueden efectuar cálculos más sofisticados. El siguiente
	  ejemplo usa las funciones de tiempo de la librería C
	  estándar para crear una clase <code class="classname">Time</code>:
	</p><div class="example"><a id="idp6401624"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Cpptime.h</span>
<span class="hl slc">// A simple time class</span>
<span class="hl ppc">#ifndef CPPTIME_H</span>
<span class="hl ppc">#define CPPTIME_H</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>

<span class="hl kwc">class</span> Time <span class="hl opt">{</span>
  std<span class="hl opt">::</span><span class="hl kwb">time_t</span> t<span class="hl opt">;</span>
  std<span class="hl opt">::</span>tm local<span class="hl opt">;</span>
  <span class="hl kwb">char</span> asciiRep<span class="hl opt">[</span><span class="hl num">26</span><span class="hl opt">];</span>
  <span class="hl kwb">unsigned char</span> lflag<span class="hl opt">,</span> aflag<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">updateLocal</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>lflag<span class="hl opt">) {</span>
      local <span class="hl opt">= *</span>std<span class="hl opt">::</span><span class="hl kwd">localtime</span><span class="hl opt">(&amp;</span>t<span class="hl opt">);</span>
      lflag<span class="hl opt">++;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">updateAscii</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>aflag<span class="hl opt">) {</span>
      <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
      std<span class="hl opt">::</span><span class="hl kwd">strcpy</span><span class="hl opt">(</span>asciiRep<span class="hl opt">,</span>std<span class="hl opt">::</span><span class="hl kwd">asctime</span><span class="hl opt">(&amp;</span>local<span class="hl opt">));</span>
      aflag<span class="hl opt">++;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Time</span><span class="hl opt">() {</span> <span class="hl kwd">mark</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">mark</span><span class="hl opt">() {</span>
    lflag <span class="hl opt">=</span> aflag <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    std<span class="hl opt">::</span><span class="hl kwd">time</span><span class="hl opt">(&amp;</span>t<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwd">ascii</span><span class="hl opt">() {</span>
    <span class="hl kwd">updateAscii</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> asciiRep<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Difference in seconds:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">delta</span><span class="hl opt">(</span>Time<span class="hl opt">*</span> dt<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwb">int</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">difftime</span><span class="hl opt">(</span>t<span class="hl opt">,</span> dt<span class="hl opt">-&gt;</span>t<span class="hl opt">));</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">daylightSavings</span><span class="hl opt">() {</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_isdst<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">dayOfYear</span><span class="hl opt">() {</span> <span class="hl slc">// Since January 1</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_yday<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">dayOfWeek</span><span class="hl opt">() {</span> <span class="hl slc">// Since Sunday</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_wday<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">since1900</span><span class="hl opt">() {</span> <span class="hl slc">// Years since 1900</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_year<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">month</span><span class="hl opt">() {</span> <span class="hl slc">// Since January</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_mon<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">dayOfMonth</span><span class="hl opt">() {</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_mday<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">hour</span><span class="hl opt">() {</span> <span class="hl slc">// Since midnight, 24-hour clock</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_hour<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">minute</span><span class="hl opt">() {</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_min<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">second</span><span class="hl opt">() {</span>
    <span class="hl kwd">updateLocal</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> local<span class="hl opt">.</span>tm_sec<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// CPPTIME_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.6. C09/Cpptime.h</strong></p></div><br class="example-break" /><p>
	  Las funciones de la librería C estándar tienen múltiples
	  representaciones para el tiempo, y todas ellas son parte de
	  la clase <code class="classname">Time</code>. Sin embargo, no es
	  necesario actualizar todos ellos, así que
	  <code class="type">time_t</code> se usa para la representación base, y
	  <code class="type">tm</code> <code class="varname">local</code> y la representación
	  ASCII <code class="varname">asciiRep</code> tienen banderas para
	  indicar si han sido actualizadas para el <code class="type">time_t</code>
	  actual. Las dos funciones privadas
	  <code class="function">updateLocal()</code> y
	  <code class="function">updateAscii()</code> comprueban las banderas y
	  condicionalmente hacen la actualización.
 	</p><p>
	  El constructor llama a la función
	  <code class="function">mark()</code> (que el usuario puede llamar
	  también para forzar al objeto a representar el tiempo
	  actual), y eso limpia las dos banderas para indicar que el
	  tiempo local y la representación ASCII ya no son válidas. La
	  función <code class="function">ascii()</code> llama a
	  <code class="function">updateAscii()</code>, que copia el resultado
	  de la función de la librería estándar de C
	  <code class="function">asctime()</code> en un buffer local porque
	  <code class="function">asctime()</code> usa una área de datos
	  estática que se sobreescribe si la función se llama en otra
	  parte. El valor de retorno de la función
	  <code class="function">ascii()</code> es la dirección de ese buffer
	  local.
	</p><p>
	  Todas las funciones que empiezan con
	  <code class="function">daylightSavings()</code> usan la función
	  <code class="function">updateLocal()</code>, que causa que la
	  composición resultante de inlines sea bastante larga. No
	  parece que valga la pena, especialmente considerando que
	  probablemente no quiera llamar mucho a esas funciones. Sin
	  embargo, eso no significa que todas las funciones deban ser
	  no-inline. Si hace otras funciones no-inline, al menos
	  mantenga <code class="function">updateLocal()</code> como
	  <code class="keyword">inline</code> de modo que su código se duplique en las
	  funciones no-inline, eliminando la sobrecarga extra de
	  invocación de funciones.
	</p><p>
	  Este es un pequeño programa de prueba:
	</p><div class="example"><a id="idp6415072"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Cpptime.cpp</span>
<span class="hl slc">// Testing a simple time class</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Cpptime.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Time start<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">1000</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>i<span class="hl opt">%</span><span class="hl num">10</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Time end<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;start = &quot;</span> <span class="hl opt">&lt;&lt;</span> start<span class="hl opt">.</span><span class="hl kwd">ascii</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;end = &quot;</span> <span class="hl opt">&lt;&lt;</span> end<span class="hl opt">.</span><span class="hl kwd">ascii</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;delta = &quot;</span> <span class="hl opt">&lt;&lt;</span> end<span class="hl opt">.</span><span class="hl kwd">delta</span><span class="hl opt">(&amp;</span>start<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.7. C09/Cpptime.cpp</strong></p></div><br class="example-break" /><p>
	  Se crea un objeto <code class="classname">Time</code>, se hace alguna
	  actividad que consuma tiempo, después se crea un segundo objeto
	  <code class="classname">Time</code> para marcar el tiempo de
	  finalización. Se usan para mostrar los tiempos de inicio, fin
	  y los intervalos.
	</p></div></div></div><div class="sect1" title="9.3. Stash y Stack con inlines"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6417632"></a>9.3. Stash y Stack con inlines</h2></div></div></div><p>
      Disponiendo de inlines, podemos modificar las clases
      <code class="classname">Stash</code> y <code class="classname">Stack</code> para
      hacerlas más eficientes.
    </p><div class="example"><a id="idp6418760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Stash4.h</span>
<span class="hl slc">// Inline functions</span>
<span class="hl ppc">#ifndef STASH4_H</span>
<span class="hl ppc">#define STASH4_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Stash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
  <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) :</span> <span class="hl kwd">size</span><span class="hl opt">(</span>sz<span class="hl opt">),</span> <span class="hl kwd">quantity</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span>
    <span class="hl kwd">next</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">storage</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwd">Stash</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">,</span> <span class="hl kwb">int</span> initQuantity<span class="hl opt">) :</span> <span class="hl kwd">size</span><span class="hl opt">(</span>sz<span class="hl opt">),</span> 
    <span class="hl kwd">quantity</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">storage</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {</span> 
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>initQuantity<span class="hl opt">);</span> 
  <span class="hl opt">}</span>
  Stash<span class="hl opt">::~</span><span class="hl kwd">Stash</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>storage <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">)</span> 
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> index<span class="hl opt">,</span> <span class="hl str">&quot;Stash::fetch (-)index&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
      <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
    <span class="hl slc">// Produce pointer to desired element:</span>
    <span class="hl kwa">return</span> <span class="hl opt">&amp;(</span>storage<span class="hl opt">[</span>index <span class="hl opt">*</span> size<span class="hl opt">]);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> next<span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STASH4_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.8. C09/Stash4.h</strong></p></div><br class="example-break" /><p>
      Obviamente las funciones pequeñas funcionan bien como inlines,
      pero note que las dos funciones más largas siguen siendo
      no-inline, dado que convertirlas a inline no representaría ninguna
      mejora de rendimiento.
    </p><div class="example"><a id="idp6421688"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Stash4.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stash4.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">const int</span> increment <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

<span class="hl kwb">int</span> Stash<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span> <span class="hl slc">// Enough space left?</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>increment<span class="hl opt">);</span>
  <span class="hl slc">// Copy element into storage,</span>
  <span class="hl slc">// starting at next empty space:</span>
  <span class="hl kwb">int</span> startBytes <span class="hl opt">=</span> next <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> e <span class="hl opt">= (</span><span class="hl kwb">unsigned char</span><span class="hl opt">*)</span>element<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    storage<span class="hl opt">[</span>startBytes <span class="hl opt">+</span> i<span class="hl opt">] =</span> e<span class="hl opt">[</span>i<span class="hl opt">];</span>
  next<span class="hl opt">++;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Stash<span class="hl opt">::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>increase <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>increase <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> newQuantity <span class="hl opt">=</span> quantity <span class="hl opt">+</span> increase<span class="hl opt">;</span>
  <span class="hl kwb">int</span> newBytes <span class="hl opt">=</span> newQuantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">int</span> oldBytes <span class="hl opt">=</span> quantity <span class="hl opt">*</span> size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> oldBytes<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Copy old to new</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[](</span>storage<span class="hl opt">);</span> <span class="hl slc">// Release old storage</span>
  storage <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
  quantity <span class="hl opt">=</span> newQuantity<span class="hl opt">;</span> <span class="hl slc">// Adjust the size</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.9. C09/Stash4.cpp</strong></p></div><br class="example-break" /><p>
      Una vez más, el programa de prueba que verifica que todo
      funciona correctamente.
    </p><div class="example"><a id="idp6424168"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Stash4Test.cpp</span>
<span class="hl slc">//{L} Stash4</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stash4.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stash <span class="hl kwd">intStash</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    intStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(&amp;</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> intStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;intStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span>intStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>j<span class="hl opt">)</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">80</span><span class="hl opt">;</span>
  Stash <span class="hl kwd">stringStash</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">) *</span> bufsize<span class="hl opt">,</span> <span class="hl num">100</span><span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Stash4Test.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Stash4Test.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    stringStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">((</span><span class="hl kwb">char</span><span class="hl opt">*)</span>line<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span>stringStash<span class="hl opt">.</span><span class="hl kwd">fetch</span><span class="hl opt">(</span>k<span class="hl opt">++))!=</span><span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;stringStash.fetch(&quot;</span> <span class="hl opt">&lt;&lt;</span> k <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.10. C09/Stash4Test.cpp</strong></p></div><br class="example-break" /><p>
      Este es el mismo programa de prueba que se usó antes, de modo que
      la salida debería ser básicamente la misma.
    </p><p>
      La clase <code class="classname">Stack</code> incluso hace mejor uso de inline's.
    </p><div class="example"><a id="idp6427784"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Stack4.h</span>
<span class="hl slc">// With inlines</span>
<span class="hl ppc">#ifndef STACK4_H</span>
<span class="hl ppc">#define STACK4_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    <span class="hl kwb">void</span><span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwd">Link</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">):</span> 
      <span class="hl kwd">data</span><span class="hl opt">(</span>dat<span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span>nxt<span class="hl opt">) {}</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() :</span> <span class="hl kwd">head</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Stack</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Stack not empty&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> dat<span class="hl opt">) {</span>
    head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span> head<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    <span class="hl kwa">return</span> head ? head<span class="hl opt">-&gt;</span>data <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwb">void</span><span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
    head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
    <span class="hl kwa">return</span> result<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STACK4_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.11. C09/Stack4.h</strong></p></div><br class="example-break" /><p>
      Note que el destructor <code class="classname">Link</code>, que se
      presentó (vacío) en la versión anterior de
      <code class="classname">Stack</code>, ha sido eliminado. En
      <code class="function">pop()</code>, la expresión <code class="code">delete
      oldHead</code> simplemente libera la memoria usada por
      <code class="classname">Link</code> (no destruye el objeto
      <code class="varname">data</code> apuntado por el
      <code class="classname">Link</code>).
    </p><p>
      La mayoría de las funciones inline quedan bastante bien
      obviamente, en especial para
      <code class="classname">Link</code>. Incluso
      <code class="methodname">pop()</code> parece justificado, aunque
      siempre que haya sentencias condicionales o variables locales no
      está claro que las inlines sean beneficiosas. Aquí, la función
      es lo suficientemente pequeña así que es probable que no haga
      ningún daño.
    </p><p>
      Si todas sus funciones son inline, usar la librería se convierte
      en algo bastante simple porque el enlazado es innecesario, como
      puede ver en el ejemplo de prueba (fíjese en que no hay
      <code class="filename">Stack4.cpp</code>).
    </p><div class="example"><a id="idp6434120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Stack4Test.cpp</span>
<span class="hl slc">//{T} Stack4Test.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Stack4.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// File name is argument</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  Stack textlines<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl slc">// Read file and store lines in the stack:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Pop the lines from the stack and print them:</span>
  string<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>s <span class="hl opt">= (</span>string<span class="hl opt">*)</span>textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.12. C09/Stack4Test.cpp</strong></p></div><br class="example-break" /><p>
      La gente escribe a veces clases con todas sus funciones inline,
      así que la clase completa está en el fichero de cabecera (verá
      en este libro que yo mismo lo hago). Durante el desarrollo de un
      programa probablemente esto es inofensivo, aunque a veces puede
      hacer que las compilaciones sean más lentas. Cuando el programa
      se estabiliza un poco, probablemente querrá volver a hacer las
      funciones no-inline donde sea conveniente.
    </p></div><div class="sect1" title="9.4. Funciones inline y el compilador"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6437296"></a>9.4. Funciones inline y el compilador</h2></div></div></div><p>
      Para comprender cuando es conveniente utilizar inlines, es útil
      saber lo que hace el compilador cuando encuentra una función
      inline. Como con cualquier función, el compilador apunta el
      <span class="emphasis"><em>tipo</em></span> de la función es su tabla de símbolos
      (es decir, el prototipo de la función incluyendo el nombre y los
      tipos de los argumentos, en combinación con valor de
      retorno). Además cuando el compilador ve que la función es
      inline <span class="emphasis"><em>y</em></span> el cuerpo no contiene errores, el
      código se coloca también en la tabla de símbolos. El código se
      almacena en su forma fuente, como instrucciones ensamblador
      compiladas, o alguna otra representación propia del compilador.
    </p><p>
      Cuando hace una llamada a una función inline, el compilador se
      asegura primero de que la llamada se puede hacer
      correctamente. Es decir, los tipos de todos los argumentos
      corresponden exactamente con los tipos de la lista de argumentos
      de la función (o convertible a tipo correcto) y el valor de
      retorno tiene el tipo correcto (o es convertible al tipo
      correcto) en la expresión destino. Esto, por supuesto, es
      exactamente lo mismo que hace el compilador para cualquier
      función y hay una diferencia considerable respecto de lo que
      hace el preprocesador, porque el preprocesador no comprueba
      tipos ni hace conversiones.
    </p><p>
      Si toda la información del tipo de la función encaja en el
      contexto de la llamada, entonces la llamada a la función se
      sustituye directamente por el código inline, eliminando la sobrecarga
      y permitiendo que el compilador pueda hacer más
      optimizaciones. Además, si el inline es un método, la dirección
      del objeto(<code class="varname">this</code>) se pone en el lugar apropiado,
      que es, por supuesto, otra acción que el preprocesador es incapaz
      de hacer.
    </p><div class="sect2" title="9.4.1. Limitaciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp6442696"></a>9.4.1. Limitaciones</h3></div></div></div><p>
	Hay dos situaciones en que el compilador no puede efectuar la
	sustitución de inline. En estos casos, simplemente convierte la
	función a la forma ordinaria tomando la definición y pidiendo
	espacio para la función como hace con una función no-inline. Si
	debe hacerlo en varias unidades de traducción (lo que
	normalmente causaría un error de definición múltiple), informa
	al enlazador que ignore esas definiciones múltiples.
      </p><p>
	En compilador no puede efectuar la sustitución de inline si la
	función es demasiado complicada. Esto depende de cada
	compilador particular, pero aunque muchos compiladores lo
	hagan, no habrá ninguna mejora de eficiencia. En general, se
	considera que cualquier tipo de bucle es demasiado complicado
	para expandir como una inline, y si lo piensa, el bucle
	implica mucho más tiempo que el que conlleva la sobrecarga de
	la invocación de la función. Si la función es simplemente una
	colección se sentencias simples, probablemente el compilador
	no tendrá ningún problema para utilizar inline, pero si hay
	muchas sentencias, la sobrecarga de llamada será mucho menor
	que el coste de ejecutar el cuerpo. Y recuerde, cada vez que
	llame a una función inline grande, el cuerpo completo se
	inserta en el lugar de la llamada, de modo que el tamaño del
	código se inflará fácilmente sin que se perciba ninguna mejora
	de rendimiento. (Note que algunos de los ejemplos de este
	libro pueden exceder el tamaño razonable para una inline a
	cambio de mejorar la estética de los listados.
      </p><p>
	El compilador tampoco efectúa sustituciones inline si la
	dirección de la función se toma implícita o explícitamente. Si
	el compilador debe producir una dirección, entonces tendrá que
	alojar el código de la función y usar la dirección
	resultante. Sin embargo, cuando no se requiere una dirección,
	probablemente el compilador hará la sustitución inline.
      </p><p>
	Es importante comprender que una declaración inline es sólo una
	sugerencia al compilador; el compilador no está forzado a hacer
	nada. Un buen compilador hará sustituciones inline para
	funciones pequeñas y simples mientras que ignorará las que sean
	demasiado complicadas. Eso le dará lo que espera - la auténtica
	semántica de una llamada a función con la eficiencia de una
	macro.
      </p></div><div class="sect2" title="9.4.2. Referencias adelantadas"><div class="titlepage"><div><div><h3 class="title"><a id="idp6447984"></a>9.4.2. Referencias adelantadas</h3></div></div></div><p>
	Si está imaginando que el compilador [FIXME: is doing to
	implement inlines], puede confundirse pensando que hay más
	limitaciones que las que existen realmente. En concreto, si
	una inline hace una referencia adelanta a una función que no
	ha sido declarada aún en la clase (sea inline o no), puede
	parecer que el compilador no sabrá tratarla.
      </p><div class="example"><a id="idp6449152"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:EvaluationOrder.cpp</span>
<span class="hl slc">// Inline evaluation order</span>

<span class="hl kwc">class</span> Forward <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Forward</span><span class="hl opt">() :</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl slc">// Call to undeclared function:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwd">g</span><span class="hl opt">() +</span> <span class="hl num">1</span><span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Forward frwd<span class="hl opt">;</span>
  frwd<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.13. C09/EvaluationOrder.cpp</strong></p></div><br class="example-break" /><p>
	En <code class="function">f()</code>, se realiza una llamada a
	<code class="function">g()</code>, aunque <code class="function">g()</code> aún no
	ha sido declarada. Esto funciona porque la definición del
	lenguaje dice que las funciones inline en una clase no serán
	evaluadas hasta la llave de cierre de la declaración de clase.
      </p><p>
	Por supuesto, si <code class="function">g()</code> a su vez llama a
	<code class="function">f()</code>, tendrá un conjunto de llamadas
	recursivas, que son demasiado complicadas para el compilador
	pueda hacer inline. (También, tendrá que efectuar alguna
	comprobación en <code class="function">f()</code> o
	<code class="function">g()</code> para forzar en alguna de ellas un caso
	base, o la recursión será infinita).
      </p></div><div class="sect2" title="9.4.3. Actividades ocultas en contructores y destructores"><div class="titlepage"><div><div><h3 class="title"><a id="idp6454160"></a>9.4.3. Actividades ocultas en contructores y destructores</h3></div></div></div><p>
	Constructores y destructores son dos lugares dónde puede
	engañarse al pensar que una inline es más eficiente de lo que
	realmente es. Constructores y destructores pueden tener
	actividades ocultas, porque la clase puede contener subobjetos
	cuyos constructores y destructores deben invocarse. Estos
	subobjetos pueden ser objetos miembro (atributos), o pueden
	existir por herencia (tratado en el Capítulo 14). Como un
	ejemplo de clase con un objeto miembro:
      </p><div class="example"><a id="idp6455432"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Hidden.cpp</span>
<span class="hl slc">// Hidden activities in inlines</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Member <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Member</span><span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>x<span class="hl opt">),</span> <span class="hl kwd">j</span><span class="hl opt">(</span>x<span class="hl opt">),</span> <span class="hl kwd">k</span><span class="hl opt">(</span>x<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Member</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Member&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> WithMembers <span class="hl opt">{</span>
  Member q<span class="hl opt">,</span> r<span class="hl opt">,</span> s<span class="hl opt">;</span> <span class="hl slc">// Have constructors</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">WithMembers</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span> <span class="hl slc">// Trivial?</span>
  <span class="hl opt">~</span><span class="hl kwd">WithMembers</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~WithMembers&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  WithMembers <span class="hl kwd">wm</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.14. C09/Hidden.cpp</strong></p></div><br class="example-break" /><p>
	El constructor para <code class="classname">Member</code> es
	suficientemente simple para ser inline, dado que no hay nada
	especial en él - ninguna herencia u objeto miembro está
	provocando actividades ocultas adicionales. Pero en la clase
	<code class="classname">WithMembers</code> hay más de lo que se ve a
	simple vista. Los constructores y destructores para los
	atributos <code class="varname">q</code>, <code class="varname">r</code> y
	<code class="varname">s</code> se llaman automáticamente, y esos
	constructores y destructores también son inline, así que la
	diferencia es significativa respecto a métodos normales. Esto no
	significa necesariamente que los constructores y destructores
	deban ser no-inline; hay casos en que tiene sentido. También,
	cuando se está haciendo un prototipo inicial de un programa
	escribiendo código rápidamente, es conveniente a menudo usar
	inlines. Pero si está preocupado por la eficiencia, es un sitio
	donde mirar.
      </p></div></div><div class="sect1" title="9.5. Reducir el desorden"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6459432"></a>9.5. Reducir el desorden</h2></div></div></div><p>
      En un libro como éste, la simplicidad y brevedad de poner
      definiciones inline dentro de las clases es muy útil porque
      permite meter más en una página o pantalla (en un
      seminario). Sin embargo, <span class="author"><span class="firstname">Dan</span> <span class="surname">Saks</span></span> <sup>[<a id="idp6460824" href="#ftn.idp6460824" class="footnote">67</a>]</sup> ha apuntado que en un proyecto real esto tiene como
      consecuencia el desorden de la interfaz de la clase y eso hace
      que la clase sea más incomoda de usar. Él se refiere a los
      métodos definidos dentro de las clases usando la expresión
      <span class="emphasis"><em>in situ</em></span> (en el lugar) e indica que todas
      las definiciones deberían colocarse fuera de la clase
      manteniendo la interfaz limpia. La optimización, argumenta él,
      es una asunto distinto. Si se requiere optimizar, use la palabra
      reservada <code class="keyword">inline</code>. Siguiente ese enfoque, el ejemplo
      anterior <code class="filename">Rectangle.cpp</code> quedaría:
    </p><div class="example"><a id="idp6464384"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Noinsitu.cpp</span>
<span class="hl slc">// Removing in situ functions</span>

<span class="hl kwc">class</span> Rectangle <span class="hl opt">{</span>
  <span class="hl kwb">int</span> width<span class="hl opt">,</span> height<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Rectangle</span><span class="hl opt">(</span><span class="hl kwb">int</span> w <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> h <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getWidth</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setWidth</span><span class="hl opt">(</span><span class="hl kwb">int</span> w<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getHeight</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setHeight</span><span class="hl opt">(</span><span class="hl kwb">int</span> h<span class="hl opt">);</span>
<span class="hl opt">};</span>

<span class="hl kwc">inline</span> Rectangle<span class="hl opt">::</span><span class="hl kwd">Rectangle</span><span class="hl opt">(</span><span class="hl kwb">int</span> w<span class="hl opt">,</span> <span class="hl kwb">int</span> h<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">width</span><span class="hl opt">(</span>w<span class="hl opt">),</span> <span class="hl kwd">height</span><span class="hl opt">(</span>h<span class="hl opt">) {}</span>

<span class="hl kwc">inline</span> <span class="hl kwb">int</span> Rectangle<span class="hl opt">::</span><span class="hl kwd">getWidth</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwa">return</span> width<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">inline</span> <span class="hl kwb">void</span> Rectangle<span class="hl opt">::</span><span class="hl kwd">setWidth</span><span class="hl opt">(</span><span class="hl kwb">int</span> w<span class="hl opt">) {</span>
  width <span class="hl opt">=</span> w<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">inline</span> <span class="hl kwb">int</span> Rectangle<span class="hl opt">::</span><span class="hl kwd">getHeight</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwa">return</span> height<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">inline</span> <span class="hl kwb">void</span> Rectangle<span class="hl opt">::</span><span class="hl kwd">setHeight</span><span class="hl opt">(</span><span class="hl kwb">int</span> h<span class="hl opt">) {</span>
  height <span class="hl opt">=</span> h<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Rectangle <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">19</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl slc">// Transpose width &amp; height:</span>
  <span class="hl kwb">int</span> iHeight <span class="hl opt">=</span> r<span class="hl opt">.</span><span class="hl kwd">getHeight</span><span class="hl opt">();</span>
  r<span class="hl opt">.</span><span class="hl kwd">setHeight</span><span class="hl opt">(</span>r<span class="hl opt">.</span><span class="hl kwd">getWidth</span><span class="hl opt">());</span>
  r<span class="hl opt">.</span><span class="hl kwd">setWidth</span><span class="hl opt">(</span>iHeight<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.15. C09/Noinsitu.cpp</strong></p></div><br class="example-break" /><p>
      Ahora si quiere comparar el efecto de la funciones inline con la
      versión convencional, simplemente borre la palabra
      <code class="keyword">inline</code>. (Las funciones inline normalmente deberían
      aparecen en los ficheros de cabecera, no obstante, las funciones
      no-inline deberían residir en un propia unidad de
      traducción). Si quiere poner las funciones en la documentación,
      es tan simple como un «copiar y pegar». Las
      funciones <span class="emphasis"><em>in situ</em></span> requieren más trabajo y
      tienen más posibilidades de provocar errores. Otro argumento
      para esta propuesta es que siempre puede producir un estilo de
      formato consistente para las definiciones de función, algo que
      no siempre ocurre con las funciones <span class="emphasis"><em>in
      situ</em></span>.
    </p></div><div class="sect1" title="9.6. Más características del preprocesador"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6469312"></a>9.6. Más características del preprocesador</h2></div></div></div><p>
      Antes, se dijo que <span class="emphasis"><em>casi</em></span> siempre se prefiere
      usar funciones inline en lugar de macros del preprocesador. Las
      excepciones aparecen cuando necesita usar tres propiedades especiales
      del preprocesador de C (que es también el preprocesador de C++):
      [FIXME(hay más):cadenización?]
      (<span class="emphasis"><em>stringizing</em></span>), concatenación de cadenas, y
      encolado de símbolos (<span class="emphasis"><em>token
      pasting</em></span>). <span class="emphasis"><em>Stringizing</em></span>, ya
      comentado anteriormente en el libro, se efectúa con la directiva
      <code class="literal">#</code> y permite tomar un identificador y
      convertirlo en una cadena de caracteres. La concatenación de
      cadenas tiene lugar cuando dos cadenas adyacentes no tienen
      puntuación, en cuyo caso se combinan. Estas dos propiedades son
      especialmente útiles cuando se escribe código de depuración. Así,
    </p><pre class="programlisting">
<span class="hl ppc">#define DEBUG(x) cout &lt;&lt; #x</span> <span class="hl pps">&quot; = &quot;</span><span class="hl ppc"> &lt;&lt; x &lt;&lt; endl</span>
</pre><p>
      Esto imprime el valor de cualquier variable. Puede conseguir
      también una traza que imprima las sentencias tal como se ejecutan:
    </p><pre class="programlisting">
<span class="hl ppc">#define TRACE(s) cerr &lt;&lt; #s &lt;&lt; endl; s</span>
</pre><p>
      El <code class="literal">#s</code> <span class="emphasis"><em>cadeniza</em></span> la
      sentencia para la salida, y la segunda <code class="literal">s</code> hace
      que la sentencia se ejecute. Por supuesto, este tipo de cosas
      pueden causar problemas, especialmente bucles <code class="keyword">for</code> de una
      única línea.
    </p><pre class="programlisting">
<span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
     <span class="hl kwd">TRACE</span><span class="hl opt">(</span><span class="hl kwd">f</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
</pre><p>
      Como realmente hay dos sentencias en la macro
      <code class="function">TRACE()</code>, el bucle <code class="keyword">for</code> de
      una única línea ejecuta solo la primera. La solución es reemplazar
      el punto y coma por una coma en la macro.
    </p><div class="sect2" title="9.6.1. Encolado de símbolos"><div class="titlepage"><div><div><h3 class="title"><a id="idp6477696"></a>9.6.1. Encolado de símbolos</h3></div></div></div><p>
	El encolado de símbolos, implementado con la directiva
	<code class="literal">##</code>, es muy útil cuando se genera
	código. Permite coger dos identificadores y pegarlos juntos
	para crear un nuevo identificador automáticamente. Por
	ejemplo,
      </p><pre class="programlisting">
<span class="hl ppc">#define FIELD(a) char* a##_string; int a##_size</span>
    <span class="hl kwc">class</span> Record <span class="hl opt">{</span>
      <span class="hl kwd">FIELD</span><span class="hl opt">(</span>one<span class="hl opt">);</span>
      <span class="hl kwd">FIELD</span><span class="hl opt">(</span>two<span class="hl opt">);</span>
      <span class="hl kwd">FIELD</span><span class="hl opt">(</span>three<span class="hl opt">);</span>
      <span class="hl slc">// ...</span>
    <span class="hl opt">};</span>
</pre><p>
	Cada llamada a la macro <code class="function">FIELD()</code> crea un
	identificador para una cadena de caracteres y otro para la
	longitud de dicha cadena. No solo es fácil de leer, también
	puede eliminar errores de codificación y facilitar el
	mantenimiento.
      </p></div></div><div class="sect1" title="9.7. Comprobación de errores mejorada"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6480720"></a>9.7. Comprobación de errores mejorada</h2></div></div></div><p>
      Las funciones de <code class="filename">require.h</code> se han usado
      antes de este punto sin haberlas definido (aunque
      <code class="function">assert()</code> se ha usado también para ayudar a
      detectar errores del programador donde es apropiado). Ahora es
      el momento de definir este fichero de cabecera. Las funciones
      inline son convenientes aquí porque permiten colocar todo en el
      fichero de cabecera, lo que simplifica el proceso para usar el
      paquete. Simplemente, incluya el fichero de cabecera y se
      preocupe por enlazar un fichero de implementación.
    </p><p>
      Debería fijarse que las excepciones (presentadas en detalle en
      el Volumen 2 de este libro) proporcionan una forma mucho más
      efectiva de manejar muchos tipos de errores -especialmente
      aquellos de los que debería recuperarse- en lugar de
      simplemente abortar el programa. Las condiciones que maneja
      <code class="filename">require.h</code>, sin embargo, son algunas que
      impiden que el programa continúe, como por ejemplo que el
      usuario no introdujo suficientes argumentos en la línea de
      comandos o que un fichero no se puede abrir. De modo que es
      aceptable que usen la función <code class="function">exit()</code> de la
      librería C estándar.
    </p><p>
      El siguiente fichero de cabecera está en el directorio raíz del
      libro, así que es fácilmente accesible desde todos los capítulos.
    </p><pre class="programlisting">
<span class="hl slc">//: :require.h&amp;#13;</span>
<span class="hl slc">// From Thinking in C++, 2nd Edition&amp;#13;</span>
<span class="hl slc">// Available at http://www.BruceEckel.com&amp;#13;</span>
<span class="hl slc">// (c) Bruce Eckel 2000&amp;#13;</span>
<span class="hl slc">// Copyright notice in Copyright.txt&amp;#13;</span>
<span class="hl slc">// Test for error conditions in programs&amp;#13;</span>
<span class="hl slc">// Local &quot;using namespace std&quot; for old compilers&amp;#13;</span>
<span class="hl ppc">#ifndef REQUIRE_H&amp;#13;</span>
<span class="hl ppc">#define REQUIRE_H&amp;#13;</span>
<span class="hl ppc">#include &lt;cstdio&gt;&amp;#13;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;&amp;#13;</span>
<span class="hl ppc">#include &lt;fstream&gt;&amp;#13;</span>
<span class="hl ppc">#include &lt;string&gt;&amp;#13;</span>
<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl kwb">bool</span> requirement<span class="hl opt">, &amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;Requirement failed&quot;</span><span class="hl opt">){&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">using namespace</span> std<span class="hl opt">;&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">if</span> <span class="hl opt">(!</span>requirement<span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">fputs</span><span class="hl opt">(</span>msg<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> stderr<span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">fputs</span><span class="hl opt">(</span><span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> stderr<span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">requireArgs</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">int</span> args<span class="hl opt">, &amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> msg <span class="hl opt">= &amp;</span><span class="hl ppc">#13;</span>
    <span class="hl str">&quot;Must use %d arguments&quot;</span><span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">using namespace</span> std<span class="hl opt">;&amp;</span><span class="hl ppc">#13;</span>
   <span class="hl kwa">if</span> <span class="hl opt">(</span>argc <span class="hl opt">!=</span> args <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
     <span class="hl kwd">fprintf</span><span class="hl opt">(</span>stderr<span class="hl opt">,</span> msg<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> args<span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
     <span class="hl kwd">fputs</span><span class="hl opt">(</span><span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> stderr<span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
     <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
   <span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">requireMinArgs</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">int</span> minArgs<span class="hl opt">,&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> msg <span class="hl opt">=&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl str">&quot;Must use at least %d arguments&quot;</span><span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">using namespace</span> std<span class="hl opt">;&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">&lt;</span> minArgs <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">fprintf</span><span class="hl opt">(</span>stderr<span class="hl opt">,</span> msg<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> minArgs<span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">fputs</span><span class="hl opt">(</span><span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> stderr<span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">assure</span><span class="hl opt">(</span>std<span class="hl opt">::</span>ifstream<span class="hl opt">&amp;</span> in<span class="hl opt">, &amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> filename <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">using namespace</span> std<span class="hl opt">;&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>in<span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">fprintf</span><span class="hl opt">(</span>stderr<span class="hl opt">,</span> <span class="hl str">&quot;Could not open file %s</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,&amp;</span><span class="hl ppc">#13;</span>
      filename<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">assure</span><span class="hl opt">(</span>std<span class="hl opt">::</span>ofstream<span class="hl opt">&amp;</span> out<span class="hl opt">, &amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> filename <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">using namespace</span> std<span class="hl opt">;&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>out<span class="hl opt">) {&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">fprintf</span><span class="hl opt">(</span>stderr<span class="hl opt">,</span> <span class="hl str">&quot;Could not open file %s</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">, &amp;</span><span class="hl ppc">#13;</span>
      filename<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());&amp;</span><span class="hl ppc">#13;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);&amp;</span><span class="hl ppc">#13;</span>
  <span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl opt">}&amp;</span><span class="hl ppc">#13;</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// REQUIRE_H ///:~&amp;#13;</span><span class="hl ppc"></span>
</pre><p>
      Los valores por defecto proporcionan mensajes razonables que se
      pueden cambiar si es necesario.
    </p><p>
      Fíjese en que en lugar de usar argumentos <code class="type">char*</code> se
      utiliza <code class="type">const string&amp;</code>. Esto permite tanto
      <code class="type">char*</code>, cadenas <code class="classname">string</code> como
      argumentos para estas funciones, y así es más general (quizá
      quiera utilizar esta forma en su propio código).
    </p><p>
      En las definiciones para <code class="function">requireArgs()</code> y
      <code class="function">requireMinArgs()</code>, se añade uno al número de
      argumentos que necesita en la línea de comandos porque
      <code class="varname">argc</code> siempre incluye el nombre del programa
      que está ejecutado como argumento cero, y por eso siempre tiene
      un valor que excede en uno al número real de argumentos de la
      línea de comandos.
    </p><p>
      Fíjese en el uso de declaraciones locales <code class="code">using namespace
      std</code> con cada función. Esto es porque algunos compiladores
      en el momento de escribir este libro incluyen incorrectamente
      las funciones de la librería C estándar en el espacio de nombres
      <code class="classname">std</code>, así que la cualificación explícita
      podría causar un error en tiempo de compilación. Las
      declaraciones locales permiten que
      <code class="filename">require.h</code> funcione tanto con librerías
      correctas como con incorrectas sin abrir el espacio de nombres
      <code class="classname">std</code> para cualquiera que incluya este
      fichero de cabecera.
    </p><p>
      Aquí hay un programa simple para probar
      <code class="filename">requite.h</code>:
    </p><div class="example"><a id="idp6494312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:ErrTest.cpp</span>
<span class="hl slc">//{T} ErrTest.cpp</span>
<span class="hl slc">// Testing require.h</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>i<span class="hl opt">,</span> <span class="hl str">&quot;value must be nonzero&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">requireMinArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span> <span class="hl slc">// Use the file name</span>
  ifstream <span class="hl kwd">nofile</span><span class="hl opt">(</span><span class="hl str">&quot;nofile.xxx&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Fails:</span>
<span class="hl slc">//!  assure(nofile); // The default argument</span>
  ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;tmp.txt&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>out<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.16. C09/ErrTest.cpp</strong></p></div><br class="example-break" /><p>
      Podría estar tentado a ir un paso más allá para manejar la
      apertura de ficheros y añadir una macro a
      <code class="function">require.h</code>.
    </p><pre class="programlisting">
<span class="hl ppc">#define IFOPEN(VAR, NAME) \</span>
<span class="hl ppc">      ifstream VAR(NAME); \</span>
<span class="hl ppc">      assure(VAR, NAME);</span>
</pre><p>
      Que podría usarse entonces así:
    </p><pre class="programlisting">
<span class="hl kwd">IFOPEN</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">])</span>
</pre><p>
      En principio, esto podría parecer atractivo porque significa que
      hay que escribir menos. No es terriblemente inseguro, pero es un
      camino que es mejor evitar. Fíjese que, de nuevo, una macro
      parece una función pero se comporta diferente; realmente se está
      creando un objeto <code class="varname">in</code> cuyo alcance persiste
      más allá de la macro. Quizá lo entienda, pero para programadores
      nuevos y mantenedores de código sólo es una cosa más que ellos
      deben resolver. C++ es suficientemente complicado sin añadir
      confusión, así que intente no abusar de las macros del
      preprocesador siempre que pueda.
    </p></div><div class="sect1" title="9.8. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6500040"></a>9.8. Resumen</h2></div></div></div><p>
      Es crítico que sea capaz de ocultar la implementación subyacente
      de una clase porque puede querer cambiarla después. Hará estos
      cambios por eficiencia, o porque haya alcanzado una mejor
      comprensión del problema, o porque hay alguna clase nueva
      disponible para usar en la implementación. Cualquier cosa que
      haga peligrar la privacidad de la implementación subyacente
      reduce la flexibilidad del lenguaje. Por eso, la función inline
      es muy importante porque prácticamente elimina la necesidad de
      macros de preprocesador y sus problemas asociados. Con inline,
      los métodos pueden ser tan eficientes como las macros.
    </p><p>
      Por supuesto se puede abusan de las funciones inline en las
      definiciones de clase. El programador está tentado de hacerlo
      porque es fácil, así que lo hace. Sin embargo, no es un problema
      grave porque después, cuando se busquen reducciones de tamaño,
      siempre puede cambiar las inline a funciones convencionales dado
      que no afecta a su funcionalidad. La pauta debería ser
      «Primero haz el trabajo, después optimiza».
    </p></div><div class="sect1" title="9.9. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6503368"></a>9.9. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Escriba un programa que use la macro <code class="function">F()</code>
	  mostrada al principio del capítulo y demuestre que no se
	  expande apropiadamente, tal como describe el texto. Arregle la
	  macro y demuestre que funciona correctamente.
	</p></li><li class="listitem"><p>
	  Escriba un programa que use la macro
	  <code class="function">FLOOR()</code> mostrada al principio del
	  capítulo. Muestre las condiciones en que no funciona
	  apropiadamente.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">MacroSideEffects.cpp</code> de modo
	  que <code class="function">BAND()</code> funcione adecuadamente.
	</p></li><li class="listitem"><p>
	  Cree dos funciones idénticas, <code class="function">f1()</code> y
	  <code class="function">f2()</code>. Haga inline a
	  <code class="function">f1()</code> y deje <code class="function">f2()</code>
	  como no-inline. Use la función <code class="function">clock()</code> de
	  la librería C estándar que se encuentra en
	  <code class="filename">&lt;ctime&gt;</code> para marcar los puntos de
	  comienzo y fin y compare las dos funciones para ver cuál es
	  más rápida. Puede que necesite hacer un bucle de llamadas
	  repetidas para conseguir números representativos.
	</p></li><li class="listitem"><p>
	  Experimente con el tamaño y complejidad del código de las
	  funciones del ejercicio 4 para ver si puede encontrar el punto
	  donde la función inline y la convencional tardan lo mismo. Si
	  dispone de ellos, inténtelo con compiladores distintos y
	  fíjese en las diferencias.
	</p></li><li class="listitem"><p>
	  Pruebe que las funciones inline hacen enlazado interno por
	  defecto.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un array de caracteres. Añada un
	  constructor inline que use la función
	  <code class="function">memset()</code> de la librería C estándar para
	  inicializar el array al valor dado como argumento del
	  constructor (por defecto será ' '), y un método inline llamado
	  <code class="function">print()</code> que imprima todos los caracteres
	  del array.
	</p></li><li class="listitem"><p>
	  Coja el ejemplo <code class="filename">NestFriend.cpp</code> del
	  Capítulo 5 y reemplace todos los métodos con inline. No haga
	  métodos inline <span class="emphasis"><em>in situ</em></span>. También cambie
	  las funciones <code class="function">initialize()</code> por
	  constructores.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">StringStack.cpp</code> del Capítulo
	  8 para usar funciones inline.
	</p></li><li class="listitem"><p>
	  Cree un enumerado llamado <code class="type">Hue</code> que contenga
	  <span class="symbol">red</span>, <span class="symbol">blue</span> y
	  <span class="symbol">yellow</span>. Ahora cree una clase llamada
	  <code class="classname">Color</code> que contenga un atributo de tipo
	  <code class="type">Hue</code> y un constructor que dé valor al
	  <code class="type">Hue</code> con su argumento. Añada métodos de acceso al
	  <code class="type">Hue</code> <code class="function">get()</code> y
	  <code class="function">set()</code>. Haga inline todos los métodos.
	</p></li><li class="listitem"><p>
	  Modifique el ejercicio 10 para usar el enfoque
	  «accesor» y «mutador».
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Cpptime.cpp</code> de modo que mida el
	  tiempo desde que comienza el programa hasta que el usuario
	  pulsa la tecla «Intro» o «Retorno».
	</p></li><li class="listitem"><p>
	  Cree una clase con dos métodos inline, el primero que está
	  definido en la clase llama al segundo, sin necesitar una
	  declaración adelantada. Escriba un <code class="function">main()</code>
	  que cree un objeto de esa clase y llame al primer método.
	</p></li><li class="listitem"><p>
	  Cree una clase <code class="classname">A</code> con un constructor
	  por defecto inline que se anuncie a sí mismo. Ahora cree una
	  nueva clase <code class="classname">B</code> y ponga un objeto de
	  <code class="classname">A</code> como miembro de
	  <code class="classname">B</code>, y dele a <code class="classname">B</code>
	  un constructor inline. Cree un array de objetos B y vea qué
	  sucede.
	</p></li><li class="listitem"><p>
	  Cree una gran cantidad de objetos del ejercicio anterior, y
	  use la clase <code class="classname">Time</code> para medir las
	  diferencias entre los contructores inline y los no-inline. (Si
	  tiene un perfilador, intente usarlo también).
	</p></li><li class="listitem"><p>
	  Escriba un programa que tome una cadena por línea de
	  comandos. Escriba un bucle <code class="keyword">for</code> que elimine
	  un carácter de la cadena en cada pasada, y use la macro
	  <code class="function">DEGUB()</code> de este capítulo para imprimir la
	  cadena cada vez.
	</p></li><li class="listitem"><p>
	  Corrija la macro <code class="function">TRACE()</code> tal como se
	  explica en el capítulo, y pruebe que funciona correctamente.
	</p></li><li class="listitem"><p>
	  Modifique la macro <code class="function">FIELD()</code> para que
	  también incluya un índice numérico. Cree una clase cuyos
	  miembros están compuestos de llamadas a la macro
	  <code class="function">FIELD()</code>. Añada un método que le permita
	  buscar en un campo usando el índice. Escriba un
	  <code class="function">main()</code> para probar la clase.
	</p></li><li class="listitem"><p>
	  Modifique la macro <code class="function">FIELD()</code> para que
	  automáticamente genere funciones de acceso para cada campo
	  (<code class="varname">data</code> debería no obstante ser
	  privado). Cree una clase cuyos miembros estén compuestos de
	  llamadas a la macro <code class="function">FIELD()</code>. Escriba un
	  <code class="function">main()</code> para probar la clase.
	</p></li><li class="listitem"><p>
	  Escriba un programa que tome dos argumentos de línea de
	  comandos: el primero es un <code class="type">entero</code> y el segundo es
	  un nombre de fichero. Use <code class="filename">requiere.h</code> para
	  asegurar que tiene el número correcto de argumentos, que el
	  <code class="type">entero</code> está entre 5 y 10, y que el fichero se
	  puede abrir satisfactoriamente.
	</p></li><li class="listitem"><p>
	  Escriba un programa que use la macro
	  <code class="function">IFOPEN()</code> para abrir un fichero como un
	  flujo de entrada. Fíjese en la creación un objeto
	  <code class="classname">ifstream</code> y su alcance.
	</p></li><li class="listitem"><p>
	  (Desafío) Averigüe cómo conseguir que su compilador genere
	  código ensamblador. Cree un fichero que contenga una función
	  muy pequeña y un <code class="function">main()</code>. Genere el código
	  ensamblador cuando la función es inline y cuando no lo es, y
	  demuestre que la versión inline no tiene la sobrecarga por la
	  llamada.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp6364968" href="#idp6364968" class="para">66</a>] </sup><span class="author"><span class="firstname">Andrew</span> <span class="surname">Koenig</span></span>
      entra en más detalles en su libro <em class="citetitle">C Traps &amp;
      Pitfalls</em> (Addison-Wesley, 1989).</p></div><div class="footnote"><p><sup>[<a id="ftn.idp6460824" href="#idp6460824" class="para">67</a>] </sup>Co-autor junto
      a <span class="author"><span class="firstname">Tom</span> <span class="surname">
      Plum</span></span> de <em class="citetitle">C++
      Programming Guidelines</em>, Plum Hall, 1991.</p></div></div></div><div class="chapter" title="10: Control de nombres"><div class="titlepage"><div><div><h2 class="title"><a id="C10"></a>10: Control de nombres</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp6543832">10.1. Los elementos estáticos de C</a></span></dt><dt><span class="sect1"><a href="#idp6619936">10.2. Espacios de nombres</a></span></dt><dt><span class="sect1"><a href="#idp6690960">10.3. Miembros estáticos en C++</a></span></dt><dt><span class="sect1"><a href="#idp6743440">10.4. Dependencia en la inicialización de variables
      estáticas</a></span></dt><dt><span class="sect1"><a href="#idp6811352">10.5. Especificaciones de enlazado alternativo</a></span></dt><dt><span class="sect1"><a href="#idp6821000">10.6. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp6824328">10.7. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      La creación de nombres es una actividad fundamental en la
      programación, y cuando un proyecto empieza a crecer, el número
      de nombres puede llegar a ser inmanejable con facilidad.
    </p></div><p>
    C++ <code class="function">permite</code> gran control sobre la creación y visibilidad de
    nombres, el lugar donde se almacenan y el enlazado de nombres. La
    palabra clave <code class="keyword">static</code> estaba sobrecargada en C incluso
    antes de que la mayoría de la gente supiera que significaba el
    término «sobrecargar». C++ ha añadido además otro
    significado. El concepto subyacente bajo todos los usos de
    <code class="keyword">static</code> parece ser «algo que mantiene su
    posición» (como la electricidad estática), sea manteniendo
    un ubicación física en la memoria o su visibilidad en un fichero.
  </p><p>
    En este capítulo aprenderá cómo <code class="keyword">static</code> controla el
    almacenamiento y la visibilidad, así como una forma mejorada para
    controlar los nombres mediante el uso de la palabra clave de C++
    <code class="keyword">namespace</code>. También descubrirá como utilizar funciones que
    fueron escritas y compiladas en C.
  </p><div class="sect1" title="10.1. Los elementos estáticos de C"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6543832"></a>10.1. Los elementos estáticos de C</h2></div></div></div><p>
      Tanto en C como en C++ la palabra clave <code class="keyword">static</code> tiene dos
      significados básicos que, desafortunadamente, a menudo se confunden:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	  Almacenado una sola vez en una dirección de memoria fija. Es
	  decir, el objeto se crea en una área de datos estática
	  especial en lugar de en la pila cada vez que se llama a una
	  función. Éste es el concepto de almacenamiento estático.
	</p></li><li class="listitem"><p>
	  Local a una unidad de traducción particular (y también local
	  para el ámbito de una clase en C++, tal como se verá
	  después). Aquí, <code class="keyword">static</code> controla la visibilidad de
	  un nombre, de forma que dicho nombre no puede ser visto
	  fuera del la unidad de traducción o la clase. Esto también
	  corresponde al concepto de enlazado, que determina qué
	  nombres verá el enlazador.
	</p></li></ul></div><p>
      En esta sección se van a analizar los significados anteriores de
      <code class="keyword">static</code> tal y como se heredaron de C.
    </p><div class="sect2" title="10.1.1. Variables estáticas dentro de funciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp6548768"></a>10.1.1. Variables estáticas dentro de funciones</h3></div></div></div><p>
	Cuando se crea una variable local dentro de una función, el
	compilador reserva espacio para esa variable cada vez que se
	llama a la función moviendo hacia abajo el puntero de pila tanto
	como sea preciso. Si existe un inicializador para la variable,
	la inicialización se realiza cada vez que se pasa por ese punto
	de la secuencia.
      </p><p>
	No obstante, a veces es deseable retener un valor entre llamadas
	a función. Esto se puede lograr creando una variable global,
	pero entonces esta variable no estará únicamente bajo control de
	la función. C y C++ permiten crear un objeto <code class="keyword">static</code> dentro de
	una función. El almacenamiento de este objeto no se lleva a cabo
	en la pila sino en el área de datos estáticos del
	programa. Dicho objeto sólo se inicializa una vez, la primera
	vez que se llama a la función, y retiene su valor entre
	diferentes invocaciones. Por ejemplo, la siguiente función
	devuelve el siguiente carácter del vector cada vez que se la
	llama:
      </p><div class="example"><a id="idp6551888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:StaticVariablesInfunctions.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">char</span> <span class="hl kwd">oneChar</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> charArray <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
  <span class="hl kwb">static const char</span><span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>charArray<span class="hl opt">) {</span>
    s <span class="hl opt">=</span> charArray<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span>s<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">else</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;un-initialized s&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(*</span>s <span class="hl opt">==</span> <span class="hl str">'\0'</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl opt">*</span>s<span class="hl opt">++;</span>
<span class="hl opt">}</span>

<span class="hl kwb">char</span><span class="hl opt">*</span> a <span class="hl opt">=</span> <span class="hl str">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// oneChar(); // require() fails</span>
  <span class="hl kwd">oneChar</span><span class="hl opt">(</span>a<span class="hl opt">);</span> <span class="hl slc">// Initializes s to a</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>c <span class="hl opt">=</span> <span class="hl kwd">oneChar</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.1. C10/StaticVariablesInfunctions.cpp</strong></p></div><br class="example-break" /><p>
	La variable <code class="type">static char* s</code> mantiene su valor
	entre llamadas a <code class="function">oneChar()</code> porque no está
	almacenada en el segmento de pila de la función, sino que está
	en el área de almacenamiento estático del programa. Cuando se
	llama a <code class="function">oneChar()</code> con <code class="type">char*</code>
	como argumento, <code class="varname">s</code> se asigna a ese argumento
	de forma que se devuelve el primer carácter del array. Cada
	llamada posterior a <code class="function">oneChar()</code>
	<span class="emphasis"><em>sin</em></span> argumentos devuelve el valor por
	defecto cero para <code class="varname">charArray</code>, que indica a
	la función que todavía se están extrayendo caracteres del
	valor previo de <code class="varname">s</code>. La función continuará
	devolviendo caracteres hasta que alcance el valor de final del
	vector, momento en el que para de incrementar el puntero
	evitando que éste sobrepase la última posición del vector.
      </p><p>
	Pero ¿qué pasa si se llama a <code class="function">oneChar()</code>
	sin argumentos y sin haber inicializado previamente el valor
	de <code class="varname">s</code>? En la definición para
	<code class="varname">s</code>, se podía haber utilizado la
	inicialización,
      </p><pre class="programlisting">
<span class="hl kwb">static char</span><span class="hl opt">*</span> s <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
</pre><p>
	pero si no se incluye un valor inicial para una variable
	estática de un tipo definido, el compilador garantiza que la
	variable se inicializará a cero (convertido al tipo adecuado)
	al comenzar el programa. Así pues, en
	<code class="function">oneChar()</code>, la primera vez que se llama a
	la función, <code class="varname">s</code> vale cero.  En este caso, se
	cumplirá la condición <code class="code">if(!s)</code>.
      </p><p>
	La inicialización anterior para <code class="varname">s</code> es muy
	simple, pero la inicialización para objetos estáticos (como la
	de cualquier otro objeto) puede ser una expresión arbitraria,
	que involucre constantes, variables o funciones previamente
	declaradas.
      </p><p>
	Fíjese que la función de arriba es muy vulnerable a problemas de
	concurrencia. Siempre que diseñe funciones que contengan
	variables estáticas, deberá tener en mente este tipo de
	problemas.
      </p><div class="sect3" title="Objetos estáticos dentro de funciones"><div class="titlepage"><div><div><h4 class="title"><a id="idp6562584"></a>Objetos estáticos dentro de funciones</h4></div></div></div><p>
	  Las reglas son las mismas para objetos estáticos de tipos
	  definidos por el usuario, añadiendo el hecho que el objeto
	  requiere ser inicializado. Sin embargo, la asignación del
	  valor cero sólo tiene sentido para tipos predefinidos. Los
	  tipos definidos por el usuario deben ser inicializados
	  llamando a sus respectivos constructores.  Por tanto, si no
	  especifica argumentos en los constructores cuando defina un
	  objeto estático, la clase deberá tener un constructor por
	  defecto. Por ejemplo:
	</p><div class="example"><a id="idp6563888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:StaticObjectsInFunctions.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span> <span class="hl slc">// Default</span>
  <span class="hl opt">~</span><span class="hl kwd">X</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;X::~X()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> X <span class="hl kwd">x1</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl kwb">static</span> X x2<span class="hl opt">;</span> <span class="hl slc">// Default constructor required</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.2. C10/StaticObjectsInFunctions.cpp</strong></p></div><br class="example-break" /><p>
	  Los objetos estáticos de tipo <code class="type">X</code> dentro de
	  <code class="function">f()</code> pueden ser inicializados tanto con
	  la lista de argumentos del constructor como con el
	  constructor por defecto. Esta construcción ocurre únicamente
	  la primera vez que el control llega a la definición.
	</p></div><div class="sect3" title="Destructores de objetos estáticos"><div class="titlepage"><div><div><h4 class="title"><a id="idp6566544"></a>Destructores de objetos estáticos</h4></div></div></div><p>
	  Los destructores para objetos estáticos (es decir, cualquier
	  objeto con almacenamiento estático, no sólo objetos
	  estáticos locales como en el ejemplo anterior) son invocados
	  cuando <code class="function">main()</code> finaliza o cuando la
	  función de librería estándar de C
	  <code class="function">exit()</code> se llama explícitamente. En la
	  mayoría de implementaciones, <code class="function">main()</code>
	  simplemente llama a <code class="function">exit()</code> cuando
	  termina. Esto significa que puede ser peligroso llamar a
	  <code class="function">exit()</code> dentro de un destructor porque
	  podría producirse una invocación recursiva infinita. Los
	  destructores de objetos estáticos no se invocan si se sale
	  del programa utilizando la función de librería estándar de C
	  <code class="function">abort()</code>.
	</p><p>
	  Es posible especificar acciones que se lleven a cabo tras
	  finalizar la ejecución de <code class="function">main()</code> (o
	  llamando a <code class="function">exit()</code>) utilizando la
	  función de librería estándar de C
	  <code class="function">atexit()</code>. En este caso, las funciones
	  registradas en <code class="function">atexit()</code> serán invocadas
	  antes de los destructores para cualquier objeto construido
	  antes de abandonar <code class="function">main()</code> (o de llamar
	  a <code class="function">exit()</code>).
	</p><p>
	  Como la destrucción ordinaria, la destrucción de objetos
	  estáticos se lleva a cabo en orden inverso al de la
	  inicialización. Hay que tener en cuenta que sólo los objetos
	  que han sido construidos serán destruidos.  Afortunadamente,
	  las herramientas de desarrollo de C++ mantienen un registro
	  del orden de inicialización y de los objetos que han sido
	  construidos. Los objetos globales siempre se construyen
	  antes de entrar en <code class="function">main()</code> y se
	  destruyen una vez se sale, pero si existe una función que
	  contiene un objeto local estático a la que nunca se llama,
	  el constructor de dicho objeto nunca fue ejecutado y, por
	  tanto, nunca se invocará su destructor. Por ejemplo:
	</p><div class="example"><a id="idp6575072"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:StaticDestructors.cpp</span>
<span class="hl slc">// Static object destructors</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;statdest.out&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Trace file</span>

<span class="hl kwc">class</span> Obj <span class="hl opt">{</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span> <span class="hl slc">// Identifier</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Obj</span><span class="hl opt">(</span><span class="hl kwb">char</span> cc<span class="hl opt">) :</span> <span class="hl kwd">c</span><span class="hl opt">(</span>cc<span class="hl opt">) {</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Obj::Obj() for &quot;</span> <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Obj</span><span class="hl opt">() {</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Obj::~Obj() for &quot;</span> <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

Obj <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl str">'a'</span><span class="hl opt">);</span> <span class="hl slc">// Global (static storage)</span>
<span class="hl slc">// Constructor &amp; destructor always called</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> Obj <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl str">'b'</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> Obj <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl str">'c'</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside main()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Calls static constructor for b</span>
  <span class="hl slc">// g() not called</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;leaving main()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.3. C10/StaticDestructors.cpp</strong></p></div><br class="example-break" /><p>
	  En <code class="classname">Obj</code>, <code class="code">char c</code> actúa
	  como un identificador de forma que el constructor y el
	  destructor pueden imprimir la información acerca del objeto
	  sobre el que actúan. <code class="code">Obj a</code> es un objeto global
	  y por tanto su constructor siempre se llama antes de que el
	  control pase a <code class="function">main()</code>, pero el
	  constructor para <code class="code">static Obj b</code> dentro de
	  <code class="function">f()</code>, y el de <code class="code">static Obj c</code>
	  dentro de <code class="function">g()</code> sólo serán invocados si
	  se llama a esas funciones.
	</p><p>
	  Para mostrar qué constructores y qué destructores serán
	  llamados, sólo se invoca a <code class="function">f()</code>. La
	  salida del programa será la siguiente:
	</p><pre class="screen">
Obj::Obj() for a
inside main()
Obj::Obj() for b
leaving main()
Obj::~Obj() for b
Obj::~Obj() for a
</pre><p>
	  El constructor para <code class="varname">a</code> se invoca antes de
	  entrar en <code class="function">main()</code> y el constructor de
	  <code class="varname">b</code> se invoca sólo porque existe una
	  llamada a <code class="function">f()</code>. Cuando se sale de
	  <code class="function">main()</code>, se invoca a los destructores de
	  los objetos que han sido construidos en orden inverso al de
	  su construcción. Esto significa que si llama a
	  <code class="function">g()</code>, el orden en el que los
	  destructores para <code class="varname">b</code> y
	  <code class="varname">c</code> son invocados depende de si se llamó
	  primero a <code class="function">f()</code> o a
	  <code class="function">g()</code>.
	</p><p>
	  Nótese que el objeto <code class="varname">out</code> de tipo
	  <code class="varname">ofstream</code>, utilizado en la gestión de
	  ficheros, también es un objeto estático (puesto que está
	  definido fuera de cualquier función, reside en el área de
	  almacenamiento estático). Es importante remarcar que su
	  definición (a diferencia de una declaración tipo
	  <code class="keyword">extern</code>) aparece al principio del fichero, antes de
	  cualquier posible uso de <code class="varname">out</code>.  De lo
	  contrario estaríamos utilizando un objeto antes de que
	  estuviese adecuadamente inicializado.
	</p><p>
	  En C++, el constructor de un objeto estático global se
	  invoca antes de entrar en <code class="function">main()</code>, de
	  forma que ya dispone de una forma simple y portable de
	  ejecutar código antes de entrar en
	  <code class="function">main()</code>, así como ejecutar código
	  después de salir de <code class="function">main()</code>. En C, eso
	  siempre implicaba revolver el código ensamblador de arranque
	  del compilador utilizado.
	</p></div></div><div class="sect2" title="10.1.2. Control del enlazado"><div class="titlepage"><div><div><h3 class="title"><a id="idp6589472"></a>10.1.2. Control del enlazado</h3></div></div></div><p>
	Generalmente, cualquier nombre dentro del ámbito del fichero
	(es decir, no incluido dentro de una clase o de una función)
	es visible para todas las unidades de traducción del
	programa. Esto suele llamarse enlazado
	externo<span class="emphasis"><em></em></span> porque durante el enlazado ese
	nombre es visible desde cualquier sitio, desde el exterior de
	esa unidad de traducción. Las variables globales y las
	funciones ordinarias tienen enlazado externo.
      </p><p>
	Hay veces en las que conviene limitar la visibilidad de un
	nombre. Puede que desee tener una variable con visibilidad a
	nivel de fichero de forma que todas las funciones de ese
	fichero puedan utilizarla, pero quizá no desee que funciones
	externas a ese fichero tengan acceso a esa variable, o que de
	forma inadvertida, cause solapes de nombres con
	identificadores externos a ese fichero.
      </p><p>
	Un objeto o nombre de función, con visibilidad dentro del
	fichero en que se encuentra, que es explícitamente declarado
	como <code class="keyword">static</code> es local a su unidad de traducción (en
	términos de este libro, el fichero <code class="filename">cpp</code>
	donde se lleva a cabo la declaración). Este nombre tiene
	<span class="emphasis"><em>enlace interno</em></span>. Esto significa que puede
	usar el mismo nombre en otras unidades de traducción sin
	confusión entre ellos.
      </p><p>
	Una ventaja del enlace interno es que el nombre puede situarse
	en un fichero de cabecera sin tener que preocuparse de si
	habrá o no un choque de nombres durante el enlazado. Los
	nombres que aparecen usualmente en los archivos de cabecera,
	como definiciones <code class="keyword">const</code> y funciones <code class="keyword">inline</code>,
	tienen por defecto enlazado interno. (De todas formas,
	<code class="keyword">const</code> tiene por defecto enlazado interno sólo en C++;
	en C tiene enlazado externo). Nótese que el enlazado se
	refiere sólo a elementos que tienen direcciones en tiempo de
	enlazado / carga. Por tanto, las declaraciones de clases y de
	variables locales no tienen enlazado.
      </p><div class="sect3" title="Confusión"><div class="titlepage"><div><div><h4 class="title"><a id="idp6596912"></a>Confusión</h4></div></div></div><p>
	  He aquí un ejemplo de cómo los dos significados de
	  <code class="keyword">static</code> pueden confundirse. Todos los objetos
	  globales tienen implícitamente almacenamiento de tipo
	  estático, o sea que si usted dice (en ámbito de fichero)
	</p><pre class="programlisting">
<span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
</pre><p>
	  el almacenamiento para <code class="varname">a</code> se llevará a
	  cabo en el área para datos estáticos del programa y la
	  inicialización para <code class="varname">a</code> sólo se realizará
	  una vez, antes de entrar en
	  <code class="function">main()</code>. Además, la visibilidad de
	  <code class="varname">a</code> es global para todas las unidades de
	  traducción. En términos de visibilidad, lo opuesto a
	  <code class="keyword">static</code> (visible tan sólo en su :unidad de
	  traducción) es <code class="keyword">extern</code> que establece explícitamente
	  que la visibilidad del nombre se extienda a todas las
	  unidades de traducción.  Es decir, la definición de arriba
	  equivale a
	</p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
</pre><p>
	  Pero si utilizase
	</p><pre class="programlisting">
<span class="hl kwb">static int</span> a <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
</pre><p>
	  todo lo que habría hecho es cambiar la visibilidad, de forma
	  que <code class="varname">a</code> tiene enlace interno. El tipo de
	  almacenamiento no se altera, el objeto reside en el área de
	  datos estática aunque en este caso su visibilidad es
	  <code class="keyword">static</code> y en el otro es <code class="keyword">extern</code>.
	</p><p>
	  Cuando pasamos a hablar de variables locales,
	  <code class="keyword">static</code> deja de alterar la visibilidad y pasa a
	  alterar el tipo de almacenamiento.
	</p><p>
	  Si declara lo que parece ser una variable local como
	  <code class="keyword">extern</code>, significa que el almacenamiento existe en
	  alguna otra parte (y por tanto la variable realmente es
	  global a la función). Por ejemplo:
	</p><div class="example"><a id="idp6606648"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:LocalExtern.cpp</span>
<span class="hl slc">//{L} LocalExtern2</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwc">extern</span> <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.4. C10/LocalExtern.cpp</strong></p></div><br class="example-break" /><p>
	  Para nombres de funciones (sin tener en cuenta las funciones
	  miembro), <code class="keyword">static</code> y <code class="keyword">extern</code> sólo pueden
	  alterar la visibilidad, de forma que si escribe
	</p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><p>
	  es lo mismo que la menos adornada declaración
	</p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><p>
	  y si utiliza
	</p><pre class="programlisting">
<span class="hl kwb">static void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><p>
	  significa que <code class="function">f()</code> es visible sólo para
	  la unidad de traducción, (esto suele llamarse <span class="emphasis"><em>estático a
	  fichero</em></span> (<span class="foreignphrase"><em class="foreignphrase">file static</em></span>).
	</p></div></div><div class="sect2" title="10.1.3. Otros especificadores para almacenamiento de clases"><div class="titlepage"><div><div><h3 class="title"><a id="idp6612176"></a>10.1.3. Otros especificadores para almacenamiento de clases</h3></div></div></div><p>
      	El uso de <code class="keyword">static</code> y <code class="keyword">extern</code> está muy
      	extendido. Existen otros dos especificadores de tipo de
      	almacenamiento bastante menos conocidos. El especificador
      	<code class="keyword">auto</code> no se utiliza prácticamente nunca porque le dice
	  al compilador que esa es una variable local. <code class="keyword">auto</code> es
      	la abreviatura de automático«» y se refiere a la
      	forma en la que el compilador reserva espacio automáticamente
      	para la variable. El compilador siempre puede determinar ese
      	hecho por el contexto en que la variable se define por lo que
	<code class="keyword">auto</code> es redundante.
      </p><p>
	El especificador <code class="keyword">register</code> aplicado a una variable
      	indica que es una variable local (<code class="keyword">auto</code>), junto con la
      	pista para el compilador de que esa variable en concreto va a
      	ser ampliamente utilizada por lo que debería ser almacenada en
      	un registro si es posible. Por tanto, es una ayuda para la
      	optimización. Diferentes compiladores responden de diferente
      	manera ante dicha pista; incluso tienen la opción de
      	ignorarla. Si toma la dirección de la variable, el
      	especificador <code class="keyword">register</code> va a ser ignorado casi con
      	total seguridad. Se recomienda evitar el uso de
      	<code class="keyword">register</code> porque, generalmente, el compilador suele
      	realizar las labores de optimización mejor que el usuario.
      </p></div></div><div class="sect1" title="10.2. Espacios de nombres"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6619936"></a>10.2. Espacios de nombres</h2></div></div></div><p>
      Pese a que los nombres pueden estar anidados dentro de clases,
      los nombres de funciones globales, variables globales y clases
      se encuentran incluidos dentro de un único espacio de
      nombres. La palabra reservada <code class="keyword">static</code> le da control
      sobre éste permitiéndole darle tanto a variables como a
      funciones enlazado interno (es decir convirtiéndolas en
      estáticas al fichero).  Pero en un proyecto grande, la falta de
      control sobre el espacio de nombres global puede causar
      problemas. Con el fin de solventar esos problemas para clases,
      los programadores suelen crear nombres largos y complicados que
      tienen baja probabilidad de crear conflictos pero que suponen
      hartarse a teclear para escribirlos. (Para simplificar este
      problema se suele utilizar <code class="keyword">typedef</code>). Pese a que el
      lenguaje la soporta, no es una solución elegante.
    </p><p>
      En lugar de eso puede subdividir el espacio de nombres global en
      varias partes más manejables utilizando la característica
      <code class="keyword">namespace</code> de C++. La palabra reservada
      <code class="keyword">namespace</code>, de forma similar a <code class="keyword">class</code>,
      <code class="keyword">struct</code>, <code class="keyword">enum</code> y <code class="keyword">union</code>, sitúa los
      nombres de sus miembros en un espacio diferente. Mientras que
      las demás palabras reservadas tienen propósitos adicionales, la
      única función de <code class="keyword">namespace</code> es la de crear un nuevo
      espacio de nombres.
    </p><div class="sect2" title="10.2.1. Crear un espacio de nombres"><div class="titlepage"><div><div><h3 class="title"><a id="idp6627120"></a>10.2.1. Crear un espacio de nombres</h3></div></div></div><p>
	La creación de un espacio de nombres es muy similar a la
	creación de una clase:
      </p><div class="example"><a id="idp6627856"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:MyLib.cpp</span>
<span class="hl kwa">namespace</span> MyLib <span class="hl opt">{</span>
  <span class="hl slc">// Declarations</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.5. C10/MyLib.cpp</strong></p></div><br class="example-break" /><p>
	Ese código crea un nuevo espacio de nombres que contiene las
	declaraciones incluidas entre las llaves. De todas formas,
	existen diferencias significativas entre <code class="keyword">class</code>,
	<code class="keyword">struct</code>, <code class="keyword">enum</code> y <code class="keyword">union</code>:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	    Una definición con namespace solamente puede aparecer en
	    un rango global de visibilidad o anidado dentro de otro
	    namespace.
	  </p></li><li class="listitem"><p>
	    No es necesario un punto y coma tras la llave de cierre
      para finalizar la definición de namespace.
    </p></li><li class="listitem"><p>
	  Una definición namespace puede ser "continuada" en
	  múltiples archivos de cabecera utilizando una sintaxis
	  que, para una clase, parecería ser la de una
	  redefinición:
	  </p></li></ul></div><div class="example"><a id="idp6633552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Header1.h</span>
<span class="hl ppc">#ifndef HEADER1_H</span>
<span class="hl ppc">#define HEADER1_H</span>
<span class="hl kwa">namespace</span> MyLib <span class="hl opt">{</span>
  <span class="hl kwc">extern</span> <span class="hl kwb">int</span> x<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span> 

<span class="hl ppc">#endif</span> <span class="hl slc">// HEADER1_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.6. C10/Header1.h</strong></p></div><br class="example-break" /><p>
	El posible crear alias de un <code class="keyword">namespace</code> de forma que
	no hace falta que teclee un enrevesado nombre creado por algún
	frabricante de librerías:
      </p><div class="example"><a id="idp6635528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:BobsSuperDuperLibrary.cpp</span>
<span class="hl kwa">namespace</span> BobsSuperDuperLibrary <span class="hl opt">{</span>
  <span class="hl kwc">class</span> Widget <span class="hl opt">{</span> <span class="hl com">/* ... */</span> <span class="hl opt">};</span>
  <span class="hl kwc">class</span> Poppit <span class="hl opt">{</span> <span class="hl com">/* ... */</span> <span class="hl opt">};</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span>
<span class="hl slc">// Too much to type! I'll alias it:</span>
<span class="hl kwa">namespace</span> Bob <span class="hl opt">=</span> BobsSuperDuperLibrary<span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.7. C10/BobsSuperDuperLibrary.cpp</strong></p></div><br class="example-break" /><p>
	No puede crear una instancia de un <code class="keyword">namespace</code> tal y
	como puede hacer con una clase.
      </p><div class="sect3" title="Espacios de nombres sin nombre"><div class="titlepage"><div><div><h4 class="title"><a id="idp6637448"></a>Espacios de nombres sin nombre</h4></div></div></div><p>
	  Cada unidad de traducción contiene un espacio de nombres sin
	  nombre al que puede referirse escribiendo
	  «<code class="code">namespace</code>» sin ningún
	  identificador.
	</p><p>
	  Los nombres en este espacio están disponibles
	  automáticamente en esa unidad de traducción sin
	  cualificación. Se garantiza que un espacio sin nombre es
	  único para cada unidad de traducción. Si usted asigna
	  nombres locales en un espacio de nombres no necesitará
	  darles enlazado interno con <code class="keyword">static</code>.
	</p><p>
	  En C++ es preferible utilizar espacios de nombres sin nombre
	  que <span class="emphasis"><em>estáticos a fichero</em></span>.
	</p></div><div class="sect3" title="Amigas"><div class="titlepage"><div><div><h4 class="title"><a id="idp6640472"></a>Amigas</h4></div></div></div><p>
	  Es posible añadir una declaración tipo <code class="keyword">friend</code>
	  dentro de un espacio de nombres incluyéndola dentro de una
	  clase:
	</p><div class="example"><a id="idp6641736"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:FriendInjection.cpp</span>
<span class="hl kwa">namespace</span> Me <span class="hl opt">{</span>
  <span class="hl kwc">class</span> Us <span class="hl opt">{</span>
    <span class="hl slc">//...</span>
    <span class="hl kwc">friend</span> <span class="hl kwb">void</span> <span class="hl kwd">you</span><span class="hl opt">();</span>
  <span class="hl opt">};</span>
<span class="hl opt">}</span> 
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.8. C10/FriendInjection.cpp</strong></p></div><br class="example-break" /><p>
	  Ahora la función <code class="function">you()</code> es un miembro
	  del espacio de nombres <code class="varname">Me</code>.
	</p><p>
	  Si introduce una declaración tipo <code class="keyword">friend</code> en una
	  clase dentro del espacio de nombres global, dicha
	  declaración se inyecta globalmente.
	</p></div></div><div class="sect2" title="10.2.2. Cómo usar un espacio de nombres"><div class="titlepage"><div><div><h3 class="title"><a id="idp6644720"></a>10.2.2. Cómo usar un espacio de nombres</h3></div></div></div><p>
	Puede referirse a un nombre dentro de un espacio de nombres de
	tres maneras diferentes: especificando el nombre utilizando el
	operador de resolución de ámbito, con una directiva
	<code class="keyword">using</code> que introduzca todos los nombres en el espacio
	de nombres o mediante una declaración <code class="keyword">using</code> para
	introducir nombres de uno en uno.
      </p><div class="sect3" title="Resolución del ámbito"><div class="titlepage"><div><div><h4 class="title"><a id="idp6646880"></a>Resolución del ámbito</h4></div></div></div><p>
	  Cualquier nombre en un espacio de nombres puede ser
	  explícitamente especificado utilizando el operador de resolución
	  de ámbito de la misma forma que puede referirse a los nombres
	  dentro de una clase:
	</p><div class="example"><a id="idp6647888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:ScopeResolution.cpp</span>
<span class="hl kwa">namespace</span> X <span class="hl opt">{</span>
  <span class="hl kwc">class</span> Y <span class="hl opt">{</span>
    <span class="hl kwb">static int</span> i<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">};</span>
  <span class="hl kwc">class</span> Z<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">func</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> X<span class="hl opt">::</span>Y<span class="hl opt">::</span>i <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span>
<span class="hl kwc">class</span> X<span class="hl opt">::</span>Z <span class="hl opt">{</span>
  <span class="hl kwb">int</span> u<span class="hl opt">,</span> v<span class="hl opt">,</span> w<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
X<span class="hl opt">::</span>Z<span class="hl opt">::</span><span class="hl kwd">Z</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span> u <span class="hl opt">=</span> v <span class="hl opt">=</span> w <span class="hl opt">=</span> i<span class="hl opt">; }</span>
<span class="hl kwb">int</span> X<span class="hl opt">::</span>Z<span class="hl opt">::</span><span class="hl kwd">g</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> u <span class="hl opt">=</span> v <span class="hl opt">=</span> w <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl kwb">void</span> X<span class="hl opt">::</span><span class="hl kwd">func</span><span class="hl opt">() {</span>
  X<span class="hl opt">::</span>Z <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  a<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(){}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.9. C10/ScopeResolution.cpp</strong></p></div><br class="example-break" /><p>
	  Nótese que la definición <code class="code">X::Y::i</code> puede
	  referirse también a un atributo de la clase
	  <code class="classname">Y</code> anidada dentro de la clase
	  <code class="classname">X</code> en lugar del espacio de nombres
	  <code class="varname">X</code>.
	</p></div><div class="sect3" title="La directiva using"><div class="titlepage"><div><div><h4 class="title"><a id="idp6650464"></a>La directiva <code class="keyword">using</code></h4></div></div></div><p>
	  Puesto que teclear toda la especificación para un
	  identificador en un espacio de nombres puede resultar
	  rápidamente tedioso, la palabra clave <code class="keyword">using</code> le
	  permite importar un espacio de nombres entero de una vez.
	  Cuando se utiliza en conjunción con la palabra clave
	  <code class="keyword">namespace</code>, se dice que utilizamos una directiva
	  <code class="keyword">using</code><span class="emphasis"><em></em></span>. Las directivas
	  <code class="keyword">using</code> hacen que los nombres actúen como si
	  perteneciesen al ámbito del espacio de nombres que les
	  incluye más cercano por lo que puede utilizar
	  convenientemente los nombres sin explicitar completamente su
	  especificación. Considere el siguiente espacio de nombres:
	</p><div class="example"><a id="idp6654616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:NamespaceInt.h</span>
<span class="hl ppc">#ifndef NAMESPACEINT_H</span>
<span class="hl ppc">#define NAMESPACEINT_H</span>
<span class="hl kwa">namespace</span> Int <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> sign <span class="hl opt">{</span> positive<span class="hl opt">,</span> negative <span class="hl opt">};</span>
  <span class="hl kwc">class</span> Integer <span class="hl opt">{</span>
    <span class="hl kwb">int</span> i<span class="hl opt">;</span>
    sign s<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">Integer</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">)</span> 
      <span class="hl opt">:</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">),</span>
        <span class="hl kwd">s</span><span class="hl opt">(</span>i <span class="hl opt">&gt;=</span> <span class="hl num">0</span> ? positive <span class="hl opt">:</span> negative<span class="hl opt">)</span>
    <span class="hl opt">{}</span>
    sign <span class="hl kwd">getSign</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> s<span class="hl opt">; }</span>
    <span class="hl kwb">void</span> <span class="hl kwd">setSign</span><span class="hl opt">(</span>sign sgn<span class="hl opt">) {</span> s <span class="hl opt">=</span> sgn<span class="hl opt">; }</span>
    <span class="hl slc">// ...</span>
  <span class="hl opt">};</span>
<span class="hl opt">}</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// NAMESPACEINT_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.10. C10/NamespaceInt.h</strong></p></div><br class="example-break" /><p>
	  Un uso de las directivas <code class="keyword">using</code> es incluir todos los
	  nombres en <code class="varname">Int</code> dentro de otro espacio de
	  nombres, dejando aquellos nombres anidados dentro del
	  espacio de nombres
	</p><div class="example"><a id="idp6657056"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:NamespaceMath.h</span>
<span class="hl ppc">#ifndef NAMESPACEMATH_H</span>
<span class="hl ppc">#define NAMESPACEMATH_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NamespaceInt.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">namespace</span> Math <span class="hl opt">{</span>
  <span class="hl kwa">using namespace</span> Int<span class="hl opt">;</span>
  Integer a<span class="hl opt">,</span> b<span class="hl opt">;</span>
  Integer <span class="hl kwd">divide</span><span class="hl opt">(</span>Integer<span class="hl opt">,</span> Integer<span class="hl opt">);</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// NAMESPACEMATH_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.11. C10/NamespaceMath.h</strong></p></div><br class="example-break" /><p>
	  También puede declarar todos los nombres en
	  <code class="varname">Int</code> dentro de la función pero dejando
	  esos nombres anidados dentro de la función:
	</p><div class="example"><a id="idp6658880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Arithmetic.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NamespaceInt.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">void</span> <span class="hl kwd">arithmetic</span><span class="hl opt">() {</span>
  <span class="hl kwa">using namespace</span> Int<span class="hl opt">;</span>
  Integer x<span class="hl opt">;</span>
  x<span class="hl opt">.</span><span class="hl kwd">setSign</span><span class="hl opt">(</span>positive<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(){}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.12. C10/Arithmetic.cpp</strong></p></div><br class="example-break" /><p>
	  Sin la directiva <code class="keyword">using</code>, todos los nombres en el
	  espacio de nombres requerirían estar completamente
	  explicitados.
	</p><p>
	  Hay un aspecto de la directiva <code class="keyword">using</code> que podría
	  parecer poco intuitivo al principio. La visibilidad de los
	  nombres introducidos con una directiva <code class="keyword">using</code> es el
	  rango en el que se crea la directiva. Pero ¡puede hacer caso
	  omiso de los nombres definidos en la directiva
	  <code class="keyword">using</code> como si estos hubiesen sido declarados
	  globalmente para ese ámbito!
	</p><div class="example"><a id="idp6663168"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:NamespaceOverriding1.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NamespaceMath.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">using namespace</span> Math<span class="hl opt">;</span>
  Integer a<span class="hl opt">;</span> <span class="hl slc">// Hides Math::a;</span>
  a<span class="hl opt">.</span><span class="hl kwd">setSign</span><span class="hl opt">(</span>negative<span class="hl opt">);</span>
  <span class="hl slc">// Now scope resolution is necessary</span>
  <span class="hl slc">// to select Math::a :</span>
  Math<span class="hl opt">::</span>a<span class="hl opt">.</span><span class="hl kwd">setSign</span><span class="hl opt">(</span>positive<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.13. C10/NamespaceOverriding1.cpp</strong></p></div><br class="example-break" /><p>
	  Suponga que tiene un segundo espacio de nombres que contiene
	  algunos nombres en <code class="code">namespace Math</code>:
	</p><div class="example"><a id="idp6664832"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:NamespaceOverriding2.h</span>
<span class="hl ppc">#ifndef NAMESPACEOVERRIDING2_H</span>
<span class="hl ppc">#define NAMESPACEOVERRIDING2_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NamespaceInt.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">namespace</span> Calculation <span class="hl opt">{</span>
  <span class="hl kwa">using namespace</span> Int<span class="hl opt">;</span>
  Integer <span class="hl kwd">divide</span><span class="hl opt">(</span>Integer<span class="hl opt">,</span> Integer<span class="hl opt">);</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// NAMESPACEOVERRIDING2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.14. C10/NamespaceOverriding2.h</strong></p></div><br class="example-break" /><p>
	  Dado que este espacio de nombres también se introduce con
	  una directiva <code class="keyword">using</code>, existe la posibilidad de tener
	  una colisión. De todos modos, la ambigüedad aparece en el
	  momento de utilizar el nombre, no en la directiva
	  <code class="keyword">using</code>:
	</p><div class="example"><a id="idp6667624"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:OverridingAmbiguity.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NamespaceMath.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NamespaceOverriding2.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">void</span> <span class="hl kwd">s</span><span class="hl opt">() {</span>
  <span class="hl kwa">using namespace</span> Math<span class="hl opt">;</span>
  <span class="hl kwa">using namespace</span> Calculation<span class="hl opt">;</span>
  <span class="hl slc">// Everything's ok until:</span>
  <span class="hl slc">//! divide(1, 2); // Ambiguity</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.15. C10/OverridingAmbiguity.cpp</strong></p></div><br class="example-break" /><p>
	  Por tanto, es posible escribir directivas <code class="keyword">using</code>
	  para introducir un número de espacios de nombre con nombres
	  conflictivos sin producir ninguna ambigüedad.
	</p></div><div class="sect3" title="La declaración using"><div class="titlepage"><div><div><h4 class="title"><a id="idp6669800"></a>La declaración <code class="keyword">using</code></h4></div></div></div><p>
	  Puede inyectar nombres de uno en uno en el ámbito actual
	  utilizando una declaración <code class="keyword">using</code>.  A diferencia de
	  la directiva <code class="keyword">using</code>, que trata los nombres como si
	  hubiesen sido declarados globalmente para ese ámbito, una
	  declaración <code class="keyword">using</code> es una declaración dentro del
	  ámbito actual. Eso significa que puede sobrescribir nombres
	  de una directiva <code class="keyword">using</code>:
	</p><div class="example"><a id="idp6673392"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:UsingDeclaration.h</span>
<span class="hl ppc">#ifndef USINGDECLARATION_H</span>
<span class="hl ppc">#define USINGDECLARATION_H</span>
<span class="hl kwa">namespace</span> U <span class="hl opt">{</span>
  <span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
  <span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {}</span>
<span class="hl opt">}</span>
<span class="hl kwa">namespace</span> V <span class="hl opt">{</span>
  <span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
  <span class="hl kwc">inline</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {}</span>
<span class="hl opt">}</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// USINGDECLARATION_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.16. C10/UsingDeclaration.h</strong></p></div><br class="example-break" /><p>
	  La declaración <code class="keyword">using</code> simplemente da el nombre
	  completamente especificado del identificador pero no da
	  información de tipo. Eso significa que si el espacio de
	  nombres contiene un grupo de funciones sobrecargadas con el
	  mismo nombre, la declaración <code class="keyword">using</code> declara todas
	  las funciones pertenecientes al grupo sobrecargado.
	</p><p>
	  Es posible poner una declaración <code class="keyword">using</code> en cualquier
	  sitio donde podría ponerse una declaración normal.  Una
	  declaración <code class="keyword">using</code> funciona de la misma forma que
	  cualquier declaración normal salvo por un aspecto: puesto
	  que no se le da ninguna lista de argumentos, una declaración
	  <code class="keyword">using</code> puede provocar la sobrecarga de una función
	  con los mismos tipos de argumentos (cosa que no está
	  permitida por el procedimiento de sobrecarga normal). De
	  todas formas, esta ambigüedad no se muestra hasta el momento
	  de uso, no apareciendo en el instante de declaración.
	</p><p>
	  Una declaración <code class="keyword">using</code> puede también aparecer dentro de un
	  espacio de nombres y tiene el mismo efecto que en cualquier otro
	  lugar (ese nombre se declara dentro del espacio):
	</p><div class="example"><a id="idp6680176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:UsingDeclaration2.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;UsingDeclaration.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">namespace</span> Q <span class="hl opt">{</span>
  <span class="hl kwa">using</span> U<span class="hl opt">::</span>f<span class="hl opt">;</span>
  <span class="hl kwa">using</span> V<span class="hl opt">::</span>g<span class="hl opt">;</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> <span class="hl kwd">m</span><span class="hl opt">() {</span>
  <span class="hl kwa">using namespace</span> Q<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Calls U::f();</span>
  <span class="hl kwd">g</span><span class="hl opt">();</span> <span class="hl slc">// Calls V::g();</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.17. C10/UsingDeclaration2.cpp</strong></p></div><br class="example-break" /><p>
	  Una declaración <code class="keyword">using</code> es un alias. Le permite declarar la
	  misma función en espacios de nombres diferentes. Si acaba
	  redeclarando la misma función importando diferentes espacios de
	  nombres no hay problema, no habrá ambigüedades o duplicados.
	</p></div></div><div class="sect2" title="10.2.3. El uso de los espacios de nombres"><div class="titlepage"><div><div><h3 class="title"><a id="idp6682624"></a>10.2.3. El uso de los espacios de nombres</h3></div></div></div><p>
	Algunas de las reglas de arriba pueden parecer un poco
	desalentadoras al principio, especialmente si tiene la impresión
	que las utilizará constantemente. No obstante, en general es
	posible salir airoso con el uso de espacios de nombres
	fácilmente siempre y cuando comprenda como funcionan. La clave a
	recordar es que cuando introduce una directiva <code class="keyword">using</code> global (vía
	"using namespace" fuera de cualquier rango) usted ha abierto el
	espacio de nombres para ese archivo. Esto suele estar bien para
	un archivo de implementación (un archivo "cpp") porque la
	directiva <code class="keyword">using</code> sólo afecta hasta el final de la compilación de
	dicho archivo. Es decir, no afecta a ningún otro archivo, de
	forma que puede ajustar el control de los espacios de nombres
	archivo por archivo.  Por ejemplo, si usted descubre un cruce de
	nombres debido a que hay demasiadas directivas <code class="keyword">using</code> en un
	archivo de implementación particular, es una cuestión simple
	cambiar dicho archivo para que use calificaciones explícitas o
	declaraciones <code class="keyword">using</code> para eliminar el cruce sin tener que
	modificar ningún otro archivo de implementación.
      </p><p>
	Los ficheros de cabecera ya son otra historia. Prácticamente
	nunca querrá introducir una directiva <code class="keyword">using</code> global en
	un fichero de cabecera, puesto que eso significaría que
	cualquier otro archivo que incluyese la cabecera también
	tendría el espacio de nombres desplegado (y un fichero de
	cabecera puede incluir otros ficheros de cabecera).
      </p><p>
	Por tanto, en los ficheros de cabecera debería utilizar o bien
	cualificación explícita o bien directivas <code class="keyword">using</code> de
	ámbito y declaraciones <code class="keyword">using</code>. Éste es el método que
	encontrará en este libro. Siguiendo esta metodología no
	«contaminará» el espacio de nombres global, que
	implicaría volver al mundo pre-espacios de nombres de C++.
      </p></div></div><div class="sect1" title="10.3. Miembros estáticos en C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6690960"></a>10.3. Miembros estáticos en C++</h2></div></div></div><p>
      A veces se necesita un único espacio de almacenamiento para
      utilizado por todos los objetos de una clase. En C, podría usar
      una variable global pero eso no es muy seguro. Los datos
      globales pueden ser modificados por todo el mundo y su nombre
      puede chocar con otros idénticos si es un proyecto grande. Sería
      ideal si los datos pudiesen almacenarse como si fuesen
      globales pero ocultos dentro de una clase y claramente asociados
      con esa clase.
    </p><p>
      Esto es posible usando atributos <code class="keyword">static</code>. Existe una
      única porción de espacio para los atributos <code class="keyword">static</code>,
      independientemente del número de objetos de dicha clase que se
      hayan creado. Todos los objetos comparten el mismo espacio de
      almacenamiento <code class="keyword">static</code> para ese atributo, constituyendo
      una forma de «comunicarse» entre ellos. Pero los
      datos <code class="keyword">static</code> pertenecen a la clase; su nombre está
      restringido al interior de la clase y puede ser <code class="keyword">public</code>,
      <code class="keyword">private</code> o <code class="keyword">protected</code>.
    </p><div class="sect2" title="10.3.1. Definición del almacenamiento para atributos estáticos"><div class="titlepage"><div><div><h3 class="title"><a id="idp6696816"></a>10.3.1. Definición del almacenamiento para atributos estáticos</h3></div></div></div><p>
	Puesto que los datos <code class="keyword">static</code> tienen una única porción
	de memoria donde almacenarse, independientemente del número de
	objetos creados, esa porción debe ser definida en un único
	sitio.  El compilador no reservará espacio de almacenamiento
	por usted. El enlazador reportará un error si un atributo
	miembro es declarado pero no definido.
      </p><p>
	La definición debe realizarse fuera de la clase (no se permite
	el uso de la sentencia <code class="keyword">inline</code>), y sólo está permitida
	una definición. Es por ello que habitualmente se incluye en el
	fichero de implementación de la clase. La sintaxis suele traer
	problemas, pero en realidad es bastante lógica. Por ejemplo,
	si crea un atributo estático dentro de una clase de la
	siguiente forma:
      </p><pre class="programlisting">
<span class="hl kwc">class</span> A <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">//...</span>
<span class="hl opt">};</span>
</pre><p>
	Deberá definir el almacenamiento para ese atributo estático en
	el fichero de definición de la siguiente manera:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> A<span class="hl opt">::</span>i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
</pre><p>
	Si quisiera definir una variable global ordinaria, debería
	utilizar
      </p><pre class="programlisting">
<span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
</pre><p>
	pero aquí, el operador de resolución de ámbito y el nombre de
	la clase se utilizan para especificar <code class="code">A::i</code>.
      </p><p>
	Algunas personas tienen problemas con la idea que
	<code class="code">A::i</code> es <code class="keyword">private</code>, y pese a ello parece
	haber algo que lo está manipulando abiertamente. ¿No rompe
	esto el mecanismo de protección? Ésta es una práctica
	completamente segura por dos razones. Primera, el único sitio
	donde esta inicialización es legal es en la
	definición. Efectivamente, si el dato <code class="keyword">static</code> fuese un
	objeto con un constructor, habría llamado al constructor en
	lugar de utilizar el operador <code class="literal">=</code>. Segundo,
	una vez se ha realizado la definición, el usuario final no
	puede hacer una segunda definición puesto que el enlazador
	indicaría un error. Y el creador de la clase está forzado a
	crear la definición o el código no enlazaría en las
	pruebas. Esto asegura que la definición sólo sucede una vez y
	que es el creador de la clase quien la lleva a cabo.
      </p><p>
	La expresión completa de inicialización para un atributo
	estático se realiza en el ámbito de la clase.  Por ejemplo,
      </p><div class="example"><a id="idp6706568"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Statinit.cpp</span>
<span class="hl slc">// Scope of static initializer</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> WithStatic <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> x<span class="hl opt">;</span>
  <span class="hl kwb">static int</span> y<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;WithStatic::x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;WithStatic::y = &quot;</span> <span class="hl opt">&lt;&lt;</span> y <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> WithStatic<span class="hl opt">::</span>x <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwb">int</span> WithStatic<span class="hl opt">::</span>y <span class="hl opt">=</span> x <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl slc">// WithStatic::x NOT ::x</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  WithStatic ws<span class="hl opt">;</span>
  ws<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.18. C10/Statinit.cpp</strong></p></div><br class="example-break" /><p>
	Aquí el calificador <code class="code">WithStatic::</code> extiende el
	ámbito de <code class="classname">WithStatic</code> a la definición
	completa.
      </p><div class="sect3" title="Inicialización de vectores estáticos"><div class="titlepage"><div><div><h4 class="title"><a id="idp6708808"></a>Inicialización de vectores estáticos</h4></div></div></div><p>
	  El <a class="link" href="#C08" title="8: Constantes">capítulo 8</a> introdujo una
	  variable <code class="code">static const</code> que le permite definir un
	  valor constante dentro del cuerpo de una clase. También es
	  posible crear arrays de objetos estáticos, ya sean
	  constantes o no constantes. La sintaxis es razonablemente
	  consistente:
	</p><div class="example"><a id="idp6710544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:StaticArray.cpp</span>
<span class="hl slc">// Initializing static arrays in classes</span>
<span class="hl kwc">class</span> Values <span class="hl opt">{</span>
  <span class="hl slc">// static consts are initialized in-place:</span>
  <span class="hl kwb">static const int</span> scSize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
  <span class="hl kwb">static const long</span> scLong <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
  <span class="hl slc">// Automatic counting works with static arrays.</span>
  <span class="hl slc">// Arrays, Non-integral and non-const statics </span>
  <span class="hl slc">// must be initialized externally:</span>
  <span class="hl kwb">static const int</span> scInts<span class="hl opt">[];</span>
  <span class="hl kwb">static const long</span> scLongs<span class="hl opt">[];</span>
  <span class="hl kwb">static const float</span> scTable<span class="hl opt">[];</span>
  <span class="hl kwb">static const char</span> scLetters<span class="hl opt">[];</span>
  <span class="hl kwb">static int</span> size<span class="hl opt">;</span>
  <span class="hl kwb">static const float</span> scFloat<span class="hl opt">;</span>
  <span class="hl kwb">static float</span> table<span class="hl opt">[];</span>
  <span class="hl kwb">static char</span> letters<span class="hl opt">[];</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> Values<span class="hl opt">::</span>size <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
<span class="hl kwb">const float</span> Values<span class="hl opt">::</span>scFloat <span class="hl opt">=</span> <span class="hl num">1.1</span><span class="hl opt">;</span>

<span class="hl kwb">const int</span> Values<span class="hl opt">::</span>scInts<span class="hl opt">[] = {</span>
  <span class="hl num">99</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">,</span> <span class="hl num">33</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">7</span>
<span class="hl opt">};</span>

<span class="hl kwb">const long</span> Values<span class="hl opt">::</span>scLongs<span class="hl opt">[] = {</span>
  <span class="hl num">99</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">,</span> <span class="hl num">33</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">7</span>
<span class="hl opt">};</span>

<span class="hl kwb">const float</span> Values<span class="hl opt">::</span>scTable<span class="hl opt">[] = {</span>
  <span class="hl num">1.1</span><span class="hl opt">,</span> <span class="hl num">2.2</span><span class="hl opt">,</span> <span class="hl num">3.3</span><span class="hl opt">,</span> <span class="hl num">4.4</span>
<span class="hl opt">};</span>

<span class="hl kwb">const char</span> Values<span class="hl opt">::</span>scLetters<span class="hl opt">[] = {</span>
  <span class="hl str">'a'</span><span class="hl opt">,</span> <span class="hl str">'b'</span><span class="hl opt">,</span> <span class="hl str">'c'</span><span class="hl opt">,</span> <span class="hl str">'d'</span><span class="hl opt">,</span> <span class="hl str">'e'</span><span class="hl opt">,</span>
  <span class="hl str">'f'</span><span class="hl opt">,</span> <span class="hl str">'g'</span><span class="hl opt">,</span> <span class="hl str">'h'</span><span class="hl opt">,</span> <span class="hl str">'i'</span><span class="hl opt">,</span> <span class="hl str">'j'</span>
<span class="hl opt">};</span>

<span class="hl kwb">float</span> Values<span class="hl opt">::</span>table<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">] = {</span>
  <span class="hl num">1.1</span><span class="hl opt">,</span> <span class="hl num">2.2</span><span class="hl opt">,</span> <span class="hl num">3.3</span><span class="hl opt">,</span> <span class="hl num">4.4</span>
<span class="hl opt">};</span>

<span class="hl kwb">char</span> Values<span class="hl opt">::</span>letters<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">] = {</span>
  <span class="hl str">'a'</span><span class="hl opt">,</span> <span class="hl str">'b'</span><span class="hl opt">,</span> <span class="hl str">'c'</span><span class="hl opt">,</span> <span class="hl str">'d'</span><span class="hl opt">,</span> <span class="hl str">'e'</span><span class="hl opt">,</span>
  <span class="hl str">'f'</span><span class="hl opt">,</span> <span class="hl str">'g'</span><span class="hl opt">,</span> <span class="hl str">'h'</span><span class="hl opt">,</span> <span class="hl str">'i'</span><span class="hl opt">,</span> <span class="hl str">'j'</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span> Values v<span class="hl opt">; }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.19. C10/StaticArray.cpp</strong></p></div><br class="example-break" /><p>
	  Usando <code class="code">static const</code> de tipos enteros puede
	  realizar las definiciones dentro de la clase, pero para
	  cualquier otro tipo (incluyendo listas de enteros, incluso
	  si estos son <code class="code">static const</code>) debe realizar una
	  única definición externa para el atributo. Estas
	  definiciones tienen enlazado interno, por lo que pueden
	  incluirse en ficheros de cabecera. La sintaxis para
	  inicializar listas estáticas es la misma que para cualquier
	  agregado, incluyendo el conteo automático<code class="literal">automatic counting</code>.
	</p><p>
	  También puede crear objetos <code class="code">static const</code> de
	  tipos de clase y listas de dichos objetos. De todas formas,
	  no puede inicializarlos utilizando la sintaxis tipo
	  «inline» permitida para <code class="code">static
	  const</code> de tipos enteros básicos:
	</p><div class="example"><a id="idp6716568"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:StaticObjectArrays.cpp</span>
<span class="hl slc">// Static arrays of class objects</span>
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Stat <span class="hl opt">{</span>
  <span class="hl slc">// This doesn't work, although </span>
  <span class="hl slc">// you might want it to:</span>
<span class="hl slc">//!  static const X x(100);</span>
  <span class="hl slc">// Both const and non-const static class </span>
  <span class="hl slc">// objects must be initialized externally:</span>
  <span class="hl kwb">static</span> X x2<span class="hl opt">;</span>
  <span class="hl kwb">static</span> X xTable2<span class="hl opt">[];</span>
  <span class="hl kwb">static const</span> X x3<span class="hl opt">;</span>
  <span class="hl kwb">static const</span> X xTable3<span class="hl opt">[];</span>
<span class="hl opt">};</span>

X Stat<span class="hl opt">::</span><span class="hl kwd">x2</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>

X Stat<span class="hl opt">::</span>xTable2<span class="hl opt">[] = {</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">),</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">)</span>
<span class="hl opt">};</span>

<span class="hl kwb">const</span> X Stat<span class="hl opt">::</span><span class="hl kwd">x3</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>

<span class="hl kwb">const</span> X Stat<span class="hl opt">::</span>xTable3<span class="hl opt">[] = {</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">),</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">)</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span> Stat v<span class="hl opt">; }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.20. C10/StaticObjectArrays.cpp</strong></p></div><br class="example-break" /><p>
	  La inicialización de listas estáticas de objetos tanto
	  constantes como no constantes debe realizarse de la misma
	  manera, siguiendo la típica sintaxis de definición estática.
	</p></div></div><div class="sect2" title="10.3.2. Clases anidadas y locales"><div class="titlepage"><div><div><h3 class="title"><a id="idp6718760"></a>10.3.2. Clases anidadas y locales</h3></div></div></div><p>
	Puede colocar fácilmente atributos estáticos en clases que
	están anidadas dentro de otras clases. La definición de tales
	miembros es intuitiva y obvia (tan sólo utiliza otro nivel de
	resolución de ámbito). No obstante, no puede tener atributos
	estáticos dentro de clases locales (una clase local es una
	clase definida dentro de una función). Por tanto,
      </p><div class="example"><a id="idp6719944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Local.cpp</span>
<span class="hl slc">// Static members &amp; local classes</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Nested class CAN have static data members:</span>
<span class="hl kwc">class</span> Outer <span class="hl opt">{</span>
  <span class="hl kwc">class</span> Inner <span class="hl opt">{</span>
    <span class="hl kwb">static int</span> i<span class="hl opt">;</span> <span class="hl slc">// OK</span>
  <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> Outer<span class="hl opt">::</span>Inner<span class="hl opt">::</span>i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>

<span class="hl slc">// Local class cannot have static data members:</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  <span class="hl kwc">class</span> Local <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
<span class="hl slc">//! static int i;  // Error</span>
    <span class="hl slc">// (How would you define i?)</span>
  <span class="hl opt">}</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span> Outer x<span class="hl opt">;</span> <span class="hl kwd">f</span><span class="hl opt">(); }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.21. C10/Local.cpp</strong></p></div><br class="example-break" /><p>
	Ya puede ver el problema con atributos estáticos en clases
	locales: ¿Cómo describirá el dato miembro en el ámbito del
	fichero para poder definirlo? En la práctica, el uso de clases
	locales es muy poco común.
      </p></div><div class="sect2" title="10.3.3. Métodos estáticos"><div class="titlepage"><div><div><h3 class="title"><a id="idp6722464"></a>10.3.3. Métodos estáticos</h3></div></div></div><p>
	También puede crear métodos estáticos que, como los atributos
	estáticos, trabajan para la clase como un todo en lugar de
	para un objeto particular de la clase. En lugar de hacer una
	función global que viva en y «contamine» el
	espacio de nombres global o local, puede incluir el método
	dentro de la clase. Cuando crea un método estático, está
	expresando una asociación con una clase particular.
      </p><p>
	Puede llamar a un miembro estáticos de la forma habitual, con
	el punto o la flecha, en asociación con un objeto. De todas
	formas, es más típico llamar a los métodos estáticos en si
	mismos, sin especificar ningún objeto, utilizando el operador
	de resolución de ámbito, como en el siguiente ejemplo:
      </p><div class="example"><a id="idp6724904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:SimpleStaticMemberFunction.cpp </span>
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">f</span><span class="hl opt">(){};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.22. C10/SimpleStaticMemberFunction.cpp</strong></p></div><br class="example-break" /><p>
	Cuando vea métodos estáticos en una clase, recuerde que el
	diseñador pretendía que esa función estuviese conceptualmente
	asociada a la clase como un todo.
      </p><p>
	Un método estático no puede acceder a los atributos
	ordinarios, sólo a los estáticos. Sólo puede llamar a otros
	métodos estáticos. Normalmente, la dirección del objeto actual
	(<code class="keyword">this</code>) se pasa de forma encubierta cuando se llama a
	cualquier método, pero un miembro <code class="keyword">static</code> no tiene
	<code class="keyword">this</code>, que es la razón por la cual no puede acceder a
	los miembros ordinarios.  Por tanto, se obtiene el ligero
	incremento de velocidad proporcionado por una función global
	debido a que un método estático no implica la carga extra de
	tener que pasar <code class="keyword">this</code>. Al mismo tiempo, obtiene los
	beneficios de tener la función dentro de la clase.
      </p><p>
	Para atributos, <code class="keyword">static</code> indica que sólo existe un
	espacio de memoria por atributo para todos los objetos de la
	clase. Esto establece que el uso de <code class="keyword">static</code> para
	definir objetos dentro de una función significa que sólo se
	utiliza una copia de una variable local para todas las
	llamadas a esa función.
      </p><p>
	Aquí aparece un ejemplo mostrando atributos y métodos
	estáticos utilizados conjuntamente:
      </p><div class="example"><a id="idp6732032"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:StaticMemberFunctions.cpp</span>
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">static int</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {</span>
     <span class="hl slc">// Non-static member function can access</span>
     <span class="hl slc">// static member function or data:</span>
    j <span class="hl opt">=</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">val</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">incr</span><span class="hl opt">() {</span>
    <span class="hl slc">//! i++; // Error: static member function</span>
    <span class="hl slc">// cannot access non-static member data</span>
    <span class="hl kwa">return</span> <span class="hl opt">++</span>j<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
    <span class="hl slc">//! val(); // Error: static member function</span>
    <span class="hl slc">// cannot access non-static member function</span>
    <span class="hl kwa">return</span> <span class="hl kwd">incr</span><span class="hl opt">();</span> <span class="hl slc">// OK -- calls static</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> X<span class="hl opt">::</span>j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X x<span class="hl opt">;</span>
  X<span class="hl opt">*</span> xp <span class="hl opt">= &amp;</span>x<span class="hl opt">;</span>
  x<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  xp<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  X<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Only works with static members</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.23. C10/StaticMemberFunctions.cpp</strong></p></div><br class="example-break" /><p>
	Puesto que no tienen el puntero <code class="keyword">this</code>, los métodos
	estáticos no pueden acceder a atributos no estáticos ni llamar
	a métodos no estáticos.
      </p><p>
	Note el lector que en <code class="function">main()</code> un miembro
	estático puede seleccionarse utilizando la habitual sintaxis
	de punto o flecha, asociando la función con el objeto, pero
	también sin objeto (ya que un miembro estático está asociado
	con una clase, no con un objeto particular), utilizando el
	nombre de la clase y el operador de resolución de ámbito.
      </p><p>
	He aquí una interesante característica: Debido a la forma en
	la que se inicializan los objetos miembro estáticos, es
	posible poner un atributos estático de la misma clase dento de
	dicha clase. He aquí un ejemplo que tan solo permite la
	existencia de un único objeto de tipo
	<code class="classname">Egg</code> definiendo el constructor
	privado. Puede acceder a este objeto pero no puede crear
	ningún otro objeto tipo <code class="classname">Egg</code>:
      </p><div class="example"><a id="idp6737672"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Singleton.cpp</span>
<span class="hl slc">// Static member of same type, ensures that</span>
<span class="hl slc">// only one object of this type exists.</span>
<span class="hl slc">// Also referred to as the &quot;singleton&quot; pattern.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Egg <span class="hl opt">{</span>
  <span class="hl kwb">static</span> Egg e<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwd">Egg</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl kwd">Egg</span><span class="hl opt">(</span><span class="hl kwb">const</span> Egg<span class="hl opt">&amp;);</span> <span class="hl slc">// Prevent copy-construction</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> Egg<span class="hl opt">*</span> <span class="hl kwd">instance</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl opt">&amp;</span>e<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">val</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
<span class="hl opt">};</span>

Egg Egg<span class="hl opt">::</span><span class="hl kwd">e</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
<span class="hl slc">//!  Egg x(1); // Error -- can't create an Egg</span>
  <span class="hl slc">// You can access the single instance:</span>
  cout <span class="hl opt">&lt;&lt;</span> Egg<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">()-&gt;</span><span class="hl kwd">val</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.24. C10/Singleton.cpp</strong></p></div><br class="example-break" /><p>
	La inicialización de <code class="varname">e</code> ocurre una vez se
	completa la declaración de la clase, por lo que el compilador
	tiene toda la información que necesita para reservar espacio y
	llamar al constructor.
      </p><p>
	Para impedir completamente la creación de cualquier otro
	objeto, se ha añadido algo más: un segundo constructor privado
	llamado <span class="emphasis"><em>constructor de copia</em></span>. Llegados a
	este punto del libro, usted no puede saber porqué esto es
	necesario puesto que el constructor de copia no se estudiará
	hasta el <a class="link" href="#C11" title="11: Las referencias y el constructor de copia">siguiente capítulo</a>. De
	todas formas, como un breve adelanto, si se propusiese retirar
	el constructor de copia definido en el ejemplo anterior, sería
	posible crear objetos Egg de la siguiente forma:
      </p><pre class="programlisting">
Egg e <span class="hl opt">= *</span>Egg<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">();</span>
Egg <span class="hl kwd">e2</span><span class="hl opt">(*</span>Egg<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">());</span>
</pre><p>
	Ambos utilizan el constructor de copia, por lo que para evitar
	esta posibilidad, se declara el constructor de copia como
	privado (no se requiere definición porque nunca va a ser
	llamado). Buena parte del siguiente capítulo es una discusión
	sobre el constructor de copia por lo que esto quedará más
	claro entonces.
      </p></div></div><div class="sect1" title="10.4. Dependencia en la inicialización de variables estáticas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6743440"></a>10.4. Dependencia en la inicialización de variables
      estáticas</h2></div></div></div><p>
      Dentro de una unidad de traducción específica, está garantizado
      que el orden de inicialización de los objetos estáticos será el
      mismo que el de aparición de sus definiciones en la unidad de
      traducción.
    </p><p>
      No obstante, no hay garantías sobre el orden en que se
      inicializan los objetos estáticos entre diferentes unidades de
      traducción, y el lenguaje no proporciona ninguna forma de
      averiguarlo. Esto puede producir problemas significativos. Como
      ejemplo de desastre posible (que provocará el cuelgue de
      sistemas operativos primitivos o la necesidad de matar el
      proceso en otros más sofisticados), si un archivo contiene:
    </p><div class="example"><a id="idp6745440"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Out.cpp {O}</span>
<span class="hl slc">// First file</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
std<span class="hl opt">::</span>ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;out.txt&quot;</span><span class="hl opt">);</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.25. C10/Out.cpp</strong></p></div><br class="example-break" /><p>
      y otro archivo utiliza el objeto <code class="varname">out</code> en uno
      de sus inicializadores
    </p><div class="example"><a id="idp6746880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Oof.cpp</span>
<span class="hl slc">// Second file</span>
<span class="hl slc">//{L} Out</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwc">extern</span> std<span class="hl opt">::</span>ofstream out<span class="hl opt">;</span>
<span class="hl kwc">class</span> Oof <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Oof</span><span class="hl opt">() {</span> out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ouch&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">}</span> oof<span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.26. C10/Oof.cpp</strong></p></div><br class="example-break" /><p>
      el programa puede funcionar, o puede que no. Si el entorno de
      programación construye el programa de forma que el primer
      archivo sea inicializado después del segundo, no habrá
      problemas. Pero si el segundo archivo se inicializa antes que el
      primero, el constructor para <code class="classname">Oof</code> se
      sustenta en la existencia de <code class="varname">out</code>, que todavía
      no ha sido construido, lo que causa el caos.
    </p><p>
      Este problema sólo ocurre con inicializadores de objetos
      estáticos que dependen el uno del otro. Los estáticos dentro de
      cada unidad de traducción son inicializados antes de la primera
      invocación a cualquier función de esa unidad, aunque puede que
      después de <code class="function">main()</code>. No puede estar seguro
      del orden de inicialización de objetos estáticos si están en
      archivos diferentes.
    </p><p>
      Un ejemplo sutil puede encontrarse en ARM.<sup>[<a id="idp6751120" href="#ftn.idp6751120" class="footnote">68</a>]</sup> en un archivo que
      aparece en el rango global:
    </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwb">int</span> x <span class="hl opt">=</span> y <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
</pre><p>
      y en un segundo archivo también en el ámbitoglobal:
    </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwb">int</span> y <span class="hl opt">=</span> x <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
</pre><p>
      Para todos los objetos estáticos, el mecanismo de carga-enlazado
      garantiza una inicialización estática a cero antes de la
      inicialización dinámica especificada por el programador. En el
      ejemplo anterior, la inicialización a cero de la zona de memoria
      ocupada por el objeto <code class="code">fstream out</code> no tiene especial
      relevancia, por lo que realmente no está definido hasta que se
      llama al constructor. Pese a ello, en el caso de los tipos
      predefinidos, la inicialización a cero sí tiene importancia, y
      si los archivos son inicializados en el orden mostrado arriba, y
      empieza estáticamente inicializada a cero, por lo que
      <code class="varname">x</code> se convierte en uno, e <code class="varname">y</code>
      es dinámicamente inicializada a dos. Pero si los archivos fuesen
      inicializados en orden opuesto, <code class="varname">x</code> sería
      estáticamente inicializada a cero, <code class="varname">y</code>
      dinámicamente inicializada a uno y después, <code class="varname">x</code>
      pasaría a valer dos.
    </p><p>
      Los programadores deben estar al tanto de esto porque puede darse
      el caso de crear un programa con dependencias de inicialización
      estáticas que funcionen en una plataforma determinada y, de golpe
      y misteriosamente, compilarlo en otro entorno y que deje de
      funcionar.
    </p><div class="sect2" title="10.4.1. Qué hacer"><div class="titlepage"><div><div><h3 class="title"><a id="idp6756840"></a>10.4.1. Qué hacer</h3></div></div></div><p>
	Existen tres aproximaciones para tratar con este problema:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    No hacerlo. Evitar las dependencias de inicialización
	    estática es la mejor solución.
	  </p></li><li class="listitem"><p>
	    Si debe hacerlo, coloque las definiciones de objetos
	    estáticos críticos en un único fichero, de forma que pueda
	    controlar, de forma portable, su inicialización
	    colocándolos en el orden correcto.
	  </p></li><li class="listitem"><p>
	    Si está convencido que es inevitable dispersar objetos
	    estáticos entre unidades de traducción diferentes (como
	    en el caso de una librería, donde no puede controlar el
	    programa que la usa), hay dos técnicas de programación
	    para solventar el problema.
	  </p></li></ol></div><div class="sect3" title="Técnica uno"><div class="titlepage"><div><div><h4 class="title"><a id="idp6760320"></a>Técnica uno</h4></div></div></div><p>
	  El pionero de esta técnica fue <span class="author"><span class="firstname">Jerry</span> <span class="surname">Schwarz</span></span> mientras creaba la
	    librería <code class="filename">iostream</code> (puesto que las
	    definiciones para <code class="varname">cin</code>,
	    <code class="varname">cout</code> y <code class="varname">cerr</code> son
	    <code class="keyword">static</code> y residen en archivos
	    diferentes). Realmente es inferior a la segunda técnica
	    pero ha pululado durante mucho tiempo por lo que puede
	    encontrarse con código que la utilice; así pues, es
	    importante que entienda como funciona.
      </p><p>
	Esta técnica requiere una clase adicional en su archivo de
	cabecera. Esta clase es la responsable de la inicialización
	dinámica de sus objetos estáticos de librería. He aquí un
	ejemplo simple:
      </p><div class="example"><a id="idp6764224"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Initializer.h</span>
<span class="hl slc">// Static initialization technique</span>
<span class="hl ppc">#ifndef INITIALIZER_H</span>
<span class="hl ppc">#define INITIALIZER_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> x<span class="hl opt">;</span> <span class="hl slc">// Declarations, not definitions</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> y<span class="hl opt">;</span>

<span class="hl kwc">class</span> Initializer <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> initCount<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Initializer</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Initializer()&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl slc">// Initialize first time only</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>initCount<span class="hl opt">++ ==</span> <span class="hl num">0</span><span class="hl opt">) {</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;performing initialization&quot;</span>
                <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
      x <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
      y <span class="hl opt">=</span> <span class="hl num">200</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Initializer</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Initializer()&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl slc">// Clean up last time only</span>
    <span class="hl kwa">if</span><span class="hl opt">(--</span>initCount <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">) {</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;performing cleanup&quot;</span> 
                <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
      <span class="hl slc">// Any necessary cleanup here</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// The following creates one object in each</span>
<span class="hl slc">// file where Initializer.h is included, but that</span>
<span class="hl slc">// object is only visible within that file:</span>
<span class="hl kwb">static</span> Initializer init<span class="hl opt">;</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// INITIALIZER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.27. C10/Initializer.h</strong></p></div><br class="example-break" /><p>
	  Las declaraciones para <code class="varname">x</code> e
	<code class="varname">y</code> anuncian tan sólo que esos objetos
	existen, pero no reservan espacio para los objetos. No
	obstante, la definición para el <code class="code">Initializer init</code>
	reserva espacio para ese objeto en cada archivo en que se
	incluya el archivo de cabecera. Pero como el nombre es
	<code class="keyword">static</code> (en esta ocasión controlando la visibilidad,
	no la forma en la que se almacena; el almacenamiento se
	produce a nivel de archivo por defecto), sólo es visible en
	esa unidad de traducción, por lo que el enlazador no se
	quejará por múltiples errores de definición.
      </p><p>
	  He aquí el archivo con las definiciones para
	  <code class="varname">x</code>, <code class="varname">y</code> e
	  <code class="varname">initCount</code>:
      </p><div class="example"><a id="idp6770424"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:InitializerDefs.cpp {O}</span>
<span class="hl slc">// Definitions for Initializer.h</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Initializer.h&quot;</span><span class="hl ppc"></span>
<span class="hl slc">// Static initialization will force</span>
<span class="hl slc">// all these values to zero:</span>
<span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwb">int</span> Initializer<span class="hl opt">::</span>initCount<span class="hl opt">;</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.28. C10/InitializerDefs.cpp</strong></p></div><br class="example-break" /><p>
	  (Por supuesto, una instancia <span class="emphasis"><em>estática de
	    fichero</em></span> de <code class="varname">init</code> también se
	    incluye en este archivo cuando se incluye el archivo de
	    cabecera. Suponga que otros dos archivos se crean por
	    la librería del usuario:
      </p><div class="example"><a id="idp6772608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Initializer.cpp {O}</span>
<span class="hl slc">// Static initialization</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Initializer.h&quot;</span><span class="hl ppc"></span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.29. C10/Initializer.cpp</strong></p></div><br class="example-break" /><p>
	y
      </p><div class="example"><a id="idp6773792"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Initializer2.cpp</span>
<span class="hl slc">//{L} InitializerDefs Initializer</span>
<span class="hl slc">// Static initialization</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Initializer.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside main()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;leaving main()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.30. C10/Initializer2.cpp</strong></p></div><br class="example-break" /><p>
	Ahora no importa en qué unidad de traducción se inicializa
	primero. La primera vez que una unidad de traducción que
	contenga <code class="filename">Initializer.h</code> se inicialice,
	<code class="varname">initCount</code> será cero por lo que la
	inicialización será llevada a cabo. (Esto depende en gran
	medida en el hecho que la zona de almacenamiento estático está
	a cero antes de que cualquier inicialización dinámica se lleve
	a cabo). Para el resto de unidades de traducción,
	<code class="varname">initCount</code> no será cero y se eludirá la
	inicialización. La limpieza ocurre en el orden inverso, y
	<code class="function">~Initializer()</code> asegura que sólo ocurrirá
	una vez.
      </p><p>
	Este ejemplo utiliza tipos del lenguaje como objetos estáticos
	globales. Esta técnica también funciona con clases, pero esos
	objetos deben ser inicializados dinámicamente por la clase
	<code class="classname">Initializer</code>.  Una forma de hacer esto
	es creando clases sin constructores ni destructores, pero sí
	con métodos de inicialización y limpieza con nombres
	diferentes. Una aproximación más común, de todas formas, es
	tener punteros a objetos y crearlos utilizando <code class="keyword">new</code>
	  dentro de <code class="function">Initializer()</code>.
      </p></div><div class="sect3" title="Técnica dos"><div class="titlepage"><div><div><h4 class="title"><a id="idp6779712"></a>Técnica dos</h4></div></div></div><p>
	Bastante después de la aparición de la técnica uno, alguien
	(no sé quien) llegó con la técnica explicada en esta sección,
	que es mucho más simple y limpia que la anterior. El hecho de
	que tardase tanto en descubrirse es un tributo a la
	complejidad de C++.
      </p><p>
	Esta técnica se sustenta en el hecho de que los objetos
	estáticos dentro de funciones (sólo) se inicializan la primera
	vez que se llama a la función. Tenga presente que el problema
	que estamos intentando resolver aquí no es cuando se
	inicializan los objetos estáticos (que se puede controlar
	separadamente) sino más bien asegurarnos de que la
	inicialización ocurre en el orden adecuado.
      </p><p>
	Esta técnica es muy limpia y astuta. Para cualquier
	dependencia de inicialización, se coloca un objeto estático
	dentro de una función que devuelve una referencia a ese
	objeto. De esta forma, la única manera de acceder al objeto
	estático es llamando a la función, y si ese objeto necesita
	acceder a otros objetos estáticos de los que depende, debe
	llamar a sus funciones. Y la primera vez que se llama a una
	función, se fuerza a llevar a cabo la inicialización. Está
	garantizado que el orden de la inicialización será correcto
	debido al diseño del código, no al orden que arbitrariamente
	decide el enlazador.
      </p><p>
	  Para mostrar un ejemplo, aquí tenemos dos clases que
	  dependen la una de la otra. La primera contiene un
	  <code class="type">bool</code> que sólo se inicializa por el constructor,
	  por lo que se puede decir si se ha llamado el constructor
	  por una instancia estática de la clase (el área de
	  almacenamiento estático se inicializa a cero al inicio del
	  programa, lo que produce un valor <code class="keyword">false</code> para el
	  <code class="type">bool</code> si el constructor no ha sido llamado).
      </p><div class="example"><a id="idp6785104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Dependency1.h</span>
<span class="hl ppc">#ifndef DEPENDENCY1_H</span>
<span class="hl ppc">#define DEPENDENCY1_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwc">class</span> Dependency1 <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> init<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Dependency1</span><span class="hl opt">() :</span> <span class="hl kwd">init</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dependency1 construction&quot;</span> 
              <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dependency1 init: &quot;</span> 
              <span class="hl opt">&lt;&lt;</span> init <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DEPENDENCY1_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.31. C10/Dependency1.h</strong></p></div><br class="example-break" /><p>
	El constructor también indica cuando ha sido llamado, y es
	posible el estado del objeto para averiguar si ha sido
	inicializado.
      </p><p>
	La segunda clase es inicializada por un objeto de la primera
	clase, que es lo que causa la dependencia:
      </p><div class="example"><a id="idp6787304"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Dependency2.h</span>
<span class="hl ppc">#ifndef DEPENDENCY2_H</span>
<span class="hl ppc">#define DEPENDENCY2_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency1.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Dependency2 <span class="hl opt">{</span>
  Dependency1 d1<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Dependency2</span><span class="hl opt">(</span><span class="hl kwb">const</span> Dependency1<span class="hl opt">&amp;</span> dep1<span class="hl opt">):</span> <span class="hl kwd">d1</span><span class="hl opt">(</span>dep1<span class="hl opt">){</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dependency2 construction &quot;</span><span class="hl opt">;</span>
    <span class="hl kwd">print</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> d1<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DEPENDENCY2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.32. C10/Dependency2.h</strong></p></div><br class="example-break" /><p>
	El constructor se anuncia a si mismo y imprime el estado del
	  objeto <code class="varname">d1</code> por lo que puede ver si éste se
	  ha inicializado cuando se llama al constructor.
      </p><p>
	Para demostrar lo que puede ir mal, el siguiente archivo
	primero pone las definiciones de los objetos estáticos en el
	orden incorrecto, tal y como sucedería si el enlazador
	inicializase el objeto <code class="classname">Dependency2</code>
	antes del <code class="classname">Dependency1</code>. Después se
	invierte el orden para mostrar que funciona correctamente si
	el orden resulta ser el correcto. Finalmente, se muestra la
	técnica dos.
      </p><p>
	  Para proporcionar una salida más legible, se ha creado la
	  función <code class="function">separator()</code>. El truco está en
	  que usted no puede llamar a la función globalmente a menos
	  que la función sea utilizada para llevar a cabo la
	  inicialización de la variable, por lo que
	  <code class="function">separator()</code> devuelve un valor absurdo
	  que es utilizado para inicializar un par de variables
	  globales.
      </p><div class="example"><a id="idp6792112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Technique2.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency2.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Returns a value so it can be called as</span>
<span class="hl slc">// a global initializer:</span>
<span class="hl kwb">int</span> <span class="hl kwd">separator</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;---------------------&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// Simulate the dependency problem:</span>
<span class="hl kwc">extern</span> Dependency1 dep1<span class="hl opt">;</span>
Dependency2 <span class="hl kwd">dep2</span><span class="hl opt">(</span>dep1<span class="hl opt">);</span>
Dependency1 dep1<span class="hl opt">;</span>
<span class="hl kwb">int</span> x1 <span class="hl opt">=</span> <span class="hl kwd">separator</span><span class="hl opt">();</span>

<span class="hl slc">// But if it happens in this order it works OK:</span>
Dependency1 dep1b<span class="hl opt">;</span>
Dependency2 <span class="hl kwd">dep2b</span><span class="hl opt">(</span>dep1b<span class="hl opt">);</span>
<span class="hl kwb">int</span> x2 <span class="hl opt">=</span> <span class="hl kwd">separator</span><span class="hl opt">();</span>

<span class="hl slc">// Wrapping static objects in functions succeeds</span>
Dependency1<span class="hl opt">&amp;</span> <span class="hl kwd">d1</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> Dependency1 dep1<span class="hl opt">;</span>
  <span class="hl kwa">return</span> dep1<span class="hl opt">;</span>
<span class="hl opt">}</span>

Dependency2<span class="hl opt">&amp;</span> <span class="hl kwd">d2</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> Dependency2 <span class="hl kwd">dep2</span><span class="hl opt">(</span><span class="hl kwd">d1</span><span class="hl opt">());</span>
  <span class="hl kwa">return</span> dep2<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Dependency2<span class="hl opt">&amp;</span> dep2 <span class="hl opt">=</span> <span class="hl kwd">d2</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.33. C10/Technique2.cpp</strong></p></div><br class="example-break" /><p>
	  Las funciones <code class="function">d1()</code> y
	<code class="function">d2()</code> contienen instancias estáticas de
	los objetos <code class="classname">Dependency1</code> y
	<code class="classname">Dependency2</code>.  Ahora, la única forma de
	acceder a los objetos estáticos es llamando a las funciones y
	eso fuerza la inicialización estática en la primera llamada a
	la función. Esto significa que se garantiza la inicialización
	correcta, cosa que verá cuando lance el programa y observe la
	salida.
      </p><p>
	He aquí como debe organizar el código para usar esta
	técnica. Ordinariamente, los objetos estáticos deben ser
	definidos en archivos diferentes (puesto que se ha visto
	forzado a ello por alguna razón; recuerde que definir objetos
	estáticos en archivos diferentes es lo que causa el problema),
	por lo que definirá las funciones envoltorio <code class="literal">wrapping functions</code>) en archivos
	diferentes. Pero éstas necesitan estar declaradas en los
	archivos de cabecera:
      </p><div class="example"><a id="idp6797928"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Dependency1StatFun.h</span>
<span class="hl ppc">#ifndef DEPENDENCY1STATFUN_H</span>
<span class="hl ppc">#define DEPENDENCY1STATFUN_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency1.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwc">extern</span> Dependency1<span class="hl opt">&amp;</span> <span class="hl kwd">d1</span><span class="hl opt">();</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DEPENDENCY1STATFUN_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.34. C10/Dependency1StatFun.h</strong></p></div><br class="example-break" /><p>
	  En realidad, el «extern» es redundante para la
	declaración de la función. Éste es el segundo archivo de
	cabecera:
      </p><div class="example"><a id="idp6799736"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Dependency2StatFun.h</span>
<span class="hl ppc">#ifndef DEPENDENCY2STATFUN_H</span>
<span class="hl ppc">#define DEPENDENCY2STATFUN_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency2.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwc">extern</span> Dependency2<span class="hl opt">&amp;</span> <span class="hl kwd">d2</span><span class="hl opt">();</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DEPENDENCY2STATFUN_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.35. C10/Dependency2StatFun.h</strong></p></div><br class="example-break" /><p>
	Ahora, en los archivos de implementación donde previamente
	habría situado las definiciones de los objetos estáticos, situará
	las definiciones de las funciones envoltorio:
      </p><div class="example"><a id="idp6801472"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Dependency1StatFun.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency1StatFun.h&quot;</span><span class="hl ppc"></span>
Dependency1<span class="hl opt">&amp;</span> <span class="hl kwd">d1</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> Dependency1 dep1<span class="hl opt">;</span>
  <span class="hl kwa">return</span> dep1<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.36. C10/Dependency1StatFun.cpp</strong></p></div><br class="example-break" /><p>
	Presumiblemente, otro código puede también componer esos
	archivos. He aquí otro archivo:
      </p><div class="example"><a id="idp6802936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Dependency2StatFun.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency1StatFun.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency2StatFun.h&quot;</span><span class="hl ppc"></span>
Dependency2<span class="hl opt">&amp;</span> <span class="hl kwd">d2</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> Dependency2 <span class="hl kwd">dep2</span><span class="hl opt">(</span><span class="hl kwd">d1</span><span class="hl opt">());</span>
  <span class="hl kwa">return</span> dep2<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.37. C10/Dependency2StatFun.cpp</strong></p></div><br class="example-break" /><p>
	Ahora hay dos archivos que pueden ser enlazados en cualquier
	orden y si contuviesen objetos estáticos ordinarios podría
	producirse cualquier orden de inicialización. Pero como
	contienen funciones envoltorio, no hay posibilidad de
	inicialización incorrecta:
      </p><div class="example"><a id="idp6804808"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Technique2b.cpp</span>
<span class="hl slc">//{L} Dependency1StatFun Dependency2StatFun</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Dependency2StatFun.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span> <span class="hl kwd">d2</span><span class="hl opt">(); }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.38. C10/Technique2b.cpp</strong></p></div><br class="example-break" /><p>
	Cuando ejecute este programa verá que la inicialización del
	  objeto estático <code class="classname">Dependency1</code> siempre
	  se lleva a cabo antes de la inicialización del objeto
	  estático <code class="classname">Dependency2</code>. También puede
	  ver que ésta es una solución bastante más simple que la de
	  la uno.
      </p><p>
	  Puede verse tentado a escribir <code class="function">d1()</code> y
	  <code class="function">d2()</code> como funciones <code class="keyword">inline</code>
	  dentro de sus respectivos archivos de cabecera, pero eso es
	  algo que, definitivamente, no debe hacer. Una función
	  <code class="keyword">inline</code> puede ser duplicada en cada archivo en el
	  que aparezca y esa duplicación incluye la definición de los
	  objetos estáticos. Puesto que las funciones <code class="keyword">inline</code>
	  llevan asociado por defecto enlazado interno, esto provocará
	  la aparición de múltiples objetos estáticos entre las
	  diversas unidades de traducción, lo que ciertamente causará
	  problemas. Es por eso que debe asegurarse que sólo existe
	  una única definición para cada función contenedora, y eso
	  significa no hacerlas <code class="keyword">inline</code>.
      </p></div></div></div><div class="sect1" title="10.5. Especificaciones de enlazado alternativo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6811352"></a>10.5. Especificaciones de enlazado alternativo</h2></div></div></div><p>
      ¿Qué pasa si está escribiendo un programa en C++ y quiere usar
      una librería de C? Si hace uso de la declaración de funciones de
      C,
    </p><pre class="programlisting">
<span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">,</span> <span class="hl kwb">char</span> b<span class="hl opt">);</span>
</pre><p>
      el compilador de C++ adornará el nombre como algo tipo
      <code class="literal">_f_int_char</code> para permitir la sobrecarga de la
      función (y el enlazado con verificación de tipos). De todas
      formas, el compilador de C que compiló su librería C
      definitivamente no decoró ese nombre, por lo que su nombre
      interno será <code class="literal">_f</code>. Así pues, el enlazador no
      será capaz de resolver sus llamadas tipo C++ a
      <code class="function">f()</code>.
    </p><p>
      La forma de resolver esto que se propone en C++ es la
      <span class="emphasis"><em>especificación de enlazado alternativo</em></span>, que
      se produjo en el lenguaje sobrecargando la palabra clave
      <code class="keyword">extern</code>. A la palabra clave <code class="keyword">extern</code> le sigue una
      cadena que especifica el enlazado deseado para la declaración,
      seguido por la declaración:
    </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl str">&quot;C&quot;</span> <span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">,</span> <span class="hl kwb">char</span> b<span class="hl opt">);</span>
</pre><p>
      Esto le dice al compilador que <code class="function">f()</code> tiene
      enlazado tipo C, de forma que el compilador no decora el
      nombre. Las dos únicas especificaciones de enlazado soportadas
      por el estándar son «C» y «C++», pero algunos vendedores ofrecen
      compiladores que también soportan otros lenguajes.
    </p><p>
      Si tiene un grupo de declaraciones con enlazado alternativo,
      póngalas entre llaves, como a continuación:
    </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl str">&quot;C&quot;</span> <span class="hl opt">{</span>
    <span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">,</span> <span class="hl kwb">char</span> b<span class="hl opt">);</span>
    <span class="hl kwb">double</span> <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">,</span> <span class="hl kwb">char</span> b<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre><p>
      O, para archivos de cabecera,
    </p><pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl str">&quot;C&quot;</span> <span class="hl opt">{</span>
    <span class="hl ppc">#include</span> <span class="hl pps">&quot;Myheader.h&quot;</span><span class="hl ppc"></span>
<span class="hl opt">}</span>
</pre><p>
      La mayoría de compiladores disponibles de C++ manejan las
      especificaciones de enlazado alternativo dentro de sus propios
      archivos de cabecera que trabajan tanto con C como con C++, por
      lo que no tiene que preocuparse de eso.
    </p></div><div class="sect1" title="10.6. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6821000"></a>10.6. Resumen</h2></div></div></div><p>
      La palabra clave <code class="keyword">static</code> puede llevar a confusión porque
      en algunas situaciones controla la reserva de espacio en
      memoria, y en otras controla la visibilidad y enlazado del
      nombre.
    </p><p>
      Con la introducción de los espacios de nombres de C++, dispone
      de una alternativa mejorada y más flexible para controlar la
      proliferación de nombres en proyectos grandes.
    </p><p>
      El uso de <code class="keyword">static</code> dentro de clases es un método más para
      controlar los nombres de un programa. Los nombres no colisionan
      con nombres globales, y la visibilidad y acceso se mantiene
      dentro del programa, dándole un mayor control para el
      mantenimiento de su código.
    </p></div><div class="sect1" title="10.7. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6824328"></a>10.7. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Cree una función con una variable estática que sea un
	  puntero (con un argumento por defecto igual cero).  Cuando
	  la función que realice la llamada proporcione un valor para
	  ese argumento se usará para apuntar al principio de un
	  array de <code class="type">int</code>. Si se llama a la función con el
	  argumento cero (utilizando el argumento por defecto), la
	  función devuelve el siguiente valor del array, hasta que
	  llegue a un valor <code class="literal">-1</code> en el array (que
	  actuará como señal de final). Experimente con esta función en
	  <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una función que devuelva el siguiente valor de una
	  serie de Fibonacci cada vez que sea llamada. Añada un
	  argumento que de tipo <code class="type">bool</code> con valor por
	  defecto <code class="keyword">false</code> tal que cuando el argumento valga
	  <code class="keyword">true</code> «reinicie» la función al
	  principio de la serie de Fibonacci. Experimente con esta función en
	  <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un array de
	  <code class="type">int</code>. Especifique la dimensión del array
	  utilizando <code class="code">static const int</code> dentro de la
	  clase. Añada una variable <code class="code">const int</code> e
	  inicialícela en la lista de inicialización del
	  constructor. Haga al constructor <code class="keyword">inline</code>. Añada un
	  atributo <code class="type">static int</code> e inicialícelo a un valor
	  específico. Añada un método estático que imprima el atributo
	  estático. Añada un miembro <code class="keyword">inline</code> llamado
	  <code class="function">print()</code> que imprima todos los valores
	  del array y que llame al método estático. Experimente con esta
	  clase en <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase llamada <code class="classname">Monitor</code> que
	  mantenga el registro del número de veces que ha sido llamado
	  su método <code class="function">incident()</code>. Añada un método
	  <code class="function">print()</code> que muestre por pantalla el
	  número de incidentes. Ahora cree una función global (no un
	  método) que contenga un objeto estático
	  <code class="classname">Monitor</code>. Cada vez que llame a la
	  función debe llamar a <code class="function">incident()</code>,
	  después al método <code class="function">print()</code> para sacar
	  por pantalla el contador de incidentes. Experimente con la función
	  en <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Modifique la clase <code class="classname">Monitor</code> del
	  Ejercicio 4 de forma que pueda decrementar
	  (<code class="function">decrement()</code>) el contador de
	  incidentes. Cree una clase llamada
	  <code class="classname">Monitor2</code> que tome como argumento del
	  constructor un puntero a <code class="classname">Monitor1</code>, y
	  que almacene ese puntero y llame a
	  <code class="function">incident()</code> y
	  <code class="function">print()</code>. En el destructor para
	  <code class="classname">Monitor2</code>, llame a
	  <code class="function">decrement()</code> y
	  <code class="function">print()</code>. Cree ahora un objeto estático
	  de <code class="classname">Monitor2</code> dentro de una
	  función. Dentro de <code class="function">main()</code>, experimente
	  llamando y no llamando a la función para ver qué pasa con el
	  destructor de <code class="classname">Monitor2</code>.
	</p></li><li class="listitem"><p>
	  Cree un objeto global de clase
	  <code class="classname">Monitor2</code> y vea qué sucede.
	</p></li><li class="listitem"><p>
	  Cree una clase con un destructor que imprima un mensaje y
	  después llame a <code class="function">exit()</code>. Cree un objeto
	  global de esa clase y vea qué pasa.
	</p></li><li class="listitem"><p>
	  En <code class="filename">StaticDestructors.cpp</code>, experimente
	  con el orden de llamada de los constructores y destructores
	  llamando a <code class="function">f()</code> y
	  <code class="function">g()</code> dentro de
	  <code class="function">main()</code> en diferentes órdenes. ¿Su
	  compilador inicializa los objetos de la forma correcta?
	</p></li><li class="listitem"><p>
	  En <code class="filename">StaticDestructors.cpp</code>, pruebe el
	  manejo de errores por defecto de su implementación
	  convirtiendo la definición original de
	  <code class="varname">out</code> dentro de una declaración
	  <code class="keyword">extern</code>, y poniendo la definición real después de la
	  definición de <code class="varname">a</code> (donde el constructor de
	  <code class="classname">Obj</code> manda información a
	  <code class="varname">out</code>). Asegúrese que no hay ningún otro
	  programa importante funcionando en su máquina cuando ejecute
	  el código o que su máquina maneje las faltas robustamente.
	</p></li><li class="listitem"><p>
	  Pruebe que las variables estáticas de fichero en los
	  archivos de cabecera no chocan entre sí cuando son incluidas
	  en más de un archivo <code class="filename">cpp</code>.
	</p></li><li class="listitem"><p>
	  Cree una única clase que contenga un <code class="type">int</code>, un
	  constructor que inicialice el <code class="type">int</code> con su
	  argumento, un método que cambie el valor del
	  <code class="type">int</code> con su argumento y una función
	  <code class="function">print()</code> que muestre por pantalla el
	  <code class="type">int</code>. Coloque su clase en un archivo de cabecera
	  e incluya dicho archivo en dos archivos
	  <code class="filename">cpp</code>. En uno de ellos cree una instancia
	  de la clase y en la otra declare ese identificador como
	  <code class="keyword">extern</code> y pruebe dentro de
	  <code class="function">main()</code>. Recuerde, debe enlazar los dos
	  archivos objeto o de lo contrario el enlazador no encontrará
	  el objeto.
	</p></li><li class="listitem"><p>
	  Cree la instancia del objeto del Ejercicio 11 como <code class="keyword">static</code> y
	  verifique que, debido a eso, el enlazador es incapaz de encontrarla.
	</p></li><li class="listitem"><p>
	  Declare una función en un archivo de cabecera. Defina la
	  función en un archivo <code class="filename">cpp</code> y llámela
	  desde <code class="function">main()</code> en un segundo archivo
	  <code class="filename">cpp</code>. Compile y verifique que
	  funciona. Ahora cambie la definición de la función de forma
	  que sea <code class="keyword">static</code> y verifique que el enlazador no
	  puede encontrarla.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Volatile.cpp</code> del Capítulo 8
	  para hacer que <code class="function">comm::isr()</code> funcione
	  realmente como una rutina de servicio de
	  interrupción. Pista: una rutina de servicio de interrupción
	  no toma ningún argumento.
	</p></li><li class="listitem"><p>
	  Escriba y compile un único programa que utilice las palabras
	  clave <code class="keyword">auto</code> y <code class="keyword">register</code>.
	</p></li><li class="listitem"><p>
	  Cree un archivo de cabecera que contenga un espacio de
	  nombres. Dentro del espacio de nombres cree varias
	  declaraciones de funciones. Cree ahora un segundo archivo de
	  cabecera que incluya el primero y continúe el espacio de
	  nombres, añadiendo varias declaraciones de funciones
	  más. Cree ahora un archivo <code class="filename">cpp</code> que
	  incluya el segundo archivo de cabecera. Cambie su espacio de
	  nombres a otro nombre (más corto). Dentro de una definición
	  de función, llame a una de sus funciones utilizando la
	  resolución de ámbito. Dentro de una definición de función
	  separada, escriba una directiva <code class="keyword">using</code> para
	  introducir su espacio de nombres en el ámbito de esa
	  función, y demuestre que no necesita utilizar la resolución
	  de ámbito para llamar a las funciones desde su espacio de
	  nombres.
	</p></li><li class="listitem"><p>
	  Cree un archivo de cabecera con un espacio de nombres sin
	  nombre. Incluya la cabecera en dos archivos
	  <code class="filename">cpp</code> diferentes y demuestre que un
	  espacio sin nombre es único para cada :unidad de traducción.
	</p></li><li class="listitem"><p>
	  Utilizando el archivo de cabecera del Ejercicio 17,
	  demuestre que los nombres de un espacio de nombres sin
	  nombre están disponibles automáticamente en una :unidad de
	  traducción sin calificación.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">FriendInjection.cpp</code> para
	  añadir una definición para la función amiga y para llamar a
	  la función desde <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  En <code class="filename">Arithmetic.cpp</code>, demuestre que la
	  directiva <code class="keyword">using</code> no se extiende fuera de la función en
	  la que fue creada.
    	</p></li><li class="listitem"><p>
	  Repare el problema de
	  <code class="filename">OverridingAmbiguity.cpp</code>, primero con
	  resolución de ámbito y luego, con una declaración
	  <code class="keyword">using</code> que fuerce al compilador a escojer uno de los
	  nombres de función idénticos.
    	</p></li><li class="listitem"><p>
	  En dos archivos de cabecera, cree dos espacios de nombres,
	  cada uno conteniendo una clase (con todas las definiciones
	  <code class="keyword">inline</code>) con idéntico nombre que el del otro espacio
	  de nombres. Cree un archivo <code class="filename">cpp</code> que
	  incluya ambos archivos. Cree una función y, dentro de la
	  función, utilice la directiva <code class="keyword">using</code> para introducir
	  ambos espacios de nombres. Pruebe a crear un objeto de la
	  clase y vea que sucede. Haga las directivas <code class="keyword">using</code>
	  globales (fuera de la función) para ver si existe alguna
	  diferencia. Repare el problema usando la resolución de
	  ámbito, y cree objetos de ambas clases.
	</p></li><li class="listitem"><p>
	  Repare el problema del Ejercicio 22 con una declaración
	  <code class="keyword">using</code> que fuerce al compilador a escojer uno de los
	  nombres de clase idénticos.
	</p></li><li class="listitem"><p>
	  Extraiga las declaraciones de espacios de nombres de
	  <code class="filename">BobsSuperDuperLibrary.cpp</code> y
	  <code class="filename">UnnamedNamespaces.cpp</code> y póngalos en
	  archivos separados, dando un nombre al espacio de nombres
	  sin nombre en el proceso. En un tercer archivo de cabecera,
	  cree un nuevo espacio de nombres que combine los elementos
	  de los otros dos espacios de nombres con declaraciones
	  <code class="keyword">using</code>. En <code class="function">main()</code>, introduzca
	  su nuevo espacio de nombres con una directiva <code class="keyword">using</code>
	  y acceda a todos los elementos de su espacio de nombres.
	</p></li><li class="listitem"><p>
	  Cree un archivo de cabecera que incluya
	  <code class="filename">&lt;string&gt;</code> y
	  <code class="filename">&lt;iostream&gt;</code> pero que no use ninguna
	  directiva <code class="keyword">using</code> ni ninguna declaración
	  <code class="keyword">using</code>. Añada guardas de inclusión como ha visto en
	  los archivos de cabecera del libro. Cree una clase con todas
	  las funciones <code class="keyword">inline</code> que muestre por pantalla el
	  <code class="type">string</code>. Cree un archivo
	  <code class="filename">cpp</code> y ejercite su clase en
	  <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un <code class="type">static double</code> y
	  <code class="type">long</code>. Escriba un método estático que imprima
	  los valores.
   	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un <code class="type">int</code>, un
	  constructor que inicialice el <code class="type">int</code> con su
	  argumento, y una función <code class="function">print()</code> que
	  muestre por pantalla el <code class="type">int</code>. Cree ahora una
	  segunda clase que contenga un objeto estático de la
	  primera. Añada un método estático que llame a la función
	  <code class="function">print()</code> del objeto estático.  Ejercitu
	  su clase en <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un array estático de
	  <code class="type">int</code> constante y otro no constante. Escriba
	  métodos estáticos que impriman los arrays. Experimente con su clase
	  en <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un <code class="type">string</code>, con un
	  constructor que inicialice el <code class="type">string</code> a partir
	  de su argumento, y una función <code class="function">print()</code>
	  que imprima el <code class="type">string</code>. Cree otra clase que
	  contenga un array estático, tanto constante como no
	  constante, de objetos de la primera clase, y métodos
	  estáticos para imprimir dichos arrays. Experimente con la
	  segunda clase en <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Cree una <code class="keyword">struct</code> que contenga un <code class="type">int</code> y
	  un constructor por defecto que inicialice el
	  <code class="type">int</code> a cero.  Haga ese <code class="keyword">struct</code> local a
	  una función. Dentro de dicha función, cree un array de
	  objetos de su <code class="keyword">struct</code> y demuestre que cada
	  <code class="type">int</code> del array ha sido inicializado a cero
	  automáticamente.
	</p></li><li class="listitem"><p>
	  Cree una clase que represente una conexión a impresora, y que
	  sólo le permita tener una impresora.
	</p></li><li class="listitem"><p>
	  En un archivo de cabecera, cree una clase
	  <code class="classname">Mirror</code> que contiene dos atributos:
	  un puntero a un objeto <code class="classname">Mirror</code> y un
	  <code class="type">bool</code>. Déle dos constructores: el constructor
	  por defecto inicializa el <code class="type">bool</code> a <code class="keyword">true</code>
	  y el puntero a <code class="classname">Mirror</code> a cero. El
	  segundo constructor toma como argumento un puntero a un
	  objeto <code class="classname">Mirror</code>, que asigna al puntero
	  interno del objeto; pone el <code class="type">bool</code> a
	  <code class="keyword">false</code>. Añada un método <code class="function">test()</code>:
	  si el puntero del objeto es distinto de cero, devuelve el
	  valor de <code class="function">test()</code> llamado a través del
	  puntero. Si el puntero es cero, devuelve el
	  <code class="type">bool</code>. Cree ahora cinco archivos
	  <code class="filename">cpp</code>, cada uno incluyendo la cabecera
	  <code class="classname">Mirror</code>. El primer archivo
	  <code class="filename">cpp</code> define un objeto
	  <code class="classname">Mirror</code> global utilizando el
	  constructor por defecto. El segundo archivo declara el
	  objeto del primer archivo como <code class="keyword">extern</code>, y define un
	  objeto <code class="classname">Mirror</code> global utilizando el
	  segundo constructor, con un puntero al primer objeto. Siga
	  haciendo lo mismo hasta que llegue al último archivo, que
	  también contendrá una definición de objeto global. En este
	  archivo, <code class="function">main()</code> debe llamar a la
	  función <code class="function">test()</code> e informar del
	  resultado. Si el resultado es <code class="keyword">true</code>, encuentre la
	  forma de cambiar el orden de enlazado de su enlazador y
	  cámbielo hasta que el resultado sea <code class="keyword">false</code>.
	</p></li><li class="listitem"><p>
	  Repare el problema del Ejercicio 32 utilizando la técnica uno
          mostrada en este libro.
      	</p></li><li class="listitem"><p>
	  Repare el problema del Ejercicio 32 utilizando la técnica dos
	  mostrada en este libro.
	</p></li><li class="listitem"><p>
	  Sin incluir ningún archivo de cabecera, declare la función
	  <code class="function">puts()</code> de la Librería Estándar de C.
	  Llame a esa función desde <code class="function">main()</code>.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp6751120" href="#idp6751120" class="para">68</a>] </sup>Bjarne
	  Stroustrup and Margaret Ellis, The Annotated C++ Reference Manual,
	  Addison-Wesley, 1990, pp. 20-21.</p></div></div></div><div class="chapter" title="11: Las referencias y el constructor de copia"><div class="titlepage"><div><div><h2 class="title"><a id="C11"></a>11: Las referencias y el constructor de copia</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp6907720">11.1. Punteros en C++</a></span></dt><dt><span class="sect1"><a href="#idp6912048">11.2. Referencias en C++</a></span></dt><dt><span class="sect1"><a href="#idp6940384">11.3. El constructor de copia</a></span></dt><dt><span class="sect1"><a href="#idp7065616">11.4. Punteros a miembros</a></span></dt><dt><span class="sect1"><a href="#idp7099888">11.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp7104712">11.6. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Las referencias son como punteros constantes que el compilador
      de-referencia automáticamente.
    </p></div><p>
    Aunque las referencias también existen en Pascal, la versión de
    C++ se tomó del lenguaje Algol. Las referencias son esenciales en
    C++ para ayudar en la sintaxis de los operadores sobrecargados
    (vea el <a class="link" href="#C12" title="12: Sobrecarga de operadores">capítulo 12</a>) y, además, son una
    buena forma para controlar la manera en que los argumentos se
    pasan a las funciones tanto hacia dentro como hacia fuera.
  </p><p>
    En este capítulo primero verá la diferencia entre los punteros en
    C y en C++, y luego se presentarán las referencias. Pero la mayor
    parte del capítulo ahondará en el asunto un tanto confuso para los
    programadores de C++ novatos: el constructor de copia, un
    constructor especial (que usa referencias) y construye un nuevo
    objeto de otro ya existente del mismo tipo. El compilador utiliza
    el constructor de copia para pasar y retornar objetos
    <span class="emphasis"><em>por valor</em></span> a las funciones.
  </p><p>
    Finalmente, se hablará sobre la característica (un tanto oscura) de
    los <span class="emphasis"><em>punteros-a-miembro</em></span> de C++.
  </p><div class="sect1" title="11.1. Punteros en C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6907720"></a>11.1. Punteros en C++</h2></div></div></div><p>
      La diferencia más importante entre los punteros en C y en C++ es
      que los de C++ están fuertemente tipados. Sobre todo en lo que
      al tipo <code class="type">void *</code> se refiere. C no permite asignar un
      puntero de un tipo a otro de forma casual, pero
      <span class="emphasis"><em>sí</em></span> permite hacerlo mediante un <code class="type">void
      *</code>. Por ejemplo,
    </p><pre class="programlisting">
Bird<span class="hl opt">*</span> b<span class="hl opt">;</span>
Rock<span class="hl opt">*</span> r<span class="hl opt">;</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> v<span class="hl opt">;</span>
v <span class="hl opt">=</span> r<span class="hl opt">;</span>
b <span class="hl opt">=</span> v<span class="hl opt">;</span>
</pre><p>
      A causa de esta «característica» de C, puede
      utilizar cualquier tipo como si de otro se tratara sin ningún
      aviso por parte del compilador. C++ no permite hacer esto; el
      compilador da un mensaje de error, y si realmente quiere
      utilizar un tipo como otro diferente, debe hacerlo
      explícitamente, tanto para el compilador como para el lector,
      usando molde (<span class="emphasis"><em>cast</em></span> en inglés). (En el <a class="link" href="#C03" title="3: C en C++">capítulo 3</a> se habló sobre la sintaxis
      mejorada del molde «explícito»).
    </p></div><div class="sect1" title="11.2. Referencias en C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6912048"></a>11.2. Referencias en C++</h2></div></div></div><p>
      Una <span class="emphasis"><em>referencia</em></span> (&amp;) es como un puntero
      constante que se de-referencia automáticamente. Normalmente se
      utiliza en la lista de argumentos y en el valor de retorno de de
      las funciones. Pero también se puede hacer una referencia que
      apunte a algo que no ha sido asignado. Por ejemplo:
    </p><div class="example"><a id="idp6913560"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:FreeStandingReferences.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Ordinary free-standing reference:</span>
<span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">&amp;</span> r <span class="hl opt">=</span> y<span class="hl opt">;</span>
<span class="hl slc">// When a reference is created, it must </span>
<span class="hl slc">// be initialized to a live object. </span>
<span class="hl slc">// However, you can also say:</span>
<span class="hl kwb">const int</span><span class="hl opt">&amp;</span> q <span class="hl opt">=</span> <span class="hl num">12</span><span class="hl opt">;</span>  <span class="hl slc">// (1)</span>
<span class="hl slc">// References are tied to someone else's storage:</span>
<span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>          <span class="hl slc">// (2)</span>
<span class="hl kwb">int</span><span class="hl opt">&amp;</span> a <span class="hl opt">=</span> x<span class="hl opt">;</span>         <span class="hl slc">// (3)</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  a<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x = &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.1. C11/FreeStandingReferences.cpp</strong></p></div><br class="example-break" /><p>
      En la linea (1) el compilador asigna la cantidad necesaria de
      memoria, la inicializa con el valor 12, y liga la referencia a
      esa porción de memoria. Lo importante es que una referencia debe
      estar ligada a la memoria de
      <span class="emphasis"><em>alguien</em></span>. Cuando se accede a una referencia,
      se está accediendo a esa memoria. Así pues, si escribe las
      lineas (2) y (3) incrementará <code class="varname">x</code> cuando se
      incremente <code class="varname">a</code>, tal como se muestra en el
      <code class="function">main()</code>. Lo más fácil es pensar que una
      referencia es como un puntero de lujo. La ventaja de este
      «puntero» es que nunca hay que preguntarse si ha
      sido inicializado (el compilador lo impone) o si hay que
      destruirlo (el compilador lo hace).
    </p><p>
      Hay que seguir unas determinadas reglas cuando se utilizan
      referencias:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    La referencia de ser inicializada cuando se crea. (Los
	    punteros pueden inicializarse en cualquier momento).
	  </p></li><li class="listitem"><p>
	    Una vez que se inicializa una referencia, ligándola a un
	    objeto, no se puede ligar a otro objeto. (Los punteros
	    pueden apuntar a otro objeto en cualquier momento).
	  </p></li><li class="listitem"><p>
	    No se pueden tener referencias con valor nulo. Siempre ha
	    de suponer que una referencia está conectada a una trozo
	    de memoria ya asignada.
	  </p></li></ol></div><p>
    </p><div class="sect2" title="11.2.1. Referencias en las funciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp6920616"></a>11.2.1. Referencias en las funciones</h3></div></div></div><p>
	El lugar más común en el que verá referencias es en los
	argumentos y valor de retorno de las funciones. Cuando se
	utiliza una referencia como un argumento de una función,
	cualquier cambio realizado en la
	referencia <span class="emphasis"><em>dentro</em></span> de la función se
	realizará realmente sobre el argumento
	<span class="emphasis"><em>fuera</em></span> de la función.  Por supuesto que
	podría hacer lo mismo pasando un puntero como argumento, pero
	una referencia es sintácticamente más clara.  (Si lo desea,
	puede pensar que una referencia es, nada más y nada menos,
	más conveniente sintácticamente).
      </p><p>
	Si una función retorna una referencia, ha de tener el mismo
	cuidado que si la función retornara un puntero. La referencia
	que se devuelva debe estar ligada a algo que no sea liberado
	cuando la función retorne. Si no, la referencia se referirá a un
	trozo de memoria sobre el que ya no tiene control.
      </p><p>
	He aquí un ejemplo:
      </p><div class="example"><a id="idp6923800"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Reference.cpp</span>
<span class="hl slc">// Simple C++ references</span>

<span class="hl kwb">int</span><span class="hl opt">*</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*</span> x<span class="hl opt">) {</span>
  <span class="hl opt">(*</span>x<span class="hl opt">)++;</span>
  <span class="hl kwa">return</span> x<span class="hl opt">;</span> <span class="hl slc">// Safe, x is outside this scope</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span><span class="hl opt">&amp;</span> <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
  x<span class="hl opt">++;</span> <span class="hl slc">// Same effect as in f()</span>
  <span class="hl kwa">return</span> x<span class="hl opt">;</span> <span class="hl slc">// Safe, outside this scope</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span><span class="hl opt">&amp;</span> <span class="hl kwd">h</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> q<span class="hl opt">;</span>
<span class="hl slc">//!  return q;  // Error</span>
  <span class="hl kwb">static int</span> x<span class="hl opt">;</span>
  <span class="hl kwa">return</span> x<span class="hl opt">;</span> <span class="hl slc">// Safe, x lives outside this scope</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(&amp;</span>a<span class="hl opt">);</span> <span class="hl slc">// Ugly (but explicit)</span>
  <span class="hl kwd">g</span><span class="hl opt">(</span>a<span class="hl opt">);</span>  <span class="hl slc">// Clean (but hidden)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.2. C11/Reference.cpp</strong></p></div><br class="example-break" /><p>
	La llamada a <code class="function">f()</code> no tiene la ventaja ni la
	claridad que la utilización de referencias, pero está claro que
	se está pasando una dirección mediante un puntero. En la llamada
	a <code class="function">g()</code>, también se pasa una dirección
	(mediante una referencia), pero no se ve.
      </p><div class="sect3" title="Referencias constantes"><div class="titlepage"><div><div><h4 class="title"><a id="idp6926896"></a>Referencias constantes</h4></div></div></div><p>
	  El argumento referencia en
	  <code class="filename">Reference.cpp</code> funciona solamente en
	  caso de que el argumento no sea un objeto constante.  Si
	  fuera un objeto constante, la función
	  <code class="function">g()</code> no aceptaría el argumento, lo cual
	  es positivo porque la función
	  <span class="emphasis"><em>modificaría</em></span> el argumento que está fuera
	  de la función. Si sabe que la función respetará las
	  constancia un objeto, el hecho de que el argumento sea una
	  referencia constante permitirá que la función se pueda
	  utilizar en cualquier situación. Esto significa que para
	  tipos predefinidos, la función no modificará el argumento, y
	  para tipos definidos por el usuario, la función llamará
	  solamente a métodos constantes, y no modificara ningún
	  atributo público.
	</p><p>
	  La utilización de referencias constantes en argumentos de
	  funciones es especialmente importante porque una función
	  puede recibir un objeto temporal. Éste podría haber sido
	  creado como valor de retorno de otra función o
	  explícitamente por el usuario de la función. Los objetos
	  temporales son siempre constantes.  Por eso, si no utiliza
	  una referencia constante, el compilador se quejará. Como
	  ejemplo muy simple:
	</p><div class="example"><a id="idp6930288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ConstReferenceArguments.cpp</span>
<span class="hl slc">// Passing references as const</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">&amp;) {}</span>
<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl kwb">const int</span><span class="hl opt">&amp;) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
<span class="hl slc">//!  f(1); // Error</span>
  <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.3. C11/ConstReferenceArguments.cpp</strong></p></div><br class="example-break" /><p>
	  La llamada <code class="code">f(1)</code> provoca un error en tiempo de
	  compilación porque el compilador debe crear primero una
	  referencia. Lo hace asignando memoria para un
	  <code class="type">int</code>, iniciánlizándolo a uno y generando la
	  dirección de memoria para ligarla a la referencia. La
	  memoria debe ser constante porque no
	  tendría sentido cambiarlo: no puede cambiarse de
	  nuevo. Puede hacer la misma suposición para todos los
	  objetos temporales: son inaccesibles. Es importante
	  que el compilador le diga cuándo está intentando cambiar
	  algo de este estilo porque podría perder información.
	</p></div><div class="sect3" title="Referencias a puntero"><div class="titlepage"><div><div><h4 class="title"><a id="idp6932960"></a>Referencias a puntero</h4></div></div></div><p>
	  En C, si desea modificar el <span class="emphasis"><em>contenido</em></span> del
	  puntero en sí en vez de modificar a lo que apunta, la
	  declaración de la función sería:
	</p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">**);</span>
</pre><p>
	  
	  y tendría que tomar la dirección del puntero cuando se llamara
	  a la función:
	</p><pre class="programlisting">
<span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">= &amp;</span>i<span class="hl opt">;</span>
<span class="hl kwd">f</span><span class="hl opt">(&amp;</span>ip<span class="hl opt">);</span>
</pre><p>
	  La sintaxis es más clara con las referencias en C++. El
	  argumento de la función pasa a ser de una referencia a un
	  puntero, y así no ha de manejar la dirección del puntero.
	</p><div class="example"><a id="idp6935728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ReferenceToPointer.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">increment</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*&amp;</span> i<span class="hl opt">) {</span> i<span class="hl opt">++; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">increment</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.4. C11/ReferenceToPointer.cpp</strong></p></div><br class="example-break" /><p>
	  Al ejecutar este programa se observa que el puntero se
	  incrementa en vez de incrementar a lo que apunta.
	</p></div></div><div class="sect2" title="11.2.2. Consejos para el paso de argumentos"><div class="titlepage"><div><div><h3 class="title"><a id="idp6937360"></a>11.2.2. Consejos para el paso de argumentos</h3></div></div></div><p>
	Cuando se pasa un argumento a un función, lo normal debería
	ser pasarlo como una referencia constante. Aunque al principio
	puede parecer que sólo tiene ventajas en términos de eficacia
	(y normalmente en diseño e implementación inicial no se tiene
	muy en cuenta la eficacia), además tiene otras: como se podrá
	ver en el resto del capítulo, se requiere un constructor de
	copia para pasar un objeto por valor, y esto no siempre es
	posible.
      </p><p>
	La eficacia puede mejorar substancialmente por este simple
	hábito: pasar un argumento por valor necesita una llamada a un
	constructor y otra a un destructor, pero si no se va a
	modificar el argumento, el hecho de pasarlo como una
	referencia constante sólo necesita poner una dirección en la
	pila.
      </p><p>
	De hecho, prácticamente la única situación en la que no es
	preferible pasar la dirección, es cuando provocará tales
	problemas a un objeto que pasar por valor es la única
	alternativa segura (en vez de modificar el objeto que está
	fuera del ámbito de la función, algo que el que llama a la
	función normalmente no espera). Ese es el tema de la
	siguiente sección.
      </p></div></div><div class="sect1" title="11.3. El constructor de copia"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp6940384"></a>11.3. El constructor de copia</h2></div></div></div><p>
      Ahora que entiende lo básico de las referencias en C++, está
      preparado para tratar uno de los conceptos más confusos del
      lenguaje: el constructor de copia, a menudo denominado
      <code class="code">X(X&amp;)</code> («X de la referencia
      X»). Este constructor es esencial para controlar el paso
      y retorno por valor de los tipos definidos por el usuario en las
      llamadas a funciones. De hecho es tan importante que el
      compilador crea automáticamente un constructor de copia en caso
      de que el programador no lo proporcione.
    </p><div class="sect2" title="11.3.1. Paso y retorno por valor"><div class="titlepage"><div><div><h3 class="title"><a id="idp6942408"></a>11.3.1. Paso y retorno por valor</h3></div></div></div><p>
	Para entender la necesidad del constructor de copia, considere la
	forma en que C maneja el paso y retorno por valor de variables
	cuando se llama a una función. Si declara una función y la
	invoca,
      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">,</span> <span class="hl kwb">char</span> c<span class="hl opt">);</span>
<span class="hl kwb">int</span> g <span class="hl opt">=</span> <span class="hl kwd">f</span><span class="hl opt">(</span>a<span class="hl opt">,</span> b<span class="hl opt">);</span>
</pre><p>
	¿cómo sabe el compilador cómo pasar y retornar esas variables?
	¡Simplemente lo sabe! El rango de tipos con los que debe
	tratar es tan pequeño (<code class="type">char</code>, <code class="type">int</code>,
	<code class="type">float</code>, <code class="type">double</code>, y sus variaciones),
	que tal información ya está dentro del compilador.
      </p><p>
	Si averigua cómo hacer que su compilador genere código
	ensamblador y determina qué instrucciones se usan para la
	invocación de la función <code class="function">f()</code>, obtendrá
	algo equivalente a:
      </p><pre class="programlisting">
push  b
push  a
call  <span class="hl kwd">f</span><span class="hl opt">()</span>
add  sp<span class="hl opt">,</span> <span class="hl num">4</span>
mov  g<span class="hl opt">,</span> <span class="hl kwc">register</span> a
</pre><p>
	Este código se ha simplificado para hacerlo genérico; las
        expresiones <code class="varname">b</code> y <code class="varname">a</code> serán
        diferentes dependiendo de si las variables son globales (en
        cuyo caso serían <code class="varname">_b</code> y
        <code class="varname">_a</code>) o locales (el compilador las pondría en
        la pila). Esto también es cierto para <code class="varname">g</code>. La
        sintaxis de la llamada a <code class="function">f()</code> dependería
        de su guía de estilo, y <code class="code">register a</code> dependería de
        cómo su ensamblador llama a los registros de la CPU. A pesar
        de la simplificación, la lógica del código sería la misma.
      </p><p>
	Tanto en C como en C++, primero se ponen los argumentos en la
	pila de derecha a izquierda, y luego se llama a la función. El
	código de llamada es responsable de recoger los argumentos de
	la pila (lo cual explica la sentencia <code class="code">add sp, 4</code>).
	Pero tenga en cuenta que cuando se pasan argumentos por valor,
	el compilador simplemente pone copias en la pila (conoce los
	tamaños de cada uno, por lo que los puede copiar).
	</p><p>
	El valor de retorno de <code class="function">f()</code> se coloca en un
	registro. Como el compilador sabe lo que se está retornando,
	porque la información del tipo ya está en el lenguaje, puede
	retornarlo colocándolo en un registro. En C, con tipos
	primitivos, el simple hecho de copiar los bits del valor es
	equivalente a copiar el objeto.
      </p><div class="sect3" title="Paso y retorno de objetos grandes"><div class="titlepage"><div><div><h4 class="title"><a id="idp6951824"></a>Paso y retorno de objetos grandes</h4></div></div></div><p>
	  Considere ahora los tipos definidos por el usuario. Si crea
	  una clase y desea pasar un objeto de esa clase por valor,
	  ¿cómo sabe el compilador lo que tiene que hacer?  La
	  información de la clase no está en el compilador, pues lo ha
	  definido el usuario.
	</p><p>
	  Para investigar esto, puede empezar con una estructura simple
	  que, claramente, es demasiado grande para ser devuelta a
	  través de los registros:
	</p><div class="example"><a id="idp6953448"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:PassingBigStructures.cpp</span>
<span class="hl kwb">struct</span> Big <span class="hl opt">{</span>
  <span class="hl kwb">char</span> buf<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">long</span> d<span class="hl opt">;</span>
<span class="hl opt">}</span> B<span class="hl opt">,</span> B2<span class="hl opt">;</span>

Big <span class="hl kwd">bigfun</span><span class="hl opt">(</span>Big b<span class="hl opt">) {</span>
  b<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span> <span class="hl slc">// Do something to the argument</span>
  <span class="hl kwa">return</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  B2 <span class="hl opt">=</span> <span class="hl kwd">bigfun</span><span class="hl opt">(</span>B<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.5. C11/PassingBigStructures.cpp</strong></p></div><br class="example-break" /><p>
	  La conversión a código ensamblador es un poco más complicada
	  porque la mayoría de los compiladores utilizan funciones
	  «auxiliares»
	  (<span class="foreignphrase"><em class="foreignphrase">helper</em></span>) en vez de inline. En
	  la función <code class="function">main()</code>, la llamada a
	  <code class="function">bigfun()</code> empieza como debe: se coloca
	  el contenido de <code class="varname">B</code> en la pila. (Aquí
	  podría ocurrir que algunos compiladores carguen registros
	  con la dirección y tamaño de <code class="classname">Big</code> y
	  luego una función auxiliar se encargue de colocar el
	  <code class="classname">Big</code> en la pila).
	</p><p>
	  En el fragmento de código fuente anterior, lo único
	  necesario antes de llamar a la función es colocar los
	  argumentos en la pila. Sin embargo, en el código ensamblador
	  de <code class="filename">PassingBigStructures.cpp</code> se ve una
	  acción adicional: la dirección de <code class="varname">B2</code> se
	  coloca en la pila antes de hacer la llamada a la función
	  aunque, obviamente, no sea un argumento. Para entender qué
	  pasa, necesita entender las restricciones del compilador
	  cuando llama a una función.
	</p></div><div class="sect3" title="Marco de pila para llamadas a función"><div class="titlepage"><div><div><h4 class="title"><a id="idp6959096"></a>Marco de pila para llamadas a función</h4></div></div></div><p>
	  Cuando el compilador genera código para llamar a una
	  función, primero coloca en la pila todos los argumentos y
	  luego hace la llamada. Dentro de la función se genera código
	  para mover el puntero de pila hacia abajo, y así proporciona
	  memoria para las variables locales dentro de la función.
	  («hacia abajo» es relativo, la máquina puede
	  incrementar o decrementar el puntero de pila al colocar un
	  argumento). Pero cuando se hace el <code class="code">CALL</code> de
	  ensamblador para llamar a la función, la CPU coloca la
	  dirección desde la que se realiza la llamada, y en el
	  <code class="code">RETURN</code> de ensamblador se utiliza esa dirección
	  para volver al punto desde donde se realizó la llamada. Esta
	  dirección es sagrada, porque sin ella el programa se
	  perdería por completo. He aquí es aspecto del marco de pila
	  después de ejecutar <code class="code">CALL</code> y poner las variables
	  locales de la función:
	</p><div class="figure"><a id="idp6962320"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_14.png" align="middle" alt="Llamada a una función" /></div></div><p class="title"><strong>Figura 11.1. Llamada a una función</strong></p></div><br class="figure-break" /><p>
	  El código generado por el resto de la función espera que la
	  memoria tenga esta disposición para que pueda utilizar los
	  argumentos y las variables locales sin tocar la dirección de
	  retorno. Llámese a este bloque de memoria, que es todo lo
	  que una función necesita cuando se la llama, <span class="emphasis"><em>el
	  marco de la función</em></span> (<span class="foreignphrase"><em class="foreignphrase">function
	  frame</em></span>).
	</p><p>
	  Podría parecer razonable retornar valores mediante la
	  utilización de la pila. El compilador simplemente los
	  colocaría allí y la función devolvería un desplazamiento que
	  indicara dónde empieza el valor de retorno.
	</p></div><div class="sect3" title="Re-entrada"><div class="titlepage"><div><div><h4 class="title"><a id="idp6966816"></a>Re-entrada</h4></div></div></div><p>
	  Este problema ocurre porque las funciones en C y C++ pueden
	  sufrir interrupciones; esto es, los lenguajes han de ser (y
	  de hecho son) <span class="emphasis"><em>re-entrantes</em></span>. También
	  permiten llamadas a funciones recursivas. Esto quiere decir
	  que en cualquier punto de ejecución de un programa puede
	  sufrir una interrupción sin que el programa se vea afectado
	  por ello. Obviamente la persona que escribe la rutina de
	  servicio de interrupciones (ISR) es responsable de guardar y
	  restaurar todos los registros que se utilicen en la
	  ISR. Pero si la ISR necesita utilizar la pila, ha de hacerlo
	  con seguridad. (Piense que una ISR es como una función
	  normal sin argumentos y con valor de retorno
	  <code class="type">void</code> que guarda y restaura el estado de la
	  CPU. La ejecución de una ISR suele producirse por un evento
	  hardware, y no con una invocación dentro del programa de
	  forma explícita).
	</p><p>
	  Ahora imagine que pasaría si una función normal intentara
	  retornar valores mediante la pila. No puede tocar la pila
	  por encima del la dirección de retorno, así que la función
	  tendría que colocar los valores de retorno debajo de la
	  dirección de retorno. Pero cuando se ejecuta el
	  <code class="code">RETURN</code>, el puntero de pila debería estar
	  apuntando a la dirección de retorno (o justo debajo, depende
	  de la máquina), así que la función debe subir el puntero de
	  la pila, desechando todas las variables locales. Si intenta
	  retornar valores usando la pila por debajo de la dirección
	  de retorno, en ese momento es vulnerable a una
	  interrupción. La ISR escribiría encima de los valores de
	  retorno para colocar su dirección de retorno y sus
	  variables locales.
	</p><p>
	  Para resolver este problema, el que llama a la función
	  <span class="emphasis"><em>podría</em></span> hacerse responsable de asignar
	  la memoria extra en la pila para los valores de retorno
	  antes de llamar a la función. Sin embargo, C no se diseñó de
	  esta manera y C++ ha de ser compatible. Como verá pronto, el
	  compilador de C++ utiliza un esquema más eficaz.
	</p><p>
	  Otra idea sería retornar el valor utilizando un área de
	  datos global, pero tampoco funcionaría. La re-entrada
	  significa que cualquier función puede ser una rutina de
	  interrupción para otra función, <span class="emphasis"><em>incluida la
	  función que se está ejecutando</em></span>. Por lo tanto, si
	  coloca un valor de retorno en un área global, podría
	  retornar a la misma función, lo cual sobreescribiría el
	  valor de retorno. La misma lógica se aplica a la
	  recursividad.
	</p><p>
	  Los registros son el único lugar seguro para devolver
	  valores, así que se vuelve al problema de qué hacer cuando
	  los registros no son lo suficientemente grandes para
	  contener el valor de retorno. La respuesta es colocar la
	  dirección de la ubicación del valor de retorno en la pila
	  como uno de los argumentos de la función, y dejar que la
	  función copie la información que se devuelve directamente en
	  esa ubicación. Esto no solo soluciona todo los problemas, si
	  no que además es más eficaz. Ésta es la razón por la que el
	  compilador coloca la dirección de <code class="varname">B2</code>
	  antes de llamar a <code class="function">bigfun</code> en la función
	  <code class="function">main()</code> de
	  <code class="filename">PassingBigStructures.cpp</code>.  Si viera el
	  código ensamblador de <code class="function">bigfun()</code>
	  observaría que la función espera este argumento escondido y
	  lo copia al destino <span class="emphasis"><em>dentro</em></span> de la
	  función.
	</p></div><div class="sect3" title="Copia bit a bit vs. inicialización"><div class="titlepage"><div><div><h4 class="title"><a id="idp6976184"></a>Copia bit a bit vs. inicialización</h4></div></div></div><p>
	  Hasta aquí, todo bien. Tenemos un procedimiento para
	  pasar y retornar estructuras simples grandes. Pero note que
	  lo único que tiene es una manera de copiar bits de un
	  lugar a otro, lo que ciertamente funciona bien para la forma
	  (muy primitiva) en que C trata las variables. Sin embargo,
	  en C++ los objetos pueden ser mucho más avanzados que un
	  puñado de bits, pues tienen significado y, por lo tanto,
	  puede que no responda bien al ser copiado.
	</p><p>
	  Considere un ejemplo simple: una clase que conoce cuantos
	  objetos de un tipo existen en cualquier momento. En el <a class="link" href="#C10" title="10: Control de nombres">Capítulo 10</a> se vio la manera de hacerlo
	  incluyendo un atributo estático (<code class="keyword">static</code>):
	</p><div class="example"><a id="idp6978768"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:HowMany.cpp</span>
<span class="hl slc">// A class that counts its objects</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;HowMany.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwc">class</span> HowMany <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> objectCount<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">HowMany</span><span class="hl opt">() {</span> objectCount<span class="hl opt">++; }</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>msg<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() !=</span> <span class="hl num">0</span><span class="hl opt">)</span> out <span class="hl opt">&lt;&lt;</span> msg <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span><span class="hl opt">;</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;objectCount = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> objectCount <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">HowMany</span><span class="hl opt">() {</span>
    objectCount<span class="hl opt">--;</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;~HowMany()&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> HowMany<span class="hl opt">::</span>objectCount <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl slc">// Pass and return BY VALUE:</span>
HowMany <span class="hl kwd">f</span><span class="hl opt">(</span>HowMany x<span class="hl opt">) {</span>
  x<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;x argument inside f()&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  HowMany h<span class="hl opt">;</span>
  HowMany<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;after construction of h&quot;</span><span class="hl opt">);</span>
  HowMany h2 <span class="hl opt">=</span> <span class="hl kwd">f</span><span class="hl opt">(</span>h<span class="hl opt">);</span>
  HowMany<span class="hl opt">::</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;after call to f()&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.6. C11/HowMany.cpp</strong></p></div><br class="example-break" /><p>
	  La clase <code class="classname">HowMany</code> contiene un entero
	  estático llamado <code class="varname">objectCount</code> y un método
	  estático llamado <code class="function">print()</code> para
	  representar el valor de <code class="varname">objectCount</code>,
	  junto con argumento de mensaje opcional. El constructor
	  incrementa <code class="varname">objectCount</code> cada vez que se
	  crea un objeto, y el destructor lo disminuye.
	</p><p>
	  Sin embargo la salida no es la que cabría esperar:
	</p><pre class="screen">
after construction of h: objectCount = 1
x argument inside f(): objectCount = 1
~HowMany(): objectCount = 0
after call to f(): objectCount = 0
~HowMany(): objectCount = -1
~HowMany(): objectCount = -2
</pre><p>
	  Después de crear <code class="varname">h</code>, el contador es uno,
	  lo cual está bien. Pero después de la llamada a
	  <code class="function">f()</code> se esperaría que el contador
	  estuviera a dos, porque <code class="varname">h2</code> está ahora
	  también dentro de ámbito. Sin embargo, el contador es cero,
	  lo cual indica que algo ha ido muy mal. Esto se confirma por
	  el hecho de que los dos destructores, llamados al final de
	  <code class="function">main()</code>, hacen que el contador pase a ser
	  negativo, algo que no debería ocurrir nunca.
	</p><p>
	  Mire lo que ocurre dentro de <code class="function">f()</code>
	  después de que el argumento se pase por valor. Esto quiere
	  decir que el objeto original <code class="varname">h</code> existe
	  fuera del ámbito de la función y, por otro lado, hay un
	  objeto de más <span class="emphasis"><em>dentro</em></span> del ámbito de la
	  función, que es copia del objeto que se pasó por valor. El
	  argumento que se pasó utiliza el primitivo concepto de copia
	  bit a bit de C, pero la clase C++
	  <code class="classname">HowMany</code> necesita inicializarse
	  correctamente para mantener su integridad. Por lo tanto, se
	  demuestra que la copia bit a bit no logra el efecto deseado.
	</p><p>
	  Cuando el objeto local sale de ámbito al acabar la función
	  <code class="function">f()</code>, se llama a su destructor, lo cual
	  decrementa <code class="varname">objectCount</code>, y por lo tanto el
	  <code class="varname">objectCount</code> se pone a cero. La creación
	  de <code class="varname">h2</code> se realiza también mediante la
	  copia bit a bit, así que tampoco se llama al constructor, y
	  cuando <code class="varname">h</code> y <code class="varname">h2</code> salen de
	  ámbito, sus destructores causan el valor negativo en
	  <code class="varname">objectCount</code>.
	</p></div></div><div class="sect2" title="11.3.2. Construcción por copia"><div class="titlepage"><div><div><h3 class="title"><a id="idp6991168"></a>11.3.2. Construcción por copia</h3></div></div></div><p>
	El problema se produce debido a que el compilador hace una
	suposición sobre cómo crear <span class="emphasis"><em>un nuevo objeto a partir
	de de otro existente</em></span>. Cuando se pasa un objeto por
	valor, se crea un nuevo objeto, que estará dentro del ámbito
	de la función, a partir del objeto original existente fuera
	del ámbito de la función. Esto también se puede aplicar a
	menudo cuando una función retorna un objeto. En la expresión
      </p><pre class="programlisting">
HowMany h2 <span class="hl opt">=</span> <span class="hl kwd">f</span><span class="hl opt">(</span>h<span class="hl opt">);</span>
</pre><p>
	<code class="varname">h2</code>, un objeto que no estaba creado
	anteriormente, se crea a partir del valor que retorna
	<code class="function">f()</code>; por tanto también se crea un nuevo
	objeto a partir de otro existente.
      </p><p>
	El compilador supone que la creación ha de hacerse con una
	copia bit a bit, lo que en muchos casos funciona bien, pero en
	<code class="classname">HowMany</code> no funciona porque la
	inicialización va más allá de una simple copia. Otro ejemplo
	muy común ocurre cuando la clase contiene punteros pues, ¿a
	qué deben apuntar? ¿debería copiar sólo los punteros o
	debería asignar memoria nueva y que apuntaran a ella?
      </p><p>
	Afortunadamente, puede intervenir en este proceso e impedir
	que el compilador haga una copia bit a bit. Se soluciona
	definiendo su propia función cuando el compilador necesite
	crear un nuevo objeto a partir de otro. Lógicamente, está
	creando un nuevo objeto, por lo que esta función es un
	constructor, y el único argumento del constructor tiene que
	ver con el objeto del que se pretende partir para crear el
	nuevo. Pero no puede pasar ese objeto por valor al constructor
	porque está intentando <span class="emphasis"><em>definir</em></span> la función
	que maneja el paso por valor, y, por otro lado,
	sintácticamente no tiene sentido pasar un puntero porque,
	después de todo, está creando un objeto a partir de de
	otro. Aquí es cuando las referencias vienen al rescate, y
	puede utilizar la referencia del objeto origen. Esta función
	se llama <span class="emphasis"><em>constructor de copia</em></span>, que
	también se lo puede encontrar como
	<code class="function">X(X&amp;)</code>, que es el constructor de copia
	de una clase llamada <code class="classname">X</code>.
      </p><p>
	Si crea un constructor de copia, el compilador no realizará
	una copia bit a bit cuando cree un nuevo objeto a partir de
	otro.  El compilador siempre llamará al constructor de
	copia. Si no crea el constructor de copia, el compilador
	intentará hacer algo razonable, pero usted tiene la opción de
	tener control total del proceso.
      </p><p>
	Ahora es posible solucionar el problema en
	<code class="filename">HowMany.cpp</code>:
      </p><div class="example"><a id="idp6999696"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:HowMany2.cpp</span>
<span class="hl slc">// The copy-constructor</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;HowMany2.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwc">class</span> HowMany2 <span class="hl opt">{</span>
  string name<span class="hl opt">;</span> <span class="hl slc">// Object identifier</span>
  <span class="hl kwb">static int</span> objectCount<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">HowMany2</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> id <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) :</span> <span class="hl kwd">name</span><span class="hl opt">(</span>id<span class="hl opt">) {</span>
    <span class="hl opt">++</span>objectCount<span class="hl opt">;</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;HowMany2()&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">HowMany2</span><span class="hl opt">() {</span>
    <span class="hl opt">--</span>objectCount<span class="hl opt">;</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;~HowMany2()&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// The copy-constructor:</span>
  <span class="hl kwd">HowMany2</span><span class="hl opt">(</span><span class="hl kwb">const</span> HowMany2<span class="hl opt">&amp;</span> h<span class="hl opt">) :</span> <span class="hl kwd">name</span><span class="hl opt">(</span>h<span class="hl opt">.</span>name<span class="hl opt">) {</span>
    name <span class="hl opt">+=</span> <span class="hl str">&quot; copy&quot;</span><span class="hl opt">;</span>
    <span class="hl opt">++</span>objectCount<span class="hl opt">;</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;HowMany2(const HowMany2&amp;)&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>msg<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() !=</span> <span class="hl num">0</span><span class="hl opt">)</span> 
      out <span class="hl opt">&lt;&lt;</span> msg <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\t</span><span class="hl str">'</span> <span class="hl opt">&lt;&lt;</span> name <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span>
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;objectCount = &quot;</span>
        <span class="hl opt">&lt;&lt;</span> objectCount <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> HowMany2<span class="hl opt">::</span>objectCount <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl slc">// Pass and return BY VALUE:</span>
HowMany2 <span class="hl kwd">f</span><span class="hl opt">(</span>HowMany2 x<span class="hl opt">) {</span>
  x<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;x argument inside f()&quot;</span><span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Returning from f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">return</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  HowMany2 <span class="hl kwd">h</span><span class="hl opt">(</span><span class="hl str">&quot;h&quot;</span><span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Entering f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  HowMany2 h2 <span class="hl opt">=</span> <span class="hl kwd">f</span><span class="hl opt">(</span>h<span class="hl opt">);</span>
  h2<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;h2 after call to f()&quot;</span><span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Call f(), no return value&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>h<span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;After call to f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.7. C11/HowMany2.cpp</strong></p></div><br class="example-break" /><p>
	Hay unas cuantas cosas nuevas para que pueda hacerse una idea
	mejor de lo que pasa. Primeramente, el <code class="code">string
	name</code> hace de identificador de objeto cuando se imprima
	en la salida.  Puede poner un identificador (normalmente el
	nombre del objeto) en el constructor para que se copie en
	<code class="varname">name</code> utilizando el constructor con un
	<code class="type">string</code> como argumento. Por defecto se crea un
	<code class="type">string</code> vacío. El constructor incrementa
	<code class="varname">objectCount</code> y el destructor lo disminuye,
	igual que en el ejemplo anterior.
      </p><p>
	Lo siguiente es el constructor de copia,
	<code class="function">HowMany2(const HowMany2&amp;)</code>. El
	constructor de copia simplemente crea un objeto a partir de
	otro existente, así que copia en <code class="varname">name</code> el
	identificador del objeto origen, seguido de la palabra
	«copy», y así puede ver de dónde procede.  Si
	mira atentamente, verá que la llamada
	<code class="code">name(h.name)</code> en la lista de inicializadores del
	constructor está llamando al constructor de copia de la clase
	<code class="type">string</code>.
      </p><p>
	Dentro del constructor de copia, se incrementa el contador
	igual que en el constructor normal. Esto quiere decir que
	obtendrá un contador de objetos preciso cuando pase y retorne
	por valor.
      </p><p>
	La función <code class="function">print()</code> se ha modificado para
	imprimir en la salida un mensaje, el identificador del objeto
	y el contador de objetos. Como ahora accede al atributo
	<code class="varname">name</code> de un objeto concreto, ya no
	puede ser un método estático.
      </p><p>
	Dentro de <code class="function">main()</code> puede ver que hay una
	segunda llamada a <code class="function">f()</code>. Sin embargo esta
	llamada utiliza la característica de C para ignorar el valor
	de retorno. Pero ahora que sabe cómo se retorna el valor (es
	decir, código <span class="emphasis"><em>dentro</em></span> de la función que
	maneja el proceso de retorno poniendo el resultado en un lugar
	cuya dirección se pasa como un argumento escondido), podría
	preguntarse qué ocurre cuando se ignora el valor de
	retorno. La salida del programa mostrará alguna luz sobre el
	asunto.
      </p><p>
	Pero antes de mostrar la salida, he aquí un pequeño programa
	que utiliza <code class="classname">iostreams</code> para añadir
	números de línea a cualquier archivo:
      </p><div class="example"><a id="idp7010240"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Linenum.cpp</span>
<span class="hl slc">//{T} Linenum.cpp</span>
<span class="hl slc">// Add line numbers</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot;Usage: linenum file</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
    <span class="hl str">&quot;Adds line numbers to file&quot;</span><span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  string line<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> lines<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span> <span class="hl slc">// Read in entire file</span>
    lines<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>line<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>lines<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() ==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> num <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Number of lines in file determines width:</span>
  <span class="hl kwb">const int</span> width <span class="hl opt">=</span> 
    <span class="hl kwb">int</span><span class="hl opt">(</span><span class="hl kwd">log10</span><span class="hl opt">((</span><span class="hl kwb">double</span><span class="hl opt">)</span>lines<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">())) +</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> lines<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++) {</span>
    cout<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>right<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);</span>
    cout<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span>width<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt; ++</span>num <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) &quot;</span> <span class="hl opt">&lt;&lt;</span> lines<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.8. C11/Linenum.cpp</strong></p></div><br class="example-break" /><p>
	El archivo se pasa a un <code class="type">vector&lt;string&gt;</code>,
	utilizando el mismo código fuente que ha visto
	anteriormente en este libro. Cuando se ponen los números de
	línea, nos gustaría que todas las líneas estuvieran alineadas,
	y esto necesita conocer el número de líneas en el archivo para
	que sea coherente.  Se puede conocer el número de líneas con
	<code class="function">vector::size()</code>, pero lo que realmente
	necesitamos es conocer si hay más líneas de 10, 100, 1000,
	etc.  Si se utiliza el logaritmo en base 10 sobre el número de
	líneas en el archivo, se trunca a un entero y se añade uno al
	valor resultante, eso determinará el ancho máximo en dígitos
	que un número de línea puede tener.
      </p><p>
	Nótese que hay un par de llamadas extrañas dentro del bucle
	<code class="keyword">for</code>: <code class="function">setf()</code> y
	<code class="function">width()</code>. Hay llamadas de
	<code class="classname">ostream</code> que permiten controlar, en este
	caso, la justificación y anchura de la salida. Sin embargo se
	debe llamar cada vez que se imprime línea y por eso están
	dentro del bucle <code class="keyword">for</code>. El Volumen 2 de este libro
	tiene un capítulo entero que explica los
	<code class="classname">iostreams</code> y que cuenta más sobre estas
	llamadas así como otras formas de controlar los
	<code class="classname">iostreams</code>.  </p><p>
	Cuando se aplica <code class="filename">Linenum.cpp</code> a
	<code class="filename">HowMany2.out</code>, resulta:
      </p><pre class="screen">
1) HowMany2()
2)   h: objectCount = 1
3) Entering f()
4) HowMany2(const HowMany2&amp;)
5)   h copy: objectCount = 2
6) x argument inside f()
7)   h copy: objectCount = 2
8) Returning from f()
9) HowMany2(const HowMany2&amp;)
10)   h copy copy: objectCount = 3
11) ~HowMany2()
12)   h copy: objectCount = 2
13) h2 after call to f()
14)   h copy copy: objectCount = 2
15) Call f(), no return value
16) HowMany2(const HowMany2&amp;)
17)   h copy: objectCount = 3
18) x argument inside f()
19)   h copy: objectCount = 3
20) Returning from f()
21) HowMany2(const HowMany2&amp;)
22)   h copy copy: objectCount = 4
23) ~HowMany2()
24)   h copy: objectCount = 3
25) ~HowMany2()
26)   h copy copy: objectCount = 2
27) After call to f()
28) ~HowMany2()
29)   h copy copy: objectCount = 1
30) ~HowMany2()
31)   h: objectCount = 0
</pre><p>
	Como se esperaba, la primera cosa que ocurre es que para
	<code class="varname">h</code> se llama al constructor normal, el cual
	incrementa el contador de objetos a uno. Pero entonces,
	mientras se entra en <code class="function">f()</code>, el compilador
	llama silenciosamente al constructor de copia para hacer el
	paso por valor. Se crea un nuevo objeto, que es copia de
	<code class="varname">h</code> (y por tanto tendrá el identificador
	«h copy») dentro del ámbito de la función
	<code class="function">f()</code>.  Así pues, el contador de objetos se
	incrementa a dos, por cortesía del constructor de copia.
	</p><p>
	La línea ocho indica el principio del retorno de
	<code class="function">f()</code>. Pero antes de que se destruya la
	variable local «h copy» (pues sale de ámbito al
	final de la función), se debe copiar al valor de retorno, que
	es <code class="varname">h2</code>. Por tanto <code class="varname">h2</code>, que
	no estaba creado previamente, se crea de un objeto ya
	existente (la variable local dentro de
	<code class="function">f()</code>) y el constructor de copia vuelve a
	utilizarse en la línea 9. Ahora el identificador de
	<code class="varname">h2</code> es «h copy copy» porque
	copió el identificador de la variable local de
	<code class="function">f()</code>. Cuando se devuelve el objeto, pero
	antes de que la función termine, el contador de objetos se
	incrementa temporalmente a tres, pero la variable local con
	identificador «h copy» se destruye, disminuyendo
	a dos. Después de que se complete la llamada a
	<code class="function">f()</code> en la línea 13, sólo hay dos objetos,
	<code class="varname">h</code> y <code class="varname">h2</code>, y puede
	comprobar, de hecho, que <code class="varname">h2</code> terminó con el
	identificador «h copy copy».
      </p><div class="sect3" title="Objetos temporales"><div class="titlepage"><div><div><h4 class="title"><a id="idp7027584"></a>Objetos temporales</h4></div></div></div><p>
	  En la línea 15 se empieza la llamada a <code class="code">f(h)</code>, y
	  esta vez ignora el valor de retorno. Puede ver que se invoca
	  el constructor de copia en la línea 16, igual que antes,
	  para pasar el argumento.  Y también, igual que antes, en la
	  línea 21 se llama al constructor de copia para el valor de
	  retorno. Pero el constructor de copia necesita una dirección
	  para utilizar como destino (es decir, para trabajar con el
	  puntero <code class="keyword">this</code>). ¿De dónde procede esta dirección?
	</p><p>
	  Esto prueba que el compilador puede crear un objeto temporal
	  cuando lo necesita para evaluar adecuadamente una
	  expresión. En este caso, crea uno que ni siquiera se le ve
	  actuar como destino para el valor ignorado retornado por
	  <code class="function">f()</code>. El tiempo de vida de este objeto
	  temporal es tan corto como sea posible para que el programa
	  no se llene de objetos temporales esperando a ser
	  destruidos, lo cual provocaría la utilización ineficaz de
	  recursos valiosos. En algunos casos, el objeto temporal
	  podría pasarse inmediatamente a otra función, pero en este
	  caso no se necesita después de la llamada a la función, así
	  que en cuanto la función termina, llamando al destructor del
	  objeto local (líneas 23 y 24), el objeto temporal también se
	  destruye (líneas 25 y 26).
	</p><p>
	  Finalmente, de la línea 28 a la línea 31, se destruye el
	  objeto <code class="varname">h2</code>, seguido de
	  <code class="varname">h</code> y el contador de objetos vuelve a cero.
	</p></div></div><div class="sect2" title="11.3.3. El constructor de copia por defecto"><div class="titlepage"><div><div><h3 class="title"><a id="idp7032712"></a>11.3.3. El constructor de copia por defecto</h3></div></div></div><p>
	Como el constructor de copia implementa el paso y retorno por
	valor, es importante que el compilador cree uno en el caso de
	estructuras simples (de hecho, es lo mismo que hace C). Sin
	embargo todo lo que se ha visto es el comportamiento por
	defecto: una copia bit a bit.
      </p><p>
	Cuando se utilizan tipos más complejos, el compilador de C++
	creará un constructor de copia automáticamente si no se implementa
	explícitamente. De nuevo, una copia bit a bit no tiene
	sentido, porque no tiene porqué ser el comportamiento que se
	necesita.
      </p><p>
	He aquí un ejemplo para mostrar el comportamiento más
	inteligente del compilador. Suponga que crea una nueva clase
	compuesta por objetos de varias clases diferentes. A esto se le
	denomina <span class="emphasis"><em>composición</em></span>, y es una de las
	formas en las que se pueden hacer nuevas clases a partir de las
	ya existentes. Ahora desempeñe el papel de un novato que trata
	de resolver un problema rápidamente creando una nueva clase de
	esta manera. No sabe nada sobre los constructores de copia, así
	que no lo implementa. El ejemplo muestra lo que el compilador
	hace cuando crea un constructor de copia por defecto para su nueva
	clase:
      </p><div class="example"><a id="idp7035944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:DefaultCopyConstructor.cpp</span>
<span class="hl slc">// Automatic creation of the copy-constructor</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> WithCC <span class="hl opt">{</span> <span class="hl slc">// With copy-constructor</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Explicit default constructor required:</span>
  <span class="hl kwd">WithCC</span><span class="hl opt">() {}</span>
  <span class="hl kwd">WithCC</span><span class="hl opt">(</span><span class="hl kwb">const</span> WithCC<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;WithCC(WithCC&amp;)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> WoCC <span class="hl opt">{</span> <span class="hl slc">// Without copy-constructor</span>
  string id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">WoCC</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> ident <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) :</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>msg<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() !=</span> <span class="hl num">0</span><span class="hl opt">)</span> cout <span class="hl opt">&lt;&lt;</span> msg <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Composite <span class="hl opt">{</span>
  WithCC withcc<span class="hl opt">;</span> <span class="hl slc">// Embedded objects</span>
  WoCC wocc<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Composite</span><span class="hl opt">() :</span> <span class="hl kwd">wocc</span><span class="hl opt">(</span><span class="hl str">&quot;Composite()&quot;</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    wocc<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span>msg<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Composite c<span class="hl opt">;</span>
  c<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;Contents of c&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Calling Composite copy-constructor&quot;</span>
       <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Composite c2 <span class="hl opt">=</span> c<span class="hl opt">;</span>  <span class="hl slc">// Calls copy-constructor</span>
  c2<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl str">&quot;Contents of c2&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.9. C11/DefaultCopyConstructor.cpp</strong></p></div><br class="example-break" /><p>
	La clase <code class="classname">WithCC</code> contiene un constructor
	de copia, que simplemente anuncia que ha sido llamado, y esto
	demuestra una cuestión interesante: dentro de la clase
	<code class="classname">Composite</code> se crea un objeto tipo
	<code class="classname">WithCC</code> utilizando el constructor por
	defecto. Si <code class="classname">WithCC</code> no tuviera ningún
	constructor, el compilador crearía uno por defecto
	automáticamente, el cual, en este caso, no haría nada. No
	obstante, si añade un constructor por defecto, le está
	diciendo al compilador que ha de utilizar los constructores
	disponibles, por lo que él no crea ningún constructor por
	defecto y se quejará a no ser que explícitamente cree un
	constructor por defecto, como se hizo en
	<code class="classname">WithCC</code>.
      </p><p>
	La clase <code class="classname">WoCC</code> no tiene constructor de
	copia, pero su constructor almacenará un <code class="type">string</code>
	interno imprimible por la función
	<code class="function">print()</code>.  La lista de inicialización del
	constructor (presentado brevemente en el <a class="link" href="#C08" title="8: Constantes">
	Capítulo 8</a> y tratado completamente en el <a class="link" href="#C14" title="14: Herencia y Composición">Capítulo 14</a>) de
	<code class="classname">Composite</code> llama explícitamente a este
	constructor. La razón de esto se verá posteriormente.
	</p><p>
	La clase <code class="classname">Composite</code> tiene objetos
	miembro tanto de <code class="classname">WithCC</code> como de
	<code class="classname">WoCC</code> (note que el objeto interno
	<code class="varname">wocc</code> se inicializa en la lista de
	inicializadores del constructor de
	<code class="classname">Composite</code>, como debe ser), pero no
	están inicializados explícitamente en el constructor de
	copia. Sin embargo un objeto <code class="classname">Composite</code> se
	crea en <code class="function">main()</code> utilizando el constructor
	de copia:
      </p><pre class="programlisting">
Composite c2 <span class="hl opt">=</span> c<span class="hl opt">;</span>
</pre><p>
	El compilador ha creado un constructor de copia para
	<code class="classname">Composite</code> automáticamente, y la salida del
	programa revela la manera en que se crea:
      </p><pre class="programlisting">
Contents of c<span class="hl opt">:</span> <span class="hl kwd">Composite</span><span class="hl opt">()</span>
Calling Composite copy<span class="hl opt">-</span>constructor
<span class="hl kwd">WithCC</span><span class="hl opt">(</span>WithCC<span class="hl opt">&amp;)</span>
Contents of c2<span class="hl opt">:</span> <span class="hl kwd">Composite</span><span class="hl opt">()</span>
</pre><p>
	Para la creación de un constructor de copia para una clase que
	utiliza composición (y herencia, que se trata en el <a class="link" href="#C14" title="14: Herencia y Composición">Capítulo 14</a>), el compilador llama a todos
	los constructores de copia de todos los miembros objeto y de
	las clases base de manera recursiva. Es decir, si el miembro
	también contiene otro objeto, también se llama a su
	constructor de copia. En el ejemplo, el compilador llama al
	constructor de copia de <code class="classname">WithCC</code>. La
	salida muestra que se llama a este constructor. Como
	<code class="classname">WoCC</code> no tiene constructor de copia, el
	compilador crea uno que realiza simplemente una copia bit a
	bit para que el constructor de copia de
	<code class="classname">Composite</code> lo pueda llamar. La llamada a
	<code class="code">Composite::print()</code> en <code class="function">main()</code>
	muestra que esto ocurre, porque el contenido de
	<code class="varname">c2.wocc</code> es idéntico al contenido de
	<code class="varname">c.wocc</code>. El proceso que realiza el
	compilador para crear un constructor de copia se denomina
	<span class="emphasis"><em>inicialización de miembros</em></span>
	(<span class="foreignphrase"><em class="foreignphrase">memberwise initialization</em></span>).
	</p><p>
	Se recomienda definir constructor de copia propio en vez de
	usar el que crea el compilador. Eso garantiza que estará bajo
	su control.
      </p></div><div class="sect2" title="11.3.4. Alternativas a la construcción por copia"><div class="titlepage"><div><div><h3 class="title"><a id="idp7051816"></a>11.3.4. Alternativas a la construcción por copia</h3></div></div></div><p>
	A estas alturas su cabeza debe estar echando humo, y se
	preguntará cómo es posible que pudiera escribir una clase que
	funcionase sin saber nada acerca del constructor de copia. No
	obstante, recuerde que el constructor de copia sólo es necesario
	cuando la clase se pasa <span class="emphasis"><em>por valor</em></span>. Si esto
	no va a ocurrir, entonces no lo necesita.
      </p><div class="sect3" title="Evitando el paso por valor"><div class="titlepage"><div><div><h4 class="title"><a id="idp7053256"></a>Evitando el paso por valor</h4></div></div></div><p>
	  «Pero», puede decir, «si no defino el
	  constructor de copia, el compilador lo creará por mí. ¿Cómo
	  sé que un objeto nunca se pasará por valor?»
	  </p><p>
	  Existe una técnica simple para evitar el paso por valor:
	  declare un constructor de copia <code class="keyword">private</code>.  Ni
	  siquiera necesita definirlo (sólo declararlo), a no ser que
	  un método o una función <code class="keyword">friend</code> necesite realizar un
	  paso por valor. Si el usuario intenta pasar o retornar el
	  objeto por valor, el compilador se quejará con un error
	  porque el constructor de copia es privado. El compilador ya
	  no puede crear un constructor de copia por defecto porque
	  explícitamente ya hay uno creado.  </p><p>
	  He aquí un ejemplo:
	</p><div class="example"><a id="idp7056936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:NoCopyConstruction.cpp</span>
<span class="hl slc">// Preventing copy-construction</span>

<span class="hl kwc">class</span> NoCC <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwd">NoCC</span><span class="hl opt">(</span><span class="hl kwb">const</span> NoCC<span class="hl opt">&amp;);</span> <span class="hl slc">// No definition</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">NoCC</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>NoCC<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  NoCC n<span class="hl opt">;</span>
<span class="hl slc">//! f(n); // Error: copy-constructor called</span>
<span class="hl slc">//! NoCC n2 = n; // Error: c-c called</span>
<span class="hl slc">//! NoCC n3(n); // Error: c-c called</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.10. C11/NoCopyConstruction.cpp</strong></p></div><br class="example-break" /><p>
	  Note la  utilización de la forma más general
	</p><pre class="programlisting">
<span class="hl kwd">NoCC</span><span class="hl opt">(</span><span class="hl kwb">const</span> NoCC<span class="hl opt">&amp;);</span>
</pre><p>
	  utilizando <code class="keyword">const</code>
	</p></div><div class="sect3" title="Funciones que modifican objetos externos"><div class="titlepage"><div><div><h4 class="title"><a id="idp7060224"></a>Funciones que modifican objetos externos</h4></div></div></div><p>
	  La sintaxis de referencias es más agradable que la de
	  punteros, aunque oculte significado al que lea el código
	  fuente. Por ejemplo, en la librería
	  <code class="filename">iostreams</code> existe una versión
	  sobrecargada de la función <code class="function">get()</code> que
	  tiene como argumento un <code class="code">char &amp;</code>, y su
	  cometido es modificar ese argumento y utilizarlo como el
	  valor que retorna <code class="function">get()</code>. No obstante,
	  si lee el código fuente de esta función, no es
	  inmediatamente obvio que la variable que se pasa como
	  argumento vaya a ser modificada:
	</p><pre class="programlisting">
<span class="hl kwb">char</span> c<span class="hl opt">;</span>
cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">(</span>c<span class="hl opt">);</span>
</pre><p>
	  Parece que a la función se le pasa por valor, lo que sugiere
	  que el argumento que se pasa <span class="emphasis"><em>no</em></span> se
	  modifica.
	</p><p>
	  A causa de esto, es probablemente más seguro, desde el punto
	  de vista de mantenimiento del código fuente, utilizar punteros
	  que pasen la dirección del argumento que se desee
	  modificar. Si <span class="emphasis"><em>siempre</em></span> pasa direcciones
	  como referencias constantes <span class="emphasis"><em>excepto</em></span>
	  cuando intenta modificar el argumento que se pasa a través de
	  la dirección, donde pasaría un puntero no constante, entonces
	  es más fácil para el lector seguir el código fuente.
	</p></div></div></div><div class="sect1" title="11.4. Punteros a miembros"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7065616"></a>11.4. Punteros a miembros</h2></div></div></div><p>
      Un puntero es una variable que contiene la dirección de alguna
      ubicación. Se puede cambiar a lo que el puntero apunta en tiempo
      de ejecución. La ubicación a la que apunta puede ser un dato o
      función. El <span class="emphasis"><em>puntero a miembro</em></span> de C++ sigue
      el mismo concepto, excepto que a lo que apunta es una ubicación
      dentro de una clase. Pero surge el dilema de que un puntero
      necesita una dirección, pero no hay «dirección»
      alguna dentro de una clase; La selección de un miembro de una
      clase se realiza mediante un desplazamiento dentro de la
      clase. Pero primero hay que conocer la dirección donde comienza
      un objeto en particular para luego sumarle el desplazamiento y
      así localizar el miembro de la clase. La sintaxis de los
      punteros a miembros requiere que usted seleccione un objeto al
      mismo tiempo que está accediendo al contenido del puntero al
      miembro.
    </p><p>
      Para entender esta sintaxis, considere una estructura simple,
      con un puntero <code class="varname">sp</code> y un objeto
      <code class="varname">so</code>.  Puede seleccionar sus miembros de la
      misma manera que en el siguiente ejemplo:
    </p><div class="example"><a id="idp7068960"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:SimpleStructure.cpp</span>
<span class="hl kwb">struct</span> Simple <span class="hl opt">{</span> <span class="hl kwb">int</span> a<span class="hl opt">; };</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Simple so<span class="hl opt">, *</span>sp <span class="hl opt">= &amp;</span>so<span class="hl opt">;</span>
  sp<span class="hl opt">-&gt;</span>a<span class="hl opt">;</span>
  so<span class="hl opt">.</span>a<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.11. C11/SimpleStructure.cpp</strong></p></div><br class="example-break" /><p>
      Ahora suponga que tiene un puntero normal que se llama
      <code class="varname">ip</code> y que apunta a un entero. Para acceder a
      lo que apunta <code class="varname">ip</code>, ha de estar precedido por
      un '*':
    </p><pre class="programlisting">
<span class="hl opt">*</span>ip<span class="hl opt">=</span><span class="hl num">4</span><span class="hl opt">;</span>
</pre><p>
      Finalmente, se preguntará qué pasa si tiene un puntero que está
      apuntando a algo que está dentro de un objeto, incluso si lo que
      realmente representa es un desplazamiento dentro del objeto. Para
      acceder a lo que está apuntando, debe preceder el puntero con '*'.
      Pero como es un desplazamiento dentro de un objeto, también ha de
      referirse al objeto con el que estamos tratando. Así, el * se
      combina con el objeto. Por tanto, la nueva sintaxis se escribe
      <span class="emphasis"><em>-&gt;*</em></span> para un puntero que apunta a un objeto, y
      <span class="emphasis"><em>.*</em></span> para un objeto o referencia, tal como
      esto:
    </p><pre class="programlisting">
objectPointer<span class="hl opt">-&gt;*</span>pointerToMember <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
object<span class="hl opt">.*</span>pointerToMember <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
</pre><p>
      Pero, ¿cuál es la sintaxis para definir el
      <code class="varname">pointerToMember</code>? Pues como cualquier puntero,
      tiene que decir el tipo al que apuntará, por lo que se
      utilizaría el '*' en la definición. La única diferencia es que
      debe decir a qué clase de objetos apuntará ese atributo
      puntero. Obviamente, esto se consigue con el nombre de la clase
      y el operador de resolución de ámbito. Así,
    </p><pre class="programlisting">
<span class="hl kwb">int</span> ObjectClass<span class="hl opt">::*</span>pointerToMember<span class="hl opt">;</span>
</pre><p>
      define un atributo puntero llamado
      <code class="varname">pointerToMember</code> que apunta a cualquier entero
      dentro de <code class="classname">ObjectClass</code>. También puede
      inicializar el puntero cuando lo defina (o en cualquier otro
      momento):
    </p><pre class="programlisting">
<span class="hl kwb">int</span> ObjectClass<span class="hl opt">::*</span>pointerToMember <span class="hl opt">= &amp;</span>ObjectClass<span class="hl opt">::</span>a<span class="hl opt">;</span>
</pre><p>
      Realmente no existe una «dirección» de
      <code class="code">ObjectClass::a</code> porque se está refiriendo a la clase
      y no a un objeto de esa clase.  Así,
      <code class="code">&amp;ObjectClass::a</code> se puede utilizar sólo con la
      sintaxis de un puntero a miembro.  </p><p>
      He aquí un ejemplo que muestra cómo crear y utilizar punteros a
      atributos:
    </p><div class="example"><a id="idp7077864"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:PointerToMemberData.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Data <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>  
  <span class="hl kwb">int</span> a<span class="hl opt">,</span> b<span class="hl opt">,</span> c<span class="hl opt">;</span> 
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, b = &quot;</span> <span class="hl opt">&lt;&lt;</span> b
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, c = &quot;</span> <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Data d<span class="hl opt">, *</span>dp <span class="hl opt">= &amp;</span>d<span class="hl opt">;</span>
  <span class="hl kwb">int</span> Data<span class="hl opt">::*</span>pmInt <span class="hl opt">= &amp;</span>Data<span class="hl opt">::</span>a<span class="hl opt">;</span>
  dp<span class="hl opt">-&gt;*</span>pmInt <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  pmInt <span class="hl opt">= &amp;</span>Data<span class="hl opt">::</span>b<span class="hl opt">;</span>
  d<span class="hl opt">.*</span>pmInt <span class="hl opt">=</span> <span class="hl num">48</span><span class="hl opt">;</span>
  pmInt <span class="hl opt">= &amp;</span>Data<span class="hl opt">::</span>c<span class="hl opt">;</span>
  dp<span class="hl opt">-&gt;*</span>pmInt <span class="hl opt">=</span> <span class="hl num">49</span><span class="hl opt">;</span>
  dp<span class="hl opt">-&gt;</span><span class="hl kwd">print</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.12. C11/PointerToMemberData.cpp</strong></p></div><br class="example-break" /><p>
      Obviamente, son muy desagradables de utilizar en cualquier lugar
      excepto para caso especiales (que es exactamente para lo que se
      crearon).
    </p><p>
      Además, los punteros a miembro son bastante limitados: pueden
      asignarse solamente a una ubicación específica dentro de una
      clase.  No podría, por ejemplo, incrementarlos o compararlos tal
      como puede hacer con punteros normales.
    </p><div class="sect2" title="11.4.1. Funciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp7080704"></a>11.4.1. Funciones</h3></div></div></div><p>
	Un ejercicio similar se produce con la sintaxis de puntero a
	miembro para métodos. Un puntero a una función (presentado al
	final del <a class="link" href="#C03-punteros-a-funcion" title="3.10. Direcciones de función">Capítulo
	3</a>) se define como:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl opt">(*</span>fp<span class="hl opt">)(</span><span class="hl kwb">float</span><span class="hl opt">);</span>
</pre><p>
	Los paréntesis que engloban a <code class="code">(*fb)</code> son
	necesarios para que fuercen la evaluación de la definición
	apropiadamente. Sin ellos sería una función que devuelve un
	<code class="type">int*</code>.
      </p><p>
	Los paréntesis también desempeñan un papel importante cuando se
	definen y utilizan punteros a métodos. Si tiene una función
	dentro de una clase, puede definir un puntero a ese método
	insertando el nombre de la clase y el operador de resolución de
	ámbito en una definición habitual de puntero a función:
      </p><div class="example"><a id="idp7084200"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:PmemFunDefinition.cpp</span>
<span class="hl kwc">class</span> Simple2 <span class="hl opt">{</span> 
<span class="hl kwc">public</span><span class="hl opt">:</span> 
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl kwb">int</span> <span class="hl opt">(</span>Simple2<span class="hl opt">::*</span>fp<span class="hl opt">)(</span><span class="hl kwb">float</span><span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl opt">(</span>Simple2<span class="hl opt">::*</span>fp2<span class="hl opt">)(</span><span class="hl kwb">float</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">= &amp;</span>Simple2<span class="hl opt">::</span>f<span class="hl opt">;</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  fp <span class="hl opt">= &amp;</span>Simple2<span class="hl opt">::</span>f<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.13. C11/PmemFunDefinition.cpp</strong></p></div><br class="example-break" /><p>
	En la definición de <code class="varname">fp2</code> puede verse que el
	puntero a un método puede inicializarse cuando se crea, o en
	cualquier otro momento. A diferencia de las funciones no son
	miembros, el <code class="literal">&amp;</code> <span class="emphasis"><em>no</em></span>
	es opcional para obtener la dirección de un método. Sin
	embargo, se puede dar el identificador de la función sin la
	lista de argumentos, porque la sobrecarga se resuelve por el
	tipo de puntero a miembro.
      </p><div class="sect3" title="Un ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp7087184"></a>Un ejemplo</h4></div></div></div><p>
	  Lo interesante de un puntero es que se puede cambiar el
	  valor del mismo para apuntar a otro lugar en tiempo de
	  ejecución, lo cual proporciona mucha flexibilidad en la
	  programación porque a través de un puntero se puede cambiar
	  el <span class="emphasis"><em>comportamiento</em></span> del programa en
	  tiempo de ejecución. Un puntero a miembro no es distinto; le
	  permite elegir un miembro en tiempo de
	  ejecución. Típicamente, sus clases sólo tendrán métodos
	  visibles públicamente (los atributos normalmente se
	  consideran parte de la implementación que va oculta), de
	  modo que el siguiente ejemplo elige métodos en tiempo de
	  ejecución.
	</p><div class="example"><a id="idp7089112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:PointerToMemberFunction.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Widget <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::g()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::h()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::i()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Widget w<span class="hl opt">;</span>
  Widget<span class="hl opt">*</span> wp <span class="hl opt">= &amp;</span>w<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl opt">(</span>Widget<span class="hl opt">::*</span>pmem<span class="hl opt">)(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">= &amp;</span>Widget<span class="hl opt">::</span>h<span class="hl opt">;</span>
  <span class="hl opt">(</span>w<span class="hl opt">.*</span>pmem<span class="hl opt">)(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">(</span>wp<span class="hl opt">-&gt;*</span>pmem<span class="hl opt">)(</span><span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.14. C11/PointerToMemberFunction.cpp</strong></p></div><br class="example-break" /><p>
	  Por supuesto, no es razonable esperar que el usuario casual
	  cree expresiones tan complejas. Si el usuario necesita
	  manipular directamente un puntero a miembro, los
	  <code class="keyword">typedef</code> vienen al rescate. Para dejar aún mejor las
	  cosas, puede utilizar un puntero a función como parte del
	  mecanismo interno de la implementación. He aquí un ejemplo
	  que utiliza un puntero a miembro <span class="emphasis"><em>dentro</em></span>
	  de la clase. Todo lo que el usuario necesita es pasar un
	  número para elegir una función.
	  <sup>[<a id="idp7092480" href="#ftn.idp7092480" class="footnote">69</a>]</sup>
	</p><div class="example"><a id="idp7092848"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:PointerToMemberFunction2.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Widget <span class="hl opt">{</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::g()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::h()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::i()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> cnt <span class="hl opt">=</span> <span class="hl num">4</span> <span class="hl opt">};</span>
  <span class="hl kwb">void</span> <span class="hl opt">(</span>Widget<span class="hl opt">::*</span>fptr<span class="hl opt">[</span>cnt<span class="hl opt">])(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Widget</span><span class="hl opt">() {</span>
    fptr<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] = &amp;</span>Widget<span class="hl opt">::</span>f<span class="hl opt">;</span> <span class="hl slc">// Full spec required</span>
    fptr<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] = &amp;</span>Widget<span class="hl opt">::</span>g<span class="hl opt">;</span>
    fptr<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">] = &amp;</span>Widget<span class="hl opt">::</span>h<span class="hl opt">;</span>
    fptr<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">] = &amp;</span>Widget<span class="hl opt">::</span>i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">select</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">int</span> j<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&lt;</span> <span class="hl num">0</span> <span class="hl opt">||</span> i <span class="hl opt">&gt;=</span> cnt<span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
    <span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">-&gt;*</span>fptr<span class="hl opt">[</span>i<span class="hl opt">])(</span>j<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> cnt<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Widget w<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> w<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    w<span class="hl opt">.</span><span class="hl kwd">select</span><span class="hl opt">(</span>i<span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 11.15. C11/PointerToMemberFunction2.cpp</strong></p></div><br class="example-break" /><p>
	  En la interfaz de la clase y en <code class="function">main()</code>,
	  puede observar que toda la implementación, funciones
	  incluidas, es privada. El código ha de pedir el
	  <code class="function">count()</code> de las funciones. De esta
	  manera, el que implementa la clase puede cambiar la cantidad
	  de funciones en la implementación por debajo sin que afecte
	  al código que utilice la clase.
	</p><p>
	  La inicialización de los punteros a miembro en el
	  constructor puede parecer redundante. ¿No debería ser capaz
	  de poner
	</p><pre class="programlisting">
fptr<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] = &amp;</span>g<span class="hl opt">;</span>
</pre><p>
	  porque el nombre <code class="varname">g</code> es un método, el cual
	  está en el ámbito de la clase? El problema aquí es que no
	  sería conforme a la sintaxis de puntero a miembro.  Así todo
	  el mundo, incluido el compilador, puede imaginarse qué está
	  pasando.  De igual forma, cuando se accede al contenido del
	  puntero a miembro, parece que
	</p><pre class="programlisting">
<span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">-&gt;*</span>fptr<span class="hl opt">[</span>i<span class="hl opt">])(</span>j<span class="hl opt">);</span>
</pre><p>
	  también es redundante; <code class="keyword">this</code> parece redundante. La
	  sintaxis necesita que un puntero a miembro siempre esté
	  ligado a un objeto cuando se accede al contenido al que
	  apunta.
	</p></div></div></div><div class="sect1" title="11.5. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7099888"></a>11.5. Resumen</h2></div></div></div><p>
      Los punteros en C++ son casi idénticos a los punteros en C, lo
      cual es bueno. De otra manera, gran cantidad de código C no
      compilaría en C++. Los únicos errores en tiempo de compilación
      serán aquéllos que realicen asignaciones peligrosas. Esos
      errores pueden eliminarse con una simple (pero explícito!)
      molde.
    </p><p>
      C++ también añade la <span class="emphasis"><em>referencia</em></span> de Algol y
      Pascal, que es como un puntero constante que el compilador hace
      que se acceda directamente al contenido al que apunta. Una
      referencia contiene una dirección, pero se trata como un
      objeto. Las referencias son esenciales para una sintaxis clara con
      la sobrecarga de operadores (el tema del siguiente capítulo), pero
      también proporcionan mejoras sintácticas para el paso y retorno de
      objetos en funciones normales.
    </p><p>
      El constructor de copia coge una referencia a un objeto
      existente del mismo tipo que el argumento, y lo utiliza para la
      creación de un nuevo objeto a partir del que existente. El
      compilador llama automáticamente al constructor de copia cuando
      pasa o retorna un objeto por valor. Aunque el compilador crea un
      constructor de copia automáticamente, si cree que su clase
      necesita uno, debería definirlo para asegurar un comportamiento
      apropiado. Si no desea que el objeto se pase o retorne por
      valor, debería crear un constructor de copia privado.
      </p><p>
      Los punteros a miembro tienen la misma capacidad que los
      punteros normales: puede elegir una región de memoria particular
      (atributo o método) en tiempo de ejecución. Los punteros a
      miembro funcionan con los miembros de una clase en vez de
      variables o funciones globales.  Ofrecen la suficiente
      flexibilidad para cambiar el comportamiento en tiempo de
      ejecución.
    </p></div><div class="sect1" title="11.6. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7104712"></a>11.6. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Convierta el fragmento de código «bird &amp;
	    rock» del principio de este capítulo a un programa
	    C (utilizando estructuras para los tipos de datos), y que
	    compile.  Ahora intente compilarlo con un compilador de
	    C++ y vea qué ocurre.
	</p></li><li class="listitem"><p>
	    Coja los fragmentos de código al principio de la sección
	  titulada «Referencias en C++» y póngalos en un
	  <code class="function">main()</code>.  Añada sentencias para imprimir
	  en la salida para que pueda demostrar usted mismo que las
	  referencias son como punteros que se dereferencian
	  automáticamente.
	</p></li><li class="listitem"><p>
	  Escriba un programa en el cual intente (1) Crear una
	  referencia que no esté inicializada cuando se crea. (2)
	  Cambiar una referencia para que se refiera a otro objeto
	  después de que se haya inicializado. (3) Crear una
	  referencia nula.
	  </p></li><li class="listitem"><p>
	  Escriba una función que tome un puntero por argumento,
	  modifique el contenido de lo que el apunta puntero, y
	  retorne ese mismo contenido como si de una referencia se
	  tratara.
	</p></li><li class="listitem"><p>
	  Cree una nueva clase con algunos métodos, y haga que el
	  objeto sea apuntado por el argumento del Ejercicio 4. Haga
	  que el puntero pasado como argumento y algunos métodos sean
	  constantes y pruebe que sólo puede llamar a los métodos
	  constantes dentro de su función. Haga que el argumento de su
	  función sea una referencia en vez de un puntero.
	</p></li><li class="listitem"><p>
	  Coja los fragmentos de código al principio de la sección
	  «referencias a puntero» y conviértalos en un
	  programa.
	</p></li><li class="listitem"><p>
	  Cree una función que tome como argumento una referencia a
	  un puntero que apunta a otro puntero y modifique ese argumento. En
	  <code class="function">main()</code>, llame a la función.
	</p></li><li class="listitem"><p>
	  Cree una función que toma un argumento del tipo
	  <code class="type">char&amp;</code> y lo modifica. En el
	  <code class="function">main()</code> imprima a la salida una variable
	  <code class="type">char</code>, llame a su función con esa variable e
	  imprima la variable de nuevo para demostrar que ha sido cambiada.
	  ¿Cómo afecta esto a la legibilidad del programa?
	</p></li><li class="listitem"><p>
	  Escriba una clase que tiene un método constante y otra que
	  no lo tiene. Escriba tres funciones que toman un objeto de
	  esa clase como argumento; la primera lo toma por valor, la
	  segunda lo toma por referencia y la tercera lo toma mediante
	  una referencia constante. Dentro de las funciones, intente
	  llamar a las dos funciones de su clase y explique los
	  resultados.
	</p></li><li class="listitem"><p>
	    (Algo difícil) Escriba una función simple que toma un
	    entero como argumento, incrementa el valor, y lo retorna. En
	    <code class="function">main()</code>, llame a su función. Intente que el
	    compilador genere el código ensamblador e intente entender cómo
	    los argumentos se pasan y se retornan, y cómo las variables locales
	    se colocan en la pila.
	  </p></li><li class="listitem"><p>
	  Escriba una función que tome como argumentos un
	  <code class="type">char</code>, <code class="type">int</code>, <code class="type">float</code> y
	  <code class="type">double</code>. Genere el código ensamblador con su
	  compilador y busque las instrucciones que apilan los
	  argumentos en la pila antes de efectuar la llamada a
	  función.
	</p></li><li class="listitem"><p>
	  Escriba una función que devuelva un <code class="type">double</code>.
	  Genere el código ensamblador y explique cómo se retorna el
	  valor.
	</p></li><li class="listitem"><p>
	    Genere el código ensamblador de
	    <code class="filename">PassingBigStructures.cpp</code>. Recorra y
	    desmitifique la manera en que su compilador genera el
	    código para pasar y devolver estructuras grandes.
	  </p></li><li class="listitem"><p>
	  Escriba una simple función recursiva que disminuya su
	  argumento y retorne cero si el argumento llega a cero, o
	  en otro caso que se llame a sí misma. Genere el código
	  ensamblador para esta función y explique la forma en el
	  compilador implementa la recurrencia.
	</p></li><li class="listitem"><p>
	  Escriba código para demostrar que el compilador genera un
	  constructor de copia automáticamente en caso de que no lo
	  haga el programador. Demuestre que el constructor de copia
	  generado por el compilador realiza una copia bit a bit de
	  tipos primitivos y llama a los constructores de copia de los
	  tipos definidos por el usuario.
	</p></li><li class="listitem"><p>
	  Escriba una clase en la que el constructor de copia se
	  anuncia a sí mismo a través de
	  <code class="varname">cout</code>. Ahora cree una función que pasa un
	  objeto de su nueva clase por valor y otra más que crea un
	  objeto local de su nueva clase y lo devuelve por valor.
	  Llame a estas funciones para demostrar que el constructor de
	  copia es, en efecto, llamado cuando se pasan y retornan
	  objetos por valor.
	</p></li><li class="listitem"><p>
	  Cree un objeto que contenga un <code class="type">double*</code>.  Que el
	  constructor inicialice el <code class="type">double*</code> llamando a
	  <code class="code">new double</code> y asignando un valor. Entonces, que
	  el destructor imprima el valor al que apunta, asigne ese
	  valor a -1, llame a <code class="keyword">delete</code> para liberar la memoria
	  y ponga el puntero a cero. Ahora cree una función que tome
	  un objeto de su clase por valor, y llame a esta función
	  desde <code class="function">main()</code>. ¿Qué ocurre?  Solucione
	  el problema escribiendo un constructor de copia.
	</p></li><li class="listitem"><p>
	  Cree una clase con un constructor que parezca un constructor
	  de copia, pero que tenga un argumento adicional con un valor
	  por defecto. Muestre que a pesar de eso se utiliza como
	  constructor de copia.
	</p></li><li class="listitem"><p>
	  Cree una clase con un constructor de copia que se anuncie a
	  sí mismo (es decir que imprima por la salida que ha sido
	  llamado).  Haga una segunda clase que contenga un objeto
	  miembro de la primera clase, pero no cree un constructor de
	  copia. Demuestre que el constructor de copia, que genera
	  automáticamente el compilador en la segunda clase, llama al
	  constructor de copia de la primera.
	</p></li><li class="listitem"><p>
	  Cree una clase muy simple, y una función que devuelva un
	  objeto de esa clase por valor. Cree una segunda función que
	  tome una referencia de un objeto de su clase. Llame a la
	  segunda función pasándole como argumento una llamada a la
	  primera función, y demuestre que la segunda función debe
	  utilizar una referencia constante como argumento.
	</p></li><li class="listitem"><p>
	  Cree una clase simple sin constructor de copia, y una
	  función simple que tome un objeto de esa clase por
	  valor. Ahora cambie su clase añadiéndole una declaración
	  (sólo declare, no defina) privada de un constructor de
	  copia. Explique lo que ocurre cuando compila la función.
	</p></li><li class="listitem"><p>
	  Este ejercicio crea una alternativa a la utilización del
	  constructor de copia. Cree una clase
	  <code class="classname">X</code> y declare (pero no defina) un
	  constructor de copia privado. Haga una función
	  <code class="function">clone()</code> pública como un método
	  constante que devuelve una copia del objeto creado
	  utilizando <code class="keyword">new</code>. Ahora escriba una función que tome
	  como argumento un <code class="type">const X&amp;</code> y clone una
	  copia local que puede modificarse. El inconveniente de esto
	  es que es el programador el responsable de destruir
	  explícitamente el objeto clonado (utilizando
	  <code class="keyword">delete</code>) cuando haya terminado con él.
	</p></li><li class="listitem"><p>
	  Explique qué está mal en <code class="filename">Mem.cpp</code> y
	  <code class="filename">MemTest.cpp</code> del <a class="link" href="#C07" title="7: Sobrecarga de funciones y argumentos por defecto">Capítulo 7</a>. Solucione el problema.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un <code class="type">double</code> y una
	  función <code class="function">print()</code> que imprima el
	  <code class="type">double</code>. Cree punteros a miembro tanto
	  para el atributo como al método de su clase. Cree un objeto
	  de su clase y un puntero a ese objeto, y manipule ambos
	  elementos de la clase a través de los punteros a miembro,
	  utilizando tanto el objeto como el puntero al objeto.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un array de enteros. ¿Puede
	  recorrer el array mediante un puntero a miembro?
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">PmemFunDefinition.cpp</code>
	  añadiendo un método <code class="function">f()</code> sobrecargado
	  (puede determinar la lista de argumentos que cause la
	  sobrecarga).  Ahora cree un segundo puntero a miembro,
	  asígnelo a la versión sobrecargada de
	  <code class="function">f()</code>, y llame al método a través del
	  puntero. ¿Cómo sucede la resolución de la función
	  sobrecargada en este caso?
	</p></li><li class="listitem"><p>
	  Empiece con la función
	  <code class="filename">FunctionTable.cpp</code> del <a class="link" href="#C03" title="3: C en C++">Capítulo 3</a>. Cree una clase que contenga
	  un <code class="type">vector</code> de punteros a funciones, con métodos
	  <code class="function">add()</code> y <code class="function">remove()</code>
	  para añadir y quitar punteros a función. Añada una función
	  denominada <code class="function">run()</code> que recorra el
	  <code class="type">vector</code> y llame a todas la funciones.
	</p></li><li class="listitem"><p>
	  Modifique el Ejercicio 27 para que funcione con punteros a
	  métodos.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp7092480" href="#idp7092480" class="para">69</a>] </sup>Gracias a Owen Mortensen por este ejemplo</p></div></div></div><div class="chapter" title="12: Sobrecarga de operadores"><div class="titlepage"><div><div><h2 class="title"><a id="C12"></a>12: Sobrecarga de operadores</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp7152320">12.1. Precaución y tranquilidad </a></span></dt><dt><span class="sect1"><a href="#idp7156592">12.2. Sintaxis</a></span></dt><dt><span class="sect1"><a href="#idp7167168">12.3. Operadores sobrecargables </a></span></dt><dt><span class="sect1"><a href="#idp7319424">12.4. Operadores no miembros</a></span></dt><dt><span class="sect1"><a href="#idp7339880">12.5. Sobrecargar la asignación</a></span></dt><dt><span class="sect1"><a href="#idp7414776">12.6. Conversión automática de tipos</a></span></dt><dt><span class="sect1"><a href="#idp7475640">12.7. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp7477136">12.8. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      La sobrecarga de operadores es solamente «azúcar sintáctico», lo que
      significa que es simplemente otra manera de invocar funciones.
    </p></div><p>
    La diferencia es que los argumentos para estas funciones no aparecen entre paréntesis,
    sino que rodean o siguen a los caracteres que siempre pensó como operadores
    inalterables.
  </p><p>
    Hay dos diferencias entre el uso de un operador y el de una llamada a función
    normal. La sintaxis es diferente: un operador es a menudo «llamado»
    situándolo entre (o después de) los argumentos.  La segunda diferencia es que el
    compilador determina qué «función» llamar. Por ejemplo, si está usando el
    operador <code class="literal">+</code> con argumentos de punto flotante, el compilador
    «llama» a la función para realizar una suma de punto flotante (esta
    «llamada» normalmente consiste en insertar código en linea, o una
    instrucción de punto flotante del procesador). Si usa el operador <code class="literal">+</code> con
    un número de punto flotante y un entero, el compilador «llama» a una
    función especial para convertir el <code class="type">int</code> a un <code class="type">float</code>,y entonces
    «llama» a la función de suma en punto flotante.
  </p><p>
    Sin embargo, en C++ es posible definir nuevos operadores que trabajen con clases. Esta
    definición es exactamente como la definición de una función ordinaria, excepto que el
    nombre de la función consiste en la palabra reservada <code class="keyword">operator</code> seguida del
    operador. Siendo esta la única diferencia, el operador se convierte en una función
    como otra cualquiera que el compilador llama cuando ve el prototipo adecuado.
  </p><div class="sect1" title="12.1. Precaución y tranquilidad"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7152320"></a>12.1. Precaución y tranquilidad </h2></div></div></div><p>
      Es tentador convertirse en un super-entusiasta de la sobrecarga de operadores. Son
      un juguete divertido, al principio. Pero recuerde que es sólo un endulzamiento
      sintáctico, otra manera de llamar a una función. Mirándolo desde esa perspectiva, no
      hay razón para sobrecargar un operador excepto si eso hace al código implicado con
      la clase más sencillo e intuitivo de escribir y especialmente de leer. (Recuerde, el
      código se lee mucho más que se escribe). Si éste no es el caso no se moleste.
    </p><p>
      Otra reacción cmún frente al uso de la sobrecarga de operadores es el pánico: de
      repente, los operadores de C pierden su significado familiar.«¡Todo ha
      cambiado y mi código C por completo hará cosas diferentes!». Esto no es
      verdad. Todos los operadores usados en expresiones que contienen solo tipos de datos
      incorporados no pueden ser cambiados. Nunca podrá sobrecargar operadores así:
    </p><pre class="programlisting">
<span class="hl num">1</span> <span class="hl opt">&lt;&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span>
</pre><p>
      para que se comporten de forman diferente, o que
    </p><pre class="programlisting">
<span class="hl num">1.414</span> <span class="hl opt">&lt;&lt;</span> <span class="hl num">2</span><span class="hl opt">;</span>
</pre><p>
	  tenga significado. Sólo una expresión que contenga tipos de datos definidos por el
	  usuario podrá tener operadores sobrecargados.
    </p></div><div class="sect1" title="12.2. Sintaxis"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7156592"></a>12.2. Sintaxis</h2></div></div></div><p>
      Definir un operador sobrecargado es como definir una función, pero el nombre de esa
      función es <code class="function">operator@</code> en la que <code class="literal">@</code> representa el
      operador que está siendo sobrecargado. El número de argumentos en la lista de
      argumentos del operador sobrecargado depende de dos factores:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		  Si es un operador unario (un argumento) o un operador binario (dos argumentos)
		</p></li><li class="listitem"><p>
		  Si el operador está definido como una función global (un argumento para los
		  unarios, dos para los binarios) o un método (cero argumentos para los unarios y
		  uno para los binarios. En este último caso el objeto (<code class="keyword">this</code>) se
		  convierte en el argumento del lado izquierdo al operador).
		</p></li></ol></div><p>
      He aquí una pequeña clase que muestra la sintaxis de la sobrecarga de operadores:
    </p><div class="example"><a id="idp7161272"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:OperatorOverloadingSyntax.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Integer <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Integer</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;operator+&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>i <span class="hl opt">+</span> rv<span class="hl opt">.</span>i<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  Integer<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">+=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;operator+=&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    i <span class="hl opt">+=</span> rv<span class="hl opt">.</span>i<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;built-in types:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">,</span> j <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">,</span> k <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">;</span>
  k <span class="hl opt">+=</span> i <span class="hl opt">+</span> j<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;user-defined types:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Integer <span class="hl kwd">ii</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">jj</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">kk</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
  kk <span class="hl opt">+=</span> ii <span class="hl opt">+</span> jj<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.1. C12/OperatorOverloadingSyntax.cpp</strong></p></div><br class="example-break" /><p>
      Los dos operadores sobrecargados están definidos como métodos en línea que imprimen
      un mensaje al ser llamados. El único argumento de estas funciones miembro será el
      que aparezca del lado derecho del operador binario. Los operadores unarios no tienen
      argumentos cuando se definen como métodos. El método es invocado por el objeto de la
      parte izquierda del operador.
    </p><p>
      Para los operadores incondicionales (los condicionales generalmente devuelven un
      valor booleano), generalmente se deseará devolver un objeto o una referencia del
      mismo tipo que está operando, si los dos argumentos son del mismo tipo. (Si no son
      del mismo tipo, la interpretación de lo que debería pasar es responsabilidad
      suya). De esta manera, se pueden construir expresiones tan complicadas como la
      siguiente:
    </p><pre class="programlisting">
kk <span class="hl opt">+=</span> ii <span class="hl opt">+</span> jj<span class="hl opt">;</span>
</pre><p>
      La expresión <code class="function">operator+</code> crea un nuevo objeto
      <code class="classname">Integer</code> (un temporario) que se usa como argumento
      <code class="varname">rv</code> para el operador <code class="function">operator+=</code>. Este objeto
      temporal se destruye tan pronto como deja de necesitarse.
    </p></div><div class="sect1" title="12.3. Operadores sobrecargables"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7167168"></a>12.3. Operadores sobrecargables </h2></div></div></div><p>
      Aunque puede sobrecargar casi todos los operadores disponibles en C, el uso de
      operadores sobrecargados es bastante restrictivo. En particular, no puede combinar
      operadores que actualmente no tienen significado en C (como <code class="literal">**</code> para
      representar la potencia), no puede cambiar la precedencia de evaluación de operadores,
      y tampoco el número de argumentos requeridos por un operador. Estas restricciones
      existen para prevenir que la creación de nuevos operadores ofusquen el significado
	  en lugar de clarificarlo.
	</p><p>
      Las siguientes dos subsecciones muestran ejemplos de todos los operadores normales,
      sobrecargados en la forma habitual.
    </p><div class="sect2" title="12.3.1. Operadores unarios"><div class="titlepage"><div><div><h3 class="title"><a id="idp7169408"></a>12.3.1. Operadores unarios</h3></div></div></div><p>
		El siguiente ejemplo muestra la sintaxis para sobrecargar todos los operadores
		unarios, en ambas formas: como funciones globales (funciones <code class="keyword">friend</code>, no
		métodos) y como métodos. Estas expandirán la clase <code class="classname">Integer</code>
		vista previamente y añadirá una nueva clase <code class="classname">byte</code>. El
		significado de sus operadores particulares dependerá de la forma en que los use,
		pero considere a los programadores del grupo antes de hacer algo inesperado.  He
		aquí un catálogo de todas las funciones unarias:
      </p><div class="example"><a id="idp7171696"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:OverloadingUnaryOperators.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Non-member functions:</span>
<span class="hl kwc">class</span> Integer <span class="hl opt">{</span>
  <span class="hl kwb">long</span> i<span class="hl opt">;</span>
  Integer<span class="hl opt">*</span> <span class="hl kwd">This</span><span class="hl opt">() {</span> <span class="hl kwa">return this</span><span class="hl opt">; }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Integer</span><span class="hl opt">(</span><span class="hl kwb">long</span> ll <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ll<span class="hl opt">) {}</span>
  <span class="hl slc">// No side effects takes const&amp; argument:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">~(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">*</span>
    <span class="hl kwc">operator</span><span class="hl opt">&amp;(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">!(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl slc">// Side effects have non-const&amp; argument:</span>
  <span class="hl slc">// Prefix:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">++(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl slc">// Postfix:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">++(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">);</span>
  <span class="hl slc">// Prefix:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">--(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl slc">// Postfix:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">--(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">);</span>
<span class="hl opt">};</span>

<span class="hl slc">// Global operators:</span>
<span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;+Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> a<span class="hl opt">;</span> <span class="hl slc">// Unary + has no effect</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;-Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(-</span>a<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer <span class="hl kwc">operator</span><span class="hl opt">~(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(~</span>a<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">&amp;(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> a<span class="hl opt">.</span><span class="hl kwd">This</span><span class="hl opt">();</span> <span class="hl slc">// &amp;a is recursive!</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">!(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;!Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl opt">!</span>a<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl slc">// Prefix; return incremented value</span>
<span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;++Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span>i<span class="hl opt">++;</span>
  <span class="hl kwa">return</span> a<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl slc">// Postfix; return the value before increment:</span>
<span class="hl kwb">const</span> Integer <span class="hl kwc">operator</span><span class="hl opt">++(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Integer++</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  Integer <span class="hl kwd">before</span><span class="hl opt">(</span>a<span class="hl opt">.</span>i<span class="hl opt">);</span>
  a<span class="hl opt">.</span>i<span class="hl opt">++;</span>
  <span class="hl kwa">return</span> before<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl slc">// Prefix; return decremented value</span>
<span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">--(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;--Integer</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span>i<span class="hl opt">--;</span>
  <span class="hl kwa">return</span> a<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl slc">// Postfix; return the value before decrement:</span>
<span class="hl kwb">const</span> Integer <span class="hl kwc">operator</span><span class="hl opt">--(</span>Integer<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Integer--</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  Integer <span class="hl kwd">before</span><span class="hl opt">(</span>a<span class="hl opt">.</span>i<span class="hl opt">);</span>
  a<span class="hl opt">.</span>i<span class="hl opt">--;</span>
  <span class="hl kwa">return</span> before<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// Show that the overloaded operators work:</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Integer a<span class="hl opt">) {</span>
  <span class="hl opt">+</span>a<span class="hl opt">;</span>
  <span class="hl opt">-</span>a<span class="hl opt">;</span>
  <span class="hl opt">~</span>a<span class="hl opt">;</span>
  Integer<span class="hl opt">*</span> ip <span class="hl opt">= &amp;</span>a<span class="hl opt">;</span>
  <span class="hl opt">!</span>a<span class="hl opt">;</span>
  <span class="hl opt">++</span>a<span class="hl opt">;</span>
  a<span class="hl opt">++;</span>
  <span class="hl opt">--</span>a<span class="hl opt">;</span>
  a<span class="hl opt">--;</span>
<span class="hl opt">}</span>

<span class="hl slc">// Member functions (implicit &quot;this&quot;):</span>
<span class="hl kwc">class</span> Byte <span class="hl opt">{</span>
  <span class="hl kwb">unsigned char</span> b<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Byte</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span> bb <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">b</span><span class="hl opt">(</span>bb<span class="hl opt">) {}</span>
  <span class="hl slc">// No side effects: const member function:</span>
  <span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;+Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte <span class="hl kwc">operator</span><span class="hl opt">-()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;-Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(-</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte <span class="hl kwc">operator</span><span class="hl opt">~()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(~</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  Byte <span class="hl kwc">operator</span><span class="hl opt">!()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;!Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(!</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">&amp;() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Side effects: non-const member function:</span>
  <span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl slc">// Prefix</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;++Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    b<span class="hl opt">++;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Byte++</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    Byte <span class="hl kwd">before</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
    b<span class="hl opt">++;</span>
    <span class="hl kwa">return</span> before<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">--() {</span> <span class="hl slc">// Prefix</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;--Byte</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl opt">--</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte <span class="hl kwc">operator</span><span class="hl opt">--(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Byte--</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    Byte <span class="hl kwd">before</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
    <span class="hl opt">--</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> before<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span>Byte b<span class="hl opt">) {</span>
  <span class="hl opt">+</span>b<span class="hl opt">;</span>
  <span class="hl opt">-</span>b<span class="hl opt">;</span>
  <span class="hl opt">~</span>b<span class="hl opt">;</span>
  Byte<span class="hl opt">*</span> bp <span class="hl opt">= &amp;</span>b<span class="hl opt">;</span>
  <span class="hl opt">!</span>b<span class="hl opt">;</span>
  <span class="hl opt">++</span>b<span class="hl opt">;</span>
  b<span class="hl opt">++;</span>
  <span class="hl opt">--</span>b<span class="hl opt">;</span>
  b<span class="hl opt">--;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Integer a<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
  Byte b<span class="hl opt">;</span>
  <span class="hl kwd">g</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.2. C12/OverloadingUnaryOperators.cpp</strong></p></div><br class="example-break" /><p>
		Las funciones están agrupadas de acuerdo a la forma en que se pasan los
		argumentos.  Más tarde se darán unas cuantas directrices de cómo pasar y devolver
		argumentos. Las clases expuestas anteriormente (y las que siguen en la siguiente
		sección) son las típicas, así que empiece con ellas como un patrón cuando
		sobrecargue sus propios operadores.
      </p><div class="sect3" title="Incremento y decremento"><div class="titlepage"><div><div><h4 class="title"><a id="idp7178872"></a>Incremento y decremento</h4></div></div></div><p>
		  Los operadores de incremento<code class="literal">++</code> y de decremento <code class="literal">--</code>
		  provocan un conflicto porque querrá ser capaz de llamar diferentes funciones
		  dependiendo de si aparecen antes (prefijo) o después (postfijo) del objeto sobre
		  el que actúan. La solución es simple, pero la gente a veces lo encuentra un poco
		  confusa inicialmente. Cuando el compilador ve, por ejemplo, <code class="code">++a</code> (un
		  pre-incremento), genera una llamada al <code class="function">operator++(a)</code> pero
		  cuando ve <code class="literal">a++</code>, genera una llamada a <code class="function">operator++(a,
		  int)</code>. Así es como el compilador diferencia entre los dos tipos,
		  generando llamadas a funciones sobrecargadas diferentes. En
		  <code class="filename">OverloadingUnaryOperators.cpp</code> para la versión de funciones
		  miembro, si el compilador ve <code class="code">++b</code>, genera una llamada a
		  <code class="function">B::operator++()</code>y si ve <code class="code">b++</code>genera una llamada a
		  <code class="function">B::operator++(int)</code>.
		</p><p>
		  Todo lo que el usuario ve es que se llama a una función diferente para las
		  versiones postfija y prefija. Internamente, sin embargo, las dos llamadas de
		  funciones tienen diferentes firmas, así que conectan con dos cuerpos
		  diferentes. El compilador pasa un valor constante ficticio para el argumento
		  <code class="type">int</code> (el cual nunca se proporcionada por un identificador porque el
		  valor nunca se usa) para generar las diferentes firmas para la versión postfija.
		</p></div></div><div class="sect2" title="12.3.2. Operadores binarios"><div class="titlepage"><div><div><h3 class="title"><a id="idp7185952"></a>12.3.2. Operadores binarios</h3></div></div></div><p>
		Los siguientes listados repiten el ejemplo de
		<code class="filename">OverloadingUnaryOperators.cpp</code> para los operadores binarios
		presentándole un ejemplo de todos los operadores que pueda querer sobrecargar. De
		nuevo se muestran ambas versiones, la global y la de método.
      </p><div class="example"><a id="idp7187288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:Integer.h</span>
<span class="hl slc">// Non-member overloaded operators</span>
<span class="hl ppc">#ifndef INTEGER_H</span>
<span class="hl ppc">#define INTEGER_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl slc">// Non-member functions:</span>
<span class="hl kwc">class</span> Integer <span class="hl opt">{</span> 
  <span class="hl kwb">long</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Integer</span><span class="hl opt">(</span><span class="hl kwb">long</span> ll <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ll<span class="hl opt">) {}</span>
  <span class="hl slc">// Operators that create new, modified value:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">*(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">/(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">%(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span>^<span class="hl opt">(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">&amp;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">|(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Integer
    <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl slc">// Assignments modify &amp; return lvalue:</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">+=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">-=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">*=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">/=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">%=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span>^<span class="hl opt">=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&amp;=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">|=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> Integer<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl slc">// Conditional operators return true/false:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">&gt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">&gt;=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">&amp;&amp;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">int</span>
    <span class="hl kwc">operator</span><span class="hl opt">||(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">);</span>
  <span class="hl slc">// Write the contents to an ostream:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> os <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">; }</span>
<span class="hl opt">};</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// INTEGER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 12.3. C12/Integer.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp7191744"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:Integer.cpp {O}</span>
<span class="hl slc">// Implementation of overloaded operators</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Integer.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">+</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">-</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">*(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">*</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">/(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>i <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;divide by zero&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">/</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">%(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>i <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;modulo by zero&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">%</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span>^<span class="hl opt">(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i ^ right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">&amp;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">&amp;</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">|(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">|</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
             <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl kwb">const</span> Integer
  <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
             <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">&gt;&gt;</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl slc">// Assignments modify &amp; return lvalue:</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">+=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">-=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">-=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">*=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">/=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>i <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;divide by zero&quot;</span><span class="hl opt">);</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">/=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">%=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>i <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;modulo by zero&quot;</span><span class="hl opt">);</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">%=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span>^<span class="hl opt">=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i ^<span class="hl opt">=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&amp;=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">&amp;=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">|=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                    <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">|=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                     <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">&gt;&gt;=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
Integer<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;=(</span>Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
                     <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
   <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>left <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
   left<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
   <span class="hl kwa">return</span> left<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl slc">// Conditional operators return true/false:</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">==</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">!=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">&lt;</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
              <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">&gt;</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">&lt;=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;=(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">&gt;=</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&amp;&amp;(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">&amp;&amp;</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">||(</span><span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> left<span class="hl opt">,</span>
               <span class="hl kwb">const</span> Integer<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> left<span class="hl opt">.</span>i <span class="hl opt">||</span> right<span class="hl opt">.</span>i<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.4. C12/Integer.cpp</strong></p></div><br class="example-break" /><div class="example"><a id="idp7200752"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:IntegerTest.cpp</span>
<span class="hl slc">//{L} Integer</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Integer.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;IntegerTest.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">(</span>Integer<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> Integer<span class="hl opt">&amp;</span> c2<span class="hl opt">) {</span>
  <span class="hl slc">// A complex expression:</span>
  c1 <span class="hl opt">+=</span> c1 <span class="hl opt">*</span> c2 <span class="hl opt">+</span> c2 <span class="hl opt">%</span> c1<span class="hl opt">;</span>
  <span class="hl ppc">#define TRY(OP) \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;c1 = &quot;</span><span class="hl ppc">; c1.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;, c2 = &quot;</span><span class="hl ppc">; c2.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;;  c1 &quot;</span><span class="hl ppc"> #OP</span> <span class="hl pps">&quot; c2 produces &quot;</span><span class="hl ppc">; \</span>
<span class="hl ppc">    (c1 OP c2).print(out); \</span>
<span class="hl ppc">    out &lt;&lt; endl;</span>
  <span class="hl kwd">TRY</span><span class="hl opt">(+)</span> <span class="hl kwd">TRY</span><span class="hl opt">(-)</span> <span class="hl kwd">TRY</span><span class="hl opt">(*)</span> <span class="hl kwd">TRY</span><span class="hl opt">(/)</span>
  <span class="hl kwd">TRY</span><span class="hl opt">(%)</span> <span class="hl kwd">TRY</span><span class="hl opt">(</span>^<span class="hl opt">)</span> <span class="hl kwd">TRY</span><span class="hl opt">(&amp;)</span> <span class="hl kwd">TRY</span><span class="hl opt">(|)</span>
  <span class="hl kwd">TRY</span><span class="hl opt">(&lt;&lt;)</span> <span class="hl kwd">TRY</span><span class="hl opt">(&gt;&gt;)</span> <span class="hl kwd">TRY</span><span class="hl opt">(+=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(-=)</span>
  <span class="hl kwd">TRY</span><span class="hl opt">(*=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(/=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(%=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(</span>^<span class="hl opt">=)</span>
  <span class="hl kwd">TRY</span><span class="hl opt">(&amp;=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(|=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(&gt;&gt;=)</span> <span class="hl kwd">TRY</span><span class="hl opt">(&lt;&lt;=)</span>
  <span class="hl slc">// Conditionals:</span>
  <span class="hl ppc">#define TRYC(OP) \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;c1 = &quot;</span><span class="hl ppc">; c1.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;, c2 = &quot;</span><span class="hl ppc">; c2.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;;  c1 &quot;</span><span class="hl ppc"> #OP</span> <span class="hl pps">&quot; c2 produces &quot;</span><span class="hl ppc">; \</span>
<span class="hl ppc">    out &lt;&lt; (c1 OP c2); \</span>
<span class="hl ppc">    out &lt;&lt; endl;</span>
  <span class="hl kwd">TRYC</span><span class="hl opt">(&lt;)</span> <span class="hl kwd">TRYC</span><span class="hl opt">(&gt;)</span> <span class="hl kwd">TRYC</span><span class="hl opt">(==)</span> <span class="hl kwd">TRYC</span><span class="hl opt">(!=)</span> <span class="hl kwd">TRYC</span><span class="hl opt">(&lt;=)</span>
  <span class="hl kwd">TRYC</span><span class="hl opt">(&gt;=)</span> <span class="hl kwd">TRYC</span><span class="hl opt">(&amp;&amp;)</span> <span class="hl kwd">TRYC</span><span class="hl opt">(||)</span>
<span class="hl opt">}</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;friend functions&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Integer <span class="hl kwd">c1</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">),</span> <span class="hl kwd">c2</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">);</span>
  <span class="hl kwd">h</span><span class="hl opt">(</span>c1<span class="hl opt">,</span> c2<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.5. C12/IntegerTest.cpp</strong></p></div><br class="example-break" /><div class="example"><a id="idp7203400"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:Byte.h</span>
<span class="hl slc">// Member overloaded operators</span>
<span class="hl ppc">#ifndef BYTE_H</span>
<span class="hl ppc">#define BYTE_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl slc">// Member functions (implicit &quot;this&quot;):</span>
<span class="hl kwc">class</span> Byte <span class="hl opt">{</span> 
  <span class="hl kwb">unsigned char</span> b<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Byte</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span> bb <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">b</span><span class="hl opt">(</span>bb<span class="hl opt">) {}</span>
  <span class="hl slc">// No side effects: const member function:</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">+</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">-</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">*(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">*</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">/(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>b <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;divide by zero&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">/</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">%(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>b <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;modulo by zero&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">%</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span>^<span class="hl opt">(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b ^ right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">&amp;(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">&amp;</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">|(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">|</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">&lt;&lt;</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">const</span> Byte
    <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>b <span class="hl opt">&gt;&gt;</span> right<span class="hl opt">.</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Assignments modify &amp; return lvalue.</span>
  <span class="hl slc">// operator= can only be a member function:</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl slc">// Handle self-assignment:</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    b <span class="hl opt">=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">+=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">-=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">-=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">*=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">/=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>b <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;divide by zero&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">/=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">%=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>right<span class="hl opt">.</span>b <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;modulo by zero&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">%=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span>^<span class="hl opt">=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b ^<span class="hl opt">=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&amp;=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">&amp;=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">|=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">|=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">&gt;&gt;=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">== &amp;</span>right<span class="hl opt">) {</span><span class="hl com">/* self-assignment */</span><span class="hl opt">}</span>
    b <span class="hl opt">&lt;&lt;=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Conditional operators return true/false:</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">==</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">!=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">&lt;</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">&gt;</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">&lt;=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">&gt;=</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">&amp;&amp;(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">&amp;&amp;</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">||(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> b <span class="hl opt">||</span> right<span class="hl opt">.</span>b<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Write the contents to an ostream:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;0x&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>hex <span class="hl opt">&lt;&lt;</span> <span class="hl kwb">int</span><span class="hl opt">(</span>b<span class="hl opt">) &lt;&lt;</span> std<span class="hl opt">::</span>dec<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// BYTE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 12.6. C12/Byte.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp7208312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:ByteTest.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Byte.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;ByteTest.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwb">void</span> <span class="hl kwd">k</span><span class="hl opt">(</span>Byte<span class="hl opt">&amp;</span> b1<span class="hl opt">,</span> Byte<span class="hl opt">&amp;</span> b2<span class="hl opt">) {</span>
  b1 <span class="hl opt">=</span> b1 <span class="hl opt">*</span> b2 <span class="hl opt">+</span> b2 <span class="hl opt">%</span> b1<span class="hl opt">;</span>

  <span class="hl ppc">#define TRY2(OP) \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;b1 = &quot;</span><span class="hl ppc">; b1.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;, b2 = &quot;</span><span class="hl ppc">; b2.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;;  b1 &quot;</span><span class="hl ppc"> #OP</span> <span class="hl pps">&quot; b2 produces &quot;</span><span class="hl ppc">; \</span>
<span class="hl ppc">    (b1 OP b2).print(out); \</span>
<span class="hl ppc">    out &lt;&lt; endl;</span>

  b1 <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span> b2 <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(+)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(-)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(*)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(/)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(%)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(</span>^<span class="hl opt">)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&amp;)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(|)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(&lt;&lt;)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&gt;&gt;)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(+=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(-=)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(*=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(/=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(%=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(</span>^<span class="hl opt">=)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(&amp;=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(|=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&gt;&gt;=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&lt;&lt;=)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(=)</span> <span class="hl slc">// Assignment operator</span>

  <span class="hl slc">// Conditionals:</span>
  <span class="hl ppc">#define TRYC2(OP) \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;b1 = &quot;</span><span class="hl ppc">; b1.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;, b2 = &quot;</span><span class="hl ppc">; b2.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;;  b1 &quot;</span><span class="hl ppc"> #OP</span> <span class="hl pps">&quot; b2 produces &quot;</span><span class="hl ppc">; \</span>
<span class="hl ppc">    out &lt;&lt; (b1 OP b2); \</span>
<span class="hl ppc">    out &lt;&lt; endl;</span>

  b1 <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span> b2 <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl kwd">TRYC2</span><span class="hl opt">(&lt;)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(&gt;)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(==)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(!=)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(&lt;=)</span>
  <span class="hl kwd">TRYC2</span><span class="hl opt">(&gt;=)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(&amp;&amp;)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(||)</span>

  <span class="hl slc">// Chained assignment:</span>
  Byte b3 <span class="hl opt">=</span> <span class="hl num">92</span><span class="hl opt">;</span>
  b1 <span class="hl opt">=</span> b2 <span class="hl opt">=</span> b3<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;member functions:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Byte <span class="hl kwd">b1</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">),</span> <span class="hl kwd">b2</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">);</span>
  <span class="hl kwd">k</span><span class="hl opt">(</span>b1<span class="hl opt">,</span> b2<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.7. C12/ByteTest.cpp</strong></p></div><br class="example-break" /><p>
		Puede ver que <code class="literal">operator=</code> solo puede ser un método. Esto se explica después.
      </p><p>
		Fíjese que todos los operadores de asignación tienen código para comprobar la auto
		asignación; ésta es una directiva general. En algunos casos esto no es necesario;
		por ejemplo, con <code class="function">operator+=</code> a menudo querrá decir <code class="code">A +=
		A</code> y sumar <code class="varname">A</code> a sí mismo. El lugar más importante para
		situar las comprobaciones para la auto asignación es
		<code class="function">operator=</code> porque con objetos complicados pueden ocurrir
		resultados desastrosos. (En algunos casos es correcto, pero siempre debería
		tenerlo en mente cuando escriba <code class="function">operator=</code>).
      </p><p>
		Todos los operadores mostrados en los dos ejemplos previos son sobrecargados para
		manejar un tipo simple. También es posible sobrecargar operadores para manejar
		tipos compuestos, de manera que pueda sumar manzanas a naranjas, por
		ejemplo. Antes de que empiece una sobrecarga exhaustiva de operadores, no
		obstante, debería mirar la sección de conversión automática de tipos más adelante
		en este capitulo. A menudo, una conversión de tipos en el lugar adecuado puede
		ahorrarle un montón de operadores sobrecargados.
      </p></div><div class="sect2" title="12.3.3. Argumentos y valores de retorno"><div class="titlepage"><div><div><h3 class="title"><a id="idp7215800"></a>12.3.3. Argumentos y valores de retorno</h3></div></div></div><p>
		Puede parecer un poco confuso inicialmente cuando lea los archivos
		<code class="filename">OverloadingUnaryOperators.cpp</code>, <code class="filename">Integer.h</code>
		y <code class="filename">Byte.h</code> y vea todas las maneras diferentes en que se pasan y
		devuelven los argumentos. Aunque usted pueda pasar y devolver argumentos de la
		forma que prefiera, las decisiones en estos ejemplos no se han realizado al
		azar. Siguen un patrón lógico, el mismo que querrá usar en la mayoría de sus
		decisiones.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
			Como con cualquier argumento de función, si sólo necesita leer el argumento y
			no cambiarlo, lo usual es pasarlo como una referencia
			<code class="keyword">const</code>. Normalmente operaciones aritméticas (como <code class="literal">+</code> y
			<code class="literal">-</code>, etc.) y booleanas no cambiarán sus argumentos, así que
			pasarlas como una referencia <code class="keyword">const</code> es lo que veré
			mayoritariamente. Cuando la función es un método, esto se traduce en una
			método <code class="keyword">const</code>. Sólo con los operadores de asignación (como
			<code class="literal">+=</code>) y <code class="function">operator=</code>, que cambian el argumento de
			la parte derecha, no es el argumento derecho una constante, pero todavía se
			pasa en dirección porque será cambiado.
		  </p></li><li class="listitem"><p>
			El tipo de valor de retorno que debe seleccionar depende del significado
			esperado del operador. (Otra vez, puede hacer cualquier cosa que desee con los
			argumentos y con los valores de retorno). Si el efecto del operador es
			producir un nuevo valor, necesitará generar un nuevo objeto como el valor de
			retorno. Por ejemplo, <code class="function">Integer::operator+</code> debe producir un
			objeto <code class="classname">Integer</code> que es la suma de los operandos. Este
			objeto se devuelve por valor como una constante así que el resultado no se
			puede modificar como un «valor izquierdo».
		  </p></li><li class="listitem"><p>
			Todas los operadores de asignación modifican el valor izquierdo. Para permitir
			que el resultado de la asignación pueda ser usado en expresiones encadenadas,
			como <code class="code">a = b = c</code>, se espera que devuelva una referencia al mismo
			valor izquierdo que acaba de ser modificado. Pero ¿debería ser esta referencia
			<code class="keyword">const</code> o no <code class="keyword">const</code>?. Aunque lea <code class="code">a = b = c</code> de
			izquierda a derecha, el compilador la analiza de derecha a izquierda, así que
			no está obligado a devolver una referencia no <code class="keyword">const</code> para soportar
			asignaciones encadenadas. Sin embargo, la gente a veces espera ser capaz de
			realizar una operación sobre el elemento de acaba de ser asignado, como
			<code class="code">(a = b).func();</code> para llamar a <code class="function">func</code> de
			<code class="varname">a</code> después de asignarle <code class="varname">b</code>. De ese modo,
			el valor de retorno para todos los operadores de asignación debería ser una
			referencia no <code class="keyword">const</code> para el valor izquierdo.
		  </p></li><li class="listitem"><p>
			Para los operadores lógicos, todo el mundo espera obtener en el peor de los
			casos un tipo <code class="type">int</code>, y en el mejor un tipo <code class="type">bool</code>. (Las
			librerías desarrolladas antes de que los compiladores de C++ soportaran el
			tipo incorporado <code class="type">bool</code> usaban un tipo <code class="type">int</code> o un
			<code class="type">typedef</code> equivalente).
		  </p></li></ol></div><p>
		Los operadores de incremento y decremento presentan un dilema a causa de las
		versiones postfija y prefija. Ambas versiones cambian el objeto y por tanto no
		pueden tratar el objeto como un <code class="keyword">const</code>. La versión prefija devuelve el
		valor del objeto después de cambiarlo, así que usted espera recuperar el objeto
		que fue cambiado. De este modo, con la versión prefija puede simplemente revolver
		<code class="varname">*this</code> como una referencia. Se supone que la versión postfija
		devolverá el valor antes de que sea cambiado, luego está forzado a crear un objeto
		separado para representar el valor y devolverlo. Así que con la versión postfija
		debe devolverlo por valor si quiere mantener el significado esperado. (Advierta
		que a veces encontrará operadores de incremento y decremento que devuelven un
		<code class="type">int</code> o un <code class="type">bool</code> para indicar, por ejemplo, que un objeto
		preparado para moverse a través de una lista está al final de ella). Ahora la
		pregunta es: ¿Debería éste devolverse como una referencia <code class="keyword">const</code> o no
		<code class="keyword">const</code>?. Si permite que el objeto sea modificado y alguien escribe
		<code class="code">(a++).func()</code>, <code class="function">func</code> operará en la propia
		<code class="varname">a</code>, pero con <code class="code">(++a).func()</code>,
		<code class="function">func</code>opera en el objeto temporal devuelto por el operador
		postfijo <code class="function">operator++</code>. Los objetos temporales son automáticamente
		<code class="keyword">const</code>, así que esto podría ser rechazado por el compilador, pero en favor
		de la consistencia tendría más sentido hacerlos ambos <code class="keyword">const</code> como hemos
		hecho aquí. O puede elegir hacer la versión prefija no <code class="keyword">const</code> y la postfija
		<code class="keyword">const</code>. Debido a la variedad de significados que puede darle a los
		operadores de incremento y decremento, deben considerarse en términos del caso
		individual.
      </p><div class="sect3" title="Retorno por valor como constante"><div class="titlepage"><div><div><h4 class="title"><a id="idp7241592"></a>Retorno por valor como constante</h4></div></div></div><p>
		  El retorno por valor como una constante puede parecer un poco sutil al
		  principio, así que es digno de un poco más de explicación. Considere el operador
		  binario <code class="function">operator+</code>. Si lo ve en una expresión como
		  <code class="code">f(a+b)</code>, el resultado de <code class="code">a+b</code> se convierte en un objeto
		  temporal que se usará en la llamada a <code class="function">f()</code>. Debido a que es
		  temporal, es automáticamente <code class="keyword">const</code>, así que aunque, de forma
		  explicita, haga el valor de retorno <code class="keyword">const</code> o no, no tendrá efecto.
		</p><p>
		  Sin embargo, también es posible mandar un mensaje al valor de retorno de
		  <code class="code">a+b</code>, mejor que simplemente pasarlo a la función. Por ejemplo, puede
		  decir <code class="code">(a+b).g()</code> en la que <code class="function">g()</code> es algún método
		  de <code class="classname">Integer</code>, en este caso. Haciendo el valor de retorno
		  <code class="keyword">const</code>, está indicando que sólo un método <code class="keyword">const</code> puede ser
		  llamado sobre ese valor de retorno. Esto es correcto desde el punto de vista del
		  <code class="keyword">const</code>, porque le evita almacenar información potencialmente importante
		  en un objeto que probablemente será destruido.
		</p></div><div class="sect3" title="Optimización del retorno"><div class="titlepage"><div><div><h4 class="title"><a id="idp7248696"></a>Optimización del retorno</h4></div></div></div><p>
		  Advierta la manera que se usa cuando se crean nuevos objetos para ser devueltos
		  por valor. En <code class="function">operator+</code>, por ejemplo:
		</p><pre class="programlisting">
<span class="hl kwa">return</span> <span class="hl kwd">Integer</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">+</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
</pre><p>
		  Esto puede parecer en principio como una «función de llamada a un
		  constructor» pero no lo es. La sintaxis es la de un objeto temporal; la
		  sentencia dice «crea un objeto <code class="classname">Integer</code> temporal y
		  desvuélvelo». A causa de esto, puede pensar que el resultado es el mismo
		  que crear un objeto local con nombre y devolverlo. Sin embargo, es algo
		  diferente. Si en su lugar escribiera:
		</p><pre class="programlisting">
Integer <span class="hl kwd">tmp</span><span class="hl opt">(</span>left<span class="hl opt">.</span>i <span class="hl opt">+</span> right<span class="hl opt">.</span>i<span class="hl opt">);</span>
    <span class="hl kwa">return</span> tmp<span class="hl opt">;</span>
</pre><p>
		  sucederían tres cosas. La primera, se crea el objeto <code class="varname">tmp</code>
		  incluyendo la llamada a su constructor. La segunda, el constructor de copia
		  duplica <code class="varname">tmp</code> en la localización del valor de retorno
		  externo. La tercera, se llama al destructor para <code class="varname">tmp</code> cuando
		  sale del ámbito.
		</p><p>
		  En contraste, la aproximación de «devolver un objeto temporal»
		  funciona de manera bastante diferente. Cuando el compilador ve eso, sabe que no
		  tiene otra razón para crearlo mas que para devolverlo. El compilador aprovecha
		  la ventaja que ofrece para construir el objeto directamente en la localización
		  del valor de retorno externo a la función. Esto necesita de una sola y ordinaria
		  llamada al constructor (la llamada al constructor de copia no es necesaria) y no
		  hay llamadas al destructor porque nunca se crea un objeto local. De esta manera,
		  no requiere nada más que el conocimiento del programador, y es
		  significativamente mas eficiente. Esto a menudo se llama optimización del valor
		  de retorno.
		</p></div></div><div class="sect2" title="12.3.4. Operadores poco usuales"><div class="titlepage"><div><div><h3 class="title"><a id="idp7254600"></a>12.3.4. Operadores poco usuales</h3></div></div></div><p>
		Varios operadores adicionales tienen una forma ligeramente diferente de ser
		sobrecargados.
	  </p><p>
		El subíndice, <code class="function">operator[]</code> debe ser un método y precisa de un
		único argumento. Dado que <code class="function">operator[]</code> implica que el objeto
		que está siendo utilizado como un array, a menudo devolverá una referencia de este
		operador, así que puede ser convenientemente usado en la parte derecha de un signo
		de igualdad. Este operador es muy comúnmente sobrecargado; verá ejemplos en el
		resto del libro.
      </p><p>
		Los operadores <code class="keyword">new</code> y <code class="keyword">delete</code> controlan la reserva dinámica de
		almacenamiento y se pueden sobrecargar de muchas maneras diferentes. Este tema se
		cubre en el capitulo 13. 
      </p><div class="sect3" title="El operador coma"><div class="titlepage"><div><div><h4 class="title"><a id="idp7258432"></a>El operador coma</h4></div></div></div><p>
		  El operador coma se llama cuando aparece después de un objeto del tipo para el
		  que está definido. Sin embargo, «<code class="function">operator,</code>» no
		  se llama para listas de argumentos de funciones, sólo para objetos fuera de ese
		  lugar separados por comas. No parece haber un montón de usos prácticos para este
		  operador, solo es por consistencia del lenguaje. He aquí un ejemplo que muestra
		  como la función coma se puede llamar cuando aparece antes de un objeto, así como
		  después:
	</p><div class="example"><a id="idp7260360"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:OverloadingOperatorComma.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> After <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">const</span> After<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">,(</span><span class="hl kwb">const</span> After<span class="hl opt">&amp;)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;After::operator,()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Before <span class="hl opt">{};</span>

Before<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">,(</span><span class="hl kwb">int</span><span class="hl opt">,</span> Before<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Before::operator,()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">return</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  After a<span class="hl opt">,</span> b<span class="hl opt">;</span>
  a<span class="hl opt">,</span> b<span class="hl opt">;</span>  <span class="hl slc">// Operator comma called</span>

  Before c<span class="hl opt">;</span>
  <span class="hl num">1</span><span class="hl opt">,</span> c<span class="hl opt">;</span>  <span class="hl slc">// Operator comma called</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.8. C12/OverloadingOperatorComma.cpp</strong></p></div><br class="example-break" /><p>
		  Las funciones globales permiten situar la coma antes del objeto en cuestión. El
		  uso mostrado es bastante oscuro y cuestionable. Probablemente podría una lista
		  separada por comas como parte de una expresión más complicada, es demasiado
		  refinado en la mayoría de las ocasiones.
		</p></div><div class="sect3" title="El operador -&gt;"><div class="titlepage"><div><div><h4 class="title"><a id="idp7263152"></a>El operador -&gt;</h4></div></div></div><p>
		  El operador <code class="literal">-&gt;</code> se usa generalmente cuando quiere hacer que un
		  objeto parezca un puntero. Este tipo de objeto se suele llamar <span class="emphasis"><em>puntero
		  inteligente</em></span> o más a menudo por su equivalente en inglés:
		  <span class="emphasis"><em>smart pointer</em></span>. Resultan especialmente utiles si quiere
		  «envolver» una clase con un puntero para hacer que ese puntero sea
		  seguro, o en la forma común de un <code class="classname">iterador</code>, que es un
		  objeto que se mueve a través de una <code class="classname">colección</code> o
		  <code class="classname">contenedor</code> de otros objetos y los selecciona de uno en
		  uno cada vez, sin proporcionar acceso directo a la implementación del
		  contenedor. (A menudo encontrará iteradores y contenedores en las librerías de
		  clases, como en la Biblioteca Estándar de C++, descrita en el volumen 2 de este
		  libro).
		</p><p>
		  El operador de indirección de punteros (*) debe ser un método. Tiene otras
		  restricciones atípicas: debe devolver un objeto (o una referencia a un objeto)
		  que también tenga un operador de indirección de punteros, o debe devolver un
		  puntero que pueda ser usado para encontrar a lo que apunta la flecha del
		  operador de indireción de punteros. He aquí un ejemplo simple:
		</p><div class="example"><a id="idp7267584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:SmartPointer.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Obj <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> i<span class="hl opt">,</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> j<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Static member definitions:</span>
<span class="hl kwb">int</span> Obj<span class="hl opt">::</span>i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
<span class="hl kwb">int</span> Obj<span class="hl opt">::</span>j <span class="hl opt">=</span> <span class="hl num">11</span><span class="hl opt">;</span>

<span class="hl slc">// Container:</span>
<span class="hl kwc">class</span> ObjContainer <span class="hl opt">{</span>
  vector<span class="hl opt">&lt;</span>Obj<span class="hl opt">*&gt;</span> a<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">add</span><span class="hl opt">(</span>Obj<span class="hl opt">*</span> obj<span class="hl opt">) {</span> a<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>obj<span class="hl opt">); }</span>
  <span class="hl kwc">friend class</span> SmartPointer<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> SmartPointer <span class="hl opt">{</span>
  ObjContainer<span class="hl opt">&amp;</span> oc<span class="hl opt">;</span>
  <span class="hl kwb">int</span> index<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">SmartPointer</span><span class="hl opt">(</span>ObjContainer<span class="hl opt">&amp;</span> objc<span class="hl opt">) :</span> <span class="hl kwd">oc</span><span class="hl opt">(</span>objc<span class="hl opt">) {</span>
    index <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Return value indicates end of list:</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl slc">// Prefix</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> oc<span class="hl opt">.</span>a<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">())</span> <span class="hl kwa">return false</span><span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>oc<span class="hl opt">.</span>a<span class="hl opt">[++</span>index<span class="hl opt">] ==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return false</span><span class="hl opt">;</span>
    <span class="hl kwa">return true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix</span>
    <span class="hl kwa">return</span> <span class="hl kwc">operator</span><span class="hl opt">++();</span> <span class="hl slc">// Use prefix version</span>
  <span class="hl opt">}</span>
  Obj<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">-&gt;()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>oc<span class="hl opt">.</span>a<span class="hl opt">[</span>index<span class="hl opt">] !=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Zero value &quot;</span>
      <span class="hl str">&quot;returned by SmartPointer::operator-&gt;()&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> oc<span class="hl opt">.</span>a<span class="hl opt">[</span>index<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> sz <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
  Obj o<span class="hl opt">[</span>sz<span class="hl opt">];</span>
  ObjContainer oc<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    oc<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(&amp;</span>o<span class="hl opt">[</span>i<span class="hl opt">]);</span> <span class="hl slc">// Fill it up</span>
  SmartPointer <span class="hl kwd">sp</span><span class="hl opt">(</span>oc<span class="hl opt">);</span> <span class="hl slc">// Create an iterator</span>
  <span class="hl kwa">do</span> <span class="hl opt">{</span>
    sp<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Pointer dereference operator call</span>
    sp<span class="hl opt">-&gt;</span><span class="hl kwd">g</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">while</span><span class="hl opt">(</span>sp<span class="hl opt">++);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.9. C12/SmartPointer.cpp</strong></p></div><br class="example-break" /><p>
		  La clase <code class="classname">Obj</code> define los objetos que son manipulados en
		  este programa. Las funciones <code class="function">f()</code> y <code class="function">g()</code>
		  simplemente escriben en pantalla los valores interesantes usando miembros de
		  datos estáticos. Los punteros a estos objetos son almacenados en el interior de
		  los contenedores del tipo <code class="classname">ObjContainer</code> usando su función
		  <code class="function">add()</code>. <code class="classname">ObjContanier</code> parece un array
		  de punteros, pero advertirá que no hay forma de traer de nuevo los punteros. Sin
		  embargo, <code class="classname">SmartPointer</code> se declara como una clase
		  <code class="classname">friend</code>, así que tiene permiso para mirar dentro del
		  contenedor. La clase <code class="classname">SmartPointer</code> se parece mucho a un
		  puntero inteligente - puede moverlo hacia adelante usando
		  <code class="function">operator++</code> (también puede definir un
		  <code class="function">operator--</code>, no pasará del final del contenedor al que
		  apunta, y genera (a través del operador de indireccion de punteros) el valor al
		  que apunta. Advierta que <code class="classname">SmartPointer</code> está hecho a medida
		  sobre el contenedor para el que se crea; a diferencia de un puntero normal, no
		  hay punteros inteligentes de «propósito general». Aprenderá más
		  sobre los punteros inteligentes llamados «iteradores» en el último
		  capitulo de este libro y en el volumen 2 (descargable desde FIXME:url
		  www. BruceEckel. com).
		</p><p>
		  En <code class="function">main()</code>, una vez que el contenedor <code class="varname">oc</code>
		  se rellena con objetos <code class="classname">Obj</code> se crea un <code class="code">SmartPointer
		  sp</code>. La llamada al puntero inteligente sucede en las expresiones:
	</p><pre class="programlisting">
sp<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">();</span>    <span class="hl slc">// Llamada al puntero inteligente</span>
     sp<span class="hl opt">-&gt;</span><span class="hl kwd">g</span><span class="hl opt">();</span>
</pre><p>
		  Aquí, incluso aunque <code class="varname">sp</code> no tiene métodos
		  <code class="function">f()</code> y <code class="function">g()</code>, el operador de indirección
		  de punteros automáticamente llama a esas funciones para <code class="type">Obj*</code> que es
		  devuelto por <code class="function">SmartPointer::operator-&gt;</code>. El compilador
		  realiza todas las comprobaciones pertinentes para asegurar que la llamada a
		  función funciona de forma correcta.
		</p><p>
		  Aunque la mecánica subyacente de los operadores de indirección de punteros es
		  más compleja que la de los otros operadores, el objetivo es exactamente el
		  mismo: proporcionar una sintaxis más conveniente para los usuarios de sus
		  clases.
		</p></div><div class="sect3" title="Un operador anidado"><div class="titlepage"><div><div><h4 class="title"><a id="idp7281728"></a>Un operador anidado</h4></div></div></div><p>
		  Es más común ver un puntero inteligente o un clase iteradora anidada dentro de
		  la clase a la que sirve. Se puede reescribir el ejemplo anterior para anidar
		  <code class="classname">SmartPointer</code> dentro de
		  <code class="classname">ObjContainer</code> así:
	</p><div class="example"><a id="idp7283096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:NestedSmartPointer.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Obj <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> i<span class="hl opt">,</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> j<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Static member definitions:</span>
<span class="hl kwb">int</span> Obj<span class="hl opt">::</span>i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
<span class="hl kwb">int</span> Obj<span class="hl opt">::</span>j <span class="hl opt">=</span> <span class="hl num">11</span><span class="hl opt">;</span>

<span class="hl slc">// Container:</span>
<span class="hl kwc">class</span> ObjContainer <span class="hl opt">{</span>
  vector<span class="hl opt">&lt;</span>Obj<span class="hl opt">*&gt;</span> a<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">add</span><span class="hl opt">(</span>Obj<span class="hl opt">*</span> obj<span class="hl opt">) {</span> a<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>obj<span class="hl opt">); }</span>
  <span class="hl kwc">class</span> SmartPointer<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> SmartPointer<span class="hl opt">;</span>
  <span class="hl kwc">class</span> SmartPointer <span class="hl opt">{</span>
    ObjContainer<span class="hl opt">&amp;</span> oc<span class="hl opt">;</span>
    <span class="hl kwb">unsigned int</span> index<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">SmartPointer</span><span class="hl opt">(</span>ObjContainer<span class="hl opt">&amp;</span> objc<span class="hl opt">) :</span> <span class="hl kwd">oc</span><span class="hl opt">(</span>objc<span class="hl opt">) {</span>
      index <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Return value indicates end of list:</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl slc">// Prefix</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> oc<span class="hl opt">.</span>a<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">())</span> <span class="hl kwa">return false</span><span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>oc<span class="hl opt">.</span>a<span class="hl opt">[++</span>index<span class="hl opt">] ==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return false</span><span class="hl opt">;</span>
      <span class="hl kwa">return true</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix</span>
      <span class="hl kwa">return</span> <span class="hl kwc">operator</span><span class="hl opt">++();</span> <span class="hl slc">// Use prefix version</span>
    <span class="hl opt">}</span>
    Obj<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">-&gt;()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>oc<span class="hl opt">.</span>a<span class="hl opt">[</span>index<span class="hl opt">] !=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Zero value &quot;</span>
        <span class="hl str">&quot;returned by SmartPointer::operator-&gt;()&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> oc<span class="hl opt">.</span>a<span class="hl opt">[</span>index<span class="hl opt">];</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  <span class="hl slc">// Function to produce a smart pointer that </span>
  <span class="hl slc">// points to the beginning of the ObjContainer:</span>
  SmartPointer <span class="hl kwd">begin</span><span class="hl opt">() {</span> 
    <span class="hl kwa">return</span> <span class="hl kwd">SmartPointer</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> sz <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
  Obj o<span class="hl opt">[</span>sz<span class="hl opt">];</span>
  ObjContainer oc<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    oc<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(&amp;</span>o<span class="hl opt">[</span>i<span class="hl opt">]);</span> <span class="hl slc">// Fill it up</span>
  ObjContainer<span class="hl opt">::</span>SmartPointer sp <span class="hl opt">=</span> oc<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">do</span> <span class="hl opt">{</span>
    sp<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Pointer dereference operator call</span>
    sp<span class="hl opt">-&gt;</span><span class="hl kwd">g</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">while</span><span class="hl opt">(++</span>sp<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.10. C12/NestedSmartPointer.cpp</strong></p></div><br class="example-break" /><p>
		  Además del anidamiento de la clase, hay solo dos diferencias aquí. La primera es
		  la declaración de la clase para que pueda ser <code class="keyword">friend</code>:
		</p><pre class="programlisting">
<span class="hl kwc">class</span> SmartPointer<span class="hl opt">;</span>
		  <span class="hl kwc">friend</span> SmartPointer<span class="hl opt">;</span>
</pre><p>
		  El compilador debe saber primero que la clase existe, antes de que se le diga
		  que es «amiga».
		</p><p>
		  La segunda diferencia es en <code class="classname">ObjContainer</code> donde el método
		  <code class="function">begin()</code> produce el <code class="classname">SmartPointer</code> que
		  apunta al principio de la secuencia del
		  <code class="classname">ObjContainer</code>. Aunque realmente es sólo por conveniencia,
		  es adecuado porque sigue la manera habitual de la librería estándar de C++.
		</p></div><div class="sect3" title="Operador -&gt;*"><div class="titlepage"><div><div><h4 class="title"><a id="idp7290464"></a>Operador -&gt;*</h4></div></div></div><p>
		  El operador <code class="literal">-&gt;*</code> es un operador binario que se comporta como todos
		  los otros operadores binarios. Se proporciona para aquellas situaciones en las
		  que quiera imitar el comportamiento producido por la sintaxis incorporada
		  <span class="emphasis"><em>puntero a miembro</em></span>, descrita en el capitulo anterior.
		</p><p>
		  Igual que <code class="literal">operator-&gt;</code>, el operador de indirección de puntero a
		  miembro se usa normalmente con alguna clase de objetos que representan un
		  «puntero inteligente», aunque el ejemplo mostrado aquí será más
		  simple para que sea comprensible. El truco cuando se define
		  <code class="function">operator-&gt;*</code> es que debe devolver un objeto para el que
		  <code class="function">operator()</code> pueda ser llamado con los argumentos para la
		  función miembro que usted llama.
		</p><p>
		  La llamada a función <code class="function">operator()</code> debe ser un método, y es
		  único en que permite cualquier número de argumentos. Hace que el objeto parezca
		  realmente una función. Aunque podría definir varias funciones sobrecargadas
		  <code class="function">operator()</code> con diferentes argumentos, a menudo se usa para
		  tipos que solo tienen una operación simple, o al menos una especialmente
		  destacada. En el Volumen2 verá que la Librería Estándar de C++ usa el operador
		  de llamada a función para crear «objetos-función».
		</p><p>
		  Para crear un <code class="literal">operator-&gt;*</code> debe primero crear una clase con un
		  <code class="function">operator()</code> que sea el tipo de objeto que
		  <code class="literal">operator-&gt;*</code> devolverá.  Esta clase debe, de algún modo, capturar la
		  información necesaria para que cuando <code class="function">operator()</code> sea
		  llamada (lo que sucede automáticamente), el puntero a miembro sea indireccionado
		  para el objeto. En el siguiente ejemplo, el constructor de
		  <code class="classname">FunctionObject</code> captura y almacena el puntero al objeto y
		  el puntero a la función miembro, y entonces <code class="function">operator()</code> los
		  usa para hacer la verdadera llamada puntero a miembro:
		</p><div class="example"><a id="idp7299832"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:PointerToMemberOperator.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">run</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;run</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>  
    <span class="hl kwa">return</span> i<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">eat</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
     cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;eat</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>  
     <span class="hl kwa">return</span> i<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ZZZ</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> i<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">int</span> <span class="hl opt">(</span>Dog<span class="hl opt">::*</span>PMF<span class="hl opt">)(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl slc">// operator-&gt;* must return an object </span>
  <span class="hl slc">// that has an operator():</span>
  <span class="hl kwc">class</span> FunctionObject <span class="hl opt">{</span>
    Dog<span class="hl opt">*</span> ptr<span class="hl opt">;</span>
    PMF pmem<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl slc">// Save the object pointer and member pointer</span>
    <span class="hl kwd">FunctionObject</span><span class="hl opt">(</span>Dog<span class="hl opt">*</span> wp<span class="hl opt">,</span> PMF pmf<span class="hl opt">)</span> 
      <span class="hl opt">:</span> <span class="hl kwd">ptr</span><span class="hl opt">(</span>wp<span class="hl opt">),</span> <span class="hl kwd">pmem</span><span class="hl opt">(</span>pmf<span class="hl opt">) {</span> 
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;FunctionObject constructor</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Make the call using the object pointer</span>
    <span class="hl slc">// and member pointer</span>
    <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">int</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;FunctionObject::operator()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl opt">(</span>ptr<span class="hl opt">-&gt;*</span>pmem<span class="hl opt">)(</span>i<span class="hl opt">);</span> <span class="hl slc">// Make the call</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  FunctionObject <span class="hl kwc">operator</span><span class="hl opt">-&gt;*(</span>PMF pmf<span class="hl opt">) {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;operator-&gt;*&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">FunctionObject</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">,</span> pmf<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
 
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Dog w<span class="hl opt">;</span>
  Dog<span class="hl opt">::</span>PMF pmf <span class="hl opt">= &amp;</span>Dog<span class="hl opt">::</span>run<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt; (</span>w<span class="hl opt">-&gt;*</span>pmf<span class="hl opt">)(</span><span class="hl num">1</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  pmf <span class="hl opt">= &amp;</span>Dog<span class="hl opt">::</span>sleep<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt; (</span>w<span class="hl opt">-&gt;*</span>pmf<span class="hl opt">)(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  pmf <span class="hl opt">= &amp;</span>Dog<span class="hl opt">::</span>eat<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt; (</span>w<span class="hl opt">-&gt;*</span>pmf<span class="hl opt">)(</span><span class="hl num">3</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.11. C12/PointerToMemberOperator.cpp</strong></p></div><br class="example-break" /><p>
		  <code class="classname">Dog</code> tiene tres métodos, todos toman un argumento entero y
		  devuelven un entero. <code class="varname">PMC</code> es un <code class="type">typedef</code> para
		  simplificar la definición de un puntero a miembro para los métodos de
		  <code class="classname">Dog</code>.
		</p><p>
		  Una <code class="function">FunctionObject</code> es creada y devuelta por
		  <code class="literal">operator-&gt;*</code>. Dese cuenta que <code class="literal">operator-&gt;*</code> conoce el
		  objeto para el que puntero a miembro está siendo llamado
		  (<code class="varname">this</code>) y el puntero a miembro, y los pasa al constructor
		  <code class="function">FunctionObject</code> que almacena sus valores. Cuando se llama a
		  <code class="literal">operator-&gt;*</code>, el compilador inmediatamente lo revuelve y llama a
		  <code class="function">operator()</code> para el valor de retorno de
		  <code class="literal">operator-&gt;*</code>, pasándole los argumentos que le fueron pasados a
		  <code class="literal">operator-&gt;*</code>.  <code class="function">FunctionObject::operator()</code> toma
		  los argumentos e desreferencia el puntero a miembro «real» usando
		  los punteros a objeto y a miembro almacenados.
		</p><p>
		  Percátese de que lo que está ocurriendo aquí, justo como con
		  <code class="literal">operator-&gt;</code>, se inserta en la mitad de la llamada a
		  <code class="literal">operator-&gt;*</code>. Esto permite realizar algunas operaciones adicionales
		  si se necesita.
		</p><p>
		  El mecanismo <code class="literal">operator-&gt;*</code> implementado aquí solo trabaja para
		  funciones miembro que toman un argumento entero y devuelven otro entero. Esto es
		  una limitación, pero si intenta crear mecanismos sobrecargados para cada
		  posibilidad diferente, verá que es una tarea prohibitiva. Afortunadamente, el
		  mecanismo de plantillas de C++ (descrito el el ultimo capitulo de este libro, y
		  en el volumen2) está diseñado para manejar semejante problema.
		</p></div></div><div class="sect2" title="12.3.5. Operadores que no puede sobrecargar"><div class="titlepage"><div><div><h3 class="title"><a id="idp7311576"></a>12.3.5. Operadores que no puede sobrecargar</h3></div></div></div><p>
		Hay cierta clase de operadores en el conjunto disponible que no pueden ser
		sobrecargados. La razón general para esta restricción es la seguridad. Si estos
		operadores fuesen sobrecargables, podría de algún modo arriesgar o romper los
		mecanismos de seguridad, hacer las cosas mas difíciles o confundir las costumbres
		existentes.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
			El operador de selección de miembros <code class="keyword">operator.</code>. Actualmente, el punto
			tiene significado para cualquier miembro de una clase, pero si se pudiera
			sobrecargar, no se podría acceder a miembros de la forma normal; en lugar de
			eso debería usar un puntero y la flecha <code class="function">operator-&gt;</code>.
	  </p></li><li class="listitem"><p>
			La indirección de punteros a miembros <code class="literal">operator.*</code> por la
			misma razón que <code class="literal">operator.</code>.
		  </p></li><li class="listitem"><p>
			No hay un operador de potencia. La elección más popular para éste era
			<code class="literal">operator**</code> de Fortram, pero provoca casos de análisis
			gramatical difíciles. C tampoco tiene un operador de potencia, así que C++ no
			parece tener necesidad de uno porque siempre puede realizar una llamada a una
			función. Un operador de potencia añadirá una notación adecuada, pero ninguna
			nueva funcionalidad a cuenta de una mayor complejidad del compilador.
		  </p></li><li class="listitem"><p>
			No hay operadores definidos por el usuario. Esto es, no puede crear nuevos
			operadores que no existan ya. Una parte del problema es como determinar la
			precedencia, y otra parte es la falta de necesidad a costa del problema
			inherente.
		  </p></li><li class="listitem"><p>
            No puede cambiar las reglas de precedencia. Son lo suficientemente difíciles de
            recordar como son sin dejar a la gente jugar con ellas.
          </p></li></ol></div></div></div><div class="sect1" title="12.4. Operadores no miembros"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7319424"></a>12.4. Operadores no miembros</h2></div></div></div><p>
      En algunos de los ejemplos anteriores, los operadores pueden ser miembros o no, y no
      parece haber mucha diferencia. Esto normalmente provoca la pregunta, «¿Cuál
      debería elegir?». En general, si no hay ninguna diferencia deberían ser
      miembros, para enfatizar la asociación entre el operador y su clase. Cuando el
      operando de la izquierda es siempre un objeto de la clase actual funciona bien.
    </p><p>
      Sin embargo, a veces querrá que el operando de la izquierda sea un objeto de alguna
      otra clase. Un caso típico en el que ocurre eso es cuando se sobrecargan los
      operadores <code class="literal">&lt;&lt;</code> y <code class="literal">&gt;&gt;</code> para los flujos de
      entrada/salida. Dado que estos flujos son una librería fundamental en C++,
      probablemente querrá sobrecargar estos operadores para la mayoría de sus clases, por
      eso el proceso es digno de tratarse:
    </p><div class="example"><a id="idp7322888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:IostreamOperatorOverloading.cpp</span>
<span class="hl slc">// Example of non-member overloaded operators</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span> <span class="hl slc">// &quot;String streams&quot;</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> IntArray <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> sz <span class="hl opt">=</span> <span class="hl num">5</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span>sz<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">IntArray</span><span class="hl opt">() {</span> <span class="hl kwd">memset</span><span class="hl opt">(</span>i<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> sz<span class="hl opt">*</span> <span class="hl kwa">sizeof</span><span class="hl opt">(*</span>i<span class="hl opt">)); }</span>
  <span class="hl kwb">int</span><span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>x <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp;</span> x <span class="hl opt">&lt;</span> sz<span class="hl opt">,</span>
      <span class="hl str">&quot;IntArray::operator[] out of range&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> i<span class="hl opt">[</span>x<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> IntArray<span class="hl opt">&amp;</span> ia<span class="hl opt">);</span>
  <span class="hl kwc">friend</span> istream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span>istream<span class="hl opt">&amp;</span> is<span class="hl opt">,</span> IntArray<span class="hl opt">&amp;</span> ia<span class="hl opt">);</span>
<span class="hl opt">};</span>

ostream<span class="hl opt">&amp;</span> 
<span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> IntArray<span class="hl opt">&amp;</span> ia<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> ia<span class="hl opt">.</span>sz<span class="hl opt">;</span> j<span class="hl opt">++) {</span>
    os <span class="hl opt">&lt;&lt;</span> ia<span class="hl opt">.</span>i<span class="hl opt">[</span>j<span class="hl opt">];</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>j <span class="hl opt">!=</span> ia<span class="hl opt">.</span>sz <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">)</span>
      os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  os <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">return</span> os<span class="hl opt">;</span>
<span class="hl opt">}</span>

istream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span>istream<span class="hl opt">&amp;</span> is<span class="hl opt">,</span> IntArray<span class="hl opt">&amp;</span> ia<span class="hl opt">){</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> ia<span class="hl opt">.</span>sz<span class="hl opt">;</span> j<span class="hl opt">++)</span>
    is <span class="hl opt">&gt;&gt;</span> ia<span class="hl opt">.</span>i<span class="hl opt">[</span>j<span class="hl opt">];</span>
  <span class="hl kwa">return</span> is<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  stringstream <span class="hl kwd">input</span><span class="hl opt">(</span><span class="hl str">&quot;47 34 56 92 103&quot;</span><span class="hl opt">);</span>
  IntArray I<span class="hl opt">;</span>
  input <span class="hl opt">&gt;&gt;</span> I<span class="hl opt">;</span>
  I<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">] = -</span><span class="hl num">1</span><span class="hl opt">;</span> <span class="hl slc">// Use overloaded operator[]</span>
  cout <span class="hl opt">&lt;&lt;</span> I<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.12. C12/IostreamOperatorOverloading.cpp</strong></p></div><br class="example-break" /><p>
      Esta clase contiene también un operador sobrecargado <code class="literal">operator[]</code> el cual
      devuelve una referencia a un valor legítimo en el array. Dado que devuelve una
      referencia, la expresión:
    </p><pre class="programlisting">
I<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">] = -</span><span class="hl num">1</span><span class="hl opt">;</span>
</pre><p>
      No sólo parece mucho más adecuada que si se usaran punteros, también causa el efecto
      deseado.
    </p><p>
      Es importante que los operadores de desplazamiento sobrecargados se pasen
      y devuelvan <span class="emphasis"><em>por referencia</em></span>, para que los cambios
      afecten a los objetos externos. En las definiciones de las funciones,
      expresiones como:
    </p><pre class="programlisting">
os <span class="hl opt">&lt;&lt;</span> ia<span class="hl opt">.</span>i<span class="hl opt">[</span>j<span class="hl opt">];</span>
</pre><p>
      provocan que sean llamadas las funciones de los operadores sobrecargados
      (esto es, aquellas definidas en <code class="classname">iostream</code>). En este
      caso, la función llamada es <code class="function">ostream&amp;
      operator&lt;&lt;(ostream&amp;, int)</code> dado que
      <code class="varname">ia[i].j</code> se resuelve a <code class="type">int</code>.
    </p><p>
      Una vez que las operaciones se han realizado en
      <code class="classname">istream</code> o en <code class="classname">ostream</code> se
      devuelve para que se pueda usaren expresiones más complicadas.
    </p><p>
      En <code class="function">main()</code> se usa un nuevo tipo de
      <code class="classname">iostream</code>: el <code class="type">stringstream</code> (declarado
      en <code class="classname">&lt;sstream&gt;</code>). Es una clase que toma una cadena
      (que se puede crear de un array de <code class="type">char</code>, como se ve aquí) y
      lo convierte en un <code class="classname">iostream</code>. En el ejemplo de
      arriba, esto significa que los operadores de desplazamiento pueden ser
      comprobados sin abrir un archivo o sin escribir datos en la línea de
      comandos.
    </p><p>
      La manera mostrada en este ejemplo para el extractor y el insertador es
      estándar. Si quiere crear estos operadores para su propia clase, copie el
      prototipo de la función y los tipos de retorno de arriba y siga el estilo
      del cuerpo.
    </p><div class="sect2" title="12.4.1. Directrices básicas"><div class="titlepage"><div><div><h3 class="title"><a id="idp7333752"></a>12.4.1. Directrices básicas</h3></div></div></div><p>
		Murray
		<sup>[<a id="idp7334272" href="#ftn.idp7334272" class="footnote">70</a>]</sup> sugiere estas reglas de estilo para elegir entre miembros y no miembros:
      </p><div class="table"><a id="idp7335264"></a><div class="table-contents"><table summary="Directrices para elegir entre miembro y no-miembro" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Operador</th><th>Uso recomendado</th></tr></thead><tbody><tr><td>Todos los operadores unarios</td><td>miembro</td></tr><tr><td>= () [] -&gt; -&gt;*</td><td><span class="emphasis"><em>debe</em></span> ser miembro</td></tr><tr><td>+= -= /= *= ^= &amp;= |= %= &gt;&gt;=
				&lt;&lt;=</td><td>miembro</td></tr><tr><td>El resto de operadores binarios</td><td>no miembro</td></tr></tbody></table></div><p class="title"><strong>Tabla 12.1. Directrices para elegir entre miembro y no-miembro</strong></p></div><br class="table-break" /></div></div><div class="sect1" title="12.5. Sobrecargar la asignación"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7339880"></a>12.5. Sobrecargar la asignación</h2></div></div></div><p>
      Una causa común de confusión para los nuevos programadores de C++ es la
      asignación. De esto no hay duda porque el signo <code class="literal">=</code> es
      una operación fundamental en la programación, directamente hasta copiar un
      registro en el nivel de máquina. Además, el constructor de copia (descrito
      en el capítulo 11) [FIXME:referencia] es invocado cuando el signo
      <code class="literal">=</code> se usa así:
    </p><pre class="programlisting">
MyType b<span class="hl opt">;</span>
    MyType a <span class="hl opt">=</span> b<span class="hl opt">;</span>
    a <span class="hl opt">=</span> b<span class="hl opt">;</span>
</pre><p>
      En la segunda línea, se define el objeto <code class="varname">a</code>. Se crea un nuevo
      objeto donde no existía ninguno. Dado que ya sabe hasta que punto es quisquilloso el
      compilador de C++ respecto a la inicialización de objetos, sabrá que cuando se
      define un objeto, siempre se invoca un constructor. Pero ¿qué constructor?,
      <code class="varname">a</code> se crea desde un objeto existente <code class="classname">MyType</code>
      (<code class="varname">b</code>, en el lado derecho del signo de igualdad), así que solo hay
      una opción: el constructor de copia. Incluso aunque el signo de igualdad esté
      involucrado, se llama al constructor de copia.
    </p><p>
      En la tercera línea, las cosas son diferentes. En la parte izquierda del signo
      igual, hay un objeto previamente inicializado. Claramente, no se invoca un
      constructor para un objeto que ya ha sido creado. En este caso
      <code class="function">MyType::operator=</code> se llama para <code class="varname">a</code>, tomando
      como argumento lo que sea que aparezca en la parte derecha. (Puede tener varias
      funciones <code class="function">operator=</code> que tomen diferentes argumentos en la parte
      derecha).
    </p><p>
      Este comportamiento no está restringido al constructor de copia. Cada vez que
      inicializa un objeto usando un signo <code class="literal">=</code> en lugar de la forma usual
      de llamada al constructor, el compilador buscará un constructor que acepte lo que
      sea que haya en la parte derecha:
    </p><div class="example"><a id="idp7347400"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:CopyingVsInitialization.cpp</span>
<span class="hl kwc">class</span> Fi <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Fi</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Fee <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Fee</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
  <span class="hl kwd">Fee</span><span class="hl opt">(</span><span class="hl kwb">const</span> Fi<span class="hl opt">&amp;) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Fee fee <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> <span class="hl slc">// Fee(int)</span>
  Fi fi<span class="hl opt">;</span>
  Fee fum <span class="hl opt">=</span> fi<span class="hl opt">;</span> <span class="hl slc">// Fee(Fi)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.13. C12/CopyingVsInitialization.cpp</strong></p></div><br class="example-break" /><p>
      Cuando se trata con el signo <code class="literal">=</code>, es importante mantener la diferencia en
      mente: Si el objeto no ha sido creado todavía, se requiere una inicialización; en
      otro caso se usa el operador de asignación <code class="literal">=</code>.
    </p><p>
      Es incluso mejor evitar escribir código que usa <code class="literal">=</code> para la
      inicialización; en cambio, use siempre la manera del constructor explícito. Las dos
      construcciones con el signo igual se convierten en:
    </p><pre class="programlisting">
Fee <span class="hl kwd">fee</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
    Fee <span class="hl kwd">fum</span><span class="hl opt">(</span>fi<span class="hl opt">);</span>
</pre><p>
      De esta manera, evitará confundir a sus lectores.
    </p><div class="sect2" title="12.5.1. Comportamiento del operador ="><div class="titlepage"><div><div><h3 class="title"><a id="idp7351952"></a>12.5.1. Comportamiento del <code class="function">operador =</code></h3></div></div></div><p>
		En <code class="filename">Integer.h</code> y en <code class="filename">Byte.h</code> vimos que el
		operador <code class="literal">=</code> sólo puede ser una función miembro. Está íntimamente
		ligado al objeto que hay en la parte izquierda del <code class="literal">=</code>. Si fuese
		posible definir <code class="function">operator=</code> de forma global, entonces podría
		intentar redefinir el signo <code class="literal">=</code> del lenguaje:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">int</span><span class="hl opt">,</span> MyType<span class="hl opt">);</span>   <span class="hl slc">// Global = !No permitido!</span>
</pre><p>
		El compilador evita esta situación obligandole a hacer un método
		<code class="function">operator=</code>.
      </p><p>
		Cuando cree un <code class="keyword">operator=</code>, debe copiar toda la información necesaria desde
		el objeto de la parte derecha al objeto actual (es decir, el objeto para el que
		<code class="literal">operator=</code> está siendo llamado) para realizar lo que sea que considere
		«asignación» para su clase. Para objetos simples, esto es trivial:
      </p><div class="example"><a id="idp7358712"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:SimpleAssignment.cpp</span>
<span class="hl slc">// Simple operator=()</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Value <span class="hl opt">{</span>
  <span class="hl kwb">int</span> a<span class="hl opt">,</span> b<span class="hl opt">;</span>
  <span class="hl kwb">float</span> c<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Value</span><span class="hl opt">(</span><span class="hl kwb">int</span> aa <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> bb <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">float</span> cc <span class="hl opt">=</span> <span class="hl num">0.0</span><span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">a</span><span class="hl opt">(</span>aa<span class="hl opt">),</span> <span class="hl kwd">b</span><span class="hl opt">(</span>bb<span class="hl opt">),</span> <span class="hl kwd">c</span><span class="hl opt">(</span>cc<span class="hl opt">) {}</span>
  Value<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Value<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    a <span class="hl opt">=</span> rv<span class="hl opt">.</span>a<span class="hl opt">;</span>
    b <span class="hl opt">=</span> rv<span class="hl opt">.</span>b<span class="hl opt">;</span>
    c <span class="hl opt">=</span> rv<span class="hl opt">.</span>c<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Value<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> rv<span class="hl opt">.</span>a <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, b = &quot;</span>
      <span class="hl opt">&lt;&lt;</span> rv<span class="hl opt">.</span>b <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, c = &quot;</span> <span class="hl opt">&lt;&lt;</span> rv<span class="hl opt">.</span>c<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Value a<span class="hl opt">,</span> <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3.3</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a: &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;b: &quot;</span> <span class="hl opt">&lt;&lt;</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  a <span class="hl opt">=</span> b<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a after assignment: &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.14. C12/SimpleAssignment.cpp</strong></p></div><br class="example-break" /><p>
		Aquí, el objeto de la parte izquierda del igual copia todos los elementos del
		objeto de la parte derecha, y entonces devuelve una referencia a sí mismo, lo que
		permite crear expresiones más complejas.
      </p><p>
		Este ejemplo incluye un error comón. Cuando asignane dos objetos del mismo tipo,
		siempre debería comprobar primero la auto-asignación: ¿Está asignado el objeto a
		sí mismo?. En algunos casos como éste, es inofensivo si realiza la operación de
		asignación en todo caso, pero si se realizan cambios a la implementación de la
		clase, puede ser importante y si no lo toma con una cuestión de costumbre,
		puede olvidarlo y provocar errores difíciles de encontrar.
      </p><div class="sect3" title="Punteros en clases"><div class="titlepage"><div><div><h4 class="title"><a id="idp7362352"></a>Punteros en clases</h4></div></div></div><p>
		  ¿Qué ocurre si el objeto no es tan simple?. Por ejemplo, ¿qué pasa si el objeto
		  contiene punteros a otros objetos?. Sólo copiar el puntero significa que
		  obtendrá dos objetos que apuntan a la misma localización de memoria. En
		  situaciones como ésta, necesita hacer algo de contabilidad.
		</p><p>
		  Hay dos aproximaciones a este problema. La técnica más simple es copiar lo que
		  quiera que apunta el puntero cuando realiza una asignación o una construcción de
		  copia. Esto es sencillo:
		</p><div class="example"><a id="idp7364112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:CopyingWithPointers.cpp</span>
<span class="hl slc">// Solving the pointer aliasing problem by</span>
<span class="hl slc">// duplicating what is pointed to during </span>
<span class="hl slc">// assignment and copy-construction.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">{</span>
  string nm<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> name<span class="hl opt">) :</span> <span class="hl kwd">nm</span><span class="hl opt">(</span>name<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Creating Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Synthesized copy-constructor &amp; operator= </span>
  <span class="hl slc">// are correct.</span>
  <span class="hl slc">// Create a Dog from a Dog pointer:</span>
  <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl kwb">const</span> Dog<span class="hl opt">*</span> dp<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg<span class="hl opt">)</span> 
    <span class="hl opt">:</span> <span class="hl kwd">nm</span><span class="hl opt">(</span>dp<span class="hl opt">-&gt;</span>nm <span class="hl opt">+</span> msg<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Copied dog &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; from &quot;</span>
         <span class="hl opt">&lt;&lt; *</span>dp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Dog</span><span class="hl opt">() {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Deleting Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    nm <span class="hl opt">=</span> newName<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dog renamed to: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Dog<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;[&quot;</span> <span class="hl opt">&lt;&lt;</span> d<span class="hl opt">.</span>nm <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;]&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> DogHouse <span class="hl opt">{</span>
  Dog<span class="hl opt">*</span> p<span class="hl opt">;</span>
  string houseName<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DogHouse</span><span class="hl opt">(</span>Dog<span class="hl opt">*</span> dog<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> house<span class="hl opt">)</span>
   <span class="hl opt">:</span> <span class="hl kwd">p</span><span class="hl opt">(</span>dog<span class="hl opt">),</span> <span class="hl kwd">houseName</span><span class="hl opt">(</span>house<span class="hl opt">) {}</span>
  <span class="hl kwd">DogHouse</span><span class="hl opt">(</span><span class="hl kwb">const</span> DogHouse<span class="hl opt">&amp;</span> dh<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">p</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Dog</span><span class="hl opt">(</span>dh<span class="hl opt">.</span>p<span class="hl opt">,</span> <span class="hl str">&quot; copy-constructed&quot;</span><span class="hl opt">)),</span>
      <span class="hl kwd">houseName</span><span class="hl opt">(</span>dh<span class="hl opt">.</span>houseName 
        <span class="hl opt">+</span> <span class="hl str">&quot; copy-constructed&quot;</span><span class="hl opt">) {}</span>
  DogHouse<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> DogHouse<span class="hl opt">&amp;</span> dh<span class="hl opt">) {</span>
    <span class="hl slc">// Check for self-assignment:</span>
    <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>dh <span class="hl opt">!=</span> <span class="hl kwa">this</span><span class="hl opt">) {</span>
      p <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Dog</span><span class="hl opt">(</span>dh<span class="hl opt">.</span>p<span class="hl opt">,</span> <span class="hl str">&quot; assigned&quot;</span><span class="hl opt">);</span>
      houseName <span class="hl opt">=</span> dh<span class="hl opt">.</span>houseName <span class="hl opt">+</span> <span class="hl str">&quot; assigned&quot;</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">renameHouse</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    houseName <span class="hl opt">=</span> newName<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Dog<span class="hl opt">*</span> <span class="hl kwd">getDog</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> p<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">DogHouse</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> p<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> DogHouse<span class="hl opt">&amp;</span> dh<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;[&quot;</span> <span class="hl opt">&lt;&lt;</span> dh<span class="hl opt">.</span>houseName 
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] contains &quot;</span> <span class="hl opt">&lt;&lt; *</span>dh<span class="hl opt">.</span>p<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  DogHouse <span class="hl kwd">fidos</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl str">&quot;Fido&quot;</span><span class="hl opt">),</span> <span class="hl str">&quot;FidoHouse&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> fidos <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  DogHouse fidos2 <span class="hl opt">=</span> fidos<span class="hl opt">;</span> <span class="hl slc">// Copy construction</span>
  cout <span class="hl opt">&lt;&lt;</span> fidos2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  fidos2<span class="hl opt">.</span><span class="hl kwd">getDog</span><span class="hl opt">()-&gt;</span><span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl str">&quot;Spot&quot;</span><span class="hl opt">);</span>
  fidos2<span class="hl opt">.</span><span class="hl kwd">renameHouse</span><span class="hl opt">(</span><span class="hl str">&quot;SpotHouse&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> fidos2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  fidos <span class="hl opt">=</span> fidos2<span class="hl opt">;</span> <span class="hl slc">// Assignment</span>
  cout <span class="hl opt">&lt;&lt;</span> fidos <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  fidos<span class="hl opt">.</span><span class="hl kwd">getDog</span><span class="hl opt">()-&gt;</span><span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl str">&quot;Max&quot;</span><span class="hl opt">);</span>
  fidos2<span class="hl opt">.</span><span class="hl kwd">renameHouse</span><span class="hl opt">(</span><span class="hl str">&quot;MaxHouse&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.15. C12/CopyingWithPointers.cpp</strong></p></div><br class="example-break" /><p>
		  <code class="classname">Dog</code> es una clase simple que contiene solo una cadena con
		  el nombre del perro. Sin embargo, generalmente sabrá cuando le sucede algo al
		  perro porque los constructores y destructores imprimen información cuando se
		  invocan. Fíjese que el segundo constructor es un poco como un constructor de
		  copia excepto que toma un puntero a <code class="classname">Dog</code> en vez de una
		  referencia, y tiene un segundo argumento que es un mensaje a ser concatenado con
		  el nombre del perro. Esto se hace así para ayudar a rastrear el comportamiento
		  del programa.
		</p><p>
		  Puede ver que cuando un método imprime información, no accede a esa información
		  directamente sino que manda <code class="varname">*this</code> a
		  <code class="function">cout</code>. Éste a su vez llama a <code class="function">ostream
		  operator&lt;&lt;</code>. Es aconsejable hacer esto así dado que si quiere
		  reformatear la manera en la que información del perro es mostrada (como hice
		  añadiendo el «[» y el «]») solo necesita hacerlo en un
		  lugar.
		</p><p>
		  Una <code class="classname">DogHouse</code> contiene un <code class="varname">Dog*</code> y
		  demuestra las cuatro funciones que siempre necesitará definir cuando sus clases
		  contengan punteros: todos los constructores necesarios usuales, el constructor
		  de copia, <code class="literal">operator=</code> (se define o se deshabilita) y un
		  destructor. <code class="literal">Operator=</code> comprueba la auto-asignación como una
		  cuestión de estilo, incluso aunque no es estrictamente necesario aquí. Esto
		  virtualmente elimina la posibilidad de que olvide comprobar la auto-asignación
		  si cambia el código.
		</p></div><div class="sect3" title="Contabilidad de referencias"><div class="titlepage"><div><div><h4 class="title"><a id="idp7375592"></a>Contabilidad de referencias</h4></div></div></div><p>
		  En el ejemplo de arriba, el constructor de copia y el operador <code class="literal">=</code>
		  realizan una copia de lo que apunta el puntero, y el destructor lo borra. Sin
		  embargo, si su objeto requiere una gran cantidad de memoria o una gran
		  inicialización fija, a lo mejor puede querer evitar esta copia. Una aproximación
		  común a este problema se llama <span class="emphasis"><em>conteo de referencias</em></span>. Se le
		  da inteligencia al objeto que está siendo apuntado de tal forma que sabe cuántos
		  objetos le están apuntado. Entonces la construcción por copia o la asignación
		  consiste en añadir otro puntero a un objeto existente e incrementar la cuenta de
		  referencias. La destrucción consiste en reducir esta cuenta de referencias y
		  destruir el objeto si la cuenta llega a cero.
		</p><p>
		  ¿Pero que pasa si quiere escribir el objeto(<code class="varname">Dog</code> en el ejemplo
		  anterior)?. Más de un objeto puede estar usando este <code class="varname">Dog</code>
		  luego podría estar modificando el perro de alguien más a la vez que el suyo, lo
		  cual no parece ser muy amigable. Para resolver este problema de
		  «solapamiento» se usa una técnica adicional llamada
		  <span class="emphasis"><em>copia-en-escritura</em></span>. Antes de escribir un bloque de memoria,
		  debe asegurarse que nadie más lo está usando. Si la cuenta de referencia es
		  superior a uno, debe realizar una copia personal del bloque antes de escribirlo,
		  de tal manera que no moleste el espacio de otro. He aquí un ejemplo simple de
		  conteo de referencias y copia-en-escritura:
		</p><div class="example"><a id="idp7380560"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:ReferenceCounting.cpp</span>
<span class="hl slc">// Reference count, copy-on-write</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">{</span>
  string nm<span class="hl opt">;</span>
  <span class="hl kwb">int</span> refcount<span class="hl opt">;</span>
  <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> name<span class="hl opt">)</span> 
    <span class="hl opt">:</span> <span class="hl kwd">nm</span><span class="hl opt">(</span>name<span class="hl opt">),</span> <span class="hl kwd">refcount</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Creating Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Prevent assignment:</span>
  Dog<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Dog<span class="hl opt">&amp;</span> rv<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Dogs can only be created on the heap:</span>
  <span class="hl kwb">static</span> Dog<span class="hl opt">*</span> <span class="hl kwd">make</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> name<span class="hl opt">) {</span>
    <span class="hl kwa">return new</span> <span class="hl kwd">Dog</span><span class="hl opt">(</span>name<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl kwb">const</span> Dog<span class="hl opt">&amp;</span> d<span class="hl opt">)</span> 
    <span class="hl opt">:</span> <span class="hl kwd">nm</span><span class="hl opt">(</span>d<span class="hl opt">.</span>nm <span class="hl opt">+</span> <span class="hl str">&quot; copy&quot;</span><span class="hl opt">),</span> <span class="hl kwd">refcount</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dog copy-constructor: &quot;</span> 
         <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Dog</span><span class="hl opt">() {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Deleting Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">attach</span><span class="hl opt">() {</span> 
    <span class="hl opt">++</span>refcount<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Attached Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">detach</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>refcount <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Detaching Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl slc">// Destroy object if no one is using it:</span>
    <span class="hl kwa">if</span><span class="hl opt">(--</span>refcount <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">delete this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Conditionally copy this Dog.</span>
  <span class="hl slc">// Call before modifying the Dog, assign</span>
  <span class="hl slc">// resulting pointer to your Dog*.</span>
  Dog<span class="hl opt">*</span> <span class="hl kwd">unalias</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Unaliasing Dog: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl slc">// Don't duplicate if not aliased:</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>refcount <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">)</span> <span class="hl kwa">return this</span><span class="hl opt">;</span>
    <span class="hl opt">--</span>refcount<span class="hl opt">;</span>
    <span class="hl slc">// Use copy-constructor to duplicate:</span>
    <span class="hl kwa">return new</span> <span class="hl kwd">Dog</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    nm <span class="hl opt">=</span> newName<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dog renamed to: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Dog<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;[&quot;</span> <span class="hl opt">&lt;&lt;</span> d<span class="hl opt">.</span>nm <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;], rc = &quot;</span> 
      <span class="hl opt">&lt;&lt;</span> d<span class="hl opt">.</span>refcount<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> DogHouse <span class="hl opt">{</span>
  Dog<span class="hl opt">*</span> p<span class="hl opt">;</span>
  string houseName<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DogHouse</span><span class="hl opt">(</span>Dog<span class="hl opt">*</span> dog<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> house<span class="hl opt">)</span>
   <span class="hl opt">:</span> <span class="hl kwd">p</span><span class="hl opt">(</span>dog<span class="hl opt">),</span> <span class="hl kwd">houseName</span><span class="hl opt">(</span>house<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Created DogHouse: &quot;</span><span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">DogHouse</span><span class="hl opt">(</span><span class="hl kwb">const</span> DogHouse<span class="hl opt">&amp;</span> dh<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">p</span><span class="hl opt">(</span>dh<span class="hl opt">.</span>p<span class="hl opt">),</span>
      <span class="hl kwd">houseName</span><span class="hl opt">(</span><span class="hl str">&quot;copy-constructed &quot;</span> <span class="hl opt">+</span> 
        dh<span class="hl opt">.</span>houseName<span class="hl opt">) {</span>
    p<span class="hl opt">-&gt;</span><span class="hl kwd">attach</span><span class="hl opt">();</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;DogHouse copy-constructor: &quot;</span>
         <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  DogHouse<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> DogHouse<span class="hl opt">&amp;</span> dh<span class="hl opt">) {</span>
    <span class="hl slc">// Check for self-assignment:</span>
    <span class="hl kwa">if</span><span class="hl opt">(&amp;</span>dh <span class="hl opt">!=</span> <span class="hl kwa">this</span><span class="hl opt">) {</span>
      houseName <span class="hl opt">=</span> dh<span class="hl opt">.</span>houseName <span class="hl opt">+</span> <span class="hl str">&quot; assigned&quot;</span><span class="hl opt">;</span>
      <span class="hl slc">// Clean up what you're using first:</span>
      p<span class="hl opt">-&gt;</span><span class="hl kwd">detach</span><span class="hl opt">();</span>
      p <span class="hl opt">=</span> dh<span class="hl opt">.</span>p<span class="hl opt">;</span> <span class="hl slc">// Like copy-constructor</span>
      p<span class="hl opt">-&gt;</span><span class="hl kwd">attach</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;DogHouse operator= : &quot;</span>
         <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Decrement refcount, conditionally destroy</span>
  <span class="hl opt">~</span><span class="hl kwd">DogHouse</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;DogHouse destructor: &quot;</span> 
         <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    p<span class="hl opt">-&gt;</span><span class="hl kwd">detach</span><span class="hl opt">();</span> 
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">renameHouse</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    houseName <span class="hl opt">=</span> newName<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">unalias</span><span class="hl opt">() {</span> p <span class="hl opt">=</span> p<span class="hl opt">-&gt;</span><span class="hl kwd">unalias</span><span class="hl opt">(); }</span>
  <span class="hl slc">// Copy-on-write. Anytime you modify the </span>
  <span class="hl slc">// contents of the pointer you must </span>
  <span class="hl slc">// first unalias it:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">renameDog</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    <span class="hl kwd">unalias</span><span class="hl opt">();</span>
    p<span class="hl opt">-&gt;</span><span class="hl kwd">rename</span><span class="hl opt">(</span>newName<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// ... or when you allow someone else access:</span>
  Dog<span class="hl opt">*</span> <span class="hl kwd">getDog</span><span class="hl opt">() {</span>
    <span class="hl kwd">unalias</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> p<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> DogHouse<span class="hl opt">&amp;</span> dh<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;[&quot;</span> <span class="hl opt">&lt;&lt;</span> dh<span class="hl opt">.</span>houseName 
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] contains &quot;</span> <span class="hl opt">&lt;&lt; *</span>dh<span class="hl opt">.</span>p<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  DogHouse 
    <span class="hl kwd">fidos</span><span class="hl opt">(</span>Dog<span class="hl opt">::</span><span class="hl kwd">make</span><span class="hl opt">(</span><span class="hl str">&quot;Fido&quot;</span><span class="hl opt">),</span> <span class="hl str">&quot;FidoHouse&quot;</span><span class="hl opt">),</span>
    <span class="hl kwd">spots</span><span class="hl opt">(</span>Dog<span class="hl opt">::</span><span class="hl kwd">make</span><span class="hl opt">(</span><span class="hl str">&quot;Spot&quot;</span><span class="hl opt">),</span> <span class="hl str">&quot;SpotHouse&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Entering copy-construction&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  DogHouse <span class="hl kwd">bobs</span><span class="hl opt">(</span>fidos<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;After copy-constructing bobs&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fidos:&quot;</span> <span class="hl opt">&lt;&lt;</span> fidos <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;spots:&quot;</span> <span class="hl opt">&lt;&lt;</span> spots <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;bobs:&quot;</span> <span class="hl opt">&lt;&lt;</span> bobs <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Entering spots = fidos&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  spots <span class="hl opt">=</span> fidos<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;After spots = fidos&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;spots:&quot;</span> <span class="hl opt">&lt;&lt;</span> spots <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Entering self-assignment&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  bobs <span class="hl opt">=</span> bobs<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;After self-assignment&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;bobs:&quot;</span> <span class="hl opt">&lt;&lt;</span> bobs <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Comment out the following lines:</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Entering rename(</span><span class="hl esc">\&quot;</span><span class="hl str">Bob</span><span class="hl esc">\&quot;</span><span class="hl str">)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  bobs<span class="hl opt">.</span><span class="hl kwd">getDog</span><span class="hl opt">()-&gt;</span><span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl str">&quot;Bob&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;After rename(</span><span class="hl esc">\&quot;</span><span class="hl str">Bob</span><span class="hl esc">\&quot;</span><span class="hl str">)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.16. C12/ReferenceCounting.cpp</strong></p></div><br class="example-break" /><p>
		  La clase <code class="classname">Dog</code> es el objeto apuntado por
		  <code class="classname">DogHouse</code>. Contiene una cuenta de referencias y métodos
		  para controlar y leer la cuenta de referencias. Hay un constructor de copia de
		  modo que puede crear un nuevo <code class="classname">Dog</code> a partir de uno
		  existente.
		</p><p>
		  La función <code class="function">attach()</code> incrementa la cuenta de referencias de
		  un <code class="classname">Dog</code> para indicar que hay otro objeto usándolo. La
		  función <code class="function">detach()</code> decrementa la cuenta de referencias. Si
		  llega a cero, entonces nadie mas lo está usando, así que el método destruye su
		  propio objeto llamando a <code class="function">delete this</code>.
		</p><p>
		 Antes de que haga cualquier modificación (como renombrar un
		 <code class="classname">Dog</code>), debería asegurarse de que no está cambiando un
		 <code class="classname">Dog</code> que algún otro objeto está usando. Hágalo llamando
		 a <code class="function">DogHouse::unalias() </code>, que llama a
		 <code class="function">Dog::unalias()</code>. Esta última función devolverá el puntero a
		 <code class="classname">Dog</code> existente si la cuenta de referencias es uno (lo que
		 significa que nadie mas está usando ese <code class="classname">Dog</code>), pero
		 duplicará <code class="classname">Dog</code> si esa cuenta es mayor que uno.
	   </p><p>
		  El constructor de copia, además de pedir su propia memoria, asigna
		  <code class="classname">Dog</code> al <code class="classname">Dog</code> del objeto
		  fuente. Entonces, dado que ahora hay un objeto más usando ese bloque de memoria,
		  incrementa la cuenta de referencias llamando a <code class="function">Dog::attach()</code>.
		</p><p>
		  El operador <code class="literal">=</code> trata con un objeto que ha sido creado en la parte
		  izquierda del <code class="literal">=</code>, así que primero debe limpiarlo llamando a
		  <code class="function">detach()</code> para ese <code class="classname">Dog</code>, lo que
		  destruirá el <code class="classname">Dog</code> viejo si nadie más lo está
		  usando. Entonces <code class="literal">operator=</code> repite el comportamiento del constructor
		  de copia. Advierta que primero realiza comprobaciones para detectar cuando está
		  asignando el objeto a sí mismo.
		</p><p>
		  El destructor llama a <code class="function">detach()</code> para destruir
		  condicionalmente el <code class="classname">Dog</code>.
		</p><p>
		  Para implementar la copia-en-escritura, debe controlar todas las operaciones que
		  escriben en su bloque de memoria. Por ejemplo, el método
		  <code class="function">renameDog()</code> le permite cambiar valores en el bloque de
		  memoria. Pero primero, llama a <code class="function">unalias()</code> para evitar la
		  modificación de un <code class="classname">Dog</code> solapado (un
		  <code class="classname">Dog</code> con más de un objeto <code class="classname">DogHouse</code>
		  apuntándole). Y si necesita crear un puntero a un <code class="classname">Dog</code>
		  desde un <code class="classname">DogHouse</code> debe llamar primero a
		  <code class="function">unalias()</code> para ese puntero.
		</p><p>
		  La función <code class="function">main()</code> comprueba varias funciones que
		  deben funcionar correctamente para implementar la cuenta de
		  referencias: el constructor, el constructor de copia,
		  <code class="literal">operator=</code> y el destructor. También comprueba la
		  copia-en-escritura llamando a <code class="function">renameDog()</code>.
		</p><p>
		  He aquí la salida (después de un poco de reformateo):
		</p><pre class="programlisting">
Creando Dog<span class="hl opt">: [</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    CreadoDogHouse<span class="hl opt">: [</span>FidoHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    Creando Dog<span class="hl opt">: [</span>Spot<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    CreadoDogHouse<span class="hl opt">: [</span>SpotHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Spot<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    Entrando en el constructor de copia
    Dog añadido<span class="hl opt">:[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">2</span>
    DogHouse constructor de copia
    <span class="hl opt">[</span>construido por copia FidoHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">2</span>
    Despues de la construcción por copia de Bobs
    fidos<span class="hl opt">:[</span>FidoHouse<span class="hl opt">]</span> contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">2</span>
    spots<span class="hl opt">:[</span>SpotHouse<span class="hl opt">]</span> contiene <span class="hl opt">[</span>Spot<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    bobs<span class="hl opt">:[</span>construido por copia FidoHouse<span class="hl opt">]</span>
    contiene<span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">2</span>
    Entrando spots <span class="hl opt">=</span> fidos
    Eliminando perro<span class="hl opt">: [</span>Spot<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    Borrando Perro<span class="hl opt">: [</span>Spot<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">0</span>
    Añadido Dog<span class="hl opt">: [</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">3</span>
    DogHouse operador<span class="hl opt">= : [</span>FidoHouse asignado<span class="hl opt">]</span>
    contiene<span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">3</span>
    Despues de  spots <span class="hl opt">=</span> fidos
    spots<span class="hl opt">:[</span>FidoHouse asignado<span class="hl opt">]</span> contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span> rc <span class="hl opt">=</span> <span class="hl num">3</span>
    Entrando en la <span class="hl kwc">auto</span> asignación
    DogHouse operador<span class="hl opt">= : [</span>construido por copia FidoHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">3</span>
    Despues de la <span class="hl kwc">auto</span> asignación
    bobs<span class="hl opt">:[</span>construido por copia FidoHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">3</span>
    Entando <span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl str">&quot;Bob&quot;</span><span class="hl opt">)</span>
    Despues de <span class="hl kwd">rename</span><span class="hl opt">(</span><span class="hl str">&quot;Bob&quot;</span><span class="hl opt">)</span>
    DogHouse destructor<span class="hl opt">: [</span>construido por copia FidoHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">3</span>
    Eliminando perro<span class="hl opt">: [</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">3</span>
    DogHouse destructor<span class="hl opt">: [</span>FidoHouse asignado<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">2</span>
    Eliminando perro<span class="hl opt">: [</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">2</span>
    DogHouse destructor<span class="hl opt">: [</span>FidoHouse<span class="hl opt">]</span>
    contiene <span class="hl opt">[</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    Eliminando perro<span class="hl opt">: [</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">1</span>
    Borrando perro<span class="hl opt">: [</span>Fido<span class="hl opt">],</span>  rc <span class="hl opt">=</span> <span class="hl num">0</span>
</pre><p>
		  Estudiando la salida, rastreando el código fuente y experimentando con
		  el programa, podrá ahondar en la comprensión de estas técnicas.
		</p></div><div class="sect3" title="Creación automática del operador ="><div class="titlepage"><div><div><h4 class="title"><a id="idp7407272"></a>Creación automática del operador =</h4></div></div></div><p>
		  Dado que asignar un objeto a otro <span class="emphasis"><em>del mismo tipo</em></span> es una
		  operación que la mayoría de la gente espera que sea posible, el compilador
		  automáticamente creará un <code class="code">type::operator=(type)</code> si usted el
		  programador no proporciona uno. El comportamiento de este operador imita el del
		  constructor de copia creado automáticamente; si la clase contiene objetos (o se
		  deriva de otra clase), se llama recursivamente a <code class="literal">operator=</code> para
		  esos objetos. A esto se le llama <span class="emphasis"><em>asignación miembro a
		  miembro</em></span>. Por ejemplo:
		</p><div class="example"><a id="idp7409896"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:AutomaticOperatorEquals.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Cargo <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Cargo<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Cargo<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside Cargo::operator=()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Truck <span class="hl opt">{</span>
  Cargo b<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Truck a<span class="hl opt">,</span> b<span class="hl opt">;</span>
  a <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Prints: &quot;inside Cargo::operator=()&quot;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.17. C12/AutomaticOperatorEquals.cpp</strong></p></div><br class="example-break" /><p>
		  El <code class="function">operador=</code> generado automáticamente para
		  <code class="classname">Truck</code> llama a <code class="function">Cargo::operator=</code>.
		</p><p>
		  En general, no querrá que el compilador haga esto por usted. Con clases de
		  cualquier sofisticación (¡Especialmente si contienen punteros!) querrá crear de
		  forma explicita un <code class="function">operator=</code>. Si realmente no quiere que la
		  gente realice asignaciones, declare <code class="function">operator=</code> como una
		  método privado. (No necesita definirla a menos que la esté usando dentro de la
		  clase).
		</p></div></div></div><div class="sect1" title="12.6. Conversión automática de tipos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7414776"></a>12.6. Conversión automática de tipos</h2></div></div></div><p>
      En C y C++, si el compilador encuentra una expresión o una llamada a función que usa
      un tipo que no es el que se requiere, a menudo podrá realizar una conversión
      automática de tipos desde el tipo que tiene al tipo que necesita. En C++, puede
      conseguir este mismo efecto para los tipos definidos por el usuario creando
      funciones de conversión automática de tipos. Estas funciones se pueden ver en dos
      versiones: un tipo particular de constructores y un operador sobrecargado.
    </p><div class="sect2" title="12.6.1. Conversión por constructor"><div class="titlepage"><div><div><h3 class="title"><a id="idp7416080"></a>12.6.1. Conversión por constructor</h3></div></div></div><p>
		Si define un constructor que toma como su único argumento un objeto (o referencia)
		de otro tipo, ese constructor permite al compilador realizar una conversión
		automática de tipos. Por ejemplo:
      </p><div class="example"><a id="idp7417080"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:AutomaticTypeConversion.cpp</span>
<span class="hl slc">// Type conversion constructor</span>
<span class="hl kwc">class</span> One <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">One</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Two <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Two</span><span class="hl opt">(</span><span class="hl kwb">const</span> One<span class="hl opt">&amp;) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Two<span class="hl opt">) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  One one<span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>one<span class="hl opt">);</span> <span class="hl slc">// Wants a Two, has a One</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.18. C12/AutomaticTypeConversion.cpp</strong></p></div><br class="example-break" /><p>
		Cuando el compilador ve que <code class="function">f()</code> es invocada pasando un objeto
		<code class="classname">One</code>, mira en la declaración de <code class="function">f()</code> y
		ve que requiere un <code class="classname">Two</code>. Entonces busca si hay alguna manera
		de conseguir un <code class="classname">Two</code> a partir de un
		<code class="classname">One</code>, encuentra el constructor
		<code class="function">Two::Two(One)</code> y lo llama. Pasa el objeto
		<code class="classname">Two</code> resultante a <code class="function">f()</code>.
      </p><p>
		En este caso, la conversión automática de tipos le ha salvado del problema de
		definir dos versiones sobrecargadas de <code class="function">f()</code>. Sin embargo el
		coste es la llamada oculta al constructor de <code class="classname">Two</code>, que puede
		ser importante si está preocupado por la eficiencia de las llamadas a
		<code class="function">f()</code>,
      </p><div class="sect3" title="Evitar la conversión por constructor"><div class="titlepage"><div><div><h4 class="title"><a id="idp7422736"></a>Evitar la conversión por constructor</h4></div></div></div><p>
		  Hay veces en que la conversión automática de tipos vía constructor puede
		  ocasionar problemas. Para desactivarlo, modifique el constructor anteponiéndole
		  la palabra reservada <code class="keyword">explicit</code> (que sólo funciona con constructores). Así
		  se ha hecho para modificar el constructor de la clase <code class="classname">Two</code>
		  en el ejemplo anterior:
		</p><div class="example"><a id="idp7424648"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:ExplicitKeyword.cpp</span>
<span class="hl slc">// Using the &quot;explicit&quot; keyword</span>
<span class="hl kwc">class</span> One <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">One</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Two <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">explicit</span> <span class="hl kwd">Two</span><span class="hl opt">(</span><span class="hl kwb">const</span> One<span class="hl opt">&amp;) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Two<span class="hl opt">) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  One one<span class="hl opt">;</span>
<span class="hl slc">//!  f(one); // No auto conversion allowed</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwd">Two</span><span class="hl opt">(</span>one<span class="hl opt">));</span> <span class="hl slc">// OK -- user performs conversion</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.19. C12/ExplicitKeyword.cpp</strong></p></div><br class="example-break" /><p>
		  Haciendo el constructor de <code class="classname">Two</code> explícito, se le dice al
		  compilador que no realice ninguna conversión automática de tipos usando ese
		  constructor en particular (sí se podrían usar otros constructores no explícitos
		  de esa clase para realizar conversiones automáticas). Si el usuario quiere que
		  ocurra esa conversión, debe escribir el codigo necesario. En el código de
		  arriba, <code class="function">f(Two(one))</code> crea un objeto temporal de tipo
		  <code class="classname">Two</code> a partir de <code class="varname">one</code>, justo como el
		  compilador hizo automáticamente en la versión anterior.
		</p></div></div><div class="sect2" title="12.6.2. Conversión por operador"><div class="titlepage"><div><div><h3 class="title"><a id="idp7428624"></a>12.6.2. Conversión por operador</h3></div></div></div><p>
		La segunda forma de producir conversiones automáticas de tipo es a través de la
		sobrecarga de operadores. Puede crear un método que tome el tipo actual
		y lo convierta al tipo deseado usando la palabra reservada
		<code class="literal">operator</code> seguida del tipo al que quiere convertir. Esta forma de
		sobrecarga de operadores es única porque parece que no se especifica un tipo de
		retorno -- el tipo de retorno es el nombre del operador que está sobrecargando. He
		aquí un ejemplo:
      </p><div class="example"><a id="idp7430640"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:OperatorOverloadingConversion.cpp</span>
<span class="hl kwc">class</span> Three <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Three</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Four <span class="hl opt">{</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Four</span><span class="hl opt">(</span><span class="hl kwb">int</span> xx<span class="hl opt">) :</span> <span class="hl kwd">x</span><span class="hl opt">(</span>xx<span class="hl opt">) {}</span>
  <span class="hl kwc">operator</span> <span class="hl kwd">Three</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwd">Three</span><span class="hl opt">(</span>x<span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span>Three<span class="hl opt">) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Four <span class="hl kwd">four</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">g</span><span class="hl opt">(</span>four<span class="hl opt">);</span>
  <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>  <span class="hl slc">// Calls Three(1,0)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.20. C12/OperatorOverloadingConversion.cpp</strong></p></div><br class="example-break" /><p>
		Con la técnica del constructor, la clase destino realiza la conversión, pero con
		los operadores, la realiza la clase origen. El valor de la técnica del constructor
		es que puede añadir una nueva ruta de conversión a un sistema existente al crear
		una nueva clase. Sin embargo, creando un constructor con un único argumento
		siempre define una conversión automática de tipos (incluso si requiere más de un
		argumento si el resto de los argumentos tiene un valor por defecto), que puede no
		ser lo que desea (en cuyo caso puede desactivarlo usando
		<code class="keyword">explicit</code>). Además, no hay ninguna forma de usar una conversión por
		constructor desde un tipo definido por el usuario a un tipo incorporado; eso sólo
		es posible con la sobrecarga de operadores.
      </p><div class="sect3" title="Reflexividad"><div class="titlepage"><div><div><h4 class="title"><a id="idp7433592"></a>Reflexividad</h4></div></div></div><p>
		  Una de las razones más convenientes para usar operadores sobrecargados globales
		  en lugar de operadores miembros es que en la versión global, la conversión
		  automática de tipos puede aplicarse a cualquiera de los operandos, mientras que
		  con objetos miembro, el operando de la parte izquierda debe ser del tipo
		  apropiado. Si quiere que ambos operandos sean convertidos, la versión global
		  puede ahorrar un montón de código. He aquí un pequeño ejemplo:
		</p><div class="example"><a id="idp7434784"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:ReflexivityInOverloading.cpp</span>
<span class="hl kwc">class</span> Number <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Number</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl kwb">const</span> Number
  <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Number<span class="hl opt">&amp;</span> n<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Number</span><span class="hl opt">(</span>i <span class="hl opt">+</span> n<span class="hl opt">.</span>i<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">const</span> Number
    <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Number<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Number<span class="hl opt">&amp;);</span>
<span class="hl opt">};</span>

<span class="hl kwb">const</span> Number
  <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Number<span class="hl opt">&amp;</span> n1<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Number<span class="hl opt">&amp;</span> n2<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Number</span><span class="hl opt">(</span>n1<span class="hl opt">.</span>i <span class="hl opt">-</span> n2<span class="hl opt">.</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Number <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">),</span> <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">11</span><span class="hl opt">);</span>
  a <span class="hl opt">+</span> b<span class="hl opt">;</span> <span class="hl slc">// OK</span>
  a <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span> <span class="hl slc">// 2nd arg converted to Number</span>
<span class="hl slc">//! 1 + a; // Wrong! 1st arg not of type Number</span>
  a <span class="hl opt">-</span> b<span class="hl opt">;</span> <span class="hl slc">// OK</span>
  a <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">;</span> <span class="hl slc">// 2nd arg converted to Number</span>
  <span class="hl num">1</span> <span class="hl opt">-</span> a<span class="hl opt">;</span> <span class="hl slc">// 1st arg converted to Number</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.21. C12/ReflexivityInOverloading.cpp</strong></p></div><br class="example-break" /><p>
		  La clase <code class="classname">Number</code> tiene tanto un miembro
		  <code class="literal">operator+</code> como un <code class="literal">friend operator-</code>. Dado que hay un
		  constructor que acepta un argumento <code class="type">int</code> simple, se puede convertir
		  un <code class="type">int</code> automáticamente a <code class="classname">Number</code>, pero sólo
		  bajo las condiciones adecuadas. En <code class="function">main()</code>, puede ver que
		  sumar un <code class="classname">Number</code> a otro <code class="classname">Number</code>
		  funciona bien dado que tiene una correspondencia exacta con el operador
		  sobrecargado. Además, cuando el compilador ve un <code class="classname">Number</code>
		  seguido de un <code class="literal">+</code> y de un <code class="type">int</code>, puede hacer la
		  correspondencia al método <code class="function">Number::operator+</code> y convertir el
		  argumento <code class="type">int</code> an <code class="classname">Number</code> usando el
		  constructor. Pero cuando ve un <code class="type">int</code>, un <code class="literal">+</code> y un
		  <code class="classname">Number</code>, no sabe qué hacer porque todo lo que tiene es
		  <code class="literal">Number::operator+</code> que requiere que el operando de la izquierda sea
		  ya un objeto <code class="classname">Number</code>. Así que, el compilador genera un
		  error.
		</p><p>
		  Con <code class="literal">friend operator-</code> las cosas son diferentes. El compilador
		  necesita rellenar ambos argumentos como quiera; no está restringido a tener un
		  <code class="classname">Number</code> como argumento de la parte izquierda. así que si
		  ve:
	</p><pre class="programlisting">
<span class="hl num">1</span> <span class="hl opt">-</span> a
</pre><p>
		  puede convertir el primer argumento a <code class="classname">Number</code> usando el
		  constructor.
		</p><p>
		  A veces querrá ser capaz de restringir el uso de sus operadores haciéndolos
		  métodos. Por ejemplo, cuando multiplique una matriz por un vector, el vector
		  debe ir a la derecha. Pero si quiere que sus operadores sean capaces de
		  convertir cualquier argumento, haga el operador una función <code class="keyword">friend</code>.
		</p><p>
		  Afortunadamente, el compilador cogerá la expresión <code class="code">1-1</code> y convertirá
		  ambos argumentos a objetos <code class="classname">Number</code> y después llamará a
		  <code class="literal">operator-</code>. Eso significaría que el código C existente podría
		  empezar a funcionar de forma diferente. El compilador intenta primero la
		  correspondencia «más simple», es decir, en este caso el operador
		  incorporado para la expresión <code class="code">1-1</code>.
		</p></div></div><div class="sect2" title="12.6.3. Ejemplo de conversión de tipos"><div class="titlepage"><div><div><h3 class="title"><a id="idp7449408"></a>12.6.3. Ejemplo de conversión de tipos</h3></div></div></div><p>
		Un ejemplo en el que la conversión automática de tipos es extremadamente útil es
		con cualquier clase que encapsule una cadena de caracteres (en este caso,
		simplemente implementaremos la clase usando la clase estándar de C++
		<code class="type">string</code> dado que es simple). Sin la conversión automática de tipos, si
		quiere usar todas las funciones existentes de <code class="type">string</code> de la librería
		estándar de C, tiene que crear un método para cada una, así:
      </p><div class="example"><a id="idp7451312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:Strings1.cpp</span>
<span class="hl slc">// No auto type conversion</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Stringc <span class="hl opt">{</span>
  string s<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stringc</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> str <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) :</span> <span class="hl kwd">s</span><span class="hl opt">(</span>str<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">strcmp</span><span class="hl opt">(</span><span class="hl kwb">const</span> Stringc<span class="hl opt">&amp;</span> S<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl opt">::</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> S<span class="hl opt">.</span>s<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// ... etc., for every function in string.h</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stringc <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;hello&quot;</span><span class="hl opt">),</span> <span class="hl kwd">s2</span><span class="hl opt">(</span><span class="hl str">&quot;there&quot;</span><span class="hl opt">);</span>
  s1<span class="hl opt">.</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>s2<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.22. C12/Strings1.cpp</strong></p></div><br class="example-break" /><p>
		Aquí, sólo se crea la función <code class="function">strcmp()</code>, pero tendría que
		crear las funciones correspondientes para cada una de
		<code class="filename">&lt;cstring&gt;</code> que necesite. Afortunadamente, puede
		proporcionar una conversión automática de tipos permitiendo el acceso a todas las
		funciones de <code class="filename">&lt;cstring&gt;</code>.
      </p><div class="example"><a id="idp7454520"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:Strings2.cpp</span>
<span class="hl slc">// With auto type conversion</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Stringc <span class="hl opt">{</span>
  string s<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stringc</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> str <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) :</span> <span class="hl kwd">s</span><span class="hl opt">(</span>str<span class="hl opt">) {}</span>
  <span class="hl kwc">operator</span> <span class="hl kwb">const char</span><span class="hl opt">*()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    <span class="hl kwa">return</span> s<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">();</span> 
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stringc <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;hello&quot;</span><span class="hl opt">),</span> <span class="hl kwd">s2</span><span class="hl opt">(</span><span class="hl str">&quot;there&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">strcmp</span><span class="hl opt">(</span>s1<span class="hl opt">,</span> s2<span class="hl opt">);</span> <span class="hl slc">// Standard C function</span>
  <span class="hl kwd">strspn</span><span class="hl opt">(</span>s1<span class="hl opt">,</span> s2<span class="hl opt">);</span> <span class="hl slc">// Any string function!</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.23. C12/Strings2.cpp</strong></p></div><br class="example-break" /><p>
		Ahora cualquier función que acepte un argumento <code class="type">char*</code> puede aceptar
		también un argumento <code class="classname">Stringc</code> porque el compilador sabe cómo
		crear un <code class="type">char*</code> a partir de <code class="classname">Stringc</code>.
      </p></div><div class="sect2" title="12.6.4. Las trampas de la conversión automática de tipos"><div class="titlepage"><div><div><h3 class="title"><a id="idp7457368"></a>12.6.4. Las trampas de la  conversión automática de tipos</h3></div></div></div><p>
		Dado que el compilador debe decidir cómo realizar una conversión de tipos, puede
		meterse en problemas si el programador no diseña las conversiones
		correctamente. Una situación obvia y simple sucede cuando una clase
		<code class="classname">X</code> que puede convertirse a sí misma en una clase
		<code class="classname">Y</code> con un <code class="literal">operator Y()</code>. Si la clase
		<code class="classname">Y</code> tiene un constructor que toma un argumento simple de tipo
		<code class="classname">X</code>, esto representa la conversión de tipos idéntica. El
		compilador ahora tiene dos formas de ir de <code class="classname">X</code> a
		<code class="classname">Y</code>, así que se generará una error de ambigüedad:
      </p><div class="example"><a id="idp7460664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:TypeConversionAmbiguity.cpp</span>
<span class="hl kwc">class</span> Orange<span class="hl opt">;</span> <span class="hl slc">// Class declaration</span>

<span class="hl kwc">class</span> Apple <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">operator</span> <span class="hl kwd">Orange</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span> <span class="hl slc">// Convert Apple to Orange</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Orange <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Orange</span><span class="hl opt">(</span>Apple<span class="hl opt">);</span> <span class="hl slc">// Convert Apple to Orange</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Orange<span class="hl opt">) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Apple a<span class="hl opt">;</span>
<span class="hl slc">//! f(a); // Error: ambiguous conversion</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.24. C12/TypeConversionAmbiguity.cpp</strong></p></div><br class="example-break" /><p>
		La solución obvia a este problema es no hacerla. Simplemente proporcione una ruta
		única para la conversión automática de un tipo a otro.
      </p><p>
		Un problema más difícil de eliminar sucede cuando proporciona conversiones
		automáticas a más de un tipo. Esto se llama a veces
		<span class="emphasis"><em>acomodamiento</em></span> (FIXME):
      </p><div class="example"><a id="idp7463112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:TypeConversionFanout.cpp</span>
<span class="hl kwc">class</span> Orange <span class="hl opt">{};</span>
<span class="hl kwc">class</span> Pear <span class="hl opt">{};</span>

<span class="hl kwc">class</span> Apple <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">operator</span> <span class="hl kwd">Orange</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwc">operator</span> <span class="hl kwd">Pear</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl slc">// Overloaded eat():</span>
<span class="hl kwb">void</span> <span class="hl kwd">eat</span><span class="hl opt">(</span>Orange<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">eat</span><span class="hl opt">(</span>Pear<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Apple c<span class="hl opt">;</span>
<span class="hl slc">//! eat(c);</span>
  <span class="hl slc">// Error: Apple -&gt; Orange or Apple -&gt; Pear ???</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.25. C12/TypeConversionFanout.cpp</strong></p></div><br class="example-break" /><p>
		La clase <code class="classname">Apple</code> tiene conversiones automáticas a
		<code class="classname">Orange</code> y a <code class="classname">Pear</code>. El elemento
		capcioso aquí es que no hay problema hasta que alguien inocentemente crea dos
		versiones sobrecargadas de <code class="function">eat()</code>. (Con una única versión el
		codigo en <code class="function">main()</code> funciona correctamente).
      </p><p>
		De nuevo la solución -- y el lema general de la conversión automática de tipos --
		es proporcionar solo una conversión automática de un tipo a otro. Puede tener
		conversiones a otros tipos, sólo que no deberían ser
		<span class="emphasis"><em>automáticas</em></span>. Puede crear llamadas a funciones explícitas con
		nombres como <code class="function">makeA()</code> y <code class="function">makeB()</code>.
      </p><div class="sect3" title="Actividades ocultas"><div class="titlepage"><div><div><h4 class="title"><a id="idp7468280"></a>Actividades ocultas</h4></div></div></div><p>
		  La conversión automática de tipos puede producir mas actividad subyacente de la
		  que se podría esperar. Mire esta modificación de
		  <code class="filename">CopyingVsInitialization.cpp</code> como un pequeño rompecabezas:
		</p><div class="example"><a id="idp7469560"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C12:CopyingVsInitialization2.cpp</span>
<span class="hl kwc">class</span> Fi <span class="hl opt">{};</span>

<span class="hl kwc">class</span> Fee <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Fee</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
  <span class="hl kwd">Fee</span><span class="hl opt">(</span><span class="hl kwb">const</span> Fi<span class="hl opt">&amp;) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Fo <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Fo</span><span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>x<span class="hl opt">) {}</span>
  <span class="hl kwc">operator</span> <span class="hl kwd">Fee</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwd">Fee</span><span class="hl opt">(</span>i<span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Fo fo<span class="hl opt">;</span>
  Fee fee <span class="hl opt">=</span> fo<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 12.26. C12/CopyingVsInitialization2.cpp</strong></p></div><br class="example-break" /><p>
		  No hay un constructor para crear <code class="varname">Fee fee</code> de un objeto
		  <code class="classname">Fo</code>. Sin embargo, <code class="classname">Fo</code> tiene una
		  conversión automática de tipos a <code class="classname">Fee</code>. No hay un
		  constructor de copia para crear un <code class="classname">Fee</code> a partir de un
		  <code class="classname">Fee</code>, pero ésa es una de las funciones especiales que el
		  compilador puede crear. (El constructor por defecto, el constructor de
		  copia y <code class="literal">operator=</code>) y el destructor pueden sintetizarse
		  automáticamente por el compilador. Así que, para la relativamente inocua
		  expresión:
		</p><pre class="programlisting">
Fee fee <span class="hl opt">=</span> fo<span class="hl opt">;</span>
</pre><p>
		  se invoca el operador de conversión automático de tipo, y se crea un constructor
		  de copia.
		</p><p>
		  Use la conversión automática de tipos con precaución. Como con toda la
		  sobrecarga de operadores, es excelente cuando reduce la tarea de codificación
		  significativamente, pero no vale la pena usarla de forma gratuita.
		</p></div></div></div><div class="sect1" title="12.7. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7475640"></a>12.7. Resumen</h2></div></div></div><p>
      El motivo de la existencia de la sobrecarga de operadores es para aquellas
      situaciones en la que la vida. No hay nada particularmente mágico en ello; los
      operadores sobrecargados son solo funciones con nombres divertidos, y el compilador
      realiza las invocaciones a esas funciones cuando aparece el patrón adecuado. Pero si
      la sobrecarga de operadores no proporciona un beneficio significativo el creador de
      la clase o para el usuario de la clase, no complique el asunto añadiéndolos.
    </p></div><div class="sect1" title="12.8. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7477136"></a>12.8. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		  Cree una clase sencilla con un operador sobrecargado <code class="literal">++</code>. Intente
		  llamar a este operador en la forma prefija y postfija y vea qué clase de
		  advertencia obtiene del compilador.
		</p></li><li class="listitem"><p>
		  Cree una clase sencilla que contenga un <code class="type">int</code> y sobrecargue
		  el operador <code class="literal">+</code> como un método. Cree también un método
		  <code class="function">print()</code> que tome un
		  <code class="classname">ostream&amp;</code> como un argumento y lo imprima a
		  un <code class="classname">ostream&amp;</code>. Pruebe su clase para comprobar
		  que funciona correctamente.
		</p></li><li class="listitem"><p>
		  Añada un operador binario <code class="literal">-</code> al ejercicio 2 como un
		  método. Demuestre que puede usar sus objetos en expresiones complejas
		  como <code class="code">a + b -c</code>.
		</p></li><li class="listitem"><p>
		  Añada un operador <code class="literal">++</code> y otro <code class="literal">--</code> al ejercicio
	      2, ambos con las versiones prefijas y postfijas, tales que devuelvan
	      el objeto incrementado o decrementado. Asegúrese de que la versión
	      postfija devuelve el valor correcto.
	    </p></li><li class="listitem"><p>
		  Modifique los operadores de incremento y decremento del ejercicio 4
		  para que la versión prefija devuelva una referencia no <code class="keyword">const</code> y
		  la postfija devuelva un objeto <code class="keyword">const</code>. Muestre que funcionan
		  correctamente y explique porqué esto se puede hacer en la práctica.
	    </p></li><li class="listitem"><p>
		  Cambie la función <code class="function">print()</code> del ejercicio2 para que
		  use el operador sobrecargado <code class="literal">&lt;&lt;</code> como en
		  <code class="filename">IostreamOperatorOverloading.cpp</code>.
	</p></li><li class="listitem"><p>
	  Modifique el ejercicio 3 para que los operadores <code class="literal">+</code> y
	  <code class="literal">-</code> no sean métodos. Demuestre que todavía funcionan
	  correctamente.
	</p></li><li class="listitem"><p>
	  Añada el operador unario <code class="literal">-</code> al ejercicio 2 y demuestre que
	  funciona correctamente.
	</p></li><li class="listitem"><p>
	  Cree una clase que contenga un único <code class="type">private
	    char</code>. Sobrecargue los operadores de flujos de entrada/salida
	    <code class="literal">&lt;&lt;</code> y <code class="literal">&gt;&gt;</code> (como en
	    <code class="filename">IostreamOperatorOverloading.cpp</code>) y pruébelos. Puede
	    probarlos con <code class="literal">fstreams</code>,
	    <code class="literal">stringstreams</code> y <code class="literal">cin</code> y
	    <code class="literal">cout</code>.
	</p></li><li class="listitem"><p>
	  Determine el valor constante ficticio que su compilador pasa
	  a los operadores postfijos <code class="literal">++</code> y
	  <code class="literal">--</code>.
	</p></li><li class="listitem"><p>
		Escriba una clase <code class="classname">Number</code> que contenga un
		<code class="type">double</code> y añada operadores sobrecargados para
		<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code> y la
		asignación. Elija los valores de retorno para estas funciones para que
		las expresiones se puedan encadenar y que sea eficiente.
		Escriba una conversión automática de tipos <code class="type">operator int()</code>.
	</p></li><li class="listitem"><p>
		Modifique el ejercicio 11 para que use la <span class="emphasis"><em>optimización del
		valor de retorno</em></span>, si todavía no lo ha hecho.
	  </p></li><li class="listitem"><p>
	  Cree una clase que contenga un puntero, y demuestre que si permite al
	  compilador sintetizar el operador <code class="literal">=</code> el resultado de usar ese
	  operador serán punteros que estarán solapados en la misma ubicación de
	  memoria. Ahora arregle el problema definiendo su propio operador
	  <code class="literal">=</code> y demuestre que corrige el solapamiento. Asegúrese que
	  comprueba la auto-asignación y que maneja el caso apropiadamente.
	</p></li><li class="listitem"><p>
	  Escriba una clase llamada <code class="classname">Bird</code> que contenga un
	  miembro <code class="type">string</code> y un <code class="type">static int</code>. En el
	  constructor por defecto, use el <code class="type">int</code> para generar
	  automáticamente un identificador que usted construya en el
	  <code class="type">string</code> junto con el nombre de la clase(<code class="varname">Bird
	  #1</code>, <code class="varname">Bird #2</code>, etc). Añada un operador
	  <code class="literal">&lt;;&lt;</code> para flujos de salida para imprimir los objetos
	  <code class="classname">Bird</code>-Escriba un operador de asignación
	  <code class="literal">=</code> y un constructor de copia. En <code class="function">main()</code>
	  verifique que todo funciona correctamente.
	</p></li><li class="listitem"><p>
	  Escriba una clase llamada <code class="classname">BirdHouse</code> que contenga un
	  objeto, un puntero y una referencia para la clase
	  <code class="classname">Bird</code> del ejercicio 14. El constructor debería tomar
	  3 <code class="classname">Birds</code> como argumentos. Añada un operador
	  <code class="literal">&lt;&lt;</code> de flujo de salida para
	  <code class="classname">BirdHouse</code>. Deshabilite el operador de asignación
	  <code class="literal">=</code> y el constructor de copia. En <code class="function">main()</code>
	  verifique que todo funciona correctamente.
	</p></li><li class="listitem"><p>
		Añada un miembro de datos <code class="type">int</code> a <code class="classname">Bird</code>
		y a <code class="classname">BirdHouse</code> en el ejercicio 15. Añada
		operadores miembros <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code> y
		<code class="literal">/</code> que usen el miembro <code class="type">int</code> para realizar las
		operaciones en los respectivos miembros. Verifique que funcionan.
	  </p></li><li class="listitem"><p>
		Repita el ejercicio 16 usando operadores no miembro.
	  </p></li><li class="listitem"><p>
		Añada un operador <code class="literal">-</code> a <code class="filename">SmartPointer.cpp</code>
		y a <code class="filename">NestedSmartPointer.cpp</code>.
	</p></li><li class="listitem"><p>
		Modifique <code class="filename">CopyingVsInitialization.cpp</code> para que
		todos los constructores impriman un mensaje que explique qué está
		pasando. Ahora verifique que las dos maneras de llamar al constructor de
		copia (la de asignación y la de paréntesis) son equivalentes.
	  </p></li><li class="listitem"><p>
		Intente crear un operador no miembro <code class="literal">=</code> para una clase y vea qué clase
		de mensaje del compilador recibe.
	  </p></li><li class="listitem"><p>
		  Cree una clase con un operador de asignación que tenga un segundo argumento, un
		  <code class="classname">string</code> que tenga un valor por defecto que diga <code class="code">op =
		  call</code>. Cree una función que asigne un objeto de su clase a otro y muestre
		  que su operador de asignación es llamado correctamente.
		</p></li><li class="listitem"><p>
		En <code class="filename">CopyingWithPointers.cpp</code> elimine el operador
		<code class="literal">=</code> en <code class="classname">DogHouse</code> y muestre que el
		operador <code class="literal">=</code> sintetizado por el compilador copia
		correctamente <code class="classname">string</code> pero es simplemente un alias
		del puntero <code class="classname">Dog</code>.
	</p></li><li class="listitem"><p>
		En <code class="filename">ReferenceCounting.cpp</code> añada un <code class="type">static
		  int</code> y un <code class="type">int</code> ordinario como atributos a
		  <code class="classname">Dog</code> y a <code class="classname">DogHouse</code>. En
		  todos los constructores para ambas clases, incremente el <code class="type">static
		  int</code> y asigne el resultado al <code class="type">int</code> ordinario para
		  mantener un seguimiento del número de objetos que están siendo
		  creados. Haga las modificaciones necesarias para que todas las
		  sentencias de impresión muestren los identificadores <code class="type">int</code>
		  de los objetos involucrados.
	</p></li><li class="listitem"><p>
		Cree una clase que contenga un <code class="classname">string</code> como
		atributo. Inicialice el <code class="classname">string</code> en el constructor,
		pero no cree un constructor de copia o un operador <code class="literal">=</code>. Haga
		una segunda clase que tenga un atributo de su primera clase; no cree un
		constructor de copia o un operador <code class="literal">=</code> para esta clase
		tampoco. Demuestre que el constructor de copia y el operador
		<code class="literal">=</code> son sintetizados correctamente por el compilador.
	  </p></li><li class="listitem"><p>
		Combine las clases en <code class="filename">OverloadingUnaryOperators.cpp</code>
		y en <code class="filename">Integer.cpp</code>.
	  </p></li><li class="listitem"><p>
		Modifique <code class="filename">PointerToMemmberOperator.cpp</code> añadiendo
		dos nuevas funciones miembro a <code class="classname">Dog</code> que no tomen
		argumentos y devuelvan <code class="type">void</code>. Cree y compruebe un operador
		sobrecargado <code class="literal">-&gt;*</code> que funcione con sus dos nuevas funciones.
	  </p></li><li class="listitem"><p>
		Añada un operador <code class="literal">-&gt;*</code> a
		<code class="filename">NestedSmartPointer.cpp</code>.
	  </p></li><li class="listitem"><p>
		Cree dos clases, <code class="classname">Apple</code> y
		<code class="classname">Orange</code>. En <code class="classname">Apple</code>, cree un
		constructor que tome una <code class="classname">Orange</code> como
		argumento. Cree una función que tome un <code class="classname">Apple</code> y
		llame a esa función con una una <code class="classname">Orange</code> para
		demostrar que funciona. Ahora haga explícito el constructor de
		<code class="classname">Apple</code> para demostrar que así se evita la
		conversión automática de tipos. Modifique la llamada a su función para
		que la la conversión se haga explícitamente y de ese modo, funcione.
	  </p></li><li class="listitem"><p>
		Añada un operador global <code class="literal">*</code> a
		<code class="filename">ReflexivityInOverloading.cpp</code> y demuestre que es
		reflexivo.
	  </p></li><li class="listitem"><p>
		Cree dos clases y un operador <code class="literal">+</code> y las funciones de
		conversión de tal manera que la adicción sea reflexiva para las dos
		clases.
	  </p></li><li class="listitem"><p>
		Arregle <code class="filename">TypeConversionFanout.cpp</code> creando una
		función explícita para realizar la conversión de tipo, en lugar de uno
		de los operadores de conversión automáticos.
	  </p></li><li class="listitem"><p>
		Escriba un código simple que use los operadores <code class="literal">+</code>,
		<code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code> para
		<code class="type">double</code>. Imagine cómo el compilador genera el codigo
		ensamblador y mire el ensamblador que se genera en realidad para
		descubrir y explicar qué está ocurriendo «bajo el capó».
	  </p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp7334272" href="#idp7334272" class="para">70</a>] </sup>
			Rob Murray, <em class="citetitle">
			  C++ Strategies &amp; Tactics
			</em>, Addison Wesley, 1993, pagina 47.
		  </p></div></div></div><div class="chapter" title="13: Creación dinámica de objetos"><div class="titlepage"><div><div><h2 class="title"><a id="C13"></a>13: Creación dinámica de objetos</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp7553248">13.1. Creación de objetos</a></span></dt><dt><span class="sect1"><a href="#idp7609552">13.2. Rediseño de los ejemplos anteriores</a></span></dt><dt><span class="sect1"><a href="#idp7672640">13.3. 
      <code class="keyword">new</code> y <code class="keyword">delete</code> para vectores
    </a></span></dt><dt><span class="sect1"><a href="#idp7828752">13.4. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp7832696">13.5. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      A veces se conoce la cantidad exacta exacta, el tipo y duración de la vida de los
      objetos en un programa, pero no siempre es así.
    </p></div><p>
    ¿Cuántos aviones tendrá que supervisar un sistema de control de tráfico aéreo?
    ¿Cuántas formas o figuras se usarán en un sistema CAD? ¿Cuántos nodos habrá en una
    red?
  </p><p>
    Para resolver un problema general de programación, es esencial poder crear y destruir
    objetos en tiempo de ejecución. Por supuesto, C proporciona las funciones de
    asignación dinámica de memoria <code class="function">malloc()</code> y sus variantes, y
    <code class="function">free()</code>, que permiten obtener y liberar bloques en el espacio de
    memoria del <span class="emphasis"><em>montículo</em></span> (también llamado <span class="emphasis"><em>espacio
    libre</em></span><sup>[<a id="idp7544576" href="#ftn.idp7544576" class="footnote">71</a>]</sup> mientras se ejecuta el programa.
  </p><p>
    Este método sin embargo, no funcionará en C++. El constructor no le permite manipular
    la dirección de memoria a inicializar, y con motivo. De permitirse, sería posible:
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		Olvidar la llamada al constructor. Con lo cual no sería posible garantizar la
		inicialización de los objetos en C++.
      </p></li><li class="listitem"><p>
		Usar accidentalmente un objeto que aún no ha sido inicializado, esperando que todo
		vaya bien.
      </p></li><li class="listitem"><p>
		Manipular un objeto de tamaño incorrecto.
      </p></li></ol></div><p>
    Y por supuesto, incluso si se hizo todo correctamente, cualquiera que modifique el
    programa estaría expuesto a cometer esos mismos errores. Una gran parte de los
    problemas de programación tienen su origen en la inicialización incorrecta de objetos,
    lo que hace especialmente importante garantizar la llamada a los constructores para
    los objetos que han de ser creados en el montículo.
  </p><p>
    ¿Cómo se garantiza en C++ la correcta inicialización y limpieza, permitiendo la
    creación dinámica de objetos?
  </p><p>
    La respuesta está en integrar en el lenguaje mismo la creación dinámica de
    objetos. <code class="function">malloc()</code> y <code class="function"> free()</code> son funciones de
    biblioteca y por tanto, están fuera del control del compilador. Si se dispone de un
    <span class="emphasis"><em>operador</em></span> que lleve a cabo el acto combinado de la asignación
    dinámica de memoria y la inicialización, y de otro operador que realice el acto
    combinado de la limpieza y de liberación de memoria, el compilador podrá garantizar la
    llamada a los constructores y destructores de los objetos.
  </p><p>
    En este capítulo verá cómo se resuelve de modo elegante este problema con los
    operadores <code class="keyword">new</code> y <code class="keyword">delete</code> de C++.
  </p><div class="sect1" title="13.1. Creación de objetos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7553248"></a>13.1. Creación de objetos</h2></div></div></div><p>
      La creación de un objeto en C++ tiene lugar en dos pasos:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Asignación de memoria para el objeto.</p></li><li class="listitem"><p>Llamada al constructor. </p></li></ol></div><p>
      Aceptemos por ahora que este segundo paso ocurre <span class="emphasis"><em>siempre</em></span>. C++
      lo fuerza, debido a que el uso de objetos no inicializados es una de las causas más
      frecuentes de errores de programación. Siempre se invoca al constructor, sin
      importar cómo ni dónde se crea el objeto.
    </p><p>
      El primero de estos pasos puede ocurrir de varios modos y en diferente momento:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		  Asignación de memoria en la zona de almacenamiento estático, que tiene lugar
		  durante la carga del programa.  El espacio de memoria asignado al objeto existe
		  hasta que el programa termina.
		</p></li><li class="listitem"><p>
		  Asignación de memoria en la pila, cuando se alcanza algún punto determinado
		  durante la ejecución del programa (la llave de apertura de un bloque). La
		  memoria asignada se vuelve a liberar de forma automática en cuanto se alcanza el
		  punto de ejecución complementario (la llave de cierre de un bloque). Las
		  operaciones de manipulación de la pila forman parte del conjunto de
		  instrucciones del procesador y son muy eficientes. Por otra parte, es necesario
		  saber cuantas variables se necesitan mientras se escribe el programa de modo que
		  el copilador pueda generar el código correspondiente.
		</p></li><li class="listitem"><p>
		  Asignación dinámica, en una zona de memoria libre llamada montículo
		  (<span class="foreignphrase"><em class="foreignphrase">heap</em></span> o <span class="foreignphrase"><em class="foreignphrase">free
		  store</em></span>). Se reserva espacio para un objeto en esta zona mediante
		  la llamada a una función durante la ejecución del programa; esto significa que
		  se puede decidir en cualquier momento que se necesita cierta cantidad de
		  memoria. Esto conlleva la responsabilidad de determinar el momento en que ha de
		  liberarse la memoria, lo que implica determinar el tiempo de vida de la misma
		  que, por tanto, ya no está bajo control de las reglas de ámbito.
	</p></li></ol></div><p>
      A menudo, las tres regiones de memoria referidas se disponen en una zona contigua de
      la memoria física: área estática, la pila, y el montículo, en un orden determinado
      por el escritor del compilador. No hay reglas fijas. La pila puede estar en una zona
      especial, y puede que las asignaciones en el montículo se obtengan mediante petición
      de bloques de la memoria del sistema operativo. Estos detalles quedan normalmente
      ocultos al programador puesto que todo lo que se necesita conocer al respecto es que
      esa memoria estará disponible cuando se necesite.
    </p><div class="sect2" title="13.1.1. Asignación dinámica en C"><div class="titlepage"><div><div><h3 class="title"><a id="idp7562536"></a>13.1.1. Asignación dinámica en C</h3></div></div></div><p>
		C proporciona las funciones de su biblioteca estándar
		<code class="function">malloc()</code> y sus variantes <code class="function">calloc()</code> y
		<code class="function">realloc()</code> para asignar, y <code class="function">free()</code> para
		liberar bloques de memoria dinámicamente en tiempo de ejecución. Estas funciones
		son pragmáticas pero rudimentarias por lo que requieren comprensión y un cuidadoso
		manejo por parte del programador. El listado que sigue es un ejemplo que ilustra
		el modo de crear una instancia de una clase con estas funciones de C:
      </p><div class="example"><a id="idp7565368"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:MallocClass.cpp</span>
<span class="hl slc">// Malloc with class objects</span>
<span class="hl slc">// What you'd have to do if not for &quot;new&quot;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span> <span class="hl slc">// malloc() &amp; free()</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;cstring&gt;</span> <span class="hl slc">// memset()</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Obj <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> sz <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">char</span> buf<span class="hl opt">[</span>sz<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">() {</span> <span class="hl slc">// Can't use constructor</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;initializing Obj&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    i <span class="hl opt">=</span> j <span class="hl opt">=</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwd">memset</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> sz<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">destroy</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl slc">// Can't use destructor</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;destroying Obj&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Obj<span class="hl opt">*</span> obj <span class="hl opt">= (</span>Obj<span class="hl opt">*)</span><span class="hl kwd">malloc</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span>Obj<span class="hl opt">));</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>obj <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  obj<span class="hl opt">-&gt;</span><span class="hl kwd">initialize</span><span class="hl opt">();</span>
  <span class="hl slc">// ... sometime later:</span>
  obj<span class="hl opt">-&gt;</span><span class="hl kwd">destroy</span><span class="hl opt">();</span>
  <span class="hl kwd">free</span><span class="hl opt">(</span>obj<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.1. C13/MallocClass.cpp</strong></p></div><br class="example-break" /><p>
		Observe el uso de <code class="function">malloc()</code> para la obtención de espacio para
		el objeto:
      </p><pre class="programlisting">
Obj<span class="hl opt">*</span> obj <span class="hl opt">= (</span>Obj<span class="hl opt">*)</span><span class="hl kwd">malloc</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span>Obj<span class="hl opt">));</span>
</pre><p>
		Se debe pasar como parámetro a <code class="function">malloc()</code> el tamaño del
		objeto. El tipo de retorno de <code class="function">malloc()</code> es <code class="type">void*</code>,
		pues es sólo un puntero a un bloque de memoria, no un objeto. En C++ no se permite
		la asignación directa de un <code class="type">void*</code> a ningún otro tipo de
		puntero, de ahí la necesidad de la conversión explícita de tipo (molde).
      </p><p>
		Puede ocurrir que <code class="function">malloc()</code> no encuentre un bloque adecuado,
		en cuyo caso devolverá un puntero nulo, de ahí la necesidad de comprobar la
		validez del puntero devuelto.
      </p><p>
		El principal escollo está en la línea:
      </p><pre class="programlisting">
obj<span class="hl opt">-&gt;</span><span class="hl kwd">initialize</span><span class="hl opt">();</span>
</pre><p>
		El usuario deberá asegurarse de inicializar el objeto antes de su uso. Obsérvese
		que no se ha usado el constructor debido a que éste no puede ser llamado de modo
		explícito <sup>[<a id="idp7572328" href="#ftn.idp7572328" class="footnote">72</a>]</sup>; es llamado por el compilador cuando se crea un
		objeto.  El problema es que el usuario puede olvidar inicializar el objeto antes
		de usarlo, introduciendo así una importante fuente de problemas.
      </p><p>
		Como consecuencia, muchos programadores encuentran muy confusas y complicadas las
		funciones de asignación dinámica de la memoria en C. No es muy difícil encontrar
		programadores que, usando máquinas con memoria virtual, usan vectores enormes en
		el área de almacenamiento estático para evitar tener que tratar con la asignación
		dinámica. Dado que C++ intenta facilitar el uso de la biblioteca a los
		programadores ocasionales, no es aceptable la forma de abordar la asignación
		dinámica en C.
      </p></div><div class="sect2" title="13.1.2. El operador new"><div class="titlepage"><div><div><h3 class="title"><a id="idp7574680"></a>13.1.2. El operador <code class="keyword">new</code></h3></div></div></div><p>
		La solución que ofrece C++ consiste en combinar la serie de acciones necesarias
		para la creación de un objeto en un único operador llamado <code class="keyword">&gt;new</code>. Cuando
		se crea un objeto mediante el operador <code class="keyword">&gt;new</code>, éste se encarga de obtener
		el espacio necesario para el objeto y de llamar a su constructor. Cuando se
		ejecuta el código:
      </p><pre class="programlisting">
MyType <span class="hl opt">*</span>fp <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">MyType</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span><span class="hl num">2</span><span class="hl opt">);</span>
</pre><p>
		se asigna espacio mediante alguna llamada equivalente a
		<code class="code">&gt;malloc(sizeof(MyType))</code> --con frecuencia es así, literalmente--, y
		usando la dirección obtenida como puntero <code class="keyword">&gt;this</code>, y <code class="code">(1, 2)</code>
		como argumentos, se llama al constructor de la clase
		<code class="classname">MyType</code>.  Para cuando está disponible, el valor de retorno
		de <code class="keyword">new</code> es ya un puntero válido a un objeto inicializado. Además es del
		tipo correcto, lo que hace innecesaria la conversión.
      </p><p>
		El operador <code class="keyword">new</code> por defecto, comprueba el éxito o fracaso de la
		asignación de memoria como paso previo a la llamada al constructor, haciendo
		innecesaria y redundante la posterior comprobación.  Más adelante en este capítulo
		se verá qué sucede si se produce este fallo.
      </p><p>
		En las expresiones con <code class="keyword">new</code> se puede usar cualquiera de los constructores
		disponibles para una clase. Si éste no tiene argumentos, se escribe la expresión
		sin lista de argumentos
      </p><pre class="programlisting">
MyType <span class="hl opt">*</span>fp <span class="hl opt">=</span> <span class="hl kwa">new</span> MyType<span class="hl opt">;</span>
</pre><p>
		Es notable la simpleza alcanzada en la creación dinámica de objetos: una única
		expresión realiza todo el trabajo de cálculo de tamaño, asignación, comprobaciones
		de seguridad y conversión de tipo. Esto hace que la creación dinámica de objetos
		sea tan sencilla como la creación en la pila.
      </p></div><div class="sect2" title="13.1.3. El operador delete"><div class="titlepage"><div><div><h3 class="title"><a id="idp7583704"></a>13.1.3. El operador <code class="keyword">delete</code></h3></div></div></div><p>
		El complemento a la expresión <code class="keyword">new</code> es la expresión <code class="keyword">delete</code>, que
		primero llama al destructor y después libera la memoria (a menudo mediante una
		llamada a <code class="function">free()</code>). El argumento para una expresión con
		<code class="keyword">delete</code> debe ser una dirección: un puntero a objeto creado mediante
		<code class="keyword">new</code>.
      </p><pre class="programlisting">
<span class="hl kwa">delete</span> fp<span class="hl opt">;</span>
</pre><p>
		Esta expresión destruye el objeto y después libera el espacio dinámicamente
		asignado al objeto <code class="type">MyType</code>
      </p><p>
		El uso del operador <code class="keyword">delete</code> debe limitarse a los objetos que hayan sido
		creados mediante <code class="keyword">new</code>. Las consecuencias de aplicar el operador
		<code class="keyword">delete</code> a los objetos creados con <code class="function">malloc()</code>,
		<code class="function">calloc()</code> o <code class="function">realloc()</code> no están
		definidas. Dado que la mayoría de las implementaciones por defecto de <code class="keyword">new</code>
		y <code class="keyword">delete</code> usan <code class="function">malloc()</code> y
		<code class="function">free()</code>, el resultado será probablemente la liberación de la
		memoria sin la llamada al destructor.
      </p><p>
		No ocurre nada si el puntero que se le pasa a <code class="keyword">delete</code> es nulo. Por esa
		razón, a menudo se recomienda asignar cero al puntero inmediatamente después de
		usar <code class="keyword">delete</code>; se evita así que pueda ser usado de nuevo como argumento
		para <code class="keyword">delete</code>. Tratar de destruir un objeto más de una vez es un error de
		consecuencias imprevisibles.
      </p></div><div class="sect2" title="13.1.4. Un ejemplo sencillo"><div class="titlepage"><div><div><h3 class="title"><a id="idp7595720"></a>13.1.4. Un ejemplo sencillo</h3></div></div></div><p>
		El siguiente ejemplo demuestra que la inicialización tiene lugar:
      </p><div class="example"><a id="idp7596416"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:Tree.h</span>
<span class="hl ppc">#ifndef TREE_H</span>
<span class="hl ppc">#define TREE_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwc">class</span> Tree <span class="hl opt">{</span>
  <span class="hl kwb">int</span> height<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Tree</span><span class="hl opt">(</span><span class="hl kwb">int</span> treeHeight<span class="hl opt">) :</span> <span class="hl kwd">height</span><span class="hl opt">(</span>treeHeight<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Tree</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;*&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Tree<span class="hl opt">*</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Tree height is: &quot;</span>
              <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">-&gt;</span>height <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// TREE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 13.2. C13/Tree.h</strong></p></div><br class="example-break" /><p>
		Se puede probar que el constructor es invocado imprimiendo el valor de
		<code class="classname">Tree</code>. Aquí se hace sobrecargando el <code class="function">operator
		&lt;&lt;</code> para usarlo con un <code class="varname">ostream</code> y un
		<code class="type">Tree*</code>. Note, sin embargo, que aunque la función está declarada como
		<code class="keyword">friend</code>, está definida como una <code class="keyword">inline</code>!. Esto es así por
		conveniencia --definir una función amiga como <code class="keyword">inline</code> a una clase no
		cambia su condición de amiga o el hecho de que es una función global y no un
		método. También resaltar que el valor de retorno es el resultado de una expresión
		completa (el <code class="type">ostream&amp;</code>), y así debe ser, para satisfacer el
		tipo del valor de retorno de la función.
      </p></div><div class="sect2" title="13.1.5. Trabajo extra para el gestor de memoria"><div class="titlepage"><div><div><h3 class="title"><a id="idp7601840"></a>13.1.5. Trabajo extra para el gestor de memoria</h3></div></div></div><p>
		Cuando se crean objetos automáticos en la pila, el tamaño de los objetos y su
		tiempo de vida queda fijado en el código generado, porque el compilador conoce su
		tipo, cantidad y alcance. Crear objetos en el montículo implica una sobrecarga
		adicional, tanto en tiempo como en espacio. Veamos el escenario típico (Puede
		reemplazar <code class="function">malloc()</code> con <code class="function">calloc()</code> o
		<code class="function">realloc()</code>).
	  </p><p>
		Se invoca <code class="function">malloc()</code>, que pide un bloque de memoria. (Este
		código realmente puede ser parte de <code class="function">malloc()</code>).
	  </p><p>
		Ahora tiene lugar la búsqueda de un bloque de tamaño adecuado de entre los bloques
		libres. Esto requiere la comprobación de un mapa o directorio de algún tipo que
		lleve el registro de los bloques disponibles y de los que están en uso. Es un
		proceso rápido, pero puede que necesite varias pruebas, es pues un proceso no
		determinista. Dicho de otro modo, no se puede contar con que
		<code class="function">malloc()</code> tarde siempre exactamente el mismo tiempo en cada
		búsqueda.
      </p><p>
		Antes de entregar el puntero del bloque obtenido, hay que registrar en alguna
		parte su tamaño y localización para que <code class="function">malloc()</code> no lo vuelva
		a usar y para que cuando se produzca la llamada a <code class="function">free()</code>, el
		sistema sepa cuánto espacio ha de liberar.
      </p><p>
		El modo en que se implementan todas estas operaciones puede variar mucho. No hay
		nada que impida que puedan implementarse las primitivas de asignación de memoria
		en el conjunto de instrucciones del procesador. Si es suficientemente curioso,
		pueden escribir programas que permitan averiguar cómo está implementada
		<code class="function">malloc()</code>. Si dispone de él, puede leer el código fuente de la
		biblioteca de funciones de C, si no, siempre está disponible el de GNU C.
      </p></div></div><div class="sect1" title="13.2. Rediseño de los ejemplos anteriores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7609552"></a>13.2. Rediseño de los ejemplos anteriores</h2></div></div></div><p>
	  Puede reescribirse el ejemplo <code class="classname">Stash</code> que vimos anteriormente
	  en el libro, haciendo uso de los operadores <code class="keyword">new</code> y <code class="keyword">delete</code>, con las
	  características que se han visto desde entonces. A la vista del nuevo código se
	  pueden repasar estas cuestiones.
    </p><p>
	  Hasta este punto del libro, ninguna de las clases <code class="classname">Stash</code> ni
	  <code class="classname">Stack</code> poseerán los objetos a los que apuntan; es decir,
	  cuando el objeto <code class="classname">Stash</code> o <code class="classname">Stack</code> sale de
	  ámbito, no se invoca <code class="keyword">delete</code> para cada uno de los objetos a los que
	  apunta. La razón por la que eso no es posible es porque, en un intento de conseguir
	  más generalidad, utilizan punteros <code class="type">void</code>. Usar <code class="keyword">delete</code> con
	  punteros <code class="literal">void</code> libera el bloque de memoria pero, al no existir
	  información de tipo, el compilador no sabe qué destructor debe invocar.
    </p><div class="sect2" title="13.2.1. delete void* probablemente es un error"><div class="titlepage"><div><div><h3 class="title"><a id="idp7615200"></a>13.2.1. <code class="keyword">delete</code> <code class="type">void*</code> probablemente es un error</h3></div></div></div><p>
		Es necesario puntualizar que, llamar a <code class="keyword">delete</code> con un argumento
		<code class="type">void*</code> es casi con seguridad un error en el programa, a no ser que el
		puntero apunte a un objeto muy simple; en particular, que no tenga un destructor.
		He aquí un ejemplo ilustrativo:
      </p><div class="example"><a id="idp7617544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:BadVoidPointerDeletion.cpp</span>
<span class="hl slc">// Deleting void pointers can cause memory leaks</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Object <span class="hl opt">{</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> data<span class="hl opt">;</span> <span class="hl slc">// Some storage</span>
  <span class="hl kwb">const int</span> size<span class="hl opt">;</span>
  <span class="hl kwb">const char</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Object</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">,</span> <span class="hl kwb">char</span> c<span class="hl opt">) :</span> <span class="hl kwd">size</span><span class="hl opt">(</span>sz<span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>c<span class="hl opt">) {</span>
    data <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">char</span><span class="hl opt">[</span>size<span class="hl opt">];</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Constructing object &quot;</span> <span class="hl opt">&lt;&lt;</span> id 
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, size = &quot;</span> <span class="hl opt">&lt;&lt;</span> size <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Object</span><span class="hl opt">() {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Destructing object &quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span>data<span class="hl opt">;</span> <span class="hl slc">// OK, just releases storage,</span>
    <span class="hl slc">// no destructor calls are necessary</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Object<span class="hl opt">*</span> a <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Object</span><span class="hl opt">(</span><span class="hl num">40</span><span class="hl opt">,</span> <span class="hl str">'a'</span><span class="hl opt">);</span>
  <span class="hl kwa">delete</span> a<span class="hl opt">;</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Object</span><span class="hl opt">(</span><span class="hl num">40</span><span class="hl opt">,</span> <span class="hl str">'b'</span><span class="hl opt">);</span>
  <span class="hl kwa">delete</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.3. C13/BadVoidPointerDeletion.cpp</strong></p></div><br class="example-break" /><p>
		La clase <code class="classname">Object</code> contiene la variable
		<code class="varname">data</code> de tipo <code class="type">void*</code> que es inicializada para
		apuntar a un objeto simple que no tiene destructor. En el destructor de
		<code class="classname">Object</code> se llama a <code class="keyword">delete</code> con este puntero, sin que
		tenga consecuencias negativas puesto que lo único que se necesita aquí es liberar
		la memoria.
      </p><p>
		Ahora bien, se puede ver en <code class="function">main()</code> la necesidad de que
		<code class="keyword">delete</code> conozca el tipo del objeto al que apunta su argumento. Esta es la
		salida del programa:
      </p><pre class="screen">
	Construyendo objeto a, tamaño = 40
	Destruyendo objeto a
	Construyendo objeto b, tamaño = 40
      </pre><p>
		Como <code class="keyword">delete</code> sabe que <code class="varname">a</code> es un puntero a
		<code class="classname">Object</code>, se lleva a cabo la llamada al destructor de
		<code class="classname">Object</code>, con lo que se libera el espacio asignado a
		<code class="varname">data</code>. En cambio, cuando se manipula un objeto usando un
		<code class="type">void*</code>, como es el caso en <code class="code">delete b</code>, se libera el bloque
		de <code class="classname">Object</code>, pero no se efectúa la llamada a su destructor,
		con lo que tampoco se liberará el espacio asignado a <code class="varname">data</code>,
		miembro de <code class="classname">Object</code>. Probablemente no se mostrará ningún
		mensaje de advertencia al compilar el programa; no hay ningún error
		sintáctico. Como resultado obtenemos un programa con una silenciosa fuga de
		memoria.
      </p><p>
		Cuando se tiene una fuga de memoria, se debe buscar entre todas las llamadas a
		<code class="keyword">delete</code> para comprobar el tipo de puntero que se le pasa. Si es un
		<code class="type">void*</code>, puede estar ante una de las posibles causas (Sin embargo, C++
		proporciona otras muchas oportunidades para la fuga de memoria).
      </p></div><div class="sect2" title="13.2.2. Responsabilidad de la limpieza cuando se usan punteros"><div class="titlepage"><div><div><h3 class="title"><a id="idp7627728"></a>13.2.2. Responsabilidad de la limpieza cuando se usan punteros</h3></div></div></div><p>
		Para hacer que los contenedores <code class="classname">Stack</code> y
		<code class="classname">Stash</code> sean flexibles, capaces de recibir cualquier tipo de
		objeto, se usan punteros de tipo <code class="type">void*</code>. Esto hace necesario convertir
		al tipo adecuado los punteros devueltos por las clases
		<code class="classname">Stash</code> y <code class="classname">Stack</code>, antes de que sean
		usados. Hemos visto en la sección anterior, que los punteros deben ser convertidos
		al tipo correcto incluso antes de ser entregados a <code class="keyword">delete</code>, para evitar
		posibles fugas de memoria.
      </p><p>
		Hay otro problema, derivado de la necesidad de llamar a <code class="keyword">delete</code> para cada
		puntero a objeto almacenado en el contenedor. El contenedor no puede realizar la
		limpieza para los punteros que almacena puesto que son punteros
		<code class="type">void*</code>. Esto puede derivar en un serio problema si a un contenedor se
		le pasan punteros a objetos automáticos junto con punteros a objetos dinámicos; el
		resultado de usar <code class="keyword">delete</code> sobre un puntero que no haya sido obtenido del
		montículo es imprevisible. Más aún, al obtener del contenedor un puntero
		cualquiera, existirán dudas sobre el origen, automático, dinámico o estático, del
		objeto al que apunta. Esto implica que hay que asegurarse del origen dinámico de
		los punteros que se almacenen en la siguiente versión de
		<code class="classname">Stash</code> y <code class="classname">Stack</code>, bien sea mediante una
		programación cuidadosa, o bien por la creación de clases que sólo puedan ser
		construidas en el montículo.
      </p><p>
		Es muy importante asegurarse también de que el programador cliente se
		responsabilice de la limpieza de los punteros del contenedor. Se ha visto en
		ejemplos anteriores que la clase <code class="classname">Stack</code> comprobaba en su
		destructor que todos los objetos <code class="classname">Link</code> habían sido
		desapilados. Un objeto <code class="classname">Stash</code> para punteros requiere un modo
		diferente de abordar el problema.
      </p></div><div class="sect2" title="13.2.3. Stash para punteros"><div class="titlepage"><div><div><h3 class="title"><a id="idp7635328"></a>13.2.3. Stash para punteros</h3></div></div></div><p>
		Esta nueva versión de la clase <code class="classname">Stash</code>, que llamamos
		<code class="classname">PStash</code>, almacena punteros a objetos existentes en el
		montículo, a diferencia de la vieja versión, que guardaba una copia por valor de
		los objetos. Usando <code class="keyword">new</code> y <code class="keyword">delete</code>, es fácil y seguro almacenar
		punteros a objetos creados en el montículo.
      </p><p>
		He aquí el archivo de cabecera para «<code class="classname">Stash</code> para
		punteros»:
      </p><div class="example"><a id="idp7638480"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:PStash.h</span>
<span class="hl slc">// Holds pointers instead of objects</span>
<span class="hl ppc">#ifndef PSTASH_H</span>
<span class="hl ppc">#define PSTASH_H</span>

<span class="hl kwc">class</span> PStash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span> <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span> <span class="hl slc">// Next empty space</span>
   <span class="hl slc">// Pointer storage:</span>
  <span class="hl kwb">void</span><span class="hl opt">**</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">PStash</span><span class="hl opt">() :</span> <span class="hl kwd">quantity</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">storage</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">PStash</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span> <span class="hl slc">// Fetch</span>
  <span class="hl slc">// Remove the reference from this PStash:</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl slc">// Number of elements in Stash:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> next<span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// PSTASH_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 13.4. C13/PStash.h</strong></p></div><br class="example-break" /><p>
		Los elementos de datos subyacentes no han cambiado mucho, pero ahora el
		almacenamiento se hace sobre un vector de punteros <code class="type">void</code>, que se
		obtiene mediante <code class="keyword">new</code> en lugar de <code class="function">malloc()</code>.  En la
		expresión
      </p><pre class="programlisting">
<span class="hl kwb">void</span><span class="hl opt">**</span> st <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">void</span><span class="hl opt">*[</span> quantity <span class="hl opt">+</span> increase <span class="hl opt">];</span>
</pre><p>
		se asigna espacio para un vector de punteros a <code class="type">void</code>.
      </p><p>
		El destructor de la clase libera el espacio en el que se almacenan los punteros
		sin tratar de borrar los objetos a los que hacen referencia, ya que esto,
		insistimos, liberaría el espacio asignado a los objetos, pero no se produciría la
		necesaria llamada a sus destructores por la falta de información de tipo.
      </p><p>
		El otro cambio realizado es el reemplazo de la función
		<code class="function">fetch()</code> por <code class="function">operator []</code>, más
		significativo sintácticamente. Su tipo de retorno es nuevamente
		<code class="type">void*</code>, por lo que el usuario deberá recordar el tipo de los objetos a
		que se refieren y efectuar la adecuada conversión al extraerlos del
		contenedor. Resolveremos este problema en capítulos posteriores.
      </p><p>Sigue la definición de los métodos de <code class="classname">PStash</code>:</p><div class="example"><a id="idp7645464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:PStash.cpp {O}</span>
<span class="hl slc">// Pointer Stash definitions</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PStash.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span> <span class="hl slc">// 'mem' functions</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> PStash<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwb">const int</span> inflateSize <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>inflateSize<span class="hl opt">);</span>
  storage<span class="hl opt">[</span>next<span class="hl opt">++] =</span> element<span class="hl opt">;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl slc">// No ownership:</span>
PStash<span class="hl opt">::~</span><span class="hl kwd">PStash</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> next<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>storage<span class="hl opt">[</span>i<span class="hl opt">] ==</span> <span class="hl num">0</span><span class="hl opt">,</span> 
      <span class="hl str">&quot;PStash not cleaned up&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span> 
<span class="hl opt">}</span>

<span class="hl slc">// Operator overloading replacement for fetch</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> PStash<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">,</span>
    <span class="hl str">&quot;PStash::operator[] index negative&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> storage<span class="hl opt">[</span>index<span class="hl opt">];</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> PStash<span class="hl opt">::</span><span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> v <span class="hl opt">=</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span>index<span class="hl opt">);</span>
  <span class="hl slc">// &quot;Remove&quot; the pointer:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>v <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">)</span> storage<span class="hl opt">[</span>index<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> v<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> PStash<span class="hl opt">::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwb">const int</span> psz <span class="hl opt">=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*);</span>
  <span class="hl kwb">void</span><span class="hl opt">**</span> st <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">void</span><span class="hl opt">*[</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">];</span>
  <span class="hl kwd">memset</span><span class="hl opt">(</span>st<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">, (</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">) *</span> psz<span class="hl opt">);</span>
  <span class="hl kwd">memcpy</span><span class="hl opt">(</span>st<span class="hl opt">,</span> storage<span class="hl opt">,</span> quantity <span class="hl opt">*</span> psz<span class="hl opt">);</span>
  quantity <span class="hl opt">+=</span> increase<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span> <span class="hl slc">// Old storage</span>
  storage <span class="hl opt">=</span> st<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.5. C13/PStash.cpp</strong></p></div><br class="example-break" /><p>
		La función <code class="function">add()</code> es, en efecto, la misma que antes si
		exceptuamos el hecho de que lo que se almacena ahora es un puntero a un objeto en
		lugar de una copia del objeto.
      </p><p>
		El código de <code class="function">inflate()</code> ha sido modificado para gestionar la
		asignación de memoria para un vector de <code class="type">void*</code>, a diferencia del
		diseño previo, que sólo trataba con bytes. Aquí, en lugar de usar el método de
		copia por el índice del vector, se pone primero a cero el vector usando la función
		<code class="function">memset()</code> de la biblioteca estándar de C, aunque esto no sea
		estrictamente necesario ya que, presumiblemente, <code class="classname">PStash</code>
		manipulará la memoria de forma adecuada, pero a veces no es muy costoso añadir un
		poco más de seguridad. A continuación, se copian al nuevo vector usando
		<code class="function">memcpy()</code> los datos existentes en el antiguo. Con frecuencia
		verá que las funciones <code class="function">memcpy()</code> y
		<code class="function">memset()</code> han sido optimizadas en cuanto al tiempo de proceso,
		de modo que pueden ser más rápidas que los bucles anteriormente vistos. No
		obstante, una función como <code class="function">inflate()</code> no es probable que sea
		llamada con la frecuencia necesaria para que la diferencia sea palpable. En
		cualquier caso, el hecho de que las llamadas a función sean más concisas que los
		bucles, puede ayudar a prevenir errores de programación.
      </p><p>
		Para dejar definitivamente la responsabilidad de la limpieza de los objetos sobre
		los hombros del programador cliente, se proporcionan dos formas de acceder a los
		punteros en <code class="classname">PStash</code>: el operador <code class="literal">[]</code>, que
		devuelve el puntero sin eliminarlo del contenedor, y un segundo método
		<code class="function">remove()</code> que además de devolver el puntero lo elimina del
		contenedor, poniendo a cero la posición que ocupaba. Cuando se produce la llamada
		al destructor de <code class="classname">PStash</code>, se prueba si han sido previamente
		retirados todos los punteros, si no es así, se notifica, de modo que es posible
		prevenir la fuga de memoria. Se verán otras soluciones mas elegantes en capítulos
		posteriores.
      </p><div class="sect3" title="Una prueba"><div class="titlepage"><div><div><h4 class="title"><a id="idp7657088"></a>Una prueba</h4></div></div></div><p>
		  Aquí aparece el programa de prueba de <code class="classname">Stash</code>, reescrito
		  para <code class="classname">PStash</code>:
		</p><div class="example"><a id="idp7658176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:PStashTest.cpp</span>
<span class="hl slc">//{L} PStash</span>
<span class="hl slc">// Test of pointer Stash</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PStash.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  PStash intStash<span class="hl opt">;</span>
  <span class="hl slc">// 'new' works with built-in types, too. Note</span>
  <span class="hl slc">// the &quot;pseudo-constructor&quot; syntax:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">25</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    intStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> intStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;intStash[&quot;</span> <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span>intStash<span class="hl opt">[</span>j<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Clean up:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> intStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> k<span class="hl opt">++)</span>
    <span class="hl kwa">delete</span> intStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span>k<span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span> <span class="hl opt">(</span><span class="hl str">&quot;PStashTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;PStashTest.cpp&quot;</span><span class="hl opt">);</span>
  PStash stringStash<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    stringStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Print out the strings:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> u <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> stringStash<span class="hl opt">[</span>u<span class="hl opt">];</span> u<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;stringStash[&quot;</span> <span class="hl opt">&lt;&lt;</span> u <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span>string<span class="hl opt">*)</span>stringStash<span class="hl opt">[</span>u<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Clean up:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> v <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> v <span class="hl opt">&lt;</span> stringStash<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">();</span> v<span class="hl opt">++)</span>
    <span class="hl kwa">delete</span> <span class="hl opt">(</span>string<span class="hl opt">*)</span>stringStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span>v<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.6. C13/PStashTest.cpp</strong></p></div><br class="example-break" /><p>
		  Igual que antes, se crean y rellenan varias <code class="classname">Stash</code>, pero
		  esta vez con los punteros obtenidos con <code class="keyword">new</code>. En el primer caso, véase
		  la línea:
		</p><pre class="programlisting">
intStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
</pre><p>
		  Se ha usado una forma de pseudo constructor en la expresión <code class="code">new
		  int(i)</code>, con lo que además de crear un objeto <code class="type">int</code> en el área
		  de memoria dinámica, le asigna el valor inicial <code class="varname">i</code>.
		</p><p>
		  Para imprimir, es necesario convertir al tipo adecuado el puntero obtenido de
		  <code class="function">PStash::operator[]</code>; lo mismo se repite con el resto de los
		  objetos de <code class="classname">PStatsh</code> del programa. Es la consecuencia
		  indeseable del uso de punteros <code class="type">void</code> como representación subyacente,
		  que se corregirá en capítulos posteriores.
		</p><p>
		  En la segunda prueba, se lee línea a línea el propio archivo fuente. Mediante
		  <code class="function">getline()</code> se lee cada línea de texto en una variable de
		  <code class="type">cadena</code>, de la que se crea una copia independiente. Si le hubiéramos
		  pasado cada vez la dirección de <code class="varname">line</code>, tendríamos un montón de
		  copias del mismo puntero, referidas a la última línea leída.
		</p><p>
		  En, en la recuperación de los punteros, verá la expresión:
		</p><pre class="programlisting">
<span class="hl opt">*(</span>string<span class="hl opt">*)</span>stringStash<span class="hl opt">[</span>v<span class="hl opt">];</span>
</pre><p>
		  El puntero obtenido por medio de <code class="function">operator[]</code> debe ser
		  convertido a <code class="type">string*</code> para tener el tipo adecuado. Después el
		  <code class="type">string*</code> es de-referenciado y es visto por el compilador como un
		  objeto <code class="type">string</code> que se envía a <code class="varname">cout</code>.
		</p><p>
		  Antes de destruir los objetos, se han de eliminar las referencias
		  correspondientes mediante el uso de <code class="function">remove()</code>. De no hacerse
		  así, <code class="classname">PStash</code> notificará que no se ha efectuado la limpieza
		  correctamente.  Véase que en el caso de los punteros a <code class="type">int</code>, no es
		  necesaria la conversión de tipo al carecer de destructor, y lo único que se
		  necesita es liberar la memoria:
		</p><pre class="programlisting">
<span class="hl kwa">delete</span> intStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span>k<span class="hl opt">);</span>
</pre><p>
		  En cambio, para los punteros a <code class="type">string</code>, hace falta la conversión de
		  tipo, so pena de crear otra (silenciosa) fuga de memoria, de modo que el molde
		  es esencial:
		</p><pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">(</span>string<span class="hl opt">*)</span> stringStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span>k<span class="hl opt">);</span>
</pre><p>
		  Algunas de estas dificultades pueden resolverse mediante el uso de plantillas,
		  que veremos en el capítulo 16. FIXME:ref
		</p></div></div></div><div class="sect1" title="13.3. new y delete para vectores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7672640"></a>13.3. 
      <code class="keyword">new</code> y <code class="keyword">delete</code> para vectores
    </h2></div></div></div><p>
      En C++ es igual de fácil crear vectores de objetos en la pila o en el montículo, con
      la certeza de que se producirá la llamada al constructor para cada uno de los
      objetos del vector. Hay una restricción: debe existir un constructor por defecto, o
      sea, sin argumentos, que será invocado para cada objeto.
    </p><p>
      Cuando se crean vectores de objetos dinámicamente, usando <code class="keyword">new</code>, hay otras
      cosas que hay que tener en cuenta. Como ejemplo de este tipo de vectores véase
    </p><pre class="programlisting">
MyType<span class="hl opt">*</span> fp <span class="hl opt">=</span> <span class="hl kwa">new</span> MyType<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
</pre><p>
      Esta sentencia asigna espacio suficiente en el montículo para 100 objetos
      <code class="classname">MyType</code> y llama al constructor para cada uno de ellos. Lo que
      se ha obtenido es simplemente un <code class="type">MyType*</code>, exactamente lo mismo que
      hubiera obtenido de esta otra forma, que crea un único objeto:
    </p><pre class="programlisting">
MyType<span class="hl opt">*</span> fp2 <span class="hl opt">=</span> <span class="hl kwa">new</span> MyType<span class="hl opt">;</span>
</pre><p>
      El escritor del programa sabe que <code class="varname">fp</code> es la dirección del primer
      elemento de un vector, por lo que tiene sentido seleccionar elementos del mismo
      mediante una expresión como <code class="code">fp[3]</code>, pero ¿qué pasa cuando
      destruimos el vector?. Las sentencias
    </p><pre class="programlisting">
<span class="hl kwa">delete</span> fp2<span class="hl opt">;</span>  <span class="hl slc">// Correcta</span>
	<span class="hl kwa">delete</span> fp<span class="hl opt">;</span>   <span class="hl slc">// Ésta no tendrá el efecto deseado</span>
</pre><p>
      parecen iguales, y sus efectos serán los mismos. Se llamará al destructor del objeto
      <code class="classname">MyType</code> al que apunta el puntero dado y después se liberará el
      bloque asignado. Esto es correcto para <code class="varname">fp2</code>, pero no lo es para
      <code class="varname">fp</code>, significa que los destructores de los 99 elementos restantes
      del vector no se invocarán. Sin embargo, sí se liberará toda la memoria asignada al
      vector, ya que fue obtenida como un único gran bloque cuyo tamaño quedó anotado en
      alguna parte por las rutinas de asignación.
    </p><p>
      Esto se soluciona indicando al compilador que el puntero que pasamos es la dirección
      de inicio de un vector, usando la siguiente sintaxis:
    </p><pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[]</span> fp<span class="hl opt">;</span>
</pre><p>
      Los corchetes indican al compilador la necesidad de generar el código para obtener
      el número de objetos en el vector, que fue guardado en alguna parte cuando se creó,
      y llamar al destructor para cada uno de dichos elementos. Esta es una mejora sobre
      la sintaxis primitiva, que puede verse ocasionalmente en el código de viejos
      programas:
    </p><pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">]</span> fp<span class="hl opt">;</span>
</pre><p>
      que forzaba al programador a incluir el número de objetos contenidos en el vector,
      introduciendo con ello una posible fuente de errores. El esfuerzo adicional que
      supone para el compilador tener en esto en cuenta es pequeño, y por eso se consideró
      preferible especificar el número de objetos en un lugar y no en dos.
    </p><div class="sect2" title="13.3.1. Cómo hacer que un puntero sea más parecido a un vector"><div class="titlepage"><div><div><h3 class="title"><a id="idp7684352"></a>13.3.1. Cómo hacer que un puntero sea más parecido a un vector</h3></div></div></div><p>
		Como defecto colateral, existe la posibilidad de modificar el puntero
		<code class="varname">fp</code> anteriormente definido, para que apunte a cualquier otra
		cosa, lo que no es consistente con el hecho de ser la dirección de inicio de un
		vector. Tiene más sentido definirlo como una constante, de modo que cualquier
		intento de modificación sea señalado como un error. Para conseguir este efecto se
		podría probar con:
      </p><pre class="programlisting">
<span class="hl kwb">int const</span><span class="hl opt">*</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre><p>
	o bien:
      </p><pre class="programlisting">
<span class="hl kwb">const int</span><span class="hl opt">*</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre><p>
		pero en ambos casos el especificador <code class="keyword">const</code> quedaría asociado al
		<code class="type">int</code>, es decir, al valor al que apunta, en lugar de al puntero en
		sí. Si se quiere conseguir el efecto deseado, en lugar de las anteriores, se debe
		poner:
      </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre><p>
		Ahora es posible modificar el valor de los elementos del vector, siendo ilegal
		cualquier intento posterior de modificar <code class="varname">q</code>, como
		<code class="literal">q++</code> por ejemplo, al igual que ocurre con el identificador de un
		vector ordinario.
	  </p></div><div class="sect2" title="13.3.2. Cuando se supera el espacio de almacenamiento"><div class="titlepage"><div><div><h3 class="title"><a id="idp7689680"></a>13.3.2. Cuando se supera el espacio de almacenamiento</h3></div></div></div><p>
		¿Qué ocurre cuando <code class="keyword">new()</code> no puede encontrar un bloque contiguo
		suficientemente grande para alojar el objeto? En este caso se produce la llamada a
		una función especial: el manejador de errores de <code class="keyword">new</code> o
		<span class="emphasis"><em>new-handler</em></span>. Para ello comprueba si un determinado puntero a
		función es nulo, si no lo es, se efectúa la llamada a la función a la que apunta.
      </p><p>
		El comportamiento por defecto del manejador de errores de <code class="keyword">new</code> es disparar
		una excepción, asunto del que se tratará en el Volumen 2. Si se piensa usar la
		asignación dinámica, conviene al menos reemplazar el manejador de errores de
		<code class="keyword">new</code> por una función que advierta de la falta de memoria y fuerce la
		terminación del programa. De este modo, durante la depuración del programa, se
		podrá seguir la pista de lo sucedido. Para la versión final del programa, será
		mejor implementar una recuperación de errores más elaborada.
      </p><p>
		La forma de reemplazar el manejador de <span class="emphasis"><em>new-handler</em></span> por defecto
		consiste en incluir el archivo <code class="filename">new.h</code> y hacer una llamada a la
		función <code class="function">set_new_handler()</code> con la dirección de la función que
		se desea instalar:
      </p><div class="example"><a id="idp7695744"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:NewHandler.cpp</span>
<span class="hl slc">// Changing the new-handler</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;new&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">out_of_memory</span><span class="hl opt">() {</span>
  cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;memory exhausted after &quot;</span> <span class="hl opt">&lt;&lt;</span> count 
    <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; allocations!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">set_new_handler</span><span class="hl opt">(</span>out_of_memory<span class="hl opt">);</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) {</span>
    count<span class="hl opt">++;</span>
    <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">1000</span><span class="hl opt">];</span> <span class="hl slc">// Exhausts memory</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.7. C13/NewHandler.cpp</strong></p></div><br class="example-break" /><p>
		La función a instalar debe retornar <code class="type">void</code> y no tomar argumentos. El
		bucle <code class="keyword">while</code> seguirá pidiendo bloques de <code class="type">int</code> hasta consumir
		la memoria libre disponible, sin hacer nada con ellos. Justo a la siguiente
		llamada a <code class="keyword">new</code>, no habrá espacio para asignar y se producirá la llamada al
		<span class="emphasis"><em>manejador de <code class="keyword">new</code></em></span>.
      </p><p>
		Este comportamiento del <span class="emphasis"><em>new-handler</em></span> está asociado al
		<code class="function">operator new()</code>, de modo que si se sobrecarga
		<code class="function">operator new()</code> (asunto que se trata en la siguiente sección),
		no se producirá la llamada al <span class="emphasis"><em>manejador de <code class="keyword">new</code></em></span>. Si
		se desea que se produzca dicha llamada será necesario que lo haga en el
		<code class="function">operator new()</code> que substituya al original.
      </p><p>
		Por supuesto, es posible escribir manejadores <code class="keyword">new</code> más sofisticados,
		incluso alguno que intente reclamar los bloques asignados que no se usan
		(conocidos habitualmente como <span class="emphasis"><em>recolectores de basura</em></span>). Pero
		este no es un trabajo adecuado para programadores noveles.
      </p></div><div class="sect2" title="13.3.3. Sobrecarga de los operadores new y delete"><div class="titlepage"><div><div><h3 class="title"><a id="idp7703600"></a>13.3.3. Sobrecarga de los operadores <code class="keyword">new</code> y <code class="keyword">delete</code></h3></div></div></div><p>
		Cuando se ejecuta una <span class="emphasis"><em>expresión con <code class="keyword">new</code></em></span>, ocurren dos
		cosas. Primero se asigna la memoria al ejecutar el código del <code class="function">operator
		new()</code> y después se realiza la llamada al constructor. En el caso de una
		<span class="emphasis"><em>expresión con <code class="keyword">delete</code></em></span>, se llama primero al destructor
		y después se libera la memoria con el operador <code class="function">operator
		delete()</code>. Las llamadas al constructor y destructor no están bajo el
		control del programador, pero se <span class="emphasis"><em>pueden</em></span> cambiar las funciones
		<code class="function">opertator new()</code> y <code class="function">operatator delete()</code>.
      </p><p>
		El sistema de asignación de memoria usado por <code class="keyword">new</code> y <code class="keyword">delete</code> es un
		sistema de propósito general. En situaciones especiales, puede que no funcione
		como se requiere. Frecuentemente la razón para cambiar el asignador es la
		eficiencia; puede que se necesite crear y destruir tantos objetos de la misma
		clase que lo haga ineficaz en términos de velocidad: un cuello de botella. En C++
		es posible sobrecargar <code class="keyword">new</code> y <code class="keyword">delete</code> para implementar un esquema
		particular más adecuado que permita manejar situaciones como ésta.
      </p><p>
		Otra cuestión es la fragmentación del montículo. Cuando los objetos tienen tamaños
		diferentes es posible llegar a dividir de tal modo el área de memoria libre que se
		vuelva inútil. Es decir, el espacio puede estar disponible, pero debido al nivel
		de fragmentación alcanzado, no exista ningún bloque del tamaño requerido. Es
		posible asegurarse de que esto no llegue a ocurrir mediante la creación de un
		asignador para una clase específica.
      </p><p>
	  En los sistemas de tiempo real y en los sistemas integrados, suele ser necesario que
	  los programas funcionen por largo tiempo con recursos muy limitados. Tales sistemas
	  pueden incluso requerir que cada asignación tome siempre la misma cantidad de
	  tiempo, y que no esté permitida la fragmentación ni el agotamiento en el área
	  dinámica. La solución a este problema consiste en utilizar un asignador
	  «personalizado»; de otro modo, los programadores evitarían usar
	  <code class="keyword">new</code> y <code class="keyword">delete</code> es estos casos y desperdiciarían un recurso muy
	  valioso de C++.
	</p><p>
		A la hora de sobrecargar <code class="function">operator new()</code> y <code class="function">operator
		delete()</code> es importante tener en cuenta que lo único que se está
		cambiando es la forma en que se realiza la asignación del espacio. El compilador
		llamará a la nueva versión de <code class="keyword">new</code> en lugar de al original, para asignar
		espacio, llamando después al constructor que actuará sobre él. Así que, aunque el
		compilador convierte una expresión <code class="keyword">new</code> en código para asignar el espacio
		y para llamar al constructor, todo lo que se puede cambiar al sobrecargar
		<code class="keyword">new</code> es la parte correspondiente a la asignación. <code class="keyword">delete</code> tiene
		una limitación similar.
      </p><p>
		Cuando se sobrecarga <code class="function">operator new()</code>, se está reemplazando
		también el modo de tratar los posibles fallos en la asignación de la memoria. Se
		debe decidir qué acciones va a realizar en tal caso: devolver cero, un bucle de
		reintento con llamada al <span class="foreignphrase"><em class="foreignphrase">new-handler</em></span>, o lo que es
		más frecuente, disparar una excepción <span class="emphasis"><em>bad_alloc</em></span> (tema que se
		trata en el Volumen 2).
      </p><p>
		La sobrecarga de <code class="keyword">new</code> y <code class="keyword">delete</code> es como la de cualquier otro
		operador. Existe la posibilidad de elegir entre sobrecarga global y sobrecarga
		para una clase determinada.
      </p><div class="sect3" title="Sobrecarga global de new y delete"><div class="titlepage"><div><div><h4 class="title"><a id="idp7722000"></a>Sobrecarga global de <code class="keyword">new</code> y <code class="keyword">delete</code></h4></div></div></div><p>
		Este es el modo más drástico de abordar el asunto, resulta útil cuando el
		comportamiento de <code class="keyword">new</code> y <code class="keyword">delete</code> no es satisfactorio para la mayor
		parte del sistema.  Al sobrecargar la versión global, quedan inaccesibles las
		originales, y ya no es posible llamarlas desde dentro de las funciones
		sobrecargadas.
	  </p><p>
		El <code class="keyword">new</code> sobrecargado debe tomar un argumento del tipo <code class="type">size_t</code>
		(el estándar de C) para tamaños. Este argumento es generado y pasado por el
		compilador, y se refiere al tamaño del objeto para el que ahora tenemos la
		responsabilidad de la asignación de memoria. Debe devolver un puntero a un bloque
		de ese tamaño, (o mayor, si hubiera motivos para hacerlo así), o cero en el caso
		de no se encontrara un bloque adecuado. Si eso sucede, no se producirá la llamada
		al constructor. Por supuesto, hay que hacer algo más informativo que sólo devolver
		cero, por ejemplo llamar al «new-handler» o disparar una excepción,
		para indicar que hubo un problema.
	  </p><p>
		El valor de retorno de <code class="function">operator new()</code> es <code class="type">void*</code>,
		no un puntero a un tipo particular. Lo que hace es obtener un bloque de memoria,
		no un objeto definido, no hasta que que sea llamado el constructor, un acto que el
		compilador garantiza y que está fuera del control de este operador.
	  </p><p>
		El operador <code class="function">operator delete()</code> toma como argumento un puntero
		<code class="type">void*</code> a un bloque obtenido con el <code class="function">operator
		new()</code>. Es un <code class="type">void*</code> ya que el <code class="keyword">delete</code> obtiene el
		puntero sólo <span class="emphasis"><em>después</em></span> de que haya sido llamado el destructor,
		lo que efectivamente elimina su caracter de objeto convirtiéndolo en un simple
		bloque de memoria. El tipo de retorno para <code class="keyword">delete</code> es <code class="type">void</code>.
	  </p><p>
		A continuación se expone un ejemplo del modo de sobrecargar globalmente
		<code class="keyword">new</code> y <code class="keyword">delete</code>:
	  </p><div class="example"><a id="idp7732808"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:GlobalOperatorNew.cpp</span>
<span class="hl slc">// Overload global new/delete</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> sz<span class="hl opt">) {</span>
  <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;operator new: %d Bytes</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> sz<span class="hl opt">);</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> m <span class="hl opt">=</span> <span class="hl kwd">malloc</span><span class="hl opt">(</span>sz<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>m<span class="hl opt">)</span> <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;out of memory&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> m<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> m<span class="hl opt">) {</span>
  <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;operator delete&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">free</span><span class="hl opt">(</span>m<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> S <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">S</span><span class="hl opt">() {</span> <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;S::S()&quot;</span><span class="hl opt">); }</span>
  <span class="hl opt">~</span><span class="hl kwd">S</span><span class="hl opt">() {</span> <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;S::~S()&quot;</span><span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;creating &amp; destroying an int&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl kwa">delete</span> p<span class="hl opt">;</span>
  <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;creating &amp; destroying an s&quot;</span><span class="hl opt">);</span>
  S<span class="hl opt">*</span> s <span class="hl opt">=</span> <span class="hl kwa">new</span> S<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> s<span class="hl opt">;</span>
  <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl str">&quot;creating &amp; destroying S[3]&quot;</span><span class="hl opt">);</span>
  S<span class="hl opt">*</span> sa <span class="hl opt">=</span> <span class="hl kwa">new</span> S<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">];</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>sa<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.8. C13/GlobalOperatorNew.cpp</strong></p></div><br class="example-break" /><p>
	  Aquí puede verse la forma general de sobrecarga de operadores <code class="keyword">new</code> y
	  <code class="keyword">delete</code>.  Estos operadores sustitutivos usan las funciones
	  <code class="function">malloc()</code> y <code class="function">free()</code> de la biblioteca
	  estándar de C, que es probablemente lo que ocurre en los operadores
	  originales. Imprimen también mensajes sobre lo que están haciendo. Nótese que no se
	  han usado <code class="literal">iostreams</code> sino <code class="function">printf()</code> y
	  <code class="function">puts()</code>. Esto se hace debido a que los objetos
	  <code class="type">iostream</code> como los globales <code class="varname">cin</code>,
	  <code class="varname">cout</code> y <code class="varname">cerr</code> llaman a <code class="keyword">new</code> para obtener
	  memoria <sup>[<a id="idp7739624" href="#ftn.idp7739624" class="footnote">73</a>]</sup>. Usar
	  <code class="function">printf()</code> evita el fatal bloqueo, ya que no hace llamadas a
	  <code class="keyword">new</code>.
	</p><p>
		En <code class="function">main()</code>, se crean algunos objetos de tipos básicos para
		demostrar que también en estos casos se llama a los operadores <code class="keyword">new</code> y
		<code class="keyword">delete</code> sobrecargados. Posteriormente, se crean un objeto simple y un
		vector, ambos de tipo <code class="classname">S</code>. En el caso del vector se puede
		ver, por el número de bytes pedidos, que se solicita algo de memoria extra para
		incluir información sobre el número de objetos que tendrá. En todos los casos se
		efectúa la llamada a las versiones globales sobrecargadas de <code class="keyword">new</code> y
		<code class="keyword">delete</code>.
	  </p></div><div class="sect3" title="Sobrecarga de new y delete específica para una clase"><div class="titlepage"><div><div><h4 class="title"><a id="idp7745128"></a>
		Sobrecarga de <code class="keyword">new</code> y <code class="keyword">delete</code> específica para una clase
	  </h4></div></div></div><p>
		Aunque no es necesario poner el modificador <code class="keyword">static</code>, cuando se sobrecarga
		<code class="keyword">new</code> y <code class="keyword">delete</code> para una clase se están creando métodos estáticos
		(métodos de clase). La sintaxis es la misma que para cualquier otro
		operador. Cuando el compilador encuentra una expresión <code class="keyword">new</code> para crear un
		objeto de una clase, elige, si existe, un método de la clase llamado
		<code class="function">operator new()</code> en lugar del <code class="keyword">new</code> global. Para el
		resto de tipos o clases se usan los operadores globales (a menos que tengan
		definidos los suyos propios).
	  </p><p>
		En el siguiente ejemplo se usa un primitivo sistema de asignación de
		almacenamiento para la clase <code class="classname">Framis</code>. Se reserva un bloque
		de memoria en el área de datos estática FIXME , y se usa esa memoria para asignar
		alojamiento para los objetos de tipo <code class="classname">Framis</code>. Para
		determinar qué bloques se han asignado, se usa un sencillo vector de bytes, un
		byte por bloque.
	  </p><div class="example"><a id="idp7751576"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:Framis.cpp</span>
<span class="hl slc">// Local overloaded new &amp; delete</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span> <span class="hl slc">// Size_t</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;new&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;Framis.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwc">class</span> Framis <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> sz <span class="hl opt">=</span> <span class="hl num">10</span> <span class="hl opt">};</span>
  <span class="hl kwb">char</span> c<span class="hl opt">[</span>sz<span class="hl opt">];</span> <span class="hl slc">// To take up space, not used</span>
  <span class="hl kwb">static unsigned char</span> pool<span class="hl opt">[];</span>
  <span class="hl kwb">static bool</span> alloc_map<span class="hl opt">[];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> psize <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>  <span class="hl slc">// frami allowed</span>
  <span class="hl kwd">Framis</span><span class="hl opt">() {</span> out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Framis()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Framis</span><span class="hl opt">() {</span> out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Framis() ... &quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span><span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>bad_alloc<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*);</span>
<span class="hl opt">};</span>
<span class="hl kwb">unsigned char</span> Framis<span class="hl opt">::</span>pool<span class="hl opt">[</span>psize <span class="hl opt">*</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Framis<span class="hl opt">)];</span>
<span class="hl kwb">bool</span> Framis<span class="hl opt">::</span>alloc_map<span class="hl opt">[</span>psize<span class="hl opt">] = {</span><span class="hl kwa">false</span><span class="hl opt">};</span>

<span class="hl slc">// Size is ignored -- assume a Framis object</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> 
Framis<span class="hl opt">::</span><span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span><span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>bad_alloc<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> psize<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>alloc_map<span class="hl opt">[</span>i<span class="hl opt">]) {</span>
      out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;using block &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; ... &quot;</span><span class="hl opt">;</span>
      alloc_map<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwa">true</span><span class="hl opt">;</span> <span class="hl slc">// Mark it used</span>
      <span class="hl kwa">return</span> pool <span class="hl opt">+ (</span>i <span class="hl opt">*</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Framis<span class="hl opt">));</span>
    <span class="hl opt">}</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;out of memory&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">throw</span> <span class="hl kwd">bad_alloc</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Framis<span class="hl opt">::</span><span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> m<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>m<span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span> <span class="hl slc">// Check for null pointer</span>
  <span class="hl slc">// Assume it was created in the pool</span>
  <span class="hl slc">// Calculate which block number it is:</span>
  <span class="hl kwb">unsigned long</span> block <span class="hl opt">= (</span><span class="hl kwb">unsigned long</span><span class="hl opt">)</span>m
    <span class="hl opt">- (</span><span class="hl kwb">unsigned long</span><span class="hl opt">)</span>pool<span class="hl opt">;</span>
  block <span class="hl opt">/=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Framis<span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;freeing block &quot;</span> <span class="hl opt">&lt;&lt;</span> block <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Mark it free:</span>
  alloc_map<span class="hl opt">[</span>block<span class="hl opt">] =</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Framis<span class="hl opt">*</span> f<span class="hl opt">[</span>Framis<span class="hl opt">::</span>psize<span class="hl opt">];</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> Framis<span class="hl opt">::</span>psize<span class="hl opt">;</span> i<span class="hl opt">++)</span>
      f<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwa">new</span> Framis<span class="hl opt">;</span>
    <span class="hl kwa">new</span> Framis<span class="hl opt">;</span> <span class="hl slc">// Out of memory</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>bad_alloc<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Out of memory!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">delete</span> f<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  f<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Use released memory:</span>
  Framis<span class="hl opt">*</span> x <span class="hl opt">=</span> <span class="hl kwa">new</span> Framis<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> x<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> Framis<span class="hl opt">::</span>psize<span class="hl opt">;</span> j<span class="hl opt">++)</span>
    <span class="hl kwa">delete</span> f<span class="hl opt">[</span>j<span class="hl opt">];</span> <span class="hl slc">// Delete f[10] OK</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.9. C13/Framis.cpp</strong></p></div><br class="example-break" /><p>
		El espacio de almacenamiento para el montículo <code class="classname">Framis</code> se
		crea sobre el bloque obtenido al declarar un vector de tamaño suficiente para
		contener <code class="varname">psize</code> objetos de clase
		<code class="classname">Framis</code>. Se ha declarado también una variable lógica para
		cada uno de los <code class="varname">psize</code> bloques en el vector. Todas estas
		variables lógicas son inicializadas a <code class="constant">false</code> usando el truco
		consistente en inicializar el primer elemento para que el compilador lo haga
		automáticamente con los restantes iniciándolos a su valor por defecto,
		<code class="constant">false</code>, en el caso de variables lógicas.
	</p><p>
		El <code class="function">operador new()</code> local usa la misma sintaxis que el
		global. Lo único que hace es buscar una posición libre, es decir, un valor
		<code class="constant">false</code> en el mapa de localización
		<code class="varname">alloc_map</code>. Si la encuentra, cambia su valor a
		<code class="constant">true</code> para marcarla como ocupada, y devuelve la dirección del
		bloque correspondiente. En caso de no encontrar ningún bloque libre, envía un
		mensaje al fichero de trazas y dispara una excepción de tipo
		<code class="type">bad_alloc</code>.
	</p><p>
		Este es el primer ejemplo con excepción que aparece en este libro.  En
		el Volumen 2 se verá una discusión detallada del tratamiento de
		excepciones, por lo que en este ejemplo se hace un uso muy simple del
		mismo. En el <code class="function">operador new</code> hay dos expresiones
		relacionadas con el tratamiento de excepciones. Primero, a la lista de
		argumentos de función le sigue la expresión
		<code class="code">throw(bad_alloc)</code>, esto informa al compilador que la
		función puede disparar una excepción del tipo indicado. En segundo
		lugar, si efectivamente se agota la memoria, la función alcanzará la
		sentencia <code class="code">throw bad_alloc()</code> lanzando la excepción. En el
		caso de que esto ocurra, la función deja de ejecutarse y se cede el
		control del programa a la rutina de tratamiento de excepción que se ha
		definido en una cláusula <code class="code">catch(bad_alloc)</code>.
     </p><p>
		  En <code class="function">main()</code> se puede ver la cláusula
		  <span class="emphasis"><em>try-catch</em></span> que es la otra parte del mecanismo. El
		  código que puede lanzar la excepción queda dentro del bloque
		  <code class="keyword">try</code>; en este caso, llamadas a <code class="keyword">new</code> para objetos
		  <code class="classname">Framis</code>. Justo a continuación de dicho bloque
		  sigue una o varias cláusulas <code class="keyword">catch</code>, especificando en cada una
		  la excepción a la que se destina. En este caso,
		  <code class="code">catch(bad_alloc)</code> indica que en ese bloque se
		  tratarán las excepciones de tipo <code class="type">bad_alloc</code>.  El código de
		  este bloque sólo se ejecutará si se dispara la excepción, continuando
		  la ejecución del programa justo después de la última del grupo de
		  cláusulas <code class="keyword">catch</code> que existan. Aquí sólo hay una, pero podría
		  haber más.
		</p><p>
		  En este ejemplo, el uso de <code class="literal">iostream</code> es correcto ya
		  que el <code class="function">operator new()</code> global no ha sido modificado.
		</p><p>
		  El <code class="function">operator delete()</code> asume que la dirección de
		  <code class="classname">Framis</code> ha sido obtenida de nuestro almacén
		  particular. Una asunción justa, ya que cada vez que se crea un objeto
		  <code class="classname">Framis</code> simple se llama al <code class="function">operator
		  new()</code> local; pero cuando se crea un vector de tales objetos
		  se llama al <code class="keyword">new</code> global. Esto causaría problemas si el usuario
		  llamara accidentalmente al operador <code class="keyword">delete</code> sin usar la
		  sintaxis para destrucción de vectores. Podría ser que incluso
		  estuviera tratando de borrar un puntero a un objeto de la pila. Si
		  cree que estas cosas puedan suceder, conviene pensar en añadir una
		  línea que asegurare que la dirección está en el intervalo correcto
		  (aquí se demuestra el potencial que tiene la sobrecarga de los
		  operadores <code class="keyword">new</code> y <code class="keyword">delete</code> para la localización de
		  fugas de memoria).
		</p><p>
		  <code class="function">operador delete()</code> calcula el bloque al que el
		  puntero representa y después pone a <code class="constant">false</code> la
		  bandera correspondiente en el mapa de localización, para indicar que
		  dicho bloque está libre.
		</p><p>
		  En la función <code class="function">main()</code>, se crean dinámicamente
		  suficientes objetos <code class="classname">Framis</code> para agotar la
		  memoria. Con esto se prueba el comportamiento del programa en este
		  caso. A continuación, se libera uno de los objetos y se crea otro para
		  mostrar la reutilización del bloque recién liberado.
		</p><p>
		  Este esquema específico de asignación de memoria es probablemente
		  mucho más rápido que el esquema de propósito general que usan los
		  operadores <code class="keyword">new</code> y <code class="keyword">delete</code> originales. Se debe
		  advertir, no obstante, que este enfoque no es automáticamente
		  utilizable cuando se usa herencia, un tema que verá en el Capítulo 14 (FIXME).
		</p></div><div class="sect3" title="Sobrecarga de new y delete para vectores"><div class="titlepage"><div><div><h4 class="title"><a id="idp7777272"></a>Sobrecarga de <code class="keyword">new</code> y <code class="keyword">delete</code> para vectores</h4></div></div></div><p>
	  Si se sobrecargan los operadores <code class="keyword">new</code> y
	  <code class="keyword">delete</code> para una clase, esos operadores se
	  llaman cada vez que se crea un objeto simple de esa clase. Sin
	  embargo, al crear un vector de tales objetos se llama al
	  <code class="function">operator new()</code> global para obtener el
	  espacio necesario para el vector, y al <code class="function">operator
	  delete()</code> global para liberarlo. Es posible
	  controlar también la asignación de memoria para vectores
	  sobrecargando los métodos <code class="function">operator new[]</code>
	  y <code class="function">operator delete[]</code>; se trata de
	  versiones especiales para vectores. A continuación se expone
	  un ejemplo que muestra el uso de ambas versiones.
	</p><div class="example"><a id="idp7782024"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:ArrayOperatorNew.cpp</span>
<span class="hl slc">// Operator new for arrays</span>
<span class="hl ppc">#include &lt;new&gt;</span> <span class="hl slc">// Size_t definition</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">trace</span><span class="hl opt">(</span><span class="hl str">&quot;ArrayOperatorNew.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwc">class</span> Widget <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> sz <span class="hl opt">=</span> <span class="hl num">10</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span>sz<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Widget</span><span class="hl opt">() {</span> trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;*&quot;</span><span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Widget</span><span class="hl opt">() {</span> trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> sz<span class="hl opt">) {</span>
    trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::new: &quot;</span>
         <span class="hl opt">&lt;&lt;</span> sz <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; bytes&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">::</span><span class="hl kwa">new</span> <span class="hl kwb">char</span><span class="hl opt">[</span>sz<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
    trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::delete&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">::</span><span class="hl kwa">delete</span> <span class="hl opt">[]</span>p<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> sz<span class="hl opt">) {</span>
    trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::new[]: &quot;</span>
         <span class="hl opt">&lt;&lt;</span> sz <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; bytes&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">::</span><span class="hl kwa">new</span> <span class="hl kwb">char</span><span class="hl opt">[</span>sz<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">[](</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
    trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Widget::delete[]&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">::</span><span class="hl kwa">delete</span> <span class="hl opt">[]</span>p<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;new Widget&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Widget<span class="hl opt">*</span> w <span class="hl opt">=</span> <span class="hl kwa">new</span> Widget<span class="hl opt">;</span>
  trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">delete Widget&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> w<span class="hl opt">;</span>
  trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">new Widget[25]&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Widget<span class="hl opt">*</span> wa <span class="hl opt">=</span> <span class="hl kwa">new</span> Widget<span class="hl opt">[</span><span class="hl num">25</span><span class="hl opt">];</span>
  trace <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">delete []Widget&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>wa<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.10. C13/ArrayOperatorNew.cpp</strong></p></div><br class="example-break" /><p>
	  Si exceptuamos la información de rastreo que se añade aquí,
	  las llamadas a las versiones globales de
	  <code class="keyword">new</code> y <code class="keyword">delete</code> causan el
	  mismo efecto que si estos operadores no se hubieran
	  sobrecargado. Como se ha visto anteriormente, es posible usar
	  cualquier esquema conveniente de asignación de memoria en
	  estos operadores modificados.
	</p><p>
	  Se puede observar que la sintaxis de <code class="keyword">new</code> y
	  <code class="keyword">delete</code> para vectores es la misma que la
	  usada para objetos simples añadiéndoles el operador subíndice
	  <code class="literal">[]</code>. En ambos casos se le pasa a
	  <code class="keyword">new</code> como argumento el tamaño del bloque de
	  memoria solicitado. A la versión para vectores se le pasa el
	  tamaño necesario para albergar todos sus componentes. Conviene
	  tener en cuenta que lo único que se requiere del
	  <code class="function">operator new()</code> es que devuelva un puntero
	  a un bloque de memoria suficientemente grande. Aunque es
	  posible inicializar el bloque referido, eso es trabajo del
	  constructor, que se llamará automáticamente por el compilador.
	</p><p>
	  El constructor y el destructor simplemente imprimen
	  mensajes para que pueda verse que han sido llamados. A
	  continuación se muestran dichos mensajes:
	</p><pre class="screen">
	    new Widget
	    Widget::new: 40 bytes
	    *
	    delete Widget
	    ~Widget::delete
	    new Widget[25]
	    Widget::new: 1004 bytes
	    *************************
	    delete []Widget
	    ~~~~~~~~~~~~~~~~~~~~~~~~~Widget::delete[]
	</pre><p>
	  La creación de un único objeto <code class="classname">Widget</code>
	  requiere 40 bytes, tal y como se podría esperar para una
	  máquina que usa 32 bits para un <code class="type">int</code>. Se invoca al
	  <code class="function">operator new()</code> y luego al constructor,
	  que se indica con la impresión del carácter
	  «*». De forma complementaria, la llamada a
	  <code class="keyword">delete</code> provoca primero la invocación del
	  destructor y sólo después, la de <code class="literal">operator
	  delete()</code>.
	</p><p>
	  Cuando lo que se crea es un vector de objetos
	  <code class="classname">Widget</code>, se observa el uso de la versión
	  de <code class="function">operator new()</code> para vectores, de acuerdo
	  con lo dicho anteriormente. Se observa que el tamaño del
	  bloque solicitado en este caso es cuatro bytes mayor que el
	  esperado. Es en estos cuatro bytes extra donde el compilador
	  guarda la información sobre el tamaño del vector. De ese
	  modo, la expresión
	</p><pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[]</span>Widget<span class="hl opt">;</span>
</pre><p>
	  informa al compilador que se trata de un vector, con lo cual,
	  generará el código para extraer la información que indica el
	  número de objetos y para llamar otras tantas veces al
	  destructor. Obsérvese que aunque se llame solo una vez a
	  <code class="function">operator new()</code> y <code class="function">operator
	  delete()</code> para el vector, se llama al constructor y
	  al destructor una vez para cada uno de los objetos del vector.
	</p></div><div class="sect3" title="Llamadas al constructor"><div class="titlepage"><div><div><h4 class="title"><a id="idp7796768"></a>Llamadas al constructor</h4></div></div></div><p>
	  Considerando que
	</p><pre class="programlisting">
MyType<span class="hl opt">*</span> f <span class="hl opt">=</span> <span class="hl kwa">new</span> MyType<span class="hl opt">;</span>
</pre><p>
	  llama a <code class="keyword">new</code> para obtener un bloque del
	  tamaño de <code class="classname">MyType</code> invocando después a su
	  constructor, ¿qué pasaría si la asignación de memoria falla en
	  <code class="keyword">new</code>?. En tal caso, no habrá llamada al
	  constructor al que se le tendría que pasar un puntero
	  <code class="varname">this</code> nulo, para un objeto que no se ha
	  creado . He aquí un ejemplo que lo
	  demuestra:
	</p><div class="example"><a id="idp7799992"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:NoMemory.cpp</span>
<span class="hl slc">// Constructor isn't called if new fails</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;new&gt;</span> <span class="hl slc">// bad_alloc definition</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> NoMemory <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">NoMemory</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;NoMemory::NoMemory()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> sz<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>bad_alloc<span class="hl opt">){</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;NoMemory::operator new&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">bad_alloc</span><span class="hl opt">();</span> <span class="hl slc">// &quot;Out of memory&quot;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  NoMemory<span class="hl opt">*</span> nm <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    nm <span class="hl opt">=</span> <span class="hl kwa">new</span> NoMemory<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>bad_alloc<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Out of memory exception&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;nm = &quot;</span> <span class="hl opt">&lt;&lt;</span> nm <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.11. C13/NoMemory.cpp</strong></p></div><br class="example-break" /><p>
	  Cuando se ejecuta, el programa imprime los mensajes del
	  <code class="function">operator new()</code> y del manejador de
	  excepción, pero no el del constructor. Como
	  <code class="keyword">new</code> nunca retorna, no se llama al
	  constructor y por tanto no se imprime su mensaje.
	</p><p>
	  Para asegurar que no se usa indebidamente, Es importante
	  inicializar <code class="varname">nm</code> a cero, debido a que
	  <code class="keyword">new</code> no se completa. El código de manejo de
	  excepciones debe hacer algo más que imprimir un mensaje y
	  continuar como si el objeto hubiera sido creado con
	  éxito. Idealmente, debería hacer algo que permitiera al
	  programa recuperarse del fallo, o al menos, provocar la salida
	  después de registrar un error.
	</p><p>
	  En las primeras versiones de C++, el comportamiento estándar
	  consistía en hacer que <code class="keyword">new</code> retornara un
	  puntero nulo si la asignación de memoria fallaba. Esto podía
	  impedir que se llamara al constructor. Si se intenta hacer
	  esto con un compilador que sea conforme al estándar actual, le
	  informará de que en lugar de devolver un valor nulo, debe
	  disparar una excepción de tipo <code class="type">bad_alloc</code>.
	</p></div><div class="sect3" title="Operadores new y delete de [FIXME emplazamiento (situación)]"><div class="titlepage"><div><div><h4 class="title"><a id="idp7806648"></a>
	    Operadores <code class="keyword">new</code> y
	    <code class="keyword">delete</code> de [FIXME emplazamiento (situación)]
	  </h4></div></div></div><p>
	  He aquí otros dos usos, menos comunes, para la sobrecarga de
	    <code class="function">operador new()</code>:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		Puede ocurrir que necesite emplazar un objeto en un
		lugar específico de la memoria.  Esto puede ser
		importante en programas en los que algunos de los
		objetos se refieren o son sinónimos de componentes
		hardware mapeados sobre una zona de la memoria.
	      </p></li><li class="listitem"><p>
		Si se quiere permitir la elección entre varios
		asignadores de memoria (allocators) en la llamada a
		<code class="keyword">new</code>.
	      </p></li></ol></div><p>
	  Ambas situaciones se resuelven mediante el mismo mecanismo: la
	  función <code class="function">operator new()</code> puede tomar más de
	  un argumento. Como se ha visto, el primer argumento de
	  <code class="keyword">new</code> es siempre el tamaño del objeto,
	  calculado en secreto y pasado por el compilador. El resto de
	  argumentos puede ser de cualquier otro tipo que se necesite:
	  la dirección en la que queremos emplazar el objeto, una
	  referencia a una función de asignación de memoria, o
	  cualquiera otra cosa que se considere conveniente.
	</p><p>
	  Al principio puede parecer curioso el modo en que se pasan los
	  argumentos extra al <code class="function">operator
	  new()</code>. Después de la palabra clave
	  <code class="keyword">new</code> y antes del nombre de clase del objeto
	  que se pretende crear, se pone la lista de argumentos, sin
	  contar con el correspondiente al <code class="literal">size_t</code> del
	  objeto, que le pasa el compilador.  Por ejemplo, la expresión:
	</p><pre class="programlisting">
X<span class="hl opt">*</span> xp <span class="hl opt">=</span> <span class="hl kwa">new</span><span class="hl opt">(</span>a<span class="hl opt">)</span> X<span class="hl opt">;</span>
</pre><p>
	  pasará <code class="varname">a</code> como segundo argumento al operador
	  <code class="function">operator new()</code>. Por supuesto, sólo
	  funcionará si ha sido declarado el <code class="function">operator
	  new()</code> adecuado.
	</p><p>
	  He aquí un ejemplo demostrativo de cómo se usa esto para
	  colocar un objeto en una posición particular:
	</p><div class="example"><a id="idp7817320"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C13:PlacementOperatorNew.cpp</span>
<span class="hl slc">// Placement with operator new()</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span> <span class="hl slc">// Size_t</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;this = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">X</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;X::~X(): &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span><span class="hl opt">,</span> <span class="hl kwb">void</span><span class="hl opt">*</span> loc<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> loc<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> l<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;l = &quot;</span> <span class="hl opt">&lt;&lt;</span> l <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  X<span class="hl opt">*</span> xp <span class="hl opt">=</span> <span class="hl kwa">new</span><span class="hl opt">(</span>l<span class="hl opt">)</span> <span class="hl kwd">X</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span> <span class="hl slc">// X at location l</span>
  xp<span class="hl opt">-&gt;</span>X<span class="hl opt">::~</span><span class="hl kwd">X</span><span class="hl opt">();</span> <span class="hl slc">// Explicit destructor call</span>
  <span class="hl slc">// ONLY use with placement!</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 13.12. C13/PlacementOperatorNew.cpp</strong></p></div><br class="example-break" /><p>
	  Observe que lo único que hace el operador
	  <code class="keyword">new</code> es retornar el puntero que se
	  pasa. Por tanto, es posible especificar la dirección en la
	  que se quiere construir el objeto.
	</p><p>
	  Aunque este ejemplo muestra sólo un argumento adicional, nada
	  impide añadir otros, si se considera conveniente para sus
	  propósitos.
	</p><p>
		  Al tratar de destruir estos objetos surge un problema.  Sólo hay una
		  versión del operador <code class="keyword">delete</code>, de modo que no hay forma de
		  decir:  "Usa mi función de liberación de memoria para este objeto".
		  Se requiere llamar al destructor, pero sin utilizar el mecanismo de
		  memoria dinámica, ya que el objeto no está alojado en el montículo.
		</p><p>
		  La solución tiene una sintaxis muy especial. Se debe llamar
		  explícitamente al destructor, tal como se muestra:
		</p><pre class="programlisting">
xp<span class="hl opt">-&gt;</span>X<span class="hl opt">::~</span><span class="hl kwd">X</span><span class="hl opt">();</span>  <span class="hl slc">//Llamada explícita al destructor</span>
</pre><p>
	  Hay que hacer una llamada de atención al respecto. Algunas
	  personas ven esto como un modo de destruir objetos en algún
	  momento anterior al determinado por las reglas de ámbito, en
	  lugar de ajustar el ámbito, o más correctamente, en lugar de
	  usar asignación dinámica como medio de determinar la duración
	  del objeto en tiempo de ejecución. Esto es un error, que puede
	  provocar problemas si se trata de destruir de esta manera un
	  objeto ordinario creado en la pila, ya que el destructor será
	  llamado de nuevo cuando se produzca la salida del ámbito
	  correspondiente. Si se llama de esta forma directa al
	  destructor de un objeto creado dinámicamente, se llevará a
	  cabo la destrucción, pero no la liberación del bloque de
	  memoria, lo que probablemente no es lo que se desea. La única
	  razón para este tipo de llamada explícita al destructor es
	  permitir este uso especial del operador
	  <code class="keyword">new</code>, para emplazamiento en memoria.
	</p><p>
	  Existe también una forma de operador <code class="keyword">delete</code>
	  de emplazamiento que sólo es llamada en caso de que el
	  constructor dispare una excepción, con lo que la memoria se
	  libera automáticamente durante la excepción. El operador
	  <code class="keyword">delete</code> de emplazamiento usa una lista de
	  argumentos que se corresponde con la del operador
	  <code class="keyword">new</code> de emplazamiento que fue llamado
	  previamente a que el constructor lanzase la excepción. Este
	  asunto se tratará en el Volumen 2, en un capítulo dedicado al
	  tratamiento de excepciones.
	</p></div></div></div><div class="sect1" title="13.4. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7828752"></a>13.4. Resumen</h2></div></div></div><p>
      La creación de objetos en la pila es eficaz y conveniente,
      pero para resolver el problema general de programación es
      necesario poder crear y destruir objetos en cualquier momento
      en tiempo de ejecución, en particular, para que pueda
      responder a la información externa al programa. Aunque C
      ofrece funciones de asignación dinámica, éstas no proporcionan
      la facilidad de uso ni la construcción garantizada de objetos
      que se necesita en C++. Al llevar al núcleo mismo del lenguaje
      gracias al uso de los operadores <code class="keyword">new</code> y
      <code class="keyword">delete</code>, la creación dinámica de objetos se
      hace tan fácil como la creación de objetos en la pila,
      añadiendo además una gran flexibilidad. Se puede modificar el
      comportamiento de <code class="keyword">new</code> y
      <code class="keyword">delete</code> si no se ajusta a los
      requerimientos, particularmente para mejorar la eficiencia, y
      también es posible definir su comportamiento en caso de
      agotarse la memoria libre.
    </p></div><div class="sect1" title="13.5. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7832696"></a>13.5. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Crear una clase <code class="classname">Counted</code> que contenga un
	  <code class="literal">int id</code> y un <code class="literal">static int
	  count</code>. El constructor por defecto debe empezar con
	  <code class="literal">Counted():id(count++){</code>. También deberá
	  mostrar mensajes con su <code class="varname">id</code>, además de
	  alguno que muestre que se está creando. El destructor debe
	  mostrar que está siendo destruido y su
	  <code class="varname">id</code>. Probar su funcionamiento.
	</p></li><li class="listitem"><p>
	  Compruebe que <code class="keyword">new</code> y
	  <code class="keyword">delete</code> llaman siempre a constructores y
	  destructores, creando mediante el uso de
	  <code class="keyword">new</code> un objeto de la clase
	  <code class="classname">Counted</code> del ejercicio 1, y
	  destruyéndolo después con <code class="keyword">delete</code>. Cree y
	  destruya un vector de <code class="classname">Counted</code> en el
	  montículo.
	</p></li><li class="listitem"><p>
	  Cree un objeto de la clase <code class="classname">PStash</code>, y
	  llénelo de los objetos del ejercicio 1. Observe lo que sucede
	  cuando el objeto <code class="classname">PStash</code> sale de su
	  ámbito y es llamado su destructor.
	</p></li><li class="listitem"><p>
	  Cree un vector de <code class="classname">Counted*</code> y cárguelo
	  con punteros a objetos <code class="classname">Counted</code>. Recorra
	  el vector llamando imprimiendo cada objeto, repita este paso y
	  elimínelos uno a uno.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 4 añadiendo una función miembro
	  <code class="function">f()</code> de <code class="classname">Counted</code> que
	  muestre un mensaje. Recorra el vector llamando a
	  <code class="function">f()</code> para cada objeto del vector.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 5 usando un objeto
	  <code class="classname">PStash</code>.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 5 usando <code class="filename">Stack4.h</code> del
	  capítulo 9.
	</p></li><li class="listitem"><p>
	  Cree mediante asignación dinámica un vector de objetos de
	  clase <code class="classname">Counted</code>. Llame a
	  <code class="keyword">delete</code> con el puntero resultante como
	  argumento, sin usar el operador subíndice []. Explique el
	  resultado.
	</p></li><li class="listitem"><p>
	  Cree un objeto de clase <code class="classname">Counted</code>
	  mediante <code class="keyword">new</code>, convierta el puntero
	  resultante a <code class="keyword">void*</code> y luego
	  bórrelo. Explique el resultado.
	</p></li><li class="listitem"><p>
	  Compile y ejecute el programa
	  <code class="filename">NewHandler.cpp</code> en su ordenador. A partir
	  del número resultante, calcule la cantidad de memoria libre
	  disponible para su programa.
	</p></li><li class="listitem"><p>
	  Cree una clase y defina en ella operadores de sobrecarga
	  para <code class="keyword">new</code> y <code class="keyword">delete</code>,
	  para objetos simples y para vectores de objetos. Demuestre
	  que ambas versiones funcionan.
	</p></li><li class="listitem"><p>
	  Diseñe un test que le permita evaluar de forma aproximada la
	  mejora en velocidad obtenida en
	  <code class="filename">Framis.cpp</code> con el uso de las versiones
	  adaptadas de <code class="keyword">new</code> y
	  <code class="keyword">delete</code>, respecto de la obtenida con las
	  globales .
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">NoMemory.cpp</code> para que contenga
	  un vector de enteros y realmente obtenga memoria en lugar de
	  disparar <code class="classname">bad_alloc</code>. Establezca un bucle
	  <code class="keyword">while</code> en el cuerpo de
	  <code class="function">main()</code> similar al que existe en
	  <code class="filename">NewHandler.cpp</code> para agotar la
	  memoria. Observe lo que sucede en el caso de que su operador
	  <code class="keyword">new</code> no compruebe el éxito de la asignación
	  de memoria. Añada después esa comprobación a su operador
	  <code class="keyword">new</code> y la llamada a <code class="literal">throw
	  bad_alloc</code>.
	</p></li><li class="listitem"><p>
	  Cree una clase y defina un operador <code class="keyword">new</code> de
	  emplazamiento, con un <code class="type">string</code> como segundo
	  argumento.  Defina un vector de <code class="type">string</code>, en
	  el que se almacenará este segundo argumento a cada llamada a
	  <code class="keyword">new</code>.  El operador <code class="keyword">new</code> de
	  emplazamiento asignará bloques de manera normal.  En
	  <code class="function">main()</code>, haga llamadas a este operador
	  <code class="keyword">new</code> pasándole como argumentos cadenas de
	  caracteres que describan las llamadas. Para ello, puede hacer
	  uso de las macros <code class="constant">__FILE__</code> y
	  <code class="constant">__LINE__</code> del preprocesador.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ArrayOperatorNew.cpp</code> definiendo
	  un vector estático de <code class="type">Widget*</code> que añada la
	  dirección de cada uno de los objetos
	  <code class="classname">Widget</code> asignados con
	  <code class="keyword">new</code>, y la retire cuando sea liberada
	  mediante <code class="keyword">delete</code>. Puede que necesite buscar
	  información sebre vectores en la documentación de la
	  biblioteca estándar de C++, o en el segundo volumen de este
	  libro que está disponible en la web del autor. Cree una
	  segunda clase a la que llamará
	  <code class="classname">MemoryChecker</code>, que contenga un
	  destructor que muestre el número de punteros a
	  <code class="classname">Widget</code> en su vector. Diseñe un programa
	  con una única instancia global de
	  <code class="classname">MemoryChecker</code>, y en
	  <code class="function">main()</code>, cree y destruya dinámicamente
	  varios objetos y vectores de objetos
	  <code class="classname">Widget</code>. Observe que
	  <code class="classname">MemoryCheck</code> revela fugas de memoria.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp7544576" href="#idp7544576" class="para">71</a>] </sup>
	N.T. espacio de almacenamiento libre (<span class="foreignphrase"><em class="foreignphrase">free store</em></span>)
      </p></div><div class="footnote"><p><sup>[<a id="ftn.idp7572328" href="#idp7572328" class="para">72</a>] </sup>Existe una sintaxis especial llamada
		<span class="foreignphrase"><em class="foreignphrase">placement-new</em></span> que permite llamar al constructor
		para un bloque de memoria preasignando. Se verá más adelante, en este mismo
		capítulo.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp7739624" href="#idp7739624" class="para">73</a>] </sup>Provocaría una serie continua de llamadas a <code class="keyword">new</code>
	  hasta agotar la pila y abortaría el programa.</p></div></div></div><div class="chapter" title="14: Herencia y Composición"><div class="titlepage"><div><div><h2 class="title"><a id="C14"></a>14: Herencia y Composición</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp7871472">14.1. Sintaxis de la composición</a></span></dt><dt><span class="sect1"><a href="#idp7879040">14.2. Sintaxis de la herencia</a></span></dt><dt><span class="sect1"><a href="#idp7888120">14.3. Lista de inicializadores de un constructor</a></span></dt><dt><span class="sect1"><a href="#idp7916760">14.4. Ocultación de nombres</a></span></dt><dt><span class="sect1"><a href="#idp7935528">14.5. Funciones que no heredan automáticamente</a></span></dt><dt><span class="sect1"><a href="#idp7978816">14.6. Protected</a></span></dt><dt><span class="sect1"><a href="#idp7985456">14.7. Herencia y sobrecarga de operadores</a></span></dt><dt><span class="sect1"><a href="#idp7991328">14.8. Herencia múltiple</a></span></dt><dt><span class="sect1"><a href="#idp7993504">14.9. Desarrollo incremental</a></span></dt><dt><span class="sect1"><a href="#idp7998760">14.10. Upcasting</a></span></dt><dt><span class="sect1"><a href="#idp8033168">14.11. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp8036048">14.12. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      Una de las características más importantes acerca de C++ es la
      reutilización de código. Pero para ser revolucionario, necesita
      ser capaz de hacer algo más que copiar código y modificarlo.
    </p></div><p>
    Este es un enfoque de C y no fue demasiado bien. Como en la mayoría
    de los casos en C++, la solución gira alrededor de la clase. Se
    reutiliza código creando nuevas clases, pero en vez de crearlas
    desde la nada, utilizará clases existentes que alguien ha realizado
    y comprobado que funcionan correctamente.
  </p><p>
    La clave consiste en utilizar estas clases sin modificarlas. En este
    capítulo, aprenderá los dos modos de hacerlo. El primero es bastante
    directo: simplemente cree objetos de la clase existente dentro de la
    nueva clase. A esto se le llama composición porqué la nueva clase
    esta compuesta por objetos de clases ya existentes.
  </p><p>
    La segunda forma es mucho más sutil. Crear la nueva clase como un
    tipo de una clase existente. Literalmente se toma la forma de la
    clase existente y se añade código, pero sin modificar la clase ya
    existente. A este hecho mágico se le llama herencia, y la mayoría
    del trabajo es realizado por el compilador. La herencia es uno de
    los pilares de la programación orientada a objetos y tiene
    extensiones adicionales que serán exploradas en el capítulo 15.
  </p><p>
    Esto es, resulta que gran parte de la sintaxis y el comportamiento
    son similares tanto en la composición como en la herencia (lo cual
    tiene sentido; ambas son dos formas de crear nuevos tipos utilizando
    tipos ya existentes). En este capítulo, aprenderá acerca de los
    mecanismos para la reutilización de código.
  </p><div class="sect1" title="14.1. Sintaxis de la composición"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7871472"></a>14.1. Sintaxis de la composición</h2></div></div></div><p>
      Realmente, ha utilizado la composición a lo largo de la creación
      de una clase. Ha estado construyendo clases principalmente con
      tipos predefinidos (y en ocasiones cadenas). Por esto, resulta
      fácil usar la composición con tipos definidos por el usuario.
    </p><p>
      Considere la siguiente clase:
    </p><div class="example"><a id="idp7872872"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Useful.h</span>
<span class="hl slc">// A class to reuse</span>
<span class="hl ppc">#ifndef USEFUL_H</span>
<span class="hl ppc">#define USEFUL_H</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">() {</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">read</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">permute</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> i <span class="hl opt">=</span> i <span class="hl opt">*</span> <span class="hl num">47</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// USEFUL_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 14.1. C14/Useful.h</strong></p></div><br class="example-break" /><p>
      En esta clase los miembros son privados, y entonces, es
      completamente seguro declarar un objeto del tipo X público en la
      nueva clase, y por ello, permitir una interfaz directa:
    </p><div class="example"><a id="idp7874616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Composition.cpp</span>
<span class="hl slc">// Reuse code with composition</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Useful.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  X x<span class="hl opt">;</span> <span class="hl slc">// Embedded object</span>
  <span class="hl kwd">Y</span><span class="hl opt">() {</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Y y<span class="hl opt">;</span>
  y<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
  y<span class="hl opt">.</span>x<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl num">37</span><span class="hl opt">);</span> <span class="hl slc">// Access the embedded object</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.2. C14/Composition.cpp</strong></p></div><br class="example-break" /><p>
      Para acceder a las funciones miembro alojadas en el objeto
      (referido como subobjeto) simplemente requiere otra selección del
      miembro.
    </p><p>
      Es habitual hacer privado el objeto alojado, y por ello, formar
      parte de la capa de implementación (lo que significa que es
      posible cambiar la implementación si se desea). La interfaz de
      funciones de la nueva clase implica el uso del objeto alojado,
      pero no necesariamente imita a la interfaz del objeto.
    </p><div class="example"><a id="idp7877216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Composition2.cpp</span>
<span class="hl slc">// Private embedded objects</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Useful.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  X x<span class="hl opt">;</span> <span class="hl slc">// Embedded object</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Y</span><span class="hl opt">() {</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">;</span> x<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span>ii<span class="hl opt">); }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i <span class="hl opt">*</span> x<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">permute</span><span class="hl opt">() {</span> x<span class="hl opt">.</span><span class="hl kwd">permute</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Y y<span class="hl opt">;</span>
  y<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
  y<span class="hl opt">.</span><span class="hl kwd">permute</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.3. C14/Composition2.cpp</strong></p></div><br class="example-break" /><p>
      Aquí, la función permute() se ha añadido a la interfaz de la
      clase, pero el resto funciones de X son utilizadas dentro de los
      miembros de Y.
    </p></div><div class="sect1" title="14.2. Sintaxis de la herencia"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7879040"></a>14.2. Sintaxis de la herencia</h2></div></div></div><p>
      La sintaxis en la composición es bastante obvia, en cambio en la
      herencia, la sintaxis es nueva y diferente.
    </p><p>
      Cuando hereda, realmente se expresa "Esta nueva clase es como esta
      otra vieja clase". Se comienza el código proporcionando el nombre
      de la clase, como se realiza normalmente, pero antes de abrir la
      llave del cuerpo de la clase, se colocan dos puntos y el nombre de
      la clase base (o de las clases bases, separadas por comas, para
      herencia múltiple). Una vez realizado, automáticamente se
      consiguen todos los miembros y las funciones de la clase
      base. Ejemplo:
    </p><div class="example"><a id="idp7880880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Inheritance.cpp</span>
<span class="hl slc">// Simple inheritance</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Useful.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Y <span class="hl opt">:</span> <span class="hl kwc">public</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span> <span class="hl slc">// Different from X's i</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Y</span><span class="hl opt">() {</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">change</span><span class="hl opt">() {</span>
    i <span class="hl opt">=</span> <span class="hl kwd">permute</span><span class="hl opt">();</span> <span class="hl slc">// Different name call</span>
    <span class="hl kwa">return</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span>
    i <span class="hl opt">=</span> ii<span class="hl opt">;</span>
    X<span class="hl opt">::</span><span class="hl kwd">set</span><span class="hl opt">(</span>ii<span class="hl opt">);</span> <span class="hl slc">// Same-name function call</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(X) = &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>X<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(Y) = &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Y<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  Y D<span class="hl opt">;</span>
  D<span class="hl opt">.</span><span class="hl kwd">change</span><span class="hl opt">();</span>
  <span class="hl slc">// X function interface comes through:</span>
  D<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">();</span>
  D<span class="hl opt">.</span><span class="hl kwd">permute</span><span class="hl opt">();</span>
  <span class="hl slc">// Redefined functions hide base versions:</span>
  D<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl num">12</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.4. C14/Inheritance.cpp</strong></p></div><br class="example-break" /><p>
      Como se puede observar, Y hereda de X, que significa que Y
      contendrá todos los miembros de X y todas las funciones de X. De
      hecho, Y contiene un subobjeto X como si se hubiese creado un
      objeto X dentro de la clase Y en vez de heredar de X. Tanto los
      miembros objetos y la clase base son conocidos como subobjetos.
    </p><p>
      Todos los elementos privados de X continúan siendo privados en Y;
      esto es, aunque Y hereda de X no significa que Y pueda romper el
      mecanismo de protección. Los elementos privados de X continúan
      existiendo, ocupando su espacio - sólo que no se puede acceder a
      ellos directamente.
    </p><p>
      En main() observamos que los datos de Y están combinados con los
      datos de X porque sizeof(Y) es el doble de grande que el
      sizeof(X).
    </p><p>
      Observará que la clase base es precedida por public. Durante la
      herencia, por defecto, todo es privado. Si la clase base no
      estuviese precedida por public, significaría que todos los
      miembros públicos de la clase base serían privados en la clase
      derivada. Esto, en la mayoría de ocasiones no es lo deseado [51];
      el resultado que se desea es mantener todos los miembros públicos
      de la clase base en la clase derivada. Para hacer esto, se usa la
      palabra clave public durante la herencia.
    </p><p>
      En change(), se utiliza a la función de la clase base
      permute(). La clase derivada tiene acceso directo a todas las
      funciones públicas de la clase base.
    </p><p>
      La función set() en la clase derivada redefine la función set()
      de la clase base. Esto es, si llama a las funciones read() y
      permute() de un objeto Y, conseguirá las versiones de la clase
      base (esto es lo que esta ocurriendo dentro de main()). Pero si
      llamamos a set() en un objeto Y, conseguiremos la versión
      redefinida. Esto significa que si no deseamos un comportamiento de
      una función durante la herencia, se puede cambiar. (También se
      pueden añadir funciones completamente nuevas como change().)
    </p><p>
      Sin embargo, cuando redefinimos una función, puede ser que desee
      llamar a la versión de la clase base. Si, dentro de set(),
      simplemente llama a set(), conseguiremos una versión local de la
      función - una función recursiva. Para llamar a la versión de la
      clase base, se debe explícitamente utilizar el nombre de la clase
      base y el operador de resolución de alcance.
    </p></div><div class="sect1" title="14.3. Lista de inicializadores de un constructor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7888120"></a>14.3. Lista de inicializadores de un constructor</h2></div></div></div><p>
      Hemos visto lo importante que es en C++ garantizar una correcta
      inicialización, y esto no va a cambiar en la composición ni en la
      herencia. Cuando se crea un objeto, el compilador garantiza la
      ejecución todos los constructores para cada uno de los
      subobjetos. Hasta ahora, en los ejemplos, todos los subobjetos
      tienen un constructor por defecto, que es ejecutado por el
      compilador automáticamente. Pero que ocurre si uno de nuestros
      subobjetos no tiene constructores por defecto, o si queremos
      cambiar los parámetros por defecto de un constructor. Esto supone
      un problema, porque el constructor de la nueva clase no tiene
      permiso para acceder a los miembros privados del subobjeto y por
      ello, no puede inicializarlos directamente.
    </p><p>
      La solución es simple: ejecutar el constructor del subobjeto. C++
      proporciona una sintaxis especial para ello, la lista de
      inicializadores de un constructor. La forma de la lista de
      inicializadores de un constructor demuestra como actúa como la
      herencia. Con la herencia, las clases bases son colocadas después
      de dos puntos y justo después, puede abrir la llave para empezar
      con el cuerpo de la clase. En la lista de inicializadores de un
      constructor, se coloca las llamadas a los constructores de los
      subobjetos, después los argumentos del constructor y los dos
      puntos, pero todo esto, antes de abrir el brazo del cuerpo de la
      función. En una clase MyType, que hereda de Bar, sería de la
      siguiente manera:
    </p><pre class="programlisting">
MyType<span class="hl opt">::</span><span class="hl kwd">MyType</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) :</span> <span class="hl kwd">Bar</span><span class="hl opt">(</span>i<span class="hl opt">) {</span> <span class="hl slc">// ...</span>
</pre><p>
      si el constructor de Bar tuviera un solo parámetro del tipo <code class="type">int</code>.
    </p><div class="sect2" title="14.3.1. Inicialización de objetos miembros"><div class="titlepage"><div><div><h3 class="title"><a id="idp7893248"></a>14.3.1. Inicialización de objetos miembros</h3></div></div></div><p>
	La inicialización de objetos miembros de una clase utiliza la
	misma sintaxis cuando se usa la composición. Para la
	composición, se proporcionan los nombres de los objetos en lugar
	de los nombres de las clases. Si se tiene más de una llamada al
	constructor en la lista de inicializadores, las llamadas se
	separan con comas:
      </p><pre class="programlisting">
MyType2<span class="hl opt">::</span><span class="hl kwd">MyType2</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) :</span> <span class="hl kwd">Bar</span><span class="hl opt">(</span>i<span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span>i<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">) {</span> <span class="hl slc">// ...</span>
</pre><p>
	Esta sería la forma de un constructor de la clase MyType2, la
	cual hereda de Bar y contiene un miembro objeto llamado
	m. Fíjese que mientras podemos ver el tipo de la clase base en
	la lista de inicializadores del constructor, sólo podemos ver el
	miembro identificador objeto.
      </p></div><div class="sect2" title="14.3.2. Tipos predefinidos en la lista de inicializadores"><div class="titlepage"><div><div><h3 class="title"><a id="idp7895744"></a>14.3.2. Tipos predefinidos en la lista de inicializadores</h3></div></div></div><p>
	La lista de inicializadores del constructor permite invocar
	explícitamente a los constructores de los objetos miembros. De
	hecho, no existe otra forma de llamar a esos constructores. La
	idea es que los constructores son llamados antes de la ejecución
	del cuerpo del constructor de la nueva clase. De esta forma,
	cualquier llamada que hagamos a las funciones miembros de los
	subobjetos siempre serán objetos inicializados. No existe otra
	manera de acceder al cuerpo del constructor sin que ningún
	constructor llame a todos los miembros objetos y los objetos de
	la clase base, es más, el compilador crea un constructor oculto
	por defecto. Esto es otra característica de C++, que garantiza
	que ningún objeto (o parte de un objeto) puedan estar desde un
	principio sin que su constructor sea llamado.
      </p><p>
	La idea de que todos los objetos miembros estén inicializados al
	inicio del constructor es una buena ayuda para programar. Una
	vez en el inicio del constructor, puede asumir que todos los
	subobjetos están correctamente inicializados y centrarse en las
	tareas que se desean realizar en el constructor. Sin embargo,
	existe un contratiempo: ¿Qué ocurre con los objetos
	predefinidos, aquellos que no tienen constructor?
      </p><p>
	Para hacer una sintaxis sólida, piense en los tipos predefinidos
	como si tuviesen un solo constructor, con un solo parámetro: una
	variable del mismo tipo como el que esta inicializando. Esto es
      </p><div class="example"><a id="idp7899616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:PseudoConstructor.cpp</span>
<span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> s<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">X</span><span class="hl opt">() :</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">7</span><span class="hl opt">),</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">1.4</span><span class="hl opt">),</span> <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl str">'x'</span><span class="hl opt">),</span> <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;howdy&quot;</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X x<span class="hl opt">;</span>
  <span class="hl kwb">int</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>  <span class="hl slc">// Applied to ordinary definition</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.5. C14/PseudoConstructor.cpp</strong></p></div><br class="example-break" /><p>
	El propósito de esta "pseudo-llamadas a los constructores" es una simple
	asignación. Es una técnica recomendada y un buen estilo de programación,
	que usted verá usar a menudo.
      </p><p>
	ncluso es posible utilizar esta sintaxis cuando se crean
	variables de tipos predefinidos fuera de la clase:
      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>
<span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
</pre><p>
	De esta forma, los tipos predefinidos actúan, más o menos, como
	los objetos. Sin embargo, recuerde que no son constructores
	reales. En particular, si usted no realiza una llamada explícita
	al constructor, no se ejecutará ninguna inicialización.
      </p></div><div class="sect2" title="14.3.3. Combinación de composición y herencia"><div class="titlepage"><div><div><h3 class="title"><a id="idp7902848"></a>14.3.3. Combinación de composición y herencia</h3></div></div></div><p>
	Por supuesto, usted puede usar la composición y la herencia a la
	vez. El siguiente ejemplo muestra la creación de una clase más
	compleja utilizando composición y herencia.
      </p><div class="example"><a id="idp7903832"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Combined.cpp</span>
<span class="hl slc">// Inheritance &amp; composition</span>

<span class="hl kwc">class</span> A <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">A</span><span class="hl opt">() {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> B <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">B</span><span class="hl opt">() {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> C <span class="hl opt">:</span> <span class="hl kwc">public</span> B <span class="hl opt">{</span>
  A a<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">B</span><span class="hl opt">(</span>ii<span class="hl opt">),</span> <span class="hl kwd">a</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">C</span><span class="hl opt">() {}</span> <span class="hl slc">// Calls ~A() and ~B()</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>  <span class="hl slc">// Redefinition</span>
    a<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
    B<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  C <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.6. C14/Combined.cpp</strong></p></div><br class="example-break" /><p>
	C hereda de B y tiene un objeto miembro ("esta compuesto de")
	del tipo A. Puede comparar que la lista de inicializadores
	contiene las llamadas al constructor de la clase base y las
	constructores de los objetos miembros.
      </p><p>
	La función C::f() redefine B::f(), que era heredada, y también
	llama a la versión de la clase base. Además, se llama a
	a.f(). Fíjese que durante todo este tiempo estamos hablando
	acerca de la redefinición de funciones durante la herencia; con
	un objeto miembro que sólo se puede manipular su interfaz
	pública, no redefinirla. Además, al llamar a f() en un objeto de
	la clase C no podrá llamar a a.f() si C::f() no ha sido
	definido, mientras que sería posible llamar a B::f().
      </p><div class="sect3" title="Llamadas automáticas al destructor"><div class="titlepage"><div><div><h4 class="title"><a id="idp7906944"></a>Llamadas automáticas al destructor </h4></div></div></div><p>
	  Aunque muy a menudo sea necesario realizar llamadas explicitas
	  a los constructores en la inicialización, nunca será necesario
	  realizar una llamada explicita a los destructores porque sólo
	  existe un destructor para cada clase y éste no tiene
	  parámetros. Sin embargo, el compilador asegura que todos los
	  destructores son llamados, esto significa que todos los
	  destructores de la jerarquía, desde el destructor de la clase
	  derivada y retrocediendo hasta la raíz, serán ejecutados.
	</p><p>
	  Es necesario destacar que los constructores y destructores son
	  un poco inusuales en el modo en que llaman a su jerarquía, en
	  una función miembro normal sólo la función en si es llamada,
	  ninguna versión de la clase base. Si usted desea llamar a la
	  versión de la clase base de una función miembro normal, deberá
	  sobrecargarla y deberá llamarla explícitamente.
	</p></div></div><div class="sect2" title="14.3.4. Orden de llamada de constructores y destructores"><div class="titlepage"><div><div><h3 class="title"><a id="idp7909464"></a>14.3.4. Orden de llamada de constructores y destructores</h3></div></div></div><p>
	Es importante conocer el orden de las llamadas de los
	constructores y destructores de un objeto con varios
	subobjetos. El siguiente ejemplo muestra cómo funciona:
      </p><div class="example"><a id="idp7910392"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Order.cpp</span>
<span class="hl slc">// Constructor/destructor order</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;order.out&quot;</span><span class="hl opt">);</span>

<span class="hl ppc">#define CLASS(ID) class ID { \</span>
<span class="hl ppc">public: \</span>
<span class="hl ppc">  ID(int) { out &lt;&lt; #ID</span> <span class="hl pps">&quot; constructor</span><span class="hl esc">\n</span><span class="hl pps">&quot;</span><span class="hl ppc">; } \</span>
<span class="hl ppc">  ~ID() { out &lt;&lt; #ID</span> <span class="hl pps">&quot; destructor</span><span class="hl esc">\n</span><span class="hl pps">&quot;</span><span class="hl ppc">; } \</span>
<span class="hl ppc">};</span>

<span class="hl kwd">CLASS</span><span class="hl opt">(</span>Base1<span class="hl opt">);</span>
<span class="hl kwd">CLASS</span><span class="hl opt">(</span>Member1<span class="hl opt">);</span>
<span class="hl kwd">CLASS</span><span class="hl opt">(</span>Member2<span class="hl opt">);</span>
<span class="hl kwd">CLASS</span><span class="hl opt">(</span>Member3<span class="hl opt">);</span>
<span class="hl kwd">CLASS</span><span class="hl opt">(</span>Member4<span class="hl opt">);</span>

<span class="hl kwc">class</span> Derived1 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base1 <span class="hl opt">{</span>
  Member1 m1<span class="hl opt">;</span>
  Member2 m2<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Derived1</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) :</span> <span class="hl kwd">m2</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">m1</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">Base1</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">) {</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived1 constructor</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Derived1</span><span class="hl opt">() {</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived1 destructor</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Derived1 <span class="hl opt">{</span>
  Member3 m3<span class="hl opt">;</span>
  Member4 m4<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Derived2</span><span class="hl opt">() :</span> <span class="hl kwd">m3</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">Derived1</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">),</span> <span class="hl kwd">m4</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">) {</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived2 constructor</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Derived2</span><span class="hl opt">() {</span>
    out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived2 destructor</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Derived2 d2<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.7. C14/Order.cpp</strong></p></div><br class="example-break" /><p>
	Primero, se crea un objeto ofstream para enviar la salida a un
	archivo. Entonces, para no teclear tanto y demostrar la técnica
	de las macros que será sustituida por otra mucho más mejorada en
	el capítulo 16, se crea una para construir varias clases que
	utilizan herencia y composición. Cada constructor y destructor
	escribe información en el archivo de salida. Fíjense que los
	constructores no son constructores por defecto; cada uno tiene
	un parámetro del tipo int. Y además, el argumento no tiene
	nombre; la única razón de su existencia es forzar la llamada al
	constructor en la lista de inicializadores del
	constructor. (Eliminando el identificador evita que el
	compilador informe con mensajes de advertencia)
      </p><p>
	La salida de este programa es
      </p><pre class="screen">
Base1 constructor
Member1 constructor
Member2 constructor
Derived1 constructor
Member3 constructor
Member4 constructor
Derived2 constructor
Derived2 destructor
Member4 destructor
Member3 destructor
Derived1 destructor
Member2 destructor
Member1 destructor
Base1 destructor
</pre><p>
	omo puede observar, la construcción empieza desde la raíz de la
	jerarquía de clases y en cada nivel, el constructor de la clase
	base se ejecuta primero, seguido por los constructores de los
	objetos miembro. Los destructores son llamados exactamente en el
	orden inverso que los constructores -esto es importante debido a
	los problemas de dependencias (en el constructor de la clase
	derivada o en el destructor, se debe asumir que el subobjeto de
	la clase base esta todavía disponible para su uso, y ha sido
	construido - o no se ha destruido todavía).
      </p><p>
	También es interesante que el orden de las llamadas al
	constructor para los objetos miembro no afecten para nada el
	orden de las llamadas en la lista de inicializadores de un
	constructor. El orden es determinado por el orden en que los
	objetos miembros son declarados en la clase. Si usted pudiera
	cambiar el orden del constructor en la lista de inicializadores
	de un constructor, usted podría tener dos secuencias diferentes
	de llamada en dos constructores diferentes, pero el destructor
	no sabría como invertir el orden para llamarse correctamente y
	nos encontraríamos con problemas de dependencias.
      </p></div></div><div class="sect1" title="14.4. Ocultación de nombres"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7916760"></a>14.4. Ocultación de nombres</h2></div></div></div><p>
      Si se ha heredado de una clase y se proporciona una nueva
      definición para alguna de sus funciones miembros, existen dos
      posibilidades. La primera es proporcionar los mismos argumentos y
      el mismo tipo de retorno en la definición de la clase derivada
      como la clase base. Esto es conocido como redefinición para
      funciones miembro ordinarias y sobrecarga, cuando la función
      miembro de la clase es una función virtual (las funciones
      virtuales son un caso normal y serán tratadas en detalle en el
      capítulo 15). Pero ¿qué ocurre cuando se modifican los argumentos
      de la función miembro o el tipo de retorno en una clase derivada?
      Aquí esta un ejemplo:
    </p><div class="example"><a id="idp7918096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:NameHiding.cpp</span>
<span class="hl slc">// Hiding overloaded names during inheritance</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Base::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">(</span>string<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived1 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Redefinition:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived2::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived3 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Change return type:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived3::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived4 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Change argument list:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived4::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> <span class="hl num">4</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;hello&quot;</span><span class="hl opt">);</span>
  Derived1 d1<span class="hl opt">;</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> d1<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  d1<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  Derived2 d2<span class="hl opt">;</span>
  x <span class="hl opt">=</span> d2<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl slc">//!  d2.f(s); // string version hidden</span>
  Derived3 d3<span class="hl opt">;</span>
<span class="hl slc">//!  x = d3.f(); // return int version hidden</span>
  Derived4 d4<span class="hl opt">;</span>
<span class="hl slc">//!  x = d4.f(); // f() version hidden</span>
  x <span class="hl opt">=</span> d4<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.8. C14/NameHiding.cpp</strong></p></div><br class="example-break" /><p>
      En Base se observa una función sobrecargada f(), en Derived1 no se
      realiza ningún cambio a f() pero se redefine la función g(). En
      main(), se observa que ambas funciones f() están disponibles en
      Derived1. Sin embargo, Derived2 redefine una versión sobrecargada
      de f() pero no la otra, y el resultado es que la segunda forma de
      sobrecarga no esta disponible. En Derived3, se ha cambiado el tipo
      de retorno y esconde ambas versiones de la clase base, y Derived4
      muestra que al cambiar la lista de argumentos también se esconde
      las versiones de la clase base. En general, usted puede expresar
      cada vez que redefine una función sobrecargada de la clase base,
      que todas las otras versiones son automáticamente escondidas en la
      nueva clase. En el capítulo 15, verá como añadir la palabra
      reservada virtual que afecta un significativamente a la sobrecarga
      de una función.
    </p><p>
      Si cambia la interfaz de la clase base modificando la signatura
      y/o el tipo de retorno de una función miembro desde la clase base,
      entonces esta utilizando la clase de una forma diferente en que la
      herencia esta pensado para realizar normalmente. Esto no quiere
      decir que lo que este haciendo sea incorrecto, esto es que el
      principal objetivo de la herencia es soportar el polimorfismo, y
      si usted cambia la signatura de la función o el tipo de retorno
      entonces realmente esta cambiando la interfaz de la clase base. Si
      esto es lo que esta intentando hacer entonces esta utilizando la
      herencia principalmente para la reutilización de código, no para
      mantener interfaces comunes en la clase base (que es un aspecto
      esencial del poliformismo). En general, cuando usa la herencia de
      esta forma significa que esta en una clase de propósito general y
      la especialización para una necesidad particular - que
      generalmente, pero no siempre, se considera parte de la
      composición.
    </p><p>
      Por ejemplo, considere la clase Stack del capítulo 9. Uno de los
      problemas con esta clase es que se tenía que realizar que
      convertir cada vez que se conseguía un puntero desde el
      contenedor. Esto no es solo tedioso, también inseguro - se puede
      convertir a cualquier cosa que desee.
    </p><p>
      Un procedimiento que a primera vista parece mejor es especializar
      la clase general Stack utilizando la herencia. Aquí esta un
      ejemplo que utiliza la clase del capítulo 9.
    </p><div class="example"><a id="idp7926288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:InheritStack.cpp</span>
<span class="hl slc">// Specializing the Stack class</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../C09/Stack4.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> StringStack <span class="hl opt">:</span> <span class="hl kwc">public</span> Stack <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>string<span class="hl opt">*</span> str<span class="hl opt">) {</span>
    Stack<span class="hl opt">::</span><span class="hl kwd">push</span><span class="hl opt">(</span>str<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  string<span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl opt">(</span>string<span class="hl opt">*)</span>Stack<span class="hl opt">::</span><span class="hl kwd">peek</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  string<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwa">return</span> <span class="hl opt">(</span>string<span class="hl opt">*)</span>Stack<span class="hl opt">::</span><span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">StringStack</span><span class="hl opt">() {</span>
    string<span class="hl opt">*</span> top <span class="hl opt">=</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>top<span class="hl opt">) {</span>
      <span class="hl kwa">delete</span> top<span class="hl opt">;</span>
      top <span class="hl opt">=</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;InheritStack.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;InheritStack.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  StringStack textlines<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  string<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>s <span class="hl opt">=</span> textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">) {</span> <span class="hl slc">// No cast!</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.9. C14/InheritStack.cpp</strong></p></div><br class="example-break" /><p>
      Como todas las funciones miembros en Stack4.h son inline, no es
      necesario ser enlazadas.
    </p><p>
      StringStack especializa Stack para que push() acepte solo punteros
      a String. Antes, Stack acepta punteros a void, y así el usuario no
      tenía que realizar una comprobación de tipos para asegurarse que
      el punteros fuesen insertados. Además, peek() and pop() ahora
      retornan punteros a String en vez de punteros a void, entonces no
      es necesario realizar la conversión para utilizar el puntero.
    </p><p>
      orprendido ¡este mecanismo de comprobación de tipos seguro es
      gratuito, en push(), peek() y pop! Al compilador se le proporciona
      información extra acerca de los tipos y éste lo utiliza en tiempo
      de compilación, pero las funciones son inline y no es necesario
      ningún código extra.
    </p><p>
      La ocultación de nombres entra en acción en la función push() que
      tiene la signatura diferente: la lista de argumentos. Si se
      tuviesen dos versiones de push() en la misma clase, tendrían que
      ser sobrecargadas, pero en este caso la sobrecarga no es lo que
      deseamos porque todavía permitiría pasar cualquier tipo de puntero
      a push como void *. Afortunadamente, C++ esconde la versión push
      (void *) en la clase base en favor de la nueva versión que es
      definida en la clase derivada, de este modo, solo se permite
      utilizar la función push() con punteros a String en StringStack.
    </p><p>
      Ahora podemos asegurar que se conoce exactamente el tipo de objeto
      que esta en el contenedor, el destructor funcionará correctamente
      y problema esta resuelto - o al menos, un parte del
      procedimiento. Si utiliza push( ) con un puntero a String en
      StringStack, entonces (según el significado de StringStack)
      también se esta pasando el puntero a StringStack. Si utiliza
      pop(), no solo consigue puntero, sino que a la vez el
      propietario. Cualquier puntero que se haya dejado en StringStack
      será borrado cuando el destructor sea invocado. Puesto que siempre
      son punteros a Strings y la declaración delete esta funcionando
      con punteros a String en vez de punteros a void, la destrucción se
      realiza de forma adecuada y todo funciona correctamente.
    </p><p>
      Esto es una desventaja: esta clase solo funciona con punteros de
      cadenas. Si se desea un Stack que funcione con cualquier variedad
      de objetos, se debe escribir una nueva versión de la clase que
      funcione con ese nuevo tipo de objeto. Esto puede convertirse
      rápidamente en una tarea tediosa, pero finalmente es resulta
      utilizando plantillas como se vera en el capítulo 16.
    </p><p>
      Existen consideraciones adicionales sobre este ejemplo: el cambio
      de la interfaz en Stack en el proceso de herencia. Si la interfaz
      es diferente, entonces StringStack no es realmente un Stack, y
      nunca será posible usar de forma correcta un StringStack como
      Stack. Esto hace que el uso de la herencia sea cuestionable en
      este punto; si no se esta creando un StringStack del tipo Stack,
      entonces, porque hereda de él. Más adelante, sen este mismo
      capítulo se mostrará una versión más adecuada.
    </p></div><div class="sect1" title="14.5. Funciones que no heredan automáticamente"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7935528"></a>14.5. Funciones que no heredan automáticamente</h2></div></div></div><p>
      No todas las funciones son heredadas automáticamente desde la
      clase base a la clase derivada. Los constructores y destructores
      manejan la creación y la destrucción de un objeto y sólo ellos
      saben que hacer con los aspectos de un objeto en sus clases
      particulares y por ello los constructores y destructores
      inferiores de la jerarquía deben llamarlos. Así, los constructores
      y destructores no se heredan y deben ser creados específicamente
      en cada clase derivada.
    </p><p>
      Además, operator= tampoco se hereda porque realiza una acción
      parecida al constructor. Esto es, sólo porque conoce como asignar
      todos los miembros de un objeto, la parte izquierda del = a la
      parte derecha del otro objeto, no significa que la asignación
      tendrá el mismo significado después de la herencia.
    </p><p>
      En la herencia, estas funciones son creadas por el compilador si
      no son creadas por usted. (Con constructores, no se pueden crear
      constructores para que el compilador cree el constructor por
      defecto y el constructor copia.) Esto fue brevemente descrito en
      el capítulo 6. Los constructores creados se usan en inicialización
      de sus miembros y la creación del operator= usa la asignación de
      los miembros. A continuación, un ejemplo de las funciones que son
      creadas por el compilador.
    </p><div class="example"><a id="idp7938936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:SynthesizedFunctions.cpp</span>
<span class="hl slc">// Functions that are synthesized by the compiler</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> GameBoard <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">GameBoard</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;GameBoard()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwd">GameBoard</span><span class="hl opt">(</span><span class="hl kwb">const</span> GameBoard<span class="hl opt">&amp;) {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;GameBoard(const GameBoard&amp;)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  GameBoard<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> GameBoard<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;GameBoard::operator=()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">GameBoard</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~GameBoard()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Game <span class="hl opt">{</span>
  GameBoard gb<span class="hl opt">;</span> <span class="hl slc">// Composition</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Default GameBoard constructor called:</span>
  <span class="hl kwd">Game</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Game()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl slc">// You must explicitly call the GameBoard</span>
  <span class="hl slc">// copy-constructor or the default constructor</span>
  <span class="hl slc">// is automatically called instead:</span>
  <span class="hl kwd">Game</span><span class="hl opt">(</span><span class="hl kwb">const</span> Game<span class="hl opt">&amp;</span> g<span class="hl opt">) :</span> <span class="hl kwd">gb</span><span class="hl opt">(</span>g<span class="hl opt">.</span>gb<span class="hl opt">) {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Game(const Game&amp;)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwd">Game</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Game(int)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  Game<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Game<span class="hl opt">&amp;</span> g<span class="hl opt">) {</span>
    <span class="hl slc">// You must explicitly call the GameBoard</span>
    <span class="hl slc">// assignment operator or no assignment at </span>
    <span class="hl slc">// all happens for gb!</span>
    gb <span class="hl opt">=</span> g<span class="hl opt">.</span>gb<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Game::operator=()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">class</span> Other <span class="hl opt">{};</span> <span class="hl slc">// Nested class</span>
  <span class="hl slc">// Automatic type conversion:</span>
  <span class="hl kwc">operator</span> <span class="hl kwd">Other</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Game::operator Other()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Other</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Game</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Game()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Chess <span class="hl opt">:</span> <span class="hl kwc">public</span> Game <span class="hl opt">{};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Game<span class="hl opt">::</span>Other<span class="hl opt">) {}</span>

<span class="hl kwc">class</span> Checkers <span class="hl opt">:</span> <span class="hl kwc">public</span> Game <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Default base-class constructor called:</span>
  <span class="hl kwd">Checkers</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Checkers()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl slc">// You must explicitly call the base-class</span>
  <span class="hl slc">// copy constructor or the default constructor</span>
  <span class="hl slc">// will be automatically called instead:</span>
  <span class="hl kwd">Checkers</span><span class="hl opt">(</span><span class="hl kwb">const</span> Checkers<span class="hl opt">&amp;</span> c<span class="hl opt">) :</span> <span class="hl kwd">Game</span><span class="hl opt">(</span>c<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Checkers(const Checkers&amp; c)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Checkers<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Checkers<span class="hl opt">&amp;</span> c<span class="hl opt">) {</span>
    <span class="hl slc">// You must explicitly call the base-class</span>
    <span class="hl slc">// version of operator=() or no base-class</span>
    <span class="hl slc">// assignment will happen:</span>
    Game<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">=(</span>c<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Checkers::operator=()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Chess d1<span class="hl opt">;</span>  <span class="hl slc">// Default constructor</span>
  Chess <span class="hl kwd">d2</span><span class="hl opt">(</span>d1<span class="hl opt">);</span> <span class="hl slc">// Copy-constructor</span>
<span class="hl slc">//! Chess d3(1); // Error: no int constructor</span>
  d1 <span class="hl opt">=</span> d2<span class="hl opt">;</span> <span class="hl slc">// Operator= synthesized</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>d1<span class="hl opt">);</span> <span class="hl slc">// Type-conversion IS inherited</span>
  Game<span class="hl opt">::</span>Other go<span class="hl opt">;</span>
<span class="hl slc">//!  d1 = go; // Operator= not synthesized </span>
           <span class="hl slc">// for differing types</span>
  Checkers c1<span class="hl opt">,</span> <span class="hl kwd">c2</span><span class="hl opt">(</span>c1<span class="hl opt">);</span>
  c1 <span class="hl opt">=</span> c2<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.10. C14/SynthesizedFunctions.cpp</strong></p></div><br class="example-break" /><p>
      Los constructores y el operator= de GameBoard y Game se describen
      por si solos y por ello distinguirá cuando son utilizados por el
      compilador. Además, el operador Other() ejecuta una conversión
      automática de tipo desde un objeto Game a un objeto de la clase
      anidada Other. La clase Chess simplemente hereda de Game y no crea
      ninguna función (sólo para ver como responde el compilador) La
      función f() coge un objeto Other para comprobar la conversión
      automática del tipo.
    </p><p>
      En main(), el constructor creado por defecto y el constructor
      copia de la clase derivada Chess son ejecutados. Las versiones de
      Game de estos constructores son llamados como parte de la
      jerarquía de llamadas a los constructores. Aun cuando esto es
      parecido a la herencia, los nuevos constructores son realmente
      creados por el compilador. Como es de esperar, ningún constructor
      con argumentos es ejecutado automáticamente porque es demasiado
      trabajo para el compilador y no es capaz de intuirlo.
    </p><p>
      El operator= es también es creado como una nueva función en Chess
      usando la asignación (así, la versión de la clase base es
      ejecutada) porque esta función no fue explícitamente escrita en la
      nueva clase. Y, por supuesto el destructor es creado
      automáticamente por el compilador.
    </p><p>
      El porqué de todas estas reglas acerca de la reescritura de
      funciones en relación a la creación de un objeto pueden parecer un
      poco extrañas en una primera impresión y como se heredan las
      conversiones automáticas de tipo. Pero todo esto tiene sentido -
      si existen suficiente piezas en Game para realizar un objeto
      Other, aquellas piezas están todavía en cualquier objeto derivado
      de Game y el tipo de conversión es válido (aun cuando puede, si lo
      desea, redefinirlo).
    </p><p>
      El operator= es creado automáticamente sólo para asignar objeto
      del mismo tipo. Si desea asignar otro tipo, deberá escribir el
      operator= usted mismo.
    </p><p>
      Si mira con detenimiento Game, observará que el constructor copia
      y la asignación tienen llamadas explicitas a constructor copia del
      objeto miembro y al operador de asignación. En la mayoría de
      ocasiones, deberá hacer esto porque sino, en vez del constructor
      copia, será llamado el constructor por defecto del objeto miembro,
      y en el caso del operador de asignación, ¡ninguna asignación se
      hará en los objetos miembros!
    </p><p>
      Por último, fíjese en Checkers, dónde explícitamente se escribe un
      constructor por defecto, constructor copia y los operadores de
      asignación. En el caso del constructor por defecto, el constructor
      por defecto de la clase base se llama automáticamente, y esto es
      lo normalmente que se desea hacer. Pero, aquí existe un punto
      importante, tan pronto que se decide escribir nuestro propio
      constructor copia y operador de asignación, el compilador asume
      que usted sabe lo que esta haciendo y no ejecutará automáticamente
      las versiones de la clase base así como las funciones creadas
      automáticamente. Si se quiere ejecutar las versiones de la clase
      base, debe llamarlas explícitamente. En el constructor copia de
      Checkers, esta llamada aparece en la lista de inicialización del
      constructor:
    </p><pre class="programlisting">
<span class="hl kwd">Checkers</span><span class="hl opt">(</span><span class="hl kwb">const</span> Checkers<span class="hl opt">&amp;</span> c<span class="hl opt">) :</span> <span class="hl kwd">Game</span><span class="hl opt">(</span>c<span class="hl opt">) {</span>
</pre><p>
      En el operador de asignación de Checkers, la clase base se llama
      en la primera línea del cuerpo de la función:
    </p><pre class="programlisting">
Game<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">=(</span>c<span class="hl opt">);</span>
</pre><p>
      Estas llamadas deben seguirse de forma canónica cuando usa
      cualquier clase derivada.
    </p><div class="sect2" title="14.5.1. Herencia y métodos estáticos"><div class="titlepage"><div><div><h3 class="title"><a id="idp7951864"></a>14.5.1. Herencia y métodos estáticos</h3></div></div></div><p>
	Las funciones miembro estáticas funcionan igual que las
	funciones miembros no estáticas:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    Son heredadas en la clase derivada.
	  </p></li><li class="listitem"><p>
	    Si redefine un miembro estático, el resto de funciones
	    sobrecargadas en la clase base son ocultas.
	  </p></li><li class="listitem"><p>
	    Si cambia la signatura de una función en la clase base,
	    todas las versiones con ese nombre de función en la clase
	    base son ocultadas (esto es realmente una variación del
	    punto anterior).
	  </p></li></ol></div><p>
	Sin embargo, las funciones miembro estáticas no pueden ser
	virtuales (este tema se cubrirá detenidamente en el capítulo
	15).
      </p></div><div class="sect2" title="14.5.2. Composición vs. herencia"><div class="titlepage"><div><div><h3 class="title"><a id="idp7955552"></a>14.5.2. Composición vs. herencia</h3></div></div></div><p>
	La composición y la herencia colocan subobjetos dentro de la
	clase. Ambos usan la lista de inicialización del constructor
	para construir esos subobjetos. Pero se preguntará cuál es la
	diferencia entre los dos, y cuando escoger una y no la otra.
      </p><p>
	La composición generalmente se usa cuando se quieren las
	características de una clase existente dentro se su clase, pero
	no en su interfaz. Esto es, aloja un objeto para implementar
	características en su clase, pero el usuario de su clase ve el
	interfaz que se ha definido, en vez del interfaz de la clase
	original. Para hacer esto, se sigue el típico patrón de alojar
	objetos privados de clases existentes en su nueva clase.
      </p><p>
	En ocasiones, sin embargo, tiene sentido permitir que el usuario
	de la clase acceda a la composición de su clase, esto es, hacer
	públicos los miembros objeto. Los miembros objeto usan su
	control de accesos, entonces es seguro y cuando el usuario
	conoce que esta formando un conjunto de piezas, hace que la
	interfaz sea más fácil de entender. Un buen ejemplo es la clase
	Car:
      </p><div class="example"><a id="idp7958464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Car.cpp</span>
<span class="hl slc">// Public composition</span>

<span class="hl kwc">class</span> Engine <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">start</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rev</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">stop</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Wheel <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> psi<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Window <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rollup</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rolldown</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Door <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Window window<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">open</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">close</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Car <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Engine engine<span class="hl opt">;</span>
  Wheel wheel<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">];</span>
  Door left<span class="hl opt">,</span> right<span class="hl opt">;</span> <span class="hl slc">// 2-door</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Car car<span class="hl opt">;</span>
  car<span class="hl opt">.</span>left<span class="hl opt">.</span>window<span class="hl opt">.</span><span class="hl kwd">rollup</span><span class="hl opt">();</span>
  car<span class="hl opt">.</span>wheel<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">].</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl num">72</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.11. C14/Car.cpp</strong></p></div><br class="example-break" /><p>
	Como la composición de Car es parte del análisis del problema (y
	no una simple capa del diseño), hace públicos los miembros y
	ayudan al programador a entender como se utiliza la clase y
	requiere menos complejidad de código para el creador de la
	clase.
      </p><p>
	Si piensa un poco, observará que no tiene sentido componer un
	Car usando un objeto "vehículo" - un coche no contiene un
	vehículo, es un vehículo. La relación "es-un" es expresado con
	la herencia y la relación "tiene un" es expresado con la
	composición.
      </p><div class="sect3" title="Subtipado"><div class="titlepage"><div><div><h4 class="title"><a id="idp7961368"></a>Subtipado</h4></div></div></div><p>
	  Ahora suponga que desea crear un objeto del tipo ifstream que
	  no solo abre un fichero sino que también guarde el nombre del
	  fichero. Puede usar la composición e alojar un objeto ifstream
	  y un string en la nueva clase:
	</p><div class="example"><a id="idp7962376"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:FName1.cpp</span>
<span class="hl slc">// An fstream with a file name</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> FName1 <span class="hl opt">{</span>
  ifstream file<span class="hl opt">;</span>
  string fileName<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> named<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">FName1</span><span class="hl opt">() :</span> <span class="hl kwd">named</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwd">FName1</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> fname<span class="hl opt">)</span> 
    <span class="hl opt">:</span> <span class="hl kwd">fileName</span><span class="hl opt">(</span>fname<span class="hl opt">),</span> <span class="hl kwd">file</span><span class="hl opt">(</span>fname<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">()) {</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>file<span class="hl opt">,</span> fileName<span class="hl opt">);</span>
    named <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  string <span class="hl kwd">name</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> fileName<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">name</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>named<span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span> <span class="hl slc">// Don't overwrite</span>
    fileName <span class="hl opt">=</span> newName<span class="hl opt">;</span>
    named <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">operator</span> ifstream<span class="hl opt">&amp;() {</span> <span class="hl kwa">return</span> file<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  FName1 <span class="hl kwd">file</span><span class="hl opt">(</span><span class="hl str">&quot;FName1.cpp&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> file<span class="hl opt">.</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Error: close() not a member:</span>
<span class="hl slc">//!  file.close();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.12. C14/FName1.cpp</strong></p></div><br class="example-break" /><p>
	  Sin embargo, existe un problema. Se intenta permitir el uso de
	  un objeto FName1 en cualquier lugar dónde se utilice un objeto
	  ifstream, incluyendo una conversión automática del tipo desde
	  FName1 a ifstream&amp;. Pero en main, la línea
	</p><pre class="programlisting">
file<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
</pre><p>
	  no compilará porque la conversión automática de tipo sólo
	  ocurre cuando se llama a la función, no durante la selección
	  del miembro. Por ello, esta manera no funcionará.
	</p><p>
	  Una segunda manera es añadir la definición Close() a FName1:
	</p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">close</span><span class="hl opt">() {</span> file<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">(); }</span>
</pre><p>
	  Esto funcionará si sólo existen unas cuantas funciones a las
	  que se desea hacer funcionar como una clase ifstream. En este
	  caso, solo una parte de la clase y la composición apropiada.
	</p><p>
	  Pero ¿qué ocurre si se quiere que todo funcione cómo la clase
	  deseada? A eso se le llama subtipos porque esta creando un
	  nuevo tipo desde uno ya existente y lo que se quiere es que el
	  nuevo tipo tenga la misma interfaz que el tipo existente
	  (además de otras funciones que se deseen añadir) para que se
	  pueda utilizar en cualquier lugar donde se utilizaba el tipo
	  existente. Aquí es dónde la herencia es esencial. Puede ver
	  que el subtipo resuelve perfectamente el problema anterior:
	</p><div class="example"><a id="idp7968520"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:FName2.cpp</span>
<span class="hl slc">// Subtyping solves the problem</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> FName2 <span class="hl opt">:</span> <span class="hl kwc">public</span> ifstream <span class="hl opt">{</span>
  string fileName<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> named<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">FName2</span><span class="hl opt">() :</span> <span class="hl kwd">named</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwd">FName2</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> fname<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">ifstream</span><span class="hl opt">(</span>fname<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">()),</span> <span class="hl kwd">fileName</span><span class="hl opt">(</span>fname<span class="hl opt">) {</span>
    <span class="hl kwd">assure</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">,</span> fileName<span class="hl opt">);</span>
    named <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  string <span class="hl kwd">name</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> fileName<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">name</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newName<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>named<span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span> <span class="hl slc">// Don't overwrite</span>
    fileName <span class="hl opt">=</span> newName<span class="hl opt">;</span>
    named <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  FName2 <span class="hl kwd">file</span><span class="hl opt">(</span><span class="hl str">&quot;FName2.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>file<span class="hl opt">,</span> <span class="hl str">&quot;FName2.cpp&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;name: &quot;</span> <span class="hl opt">&lt;&lt;</span> file<span class="hl opt">.</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  string s<span class="hl opt">;</span>
  <span class="hl kwd">getline</span><span class="hl opt">(</span>file<span class="hl opt">,</span> s<span class="hl opt">);</span> <span class="hl slc">// These work too!</span>
  file<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(-</span><span class="hl num">200</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>end<span class="hl opt">);</span>
  file<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.13. C14/FName2.cpp</strong></p></div><br class="example-break" /><p>
	  Ahora cualquier función que este disponible para el objeto
	  sfstream también esta disponible para el objeto
	  FName2. Asimismo se observan funciones no miembro como
	  getline() que esperan un objeto ifstream y que pueden
	  funcionar con un objeto FName2. Esto es porque FName2 es un
	  tipo de ifstream; esto no significa simplemente que lo
	  contiene. Esto es un tema muy importante que será explorado al
	  final de este capitulo y el siguiente.
	</p></div><div class="sect3" title="Herencia privada"><div class="titlepage"><div><div><h4 class="title"><a id="idp7971928"></a>Herencia privada</h4></div></div></div><p>
	  Puede heredar utilizando una clase base de forma privada
	  borrando public en la lista de la clase base o explícitamente
	  utilizando private (definitivamente la mejor política a tomar
	  pues indica al usuario lo que desea hacer). Cuando se hereda
	  de forma privada, esta "implementado en términos de", esto es,
	  se esta creando una nueva clase que tiene todos los datos y
	  funcionalidad de la clase base, pero la funcionalidad esta
	  oculta, solo una parte de capa de implementación. La clase
	  derivada no tiene acceso a la capa de funcionalidad y un
	  objeto no puede ser creado como instancia de la clase base
	  (como ocurrió en FName2.cpp).
	</p><p>
	  Se sorprenderá del propósito de la herencia privada, porque la
	  alternativa, usar la composición para crear un objeto privado
	  en la nueva clase parece más apropiada. La herencia privada
	  esta incluida para completar el lenguaje pero para reducir
	  confusión, normalmente se usará la composición en vez de la
	  herencia privada. Sin embargo, existen ocasiones donde se
	  desea el mismo interfaz como la clase base y anular
	  tratamiento del objeto. La herencia privada proporciona esta
	  habilidad.
	</p><div class="sect4" title="Publicar los miembros heredados de forma privada"><div class="titlepage"><div><div><h5 class="title"><a id="idp7974136"></a>Publicar los miembros heredados de forma privada</h5></div></div></div><p>
	    Cuando se hereda de forma privada, todos los miembros
	    públicos de la clase base llegan como privados. Si desea que
	    cualquiera de ellos sea visible, solo use sus nombres (sin
	    argumentos o valores de retorno) junto con la palabra clave
	    using en una sección pública de la clase derivada:
	  </p><div class="example"><a id="idp7975344"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:PrivateInheritance.cpp</span>
<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">char</span> <span class="hl kwd">eat</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">'a'</span><span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">2</span><span class="hl opt">; }</span>
  <span class="hl kwb">float</span> <span class="hl kwd">sleep</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">3.0</span><span class="hl opt">; }</span>
  <span class="hl kwb">float</span> <span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">4.0</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Goldfish <span class="hl opt">:</span> Pet <span class="hl opt">{</span> <span class="hl slc">// Private inheritance</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwa">using</span> Pet<span class="hl opt">::</span>eat<span class="hl opt">;</span> <span class="hl slc">// Name publicizes member</span>
  <span class="hl kwa">using</span> Pet<span class="hl opt">::</span>sleep<span class="hl opt">;</span> <span class="hl slc">// Both members exposed</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Goldfish bob<span class="hl opt">;</span>
  bob<span class="hl opt">.</span><span class="hl kwd">eat</span><span class="hl opt">();</span>
  bob<span class="hl opt">.</span><span class="hl kwd">sleep</span><span class="hl opt">();</span>
  bob<span class="hl opt">.</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl slc">//! bob.speak();// Error: private member function</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.14. C14/PrivateInheritance.cpp</strong></p></div><br class="example-break" /><p>
	    Así, la herencia privada es útil si desea esconder parte de
	    la funcionalidad de la clase base.
	  </p><p>
	    Fíjese que si expone el nombre de una función sobrecargada,
	    expone todas las versiones sobrecargadas de la función en la
	    clase base.
	  </p><p>
	    Debe pensar detenidamente antes de utilizar la herencia
	    privada en vez de la composición; la herencia privada tiene
	    complicaciones particulares cuando son combinadas con la
	    identificación de tipos en tiempo de ejecución (es un tema
	    de un capítulo en el volumen 2, disponible en
	    www.BruceEckel.com)
	  </p></div></div></div></div><div class="sect1" title="14.6. Protected"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7978816"></a>14.6. Protected</h2></div></div></div><p>
      Ahora que ya sabe que es la herencia, la palabra reservada
      protected ya tiene significado. En un mundo ideal, los miembros
      privados siempre serian fijos-y-rápidos, pero en los proyectos
      reales hay ocasiones cuando se desea ocultar algo a todo el mundo
      y todavía permitir accesos a los miembros de la clase derivada. La
      palabra clave protected es un movimiento al pragmatismo: este dice
      "Esto es privado como la clase usuario en cuestión, pero
      disponible para cualquiera que hereda de esta clase.
    </p><p>
      La mejor manera es dejar los miembros de datos privados - siempre
      debe preservar su derecho de cambiar la capa de
      implementación. Entonces puede permitir acceso controlado a los
      herederos de su clase a través de funciones miembro protegidas:
    </p><div class="example"><a id="idp7981048"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Protected.cpp</span>
<span class="hl slc">// The protected keyword</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">read</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) {</span> i <span class="hl opt">=</span> ii<span class="hl opt">; }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Base</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">value</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> m<span class="hl opt">*</span>i<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
  <span class="hl kwb">int</span> j<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Derived</span><span class="hl opt">(</span><span class="hl kwb">int</span> jj <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">j</span><span class="hl opt">(</span>jj<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">change</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwd">set</span><span class="hl opt">(</span>x<span class="hl opt">); }</span>
<span class="hl opt">};</span> 

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Derived d<span class="hl opt">;</span>
  d<span class="hl opt">.</span><span class="hl kwd">change</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.15. C14/Protected.cpp</strong></p></div><br class="example-break" /><p>
      Encontrará ejemplos de la necesidad de uso de protected más
      adelante y en el volumen 2.
    </p><div class="sect2" title="14.6.1. Herencia protegida"><div class="titlepage"><div><div><h3 class="title"><a id="idp7983384"></a>14.6.1. Herencia protegida</h3></div></div></div><p>
	Cuando se hereda, por defecto la clase base es privada, que
	significa que todos las funciones miembro publicas son privadas
	para el usuario en la nueva clase. Normalmente, heredará
	públicamente para que el interfaz de la clase base sea también
	el interfaz de la clase derivada. Sin embargo, puede usar la
	palabra clave protected durante la herencia.
      </p><p>
	Derivar de forma protegida significa "implementado en términos
	de" para otras clases pero "es-una" para las clases derivadas y
	amigas. Es algo que no utilizará muy a menudo, pero esta en el
	lenguaje para completarlo.
      </p></div></div><div class="sect1" title="14.7. Herencia y sobrecarga de operadores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7985456"></a>14.7. Herencia y sobrecarga de operadores</h2></div></div></div><p>
      Excepto el operador de asignación, el resto de operadores son
      heredados automáticamente en la clase derivada. Esto se puede
      demostrar heredando de C12:Byte.h:
    </p><div class="example"><a id="idp7986384"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:OperatorInheritance.cpp</span>
<span class="hl slc">// Inheriting overloaded operators</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../C12/Byte.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;ByteTest.out&quot;</span><span class="hl opt">);</span>

<span class="hl kwc">class</span> Byte2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Byte <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Constructors don't inherit:</span>
  <span class="hl kwd">Byte2</span><span class="hl opt">(</span><span class="hl kwb">unsigned char</span> bb <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">Byte</span><span class="hl opt">(</span>bb<span class="hl opt">) {}</span>  
  <span class="hl slc">// operator= does not inherit, but </span>
  <span class="hl slc">// is synthesized for memberwise assignment.</span>
  <span class="hl slc">// However, only the SameType = SameType</span>
  <span class="hl slc">// operator= is synthesized, so you have to</span>
  <span class="hl slc">// make the others explicitly:</span>
  Byte2<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Byte<span class="hl opt">&amp;</span> right<span class="hl opt">) {</span>
    Byte<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">=(</span>right<span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Byte2<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span> 
    Byte<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">=(</span>i<span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Similar test function as in C12:ByteTest.cpp:</span>
<span class="hl kwb">void</span> <span class="hl kwd">k</span><span class="hl opt">(</span>Byte2<span class="hl opt">&amp;</span> b1<span class="hl opt">,</span> Byte2<span class="hl opt">&amp;</span> b2<span class="hl opt">) {</span>
  b1 <span class="hl opt">=</span> b1 <span class="hl opt">*</span> b2 <span class="hl opt">+</span> b2 <span class="hl opt">%</span> b1<span class="hl opt">;</span>

  <span class="hl ppc">#define TRY2(OP) \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;b1 = &quot;</span><span class="hl ppc">; b1.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;, b2 = &quot;</span><span class="hl ppc">; b2.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;;  b1 &quot;</span><span class="hl ppc"> #OP</span> <span class="hl pps">&quot; b2 produces &quot;</span><span class="hl ppc">; \</span>
<span class="hl ppc">    (b1 OP b2).print(out); \</span>
<span class="hl ppc">    out &lt;&lt; endl;</span>

  b1 <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span> b2 <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(+)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(-)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(*)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(/)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(%)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(</span>^<span class="hl opt">)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&amp;)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(|)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(&lt;&lt;)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&gt;&gt;)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(+=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(-=)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(*=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(/=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(%=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(</span>^<span class="hl opt">=)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(&amp;=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(|=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&gt;&gt;=)</span> <span class="hl kwd">TRY2</span><span class="hl opt">(&lt;&lt;=)</span>
  <span class="hl kwd">TRY2</span><span class="hl opt">(=)</span> <span class="hl slc">// Assignment operator</span>

  <span class="hl slc">// Conditionals:</span>
  <span class="hl ppc">#define TRYC2(OP) \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;b1 = &quot;</span><span class="hl ppc">; b1.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;, b2 = &quot;</span><span class="hl ppc">; b2.print(out); \</span>
<span class="hl ppc">    out &lt;&lt;</span> <span class="hl pps">&quot;;  b1 &quot;</span><span class="hl ppc"> #OP</span> <span class="hl pps">&quot; b2 produces &quot;</span><span class="hl ppc">; \</span>
<span class="hl ppc">    out &lt;&lt; (b1 OP b2); \</span>
<span class="hl ppc">    out &lt;&lt; endl;</span>

  b1 <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span> b2 <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl kwd">TRYC2</span><span class="hl opt">(&lt;)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(&gt;)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(==)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(!=)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(&lt;=)</span>
  <span class="hl kwd">TRYC2</span><span class="hl opt">(&gt;=)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(&amp;&amp;)</span> <span class="hl kwd">TRYC2</span><span class="hl opt">(||)</span>

  <span class="hl slc">// Chained assignment:</span>
  Byte2 b3 <span class="hl opt">=</span> <span class="hl num">92</span><span class="hl opt">;</span>
  b1 <span class="hl opt">=</span> b2 <span class="hl opt">=</span> b3<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;member functions:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Byte2 <span class="hl kwd">b1</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">),</span> <span class="hl kwd">b2</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">);</span>
  <span class="hl kwd">k</span><span class="hl opt">(</span>b1<span class="hl opt">,</span> b2<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.16. C14/OperatorInheritance.cpp</strong></p></div><br class="example-break" /><p>
      El código de prueba anterior es idéntico a C12:ByteTest.cpp
      excepto que Byte2 se usa en vez de Byte. De esta forma todos los
      operadores son verificados para trabajar con Byte2 a través de la
      herencia.
    </p><p>
      Cuando examina la clase Byte2, verá que se ha definido
      explícitamente el constructor y que solo se ha credo el operator=
      que asigna un Byte2 a Byte2; cualquier otro operador de asignación
      tendrá que se realizado por usted.
    </p></div><div class="sect1" title="14.8. Herencia múltiple"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7991328"></a>14.8. Herencia múltiple</h2></div></div></div><p>
      Si puede heredar de una clase, tendría sentido heredar de más de
      una clase a la vez. De hecho, puede hacerlo, pero si tiene sentido
      como parte del diseño es un tema que todavía se esta
      debatiendo. Una cosa en que generalmente se esta de acuerdo: debe
      evitar intentarlo hasta que haya programado bastante y comprenda
      el lenguaje en profundidad. Por ahora, probablemente no le importa
      cuando debe absolutamente utilizar la herencia múltiple y siempre
      puede utilizar la herencia simple
    </p><p>
      Inicialmente, la herencia múltiple parece bastante simple: se
      añade las clases en la lista de clases base durante la herencia
      separadas por comas. Sin embargo, la herencia múltiple introduce
      un número mayor de ambigüedades, y por eso, un capítulo del
      Volumen 2 hablará sobre el tema.
    </p></div><div class="sect1" title="14.9. Desarrollo incremental"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7993504"></a>14.9. Desarrollo incremental</h2></div></div></div><p>
      Una de las ventajas de la herencia y la composición es el soporte
      al desarrollo incremental permitiendo introducir nuevo código sin
      causar fallos en el ya existente. Si aparecen fallos, éstos son
      rectificados con nuevo código. Heredando de (o componiendo con)
      clases y funciones existentes y añadiendo miembros de datos y
      funciones miembros (y redefiniendo las funciones existentes
      durante la herencia) puede dejar el código existente - por otro
      que todavía se esta usando - que alguien todavía lo este
      utilizando. Si ocurre algún error, ahora sabe donde esta el nuevo
      código, y entonces podrá leerlo mas rápido y fácilmente que si lo
      hubiera modificado en el cuerpo del código existente.
    </p><p>
      Es sorprendente como las clases son limpiamente separadas. Incluso
      no es necesario añadir el código fuente con funciones miembros
      para reutilizar el código, solamente el fichero de cabecera
      describiendo la clase y el fichero objeto o el fichero de librería
      con las funciones miembros compiladas. (Esto es válido tanto para
      la herencia como para la composición.)
    </p><p>
      Esto es importante para hacer que el desarrollo sea un proceso
      incremental, como el aprendizaje de una persona. Puede hacer
      tantos análisis como desee pero todavía no sabrá todas las
      respuestas cuando configure un proyecto. Tendrá más éxito y un
      progresión inmediata - si su proyecto empieza a crecer como una
      criatura orgánica, evolutiva, parecerá mas bien que esa
      construyendo algo como un rascacielos de cristal [52]
    </p><p>
      Sin embargo la herencia es una técnica útil para la
      experimentación, en algún punto donde las cosas están
      estabilizadas, necesita echar un nuevo vistazo a la jerarquía de
      clases para colapsarla dentro de una estructura sensible
      [53]. Recuerde que, por encima de todo, la herencia significa
      expresar una relación que dice "Esta nueva clase es un tipo de
      esta vieja". Su programa no debe preocuparse de cómo mueve pedazos
      de bits por alrededor, en vez debe crear y manipular objetos de
      varios tipos para expresar un modelo en los términos dados para su
      problema.
    </p></div><div class="sect1" title="14.10. Upcasting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp7998760"></a>14.10. Upcasting</h2></div></div></div><p>
      Anteriormente en este capitulo, observo como un objeto de una
      clase que derivaba de ifstream tenia todas las características y
      conductas de un objeto ifstream. En FName2.cpp, cualquier función
      miembro de ifstream podría ser llamada por cualquier objeto
      FName2.
    </p><p>
      El aspecto más importante de la herencia no es proporcionar nuevas
      funciones miembro a la nueva clase. Es la relación expresada entre
      la nueva clase y la clase base. Esta relación puede ser resumida
      diciendo "La nueva clase es de un tipo de una clase existente".
    </p><p>
      Esta no es una descripción fantasiosa de explicar la herencia -
      esta directamente soportada por el compilador. Un ejemplo,
      considere una clase base llamada Instrument que representa
      instrumentos musicales y una clase derivada llamada Wind. Dado que
      la herencia significa que todas las funciones en la clase base
      están también disponibles en la clase derivada, cualquier mensaje
      que envié a la clase base puede ser también enviado desde la
      derivada. Entonces si la clase Instrument tiene una función
      miembro play(), también existirá en los instrumentos de Wind. Esto
      significa precisamente que un objeto Wind es un tipo de
      Instrument. El siguiente ejemplo muestra como el compilador
      soporta esta idea:
    </p><div class="example"><a id="idp8002528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:Instrument.cpp</span>
<span class="hl slc">// Inheritance &amp; upcasting</span>
<span class="hl kwb">enum</span> note <span class="hl opt">{</span> middleC<span class="hl opt">,</span> Csharp<span class="hl opt">,</span> Cflat <span class="hl opt">};</span> <span class="hl slc">// Etc.</span>

<span class="hl kwc">class</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Wind objects are Instruments</span>
<span class="hl slc">// because they have the same interface:</span>
<span class="hl kwc">class</span> Wind <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{};</span>

<span class="hl kwb">void</span> <span class="hl kwd">tune</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  i<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>middleC<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Wind flute<span class="hl opt">;</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flute<span class="hl opt">);</span> <span class="hl slc">// Upcasting</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.17. C14/Instrument.cpp</strong></p></div><br class="example-break" /><p>
      Lo interesante en este ejemplo es la función tune(), que acepta
      una referencia Instrument. Sin embargo, en main() la función
      tune() se llama utilizando una referencia a un objeto Wind. Dado
      que C++ es un muy peculiar sobre la comprobación de tipos, parece
      extraño que una función que acepta solo un tipo pueda aceptar otro
      tipo, al menos que sepa que un objeto Instrument es tambien un
      objeto Instrument.
    </p><div class="sect2" title="14.10.1. ¿Por qué «upcasting»?"><div class="titlepage"><div><div><h3 class="title"><a id="idp8005000"></a>14.10.1. ¿Por qué «upcasting»?</h3></div></div></div><p>
	La razón de este término es histórica y esta basada en la
	manera en que se dibuja la herencia: con la raíz en la parte
	superior de la pagina y hacia abajo (por supuesto que puede
	pintar su diagrama de cualquier modo que le sea útil). El
	diagrama para <code class="filename">Instrument.cpp</code> es:
      </p><div class="figure"><a id="idp8006640"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_15.png" align="middle" alt="Upcasting" /></div></div><p class="title"><strong>Figura 14.1. Upcasting</strong></p></div><br class="figure-break" /><p>
	El hecho de pasar de la clase derivada a la clase base, esto es,
	desplazarse hacia arriba en el diagrama de la herencia, es
	normalmente conocido como upcasting. Upcasting es siempre seguro
	porque se esta desplazando de un tipo desde un tipo mas
	especifico a otro tipo mas general. - únicamente puede ocurrir
	es que la interfaz de la clase pierda algunas funciones miembro,
	pero no ganarlas. Esto es porque el compilador permite el
	upcasting sin ninguna conversión explicita o notación especial.
      </p></div><div class="sect2" title="14.10.2. FIXME Upcasting y el constructor de copia"><div class="titlepage"><div><div><h3 class="title"><a id="idp8010352"></a>14.10.2. FIXME Upcasting y el constructor de copia</h3></div></div></div><p>
	Si permite que el compilador cree un constructor copia de una
	clase derivada, éste llamara automáticamente al constructor
	copia de la clase base, y entones ,a los constructores copia
	para todos los miembros objeto (o realizará una copia de bits en
	los tipos predefinidos) entonces conseguirá la conducta
	correcta:
      </p><div class="example"><a id="idp8011584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:CopyConstructor.cpp</span>
<span class="hl slc">// Correctly creating the copy-constructor</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Parent <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Parent</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Parent(int ii)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">Parent</span><span class="hl opt">(</span><span class="hl kwb">const</span> Parent<span class="hl opt">&amp;</span> b<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>b<span class="hl opt">.</span>i<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Parent(const Parent&amp;)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">Parent</span><span class="hl opt">() :</span> <span class="hl kwd">i</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Parent()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Parent<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Parent: &quot;</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Member <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Member</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Member(int ii)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">Member</span><span class="hl opt">(</span><span class="hl kwb">const</span> Member<span class="hl opt">&amp;</span> m<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>m<span class="hl opt">.</span>i<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Member(const Member&amp;)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Member<span class="hl opt">&amp;</span> m<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Member: &quot;</span> <span class="hl opt">&lt;&lt;</span> m<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Child <span class="hl opt">:</span> <span class="hl kwc">public</span> Parent <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  Member m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Child</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii<span class="hl opt">) :</span> <span class="hl kwd">Parent</span><span class="hl opt">(</span>ii<span class="hl opt">),</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span>ii<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Child(int ii)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Child<span class="hl opt">&amp;</span> c<span class="hl opt">){</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt; (</span>Parent<span class="hl opt">&amp;)</span>c <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>m
              <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Child: &quot;</span> <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Child <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;calling copy-constructor: &quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Child c2 <span class="hl opt">=</span> c<span class="hl opt">;</span> <span class="hl slc">// Calls copy-constructor</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;values in c2:</span><span class="hl esc">\n</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> c2<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.18. C14/CopyConstructor.cpp</strong></p></div><br class="example-break" /><p>
	El operador&lt;&lt; de Child es interesante por la forma en que llama
	al operador&lt;&lt; del padre dentro de éste: convirtiendo el objeto
	Child a Parent&amp; (si lo convierte a un objeto de la clase base en
	vez de una referencia, probablemente obtendrá resultados no
	deseados)
      </p><pre class="programlisting">
<span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt; (</span>Parent<span class="hl opt">&amp;)</span>c <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>m
</pre><p>
	Dado que el compilador lo ve como Parent, éste llama al
	operador&lt;&lt; Parent.
      </p><p>
	Puede observar que Child no tiene explícitamente definido un
	constructor copia. El compilador crea el constructor copia (es
	una de las cuatro funciones que sintetiza, junto con el
	constructor del defecto - si no creas a ninguna constructores -
	el operator= y el destructor) llamando el constructor copia de
	Parent y el constructor copia de Member. Esto muestra la
	siguiente salida
      </p><pre class="screen">
Parent(int ii)
Member(int ii)
Child(int ii)
calling copy-constructor:
Parent(const Parent&amp;)
Member(const Member&amp;)
values in c2:
Parent: 2
Member: 2
Child: 2
</pre><p>
	Sin embargo, si escribe su propio constructor copia para Child
	puede tener un error inocente y funcionar incorrectamente:
      </p><pre class="programlisting">
<span class="hl kwd">Child</span><span class="hl opt">(</span><span class="hl kwb">const</span> Child<span class="hl opt">&amp;</span> c<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>c<span class="hl opt">.</span>i<span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span>c<span class="hl opt">.</span>m<span class="hl opt">) {}</span>
</pre><p>
	entonces el constructor por defecto será llamado automáticamente
	por la clase base por parte de Child, aquí es dónde el
	compilador muestra un error cuando no tienen otra (recuerde que
	siempre algun constructor se ejecuta para cada objeto, sin
	importar si es un subobjeto de otra clase). La salida será
	entonces:
      </p><pre class="screen">
Parent(int ii)
Member(int ii)
Child(int ii)
calling copy-constructor:
Parent()
Member(const Member&amp;)
values in c2:
Parent: 0
Member: 2
Child: 2
</pre><p>
	Esto probablemente no es lo que espera, generalmente deseará que
	la parte de la clase base sea copiada del objeto existente al
	nuevo objeto como parte del constructor copia.
      </p><p>
	Para arreglar el problema debe recordar como funciona la llamada
	al constructor copia de la clase base (como el compilador lo
	hace) para que escriba su propio constructor copia. Este puede
	parecer un poco extraño a primera vista pero es otro ejemplo de
	upcasting.
      </p><pre class="programlisting">
<span class="hl kwd">Child</span><span class="hl opt">(</span><span class="hl kwb">const</span> Child<span class="hl opt">&amp;</span> c<span class="hl opt">)</span>
   <span class="hl opt">:</span> <span class="hl kwd">Parent</span><span class="hl opt">(</span>c<span class="hl opt">),</span> <span class="hl kwd">i</span><span class="hl opt">(</span>c<span class="hl opt">.</span>i<span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span>c<span class="hl opt">.</span>m<span class="hl opt">) {</span>
   cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Child(Child&amp;)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>
	La parte extraña es cómo el constructor copia es ejecutado:
	Parent(c). ¿Qué significa pasar un objeto Child al constructor
	padre?  Child hereda de Parent, entonces una referencia de Child
	es una referencia Parent. El constructor copia de la clase base
	convierte a una referencia de Child a una referencia de Parent y
	la utiliza en el construcción de la copia. Cuando escribe su
	propio constructor copia la mayoría de ocasiones deseará lo
	mismo.
      </p></div><div class="sect2" title="14.10.3. Composición vs. herencia FIXME (revisited)"><div class="titlepage"><div><div><h3 class="title"><a id="idp8021704"></a>14.10.3. Composición vs. herencia FIXME (revisited)</h3></div></div></div><p>
	Una de las maneras más claras de determinar cuando debe utilizar
	la composición o la herencia es preguntando cuando será
	necesaria la conversión desde su nueva clase. Anteriormente, en
	esta capitulo, la clase Stack fue especializada utilizando la
	herencia. Sin embargo, los cambios en StringStack serán
	utilizados son como contenedores de string y nunca serán
	convertidos, pero ello, es mucho mas apropiado utilizas la
	alternativa de la composición.
      </p><div class="example"><a id="idp8022968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C14:InheritStack2.cpp</span>
<span class="hl slc">// Composition vs. inheritance</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../C09/Stack4.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> StringStack <span class="hl opt">{</span>
  Stack stack<span class="hl opt">;</span> <span class="hl slc">// Embed instead of inherit</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>string<span class="hl opt">*</span> str<span class="hl opt">) {</span>
    stack<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span>str<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  string<span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl opt">(</span>string<span class="hl opt">*)</span>stack<span class="hl opt">.</span><span class="hl kwd">peek</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  string<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwa">return</span> <span class="hl opt">(</span>string<span class="hl opt">*)</span>stack<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;InheritStack2.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;InheritStack2.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  StringStack textlines<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  string<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>s <span class="hl opt">=</span> textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">()) !=</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl slc">// No cast!</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 14.19. C14/InheritStack2.cpp</strong></p></div><br class="example-break" /><p>
	El fichero es idéntico a InheritStack.cpp, excepto que un objeto
	Stack es alojado en StringStack y se utilizan las funciones
	miembros para llamarlo. No se consume tiempo o espacio porque el
	subobjeto tiene el mismo tamaño y todas las comprobaciones de
	tipos han ocurrido en tiempo de compilación.
      </p><p>
	Sin embargo, esto tiende a confusión, podría también utilizar la
	herencia privada para expresar "implementado en términos
	de". Esto también resolvería el problema de forma adecuada. Un
	punto importante es cuando la herencia múltiple puede ser
	garantizada. En este caso, si observa un diseño en que la
	composición pueda utilizarse en vez de la herencia, debe
	eliminar la necesidad de utilizar herencia múltiple.
      </p></div><div class="sect2" title="14.10.4. FIXME Upcasting de punteros y referencias"><div class="titlepage"><div><div><h3 class="title"><a id="idp8027192"></a>14.10.4. FIXME Upcasting de punteros y referencias</h3></div></div></div><p>
	En Instrument.cpp, la conversión ocurre durante la llamada a la
	función - un objeto Wind fuera de la función se toma como
	referencia y se convierte en una referencia Instrument dentro de
	la función. La conversión puede también ocurrir durante una
	asignación a un puntero o una referencia.
      </p><pre class="programlisting">
Wind w<span class="hl opt">;</span>
Instrument<span class="hl opt">*</span> ip <span class="hl opt">= &amp;</span>w<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
Instrument<span class="hl opt">&amp;</span> ir <span class="hl opt">=</span> w<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
</pre><p>
	Como en la llamada a la función, ninguno de estos casos requiere una
	conversión explicita.
      </p></div><div class="sect2" title="14.10.5. Una crisis"><div class="titlepage"><div><div><h3 class="title"><a id="idp8029408"></a>14.10.5. Una crisis</h3></div></div></div><p>
	Por supuesto, cualquier conversión pierde la información del tipo sobre
	el objeto. Si dice
      </p><pre class="programlisting">
Wind w<span class="hl opt">;</span>
Instrument<span class="hl opt">*</span> ip <span class="hl opt">= &amp;</span>w<span class="hl opt">;</span>
</pre><p>
	el compilador puede utilizar ip solo como un puntero a
	Instrumento y nada mas. Esto es, éste no puede conocer que ip
	realmente esta apuntando a un objeto Wind. Entonces cuando llame
	a la función miembro play() diciendo
      </p><pre class="programlisting">
ip<span class="hl opt">-&gt;</span><span class="hl kwd">play</span><span class="hl opt">(</span>middleC<span class="hl opt">);</span>
</pre><p>
	el compilador solo puede conocer que la llamada a play() es de
	un puntero a Instrument y llamara a la versión de la clase base
	Instrument::play() en vez de lo que debería hacer, que es llamar
	a Wind::play(). Así, no conseguirá una conducta adecuada.
      </p><p>
	esto es un problema importante; es resulto en el Capitulo 15,
	introducción al tercer pilar de la programación orientada a
	objetos: poliformismo (implementado en C++ con funciones
	virtuales).
      </p></div></div><div class="sect1" title="14.11. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8033168"></a>14.11. Resumen</h2></div></div></div><p>
      Herencia y composición le permiten crear nuevos tipos desde tipos
      existentes y ambos incluyen subobjetos de tipos existentes dentro
      del nuevo tipo. Sin embargo, normalmente, utilizara la composición
      para reutilizar tipos existentes como parte de la capa de
      implementación de un nuevo tipo y la herencia cuando desea forzar
      al nuevo tipo a ser del mismo tipo que la clase base (la
      equivalencia de tipos garantiza la equivalencia de la
      interfaz). Como las clases derivadas tienen el interfaz de la
      clase base, esta puede ser convertidas a la base, lo cual es
      crítico para el poliformismo como verá el Capítulo 15.
    </p><p>
      Aunque la reutilización de código a través de la composición y la
      herencia es muy útil para el desarrollo rápido de proyectos,
      generalmente deseara rediseñar su jerarquía de clases antes de
      permitir a otros programadores dependan de ella. Su objetivo es
      crear una jerarquía en que cada clase tenga un uso especifico y
      sin ser demasiado grande (esforzándose más en la funcionalidad que
      en la dificultad de la reutilización...), ni pequeña, (no se podrá
      usar por si mismo o sin añadir funcionalidad).
    </p></div><div class="sect1" title="14.12. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8036048"></a>14.12. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Modificar Car.cpp para que herede desde una clase llamada
	  Vehicle, colocando correctamente las funciones miembro en
	  Vehicle (esto es, añadir algunas funciones miembro). Añada un
	  constructor (no el de por defecto) a Vehicle, que debe ser
	  llamado desde dentro del constructor Car
	</p></li><li class="listitem"><p>
	  Crear dos clases, A y B, con constructor por defectos
	  notificándose ellos mismos. Una nueva clase llamada C que
	  hereda de A, y cree un objeto miembro B dentro de C, pero no
	  cree un constructor para C. Cree un objeto de la clase C y
	  observe los resultados.
	</p></li><li class="listitem"><p>
	  Crear una jerarquía de clases de tres niveles con
	  constructores por defecto y con destructores, ambos
	  notificándose utilizando cout. Verificar que el objeto más
	  alto de la jerarquía, los tres constructores y destructores
	  son ejecutados automáticamente. Explicar el orden en que han
	  sido realizados.
	</p></li><li class="listitem"><p>
	  Modificar Combined.cpp para añadir otro nivel de herencia y un
	  nuevo objeto miembro. Añadir el código para mostrar cuando los
	  constructores y destructores son ejecutados.
	</p></li><li class="listitem"><p>
	  En Combined.cpp, crear una clase D que herede de B y que tenga
	  un objeto miembro de la clase C. Añadir el código para mostrar
	  cuando los constructores y los destructores son ejecutados.
	</p></li><li class="listitem"><p>
	  Modificar Order.cpp para añadir otro nivel de herencia
	  Derived3 con objetos miembro de la clase Member4 y
	  Member5. Compruebe la salida del programa.
	</p></li><li class="listitem"><p>
	  En NameHidding.cpp, verificar que Derived2, Derived3 y
	  Derived4, ninguna versión de la clase base de f() esta
	  disponible.
	</p></li><li class="listitem"><p>
	  Modificar NameHiding.cpp añadiendo tres funciones
	  sobrecargadas llamadas h() en Base y mostrar como redefiniendo
	  una de ellas en una clase derivada oculta las otras.
	</p></li><li class="listitem"><p>
	  Crear una clase StringVector que herede de vector&lt;void*&gt; y
	  redefinir push_back y el operador [] para aceptar y producir
	  string*. ¿Qué ocurre si intenta utilizar push_back() un void*?
	</p></li><li class="listitem"><p>
	  Escribir una clase que contenga muchos tipos y utilice una
	  llamada a una función pseudo-constructor que utiliza la misma
	  sintaxis de un constructor.Utilizarla en el constructor para
	  inicializar los tipos.
	</p></li><li class="listitem"><p>
	  Crear una clase llamada Asteroid. Utilizar la herencia para
	  especializar la clase PStash del capítulo 13 (PStash.h y
	  PStash.cpp) para que la acepte y retorne punteros a
	  Asteroid. También modifique PStashTest.cpp para comprobar sus
	  clases. Cambiar la clase para que PStash sea un objeto
	  miembro.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 11 con un vector en vez de la clase
	  PStash.
	</p></li><li class="listitem"><p>
	  En SynthesizedFunctions.cpp, modifique Chess para
	  proporcionarle un constructor por defecto, un constructor
	  copia y un operador de asignación. Demostrar que han sido
	  escritos correctamente.
	</p></li><li class="listitem"><p>
	  Crear dos clases llamadas Traveler y Pager sin constructores
	  por defecto, pero con constructores que toman un argumento del
	  tipo string, el cual simplemente lo copia a una variable
	  interna del tipo string. Para cada clase, escribir
	  correctamente un constructor copia y el operador de
	  asignación. Entonces cree la clase BusinessTraveler que hereda
	  de Traveler y crear ub objeto miembro Pager dentro
	  ella. Escribir correctamente el constructor por defecto, un
	  constructor que tome una cadena como argumento, un constructor
	  copia y un operador de asignación.
	</p></li><li class="listitem"><p>
	  Crear una clase con dos funciones miembro estáticas. Herede de
	  estas clases y redefina una de las funciones miembro. Mostrar
	  que la otra función se oculta en la clase derivada.
	</p></li><li class="listitem"><p>
	  Mejorar las funciones miembro de ifstream. En FName2.cpp,
	  intentar suprimirlas del objeto file.
	</p></li><li class="listitem"><p>
	  Utilice la herencia privada y protegida para crear dos nuevas
	  clases desde la clase base. Intente convertir los objetos de
	  las clases derivadas en la clase base. Explicar lo que ocurre.
	</p></li><li class="listitem"><p>
	  En Protected.cpp, añadir una función miembro en Derived que
	  llame al miembro protegido de Base read().
	</p></li><li class="listitem"><p>
	  Cambiar Protected.cpp para que Derived utilice herencia
	  protegida. Compruebe si puede llamar a value() desde un objeto
	  Derived.
	</p></li><li class="listitem"><p>
	  Crear una clase llamada SpaceShip con un metodo fly(). Crear
	  Shuttle que hereda de SpaceShip y añadir el metodo
	  land(). Creat un nuevo Shuttle, convertirlo por puntero o
	  referenciaa SpaceShip e intente llamar al metodo
	  land(). Explicar los resultados.
	</p></li><li class="listitem"><p>
	  Modificar Instrument.cpp para añadir un método prepare() a
	  Instrument. Llamar a prepare () dentro de tune().
	</p></li><li class="listitem"><p>
	  Modificar Instrument.cpp para que play() muestre un mensaje
	  con cout y que Wind redefina play() para que muestra un
	  mensaje diferente con cout. Ejecute el programa y explique
	  porque probamenteble no deseara esta conducta. Ahora ponga la
	  palabra reservada virtual (la cual aprenderá en el capitulo
	  15) delante de de la declaración de play en Instrument y
	  observe el cambio en el comportamiento.
	</p></li><li class="listitem"><p>
	  En CopyConstructor.cpp, herede una nueva clase de Child y
	  proporcionarle un miembro m. Escribir un constructor correcto,
	  un constructor copia, operator= y operator&lt;&lt; de ostreams y
	  comprobar la clase en main().
	</p></li><li class="listitem"><p>
	  Tomar como ejemplo CopyConstructor.cpp y modifíquelo añadiendo
	  su propio constructor copia a Child sin llamar el constructor
	  copia de clase base y comprobar que ocurre. Arregle el
	  problema añadiendo una llamada explicita al constructor copia
	  de la clase base en la lista de inicialización del constructor
	  del constructor copia de Child.
	</p></li><li class="listitem"><p>
	  Modificar InheritStack2.cpp para utilizar un vector&lt;string&gt;
	  en vez de Stack.
	</p></li><li class="listitem"><p>
	  Crear una clase Rock con un constructor por defecto, un
	  constructor copia y un operador de asignación y un destructor,
	  todos ellos mostrándose para saber que han sido ejecutados. En
	  main(), crear un vector&lt;Rock&gt; (esto es, tener objetos Rock
	  por valor) y añadir varios Rocks. Ejecutar el programa y
	  explicar los resultados obtenidos. Fijarse cuando los
	  destructores son llamados desde los objetos Rock en el
	  vector. Ahora repita el ejercicio con un vector&lt;Rock*&gt;. ¿Es
	  posible crear un vector&lt;Rock&amp;&gt;?
	</p></li><li class="listitem"><p>
	  En este ejercicio cree un patrón de diseño llamado
	  proxy. Comience con la clase base Subject y proporciónele tres
	  funciones: f(), g() y h(). Ahora herede una clase Proxy y dos
	  clases Implementation1 e Implementacion2 de Subject. Proxy
	  tendría que contener un puntero a un Suboject y todos los
	  miembros de Proxy (usualmente el constructor). En main(),
	  crear dos objetos Proxy diferentes que usen las dos
	  implementaciones diferentes. Modificar Proxy para que
	  dinámicamente cambie las implementaciones.
	</p></li><li class="listitem"><p>
	  Modificar ArrayOperatorNew del Capítulo 13 para mostrar que si
	  deriva de Widget, la reserva de memoria todavía funciona
	  correctamente. Explicar porque la herencia en Framis.cpp no
	  funcionaria correctamente.
	</p></li><li class="listitem"><p>
	  Modificar Framis.cpp del Capítulo 13 para que herede de Framis
	  y crear nuevas versiones de new y delete para su clase
	  derivada. Demostrar como todo ello funciona correctamente.
	</p></li></ol></div></div></div><div class="chapter" title="15: Polimorfismo y Funciones virtuales"><div class="titlepage"><div><div><h2 class="title"><a id="C15"></a>15: Polimorfismo y Funciones virtuales</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp8069376">15.1. Evolución de los programadores de C++</a></span></dt><dt><span class="sect1"><a href="#idp8075232">15.2. Upcasting</a></span></dt><dt><span class="sect1"><a href="#idp8085800">15.3. El problema</a></span></dt><dt><span class="sect1"><a href="#idp8094896">15.4. Funciones virtuales</a></span></dt><dt><span class="sect1"><a href="#idp8125576">15.5. Cómo implementa C++ la ligadura dinámica</a></span></dt><dt><span class="sect1"><a href="#idp8187008">15.6. ¿Por qué funciones virtuales?</a></span></dt><dt><span class="sect1"><a href="#idp8197152">15.7. Clases base abstractas y funciones virtuales puras</a></span></dt><dt><span class="sect1"><a href="#idp8224072">15.8. Herencia y la VTABLE</a></span></dt><dt><span class="sect1"><a href="#idp8267008">15.9. Sobrecargar y redefinir</a></span></dt><dt><span class="sect1"><a href="#idp8289328">15.10. funciones virtuales y constructores</a></span></dt><dt><span class="sect1"><a href="#idp8363912">15.11. Sobrecarga de operadores</a></span></dt><dt><span class="sect1"><a href="#idp8374520">15.12. Downcasting</a></span></dt><dt><span class="sect1"><a href="#idp8402424">15.13. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp8407888">15.14. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      El Polimorfismo (implementado en C++ con funciones
      <code class="keyword">virtual</code>es) es la tercera característica esencial de un
      lenguaje orientado a objetos, después de la abstracción de datos y
      la herencia.
    </p></div><p>
    De hecho, nos provee de otra dimensión para la separación entre
    interfaz y la implementación, desacoplando el <span class="emphasis"><em>qué</em></span>
    del <span class="emphasis"><em>cómo</em></span>. El Polimorfismo permite mejorar la
    organización del código y su legibilidad así como la creación de
    programas <span class="emphasis"><em>extensibles</em></span> que pueden "crecer" no sólo
    durante el desarrollo del proyecto, si no también cuando se deseen
    nuevas características.
  </p><p>
    La encapsulación crea nuevos tipos de datos combinando
    características y comportamientos. El control de acceso separa la
    interfaz de la implementación haciendo privados
    (<code class="keyword">private</code>) los detalles. Estos tipos de
    organización son fácilmente entendibles por cualquiera que venga de
    la programación procedimental. Pero las funciones virtuales tratan
    de desunir en términos de <span class="emphasis"><em>tipos</em></span>. En el Capítulo
    14, usted vió como la herencia permitía tratar a un objeto como su
    propio tipo <span class="emphasis"><em>o</em></span> como a su tipo base. Esta habilidad
    es básica debido a que permite a diferentes tipos (derivados del
    mismo tipo base) ser tratados como si fueran un único tipo, y un
    único trozo de código es capaz de trabajar indistintamente con
    todos. Las funciones virtuales permiten a un tipo expresar sus
    diferencias con respecto a otro similar si ambos han sido derivados
    del mismo tipo base. Esta distinción se consigue modificando las
    conductas de las funciones a las que se puede llamar a través de la
    clase base.
  </p><p>
    En este capítulo aprenderá sobre las funciones virtuales, empezando
    con ejemplos simples que le mostrará lo "desvirtual" del programa.
  </p><div class="sect1" title="15.1. Evolución de los programadores de C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8069376"></a>15.1. Evolución de los programadores de C++</h2></div></div></div><p>
      Los programadores de C parecen conseguir pasarse a C++ en tres
      pasos. Al principio, como un "C mejorado", debido a que C++ le
      fuerza a declarar todas las funciones antes de usarlas y a que es
      mucho más sensible a la forma de usar las variables. A menudo se
      pueden encontrar errores en un programa C simplemente
      recompilándolo con un compilador de C++.
    </p><p>
      El segundo paso es la "programación basada en objetos", que
      significa que se pueden ver fácilmente los beneficios de la
      organización del código al agrupar estructuras de datos junto con
      las funciones que las manejan, la potencia de los constructores y
      los destructores, y quizás algo de herencia simple. La mayoría de
      los programadores que han trabajado durante un tiempo con C ven la
      utilidad de esto porque es lo que intentan hacer cuando crean una
      librería. Con C++ usted recibe la ayuda del compilador.
    </p><p>
      Usted se puede encontrar atascado en el nivel de "programación
      basada en objetos" debido a que es de fácil acceso y no requiere
      mucho esfuerzo mental. Es también sencillo sentir cómo está
      creando tipos de datos - usted hace clases y objetos, envía
      mensajes a esos objetos, y todo es bonito y pulcro.
    </p><p>
      Pero no sea tonto. Si se para aquí, se está perdiendo una de las más
      importantes partes del lenguaje, que significa el salto a la
      verdadera programación orientada a objetos. Y esto se consigue
      únicamente con las funciones virtuales.
    </p><p>
      Las funciones virtuales realzan el concepto de tipo en lugar de
      simplemente encapsular código dentro de estructuras y dejarlo
      detrás de un muro, por lo que son, sin lugar a dudas, el concepto
      más difícil a desentrañar por los nuevos programadores en
      C++. Sin embargo, son también el punto decisivo para comprender la
      programación orientada a objetos. Si no usa funciones virtuales,
      todavía no entiende la POO.
    </p><p>
      Debido a que las funciones virtuales están intimamente unidas al
      concepto de tipo, y los tipos son el núcleo de la programación
      orientada a objetos, no existe analogía a las funciones virtuales
      dentro de los lenguajes procedurales. Como programador procedural,
      usted no tiene referente con el que comparar las funciones
      virtuales, al contrario de las otras características del
      lenguaje. Las características de un lenguaje procedural pueden ser
      entendidas en un nivel algorítmico, pero las funciones virtuales
      deben ser entendidas desde el punto de vista del diseño.
    </p></div><div class="sect1" title="15.2. Upcasting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8075232"></a>15.2. Upcasting</h2></div></div></div><p>
      En el Capítulo 14 se vió como un objeto puede ser usado como un
      objeto de su propio tipo o como un objeto de su tipo base. Además
      el objeto puede ser manejado a través de su tipo base. Tomar la
      dirección de un objeto (o un puntero o una referencia) y tratarlo
      como la dirección de su tipo base se conoce como
      <span class="foreignphrase"><em class="foreignphrase">upcasting</em></span>
	<sup>[<a id="idp8076544" href="#ftn.idp8076544" class="footnote">74</a>]</sup>
	debido al camino que se genera en los árboles de herencia que
	se suelen pintar con la clase base en la cima.
    </p><p>
      También se vió surgir un problema el cuál está encarnado en el
      siguiente código:
    </p><div class="example"><a id="idp8078952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:Instrument2.cpp</span>
<span class="hl slc">// Inheritance &amp; upcasting</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">enum</span> note <span class="hl opt">{</span> middleC<span class="hl opt">,</span> Csharp<span class="hl opt">,</span> Eflat <span class="hl opt">};</span> <span class="hl slc">// Etc.</span>

<span class="hl kwc">class</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Instrument::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Wind objects are Instruments</span>
<span class="hl slc">// because they have the same interface:</span>
<span class="hl kwc">class</span> Wind <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Redefine interface function:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Wind::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">tune</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  i<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>middleC<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Wind flute<span class="hl opt">;</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flute<span class="hl opt">);</span> <span class="hl slc">// Upcasting</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.1. C15/Instrument2.cpp</strong></p></div><br class="example-break" /><p>
      La función <code class="function">tune()</code> acepta (por referencia) un
      <code class="classname">Instrument</code>, pero también acepta cualquier
      cosa que derive de <code class="classname">Instrument</code>. En el
      <code class="function">main()</code>, se puede ver este comportamiento
      cuando se pasa un objeto <code class="classname">Wind</code> a
	<code class="function">afinar() </code> sin que se necesite ningún molde. La
      interfaz de <code class="classname">Instrument</code> tiene que existir en
      <code class="classname">Wind</code>, porque <code class="classname">Wind</code>
      hereda sus propiedades de <code class="classname">Instrument</code>. Moldear
      en sentido ascendente (<span class="foreignphrase"><em class="foreignphrase">Upcasting</em></span>) de
      <code class="classname">Wind</code> a <code class="classname">Instrument</code> puede
      "reducir" la interfaz, pero nunca puede ser menor que la interfaz
      de <code class="classname">Instrument</code>.
    </p><p>
      Los mismos argumentos son ciertos cuando trabajamos con punteros;
      la única diferencia es que el usuario debe indicar la dirección de
      los objtos de forma explícita cuando se pasen a una
      función.
    </p></div><div class="sect1" title="15.3. El problema"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8085800"></a>15.3. El problema</h2></div></div></div><p>
      El problema con <code class="filename">Instrument2.cpp</code> puede verse
      al ejecutar el programa. La salida es
      <code class="computeroutput">Instrument::play</code>. Claramente,
      esta no es la salida deseada, porque el objeto es actualmente un
      <code class="classname">Wind</code> y no solo un
      <code class="classname">Instrument</code>. La llamada debería producir un
      <code class="computeroutput">Wind::play</code>. Por este motivo,
      cualquier objeto de una clase que derive de la clase
      <code class="classname">Instrument </code> debería usar su propia versión
      de <code class="function">play()</code>, de acuerdo a la situación.
    </p><p>
      El comportamiento de <code class="filename">Instrument2.cpp</code> no es
      sorprendente dada la aproximación de C a las funciones. Para
      entender el resultado es necesario comprender el concepto de
      <span class="foreignphrase"><em class="foreignphrase">binding</em></span> (ligadura).
    </p><div class="sect2" title="15.3.1. Ligadura de las llamadas a funciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp8090056"></a>15.3.1. Ligadura de las llamadas a funciones</h3></div></div></div><p>
	Conectar una llamada a una función al cuerpo de la función se
	conoce como <span class="foreignphrase"><em class="foreignphrase">binding</em></span>
	(vincular). Cuando la vinculación se realiza antes de ejecutar
	el programa (por el compilador y el linker), se la conoce como
	<span class="foreignphrase"><em class="foreignphrase">early binding</em></span> (ligadura
	temprana). Puede no haber escuchado anteriormente este término
	debido a que no es posible con los lenguajes procedurales: los
	compiladores de C sólo admiten un tipo de vinculación que es la
	vinculación anticipada.
      </p><p>
	El problema en el programa anterior es causado por la
	vinculación anticipada porque el compilador no conoce la
	correcta función a la que debería llamar cuando sólo es una
	dirección de <code class="classname">Instrument</code>.
      </p><p>
	La solución se conoce como ligadura tardía (<span class="foreignphrase"><em class="foreignphrase">late
	binding</em></span>), que significa que la ligadura se
	produce en tiempo de ejecución basándose en el tipo de
	objeto. También es conocida como <span class="emphasis"><em>ligadura
	dinámica</em></span> o <span class="emphasis"><em>ligadura en tiempo de
	ejecución</em></span>. Cuando un lenguaje implementa la ligadura
	dinámica debe existir algún tipo de mecanismo para determinar el
	tipo del objeto en tiempo de ejecución y llamar a la función
	miembro apropiada. En el caso de un lenguaje compilado, el
	compilador todavía no conoce el tipo actual del objeto, pero
	inserta código que lo averigua y llama al cuerpo correcto de la
	función. El mecanismo de la ligadura dinámica varía de un
	lenguaje a otro, pero se puede imaginar que algún tipo de
	información debe ser introducida en los objetos. Se verá como
	trabaja posteriormente.
      </p></div></div><div class="sect1" title="15.4. Funciones virtuales"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8094896"></a>15.4. Funciones virtuales</h2></div></div></div><p>
      Para que la ligadura dinámica tenga efecto en una función
      particular, C++ necesita que se use la palabra reservada
      <code class="keyword">virtual</code> cuando se declara la función en la
      clase base. La ligadura en tiempo de ejecución funciona
      unícamente con las funciones <code class="keyword">virtual</code> es, y sólo
      cuando se está usando una dirección de la clase base donde exista
      la función <code class="keyword">virtual</code>, aunque puede ser definida
      también en una clase base anterior.
    </p><p>
      Para crear una función miembro como <code class="keyword">virtual</code>,
      simplemente hay que preceder a la declaración de la función con la
      palabra reservada <code class="keyword">virtual</code>. Sólo la declaración
      necesita la palabra reservada <code class="keyword">virtual</code>, y no la
      definición. Si una función es declarada como
      <code class="keyword">virtual</code>, en la clase base, será entonces
      <code class="keyword">virtual</code> en todas las clases derivadas. La
      redefinición de una función <code class="keyword">virtual</code> en una
      clase derivada se conoce como <span class="foreignphrase"><em class="foreignphrase">overriding</em></span>.
    </p><p>
      Hay que hacer notar que sólo es necesario declarar la función como
      <code class="keyword">virtual</code> en la clase base. Todas las funciones
      de las clases derivadas que encajen con la declaración que esté en
      la clase base serán llamadas usando el mecanismo virtual. Se
      <span class="emphasis"><em>puede</em></span> usar la palabra reservada
      <code class="keyword">virtual</code> en las declaraciones de las clases
      derivadas (no hace ningún mal), pero es redundante y puede causar
      confusión.
    </p><p>
      Para conseguir el comportamiento deseado de
      <code class="filename">Instrument2.cpp</code>, simplemente hay que añadir la
      palabra reservada <code class="keyword">virtual</code> en la clase base
      antes de <code class="function">play()</code>.
    </p><div class="example"><a id="idp8105816"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:Instrument3.cpp</span>
<span class="hl slc">// Late binding with the virtual keyword</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">enum</span> note <span class="hl opt">{</span> middleC<span class="hl opt">,</span> Csharp<span class="hl opt">,</span> Cflat <span class="hl opt">};</span> <span class="hl slc">// Etc.</span>

<span class="hl kwc">class</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Instrument::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Wind objects are Instruments</span>
<span class="hl slc">// because they have the same interface:</span>
<span class="hl kwc">class</span> Wind <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Override interface function:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Wind::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">tune</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  i<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>middleC<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Wind flute<span class="hl opt">;</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flute<span class="hl opt">);</span> <span class="hl slc">// Upcasting</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.2. C15/Instrument3.cpp</strong></p></div><br class="example-break" /><p>
      Este archivo es idéntico a <code class="filename">Instrument2.cpp</code>
      excepto por la adición de la palabra reservada
      <code class="keyword">virtual</code> y, sin embargo, el comportamiento es
      significativamente diferente: Ahora la salida es
      <code class="computeroutput">Wind::play</code>.
    </p><div class="sect2" title="15.4.1. Extensibilidad"><div class="titlepage"><div><div><h3 class="title"><a id="idp8109016"></a>15.4.1. Extensibilidad</h3></div></div></div><p>
	Con <code class="function">play()</code> definido como
	<code class="keyword">virtual</code> en la clase base, se pueden añadir
	tantos nuevos tipos como se quiera sin cambiar la función
	<code class="function">play()</code>. En un programa orientado a objetos
	bien diseñado, la mayoría de las funciones seguirán el modelo de
	<code class="function">play()</code> y se comunicarán únicamente a través
	de la interfaz de la clase base. Las funciones que usen la
	interfaz de la clase base no necesitarán ser cambiadas para
	soportar a las nuevas clases.
      </p><p>
	Aquí está el ejemplo de los instrumentos con más funciones
	virtuales y un mayor número de nuevas clases, las cuales
	trabajan de manera correcta con la antigua (sin modificaciones)
	función <code class="function">play()</code>:
      </p><div class="example"><a id="idp8112904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:Instrument4.cpp</span>
<span class="hl slc">// Extensibility in OOP</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">enum</span> note <span class="hl opt">{</span> middleC<span class="hl opt">,</span> Csharp<span class="hl opt">,</span> Cflat <span class="hl opt">};</span> <span class="hl slc">// Etc.</span>

<span class="hl kwc">class</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Instrument::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl str">&quot;Instrument&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Assume this will modify the object:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Wind <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Wind::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Wind&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Percussion <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Percussion::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Percussion&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Stringed <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Stringed::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Stringed&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Brass <span class="hl opt">:</span> <span class="hl kwc">public</span> Wind <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Brass::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Brass&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Woodwind <span class="hl opt">:</span> <span class="hl kwc">public</span> Wind <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Woodwind::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Woodwind&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Identical function from before:</span>
<span class="hl kwb">void</span> <span class="hl kwd">tune</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  i<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>middleC<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// New function:</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span> i<span class="hl opt">.</span><span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">); }</span>

<span class="hl slc">// Upcasting during array initialization:</span>
Instrument<span class="hl opt">*</span> A<span class="hl opt">[] = {</span>
  <span class="hl kwa">new</span> Wind<span class="hl opt">,</span>
  <span class="hl kwa">new</span> Percussion<span class="hl opt">,</span>
  <span class="hl kwa">new</span> Stringed<span class="hl opt">,</span>
  <span class="hl kwa">new</span> Brass<span class="hl opt">,</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Wind flute<span class="hl opt">;</span>
  Percussion drum<span class="hl opt">;</span>
  Stringed violin<span class="hl opt">;</span>
  Brass flugelhorn<span class="hl opt">;</span>
  Woodwind recorder<span class="hl opt">;</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flute<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>drum<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>violin<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flugelhorn<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>recorder<span class="hl opt">);</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>flugelhorn<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.3. C15/Instrument4.cpp</strong></p></div><br class="example-break" /><p>
	Se puede ver que se ha añadido otro nivel de herencia debajo de
	<code class="classname">Wind</code>, pero el mecanismo
	<code class="keyword">virtual</code> funciona correctamente sin importar
	cuantos niveles haya. La función <code class="function">adjust()</code>
	<span class="emphasis"><em>no</em></span> está redefinida
	(<span class="foreignphrase"><em class="foreignphrase">override</em></span>) por
	<code class="classname">Brass</code> y
	<code class="classname">Woodwind</code>. Cuando esto ocurre, se usa la
	definición más "cercana" en la jerarquía de herencia - el
	compilador garantiza que exista <span class="emphasis"><em>alguna</em></span>
	definición para una función virtual, por lo que nunca acabará en
	una llamada que no esté enlazada con el cuerpo de una función
	(lo cual sería desatroso).
      </p><p>
	El array <code class="literal">A[]</code> contiene punteros a la clase
	base <code class="classname">Instrument</code>, lo que implica que
	durante el proceso de inicialización del array habrá
	<span class="foreignphrase"><em class="foreignphrase">upcasting</em></span>. Este array y la
	función <code class="function">f()</code> serán usados en posteriores
	discusiones.
      </p><p>
	En la llamada a <code class="function">tune()</code>, el
	<span class="foreignphrase"><em class="foreignphrase">upcasting</em></span> se realiza en cada tipo
	de objeto, haciendo que se obtenga siempre el comportamiento
	deseado. Se puede describir como "enviar un mensaje a un objeto
	y dejar al objeto que se preocupe sobre qué hacer con él". La
	función <code class="keyword">virtual</code> es la lente a usar cuando
	se está analizando un proyecto: ¿Dónde deben estar las clases
	base y cómo se desea <span class="emphasis"><em>extender</em></span> el programa?
	Sin embargo, incluso si no se descubre la interfaz apropiada
	para la clase base y las funciones virtuales durante la creación
	del programa, a menudo se descubrirán más tarde, incluso mucho
	más tarde cuando se desee ampliar o se vaya a hacer funciones de
	mantenimiento en el programa. Esto no implica un error de
	análisis o de diseño; simplemente significa que no se conocía o
	no se podía conocer toda la información al principio. Debido a
	la fuerte modularización de C++, no es mucho problema que esto
	suceda porque los cambios que se hagan en una parte del sistema
	no tienden a propagarse a otras partes como sucede en C.
      </p></div></div><div class="sect1" title="15.5. Cómo implementa C++ la ligadura dinámica"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8125576"></a>15.5. Cómo implementa C++ la ligadura dinámica</h2></div></div></div><p>
      ¿Cómo funciona la ligadura dinámica? Todo el trabajo se realiza
      detrás del telón gracias al compilador, que instala los mecanismos
      necesarios de la ligadura dinámica cuando se crean funciones
      virtuales. Debido a que los programadores se suelen beneficiar de
      la comprensión del mecanismo de las funciones virtuales en C++,
      esta sección mostrará la forma en que el compilador implementa
      este mecanismo.
    </p><p>
      La palabra reservada <code class="keyword">virtual</code> le dice al
      compilador que no debe realizar ligadura estática. Al
      contrario, debe instalar automáticamente todos los mecanismos
      necesarios para realizar la ligadura dinámica. Esto significa
      que si se llama a <code class="function">play()</code> para un objeto
      <code class="classname">Brass</code> a <span class="emphasis"><em>través una dirección a la
      clase base</em></span> <code class="classname">Instrument</code>, se usará la
      función apropiada.
    </p><p>
	Para que funcione, el compilador típico
	<sup>[<a id="idp8129400" href="#ftn.idp8129400" class="footnote">75</a>]</sup>
	crea una única tabla (llamada VTABLE) por cada clase que
      contenga funciones <code class="literal">virtuales</code>. El compilador
      coloca las direcciones de las funciones virtuales de esa clase en
      concreto en la VTABLE. En cada clase con funciones virtuales el
      compilador coloca de forma secreta un puntero llamado
      <code class="literal">vpointer</code> (de forma abreviada VPTR), que apunta
      a la VTABLE de ese objeto. Cuando se hace una llamada a una
      función virtual a través de un puntero a la clase base (es decir,
      cuando se hace una llamada usando el polimorfismo), el compilador
      silenciosamente añade código para buscar el VPTR y así conseguir
      la dirección de la función en la VTABLE, con lo que se llama a la
      función correcta y tiene lugar la ligadura dinámica.
    </p><p>
      Todo esto - establecer la VTABLE para cada clase, inicializar el
      VPTR, insertar código para la llamada a la función virtual -
      sucede automáticamente sin que haya que preocuparse por ello. Con
      las funciones virtuales, se llama a la función apropiada de un
      objeto, incluso aunque el compilador no sepa el tipo exacto del
      objeto.
    </p><div class="sect2" title="15.5.1. Almacenando información de tipo"><div class="titlepage"><div><div><h3 class="title"><a id="idp8133056"></a>15.5.1. Almacenando información de tipo</h3></div></div></div><p>
	Se puede ver que no hay almacenada información de tipo de forma
	explícita en ninguna de las clases. Pero los ejemplos
	anteriores, y la simple lógica, dicen que debe existir algún
	tipo de información almacenada en los objetos; de otra forma el
	tipo no podría ser establecido en tiempo de ejecución. Es
	verdad, pero la información de tipo está oculta. Para verlo,
	aquí está un ejemplo que muestra el tamaño de las clases que
	usan funciones virtuales comparadas con aquellas que no las
	usan:
      </p><div class="example"><a id="idp8134344"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:Sizes.cpp</span>
<span class="hl slc">// Object sizes with/without virtual functions</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> NoVirtual <span class="hl opt">{</span>
  <span class="hl kwb">int</span> a<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">x</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">i</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> OneVirtual <span class="hl opt">{</span>
  <span class="hl kwb">int</span> a<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">x</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">i</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> TwoVirtuals <span class="hl opt">{</span>
  <span class="hl kwb">int</span> a<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">x</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">int</span> <span class="hl kwd">i</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;int: &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;NoVirtual: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>NoVirtual<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;void* : &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;OneVirtual: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>OneVirtual<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;TwoVirtuals: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>TwoVirtuals<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.4. C15/Sizes.cpp</strong></p></div><br class="example-break" /><p>
	Sin funciones virtuales el tamaño del objeto es exactamente el
	que se espera: el tamaño de un único
	<sup>[<a id="idp8136600" href="#ftn.idp8136600" class="footnote">76</a>]</sup> <code class="type">int</code>.  Con una única función
	virtual en <code class="classname">OneVirtual</code>, el tamaño del
	objeto es el tamaño de <code class="classname">NoVirtual</code> más el
	tamaño de un puntero a <code class="type">void</code>. Lo que implica
	que el compilador añade un único puntero (el VPTR) en la
	estructura si se tienen una <span class="emphasis"><em>o más</em></span> funciones
	virtuales. No hay diferencia de tamaño entre
	<code class="classname">OneVirtual</code> y
	<code class="classname">TwoVirtuals</code>. Esto es porque el VPTR
	apunta a una tabla con direcciones de funciones. Se necesita
	sólo una tabla porque todas las direcciones de las funciones
	virtuales están contenidas en esta tabla.
      </p><p>
	Este ejemplo requiere como mínimo un miembro de datos. Si no
	hubiera miembros de datos, el compilador de C++ hubiera forzado
	a los objetos a ser de tamaño no nulo porque cada objeto debe
	tener direcciones distintas (¿se imagina cómo indexar un array
	de objetos de tamaño nulo?). Por esto se inserta en el objeto un
	miembro "falso" ya que de otra forma tendríá un tamaño
	nulo. Cuando se inserta la información de tipo gracias a la
	palabra reservada <code class="keyword">virtual</code>, ésta ocupa el
	lugar del miembro "falso". Intente comentar el <code class="literal">int
	a</code> en todas las clases del ejemplo anterior para
	comprobarlo.
      </p></div><div class="sect2" title="15.5.2. Pintar funciones virtuales"><div class="titlepage"><div><div><h3 class="title"><a id="idp8141664"></a>15.5.2. Pintar funciones virtuales</h3></div></div></div><p>
	Para entender exactamente qué está pasando cuando se usan
	funciones virtuales, es útil ver la actividad que hay detrás del
	telón. Aquí se muestra el array de punteros
	<code class="literal">A[]</code> in <code class="filename">Instrument4.cpp</code>:
      </p><div class="figure"><a id="idp8143288"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_16.png" align="middle" alt="Funciones virtuales" /></div></div><p class="title"><strong>Figura 15.1. Funciones virtuales</strong></p></div><br class="figure-break" /><p>
	El array de punteros a <code class="classname">Instrument</code>s no
	tiene información específica de tipo; cada uno de ellos apunta a
	un objeto de tipo
	<code class="classname">Instrument</code>. <code class="classname">Wind</code>,
	<code class="classname">Percussion</code>,
	<code class="classname">Stringed</code>, y <code class="classname">Brass</code>
	encajan en esta categoría porque derivan de
	<code class="classname">Instrument</code> (esto hace que tengan la misma
	interfaz de <code class="classname">Instrument</code>, y puedan
	responder a los mismos mensajes), lo que implica que sus
	direcciones pueden ser metidas en el array. Sin embargo, el
	compilador no sabe que sean otra cosa que objetos de tipo
	<code class="classname">Instrument</code>, por lo que normalmente
	llamará a las versiones de las funciones que estén en la clase
	base. Pero en este caso, todas las funciones han sido declaradas
	con la palabra reservada <code class="keyword">virtual</code>, por lo que
	ocurre algo diferente. Cada vez que se crea una clase que
	contiene funciones virtuales, o se deriva de una clase que
	contiene funciones virtuales, el compilador crea para cada clase
	una única VTABLE, que se puede ver a la derecha en el
	diagrama. En ésta tabla se colocan las direcciones de todas las
	funciones que son declaradas virtuales en la clase o en la clase
	base. Si no se sobreescribe una función que ha sido declarada
	como virtual, el compilador usa la dirección de la versión que
	se encuentra en la clase base (esto se puede ver en la entrada
	<code class="literal">adjusta</code> de la VTABLE de
	<code class="classname">Brass</code>). Además, se coloca el VPTR
	(descubierto en <code class="filename">Sizes.cpp</code>) en la clase. Hay
	un único VPTR por cada objeto cuando se usa herencia simple como
	es el caso. El VPTR debe estar inicializado para que apunte a la
	dirección inicial de la VTABLE apropiada (esto sucede en el
	constructor que se verá más tarde con mayor detalle).
      </p><p>
	Una vez que el VPTR ha sido inicializado a la VTABLE apropiada,
	el objeto "sabe" de que tipo es. Pero este autoconocimiento no
	tiene valor a menos que sea usado en el momento en que se llama
	a la función virtual.
      </p><p>
	Cuando se llama a una función virtual a través de la clase base
	(la situación que se da cuando el compilador no tiene toda la
	información necesaria para realizar la ligadura estática),
	ocurre algo especial. En vez de realizarse la típica llamada a
	función, que en lenguaje ensamblador es simplemente un
	<code class="literal">CALL</code> a una dirección en concreto, el
	compilador genera código diferente para ejecutar la llamada a la
	función. Aquí se muestra a lo que se parece una llamada a
	<code class="function">adjust()</code> para un objeto
	<code class="function">Brass</code>, si se hace a través de un puntero a
	<code class="classname">Instrument</code> (una referencia a
	<code class="classname">Instrument</code> produce el mismo efecto):
      </p><div class="figure"><a id="idp8155288"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_17.png" align="middle" alt="Tabla de punteros virtuales" /></div></div><p class="title"><strong>Figura 15.2. Tabla de punteros virtuales</strong></p></div><br class="figure-break" /><p>
	El compilador empieza con el puntero a
	<code class="classname">Instrument</code>, que apunta a la dirección
	inicial del objeto. Todos los objetos
	<code class="classname">Instrument</code> o los objetos derivados de
	<code class="classname">Instrument</code> tienen su VPTR en el mismo
	lugar (a menudo al principio del objeto), de tal forma que el
	compilador puede conseguir el VPTR del objeto. El VPTR apunta a
	la la dirección inicial de VTABLE. Todas las direcciones de
	funciones de las VTABLE están dispuestas en el mismo orden, a
	pesar del tipo específico del
	objeto. <code class="function">play()</code> es el primero,
	<code class="function">what()</code> es el segundo y
	<code class="function">adjust()</code> es el tercero. El compilador sabe
	que a pesar del tipo específico del objeto, la función
	<code class="function">adjust()</code> se encuentra localizada en
	VPTR+2. Debido a esto, en vez de decir, "Llama a la función en
	la dirección absoluta <code class="function">Instrument::adjust()</code>
	(ligadura estática y acción equivocada), se genera código que
	dice "Llama a la función que se encuentre en VPTR+2". Como la
	búsqueda del VPTR y la determinación de la dirección de la
	función actual ocurre en tiempo de ejecución, se consigue la
	deseada ligadura dinámica. Se envía un mensaje al objeto, y el
	objeto se figura que debe hacer con él.
      </p></div><div class="sect2" title="15.5.3. Detrás del telón"><div class="titlepage"><div><div><h3 class="title"><a id="idp8162360"></a>15.5.3. Detrás del telón</h3></div></div></div><p>
	Puede ser útil ver el código ensamblador que se genera con la
	llamada a una función virtual, para poder ver como funciona la
	ligadura dinámica. Aquí está la salida de un compilador a la
	llamada
      </p><pre class="programlisting">
i<span class="hl opt">.</span><span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
</pre><p>
	dentro de la función <code class="literal">f(Instrument&amp; i)</code>:
      </p><pre class="programlisting">
push <span class="hl num">1</span>
push si
mov  bx<span class="hl opt">,</span> word ptr <span class="hl opt">[</span>si<span class="hl opt">]</span>
call word ptr <span class="hl opt">[</span>bx<span class="hl opt">+</span><span class="hl num">4</span><span class="hl opt">]</span>
add  sp<span class="hl opt">,</span> <span class="hl num">4</span>
</pre><p>
	Los argumentos de una llamada a una función C++, como los de a
	una función C, son colocados en la pila de derecha a izquierda
	(este orden es necesario para poder soportar las listas de
	argumentos variables de C), por lo que el argumento
	<code class="constant">1</code> se pone al principio en la pila. En este
	punto en la función, el registro <code class="varname">si</code> (que es
	parte de la arquitectura del procesador
	<span class="trademark">Intel</span>™ <span class="productname">X86</span>™)
	contiene la dirección de <code class="varname">i</code>. También se
	introduce en la pila porque es la dirección de comienzo del
	objeto de interés. Hay que recordar que la dirección del
	comienzo del objeto corresponde al valor de
	<code class="literal">this</code>, y <code class="literal">this</code> es
	introducido en la pila de manera oculta antes de cualquier
	llamada a función, por lo que la función miembro sabe sobre qué
	objeto en concreto está trabajando. Debido a esto se verá
	siempre uno más que el número de argumentos introducidos en la
	pila antes de una llamada a una función miembro (excepto para
	las funciones miembro <code class="keyword">static</code>, que no tienen
	<code class="literal">this</code>).
      </p><p>
	Ahora se puede ejecutar la llamada a la función virtual. Primero
	hay que producir el VPTR para poder encontrar la VTABLE. Para el
	compilador el VPTR se inserta al principio del objeto, por lo
	que el contenido de <code class="literal">this</code> corresponde al
	VPTR. La línea
      </p><pre class="programlisting">
mov bx<span class="hl opt">,</span> word ptr <span class="hl opt">[</span>si<span class="hl opt">]</span>
</pre><p>
	busca la dirección <span class="emphasis"><em>(word)</em></span> a la que apunta
	<code class="varname">si</code>, que es el VPTR y la coloca dentro del
	registro <code class="varname">bx</code>.
      </p><p>
	El VPTR contenido en <code class="varname">bx</code> apunta a la dirección
	inicial de la VTABLE, pero el puntero de la función a llamar no
	se encuentra en la posición cero de la VTABLE, si no en la
	segunda posición (debido a que es la tercera función en la
	lista). Debido al modelo de memoria cada puntero a función ocupa
	dos bytes, por lo que el compilador suma cuatro al VPTR para
	calcular donde está la dirección de la función apropiada. Hay
	que hacer notar que este es un valor constante establecido en
	tiempo de compilación, por lo que lo único que ocurre es que el
	puntero a función que está en la posición dos apunta a
	<code class="function">adjust()</code>. Afortunadamente, el compilador se
	encarga de todo y se asegura de que todos los punteros a
	funciones en todas las VTABLEs de una jerarquía particular se
	creen con el mismo orden, a pesar del orden en que se hayan
	sobreescrito las funciones en las clases derivadas.
      </p><p>
	Una vez se ha calculado en la VTABLE la dirección del puntero
	apropiado, se llama a la función a la que apunta el
	puntero. Esto es, se busca la dirección y se llama de una sola
	vez con la sentencia:
      </p><pre class="programlisting">
call word ptr <span class="hl opt">[</span>bx<span class="hl opt">+</span><span class="hl num">4</span><span class="hl opt">]</span>
</pre><p>
	Finalmente, se retrocede el puntero de la pila para limpiar los
	argumentos que se pusieron antes de la llamada. En código
	ensamblador de C y de C++ se ve a menudo la instrucción para
	limpiar la lista de argumentos pero puede variar dependiendo del
	procesador o de la implementación del compilador.
      </p></div><div class="sect2" title="15.5.4. Instalar el vpointer"><div class="titlepage"><div><div><h3 class="title"><a id="idp8175992"></a>15.5.4. Instalar el vpointer</h3></div></div></div><p>
	Debido a que el VPTR determina el comportamiento virtual de las
	funciones en un objeto, es crítico que el VPTR siempre esté
	apuntando a la VTABLE apropiada. No tendría sentido hacer una
	llamada a una función virtual antes de que esté inicializado
	apropiadamente a su correspondiente VTABLE. Por supuesto, el
	lugar donde se puede garantizar esta inicialización es en el
	constructor, pero ninguno de los ejemplos
	<code class="classname">Instrument</code> tiene constructor.
      </p><p>
	Aquí es donde la creación del constructor por defecto es
	esencial. En los ejemplos <code class="classname">Instrument</code>, el
	compilador crea un constructor por defecto que no hace nada más
	que inicializar el VPTR. Este constructor es, obviamente,
	llamado autormáticamente por todos los objetos
	<code class="classname">Instrument</code> antes de que se pueda hacer nada
	con ellos, lo que asegura el buen comportamiento con las
	llamadas a funciones virtuales.
      </p><p>
	Las implicaciones de la inicialización automática del VPTR
	dentro de un constructor se discute en un sección posterior.
      </p></div><div class="sect2" title="15.5.5. Los objetos son diferentes"><div class="titlepage"><div><div><h3 class="title"><a id="idp8179400"></a>15.5.5. Los objetos son diferentes</h3></div></div></div><p>
	Es importante darse cuenta de que el
	<span class="foreignphrase"><em class="foreignphrase">upcasting</em></span> sólo maneja
	direcciones. Si el compilador tiene un objeto, sabe su tipo
	concreto y además (en C++) no se usará la ligadura dinámica para
	ninguna de las llamadas a funciones - o como mínimo el
	compilador no <span class="emphasis"><em>necesitará</em></span> usar la ligadura
	dinámica. Por cuestiones de eficiencia, la mayoría de los
	compiladores usarán la ligadura estática cuando esten haciendo
	una llamada a una función virtual de un objeto porque saben su
	tipo concreto. Aquí hay un ejemplo:
      </p><div class="example"><a id="idp8181384"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:Early.cpp</span>
<span class="hl slc">// Early binding &amp; virtual functions</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  string <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Bark!&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Dog ralph<span class="hl opt">;</span>
  Pet<span class="hl opt">*</span> p1 <span class="hl opt">= &amp;</span>ralph<span class="hl opt">;</span>
  Pet<span class="hl opt">&amp;</span> p2 <span class="hl opt">=</span> ralph<span class="hl opt">;</span>
  Pet p3<span class="hl opt">;</span>
  <span class="hl slc">// Late binding for both:</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p1-&gt;speak() = &quot;</span> <span class="hl opt">&lt;&lt;</span> p1<span class="hl opt">-&gt;</span><span class="hl kwd">speak</span><span class="hl opt">() &lt;&lt;</span>endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p2.speak() = &quot;</span> <span class="hl opt">&lt;&lt;</span> p2<span class="hl opt">.</span><span class="hl kwd">speak</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Early binding (probably):</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p3.speak() = &quot;</span> <span class="hl opt">&lt;&lt;</span> p3<span class="hl opt">.</span><span class="hl kwd">speak</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.5. C15/Early.cpp</strong></p></div><br class="example-break" /><p>
	En <code class="literal">p1-&gt;speak()</code> y en
	<code class="literal">p2.speak()</code>, se usan direcciones, lo que
	significa que la información es incompleta:
	<code class="varname">p1</code> y <code class="varname">p2</code> pueden representar
	la dirección de una <code class="classname">Pet</code> o algo que
	derivee de una <code class="classname">Pet</code>, por lo que el debe
	ser usado el mecanismo virtual. Cuando se llama a
	<code class="literal">p3.speak</code> no existe ambigüedad. El compilador
	conoce el tipo exacto del objeto, lo que hace imposible que sea
	un objeto derivado de <code class="classname">Pet</code> - es
	<span class="emphasis"><em>exactamente</em></span> una
	<code class="classname">Pet</code>. Por esto, probablemente se use la
	ligadura estática. Sin embargo, si el compilador no quiere
	trabajar mucho, puede usar la ligadura dinámica y el
	comportamiento será el mismo.
      </p></div></div><div class="sect1" title="15.6. ¿Por qué funciones virtuales?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8187008"></a>15.6. ¿Por qué funciones virtuales?</h2></div></div></div><p>
      A estas alturas usted se puede hacer una pregunta: "Si esta
      técnica es tan importante, y si se ejecuta la función
      <span class="emphasis"><em>correcta</em></span> todo el tiempo, ¿por qué es una
      opción? ¿por qué es necesario conocerla?"
    </p><p>
      Es una buena pregunta, y la respuesta se debe a la filosofía
      fudamental de C++: "Debido a que no es tan eficiente". Se puede
      ver en el código en lenguaje ensamblador que se generan, en vez de
      un simple <code class="keyword">CALL</code> a una dirección absoluta, dos
      instrucciones ensamblador necesarias para preparar la llamada a
      función. Esto requiere más código y tiempo de ejecución.
    </p><p>
      Algunos lenguajes orientado a objetos han decidido que la
      aproximación a la ligadura dinámica es intrínseca a la
      programación orientada a objetos, que siempre debe tener lugar,
      que no puede ser opcional, y que el usuario no tiene por qué
      conocerlo. Esta es una decisión de diseño cuando se crea un
      lenguaje, y éste camino particular es adecuado para varios
      lenguajes<sup>[<a id="idp8190624" href="#ftn.idp8190624" class="footnote">77</a>]</sup>.
      Sin embargo, C++ tiene una tara por venir
      de C, donde la eficiencia es crítica. Después de todo, C fué
      creado para sustituir al lenguaje ensamblador para la
      implementación de un sistema operativo (haciendo a este sistema
      operativo - Unix - mucho más portable que sus antecesores). Y una
      de las principales razones para la invención de C++ fue hacer más
      eficientes a los programadores de C<sup>[<a id="idp8191976" href="#ftn.idp8191976" class="footnote">78</a>]</sup>. Y la primera pregunta cuando un programador de C se
      pasa a C++ es, "¿Cómo me afectará el cambio en velocidad y tamaño?
      Si la respuesta fuera, "Todo es magnífico excepto en las llamadas
      a funciones donde siempre tendrá un pequeña sobrecarga extra",
      mucha gente se hubiera aguantado con C antes que hacer el cambio a
      C++. Además las funciones inline no serían posibles, porque las
      funciones virtuales deben tener una dirección para meter en la
      VTABLE. Por lo tanto las funciones virtuales son opcionales,
      <span class="emphasis"><em>y</em></span> por defecto el lenguaje no es
      <code class="keyword">virtual</code>, porque es la configuración más
      eficiente. Stroustrup expuso que su línea de trabajo era, "Si no
      lo usa, no lo pague".
    </p><p>
      Además la palabra reservada <code class="keyword">virtual</code> permite
      afinar el rendimiento. Cuando se diseñan las clases, sin embargo,
      no hay que preocuparse por afinarlas. Si va a usar el
      polimorfismo, úselo en todos los sitios. Sólo es necesario buscar
      funciones que se puedan hacer no virtuales cuando se esté buscando
      modos de acelerar el código (y normalmente hay mucho más que ganar
      en otras áreas - una buena idea es intentar adivinar dónde se
      encuentran los cuellos de botella).
    </p><p>
      Como anécdota la evidencia sugiere que el tamaño y la velocidad de
      C++ sufren un impacto del 10 por ciento con respecto a C, y a
      menudo están mucho más cerca de ser parejos. Además otra razón es
      que se puede diseñar un programa en C++ más rápido y más pequeño
      que como sería en C.
    </p></div><div class="sect1" title="15.7. Clases base abstractas y funciones virtuales puras"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8197152"></a>15.7. Clases base abstractas y funciones virtuales puras</h2></div></div></div><p>
      A menudo en el diseño, se quiere la clase base para presentar
      <span class="emphasis"><em>sólo</em></span> una interfaz para sus clases
      derivadas. Esto es, se puede querer que nadie pueda crear un
      objeto de la clase base y que ésta sirva únicamente para hacer un
      <span class="foreignphrase"><em class="foreignphrase">upcast</em></span> hacia ella, y poder tener
      una interfaz. Se consigue haciendo a la clase
      <span class="foreignphrase"><em class="foreignphrase">abstract</em></span> (abstracta), poniendo como
      mínimo una <span class="emphasis"><em>función virtual pura</em></span>. Se puede
      reconocer a una función virtual pura porque usa la palabra
      reservada <code class="keyword">virtual</code> y es seguida por
      <code class="literal">=0</code>. Si alguien intenta hacer un objeto de una
      clase abstracta, el compilador lo impide. Esta es una utilidad que
      fuerza a un diseño en concreto.
    </p><p>
      Cuando se hereda una clase abstracta, hay que implementar todas
      las funciones virtuales, o la clase que hereda se convierte en una
      nueva clase abstracta. Crear una función virtual pura permite
      poner una fución miembro en una interfaz sin forzar a proveer un
      cuerpo con código sin significado para esa función miembro. Al
      mismo tiempo, una función virtual fuerza a las clases que la
      hereden a que implemente una definición para ellas.
    </p><p>
      En todos los ejemplos de los intrumentos, las funciones en la
      clase base <code class="classname">Instrument</code> eran siempre
      funciones «tontas». Si esas funciones hubieran sido
      llamadas algo iba mal. Esto es porque la intención de la clase
      <code class="classname">Instrument</code> es crear una interfaz común
      para todas las clases que deriven de ella.
    </p><div class="figure"><a id="idp8203224"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_18.png" align="middle" alt="Clase abstracta" /></div></div><p class="title"><strong>Figura 15.3. Clase abstracta</strong></p></div><br class="figure-break" /><p>
      La única razón para establecer una interfaz común es que después
      se pueda expresar de forma diferente en cada subtipo. Se crea una
      forma básica que tiene lo que está en común con todas las clases
      derivadas y nada más. Por esto, <code class="classname">Instrument</code> es
      un candidato perfecto para ser una clase abstracta. Se crea una
      clase abstracta sólo cuando se quiere manipular un conjunto de
      clases a través de una interfaz común, pero la interfaz común no
      necesita tener una implementación (o como mucho, no necesita una
      implementación completa).
    </p><p>
      Si se tiene un concepto como <code class="classname">Instrument</code> que
      funciona como clase abstracta, los objetos de esa clase casi nunca
      tendrán sentido. Es decir, <code class="classname">Instrument</code> sirve
      solamente para expresar la interfaz, y no una implementación
      particular, por lo que crear un objeto que sea únicamente un
      <code class="classname">Instrument</code> no tendrá sentido, y
      probablemente se quiera prevenir al usuario de hacerlo. Se puede
      solucionar haciendo que todas las funciones virtuales en
      <code class="classname">Instrument</code> muestren mensajes de error, pero
      retrasa la aparición de los errores al tiempo de ejecución lo que
      obligará a un testeo exhaustivo por parte del usuario. Es mucho
      más productivo cazar el problema en tiempo de compilación.
    </p><p>
      Aquí está la sintaxis usada para una función virtual pura:
    </p><pre class="programlisting">
<span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
</pre><p>
      Haciendo esto, se indica al compilador que reserve un hueco para
      una función en la VTABLE, pero que no ponga una dirección en ese
      hueco. Incluso aunque sólo una función en una clase sea declarada
      como virtual pura, la VTABLE estará incompleta.
    </p><p>
      Si la VTABLE de una clase está incompleta, ¿qué se supone que debe
      hacer el compilador cuando alguien intente crear un objeto de esa
      clase? No sería seguro crear un objeto de esa clase abstracta, por
      lo que se obtendría un error de parte del compilador. Dicho de
      otra forma, el compilador garantiza la pureza de una clase
      abstracta. Hacer clases abstractas asegura que el programador
      cliente no puede hacer mal uso de ellas.
    </p><p>
      Aquí tenemos <code class="filename">Instrument4.cpp</code> modificado para
      usar funciones virtuales puras. Debido a que la clase no tiene
      otra cosa que no sea funciones virtuales, se la llama
      <span class="emphasis"><em>clase abstracta pura</em></span>:
    </p><div class="example"><a id="idp8213064"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:Instrument5.cpp</span>
<span class="hl slc">// Pure abstract base classes</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">enum</span> note <span class="hl opt">{</span> middleC<span class="hl opt">,</span> Csharp<span class="hl opt">,</span> Cflat <span class="hl opt">};</span> <span class="hl slc">// Etc.</span>

<span class="hl kwc">class</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Pure virtual functions:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Assume this will modify the object:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>
<span class="hl slc">// Rest of the file is the same ...</span>

<span class="hl kwc">class</span> Wind <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Wind::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Wind&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Percussion <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Percussion::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Percussion&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Stringed <span class="hl opt">:</span> <span class="hl kwc">public</span> Instrument <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Stringed::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Stringed&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Brass <span class="hl opt">:</span> <span class="hl kwc">public</span> Wind <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Brass::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Brass&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Woodwind <span class="hl opt">:</span> <span class="hl kwc">public</span> Wind <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>note<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Woodwind::play&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Woodwind&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Identical function from before:</span>
<span class="hl kwb">void</span> <span class="hl kwd">tune</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  i<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>middleC<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// New function:</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>Instrument<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span> i<span class="hl opt">.</span><span class="hl kwd">adjust</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">); }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Wind flute<span class="hl opt">;</span>
  Percussion drum<span class="hl opt">;</span>
  Stringed violin<span class="hl opt">;</span>
  Brass flugelhorn<span class="hl opt">;</span>
  Woodwind recorder<span class="hl opt">;</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flute<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>drum<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>violin<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>flugelhorn<span class="hl opt">);</span>
  <span class="hl kwd">tune</span><span class="hl opt">(</span>recorder<span class="hl opt">);</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>flugelhorn<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.6. C15/Instrument5.cpp</strong></p></div><br class="example-break" /><p>
      Las funciones virtuales puras son útiles porque hacen explícita la
      abstracción de una clase e indican al usuario y al compilador cómo
      deben ser usadas.
    </p><p>
      Hay que hacer notar que las funciones virtuales puras previenen a
      una clase abstracta de ser pasadas a una función <span class="emphasis"><em>por
      valor</em></span>, lo que es una manera de prevenir el
      <span class="foreignphrase"><em class="foreignphrase">object slicing</em></span> (que será descrito
      de forma reducida). Convertir una clase en abstracta también
      permite garantizar que se use siempre un puntero o una referencia
      cuando se haga <span class="foreignphrase"><em class="foreignphrase">upcasting</em></span> a esa clase.
    </p><p>
      Sólo porque una función virtual pura impida a la VTABLE estar
      completa no implica que no se quiera crear cuerpos de función para
      alguna de las otras funciones. A menudo se querrá llamar a la
      versión de la función que esté en la clase base, incluso aunque
      ésta sea virtual. Es una buena idea poner siempre el código común
      tan cerca como sea posible de la raiz de la jerarquía. No sólo
      ahorra código, si no que permite fácilmente la propagación de
      cambios.
    </p><div class="sect2" title="15.7.1. Definiciones virtuales puras"><div class="titlepage"><div><div><h3 class="title"><a id="idp8219288"></a>15.7.1. Definiciones virtuales puras</h3></div></div></div><p>
	Es posible proveer una definición para una función virtual pura
	en la clase base. Todavía implica decirle al compilador que no
	permita crear objetos de esa clase base abstracta, y que las
	funciones virtuales puras deben ser definidas en las clases
	derivadas para poder crear objetos. Sin embargo, puede haber un
	trozo de código en común que se quiera llamar desde todas, o
	algunas de las clases derivadas en vez de estar duplicando
	código en todas las funciones.
      </p><p>
	Este es un ejemplo de definición de funciones virtuales.
      </p><div class="example"><a id="idp8220856"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:PureVirtualDefinitions.cpp</span>
<span class="hl slc">// Pure virtual base definitions</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">eat</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Inline pure virtual definitions illegal:</span>
  <span class="hl slc">//!  virtual void sleep() const = 0 {}</span>
<span class="hl opt">};</span>

<span class="hl slc">// OK, not defined inline</span>
<span class="hl kwb">void</span> Pet<span class="hl opt">::</span><span class="hl kwd">eat</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Pet::eat()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Pet<span class="hl opt">::</span><span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Pet::speak()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Use the common Pet code:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> Pet<span class="hl opt">::</span><span class="hl kwd">speak</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">eat</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> Pet<span class="hl opt">::</span><span class="hl kwd">eat</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Dog simba<span class="hl opt">;</span>  <span class="hl slc">// Richard's dog</span>
  simba<span class="hl opt">.</span><span class="hl kwd">speak</span><span class="hl opt">();</span>
  simba<span class="hl opt">.</span><span class="hl kwd">eat</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.7. C15/PureVirtualDefinitions.cpp</strong></p></div><br class="example-break" /><p>
	El hueco en la VTABLE de <code class="classname">Pet</code> todavía
	está vacío, pero tiene funciones a las que se puede llamar desde
	la clase derivada.
      </p><p>
	Otra ventaja de esta característica es que perimite cambiar de
	una función virtual corriente a una virtual pura sin destrozar
	el código existente (es una forma para localizar clases que no
	sobreescriban a esa función virtual).
      </p></div></div><div class="sect1" title="15.8. Herencia y la VTABLE"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8224072"></a>15.8. Herencia y la VTABLE</h2></div></div></div><p>
      Es fácil imaginar lo que sucede cuando hay herencia y se
      sobreescriben algunas de las funciones virtuales. El compilador
      crea una nueva VTABLE para la nueva clase, e inserta las nuevas
      direcciones de las funciones usando además las direcciones de las
      funciones de la clase base para aquellas funciones virtuales que
      no se hayan sobreescrito. De un modo u otro, para todos los
      objetos que se puedan crear (es decir, aquellos que no tengan
      funciones virtuales puras) existe un conjunto completo de
      direcciones de funciones en la VTABLE, por lo que será imposible
      hacer llamadas a una dirección que no esté en la VTABLE (lo cual
      sería desastroso).
    </p><p>
      Pero ¿qué ocurre cuando se hereda y añade una nueva función
      virtual en la clase derivada? Aquí hay un sencillo ejemplo:
    </p><div class="example"><a id="idp8226584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:AddingVirtuals.cpp</span>
<span class="hl slc">// Adding virtuals in derivation</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
  string pname<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Pet</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> petName<span class="hl opt">) :</span> <span class="hl kwd">pname</span><span class="hl opt">(</span>petName<span class="hl opt">) {}</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">name</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> pname<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
  string name<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> petName<span class="hl opt">) :</span> <span class="hl kwd">Pet</span><span class="hl opt">(</span>petName<span class="hl opt">) {}</span>
  <span class="hl slc">// New virtual function in the Dog class:</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">sit</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> Pet<span class="hl opt">::</span><span class="hl kwd">name</span><span class="hl opt">() +</span> <span class="hl str">&quot; sits&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  string <span class="hl kwd">speak</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl slc">// Override</span>
    <span class="hl kwa">return</span> Pet<span class="hl opt">::</span><span class="hl kwd">name</span><span class="hl opt">() +</span> <span class="hl str">&quot; says 'Bark!'&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Pet<span class="hl opt">*</span> p<span class="hl opt">[] = {</span><span class="hl kwa">new</span> <span class="hl kwd">Pet</span><span class="hl opt">(</span><span class="hl str">&quot;generic&quot;</span><span class="hl opt">),</span><span class="hl kwa">new</span> <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl str">&quot;bob&quot;</span><span class="hl opt">)};</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p[0]-&gt;speak() = &quot;</span>
       <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]-&gt;</span><span class="hl kwd">speak</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p[1]-&gt;speak() = &quot;</span>
       <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]-&gt;</span><span class="hl kwd">speak</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl slc">//! cout &lt;&lt; &quot;p[1]-&gt;sit() = &quot;</span>
<span class="hl slc">//!      &lt;&lt; p[1]-&gt;sit() &lt;&lt; endl; // Illegal</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.8. C15/AddingVirtuals.cpp</strong></p></div><br class="example-break" /><p>
      La clase <code class="classname">Pet</code> tiene dos funciones
      virtuales: <code class="function">speak()</code> y
      <code class="function">name()</code>. <code class="classname">Dog</code> añade una
      tercera función virtual llamada <code class="function">sit()</code>, y
      sobreescribe el significado de <code class="function">speak()</code>. Un
      diagrama ayuda a visualizar qué está ocurriendo. Se muestran las
      VTABLEs creadas por el compilador para <code class="classname">Pet</code>
      y <code class="classname">Dog</code>:
    </p><div class="figure"><a id="idp8231912"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_19.png" align="middle" alt="Una nueva función virtual" /></div></div><p class="title"><strong>Figura 15.4. Una nueva función virtual</strong></p></div><br class="figure-break" /><p>
      Hay que hacer notar, que el compilador mapea la dirección de
      <code class="function">speak()</code> en exactamente el mismo lugar tanto
      en la VTABLE de <code class="classname">Dog</code> como en la de
      <code class="classname">Pet</code>. De igual forma, si una clase
      <code class="classname">Pug</code> heredara de <code class="classname">Dog</code>,
      su versión de <code class="function">sit()</code> ocuparía su lugar en la
      VTABLE en la misma posición que en
      <code class="classname">Dog</code>. Esto es debido a que el compilador
      genera un código que usa un simple desplazamiento numérico en la
      VTABLE para seleccionar una función virtual, como se vio con el
      ejemplo en lenguaje ensamblador. Sin importar el subtipo en
      concreto del objeto, su VTABLE está colocada de la misma forma por
      lo que llamar a una función virtual se hará siempre del mismo
      modo.
    </p><p>
      En este caso, sin embargo, el compilador está trabajando sólo con
      un puntero a un objeto de la clase base. La clase base tiene
      únicamente las funciones <code class="function">speak()</code> y
      <code class="function">name()</code>, por lo que son a las únicas funciones
      a las que el compilador permitirá acceder. ¿Cómo es posible saber
      que se está trabajando con un objeto <code class="classname">Dog</code> si
      sólo hay un puntero a un objeto de la clase base? El puntero
      podría apuntar a algún otro tipo, que no tenga una función
      <code class="function">sit()</code>. En este punto, puede o no tener otra
      dirección a función en la VTABLE, pero en cualquiera de los casos,
      hacer una llamada a una función virtual de esa VTABLE no es lo que
      se desea hacer. De modo que el compilador hace su trabajo
      impidiendo hacer llamadas virtuales a funciones que sólo existen
      en las clases derivadas.
    </p><p>
      Hay algunos poco comunes casos en los cuales se sabe que el
      puntero actualmente apunta al objeto de una subclase
      específica. Si se quiere hacer una llamada a una función que sólo
      exista en esa subclase, entonces hay que hacer un molde
      (<span class="foreignphrase"><em class="foreignphrase">cast</em></span>) del puntero. Se puede quitar
      el mensaje de error producido por el anterior programa con:
    </p><pre class="programlisting">
<span class="hl opt">((</span>Dog <span class="hl opt">*)</span> p<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">])-&gt;</span><span class="hl kwd">sit</span><span class="hl opt">()</span>
</pre><p>
      Aquí, parece saberse que <code class="literal">p[1]</code> apunta a un
      objeto <code class="classname">Dog</code>, pero en general no se sabe. Si
      el problema consiste en averiguar el tipo exacto de todos los
      objetos, hay que volver a pensar porque posiblemente no se estén
      usando las funciones virtuales de forma apropiada. Sin embargo,
      hay algunas situaciones en las cuales el diseño funciona mejor (o
      no hay otra elección) si se conoce el tipo exacto de todos los
      objetos, por ejemplo aquellos incluidos en un contenedor
      genérico. Este es el problema de la <span class="foreignphrase"><em class="foreignphrase">run time type
      identification</em></span> o RTTI (identificación de tipos en
      tiempo de ejecución).
    </p><p>
      RTTI sirve para moldear un puntero de una clase base y "bajarlo" a
      un puntero de una clase derivada ("arriba" y "abajo", en inglés
      "up" y "down" respectivamente, se refieren al típico diagrama de
      clases, con la clase base arriba). Hacer el molde hacia arriba
      (<span class="foreignphrase"><em class="foreignphrase">upcast</em></span>) funciona de forma
      automática, sin coacciones, debido a que es completamente
      seguro. Hacer el molde en sentido descendente
      (<span class="foreignphrase"><em class="foreignphrase">downcast</em></span>) es inseguro porque no
      hay información en tiempo de compilación sobre los tipos actuales,
      por lo que hay que saber exactamente el tipo al que pertenece. Si
      se hace un molde al tipo equivocado habrá problemas.
    </p><p>
      RTTI se describe posteriormente en este capítulo, y el Volumen 2
      de este libro tiene un capítulo dedicado al tema.
    </p><div class="sect2" title="15.8.1. FIXME: Object slicing"><div class="titlepage"><div><div><h3 class="title"><a id="idp8246720"></a>15.8.1. FIXME: Object slicing</h3></div></div></div><p>
	Existe una gran diferencia entre pasar una dirección de un
	objeto a pasar el objeto por valor cuando se usa el
	polimorfismo. Todos los ejemplos que se han visto, y
	prácticamente todos los ejemplos que se verán, se pasan por
	referencia y no por valor. Esto se debe a que todas las
	direcciones tienen el mismo tamaño<sup>[<a id="idp8247856" href="#ftn.idp8247856" class="footnote">79</a>]</sup>, por lo que pasar
	la dirección de un tipo derivado (que normalmente será un objeto
	más grande) es lo mismo que pasar la dirección de un objeto del
	tipo base (que es normalmente más pequeño). Como se explicó
	anteriormente, éste es el objetivo cuando se usa el polimorfismo
	- el código que maneja un tipo base puede, también manejar
	objetos derivados de forma transparente
      </p><p>
	Si se hace un <span class="foreignphrase"><em class="foreignphrase">upcast</em></span> de un objeto
	en vez de usar un puntero o una referencia, pasará algo que
	puede resultar sorprendente: el objeto es "truncado", recortado,
	hasta que lo que quede sea un subobjeto que corresponda al tipo
	destino del molde. En el siguiente ejemplo se puede ver que
	ocurre cuando un objeto es truncado (<span class="foreignphrase"><em class="foreignphrase">object
	slicing</em></span>):
      </p><div class="example"><a id="idp8250624"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:ObjectSlicing.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
  string pname<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Pet</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> name<span class="hl opt">) :</span> <span class="hl kwd">pname</span><span class="hl opt">(</span>name<span class="hl opt">) {}</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">name</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> pname<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">description</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> <span class="hl str">&quot;This is &quot;</span> <span class="hl opt">+</span> pname<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
  string favoriteActivity<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Dog</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> name<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> activity<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">Pet</span><span class="hl opt">(</span>name<span class="hl opt">),</span> <span class="hl kwd">favoriteActivity</span><span class="hl opt">(</span>activity<span class="hl opt">) {}</span>
  string <span class="hl kwd">description</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> Pet<span class="hl opt">::</span><span class="hl kwd">name</span><span class="hl opt">() +</span> <span class="hl str">&quot; likes to &quot;</span> <span class="hl opt">+</span>
      favoriteActivity<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">describe</span><span class="hl opt">(</span>Pet p<span class="hl opt">) {</span> <span class="hl slc">// Slices the object</span>
  cout <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">.</span><span class="hl kwd">description</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Pet <span class="hl kwd">p</span><span class="hl opt">(</span><span class="hl str">&quot;Alfred&quot;</span><span class="hl opt">);</span>
  Dog <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl str">&quot;Fluffy&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;sleep&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">describe</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
  <span class="hl kwd">describe</span><span class="hl opt">(</span>d<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.9. C15/ObjectSlicing.cpp</strong></p></div><br class="example-break" /><p>
	La función <code class="function">describe()</code> recibe un objeto de
	tipo <code class="classname">Pet</code> <span class="emphasis"><em>por valor</em></span>.
	Después llama a la función virtual
	<code class="function">description()</code> del objeto
	<code class="classname">Pet</code>. En el <code class="function">main()</code>,
	se puede esperar que la primera llamada produzca "This is
	Alfred", y que la segunda produzca "Fluffy likes to
	sleep". De hecho, ambas usan la versión
	<code class="function">description()</code> de la clase base.
      </p><p>
	En este programa están sucediendo dos cosas. Primero, debido a
	que <code class="function">describe()</code> acepta un objeto
	<code class="classname">Pet</code> (en vez de un puntero o una
	referencia), cualquier llamada a <code class="function">describe()</code>
	creará un objeto del tamaño de <code class="classname">Pet</code> que
	será puesto en la pila y posteriormente limpiado cuando acabe la
	llamada. Esto significa que si se pasa a
	<code class="function">describe()</code>un objeto de una clase heredada
	de <code class="classname">Pet</code>, el compilador lo acepta, pero
	copia únicamente el fragmento del objeto que corresponda a una
	<code class="classname">Pet</code>. Se deshecha el fragmento derivado
	del objeto:
      </p><div class="figure"><a id="idp8258272"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_20.png" align="middle" alt="Object slicing" /></div></div><p class="title"><strong>Figura 15.5. Object slicing</strong></p></div><br class="figure-break" /><p>
	Ahora queda la cuestión de la llamada a la función
	virtual. <code class="function">Dog::description()</code> hace uso de
	trozos de <code class="classname">Pet</code> (que todavía existe) y de
	<code class="classname">Dog</code>, ¡el cual no existe porque fue
	truncado!. Entonces, ¿Qué ocurre cuando se llama a la función
	virtual?
      </p><p>
	El desastre es evitado porque el objeto es pasado por
	valor. Debido a esto, el compilador conoce el tipo exacto del
	objeto porque el objeto derivado ha sido forzado a transformarse
	en un objeto de la clase base. Cuando se pasa por valor, se usa
	el constructor de copia del objeto <code class="classname">Pet</code>,
	que se encarga de inicializar el VPTR a la VTABLE de
	<code class="classname">Pet</code> y copia sólo las partes del objeto
	que correspondan a <code class="classname">Pet</code>. En el ejemplo no
	hay un constructor de copia explícito por lo que el compilador
	genera uno. Quitando interpretaciones, el objeto se convierte
	realmente en una <code class="classname">Pet</code> durante el
	truncado.
      </p><p>
	El <span class="foreignphrase"><em class="foreignphrase">Object Slicing</em></span> quita parte del
	objeto existente y se copia en un nuevo objeto, en vez de
	simplemente cambiar el significado de una dirección cuando se
	usa un puntero o una referencia. Debido a esto, el
	<span class="foreignphrase"><em class="foreignphrase">upcasting</em></span> a un objeto no se usa a
	menudo; de hecho, normalmente, es algo a controlar y
	prevenir. Hay que resaltar que en este ejemplo, si
	<code class="function">description()</code> fuera una función virtual
	pura en la clase base (lo cual es bastante razonable debido a
	que realmente no hace nada en la clase base), entonces el
	compilador impedirá el <span class="foreignphrase"><em class="foreignphrase">object
	slicing</em></span> debido a que no se puede "crear" un
	objeto de la clase base (que al fin y al cabo es lo que sucede
	cuando se hace un upcast por valor). ésto podría ser el valor
	más importante de las funciones virtuales puras: prevenir el
	<span class="foreignphrase"><em class="foreignphrase">object slicing</em></span> generando un error
	en tiempo de compilación si alguien lo intenta hacer.
      </p></div></div><div class="sect1" title="15.9. Sobrecargar y redefinir"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8267008"></a>15.9. Sobrecargar y redefinir</h2></div></div></div><p>
      En el capítulo 14 se vio que redefinir una función sobrecargada en
      la función base oculta todas las otras versiones de esa
      función. Cuando se involucra a las funciones virtuales el
      comportamiento es un poco diferente. Consideremos una versión
      modificada del ejemplo <code class="filename">NameHiding.cpp</code> del
      capítulo 14:
    </p><div class="example"><a id="idp8268584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:NameHiding2.cpp</span>
<span class="hl slc">// Virtual functions restrict overloading</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Base::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>string<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived1 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Overriding a virtual function:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived2::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived3 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Cannot change return type:</span>
  <span class="hl slc">//! void f() const{ cout &lt;&lt; &quot;Derived3::f()\n&quot;;}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived4 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Change argument list:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived4::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwa">return</span> <span class="hl num">4</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;hello&quot;</span><span class="hl opt">);</span>
  Derived1 d1<span class="hl opt">;</span>
  <span class="hl kwb">int</span> x <span class="hl opt">=</span> d1<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  d1<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  Derived2 d2<span class="hl opt">;</span>
  x <span class="hl opt">=</span> d2<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl slc">//!  d2.f(s); // string version hidden</span>
  Derived4 d4<span class="hl opt">;</span>
  x <span class="hl opt">=</span> d4<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl slc">//!  x = d4.f(); // f() version hidden</span>
<span class="hl slc">//!  d4.f(s); // string version hidden</span>
  Base<span class="hl opt">&amp;</span> br <span class="hl opt">=</span> d4<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
<span class="hl slc">//!  br.f(1); // Derived version unavailable</span>
  br<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Base version available</span>
  br<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span>s<span class="hl opt">);</span> <span class="hl slc">// Base version abailable</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.10. C15/NameHiding2.cpp</strong></p></div><br class="example-break" /><p>
      La primera cosa a resaltar es que en
      <code class="classname">Derived3</code>, el compilador no permitirá
      cambiar el tipo de retorno de una función sobreescrita (lo
      permitiría si <code class="function">f()</code> no fuera virtual). ésta es
      una restricción importante porque el compilador debe garantizar
      que se pueda llamar de forma "polimórfica" a la función a través
      de la clase base, y si la clase base está esperando que
      <code class="function">f()</code> devuelva un <code class="type">int</code>,
      entonces la versión de <code class="function">f()</code> de la clase
      derivada debe mantener ese compromiso o si no algo fallará.
    </p><p>
      La regla que se enseño en el capítulo 14 todavía funciona: si se
      sobreescribe una de las funciones miembro sobrecargadas de la
      clase base, las otras versiones sobrecargadas estarán ocultas en
      la clase derivada. En el <code class="function">main()</code> el código de
      <code class="classname">Derived4</code> muestra lo que ocurre incluso si la
      nueva versión de <code class="function">f()</code> no está actualmente
      sobreescribiendo una función virtual existente de la interfaz -
      ambas versiones de <code class="function">f()</code> en la clase base estan
      ocultas por <code class="function">f(int)</code>. Sin embargo, si se hace un
      upcast de <code class="varname">d4</code> a <code class="classname">Base</code>,
      entonces únicamente las versiones de la clase base estarán
      disponibles (porque es el compromiso de la clase base) y la
      versión de la clase derivada no está disponible (debido a que no
      está especificada en la clase base).
    </p><div class="sect2" title="15.9.1. Tipo de retorno variante"><div class="titlepage"><div><div><h3 class="title"><a id="idp8277112"></a>15.9.1. Tipo de retorno variante</h3></div></div></div><p>
	La clase <code class="classname">Derived3</code> de arriba viene a sugerir
	que no se puede modificar el tipo de retorno de una función
	virtual cuando es sobreescrita. En general es verdad, pero hay
	un caso especial en el que se puede modificar ligeramente el
	tipo de retorno. Si se está devolviendo un puntero o una
	referencia a una clase base, entonces la versión sobreescrita de
	la función puede devolver un puntero o una referencia a una
	clase derivada. Por ejemplo:
      </p><div class="example"><a id="idp8278656"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:VariantReturn.cpp</span>
<span class="hl slc">// Returning a pointer or reference to a derived</span>
<span class="hl slc">// type during ovverriding</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> PetFood <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">foodType</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">type</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> PetFood<span class="hl opt">*</span> <span class="hl kwd">eats</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bird <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  string <span class="hl kwd">type</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Bird&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwc">class</span> BirdFood <span class="hl opt">:</span> <span class="hl kwc">public</span> PetFood <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    string <span class="hl kwd">foodType</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
      <span class="hl kwa">return</span> <span class="hl str">&quot;Bird food&quot;</span><span class="hl opt">;</span> 
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  <span class="hl slc">// Upcast to base type:</span>
  PetFood<span class="hl opt">*</span> <span class="hl kwd">eats</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl opt">&amp;</span>bf<span class="hl opt">; }</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  BirdFood bf<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Cat <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  string <span class="hl kwd">type</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Cat&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwc">class</span> CatFood <span class="hl opt">:</span> <span class="hl kwc">public</span> PetFood <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    string <span class="hl kwd">foodType</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Birds&quot;</span><span class="hl opt">; }</span>
  <span class="hl opt">};</span>
  <span class="hl slc">// Return exact type instead:</span>
  CatFood<span class="hl opt">*</span> <span class="hl kwd">eats</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl opt">&amp;</span>cf<span class="hl opt">; }</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  CatFood cf<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bird b<span class="hl opt">;</span> 
  Cat c<span class="hl opt">;</span>
  Pet<span class="hl opt">*</span> p<span class="hl opt">[] = { &amp;</span>b<span class="hl opt">, &amp;</span>c<span class="hl opt">, };</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwa">sizeof</span> p <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>p<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">type</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">&quot; eats &quot;</span>
         <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">eats</span><span class="hl opt">()-&gt;</span><span class="hl kwd">foodType</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Can return the exact type:</span>
  Cat<span class="hl opt">::</span>CatFood<span class="hl opt">*</span> cf <span class="hl opt">=</span> c<span class="hl opt">.</span><span class="hl kwd">eats</span><span class="hl opt">();</span>
  Bird<span class="hl opt">::</span>BirdFood<span class="hl opt">*</span> bf<span class="hl opt">;</span>
  <span class="hl slc">// Cannot return the exact type:</span>
<span class="hl slc">//!  bf = b.eats();</span>
  <span class="hl slc">// Must downcast:</span>
  bf <span class="hl opt">=</span> <span class="hl kwa">dynamic_cast</span><span class="hl opt">&lt;</span>Bird<span class="hl opt">::</span>BirdFood<span class="hl opt">*&gt;(</span>b<span class="hl opt">.</span><span class="hl kwd">eats</span><span class="hl opt">());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.11. C15/VariantReturn.cpp</strong></p></div><br class="example-break" /><p>
	La función miembro <code class="function">Pet::eats()</code> devuelve un
	puntero a <code class="classname">PetFood</code>. En
	<code class="classname">Bird</code>, ésta función miembro es
	sobreescrita exactamente como en la clase base, incluyendo el
	tipo de retorno. Esto es, <code class="function">Bird::eats()</code> hace
	un <span class="foreignphrase"><em class="foreignphrase">&gt;upcast</em></span> de
	<code class="classname">BirdFood</code> a <code class="classname">PetFood</code>
	en el retorno de la función.
      </p><p>
	Pero en <code class="classname">Cat</code>, el tipo devuelto por
	<code class="function">eats()</code> es un puntero a
	<code class="classname">CatFood</code>, que es un tipo derivado de
	<code class="classname">PetFood</code>. El hecho de que el tipo de
	retorno esté heredado del tipo de retorno la función de la clase
	base es la única razón que hace que esto compile. De esta forma
	el acuerdo se cumple totalmente: <code class="function">eats()</code>
	siempre devuelve un puntero a <code class="classname">PetFood</code>.
      </p><p>
	Si se piensa de forma polimórfica lo anterior no parece
	necesario. ¿Por qué no simplemente se hacen upcast de todos los
	tipos retornados a <code class="type">PetFood*</code> como lo hace
	<code class="function">Bird::eats()</code>? Normalmente esa es una buena
	solución, pero al final del <code class="function">main()</code> se puede
	ver la diferencia: <code class="function">Cat::eats()</code> puede
	devolver el tipo exacto de <code class="classname">PetFood</code>,
	mientras que al valor retornado por
	<code class="function">Bird::eats()</code> hay que hacerle
	un <span class="foreignphrase"><em class="foreignphrase">downcast</em></span> al
	tipo exacto.
      </p><p>
	Devolver el tipo exacto es un poco más general y además no
	pierde la información específica de tipo debida al upcast
	automático. Sin embargo, devolver un tipo de la clase base
	generalmente resuelve el problema por lo que esto es una
	característica bastante específica.
      </p></div></div><div class="sect1" title="15.10. funciones virtuales y constructores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8289328"></a>15.10. funciones virtuales y constructores</h2></div></div></div><p>
      Cuando se crea un objeto que contiene funciones virtuales, su VPTR
      debe ser inicializado para apuntar a la correcta VTABLE. Esto debe
      ser hecho antes de que exista la oportunidad de llamar a una
      función virtual. Como se puede adivinar, debido a que el
      constructor tiene el trabajo de traer a la existencia al objeto,
      también será trabajo del constructor inicializar el VPTR. El
      compilador de forma secreta añade código al principio del
      constructor para inicializar el VPTR. Y como se describe en el
      capítulo 14, si no se crea un constructor de una clase de forma
      explícita, el compilador genera uno de forma automática. Si la
      clase tiene funciones virtuales, el constructor incluirá el código
      apropidado para la inicialización del VPTR. Esto tiene varias
      consecuencias.
    </p><p>
      La primera concierne a la eficiencia. La razón de que existan
      funciones <code class="keyword">inline</code> es reducir la sobrecarga que
      produce llamar a funciones pequeñas. Si C++ no proporciona
      funciones <code class="keyword">inline</code>, el preprocesador debe ser
      usado para crear estas "macros". Sin embargo, el preprocesador no
      tiene los conceptos de accesos o clases, y además no puede ser
      usado para crear macros con funciones miembro. Además, con los
      constructores que deben tener código oculto insertado por el
      compilador, una macro del preprocesador no funcionaría del todo.
    </p><p>
      Hay que estar precavidos cuando se estén buscando agujeros de
      eficiencia porque el compilador está insertando código oculto en
      los constructores. No sólo hay que inicializar el VPTR, también
      hay que comprobar el valor de <code class="literal">this</code> (en caso de
      que el operador <code class="keyword">new</code> devuelva cero), y llamar
      al constructor de la clase base. Todo junto, éste código puede
      tener cierto impacto cuando se pensaba que era una simple función
      <code class="keyword">inline</code>. En particular, el tamaño del
      constructor puede aplastar al ahorro que se consigue al reducir la
      sobrecarga en las llamadas. Si se hacen un monton de llamadas a
      constructores inline, el tamaño del código puede crecer sin ningún
      beneficio en la velocidad.
    </p><p>
      Cuando esté afinando el código recuerde considerar el quitar los
      constructores en línea.
    </p><div class="sect2" title="15.10.1. Orden de las llamadas a los constructores"><div class="titlepage"><div><div><h3 class="title"><a id="idp8296672"></a>15.10.1. Orden de las llamadas a los constructores</h3></div></div></div><p>
	La segunda faceta interesante de los constructores y las
	funciones virtuales tiene que ver con el orden de las llamadas a
	los constructores y el modo en que las llamadas virtuales se
	hacen dentro de los constructores.
      </p><p>
	Todos los constructores de la clase base son siempre llamados en
	el constructor de una clase heredada. Esto tiene sentido porque
	el constructor tiene un trabajo especial: ver que el objeto está
	construido de forma apropiada. Una clase derivada sólo tiene
	acceso a sus propios miembros, y no a los de la clase
	base. únicamente el constructor de la clase base puede
	inicializar de forma adecuada a sus propios elementos. Por lo
	tanto es esencial que se llame a todos los constructores; de
	otra forma el objeto no estará construido de forma
	adecuada. Esto es por lo que el compilador obliga a hacer una
	llamada por cada trozo en una clase derivada. Se llamará al
	constructor por defecto si no se hace una llamada explícita a un
	constructor de la clase base. Si no existe constructor por
	defecto, el compilador lo creará.
      </p><p>
	El orden de las llamadas al constructor es importante. Cuando se
	hereda, se sabe todo sobre la clase base y se puede acceder a
	todos los miembros públicos y protegidos
	(<code class="keyword">public</code> y <code class="keyword">protected</code>) de la
	clase base. ésto significa que se puede asumir que todos los
	miembros de la clase base son válidos cuando se está en la clase
	derivada. En una función miembro normal, la construcción ya ha
	ocurrido, por lo que todos los miembros de todas las partes del
	objeto ya han sido construidos. Dentro del constructor, sin
	embargo, hay que asumir que todos los miembros que se usen han
	sido construidos. La única manera de garantizarlo es llamando
	primero al constructor de la clase base. Entonces cuando se esté
	en el constructor de la clase derivada, todos los miembros a los
	que se pueda acceder en la clase base han sido
	inicializados. "Saber que todos los miembros son válidos" dentro
	del constructor es también la razón por la que, dentro de lo
	posible, se debe inicializar todos los objetos miembros (es
	decir, los objetos puestos en la clase mediante composición). Si
	se sigue ésta práctica, se puede asumir que todos los miembros
	de la clase base y los miembros objetos del objeto actual han
	sido inicializados.
      </p></div><div class="sect2" title="15.10.2. Comportamiento de las funciones virtuales dentro de los constructores"><div class="titlepage"><div><div><h3 class="title"><a id="idp8302136"></a>15.10.2. Comportamiento de las funciones virtuales dentro de los
      constructores</h3></div></div></div><p>
	La jerarquía de las llamadas a los constructores plantea un
	interesante dilema. ¿Qué ocurre si se está dentro de un
	constructor y se llama a una función virtual? Dentro de una
	función miembro ordinaria se puede imaginar que ocurrirá - la
	llamada virtual es resuelta en tiempo de ejecución porque el
	objeto no puede conocer si la función miembro es de la clase en
	la que está o es de una clase derivada. Por consistencia, se
	podría pensar que también es lo que debería ocurrir dentro de
	los constructores.
      </p><p>
	No es el caso. Si se llama a una función virtual dentro de un
	constructor, sólo se usa la versión local de la función. Es
	decir, el mecanismo virtual no funciona dentro del constructor.
      </p><p>
	éste comportamiento tiene sentido por dos
	motivos. Conceptualmente, el trabajo del constructor es dar al
	objeto una <span class="emphasis"><em>existencia</em></span>. Dentro de cualquier
	constructor, el objeto puede ser formado sólo parcialmente - se
	puede saber sólo que los objetos de la clase base han sido
	inicializados, pero no se puede saber que clases heredan de
	ésta. Una función virtual, sin embargo, se mueve "arriba" y
	"abajo" dentro de la jerarquía de herencia. Llama a una función
	de una clase derivada. Si se pudiera hacer esto dentro de un
	constructor, se estaría llamando a una función que debe manejar
	miembros que todavía no han sido inicializados, una receta
	segura para el desastre.
      </p><p>
	El segundo motivo es mecánico. Cuando se llama a un constructor,
	una de las primeras cosas que hace es inicializar su VPTR. Sin
	embargo, sólo puede saber que es del tipo "actual" - el tipo
	para el que se ha escrito el constructor. El código del
	constructor ignora completamente si el objeto está en la base de
	otra clase. Cuando el compilador genera código para ese
	constructor, se genera código para un constructor de esa clase,
	no para la clase base, ni para una clase derivada (debido a que
	una clase no puede saber quién la hereda). Por eso, el VPTR que
	use debe apuntar a la VTABLE de <span class="emphasis"><em>esa</em></span> clase. El
	VPTR permanece inicializado a la VTABLE para el resto de vida
	del objeto a menos que no sea la última llamada al
	constructor. Si posteriormente se llama a un constructor de una
	clase derivada, éste constructor pone el VPTR a
	<span class="emphasis"><em>su</em></span> VTABLE, y así hasta que el último
	constructor termine. El estado del VPTR es determinado por el
	constructor que sea llamado en último lugar. Otra razón por la
	que los constructores son llamados en orden desde la base al más
	derivado.
      </p><p>
	Pero mientras que toda esta serie de llamadas al constructor
	tiene lugar, cada constructor ha puesto el VPTR a su propia
	VTABLE. Si se usa el mecanismo virtual para llamar a funciones,
	producirá sólo una llamada a través de su propia VTABLE, y no de
	la VTABLE del más derivado (como debería suceder después de que
	todos los constructores hayan sido llamados). Además, muchos
	compiladores reconocen cuando se hace una llamada a una función
	virtual dentro de un constructor, y realizan una ligadura
	estática porque saben que la ligadura dinámica producirá una
	llamada a una función local. En todo caso, no se conseguirán los
	resultados que se podían esperar inicialmente de la llamada a
	una función virtual dentro de un constructor.
      </p></div><div class="sect2" title="15.10.3. Destructores y destructores virtuales"><div class="titlepage"><div><div><h3 class="title"><a id="idp8308904"></a>15.10.3. Destructores y destructores virtuales</h3></div></div></div><p>
	No se puede usar la palabra reservada
	<code class="keyword">virtual</code> con los constructores, pero los
	destructores pueden, y a menudo deben, ser virtuales.
      </p><p>
	El constructor tiene el trabajo especial de iniciar un objeto
	poco a poco, primero llamando al constructor base y después a
	los constructores derivados en el orden de la herencia. De
	manera similar, el destructor tiene otro trabajo especial:
	desmontar un objeto, el cual puede pertenecer a una jerarquía de
	clases. Para hacerlo, el compilador genera código que llama a
	todos los destructores, pero en el orden
	<span class="emphasis"><em>inverso</em></span> al que son llamados en los
	constructores. Es decir, el constructor empieza en la clase más
	derivada y termina en la clase base. ésta es la opción deseable
	y segura debido a que el destructor siempre sabe que los
	miembros de la clase base están vivos y activos. Si se necesita
	llamar a una función miembro de la clase base dentro del
	destructor, será seguro hacerlo. De esta forma, el destructor
	puede realizar su propio limpiado, y entonces llamar al
	siguiente destructor, el cual hará <span class="emphasis"><em>su</em></span> propio
	limpiado, etc. Cada destructor sabe de que clase deriva, pero no
	cuales derivan de él.
      </p><p>
	Hay que tener en cuenta que los constructores y los destructores
	son los únicos lugares donde tiene que funcionar ésta jerarquía
	de llamadas (que es automáticamente generada por el
	compilador). En el resto de las funciones, sólo esa función, sea
	o no virtual, será llamada (y no las versiones de la clase
	base). La única forma para acceder a las versiones de la clase
	base de una función consiste en llamar de forma
	<span class="emphasis"><em>explicita</em></span> a esa funciones.
      </p><p>
	Normalmente, la acción del destructor es adecuada. Pero ¿qué
	ocurre si se quiere manipular un objeto a través de un puntero a
	su clase base (es decir, manipular al objeto a través de su
	interfaz genérica)? Este tipo de actividades es uno de los
	objetivos de la programación orientada a objetos. El problema
	viene cuando se quiere hacer un <code class="keyword">delete</code>
	(eliminar) de un puntero a un objeto que ha sido creado en el
	<span class="emphasis"><em>montón</em></span>
	(<span class="foreignphrase"><em class="foreignphrase">&gt;heap</em></span>) con
	<code class="keyword">new</code>. Si el puntero apunta a la clase base, el
	compilador sólo puede conocer la versión del destructor que se
	encuentre en la clase base durante el
	<code class="keyword">delete</code>. ¿Suena familiar? Al fin y al cabo, es
	el mismo problema por las que fueron creadas las funciones
	virtuales en el caso general. Afortunadamente, las funciones
	virtuales funcionan con los destructores como lo hacen para las
	otras funciones excepto los constructores.
      </p><div class="example"><a id="idp8317400"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:VirtualDestructors.cpp</span>
<span class="hl slc">// Behavior of virtual vs. non-virtual destructor</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base1 <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Base1</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Base1()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived1 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base1 <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Derived1</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Derived1()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Base2 <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Base2</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Base2()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Base2 <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Derived2</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Derived2()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Base1<span class="hl opt">*</span> bp <span class="hl opt">=</span> <span class="hl kwa">new</span> Derived1<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
  <span class="hl kwa">delete</span> bp<span class="hl opt">;</span>
  Base2<span class="hl opt">*</span> b2p <span class="hl opt">=</span> <span class="hl kwa">new</span> Derived2<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
  <span class="hl kwa">delete</span> b2p<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.12. C15/VirtualDestructors.cpp</strong></p></div><br class="example-break" /><p>
	Cuando se ejecuta el programa, se ve que <code class="literal">delete
	bp</code> sólo llama al destructor de la clase base, mientras
	que <code class="literal">delete b2p</code> llama al destructor de la
	clase derivada seguido por el destructor de la clase base, que
	es el comportamiento que deseamos. Olvidar hacer
	<code class="keyword">virtual</code> a un destructor es un error
	peligroso porque a menudo no afecta directamente al
	comportamiento del programa, pero puede introducir de forma
	oculta agujeros de memoria. Además, el hecho de que
	<span class="emphasis"><em>alguna</em></span> destrucción está teniendo lugar puede
	enmascarar el problema.
      </p><p>
	Es posible que el destructor sea virtual porque el objeto sabe
	de que tipo es (lo que no ocurre durante la construcción del
	objeto). Una vez que el objeto ha sido construido, su VPTR es
	inicializado y se pueden usar las funciones virtuales.
      </p></div><div class="sect2" title="15.10.4. Destructores virtuales puros"><div class="titlepage"><div><div><h3 class="title"><a id="idp8322088"></a>15.10.4. Destructores virtuales puros</h3></div></div></div><p>
	Mientras que los destructores virtuales puros son legales en el
	Standard C++, hay una restricción añadida cuando se usan: hay
	que proveer de un cuerpo de función a los destructores virtuales
	puros. Esto parece antinatural; ¿Cómo puede una función virtual
	ser "pura" si necesita el cuerpo de una función? Pero si se
	tiene en cuenta que los constructores y los destructores son
	operaciones especiales tiene más sentido, especialmente si se
	recuerda que todos los destructores en una jerarquía de clases
	son llamados siempre. Si se quita la definición de un destructor
	virtual puro, ¿a qué cuerpo de función se llamará durante la
	destrucción? Por esto, es absolutamente necesario que el
	compilador y el enlazador requieran la existencia del cuerpo de
	una función para un destructor virtual puro.
      </p><p>
	Si es puro, pero la función tiene cuerpo ¿cuál es su valor? La
	única diferencia que se verá entre el destructor virtual puro y
	el no-puro es que el destructor virtual puro convierte a la
	clase base en abstracta, por lo que no se puede crear un objeto
	de la clase base (aunque esto también sería verdad si cualquier
	otra función miembro de esa clase base fuera virtual pura).
      </p><p>
	Sin embargo, las cosas son un poco confusas cuando se hereda una
	clase de otra que contenga un destructor puro virtual. Al
	contrario que en el resto de las funciones virtuales puras,
	<span class="emphasis"><em>no</em></span> es necesario dar una definición de un
	destructor virtual puro en la clase derivada. El hecho de que el
	siguiente código compile es la prueba:
      </p><div class="example"><a id="idp8326256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:UnAbstract.cpp</span>
<span class="hl slc">// Pure virtual destructors </span>
<span class="hl slc">// seem to behave strangely</span>

<span class="hl kwc">class</span> AbstractBase <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">AbstractBase</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

AbstractBase<span class="hl opt">::~</span><span class="hl kwd">AbstractBase</span><span class="hl opt">() {}</span>

<span class="hl kwc">class</span> Derived <span class="hl opt">:</span> <span class="hl kwc">public</span> AbstractBase <span class="hl opt">{};</span>
<span class="hl slc">// No overriding of destructor necessary?</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span> Derived d<span class="hl opt">; }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.13. C15/UnAbstract.cpp</strong></p></div><br class="example-break" /><p>
	Normalmente, una función virtual pura en una clase base causará
	que la clase derivada sea abstracta a menos que esa (y todas las
	demás funciones virtuales puras) tengan una definición. Pero
	aquí, no parece ser el caso. Sin embargo, hay que recordar que
	el compilador crea <span class="emphasis"><em>automáticamente</em></span> una
	definición del destructor en todas las clases si no se crea una
	de forma explícita. Esto es lo que sucede aquí - el destructor
	de la clase base es sobreescrito de forma oculta, y una
	definición es puesta por el compilador por lo que
	<code class="classname">Derived</code> no es abstracta.
      </p><p>
	Esto nos brinda una cuestión interesante: ¿Cuál es el sentido de
	un destructor virtual puro? Al contrario que con las funciones
	virtuales puras ordinarias en las que hay que
	<span class="emphasis"><em>dar</em></span> el cuerpo de una función, en una clase
	derivada de otra con un destructor virtual puro, no se está
	obligado a implementar el cuerpo de la función porque el
	compilador genera automáticamente el destructor. Entonces ¿Cuál
	es la diferencia entre un destructor virtual normal y un
	destructor virtual puro?
      </p><p>
	La única diferencia ocurre cuando se tiene una clase que sólo
	tiene una función virtual pura: el destructor. En este caso, el
	único efecto de la <span class="emphasis"><em>pureza</em></span> del destructor es
	prevenir la instanciación de la clase base, pero si no existen
	otros destructores en las clase heredadas, el destructor virtual
	se ejecutará. Por esto, mientras que el añadir un destructor
	virtual es esencial, el hecho de que sea puro o no lo sea no es
	tan importante.
      </p><p>
	Cuando se ejecuta el siguiente ejemplo, se puede ver que se
	llama al cuerpo de la función virtual pura después de la versión
	que está en la clase derivada, igual que con cualquier otro
	destructor.
      </p><div class="example"><a id="idp8332576"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:PureVirtualDestructors.cpp</span>
<span class="hl slc">// Pure virtual destructors</span>
<span class="hl slc">// require a function body</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Pet</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

Pet<span class="hl opt">::~</span><span class="hl kwd">Pet</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Pet()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Dog</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Dog()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Pet<span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwa">new</span> Dog<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
  <span class="hl kwa">delete</span> p<span class="hl opt">;</span> <span class="hl slc">// Virtual destructor call</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.14. C15/PureVirtualDestructors.cpp</strong></p></div><br class="example-break" /><p>
	Como guía, cada vez que se tenga una función virtual en una
	clase, se debería añadir inmediatamente un destructor virtual
	(aunque no haga nada). De esta forma se evitan posteriores
	sorpresas.
      </p></div><div class="sect2" title="15.10.5. Mecanismo virtual en los destructores"><div class="titlepage"><div><div><h3 class="title"><a id="idp8334728"></a>15.10.5. Mecanismo virtual en los destructores</h3></div></div></div><p>
	Hay algo que sucede durante la destrucción que no se espera de
	manera intuitiva. Si se está dentro de una función miembro y se
	llama a una función virtual, esa función es ejecutada usando el
	mecanismo de la ligadura dinámica. Esto no es verdad con los
	destructores, virtuales o no. Dentro de un destructor, sólo se
	llama a la función miembro "local"; el mecanismo virtual es
	ignorado.
      </p><div class="example"><a id="idp8335984"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:VirtualsInDestructors.cpp</span>
<span class="hl slc">// Virtual calls inside destructors</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Base</span><span class="hl opt">() {</span> 
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Base1()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> 
    <span class="hl kwd">f</span><span class="hl opt">();</span> 
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Base::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Derived</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Derived()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Derived::f()</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Base<span class="hl opt">*</span> bp <span class="hl opt">=</span> <span class="hl kwa">new</span> Derived<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
  <span class="hl kwa">delete</span> bp<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.15. C15/VirtualsInDestructors.cpp</strong></p></div><br class="example-break" /><p>
	Durante la llamada al destructor virtual, no se llama a
	<code class="function">Derived::f()</code>, incluso aunque
	<code class="function">f()</code> es virtual.
      </p><p>
	¿A qué es debido ésto? Supongamos que fuera usado el mecanismo
	virtual dentro del destructor. Entonces sería posible para la
	llamada virtual resolver una función que está "lejana" (más
	derivada) en la jerarquía de herencia que el destructor
	actual. Pero los destructores son llamados de "afuera a dentro"
	(desde el destructor más derivado hacia el destructor de la
	clase base), por lo que la llamada actual a la función puede
	intentar acceder a fragmentos de un objeto que <span class="emphasis"><em>!ya ha
	sido destruido!</em></span> En vez de eso, el compilador resuelve
	la llamada en tiempo de compilación y llama sólo a la versión
	local de la función. Hay que resaltar que lo mismo es también
	verdad para el constructor (como se explicó anteriormente), pero
	en el caso del constructor el tipo de información no estaba
	disponible, mientras que en el destructor la información está
	ahí (es decir, el VPTR) pero no es accesible.
      </p></div><div class="sect2" title="15.10.6. Creación una jerarquía basada en objetos"><div class="titlepage"><div><div><h3 class="title"><a id="idp8340192"></a>15.10.6. Creación una jerarquía basada en objetos</h3></div></div></div><p>
	Un asunto que ha aparecido de forma recurrente a lo largo de
	todo el libro cuando se usaban las clases
	<code class="classname">Stack</code> y <code class="classname">Stash</code> es
	el "problema de la propiedad". El "propietario" se refiere a
	quien o al que sea responsable de llamar al
	<code class="keyword">delete</code> de aquellos objetos que hayan sido
	creados dinámicamente (usando <code class="keyword">new</code>). El
	problema cuando se usan contenedores es que es necesario ser lo
	suficientemente flexible para manejar distintos tipos de
	objetos. Para conseguirlo, los contenedores manejan punteros a
	<code class="type">void</code> por lo que no pueden saber el tipo del
	objeto que están manejando. Borrar un puntero a
	<code class="type">void</code> no llama al destructor, por lo que el
	contenedor no puede ser responsable de borrar sus objetos.
      </p><p>
	Una solución fue presentada en el ejemplo
	<code class="filename">C14:InheritStack.cpp</code>, en el que
	<code class="classname">Stack</code> era heredado en una nueva clase que
	aceptaba y producía únicamente objetos
	<code class="type">string</code>, por lo que se les podía borrar de
	manera adecuada. Era una buena solución pero requería heredar
	una nueva clase contenedera por cada tipo que se quisiera
	manejar en el contenedor. (Aunque suene un poco tedioso funciona
	bastante bien como se verá en el capítulo 16 cuando las
	plantillas o templates sean introducidos).
      </p><p>
	El problema es que se quiere que el contenedor maneje más de un
	tipo, pero sólo se quieren usar punteros a
	<code class="type">void</code>. Otra solución es usar polimorfismo
	forzando a todos los objetos incluidos en el contenedor a ser
	heredados de la misma clase base. Es decir, el contenedor maneja
	los objetos de la clase base, y sólo hay que usar funciones
	virtuales - en particular, se pueden llamar a destructores
	virtuales para solucionar el problema de pertenencia.
      </p><p>
	Esta solución usa lo que se conoce como "jerarquía de raiz
	única" (<span class="foreignphrase"><em class="foreignphrase">singly-rooted hierarchy</em></span>)
	o "jerarquía basada en objetos" (<span class="foreignphrase"><em class="foreignphrase">object-based
	hierarchy</em></span>), siendo el último nombre debido a que la
	clase raiz de la jerarquía suele ser llamada "Objeto". Además,
	el usar jerarquía de raiz única, tiene como resultado otros
	beneficios: de hecho, cualquier otro lenguaje orientado a
	objetos que no sea el C++ obliga a usar una jerarquía - cuando
	se crea una clase se hereda automáticamente de forma directa o
	indirecta de una clase base común, una clase base que fue
	establecida por los creadores del lenguaje. En C++, se penso que
	forzar a tener una base clase común crearía demasiada
	sobrecarga, por lo que se desestimó. Sin embargo, se puede
	elegir usar en nuestros proyectos una clase base común, y esta
	materia será tratada en el segundo volumen de este libro.
      </p><p>
	Para solucionar el problema de pertenencia, se puede crear una
	clase base <code class="classname">Object</code> extremadamente simple,
	que sólo tiene un destructor virtual. De esta forma
	<code class="classname">Stack</code> puede manejar objetos que hereden
	de <code class="classname">Object</code>:
      </p><div class="example"><a id="idp8350160"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:OStack.h</span>
<span class="hl slc">// Using a singly-rooted hierarchy</span>
<span class="hl ppc">#ifndef OSTACK_H</span>
<span class="hl ppc">#define OSTACK_H</span>

<span class="hl kwc">class</span> Object <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Object</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl slc">// Required definition:</span>
<span class="hl kwc">inline</span> Object<span class="hl opt">::~</span><span class="hl kwd">Object</span><span class="hl opt">() {}</span>

<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    Object<span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwd">Link</span><span class="hl opt">(</span>Object<span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">) :</span> 
      <span class="hl kwd">data</span><span class="hl opt">(</span>dat<span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span>nxt<span class="hl opt">) {}</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() :</span> <span class="hl kwd">head</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Stack</span><span class="hl opt">(){</span> 
    <span class="hl kwa">while</span><span class="hl opt">(</span>head<span class="hl opt">)</span>
      <span class="hl kwa">delete</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>Object<span class="hl opt">*</span> dat<span class="hl opt">) {</span>
    head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span> head<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  Object<span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    <span class="hl kwa">return</span> head ? head<span class="hl opt">-&gt;</span>data <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Object<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
    Object<span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
    head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
    <span class="hl kwa">return</span> result<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OSTACK_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 15.16. C15/OStack.h</strong></p></div><br class="example-break" /><p>
	Para simplificar las cosas se crea todo en el fichero cabecera,
	la definición (requerida) del destructor virtual puro es
	introducida en línea el el fichero cabecera, y
	<code class="function">pop()</code> también está en línea aunque podría
	ser considearado como demasiado largo para ser incluido así.
      </p><p>
	Los objetos <code class="classname">Link</code> (lista) ahora manejan
	punteros a <code class="classname">Object</code> en vez de punteros a
	<code class="type">void</code>, y la <code class="classname">Stack</code> (pila) sólo
	aceptará y devolverá punteros a
	<code class="classname">Object</code>. Ahora
	<code class="classname">Stack</code> es mucho más flexible, ya que puede
	manejar un montón de tipos diferentes pero además es capaz de
	destruirá cualquier objeto dejado en la pila. La nueva
	limitación (que será finalmente eliminada cuando las plantillas
	se apliquen al problema en el capítulo 16) es que todo lo que se
	ponga en la pila debe ser heredado de
	<code class="classname">Object</code>. Esto está bien si se crea una clase
	desde la nada, pero ¿qué pasa si se tiene una clase como
	<code class="classname">string</code> y se quiere ser capaz de meterla en
	la pila? En este caso, la nueva clase debe ser al mismo tiempo
	un <code class="classname">string</code> y un <code class="classname">Object</code>, lo
	que significa que debe heredar de ambas clases. Esto se conoce
	como <span class="emphasis"><em>herencia múltiple</em></span> y es materia para un
	capítulo entero en el Volumen 2 de este libro (se puede bajar de
	www.BruceEckel.com). cuando se lea este capítulo, se verá que la
	herencia múltiple genera un montón de complejidad, y que es una
	característica que hay que usar con cuentagotas. Sin embargo,
	ésta situación es lo suficiéntemente simple como para no tener
	problemas al usar herencia múltiple:
      </p><div class="example"><a id="idp8357712"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:OStackTest.cpp</span>
<span class="hl slc">//{T} OStackTest.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;OStack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Use multiple inheritance. We want </span>
<span class="hl slc">// both a string and an Object:</span>
<span class="hl kwc">class</span> MyString<span class="hl opt">:</span> <span class="hl kwc">public</span> string<span class="hl opt">,</span> <span class="hl kwc">public</span> Object <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">MyString</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;deleting string: &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">MyString</span><span class="hl opt">(</span>string s<span class="hl opt">) :</span> <span class="hl kwd">string</span><span class="hl opt">(</span>s<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// File name is argument</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  Stack textlines<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl slc">// Read file and store lines in the stack:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">MyString</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Pop some lines from the stack:</span>
  MyString<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwa">if</span><span class="hl opt">((</span>s<span class="hl opt">=(</span>MyString<span class="hl opt">*)</span>textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">())==</span><span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Letting the destructor do the rest:&quot;</span>
    <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.17. C15/OStackTest.cpp</strong></p></div><br class="example-break" /><p>
	Aunque es similar a la versión anterior del programa de pruebas
	de <code class="classname">Stack</code>, se puede ver que sólo se han
	sacado 10 elementos de la pila, lo que implica que probablemente
	quede algún elemento. Como la pila ahora maneja
	<code class="classname">Object</code>s, el destructor puede limpiarlos
	de forma adecuada, como se puede ver en la salida del programa
	gracias a que los objetos <code class="classname">MyString</code>
	muestran un mensaje cuando son destruidos.
      </p><p>
	Crear contenedores que manejen <code class="classname">Object</code>s es
	una aproximación razonable - si se tiene una jerarquía de raiz
	única (debido al lenguaje o por algún requerimiento que obligue
	a que todas las clases hereden de
	<code class="classname">Object</code>). En este caso, está garantizado
	que todo es un <code class="classname">Object</code> y no es muy
	complicado usar contenedores. Sin embargo, en C++ no se puede
	esperar este comportamiento de todas las clases, por lo que se
	está abocado a usar herencia múltiple si se quiere usar esta
	aproximación. Se verá en el capítulo 16 que las plantillas
	solucionan este problema de una forma más simple y elegante.
      </p></div></div><div class="sect1" title="15.11. Sobrecarga de operadores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8363912"></a>15.11. Sobrecarga de operadores</h2></div></div></div><p>
      Se pueden crear operadores <code class="keyword">virtual</code>es de forma
      análoga a otras funciones miembro. Sin embargo implementar
      operadores <code class="keyword">virtual</code>es se vuelve a menudo confuso
      porque se está operando sobre dos objetos, ambos sin tipos
      conocidos. Esto suele ser el caso de los componentes matemáticos
      (para los cuales se suele usar la sobrecarga de operadores). Por
      ejemplo, considere un sistema que usa matrices, vectores y valores
      escalares, todos ellos heredados de la clase
      <code class="classname">Math</code>:
    </p><div class="example"><a id="idp8366584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:OperatorPolymorphism.cpp</span>
<span class="hl slc">// Polymorphism with overloaded operators</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Matrix<span class="hl opt">;</span>
<span class="hl kwc">class</span> Scalar<span class="hl opt">;</span>
<span class="hl kwc">class</span> Vector<span class="hl opt">;</span>

<span class="hl kwc">class</span> Math <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> Math<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*(</span>Math<span class="hl opt">&amp;</span> rv<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Matrix<span class="hl opt">*) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Scalar<span class="hl opt">*) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Vector<span class="hl opt">*) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Math</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Matrix <span class="hl opt">:</span> <span class="hl kwc">public</span> Math <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*(</span>Math<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> rv<span class="hl opt">.</span><span class="hl kwd">multiply</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span> <span class="hl slc">// 2nd dispatch</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Matrix<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Matrix * Matrix&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Scalar<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Scalar * Matrix&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Vector<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vector * Matrix&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Scalar <span class="hl opt">:</span> <span class="hl kwc">public</span> Math  <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*(</span>Math<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> rv<span class="hl opt">.</span><span class="hl kwd">multiply</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span> <span class="hl slc">// 2nd dispatch</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Matrix<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Matrix * Scalar&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Scalar<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Scalar * Scalar&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Vector<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vector * Scalar&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Vector <span class="hl opt">:</span> <span class="hl kwc">public</span> Math  <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*(</span>Math<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> rv<span class="hl opt">.</span><span class="hl kwd">multiply</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span> <span class="hl slc">// 2nd dispatch</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Matrix<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Matrix * Vector&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Scalar<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Scalar * Vector&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Math<span class="hl opt">&amp;</span> <span class="hl kwd">multiply</span><span class="hl opt">(</span>Vector<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vector * Vector&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Matrix m<span class="hl opt">;</span> Vector v<span class="hl opt">;</span> Scalar s<span class="hl opt">;</span>
  Math<span class="hl opt">*</span> math<span class="hl opt">[] = { &amp;</span>m<span class="hl opt">, &amp;</span>v<span class="hl opt">, &amp;</span>s <span class="hl opt">};</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">3</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">3</span><span class="hl opt">;</span> j<span class="hl opt">++) {</span>
      Math<span class="hl opt">&amp;</span> m1 <span class="hl opt">= *</span>math<span class="hl opt">[</span>i<span class="hl opt">];</span>
      Math<span class="hl opt">&amp;</span> m2 <span class="hl opt">= *</span>math<span class="hl opt">[</span>j<span class="hl opt">];</span>
      m1 <span class="hl opt">*</span> m2<span class="hl opt">;</span>
    <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.18. C15/OperatorPolymorphism.cpp</strong></p></div><br class="example-break" /><p>
      Para simplificar sólo se ha sobrecargado el
      <code class="type">operator*</code>. El objetivo es ser capaz de
      multiplicar dos objetos <code class="classname">Math</code> cualquiera y
      producir el resultado deseado - hay que darse cuenta que
      multiplicar una matriz por un vector es una operación totalmente
      distinta a la de multiplicar un vector por una matriz.
    </p><p>
      El problema es que, en el <code class="function">main()</code>, la
      expresión <code class="literal">m1 * m2</code> contiene dos referencias
      <code class="classname">Math</code>, y son dos objetos de tipo
      desconocido. Una función virtual es sólo capaz de hacer una única
      llamada - es decir, determinar el tipo de un único objeto. Para
      determinar ambos tipos en este ejemplo se usa una técnica conocida
      como despachado múltiple (<span class="foreignphrase"><em class="foreignphrase">multiple
      dispatching</em></span>), donde lo que parece ser una única
      llamada a una función virtual se convierte en una segunda llamada
      a una función virtual. Cuando la segunda llamada se ha ejecutado,
      ya se han determinado ambos tipos de objetos y se puede ejecutar
      la actividad de forma correcta. En un principio no es
      transparante, pero después de un rato mirando el código empieza a
      cobrar sentido. Esta materia es tratada con más profundidad en el
      capítulo de los patrones de diseño en el Volumen 2 que se puede
      bajar de <a class="ulink" href="http://www.bruceeckel.com" target="_top">&gt;www.BruceEckel.com</a>.
    </p></div><div class="sect1" title="15.12. Downcasting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8374520"></a>15.12. Downcasting</h2></div></div></div><p>
      Como se puede adivinar, desde el momento que existe algo conocido
      como upcasting - mover en sentido ascendente por una jerarquía de
      herencia - debe existir el
      <span class="foreignphrase"><em class="foreignphrase">downcasting</em></span> para mover en sentido
      descendente en una jerarquía. Pero el upcasting es sencillo porque
      al movernos en sentido ascendente en la jerarquía de clases
      siempre convergemos en clases más generales. Es decir, cuando se
      hace un upcast siempre se está en una clase claramente derivada de
      un ascendente (normalmente solo uno, excepto en el caso de
      herencia múltiple) pero cuando se hace downcast hay normalmente
      varias posibilidades a las que amoldarse. Mas concretamente, un
      <code class="classname">Circulo</code> es un tipo de
      <code class="classname">Figura</code> (que sería su
      <span class="foreignphrase"><em class="foreignphrase">upcast</em></span>), pero si se intenta hacer
      un <span class="foreignphrase"><em class="foreignphrase">downcast</em></span> de una
      <code class="classname">Figura</code> podría ser un
      <code class="classname">Circulo</code>, un
      <code class="classname">Cuadrado</code>, un
      <code class="classname">Triángulo</code>, etc. El problema es encontrar un
      modo seguro de hacer <span class="foreignphrase"><em class="foreignphrase">downcast</em></span>
      (aunque es incluso más importante preguntarse por qué se está
      usando <span class="foreignphrase"><em class="foreignphrase">downcasting</em></span> en vez de usar
      el polimorfismo para que adivine automáticamente el tipo
      correcto. En el Volumen 2 de este libro se trata como evitar el
      <span class="foreignphrase"><em class="foreignphrase">downcasting</em></span>.
    </p><p>
      C++ proporciona un moldeado explícito especial (introducido en el
      capítulo 3) llamado "moldeado dinámico"
      (<span class="foreignphrase"><em class="foreignphrase">dynamic_cast</em></span>) que es una operación
      segura. Cuando se usa <span class="emphasis"><em>moldeado dinámico</em></span> para
      intentar hacer un molde a un tipo en concreto, el valor de retorno
      será un puntero al tipo deseado sólo si el molde es adecuado y
      tiene éxito, de otra forma devuelve cero para indicar que no es
      del tipo correcto. Aquí tenemos un ejemplo mínimo:
    </p><div class="example"><a id="idp8381136"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:DynamicCast.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Pet <span class="hl opt">{</span> <span class="hl kwc">public</span><span class="hl opt">:</span> <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Pet</span><span class="hl opt">(){}};</span>
<span class="hl kwc">class</span> Dog <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{};</span>
<span class="hl kwc">class</span> Cat <span class="hl opt">:</span> <span class="hl kwc">public</span> Pet <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Pet<span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> Cat<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
  <span class="hl slc">// Try to cast it to Dog*:</span>
  Dog<span class="hl opt">*</span> d1 <span class="hl opt">=</span> <span class="hl kwa">dynamic_cast</span><span class="hl opt">&lt;</span>Dog<span class="hl opt">*&gt;(</span>b<span class="hl opt">);</span>
  <span class="hl slc">// Try to cast it to Cat*:</span>
  Cat<span class="hl opt">*</span> d2 <span class="hl opt">=</span> <span class="hl kwa">dynamic_cast</span><span class="hl opt">&lt;</span>Cat<span class="hl opt">*&gt;(</span>b<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;d1 = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>d1 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;d2 = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>d2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.19. C15/DynamicCast.cpp</strong></p></div><br class="example-break" /><p>
      Cuando se use <span class="emphasis"><em>moldeado dinámico</em></span>, hay que
      trabajar con una jerarquía polimórfica real - con funciones
      virtuales - debido a que el <span class="emphasis"><em>modeado dinámico</em></span>
      usa información almacenada en la VTABLE para determinar el tipo
      actual. Aquí, la clase base contiene un destructor virtual y esto
      es suficiente. En el <code class="function">main()</code>, un puntero a
      <code class="classname">Cat</code> es elevado a
      <code class="classname">Pet</code>, y después se hace un downcast tanto a
      puntero <code class="classname">Dog</code> como a puntero a
      <code class="classname">Cat</code>. Ambos punteros son imprimidos, y se
      puede observar que cuando se ejecuta el programa el
      <span class="foreignphrase"><em class="foreignphrase">downcast</em></span> incorrecto produce el
      valor cero. Por supuesto somos los responsables de comprobar que
      el resultado del cast no es cero cada vez que se haga un
      downcast. Además no hay que asumir que el puntero será exactamente
      el mismo, porque a veces se realizan ajustes de punteros durante
      el <span class="foreignphrase"><em class="foreignphrase">upcasting</em></span> y el
      <span class="foreignphrase"><em class="foreignphrase">downcasting</em></span> (en particular, con la
      herencia múltiple).
    </p><p>
      Un <span class="emphasis"><em>moldeado dinámico</em></span> requiere un poco de
      sobrecarga extra en ejecución; no mucha, pero si se está haciendo
      mucho <span class="emphasis"><em>moldeado dinámico</em></span> (en cuyo caso debería
      ser cuestionado seriamente el diseño del programa) se convierte en
      un lastre en el rendimiento. En algunos casos se puede tener
      alguna información especial durante el downcasting que permita
      conocer el tipo que se está manejando, con lo que la sobrecarga
      extra del <span class="emphasis"><em>modeado dinámico</em></span> se vuelve
      innecesario, y se puede usar de manera alternativa un
      <span class="emphasis"><em>moldeado estático</em></span>. Aquí se muestra como
      funciona:
    </p><div class="example"><a id="idp8388960"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C15:StaticHierarchyNavigation.cpp</span>
<span class="hl slc">// Navigating class hierarchies with static_cast</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;typeinfo&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Shape <span class="hl opt">{</span> <span class="hl kwc">public</span><span class="hl opt">:</span> <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Shape</span><span class="hl opt">() {}; };</span>
<span class="hl kwc">class</span> Circle <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{};</span>
<span class="hl kwc">class</span> Square <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{};</span>
<span class="hl kwc">class</span> Other <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Circle c<span class="hl opt">;</span>
  Shape<span class="hl opt">*</span> s <span class="hl opt">= &amp;</span>c<span class="hl opt">;</span> <span class="hl slc">// Upcast: normal and OK</span>
  <span class="hl slc">// More explicit but unnecessary:</span>
  s <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span>Shape<span class="hl opt">*&gt;(&amp;</span>c<span class="hl opt">);</span>
  <span class="hl slc">// (Since upcasting is such a safe and common</span>
  <span class="hl slc">// operation, the cast becomes cluttering)</span>
  Circle<span class="hl opt">*</span> cp <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  Square<span class="hl opt">*</span> sp <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Static Navigation of class hierarchies</span>
  <span class="hl slc">// requires extra type information:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwc">typeid</span><span class="hl opt">(</span>s<span class="hl opt">) ==</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>cp<span class="hl opt">))</span> <span class="hl slc">// C++ RTTI</span>
    cp <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span>Circle<span class="hl opt">*&gt;(</span>s<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwc">typeid</span><span class="hl opt">(</span>s<span class="hl opt">) ==</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>sp<span class="hl opt">))</span>
    sp <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span>Square<span class="hl opt">*&gt;(</span>s<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>cp <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;It's a circle!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>sp <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;It's a square!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Static navigation is ONLY an efficiency hack;</span>
  <span class="hl slc">// dynamic_cast is always safer. However:</span>
  <span class="hl slc">// Other* op = static_cast&lt;Other*&gt;(s);</span>
  <span class="hl slc">// Conveniently gives an error message, while</span>
  Other<span class="hl opt">*</span> op2 <span class="hl opt">= (</span>Other<span class="hl opt">*)</span>s<span class="hl opt">;</span>
  <span class="hl slc">// does not</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 15.20. C15/StaticHierarchyNavigation.cpp</strong></p></div><br class="example-break" /><p>
      En este programa, se usa una nueva característica que no será
      completamente descrita hasta el Volumen 2 de este libro, donde hay
      un capítulo que cubre este tema: <span class="emphasis"><em>Información de tipo en
      tiempo de ejecución en C++</em></span> o mecanismo RTTI
      (<span class="foreignphrase"><em class="foreignphrase">run time type information</em></span>). RTTI
      permite descubrir información de tipo que ha sido perdida en el
      upcasting. El <span class="emphasis"><em>moldeado dinámico</em></span> es
      actualmente una forma de RTTI. Aquí se usa la palabra reservada
      <code class="keyword">typeid</code> (declarada en el fichero cabecera
      <code class="filename">typeinfo</code>) para detectar el tipo de los
      punteros. Se puede ver que el tipo del puntero a
      <code class="classname">Figura</code> es comparado de forma sucesiva con
      un puntero a <code class="classname">Circulo</code> y con un
      <code class="classname">Cuadrado</code> para ver si existe alguna
      coincidencia. Hay más RTTI que el <code class="keyword">typeid</code>, y se
      puede imaginar que es fácilmente implementable un sistema de
      información de tipos usando una función virtual.
    </p><p>
      Se crea un objeto <code class="classname">Circulo</code> y la dirección es
      elevada a un puntero a <code class="classname">Figura</code>; la segunda
      versión de la expresión muestra como se puede usar
      <span class="emphasis"><em>modeado estático</em></span> para ser más explícito con el
      upcast. Sin embargo, desde el momento que un upcast siempre es
      seguro y es una cosa que se hace comunmente, considero que un cast
      explícito para hacer upcast ensucia el código y es innecesario.
    </p><p>
      Para determinar el tipo se usa RTTI, y se usa <span class="emphasis"><em>modelado
	estático</em></span> para realizar el downcast. Pero hay que
	resaltar que, efectivamente, en este diseño el proceso es el
	mismo que usar el <span class="emphasis"><em>moldeado dinámico</em></span>, y el
	programador cliente debe hacer algún test para descubrir si el
	cast tuvo éxito. Normalmente se prefiere una situación más
	determinista que la del ejemplo anterior para usar el
	<span class="emphasis"><em>modeado estático</em></span> antes que el
	<span class="emphasis"><em>moldeado dinámico</em></span> (y hay que examinar
	detenidamente el diseño antes de usar
	<span class="emphasis"><em>moldeado dinámico</em></span>).
    </p><p>
      Si una jerarquía de clases no tiene funciones
      <code class="keyword">virtual</code>es (que es un diseño cuestionable) o si
      hay otra información que permite hacer un downcast seguro, es un
      poco más rápido hacer el downcast de forma estática que con el
      <span class="emphasis"><em>moldeado dinámico</em></span>. Además, <span class="emphasis"><em>modeado
      estático</em></span> no permitirá realizar un cast fuera de la
      jerarquía, como un cast tradicional permitiría, por lo que es más
      seguro. Sin enbargo, navegar de forma estática por la jerarquía de
      clases es siempre arriesgado por lo que hay que usar
      <span class="emphasis"><em>moldeado dinámico</em></span> a menos que sea una
      situación especial.
    </p></div><div class="sect1" title="15.13. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8402424"></a>15.13. Resumen</h2></div></div></div><p>
      Polimorfismo - implementado en C++ con las funciones virtuales -
      significa "formas diferentes". En la programación orientada a
      objetos, se tiene la misma vista (la interfaz común en la clase
      base) y diferentes formas de usarla: las diferentes versiones de
      las funciones virtuales.
    </p><p>
      Se ha visto en este capítulo que es imposible entender, ni
      siquiera crear, un ejemplo de polimorfismo sin usar la abstracción
      de datos y la herencia. El polimorfismo es una característica que
      no puede ser vista de forma aislada (como por ejemplo las
      sentencias <code class="keyword">const</code> y <code class="keyword">switch</code>),
      pero sin embargo funciona únicamente de forma conjunta, como una
      parte de un "gran cuadro" de relaciones entre clases. La gente se
      vuelve a menudo confusa con otras características no orientadas a
      objetos de C++ como es la sobrecarga y los argumentos por defecto,
      los cuales son presentados a veces como orientado a objetos. No
      nos liemos; si no hay ligadura dinámica, no hay polimorfismo.
    </p><p>
      Para usar el polimorfismo - y por lo tanto, técnicas orientadas a
      objetos - en los programas hay que ampliar la visión de la
      programación para incluir no solo miembros y mensajes entre clases
      individuales, si no también sus puntos en común y las relaciones
      entre ellas. Aunque requiere un esfuerzo significativo, es
      recompensado gracias a que se consigue mayor velocidad en el
      desarrollo, mejor organización de código, programas extensibles, y
      mayor mantenibilidad.
    </p><p>
      El polimorfismo completa las características de orientación a
      objetos del lenguaje, pero hay dos características fundamentales
      más en C++: plantillas (introducidas en el capítulo 16 y cubiertas
      en mayor detalle en el segundo volumen de este libro), y manejo de
      excepciones (cubierto en el Volumen 2). Estas características nos
      proporcionan un incremento de poder de cada una de las
      características de la orientación a objetos: tipado abstracto de
      datos, herencia, y polimorfismo.
    </p></div><div class="sect1" title="15.14. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8407888"></a>15.14. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Cree una jerarquía simple "figura": una clase base llamada
	  <code class="classname">Figura</code> y una clases derivadas llamadas
	  <code class="classname">Circulo</code>,
	  <code class="classname">Cuadrado</code>, y
	  <code class="classname">Triangulo</code>. En la clase base, hay que
	  hacer una función virtual llamada
	  <code class="function">dibujar()</code>, y sobreescribirla en las
	  clases derivadas. Hacer un array de punteros a objetos
	  <code class="classname">Figura</code> que se creen en el montón (heap)
	  y que obligue a realizar upcasting de los punteros, y llamar a
	  <code class="function">dibujar()</code> a través de la clase base para
	  verificar el comportamiento de las funciones virtuales. Si el
	  depurador lo soporta, intente ver el programa paso a paso.
	</p></li><li class="listitem"><p>
	  Modifique el Ejercicio 1 de tal forma que
	  <code class="function">dibujar()</code> sea una función virtual
	  pura. Intente crear un objeto de tipo
	  <code class="classname">Figura</code>. Intente llamar a la función
	  virtual pura dentro del constructor y mire lo que
	  ocurre. Dejándolo como una función virtual pura cree una
	  definición para <code class="function">dibujar()</code>.
	</p></li><li class="listitem"><p>
	  Aumentando el Ejercicio 2, cree una función que use un objeto
	  <code class="classname">Figura</code> <span class="emphasis"><em>por valor</em></span> e
	  intente hacer un upcast de un objeto derivado como
	  argumento. Vea lo que ocurre. Arregle la función usando una
	  referencia a un objeto <code class="classname">Figura</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">C14:Combined.cpp</code> para que
	  <code class="function">f()</code> sea <code class="keyword">virtual</code> en la
	  clase base. Cambie el <code class="function">main()</code> para que se
	  haga un <span class="foreignphrase"><em class="foreignphrase">upcast</em></span> y una llamada virtual.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">Instrument3.cpp</code> añadiendo una
	  función virtual <code class="function">preparar()</code>. Llame a
	  <code class="function">preparar()</code> dentro de
	  <code class="function">tune()</code>.
	</p></li><li class="listitem"><p>
	  Cree una jerarquía de herencia de
	  <code class="classname">Roedor</code>es: <code class="classname">Raton</code>,
	  <code class="classname">Gerbo</code>, <code class="classname">Hamster</code>,
	  etc. En la clase base, proporcione los métodos que son comunes
	  a todos los roedores, y redefina aquellos en las clases
	  derivadas para que tengan diferentes comportamientos
	  dependiendo del tipo específico de roedor. Cree un array de
	  punteros a <code class="classname">Roedor</code>, rellenelo con distintos
	  tipos de roedores y llame a los métodos de la clase base para
	  ver lo que ocurre.
	</p></li><li class="listitem"><p>
	  Modifique el Ejercicio 6 para que use un
	  <code class="literal">vector&lt;Roedor*&gt; </code> en vez de un array
	  de punteros. Asegurese que se hace un limpiado correcto de la
	  memoria.
	</p></li><li class="listitem"><p>
	  Empezando con la jerarquía anterior de
	  <code class="classname">Roedor</code>, herede un
	  <code class="classname">HamsterAzul</code> de
	  <code class="classname">Hamster</code> (si, existe algo así, tuve uno
	  cuando era niño), sobreescriba los métodos de la clase base y
	  muestre que el código que llama a los métodos de clase base no
	  necesitan cambiar para adecuarse el nuevo tipo.
	</p></li><li class="listitem"><p>
	  A partir de la jerarquía <code class="classname">Roedor</code> anterior,
	  añadaun destructor no virtual, cree un objeto de la
	  <code class="classname">Hamster</code> usando <code class="keyword">new</code>,
	  haga un upcast del puntero a <code class="type">Roedor*</code>, y
	  borre el puntero con <code class="keyword">delete</code> para ver si no
	  se llama a los destructores en la jerarquía. Cambie el
	  destructor a <code class="keyword">virtual</code> y demuestre que el
	  comportamiento es ahora correcto.
	</p></li><li class="listitem"><p>
	  Modifique <code class="classname">Roedor</code> para convertirlo en una
	  clase base pura abstracta.
	</p></li><li class="listitem"><p>
	  Cree un sistema de control aéreo con la clase base
	  <code class="classname">Avion</code> y varios tipos derivados. Cree
	  una clase <code class="classname">Torre</code> con un
	  <code class="literal">vector&lt;Avion*&gt; </code> que envie los
	  mensajes adecuados a los distintos aviones que están bajo su
	  control.
	</p></li><li class="listitem"><p>
	  Cree un modelo de invernadero heredando varios tipos de
	  <code class="classname">Planta</code>s y construyendo mecanismos en el
	  invernadero que se ocupen de las plantas.
	</p></li><li class="listitem"><p>
	  En <code class="filename">Early.cpp</code>, haga a
	  <code class="classname">Pet</code> una clase base abstracta pura.
	</p></li><li class="listitem"><p>
	  En <code class="filename">AddingVirtuals.cpp</code>, haga a todas las
	  funciones miembro de <code class="classname">Pet</code> virtuales
	  puras, pero proporcione una definición para
	  <code class="function">name()</code>. Arregle <code class="classname">Dog</code>
	  como sea necesario, usando la definición de
	  <code class="function">name()</code> que se encuentra en la clase base.
	</p></li><li class="listitem"><p>
	  Escriba un pequeño programa para mostrar la diferencia entre
	  llamar a una función virtual dentro de una función miembro
	  normal y llamar a una función virtual dentro de un
	  constructor. El programa de probar que las dos llamadas
	  producen diferentes resultados.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">VirtualsInDestructors.cpp</code> por
	  heredando una clase de <code class="classname">Derived</code> y
	  sobreescribiendo <code class="function">f()</code> y el destructor. En
	  <code class="function">main()</code>, cree y haga un upcast de un objeto
	  de su nuevo tipo, después borrelo.
	</p></li><li class="listitem"><p>
	  Use el Ejercicio 16 y añada llamadas a <code class="function">f()</code>
	  en cada destructor. Explique que ocurre.
	</p></li><li class="listitem"><p>
	  Cree un clase que tenga un dato miembro y una clase derivada
	  que añada otro dato miembro. Escriba una función no miembro
	  que use un objeto de la clase base <span class="emphasis"><em>por
	  valor</em></span> e imprima el tamaño del objeto usando
	  <code class="literal">sizeof</code>. En el <code class="function">main()</code>
	  cree un objeto de la clase derivada, imprima su tamaño, y
	  llame a su función. Explique lo que ocurre.
	</p></li><li class="listitem"><p>
	  Cree un ejemplo sencillo de una llamada a una función virtual
	  y genere su salida en ensamblador. Localize el código en
	  ensamblador para la llamada a la función virtual y explique el
	  código.
	</p></li><li class="listitem"><p>
	  Escriba una clase con una función virtual y una función no
	  virtual. Herede una nueva clase, haga un objeto de esa clase,
	  y un upcast a un puntero del tipo de la clase base. Use la
	  función <code class="function">clock()</code> que se encuentra en
	  <code class="filename">&lt;ctime&gt;</code> (necesitará echar un vistazo
	  a su librerí C) para medir la diferencia entre una llamada
	  virtual y una llamada no virtual. Será necesario realizar
	  multiples llamadas a cada función para poder ver la
	  diferencia.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">C14:Order.cpp </code> añadiendo una
	  función virtual en la clase base de la macro
	  <code class="literal">CLASS</code> (que pinte algo) y haciendo el
	  destructor virtual. Cree objetos de las distintas subclases y
	  hagales un upcast a la clase base. Verifique que el
	  comportamiento virtual funciona y que se realiza de forma
	  correcta la construcción y la destrucción del objeto.
	</p></li><li class="listitem"><p>
	  Escriba una clase con tres funciones virtuales
	  sobrecargadas. Herede una nueva clase y sobreescriba una de
	  las funciones. Cree un objeto de la clase derivada. ¿Se puede
	  llamar a todas las funciones de la clase base a través del
	  objeto derivado? Haga un <span class="foreignphrase"><em class="foreignphrase">upcast</em></span>
	  de la dirección del objeto a la base. ¿Se pueden llamar a las
	  tres funciones a través de la base? Elimine la definición
	  sobreescrita en la clase derivada. Ahora ¿Se puede llamar a
	  todas las funciones de la clase base a través del objeto
	  derivado?.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">VariantReturn.cpp</code> para que
	  muestre que su comportamiento funciona con referencias igual
	  que con punteros.
	</p></li><li class="listitem"><p>
	  En <code class="filename">Early.cpp</code>, ¿Cómo se le puede indicar
	  al compilador que haga la llamada usando ligadura estática o
	  ligadura dinámica? Determine el caso para su propio
	  compilador.
	</p></li><li class="listitem"><p>
	  Cree una clase base que contenga una función
	  <code class="function">clone()</code> que devuelva un puntero a una
	  <span class="emphasis"><em>copia</em></span> del objeto actual. Derive dos
	  subclases que sobreescriban <code class="function">clone()</code> para
	  devolver copias de sus tipos específicos. En el
	  <code class="function">main()</code>, cree y haga
	  <span class="foreignphrase"><em class="foreignphrase">upcast</em></span> de sus dos tipos
	  derivados, y llame a <code class="function">clone()</code> para cada
	  uno y verifique que las copias clonadas son de los subtipos
	  correctos. Experimente con su función
	  <code class="function">clone()</code> para que se pueda ir al tipo
	  base, y después intente regresar al tipo exacto derivado. ¿Se
	  le ocurre alguna situación en la que sea necesario esta
	  aproximación?
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">OStackTest.cpp</code> creando su
	  propia clase, después haga multiple herencia con
	  <code class="classname">Object</code> para crear algo que pueda ser
	  introducido en la pila. Pruebe su clase en el
	  <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Añada un tipo llamado <code class="classname">Tensor</code> a
	  <code class="filename">OperartorPolymorphism.cpp</code>.
	</p></li><li class="listitem"><p>
	  (Intermedio) Cree una clase base <code class="classname">X</code> sin
	  datos miembro y sin constructor, pero con una función
	  virtual. Cree una <code class="classname">Y</code> que herede de
	  <code class="classname">X</code>, pero sin un constructor
	  explícito. Genere código ensamblador y examinelo para
	  deteriminar si se crea y se llama un constructor de
	  <code class="classname">X</code> y, si eso ocurre, qué código lo
	  hace. Explique lo que haya
	  descubierto. <code class="classname">X</code> no tiene constructor por
	  defecto, entonces ¿por qué no se queja el compilador?
	</p></li><li class="listitem"><p>
	  (Intermedio) Modifique el Ejercicio 28 escribiendo
	  constructores para ambas clases de tal forma que cada
	  constructor llame a una función virtual. Genere el código
	  ensamblador. Determine donde se encuentra asignado el VPTR
	  dentro del constructor. ¿El compilador está usando el
	  mecanismo virtual dentro del constructor? Explique por qué se
	  sigue usando la version local de la función.
	</p></li><li class="listitem"><p>
	  (Avanzado) Si una función llama a un objeto pasado por valor
	  si ligadura estática, una llamada virtual accede a partes que
	  no existen. ¿Es posible? Escriba un código para forzar una
	  llamada virtual y vea si se produce un cuelgue de la
	  aplicación. Para explicar el comportamiento, observe que
	  ocurre si se pasa un objeto por valor.
	</p></li><li class="listitem"><p>
	  (Avanzado) Encuentre exactamente cuanto tiempo más es
	  necesario para una llamada a una función virtual buscando en
	  la información del lenguaje ensamblador de su procesador o
	  cualquier otro manual técnico y encontrando los pulsos de
	  reloj necesarios para una simple llamada frente al número
	  necesario de las instrucciones de las funciones virtuales.
	</p></li><li class="listitem"><p>
	  Determine el tamaño del VPTR (usando
	  <code class="literal">sizeof</code>) en su implementación. Ahora herede
	  de dos clases (herencia múltiple) que contengan funciones
	  virtuales. ¿Se tiene una o dos VPTR en la clase derivada?
	</p></li><li class="listitem"><p>
	  Cree una clase con datos miembros y funciones
	  virtuales. Escriba una función que mire en la memoria de un
	  objeto de su clase y que imprima sus distintos
	  fragmentos. Para hacer esto será necesario experimentar y de
	  forma iterativa descubrir donde se encuentra alojado el VPTR
	  del objeto.
	</p></li><li class="listitem"><p>
	  Imagine que las funciones virtuales no existen, y modifique
	  <code class="filename">Instrument4.cpp</code> para que use
	  <span class="emphasis"><em>moldeado dinámico</em></span> para hacer el
	  equivalente de las llamadas virtuales. Esplique porque es una
	  mala idea.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">StaicHierarchyNavigation.cpp</code>
	  para que en vez de usar el RTTI de C++ use su propio RTTI via
	  una función virtual en la clase base llamada
	  <code class="function">whatAmI()</code> y un <code class="literal">enum type {
	  Circulos, Cuadrados };</code>.
	</p></li><li class="listitem"><p>
	  Comience con <code class="filename">PointerToMemberOperator.cpp </code>
	  del capítulo 12 y demuestre que el polimorfismo todavía
	  funciona con punteros a miembros, incluso si
	  <code class="literal">operator-&gt;*</code> está sobrecargado.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp8076544" href="#idp8076544" class="para">74</a>] </sup>
	    N del T: Por desgracia <code class="literal">upcasting</code> es otro
	    de los términos a los que no he encontrado una traducción
	    convincente (¿¿amoldar hacia arriba??) y tiene el agravante
	    que deriva de una expresión ampliamente usada por los
	    programadores de C (¿Quién no ha hecho nunca un
	    <code class="literal">cast a void*</code> ;-) ?. Se aceptan
	    sugerencias.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp8129400" href="#idp8129400" class="para">75</a>] </sup>
	    Los compiladores pueden implementar el comportamiento
	    virtual como quieran, pero el modo aquí descrito es una
	    aproximación casi universal.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp8136600" href="#idp8136600" class="para">76</a>] </sup>
	    Algunos compiladores pueden aumentar el tamaño pero sería
	    raro.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp8190624" href="#idp8190624" class="para">77</a>] </sup>
	  Smalltalk, Java y Python, por ejemplo, usan esta aproximación
	  con gran éxito.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8191976" href="#idp8191976" class="para">78</a>] </sup>
	  En los laboratorios Bell, donde se inventó C, hay <span class="emphasis"><em>un
	  montón</em></span> de programadores de C. Hacerlos más
	  eficientes, aunque sea sólo un poco, ahorra a la compañía
	  muchos millones.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8247856" href="#idp8247856" class="para">79</a>] </sup>
	    Actualmente, no todos los punteros tienen el mismo tamaño en
	    todos las máquinas. Sin embargo, en el contexto de esta
	    discusión se pueden considerar iguales.
	  </p></div></div></div><div class="chapter" title="16: Introducción a las Plantillas"><div class="titlepage"><div><div><h2 class="title"><a id="C16"></a>16: Introducción a las Plantillas</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp8472232">16.1. Contenedores</a></span></dt><dt><span class="sect1"><a href="#idp8493592">16.2. Un vistazo a las plantillas</a></span></dt><dt><span class="sect1"><a href="#idp8527032">16.3. Sintaxis del Template</a></span></dt><dt><span class="sect1"><a href="#idp8570088">16.4. Stack y Stash como Plantillas</a></span></dt><dt><span class="sect1"><a href="#idp8617896">16.5. Activando y desactivando la propiedad</a></span></dt><dt><span class="sect1"><a href="#idp8630184">16.6. Manejando objetos por valor</a></span></dt><dt><span class="sect1"><a href="#idp8642600">16.7. Introducción a los iteradores</a></span></dt><dt><span class="sect1"><a href="#idp8739008">16.8. Por qué usar iteradores</a></span></dt><dt><span class="sect1"><a href="#idp8764216">16.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp8769616">16.10. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      La herencia y la composición proporcionan una forma de retilizar
      código objeto.  Las plantillas de C++ proporcionan una manera de
      reutilizar el código <span class="emphasis"><em>fuente</em></span>.
    </p></div><p>
    Aunque las plantillas (o templates) son una herramienta de
    programación de propósito general, cuando fueron introducidos en el
    lenguaje, parecían oponerse al uso de las jerarquías de clases
    contenedoras basadas en objetos (demostrado al final del Capítulo
    15). Además, los contenedores y algoritmos del C++ Standard
    (explicados en dos capítulos del Volumen 2 de este libro, que se
    puede bajar de <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>) están
    construidos exclusivamente con plantillas y son relativamente
    fáciles de usar por el programador.
  </p><p>
    Este capítulo no sólo muestra los fundamentos de los templates,
    también es una introducción a los contenedores, que son componentes
    fundamentales de la programación orientada a objetos lo cual se
    evidencia a través de los contenedores de la librería estándar de
    C++. Se verá que este libro ha estado usando ejemplos contenedores -
    <code class="classname">Stash</code> y <code class="classname">Stack</code>- para
    hacer más sencillo el concepto de los contenedores; en este capítulo
    se sumará el concepto del <code class="classname">iterator</code>. Aunque
    los contenedores son el ejemplo ideal para usarlos con las
    plantillas, en el Volumen 2 (que tiene un capítulo con plantillas
    avanzadas) se aprenderá que también hay otros usos para los
    templates.
  </p><div class="sect1" title="16.1. Contenedores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8472232"></a>16.1. Contenedores</h2></div></div></div><p>
      Supóngase que se quiere crear una pila, como se ha estado haciendo
      a través de este libro. Para hacerlo sencillo, esta clase manejará
      enteros.
    </p><div class="example"><a id="idp8473112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:IntStack.cpp</span>
<span class="hl slc">// Simple integer stack</span>
<span class="hl slc">//{L} fibonacci</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;fibonacci.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> IntStack <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> ssize <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> stack<span class="hl opt">[</span>ssize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> top<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">IntStack</span><span class="hl opt">() :</span> <span class="hl kwd">top</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&lt;</span> ssize<span class="hl opt">,</span> <span class="hl str">&quot;Too many push()es&quot;</span><span class="hl opt">);</span>
    stack<span class="hl opt">[</span>top<span class="hl opt">++] =</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Too many pop()s&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> stack<span class="hl opt">[--</span>top<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  IntStack is<span class="hl opt">;</span>
  <span class="hl slc">// Add some Fibonacci numbers, for interest:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    is<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwd">fibonacci</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl slc">// Pop &amp; print them:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> k<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> is<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.1. C16/IntStack.cpp</strong></p></div><br class="example-break" /><p>
      La clase <code class="classname">IntStack</code> es un ejemplo trivial de
      una pila. Para mantener la simplicidad ha sido creada con un
      tamaño fijo, pero se podría modificar para que automáticamente se
      expanda usando la memoria del montón, como en la clase
      <code class="classname">Stack</code> que ha sido examinada a través del
      libro.
    </p><p>
      <code class="function">main()</code> añade algunos enteros a la pila, y
      posteriormente los extrae.  Para hacer el ejemplo más interesante,
      los enteros son creados con la función
      <code class="function">fibonacci()</code>, que genera los tradicionales
      números de la reproducción del conejo. Aquí está el archivo de
      cabecera que declara la función:
    </p><div class="example"><a id="idp8477592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:fibonacci.h</span>
<span class="hl slc">// Fibonacci number generator</span>
<span class="hl kwb">int</span> <span class="hl kwd">fibonacci</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">);</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.2. C16/fibonacci.h</strong></p></div><br class="example-break" /><p>
      Aquí está la implementación:
    </p><div class="example"><a id="idp8478856"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:fibonacci.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">fibonacci</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span>
  <span class="hl kwb">const int</span> sz <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>n <span class="hl opt">&lt;</span> sz<span class="hl opt">);</span>
  <span class="hl kwb">static int</span> f<span class="hl opt">[</span>sz<span class="hl opt">];</span> <span class="hl slc">// Initialized to zero</span>
  f<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> f<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl slc">// Scan for unfilled array elements:</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>f<span class="hl opt">[</span>i<span class="hl opt">] ==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>i <span class="hl opt">&lt;=</span> n<span class="hl opt">) {</span>
    f<span class="hl opt">[</span>i<span class="hl opt">] =</span> f<span class="hl opt">[</span>i<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">] +</span> f<span class="hl opt">[</span>i<span class="hl opt">-</span><span class="hl num">2</span><span class="hl opt">];</span>
    i<span class="hl opt">++;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> f<span class="hl opt">[</span>n<span class="hl opt">];</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.3. C16/fibonacci.cpp</strong></p></div><br class="example-break" /><p>
      Esta es una implementación bastante eficiente, porque nunca se
      generan los números más de una vez. Se usa un array
      <code class="keyword">static</code> de <code class="type">int</code>, y se basa en el hecho de que
      el compilador inicializará el array estático a cero.  El primer
      bucle <code class="keyword">for</code> mueve el índice <code class="varname">i</code> a la
      primera posición del array que sea cero, entonces un bucle
      <code class="keyword">while</code> añade números Fibonacci al array hasta que se
      alcance el elemento deseado. Hay que hacer notar que si los
      números Fibonacci hasta el elemento <code class="varname">n</code> ya están
      inicializados, entonces también se salta el bucle <code class="keyword">while</code>.
    </p><div class="sect2" title="16.1.1. La necesidad de los contenedores"><div class="titlepage"><div><div><h3 class="title"><a id="idp8484392"></a>16.1.1. La necesidad de los contenedores</h3></div></div></div><p>
	Obviamente, una pila de enteros no es una herramienta
	crucial. La necesidad real de los contenedores viene cuando se
	empizan a crear objetos en el montón (heap) usando <code class="keyword">new</code> y se destruyen con <code class="keyword">delete</code>. En un problema general de
	programación no se saben cuantos objetos van a ser necesarios
	cuando se está escribiendo el programa. Por ejemplo, en un
	sistema de control de tráfico aéreo no se quiere limitar el
	número de aviones que el sistema pueda gestionar. No puede ser
	que el programa se aborte sólo porque se excede algún
	número. En un sistema de diseño asistido por computadora, se
	están manejando montones de formas, pero únicamente el usuario
	determina (en tiempo de ejecución) cuantas formas serán
	necesarias. Una vez apreciemos estas tendencias, se
	descubrirán montones de ejemplos en otras situaciones de
	programación.
      </p><p>
	Los programadores de C que dependen de la memoria virtual para
	manejar su "gestión de memoria" encuentran a menudo como
	perturbantentes las ideas del <code class="keyword">new</code>, <code class="keyword">delete</code> y de los contenedores de
	clases. Aparentemente, una práctica en C es crear un enorme
	array global, más grande que cualquier cosa que el programa
	parezca necesitar. Para esto no es necesario pensar demasiado
	(o hay que meterse en el uso de <code class="function">malloc()</code>
	y <code class="function">free()</code>), pero se producen programas que
	no se pueden portar bien y que esconden sutiles errores.
      </p><p>
	Además, si se crea un enorme array global de objetos en C++,
	la sobrecarga de los constructores y de los destructores
	pueden enlentecer las cosas de forma significativa. La
	aproximación de C++ funciona mucho mejor: Cuando se necesite
	un objeto, se crea con <code class="keyword">new</code>,
	y se pone su puntero en un contenedor. Más tarde, se saca y se
	hace algo con él. De esta forma, sólo se crean los objetos
	cuando sea necesario. Y normalmente no se dan todas las
	condiciones para la inicialización al principio del
	programa. <code class="keyword">new</code> permite
	esperar hasta que suceda algo en el entorno para poder crear
	el objeto.
      </p><p>
	Así, en la situación más común, se creará un contenedor que
	almacene los punteros de algunos objetos de interés. Se
	crearán esos objetos usando <code class="keyword">new</code> y se pondrá el puntero resultante
	en el contenedor (potencialmete haciendo upcasting en el
	proceso), más tarde el objeto se puede recuperar cuando sea
	necesario.  Esta técnica produce el tipo de programas más
	flexible y general.
      </p></div></div><div class="sect1" title="16.2. Un vistazo a las plantillas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8493592"></a>16.2. Un vistazo a las plantillas</h2></div></div></div><p>
      Ahora surge un nuevo problema. Tenemos un
      <code class="classname">IntStack</code>, que maneja enteros. Pero
      queremos una pila que maneje formas, o flotas de aviones, o
      plantas o cualquier otra cosa.  Reinventar el código fuente cada
      vez no parece una aproximación muy inteligente con un lenguaje
      que propugna la reutilización. Debe haber un camino mejor.
    </p><p>
      Hay tres técnicas para reutilizar código en esta situación: el modo
      de C, presentado aquí como contraste; la aproximación de
      Smalltalk, que afectó de forma significativa a C++, y la
      aproximación de C++: los templates.
    </p><p>
      <span class="emphasis"><em>La solución de C</em></span>. Por supuesto hay que
      escapar de la aproximación de C porque es desordenada y provoca
      errores, al mismo tiempo que no es nada elegante. En esta
      aproximación, se copia el código de una <code class="classname">Stack
      </code> y se hacen modificaciones a mano, introduciendo
      nuevos errores en el proceso. Esta no es una técnica muy
      productiva.
    </p><p>
      <span class="emphasis"><em>La solución de Smalltalk</em></span>. Smalltalk (y Java
      siguiendo su ejemplo) optó por una solución simple y directa: Se
      quiere reutilizar código, pues utilicese la herencia. Para
      implementarlo, cada clase contenedora maneja elementos de una
      clase base genérica llamada <code class="classname">Object </code> (similar
      al ejemplo del final del capítulo 15). Pero debido a que la
      librería de Smalltalk es fundamental, no se puede crear una
      clase desde la nada. En su lugar, siempre hay que heredar de una
      clase existente. Se encuentra una clase lo más cercana posible a
      lo que se desea, se hereda de ella, y se hacen un par de
      cambios. Obviamente, esto es un beneficio porque minimiza el
      trabajo (y explica porque se pierde un montón de tiempo
      aprendiendo la librería antes de ser un programador efectivo en
      Smalltalk).
    </p><p>
      Pero también significa que todas las clases de Smalltalk acaban
      siendo parte de un único árbol de herencia. Hay que heredar de
      una rama de este árbol cuando se está creando una nueva
      clase. La mayoría del árbol ya esta allí (es la librería de
      clases de Smalltalk), y la raiz del árbol es una clase llamada
      <code class="classname">Object</code> - la misma clase que los contenedores
      de Smalltalk manejan.
    </p><p>
      Es un truco ingenioso porque significa que cada clase en la
      jerarquía de herencia de Smalltalk (y Java<sup>[<a id="idp8500448" href="#ftn.idp8500448" class="footnote">80</a>]</sup>) se deriva de <code class="classname">Object</code>, por lo
      que cualquier clase puede ser almacenada en cualquier contenedor
      (incluyendo a los propios contenedores). Este tipo de jerarquía
      de árbol única basada en un tipo genérico fundamental (a menudo
      llamado <code class="classname">Object</code>, como también es el caso
      en Java) es conocido como "jerarquía basada en objectos". Se
      puede haber oido este témino y asumido que es un nuevo concepto
      fundamental de la POO, como el polimorfismo. Sin embargo,
      simplemente se refiere a la raíz de la jerarquía como
      <code class="classname">Object </code> (o algún témino similar) y a
      contenedores que almacenan <code class="classname">Object</code>s.
    </p><p>
      Debido a que la librería de clases de Smalltalk tenía mucha más
      experiencia e historia detrás de la que tenía C++, y porque los
      compiladores de C++ originales no tenían librerías de clases
      contenedoras, parecía una buena idea duplicar la librería de
      Smalltalk en C++. Esto se hizo como experimento con una de las
      primeras implementaciónes de C++<sup>[<a id="idp8504208" href="#ftn.idp8504208" class="footnote">81</a>]</sup>, y como representaba un significativo ahorro de
      código mucha gente empezo a usarlo. En el proceso de intentar
      usar las clases contenedoras, descubrieron un problema.
    </p><p>
      El problema es que en Smalltalk (y en la mayoría de los
      lenguajes de POO que yo conozco), todas las clases derivan
      automáticamente de la jerarquía única, pero esto no es cierto en
      C++. Se puede tener una magnifica jerarquía basada en objetos
      con sus clases contenedoras, pero entonces se compra un conjunto
      de clases de figuras, o de aviones de otro vendedor que no usa
      esa jerarquía. (Esto se debe a que usar una jerarquía supone
      sobrecarga, rechazada por los programadores de C). ¿Cómo se
      inserta un árbol de clases independientes en nuestra jerarquía?
      El problema se parece a lo siguiente:
    </p><div class="figure"><a id="idp8506080"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_21.png" align="middle" alt="Contenedores" /></div></div><p class="title"><strong>Figura 16.1. Contenedores</strong></p></div><br class="figure-break" /><p>
      Debido a que C++ suporta múltiples jerarquías independientes, la
      jerarquía basada en objetos de Smalltalk no funciona tan bien.
    </p><p>
      La solución parace obvia. Si se pueden tener múltiples
      jerarquías de herencia, entonces hay que ser capaces de heredar
      de más de una clase: La herencia múltiple resuelve el
      problema. Por lo que se puede hacer lo siguiente (un ejemplo
      similar se dió al final del Capítulo 15).
    </p><div class="figure"><a id="idp8509840"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_22.png" align="middle" alt="Herencia múltiple" /></div></div><p class="title"><strong>Figura 16.2. Herencia múltiple</strong></p></div><br class="figure-break" /><p>
      Ahora <code class="classname">OShape</code> tiene las características y
      el comportamiento de <code class="classname">Shape</code>, pero como
      también está derivado de <code class="classname">Object</code> puede ser
      insertado en el contenedor. La herencia extra dada a
      <code class="classname">OCircle</code>, <code class="classname">OSquare</code>,
      etc. es necesaria para que esas clases puedan hacer upcast hacia
      <code class="classname">OShape </code> y puedan mantener el
      comportamiento correcto. Se puede ver como las cosas se están
      volviendo confusas rápidamente.
    </p><p>
      Los vendedores de compiladores inventaron e incluyeron sus
      propias jerarquías y clases contenedoras, muchas de las cuales
      han sido reemplazadas desde entonces por versiones de templates.
      Se puede argumentar que la herencia múltiple es necesaria para
      resolver problemas de programación general, pero como se verá en
      el Volumen 2 de este libro es mejor evitar esta complejidad
      excepto en casos especiales.
    </p><div class="sect2" title="16.2.1. La solución de la plantilla"><div class="titlepage"><div><div><h3 class="title"><a id="idp8515408"></a>16.2.1. La solución de la plantilla</h3></div></div></div><p>
	Aunque una jerarquía basada en objetos con herencia múltiple
	es conceptualmente correcta, se vuelve difícil de usar. En su
	libro<sup>[<a id="idp8516200" href="#ftn.idp8516200" class="footnote">82</a>]</sup>, Stroustrup demostró
	lo que el consideraba una alternativa preferible a la
	jerarquía basada en objetos.  Clases contenedoras que fueran
	creadas como grandes macros del preprocesador con argumentos
	que pudieran ser sustituidos con el tipo deseado. Cuando se
	quiera crear un contenedor que maneje un tipo en concreto, se
	hacen un par de llamadas a macros.
      </p><p>
	Desafortunadamente, esta aproximación era confusa para toda la
	literatura existente de Smalltalk y para la experiencia de
	programación, y era un poco inmanejable.  Básicamente, nadie
	la entendía.
      </p><p>
	Mientras tanto, Stroustrup y el equipo de C++ de los
	Laboratorios Bell habían modificado su aproximación de las
	macros, simplificándola y moviéndola del dominio del
	preprocesador al compilador. Este nuevo dispositivo de
	sustitución de código se conoce como <code class="keyword">template</code>
	<sup>[<a id="idp8519376" href="#ftn.idp8519376" class="footnote">83</a>]</sup>
	(plantilla), y representa un modo completamente diferente de
	reutilizar el código. En vez de reutilizar código objeto, como
	en la herencia y en la composición, un template reutiliza
	<span class="emphasis"><em>código fuente</em></span>. El contenedor no maneja una
	clase base genérica llamada <code class="classname">Object</code>, si no
	que gestiona un parámetro no especificado. Cuando se usa un
	template, el parámetro es sustituido <span class="emphasis"><em>por el
	compilador</em></span>, parecido a la antigua aproximación de las
	macros, pero más claro y fácil de usar.
      </p><p>
	Ahora, en vez de preocuparse por la herencia o la composición
	cuando se quiera usar una clase contenedora, se usa la versión
	en plantilla del contenedor y se crea una versión específica
	para el problema, como lo siguiente:
      </p><div class="figure"><a id="idp8522736"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V1_23.png" align="middle" alt="Contenedor de objetos Figura" /></div></div><p class="title"><strong>Figura 16.3. Contenedor de objetos <code class="classname">Figura</code></strong></p></div><br class="figure-break" /><p>
	El compilador hace el trabajo por nosotros, y se obtiene el
	contenedor necesario para hacer el trabajo, en vez de una
	jerarquía de herencia inmanejable. En C++, el template
	implementa el concepto de <span class="emphasis"><em>tipo
	  parametrizado</em></span>. Otro beneficio de la aproximación de
	las plantillas es que el programador novato que no tenga
	familiaridad o esté incómodo con la herencia puede usar las
	clases contenedoras de manera adecuada (como se ha estado
	haciendo a lo largo del libro con el
	<code class="classname">vector</code>).

      </p></div></div><div class="sect1" title="16.3. Sintaxis del Template"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8527032"></a>16.3. Sintaxis del Template</h2></div></div></div><p>
      La palabra reservada <code class="keyword">template</code>
      le dice al compilador que la definición de clases que sigue
      manipulará uno o más tipos no especificados. En el momento en
      que el código de la clase actual es generado, los tipos deben
      ser especificados para que el compilador pueda sustituirlos.
    </p><p>
      Para demostrar la sintaxis, aquí está un pequeño ejemplo que
      produce un array con límites comprobados:
    </p><div class="example"><a id="idp8529112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:Array.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Array <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> size <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  T A<span class="hl opt">[</span>size<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp;</span> index <span class="hl opt">&lt;</span> size<span class="hl opt">,</span>
      <span class="hl str">&quot;Index out of range&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> A<span class="hl opt">[</span>index<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Array<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> ia<span class="hl opt">;</span>
  Array<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> fa<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    ia<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> i<span class="hl opt">;</span>
    fa<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwb">float</span><span class="hl opt">(</span>i<span class="hl opt">) *</span> <span class="hl num">1.414</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> j <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> ia<span class="hl opt">[</span>j<span class="hl opt">]</span>
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span> <span class="hl opt">&lt;&lt;</span> fa<span class="hl opt">[</span>j<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.4. C16/Array.cpp</strong></p></div><br class="example-break" /><p>
      Se puede ver que parece una clase normal excepto por la línea.
    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
</pre><p>
      que indica que <em class="parameter"><code>T</code></em> es un parámetro de
      sustitución, y que representa un nombre de un tipo. Además, se
      puede ver que <em class="parameter"><code>T</code></em> es usado en todas las
      partes de la clase donde normalmente se vería al tipo específico
      que el contenedor gestiona.
    </p><p>
      En <code class="classname">Array</code> los elementos son insertados y
      extraidos con la misma función: el operador sobrecargado
      <code class="literal">operator[]</code>. Devuelve una
      referencia, por lo que puede ser usado en ambos lados del signo
      igual (es decir, tanto como <code class="literal">lvalue</code> como
      <code class="literal">rvalue</code>). Hay que hacer notar que si el índice
      se sale de los límites se usa la función <code class="function">require()
      </code> para mostrar un mensaje. Como <code class="literal">operator[] </code> es <code class="keyword">inline</code>, se puede usar esta aproximación
      para garantizar que no se producen violaciones del límite del
      array para entonces eliminar el <code class="function">require()</code>.
    </p><p>
      En el <code class="function">main()</code>, se puede ver lo fácil que es
      crear <code class="classname">Array</code>s que manejen distintos tipos de
      objetos. Cuando se dice:
    </p><pre class="programlisting">
Array<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> ia<span class="hl opt">;</span>
    Array<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> fa<span class="hl opt">;</span>
</pre><p>
      el compilador expande dos veces la plantilla del
      <code class="classname">Array </code> (que se conoce como <code class="keyword">instantiation </code> o crear una instancia),
      para crear dos nuevas <span class="emphasis"><em>clases generadas</em></span>, las
      cuales pueden ser interpretadas como <code class="classname">Array_int
      </code> y <code class="classname">Array_float</code>. Diferentes
      compiladores pueden crear los nombres de diferentes
      maneras. Estas clases son idénticas a las que hubieran producido
      de estar hechas a mano, excepto que el compilador las crea por
      nosotros cuando se definen los objetos <code class="varname">ia </code> y
      <code class="varname">fa</code>. También hay que notar que las
      definiciones de clases duplicadas son eludidas por el
      compilador.
    </p><div class="sect2" title="16.3.1. Definiciones de función no inline"><div class="titlepage"><div><div><h3 class="title"><a id="idp8541704"></a>16.3.1. Definiciones de función no inline</h3></div></div></div><p>
	Por supuesto, hay veces en las que se querrá tener definición
	de funciones no inline. En ese caso, el compilador necesita
	ver la declaración del <code class="keyword">template</code> antes que
	la definición de la función miembro.  Aquí está el ejemplo
	anterior, modificado para mostrar la definición del miembro no
	inline.
      </p><div class="example"><a id="idp8543408"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:Array2.cpp</span>
<span class="hl slc">// Non-inline template definition</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Array <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> size <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  T A<span class="hl opt">[</span>size<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
T<span class="hl opt">&amp;</span> Array<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span><span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp;</span> index <span class="hl opt">&lt;</span> size<span class="hl opt">,</span>
    <span class="hl str">&quot;Index out of range&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> A<span class="hl opt">[</span>index<span class="hl opt">];</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Array<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> fa<span class="hl opt">;</span>
  fa<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl num">1.414</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.5. C16/Array2.cpp</strong></p></div><br class="example-break" /><p>
	Cualquier referencia al nombre de una plantilla de clase debe
	estar acompañado por la lista de argumentos del template, como
	en
	<code class="code">Array&lt;T&gt;operator[]</code>. Se
	puede imaginar que internamente, el nombre de la clase se
	rellena con los argumentos de la lista de argumentos de la
	plantilla para producir un nombre identificador único de la
	clase for cada instanciación de la plantilla.
      </p><div class="sect3" title="Archivos cabecera"><div class="titlepage"><div><div><h4 class="title"><a id="idp8545960"></a>Archivos cabecera</h4></div></div></div><p>
	  Incluso si se crean definiciones de funciones no inline,
	  normalmente se querrá poner todas las declaraciones y
	  definiciones de un template en un archivo cabecera. Esto
	  parece violar la regla usual de los archivos cabecera de
	  «No poner nada que asigne almacenamiento», (lo
	  cual previene múltiples errores de definición en tiempo de
	  enlace), pero las definiciones de plantillas son
	  especial. Algo precedido por
	  <code class="code">template&lt;...&gt; </code>
	  significa que el compilador no asignará almacenamiento en
	  ese momento, sino que se esperará hasta que se lo indiquen
	  (en la instanciación de una plantilla), y que en algún lugar
	  del compilador y del enlazador hay un mecanismo para
	  eliminar las múltiples definiciones de una plantilla
	  idéntica.  Por lo tanto casi siempre se pondrá toda la
	  declaración y definición de la plantilla en el archivo
	  cabecera por facilidad de uso.
	</p><p>
	  Hay veces en las que puede ser necesario poner las
	  definiciones de la plantilla en un archivo <code class="filename">cpp </code> separado para satisfacer
	  necesidades especiales (por ejemplo, forzar las
	  instanciaciones de las plantillas para que se encuentren en
	  un único archivo <code class="filename">dll </code>
	  de Windows). La mayoría de los compiladores tienen algún
	  mecanismo para permitir esto; hay que investigar la
	  documentación del compilador concreto para usarlo.
	</p><p>
	  Algunas personas sienten que poner el código fuente de la
	  implementación en un archivo cabecera hace posible que se
	  pueda robar y modificar el código si se compra la
	  librería. Esto puede ser una característica, pero
	  probablemente dependa del modo de mirar el problema: ¿Se
	  está comprando un producto o un servicio? Si es un producto,
	  entonces hay que hacer todo lo posible por protegerlo, y
	  probablemente no se quiera dar el código fuente, sino sólo
	  el código compilado. Pero mucha gente ve el software como un
	  servicio, incluso más, como un servicio por suscripción. El
	  cliente quiere nuestra pericia, quieren que se mantenga ese
	  fragmento de código reutilizable para no tenerlo que hacer él -
	  para que se pueda enfocar en hacer su propio trabajo.
	  Personalmente creo que la mayoría de los clientes le
	  tratarán como una fuente de recursos a tener en cuenta y no
	  querrán poner en peligro su relación con usted.  Y para los
	  pocos que quieran robar en vez de comprar o hacer el trabajo
	  original, de todas formas probablemante tampoco se
	  mantendrían con usted.
	</p></div></div><div class="sect2" title="16.3.2. IntStack como plantilla"><div class="titlepage"><div><div><h3 class="title"><a id="idp8552720"></a>16.3.2. IntStack como plantilla</h3></div></div></div><p>
	Aquí está el contenedor y el iterador de
	<code class="filename">IntStack.cpp</code>, implementado como una clase
	contenedora genérica usando plantillas:
      </p><div class="example"><a id="idp8553888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:StackTemplate.h</span>
<span class="hl slc">// Simple stack template</span>
<span class="hl ppc">#ifndef STACKTEMPLATE_H</span>
<span class="hl ppc">#define STACKTEMPLATE_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> StackTemplate <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> ssize <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  T stack<span class="hl opt">[</span>ssize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> top<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">StackTemplate</span><span class="hl opt">() :</span> <span class="hl kwd">top</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&lt;</span> ssize<span class="hl opt">,</span> <span class="hl str">&quot;Too many push()es&quot;</span><span class="hl opt">);</span>
    stack<span class="hl opt">[</span>top<span class="hl opt">++] =</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Too many pop()s&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> stack<span class="hl opt">[--</span>top<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">size</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> top<span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STACKTEMPLATE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.6. C16/StackTemplate.h</strong></p></div><br class="example-break" /><p>
	Hay que darse cuenta que esta plantilla asume ciertas
	características de los objetos que está manejando. Por
	ejemplo, <code class="classname">StackTemplate </code> asume que hay
	alguna clase de operación de asignación a <em class="parameter"><code>T
	</code></em> dentro de la función
	<code class="function">push()</code>. Se puede decir que una plantilla
	«implica una interfaz» para los tipos que es
	capaz de manejar.
      </p><p>
	Otra forma de decir esto es que las plantillas proporcionan
	una clase de mecanismo de <span class="emphasis"><em>tipado débil</em></span> en
	C++, lo cual es típico en un lenguaje fuertemente tipado. En
	vez de insistir en que un objeto sea del mismo tipo para que
	sea aceptable, el tipado débil requiere únicamente que la
	función miembro a la que se quiere llamar esté
	<span class="emphasis"><em>disponible</em></span> para un objeto en
	particular. Es decir, el código débilmente tipado puede ser
	aplicado a cualquier objeto que acepte esas llamadas a
	funciones miembro, lo que lo hace mucho más flexible<sup>[<a id="idp8558768" href="#ftn.idp8558768" class="footnote">84</a>]</sup>.
      </p><p>
	Aquí tenemos el objeto revisado para comprobar la plantilla:
      </p><div class="example"><a id="idp8560032"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:StackTemplateTest.cpp</span>
<span class="hl slc">// Test simple stack template</span>
<span class="hl slc">//{L} fibonacci</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;fibonacci.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;StackTemplate.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  StackTemplate<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> is<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    is<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwd">fibonacci</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> k<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> is<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;StackTemplateTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;StackTemplateTest.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  StackTemplate<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> strings<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    strings<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span>line<span class="hl opt">);</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>strings<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> strings<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.7. C16/StackTemplateTest.cpp</strong></p></div><br class="example-break" /><p>
	La única diferencia está en la creación de
	<code class="varname">is</code>. Dentro de la lista de argumentos del
	template hay que especificar el tipo de objeto que la pila y
	el iterador deberán manejar. Para demostrar la genericidad de
	la plantilla, se crea un <code class="classname">StackTemplate </code>
	para manejar <code class="type">string</code>. El ejemplo lee las líneas
	del archivo con el código fuente.
      </p></div><div class="sect2" title="16.3.3. Constantes en los Templates"><div class="titlepage"><div><div><h3 class="title"><a id="idp8563168"></a>16.3.3. Constantes en los Templates</h3></div></div></div><p>
	Los argumentos de los templates no restrigen su uso a tipos
	class; se pueden también usar tipos empotrados. Los valores de
	estos argumentos se convierten en constantes en tiempo de
	compilación para una instanciación en particular de la
	plantilla. Se pueden usar incluso valores por defecto para
	esos argumentos. El siguiente ejemplo nos permite indicar el
	tamaño de la clase <code class="classname">Array </code> durante la
	instanciación, pero también proporciona un valor por defecto:
      </p><div class="example"><a id="idp8564872"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:Array3.cpp</span>
<span class="hl slc">// Built-in types as template arguments</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> size <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Array <span class="hl opt">{</span>
  T array<span class="hl opt">[</span>size<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp;</span> index <span class="hl opt">&lt;</span> size<span class="hl opt">,</span>
      <span class="hl str">&quot;Index out of range&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> array<span class="hl opt">[</span>index<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">length</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> size<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Number <span class="hl opt">{</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Number</span><span class="hl opt">(</span><span class="hl kwb">float</span> ff <span class="hl opt">=</span> <span class="hl num">0.0</span>f<span class="hl opt">) :</span> <span class="hl kwd">f</span><span class="hl opt">(</span>ff<span class="hl opt">) {}</span>
  Number<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Number<span class="hl opt">&amp;</span> n<span class="hl opt">) {</span>
    f <span class="hl opt">=</span> n<span class="hl opt">.</span>f<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">operator</span> <span class="hl kwb">float</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> f<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Number<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span>f<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> size <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Holder <span class="hl opt">{</span>
  Array<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> size<span class="hl opt">&gt;*</span> np<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Holder</span><span class="hl opt">() :</span> <span class="hl kwd">np</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> i <span class="hl opt">&amp;&amp;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>np<span class="hl opt">)</span> np <span class="hl opt">=</span> <span class="hl kwa">new</span> Array<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> size<span class="hl opt">&gt;;</span>
    <span class="hl kwa">return</span> np<span class="hl opt">-&gt;</span><span class="hl kwc">operator</span><span class="hl opt">[](</span>i<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">length</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> size<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Holder</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> np<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Holder<span class="hl opt">&lt;</span>Number<span class="hl opt">&gt;</span> h<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    h<span class="hl opt">[</span>i<span class="hl opt">] =</span> i<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> h<span class="hl opt">[</span>j<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.8. C16/Array3.cpp</strong></p></div><br class="example-break" /><p>
	Como antes, <code class="classname">Array </code> es un array de
	objetos que previene de rebasar los límites.  La clase
	<code class="classname">Holder </code> es muy parecida a
	<code class="classname">Array </code> excepto que tiene un puntero a
	<code class="classname">Array </code> en vez de un tener incrustrado
	un objeto del tipo <code class="classname">Array</code>. Este puntero
	no se inicializa en el constructor; la inicialización es
	retrasada hasta el primer acceso. Esto se conoce como
	<span class="emphasis"><em>inicialización perezosa</em></span>; se puede usar
	una técnica como esta si se están creando un montón de
	objetos, pero no se está accediendo a todos ellos y se quiere
	ahorrar almacenamiento.
      </p><p>
	Hay que resaltar que nunca se almacena internamente el valor
	de <code class="varname">size</code> en la clase, pero se usa como si
	fuera un dato interno dentro de las funciones miembro.
      </p></div></div><div class="sect1" title="16.4. Stack y Stash como Plantillas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8570088"></a>16.4. Stack y Stash como Plantillas</h2></div></div></div><p>
      Los problemas recurrentes de «propiedad» con las
      clases contenedoras <code class="classname">Stack</code> y
      <code class="classname">Stash </code> (Pila y Cola respectivamente) que
      han sido usadas varias veces a través del libro, vienen del
      hecho de que estos contenedores no son capaces de saber
      exactamente que tipo manejan. Lo más cerca que han estado es en
      el «contenedor» de objectos <code class="classname">Stack
      </code> que se vio al final del capítulo 15 en
      <code class="filename">OStackTest.cpp</code>.
    </p><p>
      Si el programador cliente no elimina explícitamente todos los
      punteros a objeto que están almacenados en el contenedor,
      entonces el contenedor debería ser capaz de eliminar esos
      punteros de manera adecuada. Es decir, el contenedor
      «posee» cualquiera de los objetos que no hayan sido
      eliminados, y es el responsable de limpiarlos. La dificultad
      radica en que el limpiado requiere conocer el tipo del objeto, y
      crear un contenedor genérico <span class="emphasis"><em>no </em></span> requiere
      conocer el tipo de ese objeto. Con los templates, sin embargo,
      podemos escribir código que no conozcan el tipo de objeto, y
      fácilmente instanciar una nueva versión del contenedor por cada
      tipo que queramos que contenga. La instancia contenedora
      individual <span class="emphasis"><em>conoce </em></span> el tipo de objetos que
      maneja y puede por tanto llamar al destructor correcto
      (asumiendo que se haya proporcionado un destructor virtual).
    </p><p>
      Para la pila es bastante sencillo debido a todas las funciones
      miembro pueden ser introducidas en línea:
    </p><div class="example"><a id="idp8575816"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TStack.h</span>
<span class="hl slc">// The Stack as a template</span>
<span class="hl ppc">#ifndef TSTACK_H</span>
<span class="hl ppc">#define TSTACK_H</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    T<span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwd">Link</span><span class="hl opt">(</span>T<span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">):</span> 
      <span class="hl kwd">data</span><span class="hl opt">(</span>dat<span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span>nxt<span class="hl opt">) {}</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() :</span> <span class="hl kwd">head</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Stack</span><span class="hl opt">(){</span> 
    <span class="hl kwa">while</span><span class="hl opt">(</span>head<span class="hl opt">)</span>
      <span class="hl kwa">delete</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>T<span class="hl opt">*</span> dat<span class="hl opt">) {</span>
    head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span> head<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> head ? head<span class="hl opt">-&gt;</span>data <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">(){</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
    T<span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
    head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
    <span class="hl kwa">return</span> result<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TSTACK_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.9. C16/TStack.h</strong></p></div><br class="example-break" /><p>
      Si se compara esto al ejemplo de <code class="filename">OStack.h </code> al
      final del capítulo 15, se verá que <code class="classname">Stack </code> es
      virtualmente idéntica, excepto que <code class="classname">Object </code> ha
      sido reemplazado con <em class="parameter"><code>T</code></em>. El programa de prueba
      también es casi idéntico, excepto por la necesidad de múltiple
      herencia de <code class="type">string </code> y <code class="classname">Object
      </code> (incluso por la necesidad de <code class="classname">Object
      </code> en sí mismo) que ha sido eliminada. Ahora no tenemos
      una clase <code class="classname">MyString </code> para anunciar su
      destrucción por lo que añadimos una pequeña clase nueva para
      mostrar como la clase contenedora <code class="classname">Stack </code>
      limpia sus objetos:
    </p><div class="example"><a id="idp8581096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TStackTest.cpp</span>
<span class="hl slc">//{T} TStackTest.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TStack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">X</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~X &quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// File name is argument</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  Stack<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> textlines<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl slc">// Read file and store lines in the Stack:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Pop some lines from the stack:</span>
  string<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwa">if</span><span class="hl opt">((</span>s <span class="hl opt">= (</span>string<span class="hl opt">*)</span>textlines<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">())==</span><span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt; *</span>s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span> 
  <span class="hl opt">}</span> <span class="hl slc">// The destructor deletes the other strings.</span>
  <span class="hl slc">// Show that correct destruction happens:</span>
  Stack<span class="hl opt">&lt;</span>X<span class="hl opt">&gt;</span> xx<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> j<span class="hl opt">++)</span>
    xx<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> X<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.10. C16/TStackTest.cpp</strong></p></div><br class="example-break" /><p>
      El destructor de <code class="classname">X </code> es virtual, no porque se
      sea necesario aquí, sino porque <code class="varname">xx</code> podría
      ser usado más tarde para manejar objetos derivados de
      <code class="classname">X</code>.
    </p><p>
      Note lo fácil que es crear diferentes clases de
      <code class="classname">Stack</code>s para <code class="type">string</code> y para
      <code class="classname">X</code>. Debido a la plantilla, se consigue lo
      mejor de los dos mundos: la facilidad de uso de la
      <code class="classname">Stack </code> junto con un limpiado correcto.
    </p><div class="sect2" title="16.4.1. Cola de punteros mediante plantillas"><div class="titlepage"><div><div><h3 class="title"><a id="idp8585808"></a>16.4.1. Cola de punteros mediante plantillas</h3></div></div></div><p>
	Reorganizar el código de <code class="classname">PStash </code> en un
	template no es tan simple porque hay un número de funciones
	miembro que no deben estar en línea. Sin embargo, como buena
	plantilla aquellas definiciones de función deben permanecer en
	el archivo cabecera (el compilador y el enlazador se
	preocuparán por los problemas de múltiples definiciones). El
	código parece bastante similar al <code class="classname">PStash
	</code> ordinario excepto que el tamaño del incremento
	(usado por <code class="function">inflate()</code>) ha sido puesto en
	el template como un parámetro no de clase con un valor por
	defecto, para que el tamaño de incremento pueda ser modificado
	en el momento de la instanciación (esto significa que el
	tamaño es fijo aunque se podría argumentar que el tamaño de
	incremento debería ser cambiable a lo largo de la vida del
	objeto):
      </p><div class="example"><a id="idp8588720"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TPStash.h</span>
<span class="hl ppc">#ifndef TPSTASH_H</span>
<span class="hl ppc">#define TPSTASH_H</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> PStash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span> <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span> <span class="hl slc">// Next empty space</span>
  T<span class="hl opt">**</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase <span class="hl opt">=</span> incr<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">PStash</span><span class="hl opt">() :</span> <span class="hl kwd">quantity</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">storage</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">PStash</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span>T<span class="hl opt">*</span> element<span class="hl opt">);</span>
  T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span> <span class="hl slc">// Fetch</span>
  <span class="hl slc">// Remove the reference from this PStash:</span>
  T<span class="hl opt">*</span> <span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl slc">// Number of elements in Stash:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> next<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
<span class="hl kwb">int</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwd">add</span><span class="hl opt">(</span>T<span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>incr<span class="hl opt">);</span>
  storage<span class="hl opt">[</span>next<span class="hl opt">++] =</span> element<span class="hl opt">;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl slc">// Ownership of remaining pointers:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::~</span><span class="hl kwd">PStash</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> next<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwa">delete</span> storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Null pointers OK</span>
    storage<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// Just to be safe</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
T<span class="hl opt">*</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">,</span>
    <span class="hl str">&quot;PStash::operator[] index negative&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>storage<span class="hl opt">[</span>index<span class="hl opt">] !=</span> <span class="hl num">0</span><span class="hl opt">,</span> 
    <span class="hl str">&quot;PStash::operator[] returned null pointer&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> storage<span class="hl opt">[</span>index<span class="hl opt">];</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
T<span class="hl opt">*</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl slc">// operator[] performs validity checks:</span>
  T<span class="hl opt">*</span> v <span class="hl opt">=</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span>index<span class="hl opt">);</span>
  <span class="hl slc">// &quot;Remove&quot; the pointer:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>v <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">)</span> storage<span class="hl opt">[</span>index<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> v<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwb">const int</span> psz <span class="hl opt">=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>T<span class="hl opt">*);</span>
  T<span class="hl opt">**</span> st <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">*[</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">];</span>
  <span class="hl kwd">memset</span><span class="hl opt">(</span>st<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">, (</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">) *</span> psz<span class="hl opt">);</span>
  <span class="hl kwd">memcpy</span><span class="hl opt">(</span>st<span class="hl opt">,</span> storage<span class="hl opt">,</span> quantity <span class="hl opt">*</span> psz<span class="hl opt">);</span>
  quantity <span class="hl opt">+=</span> increase<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span> <span class="hl slc">// Old storage</span>
  storage <span class="hl opt">=</span> st<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TPSTASH_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.11. C16/TPStash.h</strong></p></div><br class="example-break" /><p>
	El tamaño del incremento por defecto es muy pequeño para
	garantizar que se produzca la llamada a
	<code class="function">inflate()</code>. Esto nos asegura que funcione
	correctamente.
      </p><p>
	Para comprobar el control de propiedad de <code class="classname">PStack
	</code> en template, la siguiente clase muestra informes
	de creación y destrucción de elementos, y también garantiza
	que todos los objetos que hayan sido creados sean destruidos.
	<code class="classname">AutoCounter </code> permitirá crear objetos en
	la pila sólo a los objetos de su tipo:
      </p><div class="example"><a id="idp8594360"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:AutoCounter.h</span>
<span class="hl ppc">#ifndef AUTOCOUNTER_H</span>
<span class="hl ppc">#define AUTOCOUNTER_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;set&gt;</span> <span class="hl slc">// Standard C++ Library container</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;string&gt;</span>

<span class="hl kwc">class</span> AutoCounter <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> count<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
  <span class="hl kwc">class</span> CleanupCheck <span class="hl opt">{</span>
    std<span class="hl opt">::</span>set<span class="hl opt">&lt;</span>AutoCounter<span class="hl opt">*&gt;</span> trace<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">add</span><span class="hl opt">(</span>AutoCounter<span class="hl opt">*</span> ap<span class="hl opt">) {</span>
      trace<span class="hl opt">.</span><span class="hl kwd">insert</span><span class="hl opt">(</span>ap<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">remove</span><span class="hl opt">(</span>AutoCounter<span class="hl opt">*</span> ap<span class="hl opt">) {</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>trace<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(</span>ap<span class="hl opt">) ==</span> <span class="hl num">1</span><span class="hl opt">,</span>
        <span class="hl str">&quot;Attempt to delete AutoCounter twice&quot;</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl opt">~</span><span class="hl kwd">CleanupCheck</span><span class="hl opt">() {</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~CleanupCheck()&quot;</span><span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>trace<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() ==</span> <span class="hl num">0</span><span class="hl opt">,</span>
       <span class="hl str">&quot;All AutoCounter objects not cleaned up&quot;</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  <span class="hl kwb">static</span> CleanupCheck verifier<span class="hl opt">;</span>
  <span class="hl kwd">AutoCounter</span><span class="hl opt">() :</span> <span class="hl kwd">id</span><span class="hl opt">(</span>count<span class="hl opt">++) {</span>
    verifier<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span> <span class="hl slc">// Register itself</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;created[&quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;]&quot;</span> 
              <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Prevent assignment and copy-construction:</span>
  <span class="hl kwd">AutoCounter</span><span class="hl opt">(</span><span class="hl kwb">const</span> AutoCounter<span class="hl opt">&amp;);</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> AutoCounter<span class="hl opt">&amp;);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// You can only create objects with this:</span>
  <span class="hl kwb">static</span> AutoCounter<span class="hl opt">*</span> <span class="hl kwd">create</span><span class="hl opt">() {</span> 
    <span class="hl kwa">return new</span> <span class="hl kwd">AutoCounter</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">AutoCounter</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;destroying[&quot;</span> <span class="hl opt">&lt;&lt;</span> id 
              <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;]&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    verifier<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Print both objects and pointers:</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>
    std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> AutoCounter<span class="hl opt">&amp;</span> ac<span class="hl opt">){</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;AutoCounter &quot;</span> <span class="hl opt">&lt;&lt;</span> ac<span class="hl opt">.</span>id<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>
    std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> AutoCounter<span class="hl opt">*</span> ac<span class="hl opt">){</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;AutoCounter &quot;</span> <span class="hl opt">&lt;&lt;</span> ac<span class="hl opt">-&gt;</span>id<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> 
<span class="hl ppc">#endif</span> <span class="hl slc">// AUTOCOUNTER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.12. C16/AutoCounter.h</strong></p></div><br class="example-break" /><p>
	La clase <code class="classname">AutoCounter </code> hace dos
	cosas. Primero, numera cada instancia de <code class="classname">AutoCounter
	</code> de forma secuencial: el valor de este número se
	guarda en <code class="varname">id</code>, y el número se genera usando
	el dato miembro <code class="varname">count </code> que es
	<code class="keyword">static</code>.
      </p><p>
	Segundo, y más complejo, una instancia estática (llamada
	<code class="varname">verifier</code>) de la clase
	<code class="classname">CleanupCheck </code> se mantiene al tanto de
	todos los objetos <code class="classname">AutoCounter </code> que son
	creados y destruidos, y nos informa si no se han limpiado
	todos (por ejemplo si existe un agujero en memoria). Este
	comportamiento se completa con el uso de la clase
	<code class="classname">set</code> de la Librería Estándar de C++, lo
	cual es un magnífico ejemplo de cómo las plantillas bien
	diseñadas nos pueden hacer la vida más fácil (se podrá
	aprender más de los contenedores en el Volumen 2 de este
	libro).
      </p><p>
	La clase <code class="classname">set </code> está instanciada para el tipo
	que maneja; aquí hay una instancia que maneja punteros a
	<code class="classname">AutoCounter</code>. Un <code class="classname">set </code>
	permite que se inserte sólo una instancia de cada objeto; en
	<code class="function">add() </code> se puede ver que esto sucede con la
	función <code class="function">set::insert()</code>.  <code class="function">insert()
	</code> nos informa con su valor de retorno si se está
	intentando añadir algo que ya se había incluido; sin embargo,
	desde el momento en que las direcciones a objetos se inserten
	podemos confiar en C++ para que garantice que todos los
	objetos tengan direcciones únicas.
      </p><p>
	En <code class="function">remove()</code>, se usa <code class="function">set::erase()
	</code> para eliminar un puntero a <code class="classname">AutoCounter
	</code> del <code class="classname">set</code>. El valor de retorno
	indica cuantas instancias del elemento se han eliminado; en
	nuestro caso el valor puede ser únicamente uno o cero. Si el
	valor es cero, sin embargo, significa que el objeto ya había
	sido borrado del conjunto y que se está intentando borrar por
	segunda vez, lo cual es un error de programación que debe ser
	mostrado mediante <code class="function">require()</code>.
      </p><p>
	El destructor de <code class="classname">CleanupCheck </code> hace una
	comprobación final asegurándose de que el tamaño del
	<code class="classname">set </code> es cero - Lo que significa que todos
	los objetos han sido eliminados de manera adecuada. Si no es
	cero, se tiene un agujero de memoria, lo cual se muestra
	mediante el <code class="function">require()</code>.
      </p><p>
	El constructor y el destructor de <code class="classname">AutoCounter
	</code> se registra y desregistra con el objeto
	<code class="varname">verifier</code>. Hay que resaltar que el
	constructor, el constructor de copia, y el operador de
	asignación son <code class="keyword">private</code>, por
	lo que la única forma de crear un objeto es con la función
	miembro <code class="function">static create() </code> - esto es un
	ejemplo sencillo de una <code class="literal">factory</code>, y
	garantiza que todos los objetos sean creados en el montón
	(heap), por lo que <code class="varname">verifier</code> no se verá
	confundido con sobreasignaciones y construcciones de copia.
      </p><p>
	Como todas las funciones miembro han sido definidas inline, la
	única razón para el archivo de implementación es que contenga
	las definiciones de los datos miembro:
      </p><div class="example"><a id="idp8610760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:AutoCounter.cpp {O}</span>
<span class="hl slc">// Definition of static class members</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;AutoCounter.h&quot;</span><span class="hl ppc"></span>
AutoCounter<span class="hl opt">::</span>CleanupCheck AutoCounter<span class="hl opt">::</span>verifier<span class="hl opt">;</span>
<span class="hl kwb">int</span> AutoCounter<span class="hl opt">::</span>count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.13. C16/AutoCounter.cpp</strong></p></div><br class="example-break" /><p>
	Con el <code class="classname">AutoCounter </code> en la mano, podemos
	comprobar las facilidades que proporciona el
	<code class="classname">PStash</code>. El siguiente ejemplo no sólo
	muestra que el destructor de <code class="classname">PStash </code> limpia
	todos los objetos que posee, sino que también muestra como la
	clase <code class="classname">AutoCounter </code> detecta a los objetos
	que no se han limpiado.
      </p><div class="example"><a id="idp8613336"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TPStashTest.cpp</span>
<span class="hl slc">//{L} AutoCounter</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;AutoCounter.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TPStash.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  PStash<span class="hl opt">&lt;</span>AutoCounter<span class="hl opt">&gt;</span> acStash<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    acStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span>AutoCounter<span class="hl opt">::</span><span class="hl kwd">create</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Removing 5 manually:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> j<span class="hl opt">++)</span>
    <span class="hl kwa">delete</span> acStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span>j<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Remove two without deleting them:&quot;</span>
       <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// ... to generate the cleanup error message.</span>
  cout <span class="hl opt">&lt;&lt;</span> acStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> acStash<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl num">6</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;The destructor cleans up the rest:&quot;</span>
       <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Repeat the test from earlier chapters: </span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;TPStashTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;TPStashTest.cpp&quot;</span><span class="hl opt">);</span>
  PStash<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> stringStash<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    stringStash<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl slc">// Print out the strings:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> u <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> stringStash<span class="hl opt">[</span>u<span class="hl opt">];</span> u<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;stringStash[&quot;</span> <span class="hl opt">&lt;&lt;</span> u <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span>
         <span class="hl opt">&lt;&lt; *</span>stringStash<span class="hl opt">[</span>u<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.14. C16/TPStashTest.cpp</strong></p></div><br class="example-break" /><p>
	Cuando se eliminan los elementos <code class="classname">AutoCounter
	</code> 5 y 6 de la <code class="classname">PStash</code>, se
	vuelve responsabilidad del que los llama, pero como el cliente
	nunca los borra se podrín producir agujeros de memoria, que
	serín detectados por <code class="classname">AutoCounter </code> en
	tiempo de ejecución.
      </p><p>
	Cuando se ejecuta el programa, se verá que el mensaje de error
	no es tan específico como podría ser. Si se usa el esquema
	presentado en <code class="classname">AutoCounter </code> para
	descubrir agujeros de memoria en nuestro sistema,
	probablemente se quiera imprimir información más detallada
	sobre los objetos que no se hayan limpiado. El Volumen 2 de
	este libro muestra algunas formas más sofisticadas de hacer
	esto.
      </p></div></div><div class="sect1" title="16.5. Activando y desactivando la propiedad"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8617896"></a>16.5. Activando y desactivando la propiedad</h2></div></div></div><p>
      Volvamos al problema del propietario. Los contenedores que
      manejan objetos por valor normalmente no se preocupan por la
      propiedad porque claramente poseen los objetos que
      contienen. Pero si el contenedor gestiona punteros (lo cual es
      común en C++, especialmente con el polimorfismo), entonces es
      bastante probable que esos punteros sean usados en algún otro
      lado del programa, y no necesariamente se quiere borrar el
      objeto porque los otros punteros del programa estarán
      referenciando a un objeto destruido. Para prevenir que esto
      ocurra, hay que considerar al propietario cuando se está
      diseñando y usando un contenedor.
    </p><p>
      Muchos programas son más simples que este, y no se encuentran
      con el problema de la propiedad: Un contenedor que maneja
      punteros a objetos y que son usados sólo por ese contenedor. En
      este caso el propietario es evidente: El contenedor posee sus
      objetos.
    </p><p>
      La mejor aproximación para gestionar quién es el propietario es
      dar al programador cliente una elección. Esto se puede realizar
      con un argumento en el constructor que por defecto defina al
      propietario (el caso más sencillo). Además habrá que poner las
      funciones «get» y «set» para poder ver
      y modificar al propietario del contenedor. Si el contenedor
      tiene funciones para eliminar un objeto, el estado de propiedad
      normalmente afecta a la función de eliminación, por lo que se
      deberían encontrar opciones para controlar la destrucción en la
      función de eliminación. Es concebible que se añadan datos
      propietarios por cada elemento que contenga el contenedor, por
      lo que cada posición debería saber cuando es necesario ser
      destruido; esto es una variante del conteo de referencias,
      excepto en que es el contenedor y no el objeto el que conoce el
      número de referencias a un objeto.
    </p><div class="example"><a id="idp8622552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:OwnerStack.h</span>
<span class="hl slc">// Stack with runtime conrollable ownership</span>
<span class="hl ppc">#ifndef OWNERSTACK_H</span>
<span class="hl ppc">#define OWNERSTACK_H</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    T<span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwd">Link</span><span class="hl opt">(</span>T<span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">)</span> 
      <span class="hl opt">:</span> <span class="hl kwd">data</span><span class="hl opt">(</span>dat<span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span>nxt<span class="hl opt">) {}</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> own<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">(</span><span class="hl kwb">bool</span> own <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">) :</span> <span class="hl kwd">head</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">own</span><span class="hl opt">(</span>own<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Stack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>T<span class="hl opt">*</span> dat<span class="hl opt">) {</span>
    head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span>head<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    <span class="hl kwa">return</span> head ? head<span class="hl opt">-&gt;</span>data <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">;</span> 
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">owns</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> own<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">owns</span><span class="hl opt">(</span><span class="hl kwb">bool</span> newownership<span class="hl opt">) {</span>
    own <span class="hl opt">=</span> newownership<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Auto-type conversion: true if not empty:</span>
  <span class="hl kwc">operator</span> <span class="hl kwb">bool</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> head <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> T<span class="hl opt">*</span> Stack<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span><span class="hl kwd">pop</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  T<span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
  Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
  head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
  <span class="hl kwa">return</span> result<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> Stack<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::~</span><span class="hl kwd">Stack</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>own<span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>head<span class="hl opt">)</span>
    <span class="hl kwa">delete</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OWNERSTACK_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.15. C16/OwnerStack.h</strong></p></div><br class="example-break" /><p>
      El comportamiento por defecto del contenedor consiste en
      destruir sus objetos pero se puede cambiar o modificando el
      argumento del constructor o usando las funciones miembro de
      <code class="function">owns()</code>.
    </p><p>
      Como con la mayoría de las plantillas que se verán, la
      implementación entera se encuentra en el archivo de
      cabecera. Aquí tenemos un pequeño test que muestra las
      capacidades de la propiedad:
    </p><div class="example"><a id="idp8625984"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:OwnerStackTest.cpp</span>
<span class="hl slc">//{L} AutoCounter </span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;AutoCounter.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;OwnerStack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stack<span class="hl opt">&lt;</span>AutoCounter<span class="hl opt">&gt;</span> ac<span class="hl opt">;</span> <span class="hl slc">// Ownership on</span>
  Stack<span class="hl opt">&lt;</span>AutoCounter<span class="hl opt">&gt;</span> <span class="hl kwd">ac2</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">);</span> <span class="hl slc">// Turn it off</span>
  AutoCounter<span class="hl opt">*</span> ap<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    ap <span class="hl opt">=</span> AutoCounter<span class="hl opt">::</span><span class="hl kwd">create</span><span class="hl opt">();</span>
    ac<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span>ap<span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">%</span> <span class="hl num">2</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
      ac2<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span>ap<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>ac2<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> ac2<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// No destruction necessary since</span>
  <span class="hl slc">// ac &quot;owns&quot; all the objects</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.16. C16/OwnerStackTest.cpp</strong></p></div><br class="example-break" /><p>
      El objeto <code class="varname">ac2 </code> no posee los objetos que
      pusimos en él, sin embargo <code class="varname">ac </code> es un
      contenedor «maestro» que tiene la responsabilidad
      de ser el propietario de los objetos. Si en algún momento de la
      vida de un contenedor se quiere cambiar el que un contenedor
      posea a sus objetos, se puede hacer usando
      <code class="function">owns()</code>.
    </p><p>
      También sería posible cambiar la granularidad de la propiedad
      para que estuviera en la base, es decir, objeto por
      objeto. Esto, sin embargo, probablemente haría a la solución del
      problema del propietario más complejo que el propio problema.
    </p></div><div class="sect1" title="16.6. Manejando objetos por valor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8630184"></a>16.6. Manejando objetos por valor</h2></div></div></div><p>
      Actualmente crear una copia de los objetos dentro de un
      contenedor genérico sería un problema complejo si no se tuvieran
      plantillas. Con los templates las cosas se vuelven relativamente
      sencillas - sólo hay que indicar que se están manejando objetos
      en vez de punteros:
    </p><div class="example"><a id="idp8631352"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:ValueStack.h</span>
<span class="hl slc">// Holding objects by value in a Stack</span>
<span class="hl ppc">#ifndef VALUESTACK_H</span>
<span class="hl ppc">#define VALUESTACK_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> ssize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl slc">// Default constructor performs object</span>
  <span class="hl slc">// initialization for each element in array:</span>
  T stack<span class="hl opt">[</span>ssize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> top<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() :</span> <span class="hl kwd">top</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl slc">// Copy-constructor copies object into array:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&lt;</span> ssize<span class="hl opt">,</span> <span class="hl str">&quot;Too many push()es&quot;</span><span class="hl opt">);</span>
    stack<span class="hl opt">[</span>top<span class="hl opt">++] =</span> x<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> stack<span class="hl opt">[</span>top<span class="hl opt">]; }</span>
  <span class="hl slc">// Object still exists when you pop it; </span>
  <span class="hl slc">// it just isn't available anymore:</span>
  T <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Too many pop()s&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> stack<span class="hl opt">[--</span>top<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// VALUESTACK_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.17. C16/ValueStack.h</strong></p></div><br class="example-break" /><p>
      El constructor de copia de los objetos contenidos hacen la
      mayoría del trabajo pasando y devolviendo objetos por
      valor. Dentro de <code class="function">push()</code>, el almacenamiento
      del objeto en el array <code class="classname">Stack </code> viene
      acompañado con <code class="function">T::operator=</code>.  Para
      garantizar que funciona, una clase llamada
      <code class="classname">SelfCounter </code> mantiene una lista de las
      creaciones y construcciones de copia de los objetos.
    </p><div class="example"><a id="idp8635192"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:SelfCounter.h</span>
<span class="hl ppc">#ifndef SELFCOUNTER_H</span>
<span class="hl ppc">#define SELFCOUNTER_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ValueStack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwc">class</span> SelfCounter <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> counter<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">SelfCounter</span><span class="hl opt">() :</span> <span class="hl kwd">id</span><span class="hl opt">(</span>counter<span class="hl opt">++) {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Created: &quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">SelfCounter</span><span class="hl opt">(</span><span class="hl kwb">const</span> SelfCounter<span class="hl opt">&amp;</span> rv<span class="hl opt">) :</span> <span class="hl kwd">id</span><span class="hl opt">(</span>rv<span class="hl opt">.</span>id<span class="hl opt">){</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Copied: &quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  SelfCounter <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> SelfCounter<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Assigned &quot;</span> <span class="hl opt">&lt;&lt;</span> rv<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; to &quot;</span> 
              <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">SelfCounter</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Destroyed: &quot;</span><span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span> 
    std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> SelfCounter<span class="hl opt">&amp;</span> sc<span class="hl opt">){</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;SelfCounter: &quot;</span> <span class="hl opt">&lt;&lt;</span> sc<span class="hl opt">.</span>id<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// SELFCOUNTER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.18. C16/SelfCounter.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp8637416"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:SelfCounter.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;SelfCounter.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">int</span> SelfCounter<span class="hl opt">::</span>counter <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.19. C16/SelfCounter.cpp</strong></p></div><br class="example-break" /><div class="example"><a id="idp8638400"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:ValueStackTest.cpp</span>
<span class="hl slc">//{L} SelfCounter</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ValueStack.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;SelfCounter.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stack<span class="hl opt">&lt;</span>SelfCounter<span class="hl opt">&gt;</span> sc<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    sc<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwd">SelfCounter</span><span class="hl opt">());</span>
  <span class="hl slc">// OK to peek(), result is a temporary:</span>
  cout <span class="hl opt">&lt;&lt;</span> sc<span class="hl opt">.</span><span class="hl kwd">peek</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> k <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> k <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> k<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> sc<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.20. C16/ValueStackTest.cpp</strong></p></div><br class="example-break" /><p>
      Cuando se crea un contenedor <code class="classname">Stack</code>, el
      constructor por defecto del objeto a contener es ejecutado por
      cada objeto en el array. Inicialmente se verán 100 objetos
      <code class="classname">SelfCounter </code> creados sin ningún motivo
      aparente, pero esto es justamente la inicialización del
      array. Esto puede resultar un poco caro, pero no existe ningún
      problema en un diseño simple como este. Incluso en situaciones
      más complejas si se hace a <code class="classname">Stack </code> más general
      permitiendo que crezca dinámicamente, porque en la
      implementación mostrada anteriormente esto implicaría crear un
      nuevo array más grande, copiando el anterior al nuevo y
      destruyendo el antiguo array (de hecho, así es como lo hace la
      clase <code class="classname">vector </code> de la Librería Estándar de
      C++).
    </p></div><div class="sect1" title="16.7. Introducción a los iteradores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8642600"></a>16.7. Introducción a los iteradores</h2></div></div></div><p>
      Un <code class="literal">iterator </code> es un objeto que se mueve a
      través de un contenedor de otros objetos y selecciona a uno de
      ellos cada vez, sin porporcionar un acceso directo a la
      implementación del contenedor. Los iteradores proporcionan una
      forma estándar de acceder a los elementos, sin importar si un
      contenedor proporciona alguna marnera de acceder a los elementos
      directamente.  Se verán a los iteradores usados frecuentemente
      en asociación con clases contenedoras, y los iteradores son un
      concepto fundamental en el diseño y el uso de los contenedores
      del Standard C++, los cuales son descritos en el Volumen 2 de
      este libro (que se puede bajar de <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>. Un
      iterador es también un tipo de <span class="emphasis"><em>patrón de
	diseño</em></span>, lo cual es materia de un capítulo del Volumen
      2.
    </p><p>
      En muchos sentidos, un iterador es un «puntero
	elegante», y de hecho se verá que los iteradores
      normalmente ocultan la mayoría de las operaciones de los
      punteros. Sin embargo, al contrario que un puntero, el iterador
      es diseñado para ser seguro por lo que es mucho menos probable
      de hacer el equivalente de avanzar atravesando el final de un
      array (o si se hace, se encontrará más fácilmente).
    </p><p>
      Considere el primer ejemplo de este capítulo. Aquí está pero
      añadiendo un iterador sencillo:
    </p><div class="example"><a id="idp8647392"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:IterIntStack.cpp</span>
<span class="hl slc">// Simple integer stack with iterators</span>
<span class="hl slc">//{L} fibonacci</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;fibonacci.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> IntStack <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> ssize <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> stack<span class="hl opt">[</span>ssize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> top<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">IntStack</span><span class="hl opt">() :</span> <span class="hl kwd">top</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&lt;</span> ssize<span class="hl opt">,</span> <span class="hl str">&quot;Too many push()es&quot;</span><span class="hl opt">);</span>
    stack<span class="hl opt">[</span>top<span class="hl opt">++] =</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Too many pop()s&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> stack<span class="hl opt">[--</span>top<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend class</span> IntStackIter<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl slc">// An iterator is like a &quot;smart&quot; pointer:</span>
<span class="hl kwc">class</span> IntStackIter <span class="hl opt">{</span>
  IntStack<span class="hl opt">&amp;</span> s<span class="hl opt">;</span>
  <span class="hl kwb">int</span> index<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">IntStackIter</span><span class="hl opt">(</span>IntStack<span class="hl opt">&amp;</span> is<span class="hl opt">) :</span> <span class="hl kwd">s</span><span class="hl opt">(</span>is<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl slc">// Prefix</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span> 
      <span class="hl str">&quot;iterator moved out of range&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[++</span>index<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span> 
      <span class="hl str">&quot;iterator moved out of range&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[</span>index<span class="hl opt">++];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  IntStack is<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    is<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwd">fibonacci</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl slc">// Traverse with an iterator:</span>
  IntStackIter <span class="hl kwd">it</span><span class="hl opt">(</span>is<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> j<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> it<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.21. C16/IterIntStack.cpp</strong></p></div><br class="example-break" /><p>
      El <code class="classname">IntStackIter </code> ha sido creado para
      trabajar solo con un <code class="classname">IntStack</code>.  Hay que
      resaltar que <code class="classname">IntStackIter </code> es un <code class="keyword">friend
      </code> de <code class="classname">IntStack</code>, lo que lo da un acceso a
      todos los elementos privados de <code class="classname">IntStack</code>.
    </p><p>
      Como un puntero, el trabajo de <code class="classname">IntStackIter
      </code> consiste en moverse a través de un
      <code class="classname">IntStack </code> y devolver valores. En este
      sencillo ejemplo, el objeto <code class="classname">IntStackIter </code>
      se puede mover sólo hacia adelante (usando la forma prefija y
      sufija del <code class="literal">operador++ </code>). Sin
      embargo, no hay límites de la forma en que se puede definir un
      iterador a parte de las restricciones impuestas por el
      contenedor con el que trabaje. Esto es totalmente aceptable
      (incluido los límites del contenedor que se encuentre por
      debajo) para un iterador que se mueva de cualquier forma por su
      contenedor asociado y para que se puedan modificar los valores
      del contenedor.
    </p><p>
      Es usual el que un iterador sea creado con un constructor que lo
      asocie a un único objeto contenedor, y que ese iterador no pueda
      ser asociado a otro contenedor diferente durante su ciclo de
      vida. (Los iteradores son normalemente pequeños y baratos, por
      lo que se puede crear otro fácilmente).
    </p><p>
      Con el iterador, se puede atravesar los elementos de la pila sin
      sacarlos de ella, como un puntero se mueve a través de los
      elementos del array. Sin embargo, el iterador conoce la
      estructura interna de la pila y como atravesar los elementos,
      dando la sensación de que se está moviendo a través de ellos
      como si fuera «incrementar un puntero», aunque sea
      más complejo lo que pasa por debajo. Esta es la clave del
      iterador: Abstrae el proceso complicado de moverse de un
      elemento del contenedor al siguiente y lo convierte en algo
      parecido a un puntero.  La meta de cada iterador del programa es
      que tengan la misma interfaz para que cualquier código que use
      un iterador no se preocupe de a qué está apuntando - sólo se
      sabe que todos los iteradores se tratan de la misma manera, por
      lo que no es importante a lo que apunte el iterador.  De esta
      forma se puede escribir código más genérico. Todos los
      contenedores y algoritmos en la Librería Estándar de C++ se
      basan en este principio de los iteradores.
    </p><p>
      Para ayudar a hacer las cosas más genéricas, sería agradable
      decir «todas las clases contenedoras tienen una clase
	asociada llamada <code class="classname">iterator</code>», pero
      esto causará normalmente problemas de nombres. La solución
      consite en añadir una clase anidada para cada contenedor (en
      este caso, «<code class="classname">iterator</code>»
      comienza con una letra minúscula para que esté conforme al
      estilo del C++ estándar).  Aquí está el
      <code class="filename">InterIntStack.cpp </code> con un
      <code class="classname">iterator </code> anidado:
    </p><div class="example"><a id="idp8660536"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:NestedIterator.cpp</span>
<span class="hl slc">// Nesting an iterator inside the container</span>
<span class="hl slc">//{L} fibonacci</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;fibonacci.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> IntStack <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> ssize <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> stack<span class="hl opt">[</span>ssize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> top<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">IntStack</span><span class="hl opt">() :</span> <span class="hl kwd">top</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&lt;</span> ssize<span class="hl opt">,</span> <span class="hl str">&quot;Too many push()es&quot;</span><span class="hl opt">);</span>
    stack<span class="hl opt">[</span>top<span class="hl opt">++] =</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Too many pop()s&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> stack<span class="hl opt">[--</span>top<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">class</span> iterator<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> iterator<span class="hl opt">;</span>
  <span class="hl kwc">class</span> iterator <span class="hl opt">{</span>
    IntStack<span class="hl opt">&amp;</span> s<span class="hl opt">;</span>
    <span class="hl kwb">int</span> index<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>IntStack<span class="hl opt">&amp;</span> is<span class="hl opt">) :</span> <span class="hl kwd">s</span><span class="hl opt">(</span>is<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
    <span class="hl slc">// To create the &quot;end sentinel&quot; iterator:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>IntStack<span class="hl opt">&amp;</span> is<span class="hl opt">,</span> <span class="hl kwb">bool</span><span class="hl opt">)</span> 
      <span class="hl opt">:</span> <span class="hl kwd">s</span><span class="hl opt">(</span>is<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span>s<span class="hl opt">.</span>top<span class="hl opt">) {}</span>
    <span class="hl kwb">int</span> <span class="hl kwd">current</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[</span>index<span class="hl opt">]; }</span>
    <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl slc">// Prefix</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span> 
        <span class="hl str">&quot;iterator moved out of range&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[++</span>index<span class="hl opt">];</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span> 
        <span class="hl str">&quot;iterator moved out of range&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[</span>index<span class="hl opt">++];</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Jump an iterator forward</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+=(</span><span class="hl kwb">int</span> amount<span class="hl opt">) {</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">+</span> amount <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span>
        <span class="hl str">&quot;IntStack::iterator::operator+=() &quot;</span>
        <span class="hl str">&quot;tried to move out of bounds&quot;</span><span class="hl opt">);</span>
      index <span class="hl opt">+=</span> amount<span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// To see if you're at the end:</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> index <span class="hl opt">==</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> index <span class="hl opt">!=</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> 
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> it<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> it<span class="hl opt">.</span><span class="hl kwd">current</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  iterator <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
  <span class="hl slc">// Create the &quot;end sentinel&quot;:</span>
  iterator <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">,</span> <span class="hl kwa">true</span><span class="hl opt">);}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  IntStack is<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    is<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwd">fibonacci</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Traverse the whole IntStack</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  IntStack<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> is<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> is<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt;</span> it<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Traverse a portion of the IntStack</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  IntStack<span class="hl opt">::</span>iterator 
    start <span class="hl opt">=</span> is<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> end <span class="hl opt">=</span> is<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  start <span class="hl opt">+=</span> <span class="hl num">5</span><span class="hl opt">,</span> end <span class="hl opt">+=</span> <span class="hl num">15</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;start = &quot;</span> <span class="hl opt">&lt;&lt;</span> start <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;end = &quot;</span> <span class="hl opt">&lt;&lt;</span> end <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>start <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> start<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.22. C16/NestedIterator.cpp</strong></p></div><br class="example-break" /><p>
      Cuando se crea una clase <code class="keyword">friend </code> anidada, hay
      que seguir el proceso de primero declarar el nombre de la clase,
      después declararla como <code class="keyword">friend</code>, y después
      definir la clase. De otra forma, se confundirá el compilador.
    </p><p>
      Al iterador se le han dado algunas vueltas de tuerca más. La
      función miembro <code class="function">current()</code> produce el
      elemento que el iterador está seleccionando actualmente en el
      contenedor. Se puede «saltar» hacia adelante un
      número arbitrario de elementos usando el <code class="literal">operator+=</code>. También, se pueden ver
      otros dos operadores sobrecargados: == y != que compararán un
      iterador con otro. Estos operadores pueden comparar dos
      <code class="classname">IntStack::iterator</code>, pero su intención
      primordial es comprobar si el iterador está al final de una
      secuencia de la misma manera que lo hacen los iteradores
      «reales» de la Librería Estándar de C++. La idea es
      que dos iteradores definan un rango, incluyendo el primer
      elemento apuntado por el primer iterador pero <span class="emphasis"><em>sin
      </em></span> incluir el último elemento apuntado por el segundo
      iterador. Por esto, si se quiere mover a través del rango
      definido por los dos iteradores, se dirá algo como lo siguiente:
    </p><pre class="programlisting">
<span class="hl kwa">while</span> <span class="hl opt">(</span>star <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> start<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
</pre><p>
      Donde <code class="varname">start </code> y <code class="varname">end </code> son
      los dos iteradores en el rango.  Note que el iterador
      <code class="varname">end</code>, al cual se le suele referir como el
      <code class="literal">end sentinel</code>, no es desreferenciado y nos
      avisa que estamos al final de la secuencia. Es decir, representa
      el que «otro sobrepasa el final».
    </p><p>
      La mayoría del tiempo se querrá mover a través de la secuencia
      entera de un contenedor, por lo que el contenedor necesitará
      alguna forma de producir los iteradores indicando el principio y
      el final de la secuencia. Aquí, como en la Standard C++ Library,
      estos iteradores se producen por las funciones miembro del
      contenedor <code class="function">begin() </code> y
      <code class="function">end()</code>. <code class="function">begin() </code> usa el
      primer constructor de <code class="classname">iterator </code> que por
      defecto apunta al principio del contenedor (esto es el primer
      elemento que se introdujo en la pila). Sin embargo, un segundo
      constructor, usado por <code class="function">end()</code>, es necesario
      para crear el iterador final. Estar «al final»
      significa apuntar a lo más alto de la pila, porque <code class="varname">top
      </code> siempre indica el siguiente espacio de la pila que
      esté disponible pero sin usar. Este constructor del
      <code class="classname">iterator </code> toma un segundo argumento del
      tipo <code class="type">bool</code>, lo cual es útil para distinguir los dos
      constructores.
    </p><p>
      De nuevo se usan los números Fibonacci para rellenar la
      <code class="classname">IntStack </code> en el
      <code class="function">main()</code>, y se usan iteradores para moverse
      completamente a través de la <code class="classname">IntStack </code>
      así como para moverse en un reducido rango de la secuencia.
    </p><p>
      El siguiente paso, por supuesto, es hacer el código general
      transformándolo en un template del tipo que maneje, para que en
      vez ser forzado a manejar enteros se pueda gestionar cualquier
      tipo:
    </p><div class="example"><a id="idp8679664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:IterStackTemplate.h</span>
<span class="hl slc">// Simple stack template with nested iterator</span>
<span class="hl ppc">#ifndef ITERSTACKTEMPLATE_H</span>
<span class="hl ppc">#define ITERSTACKTEMPLATE_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> ssize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> StackTemplate <span class="hl opt">{</span>
  T stack<span class="hl opt">[</span>ssize<span class="hl opt">];</span>
  <span class="hl kwb">int</span> top<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">StackTemplate</span><span class="hl opt">() :</span> <span class="hl kwd">top</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> i<span class="hl opt">) {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&lt;</span> ssize<span class="hl opt">,</span> <span class="hl str">&quot;Too many push()es&quot;</span><span class="hl opt">);</span>
    stack<span class="hl opt">[</span>top<span class="hl opt">++] =</span> i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwd">require</span><span class="hl opt">(</span>top <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl str">&quot;Too many pop()s&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> stack<span class="hl opt">[--</span>top<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">class</span> iterator<span class="hl opt">;</span> <span class="hl slc">// Declaration required</span>
  <span class="hl kwc">friend class</span> iterator<span class="hl opt">;</span> <span class="hl slc">// Make it a friend</span>
  <span class="hl kwc">class</span> iterator <span class="hl opt">{</span> <span class="hl slc">// Now define it</span>
    StackTemplate<span class="hl opt">&amp;</span> s<span class="hl opt">;</span>
    <span class="hl kwb">int</span> index<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>StackTemplate<span class="hl opt">&amp;</span> st<span class="hl opt">):</span> <span class="hl kwd">s</span><span class="hl opt">(</span>st<span class="hl opt">),</span><span class="hl kwd">index</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">){}</span>
    <span class="hl slc">// To create the &quot;end sentinel&quot; iterator:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>StackTemplate<span class="hl opt">&amp;</span> st<span class="hl opt">,</span> <span class="hl kwb">bool</span><span class="hl opt">)</span> 
      <span class="hl opt">:</span> <span class="hl kwd">s</span><span class="hl opt">(</span>st<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span>s<span class="hl opt">.</span>top<span class="hl opt">) {}</span>
    T <span class="hl kwc">operator</span><span class="hl opt">*()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[</span>index<span class="hl opt">];}</span>
    T <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl slc">// Prefix form</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span> 
        <span class="hl str">&quot;iterator moved out of range&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[++</span>index<span class="hl opt">];</span>
    <span class="hl opt">}</span>
    T <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl slc">// Postfix form</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span> 
        <span class="hl str">&quot;iterator moved out of range&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> s<span class="hl opt">.</span>stack<span class="hl opt">[</span>index<span class="hl opt">++];</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Jump an iterator forward</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+=(</span><span class="hl kwb">int</span> amount<span class="hl opt">) {</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">+</span> amount <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>top<span class="hl opt">,</span>
        <span class="hl str">&quot; StackTemplate::iterator::operator+=() &quot;</span>
        <span class="hl str">&quot;tried to move out of bounds&quot;</span><span class="hl opt">);</span>
      index <span class="hl opt">+=</span> amount<span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// To see if you're at the end:</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> index <span class="hl opt">==</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> index <span class="hl opt">!=</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>
      std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> it<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt; *</span>it<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  iterator <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
  <span class="hl slc">// Create the &quot;end sentinel&quot;:</span>
  iterator <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">,</span> <span class="hl kwa">true</span><span class="hl opt">);}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// ITERSTACKTEMPLATE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.23. C16/IterStackTemplate.h</strong></p></div><br class="example-break" /><p>
      Se puede ver que la transformación de una clase regular en un
      <code class="keyword">template </code> es razonablemente
      transparente. Esta aproximación de primero crear y depurar una
      clase ordinaria, y después transformarla en plantilla, está
      generalmente considerada como más sencilla que crear el template
      desde la nada.
    </p><p>
      Dese cuenta que en vez de sólo decir:
    </p><pre class="programlisting">
<span class="hl kwc">friend</span> iterator<span class="hl opt">;</span>  <span class="hl slc">// Hacerlo amigo</span>
</pre><p>
      Este código tiene:
    </p><pre class="programlisting">
<span class="hl kwc">friend class</span> iterator<span class="hl opt">;</span>  <span class="hl slc">// Hacerlo amigo</span>
</pre><p>
      Esto es importante porque el nombre
      «<code class="keyword">iterator</code>» ya existe en el ámbito de
      resolución, por culpa de un archivo incluido.
    </p><p>
      En vez de la función miembro <code class="function">current()</code>, el
      <code class="classname">iterator </code> tiene un <code class="literal">operator* </code>
      para seleccionar el elemento actual, lo que hace que el
      <code class="classname">iterator </code> se parezca más a un puntero lo
      cual es una práctica común.
    </p><p>
      Aquí está el ejemplo revisado para comprobar el template.
    </p><div class="example"><a id="idp8688416"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:IterStackTemplateTest.cpp</span>
<span class="hl slc">//{L} fibonacci</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;fibonacci.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;IterStackTemplate.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  StackTemplate<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> is<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    is<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwd">fibonacci</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl slc">// Traverse with an iterator:</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Traverse the whole StackTemplate</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  StackTemplate<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span> is<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> is<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt;</span> it<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Traverse a portion</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  StackTemplate<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;::</span>iterator 
    start <span class="hl opt">=</span> is<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> end <span class="hl opt">=</span> is<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  start <span class="hl opt">+=</span> <span class="hl num">5</span><span class="hl opt">,</span> end <span class="hl opt">+=</span> <span class="hl num">15</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;start = &quot;</span> <span class="hl opt">&lt;&lt;</span> start <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;end = &quot;</span> <span class="hl opt">&lt;&lt;</span> end <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>start <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> start<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;IterStackTemplateTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;IterStackTemplateTest.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  StackTemplate<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> strings<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    strings<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span>line<span class="hl opt">);</span>
  StackTemplate<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span>iterator 
    sb <span class="hl opt">=</span> strings<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> se <span class="hl opt">=</span> strings<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>sb <span class="hl opt">!=</span> se<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> sb<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.24. C16/IterStackTemplateTest.cpp</strong></p></div><br class="example-break" /><p>
      El primer uso del iterador simplemente lo recorre de principio a
      fin (y muestra que el límite final funciona correctamente). En el
      segundo uso, se puede ver como los iteradores permite fácilmente
      especificar un rango de elementos (los contenedores y los
      iteradores del Standard C++ Library usan este concepto de rangos
      casi en cualquier parte). El sobrecargado <code class="literal">operator+= </code>
      mueve los iteradores <code class="varname">start </code> y <code class="varname">end
      </code> a posiciones que están en el medio del rango de
      elementos de <code class="varname">is</code>, y estos elementos son
      imprimidos. Hay que resaltar, como se ve en la salida, que el
      elemento final no está incluido en el rango, o sea que una vez
      llegado al elemento final (end sentinel) se sabe que se ha pasado
      el final del rango - pero no hay que desreferenciar el elemento
      final o si no se puede acabar desreferenciando un puntero
      nulo. (Yo he puesto un guardian en el
      <code class="classname">StackTemplate::iterator</code>, pero en la
      Librería Estándar de C++ los contenedores y los iteradores no
      tienen ese código - por motivos de eficiencia - por lo que hay que
      prestar atención).
    </p><p>
      Por último para verificar que el <code class="classname">StackTemplate
      </code> funciona con objetos clase, se instancia uno para
      <code class="type">string</code>s y se rellena con líneas del código fuente,
      las cuales son posteriormente imprimidas en pantalla.
    </p><div class="sect2" title="16.7.1. Stack con iteradores"><div class="titlepage"><div><div><h3 class="title"><a id="idp8695376"></a>16.7.1. Stack con iteradores</h3></div></div></div><p>
	Podemos repetir el proceso con la clase de tamaño dinámico
	<code class="classname">Stack</code> que ha sido usada como un ejemplo
	a lo largo de todo el libro. Aquí está la clase
	<code class="classname">Stack </code> con un iterador anidado en todo
	el medio:
      </p><div class="example"><a id="idp8696712"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TStack2.h</span>
<span class="hl slc">// Templatized Stack with nested iterator</span>
<span class="hl ppc">#ifndef TSTACK2_H</span>
<span class="hl ppc">#define TSTACK2_H</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  <span class="hl kwb">struct</span> Link <span class="hl opt">{</span>
    T<span class="hl opt">*</span> data<span class="hl opt">;</span>
    Link<span class="hl opt">*</span> next<span class="hl opt">;</span>
    <span class="hl kwd">Link</span><span class="hl opt">(</span>T<span class="hl opt">*</span> dat<span class="hl opt">,</span> Link<span class="hl opt">*</span> nxt<span class="hl opt">)</span>
      <span class="hl opt">:</span> <span class="hl kwd">data</span><span class="hl opt">(</span>dat<span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span>nxt<span class="hl opt">) {}</span>
  <span class="hl opt">}*</span> head<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() :</span> <span class="hl kwd">head</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Stack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>T<span class="hl opt">*</span> dat<span class="hl opt">) {</span>
    head <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Link</span><span class="hl opt">(</span>dat<span class="hl opt">,</span> head<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">peek</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    <span class="hl kwa">return</span> head ? head<span class="hl opt">-&gt;</span>data <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl slc">// Nested iterator class:</span>
  <span class="hl kwc">class</span> iterator<span class="hl opt">;</span> <span class="hl slc">// Declaration required</span>
  <span class="hl kwc">friend class</span> iterator<span class="hl opt">;</span> <span class="hl slc">// Make it a friend</span>
  <span class="hl kwc">class</span> iterator <span class="hl opt">{</span> <span class="hl slc">// Now define it</span>
    Stack<span class="hl opt">::</span>Link<span class="hl opt">*</span> p<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span><span class="hl kwb">const</span> Stack<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> tl<span class="hl opt">) :</span> <span class="hl kwd">p</span><span class="hl opt">(</span>tl<span class="hl opt">.</span>head<span class="hl opt">) {}</span>
    <span class="hl slc">// Copy-constructor:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> tl<span class="hl opt">) :</span> <span class="hl kwd">p</span><span class="hl opt">(</span>tl<span class="hl opt">.</span>p<span class="hl opt">) {}</span>
    <span class="hl slc">// The end sentinel iterator:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">() :</span> <span class="hl kwd">p</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
    <span class="hl slc">// operator++ returns boolean indicating end:</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>p<span class="hl opt">-&gt;</span>next<span class="hl opt">)</span>
        p <span class="hl opt">=</span> p<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
      <span class="hl kwa">else</span> p <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// Indicates end of list</span>
      <span class="hl kwa">return</span> <span class="hl kwb">bool</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl kwc">operator</span><span class="hl opt">++(); }</span>
    T<span class="hl opt">*</span> <span class="hl kwd">current</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">if</span><span class="hl opt">(!</span>p<span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> p<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Pointer dereference operator:</span>
    T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">-&gt;()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
      <span class="hl kwd">require</span><span class="hl opt">(</span>p <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">,</span> 
        <span class="hl str">&quot;PStack::iterator::operator-&gt;returns 0&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> <span class="hl kwd">current</span><span class="hl opt">();</span> 
    <span class="hl opt">}</span>
    T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">*()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwd">current</span><span class="hl opt">(); }</span>
    <span class="hl slc">// bool conversion for conditional test:</span>
    <span class="hl kwc">operator</span> <span class="hl kwb">bool</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwb">bool</span><span class="hl opt">(</span>p<span class="hl opt">); }</span>
    <span class="hl slc">// Comparison to test for end:</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> p <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> p <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  iterator <span class="hl kwd">begin</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
    <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">);</span> 
  <span class="hl opt">}</span>
  iterator <span class="hl kwd">end</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> Stack<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::~</span><span class="hl kwd">Stack</span><span class="hl opt">() {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>head<span class="hl opt">)</span>
    <span class="hl kwa">delete</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> T<span class="hl opt">*</span> Stack<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span><span class="hl kwd">pop</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>head <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  T<span class="hl opt">*</span> result <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>data<span class="hl opt">;</span>
  Link<span class="hl opt">*</span> oldHead <span class="hl opt">=</span> head<span class="hl opt">;</span>
  head <span class="hl opt">=</span> head<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> oldHead<span class="hl opt">;</span>
  <span class="hl kwa">return</span> result<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TSTACK2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.25. C16/TStack2.h</strong></p></div><br class="example-break" /><p>
	Hay que hacer notar que la clase ha sido cambiada para
	soportar la posesión, que funciona ahora debido a que la clase
	conoce ahora el tipo exacto (o al menos el tipo base, que
	funciona asumiendo que son usados los destructores
	virtuales). La opción por defecto es que el contenedor
	destruya sus objetos pero nosotros somos responsables de los
	objetos a los que se haga <code class="function">pop()</code>.
      </p><p>
	El iterador es simple, y físicamente muy pequeño - el tamaño
	de un único puntero. Cuando se crea un
	<code class="classname">iterator</code>, se inicializa a la cabeza de
	la lista enlazada, y sólo puede ser incrementado avanzando a
	través de la lista. Si se quiere empezar desde el principio,
	hay que crear un nuevo iterador, y si se quiere recordar un
	punto de la lista, hay que crear un nuevo iterador a partir
	del iterador existente que está apuntando a ese elemento
	(usando el constructor de copia del iterador).
      </p><p>
	Para llamar a funciones del objeto referenciado por el
	iterador, se puede usar la función
	<code class="function">current()</code>, el <code class="literal">operator*</code>, o la desreferencia de
	puntero <code class="literal">operator-&gt; </code> (un
	elemento común en los iteradores).  La última tiene una
	implementación que <span class="emphasis"><em>parece</em></span> idéntica a
	<code class="function">current() </code> debido a que devuelve un
	puntero al objeto actual, pero es diferente porque el operador
	desreferencia del puntero realiza niveles extra de
	desreferenciación (ver Capítulo 12).
      </p><p>
	La clase <code class="classname">iterator </code> sigue el formato que
	se vio en el ejemplo anterior.  <code class="classname">class iterator
	</code> está anidada dentro de la clase contenedora,
	contiene constructores para crear un iterador que apunta a un
	elemento en el contenedor y un iterador «marcador de
	  final», y la clase contenedora tiene los métodos
	<code class="function">begin() </code> y <code class="function">end() </code>
	para producir estos iteradores. (Cuando aprenda más de la
	Librería Estándar de C++, verá que los nombres
	<code class="classname">iterator</code>, <code class="function">begin() </code>
	y <code class="function">end()</code> que se usan aquí tienen
	correspondecia en las clases contenedoras. Al final de este
	capítulo, se verá que esto permite manejar estas clases
	contenedoras como si fueran clases de la STL).
      </p><p>
	La implementación completa se encuentra en el archivo
	cabecera, por lo que no existe un archivo <code class="filename">cpp
	</code> separado. Aquí tenemos un pequeño test que usa el
	iterador.
      </p><div class="example"><a id="idp8710064"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TStack2Test.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TStack2.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">file</span><span class="hl opt">(</span><span class="hl str">&quot;TStack2Test.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>file<span class="hl opt">,</span> <span class="hl str">&quot;TStack2Test.cpp&quot;</span><span class="hl opt">);</span>
  Stack<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> textlines<span class="hl opt">;</span>
  <span class="hl slc">// Read file and store lines in the Stack:</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>file<span class="hl opt">,</span> line<span class="hl opt">))</span>
    textlines<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// Use iterator to print lines from the list:</span>
  Stack<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span> textlines<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  Stack<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span>iterator<span class="hl opt">*</span> it2 <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> textlines<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
    cout <span class="hl opt">&lt;&lt;</span> it<span class="hl opt">-&gt;</span><span class="hl kwd">c_str</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    it<span class="hl opt">++;</span>
    <span class="hl kwa">if</span><span class="hl opt">(++</span>i <span class="hl opt">==</span> <span class="hl num">10</span><span class="hl opt">)</span> <span class="hl slc">// Remember 10th line</span>
      it2 <span class="hl opt">=</span> <span class="hl kwa">new</span> Stack<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span><span class="hl kwd">iterator</span><span class="hl opt">(</span>it<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt; (*</span>it2<span class="hl opt">)-&gt;</span><span class="hl kwd">c_str</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> it2<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.26. C16/TStack2Test.cpp</strong></p></div><br class="example-break" /><p>
	Una pila <code class="classname">Stack </code> es instanciada para
	gestionar objetos <code class="type">string </code> y se rellena con líneas
	de un fichero. Entonces se crea un iterador y se usa para
	moverse a través de la secuencia. La décima línea es recordada
	mediante un segundo iterador creado con el constructor de
	copia del primero; posteriormente esta línea es imprimida y el
	iterador - crado dinámicamente - es destruido. Aquí la
	creación dinámica de objetos es usada para controlar la vida
	del objeto.
      </p></div><div class="sect2" title="16.7.2. PStash con iteradores"><div class="titlepage"><div><div><h3 class="title"><a id="idp8713536"></a>16.7.2. PStash con iteradores</h3></div></div></div><p>
	Para la mayoría de los contenedores tiene sentido tener un
	iterador. Aquí tenemos un iterador añadido a la clase
	<code class="classname">PStash</code>:
      </p><div class="example"><a id="idp8714552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TPStash2.h</span>
<span class="hl slc">// Templatized PStash with nested iterator</span>
<span class="hl ppc">#ifndef TPSTASH2_H</span>
<span class="hl ppc">#define TPSTASH2_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> PStash <span class="hl opt">{</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>
  T<span class="hl opt">**</span> storage<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase <span class="hl opt">=</span> incr<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">PStash</span><span class="hl opt">() :</span> <span class="hl kwd">quantity</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">storage</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">next</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">PStash</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span>T<span class="hl opt">*</span> element<span class="hl opt">);</span>
  T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  T<span class="hl opt">*</span> <span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> next<span class="hl opt">; }</span>
  <span class="hl slc">// Nested iterator class:</span>
  <span class="hl kwc">class</span> iterator<span class="hl opt">;</span> <span class="hl slc">// Declaration required</span>
  <span class="hl kwc">friend class</span> iterator<span class="hl opt">;</span> <span class="hl slc">// Make it a friend</span>
  <span class="hl kwc">class</span> iterator <span class="hl opt">{</span> <span class="hl slc">// Now define it</span>
    PStash<span class="hl opt">&amp;</span> ps<span class="hl opt">;</span>
    <span class="hl kwb">int</span> index<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>PStash<span class="hl opt">&amp;</span> pStash<span class="hl opt">)</span>
      <span class="hl opt">:</span> <span class="hl kwd">ps</span><span class="hl opt">(</span>pStash<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
    <span class="hl slc">// To create the end sentinel:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>PStash<span class="hl opt">&amp;</span> pStash<span class="hl opt">,</span> <span class="hl kwb">bool</span><span class="hl opt">)</span>
      <span class="hl opt">:</span> <span class="hl kwd">ps</span><span class="hl opt">(</span>pStash<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span>ps<span class="hl opt">.</span>next<span class="hl opt">) {}</span>
    <span class="hl slc">// Copy-constructor:</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span>
      <span class="hl opt">:</span> <span class="hl kwd">ps</span><span class="hl opt">(</span>rv<span class="hl opt">.</span>ps<span class="hl opt">),</span> <span class="hl kwd">index</span><span class="hl opt">(</span>rv<span class="hl opt">.</span>index<span class="hl opt">) {}</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">) {</span>
      ps <span class="hl opt">=</span> rv<span class="hl opt">.</span>ps<span class="hl opt">;</span>
      index <span class="hl opt">=</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span>
      <span class="hl kwd">require</span><span class="hl opt">(++</span>index <span class="hl opt">&lt;=</span> ps<span class="hl opt">.</span>next<span class="hl opt">,</span>
        <span class="hl str">&quot;PStash::iterator::operator++ &quot;</span>
        <span class="hl str">&quot;moves index out of bounds&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span>
      <span class="hl kwa">return</span> <span class="hl kwc">operator</span><span class="hl opt">++();</span>
    <span class="hl opt">}</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">--() {</span>
      <span class="hl kwd">require</span><span class="hl opt">(--</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">,</span>
        <span class="hl str">&quot;PStash::iterator::operator-- &quot;</span>
        <span class="hl str">&quot;moves index out of bounds&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">--(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> 
      <span class="hl kwa">return</span> <span class="hl kwc">operator</span><span class="hl opt">--();</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Jump interator forward or backward:</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+=(</span><span class="hl kwb">int</span> amount<span class="hl opt">) {</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">+</span> amount <span class="hl opt">&lt;</span> ps<span class="hl opt">.</span>next <span class="hl opt">&amp;&amp;</span> 
        index <span class="hl opt">+</span> amount <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">,</span> 
        <span class="hl str">&quot;PStash::iterator::operator+= &quot;</span>
        <span class="hl str">&quot;attempt to index out of bounds&quot;</span><span class="hl opt">);</span>
      index <span class="hl opt">+=</span> amount<span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">-=(</span><span class="hl kwb">int</span> amount<span class="hl opt">) {</span>
      <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">-</span> amount <span class="hl opt">&lt;</span> ps<span class="hl opt">.</span>next <span class="hl opt">&amp;&amp;</span> 
        index <span class="hl opt">-</span> amount <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">,</span> 
        <span class="hl str">&quot;PStash::iterator::operator-= &quot;</span>
        <span class="hl str">&quot;attempt to index out of bounds&quot;</span><span class="hl opt">);</span>
      index <span class="hl opt">-=</span> amount<span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Create a new iterator that's moved forward</span>
    iterator <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">int</span> amount<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      iterator <span class="hl kwd">ret</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">);</span>
      ret <span class="hl opt">+=</span> amount<span class="hl opt">;</span> <span class="hl slc">// op+= does bounds check</span>
      <span class="hl kwa">return</span> ret<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    T<span class="hl opt">*</span> <span class="hl kwd">current</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> ps<span class="hl opt">.</span>storage<span class="hl opt">[</span>index<span class="hl opt">];</span>
    <span class="hl opt">}</span>
    T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">*()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl kwd">current</span><span class="hl opt">(); }</span>
    T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">-&gt;()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> 
      <span class="hl kwd">require</span><span class="hl opt">(</span>ps<span class="hl opt">.</span>storage<span class="hl opt">[</span>index<span class="hl opt">] !=</span> <span class="hl num">0</span><span class="hl opt">,</span> 
        <span class="hl str">&quot;PStash::iterator::operator-&gt;returns 0&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">return</span> <span class="hl kwd">current</span><span class="hl opt">();</span> 
    <span class="hl opt">}</span>
    <span class="hl slc">// Remove the current element:</span>
    T<span class="hl opt">*</span> <span class="hl kwd">remove</span><span class="hl opt">(){</span>
      <span class="hl kwa">return</span> ps<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">(</span>index<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Comparison tests for end:</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> index <span class="hl opt">==</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> rv<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> index <span class="hl opt">!=</span> rv<span class="hl opt">.</span>index<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">};</span>
  iterator <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
  iterator <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">,</span> <span class="hl kwa">true</span><span class="hl opt">);}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Destruction of contained objects:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::~</span><span class="hl kwd">PStash</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> next<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwa">delete</span> storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Null pointers OK</span>
    storage<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// Just to be safe</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
<span class="hl kwb">int</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwd">add</span><span class="hl opt">(</span>T<span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>next <span class="hl opt">&gt;=</span> quantity<span class="hl opt">)</span>
    <span class="hl kwd">inflate</span><span class="hl opt">();</span>
  storage<span class="hl opt">[</span>next<span class="hl opt">++] =</span> element<span class="hl opt">;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span> <span class="hl kwc">inline</span>
T<span class="hl opt">*</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> index<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">,</span>
    <span class="hl str">&quot;PStash::operator[] index negative&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>storage<span class="hl opt">[</span>index<span class="hl opt">] !=</span> <span class="hl num">0</span><span class="hl opt">,</span> 
    <span class="hl str">&quot;PStash::operator[] returned null pointer&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> storage<span class="hl opt">[</span>index<span class="hl opt">];</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
T<span class="hl opt">*</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwd">remove</span><span class="hl opt">(</span><span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl slc">// operator[] performs validity checks:</span>
  T<span class="hl opt">*</span> v <span class="hl opt">=</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span>index<span class="hl opt">);</span>
  <span class="hl slc">// &quot;Remove&quot; the pointer:</span>
  storage<span class="hl opt">[</span>index<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> v<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> incr<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> PStash<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> incr<span class="hl opt">&gt;::</span><span class="hl kwd">inflate</span><span class="hl opt">(</span><span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwb">const int</span> tsz <span class="hl opt">=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>T<span class="hl opt">*);</span>
  T<span class="hl opt">**</span> st <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">*[</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">];</span>
  <span class="hl kwd">memset</span><span class="hl opt">(</span>st<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">, (</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">) *</span> tsz<span class="hl opt">);</span>
  <span class="hl kwd">memcpy</span><span class="hl opt">(</span>st<span class="hl opt">,</span> storage<span class="hl opt">,</span> quantity <span class="hl opt">*</span> tsz<span class="hl opt">);</span>
  quantity <span class="hl opt">+=</span> increase<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span>storage<span class="hl opt">;</span> <span class="hl slc">// Old storage</span>
  storage <span class="hl opt">=</span> st<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TPSTASH2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.27. C16/TPStash2.h</strong></p></div><br class="example-break" /><p>
	La mayoría de este archivo es un traducción prácticamente
	directa del anterior <code class="classname">PStash </code> y el iterador
	anidado dentro de un template. Esta vez, sin embargo, el
	operador devuelve referencias al iterador actual, la cual es
	una aproximación más típica y flexible.
      </p><p>
	El destructor llama a <code class="function">delete </code> para todos
	los punteros que contiene, y como el tipo es obtenido de la
	plantilla, se ejecutará la destrucción adecuada.  Hay que
	estar precavido que si el contenedor controla punteros al tipo
	de la clase base, este tipo debe tener un destructor <code class="keyword">virtual </code> para asegurar un limpiado
	adecuado de los objetos derivados que hayan usado un upcast
	cuando se los alojó en el contenedor.
      </p><p>
	El <code class="varname">PStash::iterator</code> mantiene el modelo de
	engancharse a un único objeto contenedor durante su ciclo de
	vida. Además, el constructor de copia permite crear un nuevo
	iterador que apunte a la misma posición del iterador desde el
	que se le creo, creando de esta manera un marcador dentro del
	contenedor. Las funciones miembro <code class="function">operator+=
	</code> y el <code class="function">operator-=</code> permiten
	mover un iterador un número de posiciones, mientras se
	respeten los límites del contenedor.  Los operadores
	sobrecargados de incremento y decremento mueven el iterador
	una posición.  El <code class="function">operator+</code> produce un
	nuevo iterador que se mueve adelante la cantidad añadida. Como
	en el ejemplo anterior, los operadores de desreferencia de
	punteros son usados para manejar el elemento al que el
	iterador está referenciando, y <code class="function">remove()</code>
	destruye el objeto actual llamando al
	<code class="function">remove()</code> del contenedor.
      </p><p>
	Se usa la misma clase de código de antes para crear el
	marcador final: un segundo constructor, la función miembro del
	contenedor <code class="function">end()</code>, y el
	<code class="function">operator== </code> y <code class="function">operator!=
	</code> para comparaciones.
      </p><p>
	El siguiente ejemplo crea y comprueba dos diferentes clases de
	objetos <code class="classname">Stash</code>, uno para una nueva clase
	llamada <code class="classname">Int</code> que anuncia su construcción y
	destrucción y otra que gestiona objetos <code class="type">string
	</code> de la librería Estándar.
      </p><div class="example"><a id="idp8731120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:TPStash2Test.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TPStash2.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Int <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl kwb">int</span> ii <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>ii<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&gt;&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Int</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">; }</span>
  <span class="hl kwc">operator</span> <span class="hl kwb">int</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Int<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Int: &quot;</span> <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span>i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Int<span class="hl opt">*</span> x<span class="hl opt">) {</span>
      <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Int: &quot;</span> <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">-&gt;</span>i<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl opt">{</span> <span class="hl slc">// To force destructor call</span>
    PStash<span class="hl opt">&lt;</span>Int<span class="hl opt">&gt;</span> ints<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">30</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      ints<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Int</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
    cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    PStash<span class="hl opt">&lt;</span>Int<span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span> ints<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
    it <span class="hl opt">+=</span> <span class="hl num">5</span><span class="hl opt">;</span>
    PStash<span class="hl opt">&lt;</span>Int<span class="hl opt">&gt;::</span>iterator it2 <span class="hl opt">=</span> it <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(;</span> it <span class="hl opt">!=</span> it2<span class="hl opt">;</span> it<span class="hl opt">++)</span>
      <span class="hl kwa">delete</span> it<span class="hl opt">.</span><span class="hl kwd">remove</span><span class="hl opt">();</span> <span class="hl slc">// Default removal</span>
    cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span>it <span class="hl opt">=</span> ints<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>it <span class="hl opt">!=</span> ints<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span>it<span class="hl opt">++)</span>
      <span class="hl kwa">if</span><span class="hl opt">(*</span>it<span class="hl opt">)</span> <span class="hl slc">// Remove() causes &quot;holes&quot;</span>
        cout <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl slc">// &quot;ints&quot; destructor called here</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">-------------------</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>  
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;TPStash2Test.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;TPStash2Test.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Instantiate for String:</span>
  PStash<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> strings<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    strings<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>line<span class="hl opt">));</span>
  PStash<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span>iterator sit <span class="hl opt">=</span> strings<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(;</span> sit <span class="hl opt">!=</span> strings<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span> sit<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt; **</span>sit <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  sit <span class="hl opt">=</span> strings<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> n <span class="hl opt">=</span> <span class="hl num">26</span><span class="hl opt">;</span>
  sit <span class="hl opt">+=</span> n<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(;</span> sit <span class="hl opt">!=</span> strings<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span> sit<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> n<span class="hl opt">++ &lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt; **</span>sit <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.28. C16/TPStash2Test.cpp</strong></p></div><br class="example-break" /><p>
	Por conveniencia <code class="classname">Int </code> tiene asociado un
	<code class="varname">ostream operator&lt;&lt;</code> para
	<code class="classname">Int&amp;</code> y <code class="classname">Int*</code>.
      </p><p>
	El primer bloque de código en <code class="function">main()</code> está
	rodeado de llaves para forzar la destrucción de
	<code class="varname">PStash&lt;Int&gt;</code> que produce un limpiado
	automático por este destructor. Unos cuantos elementos son
	sacados y borrados a mano para mostrar que <code class="classname">PStash
	</code> limpia el resto.
      </p><p>
	Para ambas instancias de <code class="classname">PStash</code>, se
	crea un iterador y se usa para moverse a través del
	contenedor. Note la elegancia generada por el uso de estos
	constructores; no hay que preocuparse por los detalles de
	implementación de usar un array. Se le dice al contenedor y al
	iterador <span class="emphasis"><em>qué</em></span> hacer y no
	<span class="emphasis"><em>cómo</em></span> hacerlo. Esto produce una solución
	más sencilla de conceptualizar, construir y modificar.
      </p></div></div><div class="sect1" title="16.8. Por qué usar iteradores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8739008"></a>16.8. Por qué usar iteradores</h2></div></div></div><p>
      Hasta ahora se han visto los mecanismos de los iteradores, pero
      entender el por qué son tan importantes necesita un ejemplo más
      complejo.
    </p><p>
      Es normal ver el polimorfismo, la creación dinámica de objetos,
      y los contenedores en un programa orientado a objetos real. Los
      contendores y la creación dinámica de objetos resuelven el
      problema de no saber cuantos o que tipo de objetos se
      necesitarán. Y si el contenedor está configurado para manejar
      punteros a la clase base, cada vez que se ponga un puntero a una
      clase derivada hay un upcast (con los beneficios que conlleva de
      claridad de código y extensibilidad). Como código del final del
      Volumen 1, este ejemplo reune varios aspectos de todo lo que se
      ha aprendido - si es capaz de seguir este ejemplo, entonces está
      preparado para el Volumen 2.
    </p><p>
      Suponga que esta creando un programa que permite al usuario
      editar y producir diferentes clases de dibujos. Cada dibujo es
      un objeto que contiene una colección de objetos
      <code class="classname">Shape</code>:
    </p><div class="example"><a id="idp8742496"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:Shape.h</span>
<span class="hl ppc">#ifndef SHAPE_H</span>
<span class="hl ppc">#define SHAPE_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>

<span class="hl kwc">class</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Shape</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Circle <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Circle</span><span class="hl opt">() {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Circle</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::~Circle</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::draw</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::erase</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Square <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Square</span><span class="hl opt">() {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Square</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::~Square</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::draw</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::erase</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Line <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Line</span><span class="hl opt">() {}</span>
  <span class="hl opt">~</span><span class="hl kwd">Line</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Line::~Line</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Line::draw</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Line::erase</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// SHAPE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 16.29. C16/Shape.h</strong></p></div><br class="example-break" /><p>
      Se usa la estructura clásica de las funciones virtuales en la
      clase base que son sobreescritas en la clase derivada. Hay que
      resaltar que la clase <code class="classname">Shape </code> incluye un
      destructor virtual, algo que se debería añadir automáticamente a
      cualquier clase con funciones <code class="keyword">virtual</code>es. Si un contenedor maneja
      punteros o referencias a objetos <code class="classname">Shape</code>,
      entonces cuando los destructores virtuales sean llamados para
      estos objetos todo será correctamente limpiado.
    </p><p>
      Cada tipo diferente de dibujo en el siguiente ejemplo hace uso
      de una plantilla de clase contenedora diferente: el
      <code class="classname">PStash </code> y el <code class="classname">Stack
      </code> que han sido definido en este capítulo, y la clase
      <code class="classname">vector </code> de la Librería Estándar de
      C++. El «uso» de los contenedores es extremadamente
      simple, y en general la herencia no es la mejor aproximación
      (composición puede tener más sentido), pero en este caso la
      herencia es una aproximación más simple.
    </p><div class="example"><a id="idp8748736"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C16:Drawing.cpp</span>
<span class="hl ppc">#include &lt;vector&gt;</span> <span class="hl slc">// Uses Standard vector too!</span>
<span class="hl ppc"></span><span class="hl ppc">#include</span> <span class="hl pps">&quot;TPStash2.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TStack2.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Shape.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A Drawing is primarily a container of Shapes:</span>
<span class="hl kwc">class</span> Drawing <span class="hl opt">:</span> <span class="hl kwc">public</span> PStash<span class="hl opt">&lt;</span>Shape<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Drawing</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Drawing&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// A Plan is a different container of Shapes:</span>
<span class="hl kwc">class</span> Plan <span class="hl opt">:</span> <span class="hl kwc">public</span> Stack<span class="hl opt">&lt;</span>Shape<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Plan</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Plan&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// A Schematic is a different container of Shapes:</span>
<span class="hl kwc">class</span> Schematic <span class="hl opt">:</span> <span class="hl kwc">public</span> vector<span class="hl opt">&lt;</span>Shape<span class="hl opt">*&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Schematic</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Schematic&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// A function template:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Iter<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">drawAll</span><span class="hl opt">(</span>Iter start<span class="hl opt">,</span> Iter end<span class="hl opt">) {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>start <span class="hl opt">!=</span> end<span class="hl opt">) {</span>
    <span class="hl opt">(*</span>start<span class="hl opt">)-&gt;</span><span class="hl kwd">draw</span><span class="hl opt">();</span>
    start<span class="hl opt">++;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Each type of container has </span>
  <span class="hl slc">// a different interface:</span>
  Drawing d<span class="hl opt">;</span>
  d<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> Circle<span class="hl opt">);</span>
  d<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> Square<span class="hl opt">);</span>
  d<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> Line<span class="hl opt">);</span>
  Plan p<span class="hl opt">;</span>
  p<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> Line<span class="hl opt">);</span>
  p<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> Square<span class="hl opt">);</span>
  p<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwa">new</span> Circle<span class="hl opt">);</span>
  Schematic s<span class="hl opt">;</span>
  s<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> Square<span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> Circle<span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> Line<span class="hl opt">);</span>
  Shape<span class="hl opt">*</span> sarray<span class="hl opt">[] = {</span> 
    <span class="hl kwa">new</span> Circle<span class="hl opt">,</span> <span class="hl kwa">new</span> Square<span class="hl opt">,</span> <span class="hl kwa">new</span> Line 
  <span class="hl opt">};</span>
  <span class="hl slc">// The iterators and the template function</span>
  <span class="hl slc">// allow them to be treated generically:</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Drawing d:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">drawAll</span><span class="hl opt">(</span>d<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> d<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Plan p:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">drawAll</span><span class="hl opt">(</span>p<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> p<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Schematic s:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">drawAll</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Array sarray:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Even works with array pointers:</span>
  <span class="hl kwd">drawAll</span><span class="hl opt">(</span>sarray<span class="hl opt">,</span> 
    sarray <span class="hl opt">+</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>sarray<span class="hl opt">)/</span><span class="hl kwa">sizeof</span><span class="hl opt">(*</span>sarray<span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;End of main&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 16.30. C16/Drawing.cpp</strong></p></div><br class="example-break" /><p>
      Los distintos tipos de contenedores manejan punteros a
      <code class="classname">Shape </code> y punteros a objetos de clases
      derivadas de <code class="classname">Shape</code>. Sin embargo, debido
      al polimorfismo, cuando se llama a las funcione virtuales ocurre
      el comportamiento adecuado.
    </p><p>
      Note que <code class="varname">sarray</code>, el array de
      <code class="classname">Shape*</code>, puede ser recorrido como un
      contenedor.
    </p><div class="sect2" title="16.8.1. Plantillas Función"><div class="titlepage"><div><div><h3 class="title"><a id="idp8754600"></a>16.8.1. Plantillas Función</h3></div></div></div><p>
	En <code class="function">drawAll()</code> se ve algo nuevo. En este
	capítulo, únicamente hemos estado usando <span class="emphasis"><em>plantillas
	  de clases</em></span>, las cuales pueden instanciar nuevas
	clases basadas en uno o más parámetros de tipo. Sin embargo,
	se puede crear <span class="emphasis"><em>plantillas de función</em></span>, las
	cuales crean nuevas funciones basadas en parámetros de
	tipo. La razón para crear una plantilla de función es la misma
	por la cual se crea una plantilla de clase: intentar crear
	código más genérico, y se hace retrasando la especificación de
	uno o más tipos.  Se quiere decir que estos parámetros de
	tipos soportan ciertas operaciones, no qué tipos exactos son.
      </p><p>
	Se puede pensar sobre la plantilla función <code class="function">drawAll()
	</code> como si fuera un <span class="emphasis"><em>algoritmo </em></span>
	(y así es como se llaman la mayoría de las plantillas de
	función de la STL). Sólo dice como hacer algo dado unos
	iteradores que describen un rango de elementos, mientras que
	estos iteradores pueden ser desreferenciados, incrementados, y
	comparados. Estos son exactamente la clase de iteradores que
	hemos estado desarrollando en este capítulo, y también - y no
	por casualidad - la clase de iteradores que son producidos por
	los contenedores de la Librería Estándar de C++, evidenciado
	por el uso de <code class="classname">vector</code> en este ejemplo.
      </p><p>
	Además nos gustaría que <code class="function">drawAll() </code> fuera un
	<span class="emphasis"><em>algoritmo genérico</em></span>, para que los
	contenedores pudieran ser de cualquier tipo y que no se
	tuviera que escribir una nueva versión del algoritmo para cada
	tipo diferente del contenedor. Aquí es donde las plantillas de
	funciones son esenciales, porque automáticamente generan el
	código específico para cada tipo de contenedor diferente. Pero
	sin la indirección extra proporcionada por los iteradores,
	estas generalizaciones no serían posibles. Este es el motivo
	por el que los iteradores son importantes; nos permiten
	escribir código de propósito general que involucra a
	contenedores sin conocer la estructura subyacente del
	contenedor. (Note que los iteradores de C++ y los algoritmos
	genéricos requieren plantillas de funciones).
      </p><p>
	Se puede ver el alcance de esto en el
	<code class="function">main()</code>, ya que <code class="function">drawAll()
	</code> funciona sin cambiar cada uno de los diferentes
	tipos de contenedores. E incluso más interesante,
	<code class="function">drawAll() </code> también funciona con punteros
	al principio y al final del array
	<code class="varname">sarray</code>. Esta habilidad para tratar arrays
	como contenedores está integrada en el diseño de la Librería
	Estándar de C++, cuyos algoritmos se parecen mucho a
	<code class="function">drawAll()</code>.
      </p><p>
	Debido a que las plantillas de clases contenedoras están
	raramente sujetas a la herencia y al upcast se ven como clases
	«ordinarias», casi nunca se verán funciones virtuales en
	clases contenedoras. La reutilización de las clases contenedoras está
	implementado mediante plantillas, no mediante herencia.
      </p></div></div><div class="sect1" title="16.9. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8764216"></a>16.9. Resumen</h2></div></div></div><p>
      Las clases contenedoras son una parte esencial de la
      programación orientada a objetos.  Son otro modo de simplificar
      y ocultar los detalles de un programa y de acelerar el proceso
      de desarrollo del programa. Además, proporcionan un gran nivel
      de seguridad y flexibilidad reemplazando los anticuados arrays y
      las relativamente toscas técnicas de estructuras que se pueden
      encontrar en C.
    </p><p>
      Como el programador cliente necesita contenedores, es esencial
      que sean fáciles de usar.  Aquí es donde entran los <code class="keyword">template</code>s. Con las plantillas la
      sintaxis para el reciclaje del código fuente (al contrario del
      reciclaje del código objeto que proporciona la herencia y la
      composición) se vuelve lo suficientemente trivial para el
      usuario novel. De hecho, la reutilización de código con
      plantillas es notablemente más fácil que la herencia y el
      polimorfismo.
    </p><p>
      Aunque se ha aprendido cómo crear contenedores y clases
      iteradoras en este libro, en la práctica es mucho más útil
      aprender los contenedores e iteradores que contiene la Librería
      Estándar de C++, ya que se puede esperar encontrarlas en
      cualquier compilador. Como se verá en el Volumen 2 de este libro
      (que se puede bajar de <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>, los
      contenedores y algoritmos de la STL colmarán virtualmente sus
      necesidades por lo que no tendrá que crear otras nuevas.
    </p><p>
      Las características que implica el diseño con clases
      contenedoras han sido introducidas a lo largo de todo el
      capítulo, pero hay que resaltar que van mucho más allá. Una
      librería de clases contenedoras más complicada debería cubrir
      todo tipo de características adicionales, como la multitarea, la
      persistencia y la recolección de basura.
    </p></div><div class="sect1" title="16.10. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8769616"></a>16.10. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Implemente la jerarquía de herencia del diagrama de
	  <code class="classname">OShape </code> de este capítulo.
	</p></li><li class="listitem"><p>
	  Modifique el resultado del Ejercicio 1 del capítulo 15 para
	  usar la <code class="classname">Stack </code> y el
	  <code class="classname">iterator </code> en <code class="filename">TStack2.h
	  </code> en vez de un array de punteros a
	  <code class="classname">Shape</code>. Añada destructores a la
	  jerarquía de clases para que se pueda ver que los objetos
	  <code class="classname">Shape </code> han sido destruidos cuando la
	  <code class="classname">Stack </code> se sale del ámbito.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">TPStash.h </code> para que el valor
	  de incremento usado por <code class="function">inflate() </code>
	  pueda ser cambiado durante la vida de un objeto contenedor
	  particular.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">TPStash.h </code> para que el valor de
	  incremento usado por <code class="function">inflate() </code>
	  automáticamente cambie de tamaño para que reduzca el número
	  de veces que debe ser llamado. Por ejemplo, cada vez que se
	  llama podría doblar el valor de incremento para su uso en la
	  siguiente llamada. Demuestre la funcionalidad mostrando cada
	  vez que se llama a <code class="function">inflate()</code>, y escriba
	  código de prueba en <code class="function">main()</code>.
	</p></li><li class="listitem"><p>
	  Convierta en plantilla la función de <code class="function">fibonacci()
	  </code> con los tipos que puede producir (puede generar
	  <code class="type">long</code>, <code class="type">float</code>, etc.  en vez de sólo
	  <code class="type">int</code>).
	</p></li><li class="listitem"><p>
	  Usar el <code class="classname">vector </code> de la STL como
	  implementación subyacente, para crear una platilla
	  <code class="classname">Set </code> que acepte solo uno de cada tipo
	  de objeto que se aloje en él. Cree un iterador anidado que
	  soporte el concepto de "marcador final" de este
	  capítulo. Escriba código de prueba para el <code class="classname">Set
	  </code> en el <code class="function">main()</code>, y entonces
	  sustituyalo por la plantilla <code class="classname">set </code> de
	  la STL para comprobar que el comportamiento es correcto.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">AutoCounter.h </code> para que pueda
	  ser usado como un objeto miembro dentro de cualquier clase
	  cuya creación y destrucción quiera comprobar. Añada un
	  miembro <code class="type">string </code> para que contenga el
	  nombre de la clase. Compruebe esta herramienta dentro una
	  clase suya.
	</p></li><li class="listitem"><p>
	  Cree una versión de <code class="filename">OwnerStack.h </code> que use
	  un <code class="classname">vector </code> de la Librería Estándar de C++
	  como su implementación subyacente.  Será necesario conocer
	  algunas de las funciones miembro de <code class="classname">vector
	  </code> para poder hacerlo (sólo hay que mirar en el
	  archivo cabecera &lt;vector&gt;).
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ValueStack.h </code> para que pueda
	  expandirse dinámicamente según se introduzcan más objetos y
	  se quede sin espacio. Cambie <code class="filename">ValueStackTest.cpp
	  </code> para comprobar su nueva funcionalidad.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 9 pero use el <code class="classname">vector
	  </code> de la STL como la implementación interna de
	  <code class="classname">ValueStack</code>. Note lo sencillo que es.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">ValueStackTest.cpp </code> para que
	  use un <code class="classname">vector </code> de la STL en vez de un
	  <code class="classname">Stack </code> en el
	  <code class="function">main()</code>. Dése cuenta del comportamiento
	  en tiempo de ejecución: ¿Se genera un grupo de objetos por
	  defecto cuando se crea el <code class="classname">vector</code>?
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">TStack2.h </code> para que use un
	  <code class="classname">vector </code> de la STL.  Asegurese de que no
	  cambia la interfaz, para que <code class="filename">TStack2Test.cpp
	  </code> funcione sin cambiarse.
	</p></li><li class="listitem"><p>
	  Repita el Ejercicio 12 usando una <code class="classname">stack </code>
	  de la Librería Estándar de C++ en vez de un
	  <code class="classname">vector</code>.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">TPStash2.h </code> para que use un
	  <code class="classname">vector </code> de la STL como su
	  implementación interna. Asegurese que no cambia la interfaz,
	  por lo que <code class="filename">TPStash2Test.cpp </code> funciona
	  sin modificarse.
	</p></li><li class="listitem"><p>
	  En <code class="filename">IterIntStack.cpp</code>, modifique
	  <code class="classname">IntStackIter </code> para darle un
	  constructor de «marcador final», y añada el
	  <code class="literal">operator== </code> y el <code class="literal">operator!=</code>. En el
	  <code class="function">main()</code>, use un iterador para moverse a
	  través de los elementos del contenedor hasta que se
	  encuentre el marcador.
	</p></li><li class="listitem"><p>
	  Use <code class="filename">TStack2.h</code>,
	  <code class="filename">TPSTash2.h</code>, y
	  <code class="filename">Shape.h</code>, instancie los contenedores
	  <code class="classname">PStash </code> y <code class="classname">Stack
	  </code> para que contenga
	  <code class="classname">Shape*</code>, rellene cada uno con punteros
	  a <code class="classname">Shape</code>, entonces use iteradores para
	  moverse a través de cada contenedor y llame a
	  <code class="function">draw() </code> para cada objeto.
	</p></li><li class="listitem"><p>
	  Cree una plantilla en la clase <code class="type">Int </code> para
	  que pueda alojar cualquier tipo de objetos (Siéntase libre
	  de cambiar el nombre de la clase a algo más apropiado).
	</p></li><li class="listitem"><p>
	  Cree una plantilla de la clase <code class="classname">IntArray
	  </code> en <code class="filename">IostreamOperatorOverloading.cpp
	  </code> del capítulo 12, introduzca en plantilla ambos
	  tipos de objetos que están contenidos y el tamaño del array
	  interno
	</p></li><li class="listitem"><p>
	  Convierta <code class="classname">ObjContainer </code> en
	  <code class="filename">NestedSmartPointer.cpp </code> del Capítulo 12
	  en una plantilla. Compruebelo con dos clases diferentes.
	</p></li><li class="listitem"><p>
	  Modifique <code class="filename">C15:OStack.h </code> y
	  <code class="filename">C15:OStackTest.cpp </code> consiguiendo que
	  <code class="classname">class Stack </code> pueda tener múltiple
	  herencia automáticamente de la clase contenida y de
	  <code class="classname">Object</code>. La <code class="classname">Stack
	  </code> contenida debe aceptar y producir sólo punteros
	  del tipo contenido.
	</p></li><li class="listitem"><p>
	  Repita el ejercicio 20 usando <code class="classname">vector </code>
	  en vez de <code class="classname">Stack</code>.
	</p></li><li class="listitem"><p>
	  Herede una clase <code class="classname">StringVector </code> de
	  <code class="classname">vector&lt;void&gt; </code> y redefina las
	  funciones miembro <code class="function">push_back() </code> y el
	  <code class="literal">operator[] </code> para que acepten y produzcan
	  únicamente <code class="type">string* </code> (y realizen el
	  moldeado adecuado). Ahora creee una plantilla que haga
	  automáticamente lo mismo a una clase contenedora para
	  punteros de cualquier tipo. Esta técnica es a menudo usada
	  para reducir el código producido por muchas instanciaciones
	  de templates.
	</p></li><li class="listitem"><p>
	  En <code class="filename">TPStash2.h</code>, añada y compruebe un
	  <code class="literal">operator- </code> para
	  <code class="classname">PStash::iterator</code>, siguiendo la lógica
	  de <code class="literal">operator+</code>.
	</p></li><li class="listitem"><p>
	  En <code class="filename">Drawing.cpp</code>, añada y compruebe una
	  plantilla de función que llame a funciones miembro
	  <code class="function">erase()</code>.
	</p></li><li class="listitem"><p>
	  (Avanzado) Modifique la clase <code class="classname">Stack </code>
	  en <code class="filename">TStack2.h </code> para permitir una
	  granularidad de la propiedad: Añada una bandera para cada
	  enlace indicando si el enlace posee el objeto al que apunta,
	  y de soporte a esta información la función <code class="function">push()
	  </code> y en el destructor. Añada funciones miembro para
	  leer y cambiar la propiedad de cada enlace.
	</p></li><li class="listitem"><p>
	  (Avanzado) Modifique <code class="filename">PointerToMemberOperator.cpp
	  </code> del Capítulo 12 para que la
	  <code class="classname">FunctionObject </code> y el <code class="literal">operator-&gt;* </code> sean convertidos en
	  plantillas para que funcionen con cualquier tipo de retorno
	  (para <code class="literal">operator-&gt;*</code>, tendrá
	  que usar <span class="emphasis"><em>plantillas miembro </em></span> descritas
	  en el Volumen 2). Añada soporte y compruebe para cero, uno y
	  dos argumentos en las funciones miembro
	  <code class="classname">Dog</code>.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp8500448" href="#idp8500448" class="para">80</a>] </sup>Con
	  la excepción, en Java, de los tipos de datos primitivos, que se
	  hicieron no <code class="classname">Object</code>s por eficiencia. </p></div><div class="footnote"><p><sup>[<a id="ftn.idp8504208" href="#idp8504208" class="para">81</a>] </sup>La librería
	  OOPS, por Keith Gorlen, mientras estaba en el NIH.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8516200" href="#idp8516200" class="para">82</a>] </sup><span class="emphasis"><em>The C++ Programming
	      Language</em></span> by Bjarne Stroustrup (1ª edición,
	    Addison-Wesley, 1986)</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8519376" href="#idp8519376" class="para">83</a>] </sup>
	    La inspiración de los templates parece venir de los
	    <code class="keyword">generics</code> de ADA</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8558768" href="#idp8558768" class="para">84</a>] </sup>Todos los métodos en Smalltalk y Python están débilmente
	    tipados, y ese es el motivo por lo que estos lenguajes no
	    necesitan el mecanismo de los templates.  En efecto, se
	    consiguen plantillas sin templates.</p></div></div></div><div class="appendix" title="Apéndice A. Estilo de codificación"><div class="titlepage"><div><div><h2 class="title"><a id="ApendiceA"></a>Apéndice A. Estilo de codificación</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp8819896">A.1. General</a></span></dt><dt><span class="sect1"><a href="#idp8833216">A.2. Nombres de fichero</a></span></dt><dt><span class="sect1"><a href="#idp8839992">A.3. Marcas comentadas de inicio y fin</a></span></dt><dt><span class="sect1"><a href="#idp8848376">A.4. Paréntesis, llaves e indentación</a></span></dt><dt><span class="sect1"><a href="#idp8879240">A.5. Nombres para identificadores</a></span></dt><dt><span class="sect1"><a href="#idp8885584">A.6. Orden de los #includes</a></span></dt><dt><span class="sect1"><a href="#idp8891576">A.7. Guardas de inclusión en ficheros de cabecera</a></span></dt><dt><span class="sect1"><a href="#idp8895848">A.8. Uso de los espacios de nombres</a></span></dt><dt><span class="sect1"><a href="#idp8899928">A.9. 
      Utilización de <code class="function">require()</code> y <code class="function">assure()</code>
    </a></span></dt></dl></div><div class="highlights"><p>
      Este apéndice no trata sobre indentación o colocación de
      paréntesis y llaves, aunque sí que se menciona. Trata sobre las
      directrices generales que se usan en este libro para la
      organización de los listados de código.
    </p></div><p>
    Aunque muchas de estas cuestiones se han tratado a lo largo del
    libro, este apéndice aparece al final de manera que se puede asumir que
    cada tema es FIXME:juego limpio, y si no entiende algo puede buscar
    en la sección correspondiente.
  </p><p>
    Todas las decisiones sobre estilo de codificación en este libro han
    sido consideradas y ejectuadas deliberadamente, a veces a lo largo
    de períodos de años. Por supuesto, cada uno tiene sus razones para
    organizar el código en el modo en que lo hace, y yo simplemente
    intento explicarle cómo llegué a tomar mi postura y las
    restricciones y factores del entorno que me llevaron a tomar esas
    decisiones.
  </p><div class="sect1" title="A.1. General"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8819896"></a>A.1. General</h2></div></div></div><p>
      En el texto de este libro, los identificadores (funciones,
      variables, y nombres de clases) aparecen en negrita. Muchas
      palabras reservadas también son negritas, exceptuando aquellas que
      se usan tan a menudo que escribirlas en negrita puede resultar
      tedioso, como «class» o «virtual».
    </p><p>
      Utilizo un estilo de codificación particular para los ejemplos de
      este libro. Se desarrolló a lo largo de varios años, y se inspiró
      parcialmente en el estilo de
      <span class="author"><span class="firstname">Bjarne</span> <span class="surname">Stroustrup</span></span>
      en el <em class="citetitle">The C++ Programming Language</em>
      <sup>[<a id="idp8822696" href="#ftn.idp8822696" class="footnote">85</a>]</sup>
      original. El asunto del estilo de codificación es ideal para
      horas de acalorado debate, así que sólo diré que no trato de
      dictar el estilo correcto a través de mis ejemplos; tengo mis
      propios motivos para usar el estilo que uso. Como C++ es un
      lenguaje de formato libre, cada uno puede continuar usando el
      estilo que le resulte más cómodo.
    </p><p>
      Dicho esto, sí haré hincapié en que es importante tener un estilo
      consistente dentro de un proyecto. Si busca en Internet,
      encontrará un buen número de herramientas que se pueden utilizar
      para reformatear todo el código de un proyecto para conseguir esa
      valiosa consistencia.
    </p><p>
      Los programas de este libro son ficheros extraídos
      automáticamentente del texto del libro, lo que permite que se
      puedan probar para asegurar que funcionan correctamente
      <sup>[<a id="idp8825240" href="#ftn.idp8825240" class="footnote">86</a>]</sup>. De ese modo, el código mostrado en el libro debería
      funcionar sin errores cuando se compile con una implementación
      conforme al Estándar C++ (no todos los compiladores soportan todas
      las características del lenguaje). Las sentencias que
      <span class="emphasis"><em>deberían</em></span> causar errores de compilación están
      comentadas con <code class="code">//!</code> de modo que se pueden descubrir y probar
      fácilmente de modo automático. Los errores descubiertos por el
      autor aparecerán primero en la versión electrónica del libro
      (<a class="ulink" href="http://www.BruceEchel.com" target="_top">www.BruceEckel.com</a>) y
      después en las actualizaciones del libro.
    </p><p>
      Uno de los estándares de este libro es que todos los programas
      compilarán y enlazarán sin errores (aunque a veces causarán
      advertencias). Algunos de los programas, que demuestran sólo un
      ejemplo de codificación y no representan programas completos,
      tendrán funciones <code class="function">main()</code> vacías, como ésta:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span>
</pre><p>
      Esto permite que se pueda enlazar el programa sin errores.
    </p><p>
      El estándar para <code class="function">main()</code> es retornar un
      <code class="type">int</code>, pero C++ Estándar estipula que si no hay una
      sentencia <code class="keyword">return</code> en <code class="function">main()</code>, el
      compilador generará automáticamente código para <code class="code">return
      0</code>. Esta opción (no poner un <code class="keyword">return</code> en
      <code class="function">main()</code>) se usa en el libro (algunos
      compiladores producen advertencias sobre ello, pero es porque no
      son conformes con C++ Estándar).
    </p></div><div class="sect1" title="A.2. Nombres de fichero"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8833216"></a>A.2. Nombres de fichero</h2></div></div></div><p>
      En C, es tradición nombrar a los ficheros de cabecera (que
      contienen las declaraciones) con una extensión
      <code class="filename">.h</code> y a los ficheros de implementación (que
      generan alojamiento en memoria y código) con una extensión
      <code class="filename">.c</code>. C++ supuso una evolución. Primero fue
      desarrollado en Unix, donde el sistema operativo distingue entre
      mayúsculas y minúsculas para nombres de ficheros. Los nombres
      originales para los ficheros simplemente se pusieron en mayúscula:
      <code class="filename">.H</code> y <code class="filename">.C</code>. Esto, por
      supuesto, no funcionaba en sistemas operativos que no distinguen
      entre mayúsculas y minúsculas como DOS. Los vendedores de C++ para
      DOS usaban extensiones <code class="filename">hxx</code> y
      <code class="filename">cxx</code>, o <code class="filename">hpp</code> y
      <code class="filename">cpp</code>. Después, alguien se dio cuenta que la
      única razón por la que se puede necesitar un extensión diferente
      es que el compilador no puede determinar si debe compilarlo como C
      o C++. Como el compilador nunca compila ficheros de cabecera
      directamente, sólo el fichero de implementación necesita una
      distinción. Ahora, en prácticamente todos los sistemas, la
      costumbre es usar <code class="filename">cpp</code> para los ficheros de
      implementación y <code class="filename">.h</code> para los ficheros de
      cabecera. Fíjese que cuando se incluye un fichero de cabecera C++,
      se usa la opción de no poner extensión al nombre del fichero, por
      ejemplo: <code class="code">#include &lt;iostream&gt;</code>
    </p></div><div class="sect1" title="A.3. Marcas comentadas de inicio y fin"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8839992"></a>A.3. Marcas comentadas de inicio y fin</h2></div></div></div><p>
      Un tema muy importante en este libro es que todo el código que
      puede ver en el libro ha sido sido verificado (con al menos un
      compilador). Esto se consigue extrayendo automáticamente los
      listados del libro. Para facilitar esta tarea, todos los
      listados de código susceptibles de ser compilados (al contrario
      que los fragmentos, que hay pocos) tienen unas marcas comentadas
      al principio y al final. Estas marcas las usa la herramienta de
      extracción de código <code class="filename">ExtractCode.cpp</code> del
      Volumen 2 de este libro (y que se puede encontrar en el sitio
      web <a class="ulink" href="http://www.BruceEchel.com" target="_top">www.BruceEckel.com</a>) para
      extraer cada listado de código a partir de la versión en texto
      plano ASCII de este libro.
    </p><p>
      La marca de fin de listado simplemente le indica a
      <code class="filename">ExtractCode.cpp</code> que ese es el final del
      listado, pero la marca de comienzo incluye información sobre el
      subdirectorio al que corresponde el fichero (normalmente
      organizado por capítulos, así que si corresponde al Capítulo 8
      debería tener una etiqueta como <code class="literal">C08</code>), seguido
      de dos puntos y el nombre del fichero.
    </p><p>
      Como <code class="filename">ExtractCode.cpp</code> también crea un
      <code class="filename">makefile</code> para cada subdirectorio, la
      información de cómo construir el programa y la línea de comando
      que se debe usar para probarlo también se incorpora a los
      listados. Si un programa es autónomo (no necesita ser enlazado con
      nada más) no tiene información extra. Esto también es cierto para
      los ficheros de cabecera. Sin embargo, si no contiene un
      <code class="filename">main()</code> y necesita enlazarse con algún otro,
      aparece un <code class="literal">{O}</code> después del nombre del
      fichero. Si ese listado es el programa principal pero necesita
      ser enlazado con otros componentes, hay una línea adicional que
      comienza con <code class="literal">//{L}</code> y continúa con el nombre
      de todos los ficheros con los que debe enlazarse (sin
      extensiones, dado que puede variar entre plataformas).
    </p><p>
      Puede encontrar ejemplos a lo largo de todo el libro.
    </p><p>
      Cuando un fichero debe extraerse sin que las marcas de inicio y fin
      deban incluirse en el fichero extraído (por ejemplo, si es un
      fichero con datos para una prueba) la marca de inicio va seguida
      de un '!'.
    </p></div><div class="sect1" title="A.4. Paréntesis, llaves e indentación"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8848376"></a>A.4. Paréntesis, llaves e indentación</h2></div></div></div><p>
      Habrá notado que el estilo de este libro es diferente a la mayoría
      de los estilos C tradicionales. Por supuesto, cualquiera puede
      pensar que su propio estilo es más racional. Sin embargo, el
      estilo que se emplea aquí tiene una lógica más simple, que se
      presentará mezclada con las de otros estilos desarrollados.
    </p><p>
      El estilo está motivado por una cosa: la presentación, tanto
      impresa como en un seminario. Quizá sus necesidades sean
      diferentes porque no realiza muchas presentaciones. Sin embargo,
      el código real se lee muchas más veces de las que se escribe, y por
      eso debería ser fácil de leer. Mis dos criterios más importantes
      son la «escaneabilidad» (que se refiere a la facilidad
      con la que el lector puede comprender el significado de una única
      línea) y el número de líneas que caben en una página. Lo segundo
      puede sonar gracioso, pero cuando uno da una charla, distrae mucho
      a la audiencia que el ponente tenga que avanzar y retroceder
      diapositivas, y sólo unas pocas líneas de más puede provocar este
      efecto.
    </p><p>
      Todo el mundo parece estar de acuerdo en que el código que se
      pone dentro de llaves debe estar indentado. En lo que la gente
      no está de acuerdo - y es el sitio donde más inconsistencia
      tienen los estilos - es: ¿Dónde debe ir la llave de apertura?
      Esta única cuestión, creo yo, es la que causa la mayoría de las
      variaciones en los estilos de codificación (Si quiere ver una
      enumeración de estilos de codificación vea <em class="citetitle">C++
      Programming Guidelines</em>, de [FIXME:autores] Tom Plum
      y Dan Saks, Plum Hall 1991), Intentaré convencerle de que muchos
      de los estilos de codificación actuales provienen de la
      restricciones previas al C Estándar (antes de los prototipos de
      función) de manera que no son apropiadas actualmente.
    </p><p>
      Lo primero, mi respuesta a esa pregunta clave: la llave de
      apertura debería ir siempre en la misma línea que el
      «precursor» (es decir «cualquier cosa de la que
      sea cuerpo: una clase, función, definición de objeto, sentencia
      <code class="keyword">if</code>, etc». Es una regla única y
      consistente que aplico a todo el código que escribo, y hace que
      el formateo de código sea mucho más sencillo. Hace más sencilla la
      «escaneabilidad» - cuando se lee esta línea:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">);</span>
</pre><p>
      Se sabe, por el punto y coma al final de la línea, que esto es una
      declaración y no hay nada más, pero al leer la línea:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span>
</pre><p>
      inmediatamente se sabe que se trata de una definición porque la
      línea termina con una llave de apertura, y no un punto y
      coma. Usando este enfoque, no hay diferencia a la hora de
      colocar el paréntesis de apertura en una definición de múltiples
      líneas.
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span>
      <span class="hl kwb">int</span> b <span class="hl opt">=</span> a <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> b <span class="hl opt">*</span> <span class="hl num">2</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre><p>
      y para una definición de una sola línea que a menudo se usa para inlines:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) *</span> <span class="hl num">2</span><span class="hl opt">; }</span>
</pre><p>
      Igualmente, para una clase:
    </p><pre class="programlisting">
<span class="hl kwc">class</span> Thing<span class="hl opt">;</span>
</pre><p>
      es una declaración del nombre de una clase, y
    </p><pre class="programlisting">
<span class="hl kwc">class</span> Thing <span class="hl opt">{</span>
</pre><p>
      es una definición de clase. En todos los casos, se puede saber
      mirando una sola línea si se trata de una declaración o una
      definición. Y por supuesto, escribir la llave de apertura en la
      misma línea, en lugar de una línea propia, permite ahorrar
      espacio en la página.
    </p><p>
      Así que ¿por qué tenemos tantos otros estilos? En concreto, verá
      que mucha gente crea clases siguiente el estilo anterior (que
      Stroustrup usa en todas las ediciones de su libro <em class="citetitle">The
      C++ Programming Language</em> de Addison-Wesley) pero crean
      definiciones de funciones poniendo la llave de apertura en una
      línea aparte (lo que da lugar a muchos estilos de indentación
      diferentes). Stroustrup lo hace excepto para funciones inline
      cortas. Con el enfoque que yo describo aquí, todo es consistente -
      se nombra lo que sea (<code class="keyword">class</code>, functión, <code class="keyword">enum</code>, etc)
      y en la misma línea se pone la llave de apertura para indicar que
      el cuerpo de esa cosa está debajo. Y también, la llave de apertura
      se pone en el mismo sitio para funciones inline que para
      definiciones de funciones ordinarias.
    </p><p>
      Creo que el estilo de definición de funciones que utiliza mucha
      gente viene de el antiguo prototipado de funciones de C, en el que
      no se declaraban los argumentos entre los paréntesis, si no entre
      el paréntesis de cierre y la llave de apertura (esto demuestra que
      las raíces de C son el lenguaje ensamblador):
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">bar</span><span class="hl opt">()</span>
     <span class="hl kwb">int</span> x<span class="hl opt">;</span>
     <span class="hl kwb">float</span> y<span class="hl opt">;</span>
    <span class="hl opt">{</span>
     <span class="hl com">/* body here */</span>
    <span class="hl opt">}</span>
</pre><p>
      Aquí, quedaría bastante mal poner la llave de apertura en la
      misma línea, así que nadie lo hacía. Sin embargo, había
      distintas opiniones sobre si las llaves debían
      indentarse con el cuerpo del código o debían dejarse a nivel con
      el «precursor». De modo que tenemos muchos estilos
      diferentes.
    </p><p>
      Hay otros argumentos para poner la llave en la línea
      siguiente a la declaración (de una clase, <code class="keyword">struct</code>,
      función, etc). Lo siguiente proviene de un lector, y lo presento
      aquí para que sepa a qué se refiere.
    </p><p>
      Los usuarios experimentado de <span class="command"><strong>vi</strong></span> (vim)
      saben que pulsar la tecla «]» dos veces lleva el
      cursor a la siguiente ocurrencia de «{» (o ^L) en la
      columna 0. Esta característica es extremadamente útil para moverse
      por el código (saltando a la siguiente defición de función o
      clase). [Mi comentario: cuando yo trabajaba en Unix, GNU
      Emacs acababa de aparecer y yo me convertí en un fan suyo. Como
      resultado, <span class="command"><strong>vi</strong></span> nunca ha tenido sentido
      para mí, y por eso yo no pienso en términos de «situación
      de columna 0». Sin embargo, hay una buena cantidad de
      usuarios de <span class="command"><strong>vi</strong></span> ahí fuera, a los que les
      afecta esta característica.]
    </p><p>
      Poniendo la «{» en la siguiente línea se eliminan
      algunas confusiones en sentencias condicionales complejas,
      ayudando a la escaneabilidad.
    </p><pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>cond1
       <span class="hl opt">&amp;&amp;</span> cond2
       <span class="hl opt">&amp;&amp;</span> cond3<span class="hl opt">) {</span>
       statement<span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre><p>
      Lo anterior [dice el lector] tiene una escaneabilidad pobre. Sin embargo,
    </p><pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>cond1
    <span class="hl opt">&amp;&amp;</span> cond2
    <span class="hl opt">&amp;&amp;</span> cond3<span class="hl opt">)</span>
    <span class="hl opt">{</span>
    statement<span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre><p>
      separa el <code class="keyword">if</code> del cuerpo, mejorando la
      legibilidad. [Sus opiniones sobre si eso es cierto variarán
      dependiendo para qué lo haya usado.]
    </p><p>
      Finalmente, es mucho más fácil visualizar llaves emparejadas
      si están alineadas en la misma columna. Visualmente destacan mucho
      más. [Fin del comentario del lector]
    </p><p>
      El tema de dónde poner la llave de apertura es probablemente el
      asunto en el que hay menos acuerdo. He aprendido a leer ambas
      formas, y al final cada uno utiliza la que le resulta más
      cómoda. Sin embargo, he visto que el estándar oficial de
      codificación de Java (que se puede encontar en la página de Java
      de Sun) efectivamente es el mismo que yo he presentado aquí - dado
      que más personas están empezando a programar en ambos lenguajes,
      la consistencia entre estilos puede ser útil.
    </p><p>
      Mi enfoque elimina todas las excepciones y casos especiales, y
      lógicamente produce un único estilo de indentación, Incluso con
      un cuerpo de función, la consistencia se mantiene, como en:
    </p><pre class="programlisting">
<span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      cout <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">*</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre><p>
      El estilo es fácil de enseñar y recordar - use una regla simple y
      consistente para todo sus formatos, no una para clases, dos para
      funciones (funciones inline de una línea vs. multi-línea), y
      posiblemente otras para bucles, sentencias <code class="keyword">if</code>,
      etc. La consistencia por si sola merece ser tenida en
      cuenta. Sobre todo, C++ es un lenguaje más nuevo que C, y aunque
      debemos hacer muchas concesiones a C, no deberíamos acarrear demasiados
      FIXME:artifacts que nos causen problemas en el futuro. Problemas
      pequeños multiplicados por muchas líneas de código se convierten en
      grandes problemas. Para un examen minucioso del asunto, aunque
      trata de C, vea <em class="citetitle">C Style: Standards and
      Guidelines</em>, de David Straker (Prentice-Hall 1992).
    </p><p>
      La otra restricción bajo la que debo trabajar es la longitud de la
      línea, dado que el libro tiene una limitación de 50
      caracteres. ¿Qué ocurre si algo es demasiado largo para caber en
      una línea? Bien, otra vez me esfuerzo en tener una política
      consistente para las líneas partidas, de modo que sean fácilmente
      visibles. Siempre que sean parte de una única definición, lista de
      argumentos, etc., las líneas de continuación deberían indentarse
      un nivel respecto al comienzo de la definición, lista de
      argumentos, etc.
    </p></div><div class="sect1" title="A.5. Nombres para identificadores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8879240"></a>A.5. Nombres para identificadores</h2></div></div></div><p>
      Aquellos que conozcan Java notarán que yo me he cambiado al estilo
      estándar de Java para todos los identificadores. Sin embargo, no
      puedo ser completamente consistente porque los identificadores en
      C Estándar y en librerías C++ no siguen ese estilo.
    </p><p>
      El estilo es bastante sencillo. La primera letra de un
      identificador sólo se pone en mayúscula si el identificador es una
      clase. Si es una función o variable, la primera letra siempre va
      en minúscula. El resto del identificador consiste en una o más
      palabras, todas juntas pero se distinguen porque la primera letra
      de cada palabra es mayúscula. De modo que una clase es algo
      parecido a esto:
    </p><pre class="programlisting">
<span class="hl kwc">class</span> FrenchVanilla <span class="hl opt">:</span> <span class="hl kwc">public</span> IceCream <span class="hl opt">{</span>
</pre><p>
      y un objeto es algo como esto:
    </p><pre class="programlisting">
FrenchVanilla <span class="hl kwd">myIceCreamCone</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
</pre><p>
      y una función:
    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">eatIceCreamCone</span><span class="hl opt">();</span>
</pre><p>
      (tanto para un método como para un función normal).
    </p><p>
      La única excepción son las constantes en tiempo de compilación
      (<code class="keyword">const</code> y <code class="keyword">#define</code>), en las que todas las letras
      del identificador son mayúsculas.
    </p><p>
      El valor del estilo es que el uso de mayúsculas tiene significado
      - viendo la primera letra se puede saber si es una clase o un
      objeto/método. Esto es especialmente útil cuando se invocan
      miembros estáticos.
    </p></div><div class="sect1" title="A.6. Orden de los #includes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8885584"></a>A.6. Orden de los #includes</h2></div></div></div><p>
      Los ficheros de cabecera se incluyen en orden «del más
      específico al más general». Es decir, cualquier fichero de
      cabecera en el directorio local se incluye primero, después las
      «herramientas» propias, como
      <code class="filename">require.h</code>, luego cabeceras de librerías de
      terceros, después cabeceras de la librería estándar C++, y
      finalmente cabeceras de la librería C.
    </p><p>
      La justificación para esto viene de John Lakos en
      <em class="citetitle">Large-Scale C++ Software Design</em>
      (Addison-Wesley, 1996):
    </p><div class="blockquote"><blockquote class="blockquote"><p>
	FIXME Los errores de uso latentes se puede evitar asegurando
	que el fichero .h de un componente es coherente en si mismo -
	sin declaraciones o definiciones externas. Incluir el fichero
	<code class="filename">.h</code> como primera línea del fichero
	<code class="filename">.c</code> asegura que no falta ninguna pieza de
	información de la interfaz física del componente en el fichero
	<code class="filename">.h</code> (o, si la hay, aparecerá en cuanto
	intente compilar el fichero <code class="filename">.c</code>.
      </p></blockquote></div><p>
      Si el orden de inclusión fuese «desde el más específico al
      más general», entonces es más probable que si su fichero de
      cabecera no es coherente por si mismo, lo descubrirá antes y
      prevendrá disgustos en el futuro.
    </p></div><div class="sect1" title="A.7. Guardas de inclusión en ficheros de cabecera"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8891576"></a>A.7. Guardas de inclusión en ficheros de cabecera</h2></div></div></div><p>
      Los guardas de inclusión se usan siempre en los ficheros de
      cabecera para prevenir inclusiones múltiples durante la
      compilación de un único fichero <code class="filename">.cpp</code>. Los
      guardas de inclusión se implementan usado <code class="keyword">#define</code> y
      comprobando si el nombre no ha sido definido previamente. El
      nombre que se usa para el guarda está basado en el nombre del
      fichero de cabecera, pero con todas las letras en mayúscula y
      reemplazando el punto por un guión bajo. Por ejemplo:
    </p><pre class="programlisting">
<span class="hl slc">// IncludeGuard.h</span>
    <span class="hl ppc">#ifndef INCLUDEGUARD_H</span>
    <span class="hl ppc">#define INCLUDEGUARD_H</span>
    <span class="hl slc">// Body of header file here...</span>
    <span class="hl ppc">#endif</span> <span class="hl slc">// INCLUDEGUARD_H</span><span class="hl ppc"></span>
</pre><p>
      El identificador de la última línea se incluye únicamente por
      claridad. Algunos preprocesadores ignoran cualquier carácter que
      aparezca después de un <code class="keyword">#endif</code>, pero no es el
      comportamiento estándar y por eso el identificador aparece
      comentado.
    </p></div><div class="sect1" title="A.8. Uso de los espacios de nombres"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8895848"></a>A.8. Uso de los espacios de nombres</h2></div></div></div><p>
      En los ficheros de cabecera, se debe evitar de forma escrupulosa
      cualquier contaminación del espacio de nombres. Es decir, si se
      cambia el espacio de nombres fuera de una función o clase,
      provocará que el cambio ocurra también en cualquier fichero que
      incluya ese fichero de cabecera, lo que resulta en todo tipo de
      problemas. No están permitidas las declaraciones <code class="keyword">using</code> de
      ningún tipo fuera de las definiciones de función, y tampoco deben
      ponerse directivas <code class="keyword">using</code> globales en ficheros de
      cabecera.
    </p><p>
      En ficheros <code class="filename">cpp</code>, cualquier directiva
      <code class="keyword">using</code> global sólo afectará a ese fichero, y por eso en
      este libro se usan generalmente para conseguir código más legible,
      especialmente en programas pequeños.
    </p></div><div class="sect1" title="A.9. Utilización de require() y assure()"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp8899928"></a>A.9. 
      Utilización de <code class="function">require()</code> y <code class="function">assure()</code>
    </h2></div></div></div><p>
      Las funciones <code class="function">require()</code> y
      <code class="function">assure()</code> definidas en
      <code class="filename">requiere.h</code> se usan constantemente a lo
      largo de todo el libro, para que informen de problemas. Si se
      está familiarizado con los conceptos de precondiciones y
      postcondiciones (introducidos por <span class="personname"><span class="firstname">Bertrand</span> <span class="surname">
      Meyer</span></span>) es fácil reconocer que el uso de
      <code class="function">require()</code> y <code class="function">assure()</code>
      más o menos proporciona precondiciones (normalmente) y
      postcondiciones (ocasionalmente). Por eso, al principio de una
      función, antes de que se ejecute el «núcleo» de la
      función, se comprueban las precondiciones para estar seguro de
      que se cumplen todas las condiciones necesarias. Entonces, se
      ejecuta el «núcleo» de la función, y a veces se
      comprueban algunas postcondiciones para estar seguro de que el
      nuevo estado en el que han quedado los datos está dentro de los
      parámetros correspondientes. Notará que las comprobaciones de
      postcondición se usan raramente en este libro, y
      <code class="function">assure()</code> se usa principalmente para estar
      seguro de que los ficheros se abren adecuadamente.
    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp8822696" href="#idp8822696" class="para">85</a>] </sup>
	  FIXME:Ibid.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp8825240" href="#idp8825240" class="para">86</a>] </sup>
	  (N. de T.) Se refiere al libro original. En esta traducción,
	  los programas son ficheros externos incluidos en el texto.
	</p></div></div></div><div class="appendix" title="Apéndice B. Directrices de Programación"><div class="titlepage"><div><div><h2 class="title"><a id="ApendiceB"></a>Apéndice B. Directrices de Programación</h2></div></div></div><div class="highlights"><p>
      Este apéndice es una colección de sugerencias para programación
      con C++. Se han reunido a lo largo de mi experiencia en
      como docente y programador y
    </p></div><p>
    también de las aportaciones de amigos incluyendo a Dan Saks
    (co-autor junto a Tom Plum de <em class="citetitle">C++ Programming
      Guidelines</em>, Plum Hall, 1991), Scott Meyers (autor de
    <em class="citetitle">Effective C++</em>, 2ª edición, Addison-Wesley,
    1998), and Rob Murray (autor de <em class="citetitle">C++ Strategies &amp;
    Tactics</em>, Addison-Wesley, 1993). También, muchos de los
    consejos están resumidos a partir del contenido de
    <em class="citetitle">Thinking in C++</em>.
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	Primero haga que funcione, después hágalo rápido. Esto es cierto
	incluso si se está seguro de que una trozo de código es
	realmente importante y se sabe que será un cuello de botella es
	el sistema. No lo haga. Primero, consiga que el sistema tenga un
	diseño lo más simple posible. Entonces, si no es suficientemente
	rápido, optimícelo. Casi siempre descubrirá que
	«su» cuello de botella no es el problema. Guarde su
	tiempo para lo verdaderamente importante.
      </p></li><li class="listitem"><p>
	La elegancia siempre vale la pena. No es un pasatiempo
	frívolo. No sólo permite que un programa sea más fácil de
	construir y depurar, también es más fácil de comprender y
	mantener, y ahí es donde radica su valor económico. Esta
	cuestión puede requerir de alguna experiencia para creerselo,
	porque puede parecer que mientras se está haciendo un trozo de
	código elegante, no se es productivo. La productividad aparece
	cuando el código se integra sin problemas en el sistema, e
	incluso cuando se modifica el código o el sistema.
      </p></li><li class="listitem"><p>
	Recuerde el principio «divide y vencerás». Si el
	problema al que se enfrenta es desmasiado confuso, intente
	imaginar la operación básica del programa se puede hacer, debido
	a la existencia de una «pieza» mágica que hace el
	trabajo difícil. Esta «pieza» es un objeto -
	escriba el código que usa el objeto, después implemente ese
	objeto encapsulando las partes difíciles en otros objetos, etc.
      </p></li><li class="listitem"><p>
	No reescriba automáticamente todo su código C a C++ a menos que
	necesite un cambiar significativamente su funcionalidad (es
	decir, no lo arregle si no está roto). <span class="emphasis"><em>Recompilar
	C</em></span> en C++ es un positivo porque puede revelar errores
	ocultos. Sim embargo, tomar código C que funciona bien y
	reescribirlo en C++ no es la mejor forma de invertir el tiempo,
	a menos que la versión C++ le ofrezca más oportunidad de
	reutilizarlo como una clase.
      </p></li><li class="listitem"><p>
	Si tiene un gran trozo de código C que necesite cambios, primero
	aisle las partes del código que no se modificará, posiblemente
	envolviendo esas funciones en una «clase API» como
	métodos estáticos. Después ponga aténción al código que va a
	cambiar, recolocandolo dentro de clases para facilitar las
	modificaciones en el proceso de mantenimiento.
      </p></li><li class="listitem"><p>
	Separe al creador de la clase del usuario de la clase (el
	<span class="emphasis"><em>programador cliente</em></span>). El usuario de la
	clase es el «consumidor» y no necesita o no quiere
	conocer que hay dentro de la clase. El creador de la clase debe
	ser un experto en diseño de clases y escribir la clase para que
	pueda ser usada por el programador más inexperto posible, y aún
	así funcionar de forma robusta en la aplicación. El uso de la
	librería será sencillo sólo is es transparente.
      </p></li><li class="listitem"><p>
	Cuando cree una clase, utilice nombres tan claros como sea
	posible. Eo objetivo debería ser que la interface del
	programador cliente sea conceptualmente simple. Intente utilizar
	nombres tan claros que los comentarios sean innecesarios. Luego,
	use sobrecarga de funciones y argumentos por defecto para crear
	un interface intuitiva y fácil de usar.
      </p></li><li class="listitem"><p>
	El control de acceso permite (al creador de la clase) cambiar
	tanto como sea posible en el futuro sin afectar al código del
	cliente en el que se usa la clase. FIXME:Is this light, mantenga
	todo tan privado como sea posible, y haga pública solamente la
	interfaz de la clase, usando siempre métodos en lugar de
	atributos. Ponga atributos públicos sólo cuando se vea
	obligado. Si una parte de su clase debe quedar expuesta a clases
	derivadas como protegida, proporcione una interface
	con funciones en lugar de exponer los datos reales. De este
	modo, los cambios en la implementación tendrán un impacto mínimo
	en las clases derivadas.
      </p></li><li class="listitem"><p>
	FIXME
	No caiga en FIXME:analysis paralysis. Hay algunas cosas que no
	aprenderá hasta que empiece a codificar y consiga algún tipo de
	sistema. C++ tiene mecanimos de seguridad de fábrica, dejelos
	trabajar por usted. Sus errores en una clase o conjunto de
	clases no destruirá la integridad del sistema completo.
      </p></li><li class="listitem"><p>
	El análisis y diseño debe producir, como mínimo, las clases del
	sistema, sus interfaces públicas, y las relaciones con otras
	clases, especialmente las clases base. Si su metodología de
	diseño produce más que eso, preguntese a si mismo si todas las
	piezas producidas por la metodología tiene valor respecto al
	tiempo de vide del programa. Si no lo tienen, no mantenga nada
	que no contribuya a su productividad, este es un FIXME:fact of
	life] que muchos métodos de diseño no tienen en cuenta.
      </p></li><li class="listitem"><p>
	Escriba primero el código de las pruebas (antes de escribir la
	clase), y guardelo junto a la clase. Automatice la ejecución de
	las pruebas con un <code class="function">makefile</code> o herramienta
	similar. De este modo, cualquier cambio se puede verificar
	automáticamente ejecutando el código de prueba, lo que permite
	descubrir los errores inmediatamante. Como sabe que cuenta con
	esa red de seguridad, puede arriesgar haciendo cambios más
	grandes cuando descubra la necesidad. Recuerde que las mejoras
	más importantes en los lenguajes provienen de las pruebas que
	hace el compilador: chequeo de tipos, gestión de excepciones,
	etc., pero estas características no puede ir muy lejos. Debe
	hacer el resto del camino creando un sistema robusto rellenando
	las pruebas que verifican las características específicas de la
	clase o programa concreto.
      </p></li><li class="listitem"><p>
	Escriba primero el código de las pruebas (antes de escribir la
	clase) para verificar que el diseño de la clase está
	completo. Si no puede escribir el código de pruebas, significa
	que no sabe que aspecto tiene la clases. En resumen, el echo de
	escribir las pruebas a menudo desvela características
	adicionales o restricciones que necesita la clase - esas
	características o restricciones no siempre aparecen durante el
	análisis y diseño.
      </p></li><li class="listitem"><p>
	Recuerde una regla fundamental de la ingeniería del software
	<sup>[<a id="idp8926200" href="#ftn.idp8926200" class="footnote">87</a>]</sup>: <span class="emphasis"><em>Todos los problemas del diseño de
	software se puede simplificar introduciendo una nivel más de
	indirección conceptual</em></span>. Esta única idea es la pase de
	la abstracción, la principal cualidad de la programación
	orientada a objetos.
      </p></li><li class="listitem"><p>
	Haga clases tan atómicas como sea posible: Es decir, dé a cada
	clase un propósito único y claro. Si el diseño de su clase o de
	su sistema crece hasta ser demasiado complicado, divida las
	clases complejas en otras más simples. El indicador más obvio es
	tamaño total: si una clase es grande, FIXME: chances are it's
	doing demasiado y debería dividirse.
      </p></li><li class="listitem"><p>
        Vigile las definiciones de métodos largos. Una función demasiado
        larga y complicada es dificil y cara de mantener, y es problema
        que esté intentado hacer demasiado trabajo por ella misma. Si ve
        una función así, indica que, al menos, debería dividirse en
        múltiples funciones. También puede sugerir la creación de una
        nueva clase.
      </p></li><li class="listitem"><p>
	Vigile las listas de argumentos largas. Las llamadas a función
	se vuelven difíciles de escribir, leer y mantener. En su lugar,
	intente mover el método a una clase donde sea más apropiado, y/o
	pasele objetos como argumentos.
      </p></li><li class="listitem"><p>
	No se repita. Si un trozo de código se repite en muchos métodos
	de las clases derivadas, ponga el código en un método de la
	clase base e invóquelo desde las clases derivadas. No sólo
	ahorrará código, también facilita la propagación de los
	cambios. Puede usar una función inline si necesita eficiencia. A
	veces el descubrimiento de este código común añadirá
	funcionalidad valiosa a su interface.
      </p></li><li class="listitem"><p>
	Vigile las sentencias <code class="keyword">switch</code> o cadenas de
	<code class="keyword">if-else</code>. Son indicadores típicos de <span class="emphasis"><em>código
	dependiente del tipo</em></span>, lo que significa que está
	decidiendo qué código ejecutar basándose en alguna información
	de tipo (el tipo exacto puede no ser obvio en
	principio). Normalemente puede reemplazar este tipo de código
	por herencia y polimorfismo; una llamada a una función
	polimórfica efectuará la comprobación de tipo por usted, y hará
	que el código sea más fiable y sencillo de extender.
      </p></li><li class="listitem"><p>
	Desde el punto de vista del diseño, busque y distinga cosas que
	cambian y cosas que no cambian. Es decir, busque elementos en un
	sistema que podrían cambiar sin forzar un rediseño, después
	encapsule esos elementos en clases. Puede aprender mucho más
	sobre este concepto en el capítulo <span class="emphasis"><em>Dessign
	Patterns</em></span> del Volumen 2 de este libro, disponible en
	<a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>
	<sup>[<a id="idp8935408" href="#ftn.idp8935408" class="footnote">88</a>]</sup>
      </p></li><li class="listitem"><p>
	Tenga cuidado con las FIXME
	<span class="emphasis"><em>discrepancia</em></span>. Dos objetos semánticamente
	diferentes puede tener acciones idénticas, o responsabilidades,
	y hay una tendencia natural a intentar hacer que una sea
	subclase de la otra sólo como beneficio de la herencia. Ese se
	llama discrepancia, pero no hay una justificación real para
	forzar una relación superclase/subclase donde no existe. Un
	solución mejor es crear una clase base general que produce una
	herencia para las dos como clases derivadas - eso require un
	poco más de espacio, pero sigue beneficiandose de la herencia y
	probablemente hará un importante descubrimiento sobre el diseño.
      </p></li><li class="listitem"><p>
	Tenga cuidado con la FIXME: <span class="emphasis"><em>limitación</em></span> de la
	herencia. Los diseños más límpios añaden nuevas capacidades a
	las heredadas. Un diseño sospechoso elimina capacidades durante
	la herencia sin añadir otras nuevas. Pero las reglas están
	hechas para romperse, y si está trabajando con una librería
	antigua, puede ser más eficiente restringir una clase existente
	en sus subclases que restructurar la jerarquía de modo que la
	nueva clase encaje donde debería, sobre la clase antigua.
      </p></li><li class="listitem"><p>
	No extienda funcionalidad fundamental por medio de subclases. Si
	un elemento de la interfaz es esecial para una clase debería
	estár en la clase base, no añadido en una clase derivada. Si
	está añadiendo métodos por herencia, quizá debería repensar el
	diseño.
      </p></li><li class="listitem"><p>
	Menos es más. Empiece con una interfaz mínima a una clase, tan
	pequeña y simple como necesite para resolver el problema que
	está tratando, pero no intente anticipar todas las formas en las
	que se <span class="emphasis"><em>podría</em></span> usar la clase. Cuando use la
	clase, descubrirá formas de usarla y deberá expandir la
	interface. Sin embargo, una vez que que la clase esté siendo
	usada, no podrá reducir la interfaz sin causar problemas al
	código cliente. Si necesita añadir más funciones, está bien; eso
	no molesta, únicamente obliga a recompilar. Pero incluso si los
	nuevos métodos reemplazan las funcionalidad de los antiguos,
	deje tranquila la interfaz existente (puede combinar la
	funcionalidad de la implementación subyacente si lo desea. Si
	necesita expandir la interfaz de un método existente añadiendo
	más argumentos, deje los argumentos existentes en el orden
	actual, y ponga valores por defecto a todos los argumentos
	nuevos; de este modo no perturbará ninguna de las llamadas
	antiguas a esa función.
      </p></li><li class="listitem"><p>
	Lea sus clases en voz alta para estar seguro que que suenan
	lógicas, refiriendose a las relación entre una clase base y una
	clase derivada com «es-un» y a los objetos miembro
	como «tiene-un».
      </p></li><li class="listitem"><p>
	Cuando tenga que decidir entre herencia y composición, pregunte
	si necesita hacer upcast al tipo base. Si la respuesta es no,
	elija composición (objetos miembro) en lugar de herencia. Esto
	puede eliminar la necesidad de herencia múltiple. Si hereda, los
	usuarios pensarán FIXME:they are supposed to upcast.
      </p></li><li class="listitem"><p>
	A veces, se necesita heredar para acceder a miembros protegidos
	de una clase base. Esto puede conducir a una necesidad de
	herencia múltiple. Si no necesita hacer upcast, primero derive
	una nueva clase para efectuar el acceso protegido. Entonces haga
	que la nueva clase sea un objeto miembro dentro de cualquier
	clase que necesite usarla, el lugar de heredar.
      </p></li><li class="listitem"><p>
	Típicamente, una clase base se usará principalmente para crear
	una interface a las clases que hereden de ella. De ese modo,
	cuando cree una clase base, haga que por defecto los métodos
	sean virtuales puros. El destructor puede ser también virtual
	puro (para forzar que los derivadas tengan que anularlo
	explicitamente), pero recuerde poner al destructor un cuerpo,
	porque todos destructores de la jerarquía se ejecutan siempre.
      </p></li><li class="listitem"><p>
	Cuando pone un método virtual puro en una clase, haga que todos
	los métodos de la clase sean también viruales, y ponga un
	constructor virtual. Esta propuesta evita sorpresas en el
	comportamiento de la interfaz. Empiece a quitar la palabra
	<code class="keyword">virtual</code> sólo cuando esté intentando optimizar y su
	perfilador haya apuntado en esta dirección.
      </p></li><li class="listitem"><p>
	Use atributos para variaciones en los valores y métodos
	virtuales para variaciones en el comportamiento. Es decir, si
	encuentra una clase que usa atributos estáticos con métodos que
	cambian de comportamiento basandose en esos atributos,
	probablemente deberia rediseñarla para expresar las diferencias
	de comportamiento con subclases y métodos virtuales anulados.
      </p></li><li class="listitem"><p>
	If debe hacer algo no portable, cree una abstracción para el
	servicio y póngalo en una clase. Este nivel extra de indirección
	facilita la portabilidad mejor que si se distribuyera por todo
	el programa.

      </p></li><li class="listitem"><p>
	Evite la herencia múltiple. Estará a salvo de malas situaciones,
	especialmente cuando repare las interfaces de clases que están
	fuera de su control (vea el Volumen 2). Debería ser un
	programador experimentado antes de poder diseñar con herencia
	múltiple.
      </p></li><li class="listitem"><p>
	No use herencia privada. Aunque, está en el lenguaje y parece
	que tiene una funcionalidad ocasional, ello implica ambigüedades
	importantes cuando se combina con comprobación dinámica de
	tipo. Cree un objeto miembro privado en lugar de usar herencia
	privada.
      </p></li><li class="listitem"><p>
	Si dos clases están asociadas entre si de algún modo (como los
	contenedores y los iteradores). intente hacer que una de ellas
	sea una clase amiga anidada de la otro, tal como la Librería
	Estándar C++ hace con los interadores dentro de los contenedores
	(En la última parte del Capítulo 16 se muestran ejemplos de
	esto). No solo pone de manifiesto la asociación entre las
	clases, también permite que el nombre de la clase se pueda
	reutilizar anidándola en otra clase. La Librería Estándar C++ lo
	hace definiendo un clase iterador anidada dentro de cada clase
	contenedor, de ese modo los contenedores tienen una interface
	común. La otra razón por la que querrá anidar una clase es como
	parte de la implementación privada. En ese caso, el anidamiento
	es beneficioso para ocultar la implementación más por la
	asociación de clases y la prevención de la contaminación del
	espacio de nombres citada arriba.
      </p></li><li class="listitem"><p>
	La sobrecarga de operadores en sólo «azucar
	sintáctico:» una manera diferente de hacer una llamada a
	función. Is sobrecarga un operador no está haciendo que la
	interfaz de la clase sea más clara o fácil de usar, no lo
	haga. Cree sólo un operador de conversión automática de tipo. En
	general, seguir las directrices y estilo indicados en el
	Capítulo 12 cuando sobrecargue operadores.
      </p></li><li class="listitem"><p>
	No sea una víctima de la optimización prematura. Ese camino
	lleva a la locura. In particular, no se preocupe de escribir (o
	evitar) funciones inline, hacer algunas funciones no virtuales,
	afinar el código para hacerlo más eficiente cuando esté en las
	primer fase de contrucción del sistema. El objetivo principal
	debería ser probar el diseño, a menos que el propio diseño
	requiera cierta eficiencia.
      </p></li><li class="listitem"><p>
	Normalmente, no deje que el compilador cree los constructores,
	destructores o el <code class="literal">operator=</code> por usted. Los
	diseñadores de clases siempre deberían decir qué debe hacer la
	clase exactamente y mantenerla enteramente bajo su control. Si
	no quiere costructor de copia u <code class="literal">operator=</code>,
	declarelos como privados. Recuerde que si crea algún
	constructor, el compilador un sintetizará un constructor por
	defecto.
      </p></li><li class="listitem"><p>
	Si su clase contiene punteros, debe crear el constructor de
	copia, el <code class="literal">operator=</code> y el destructor de la clase
	para que funcione adecuadamente.
      </p></li><li class="listitem"><p>
	Cuando escriba un constructor de copia para una clase
	derivada, recuerde llamar explícitamente al constructor de copia
	de la clase base (también cuando se usan objetos miembro). (Vea
	el Capítulo 14.) Si no lo hace, el constructor por defecto será
	invocado desde la case base (o el objeto miembro) y con mucha
	probabilidad no hará lo que usted espera. Para invocar el
	constructor de copia de la clase base, pásele el objeto derivado
	desde el que está copiando:
      </p><pre class="programlisting">
<span class="hl kwd">Derived</span><span class="hl opt">(</span><span class="hl kwb">const</span> Derived<span class="hl opt">&amp;</span> d<span class="hl opt">) :</span> <span class="hl kwd">Base</span><span class="hl opt">(</span>d<span class="hl opt">) {</span> <span class="hl slc">// ...</span>
</pre></li><li class="listitem"><p>
	Cuando escriba un operador de asignación para una clase
	derivada, recuerde llamar explícitamente al operador de
	asignación de la clase base. (Vea el Capítulo 14.) SI no lo
	hace, no ocurrirá nada (lo mismo es aplicable a los objetos
	miembro). Para invocar el operador de asignación de la clase
	base, use el nombre de la clase base y el operador de resolución
	de ámbito:
      </p><pre class="programlisting">
Derived<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Derived<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
    Base<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">=(</span>d<span class="hl opt">);</span>
</pre></li><li class="listitem"><p>
	Si necesita minimizar las recompilaciones durante el desarrollo
	de un proyecto largo, use FIXME: demostrada en el Capítulo 5, y
	eliminela solo si la eficiencia en tiempo de ejecución es un
	problema.
      </p></li><li class="listitem"><p>
	Evite el preprocesador. Use siempre <code class="keyword">const</code> para
	substitución de valores e inlines para las machos.
      </p></li><li class="listitem"><p>
	Mantenga los ámbitos tan pequeños como sea posible de modo que
	la visibilidad y el tiempo de vidad de los objetos sea lo más
	pequeño posible. Esto reduce el peligro de usar un objeto en el
	contexto equivocado y ello supone un bug dificil de
	encontrar. Por ejemplo, suponga que tiene un contenedor y un
	trozo de código que itera sobre él. Si copia el código para
	usarlo otro contenedor, puede que accidentalmente acabe usando
	el tamaño del primer contenedor como el límite superior del
	nuevo. Pero, si el primer contendor estuviese fuera del ámbito,
	podría detectar el error en tiempo de compilación.
      </p></li><li class="listitem"><p>
	Evite las variables globales. Esfuercese en pones los datos
	dentro de clases. En más probable que aparezcan funciones
	globales de forma natural que variables globales, aunque puede
	que después descubra que una función global puede encajar como
	método estático de una clase.
      </p></li><li class="listitem"><p>
	Si necesita declara una clase o función de una librería, hágalo
	siempre incluyendo su fichero de cabecera. Por ejemplo, si
	quiere crear una función para escribir en un
	<code class="classname">ostream</code>, no declare nunca el
	<code class="classname">ostream</code> por usted mismo, usando una
	especificación de tipo incompleta como esta:
      </p><pre class="programlisting">
<span class="hl kwc">class</span> ostream<span class="hl opt">;</span>
</pre><p>
	Este enfoque hace que su código sea vulnerabla a cambios en la
	representación. (Por ejmplo, <code class="classname">ostream</code>
	podrías ser en realidad un <code class="keyword">typedef</code>.) En lugar de lo
	anterior, use siempre el ficheor de cabecera:
      </p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
</pre><p>
	Cuando cree sus propias clases, si una librería es grande,
	proporciones a sus usuarios una versión abreviada del fichero de
	cabecera con especificaciones de tipo incompletas (es decir,
	declaraciones de los nombres de las clases) para los casos en
	que ellos puedan necesitar usar únicamente punteros. (eso puede
	acelerar las compilaciones.)
      </p></li><li class="listitem"><p>
	Cuando elija el tipo de retorno de una operador sobrecargado,
	considere que ocurrirá if se encadenan expresiones. Retorne una
	copia o referencia al valor (<code class="code">return *this</code>) de modo
	que se pueda usar e una expresión encadenada (<code class="code">A = B =
	C</code>). Cuando defina el <code class="literal">operator=</code>, recuerde que
	<code class="code">x=x</code>.
      </p></li><li class="listitem"><p>
	Cuando escriba una función, pase los argumentos por referencia
	constante como primera elección. Siempre que no necesite
	modificar el objeto que está pasando, esta es la mejor práctica
	porque es tan simple como si lo parasa por valor pero sin pagar el
	alto precio de construir y destruir un objeto local, que es lo
	que ocurre cuando se pasa por valor. Normalmente no se querrá
	preocupar demasiado de las cuestiones de eficiencia cuando esté
	diseñando y contruyendo su sistema, pero este hábito es una
	ganancia segura.
      </p></li><li class="listitem"><p>
	Tenga cuidado con los temporarios. Cuando esté optimizando,
	busque creaciones de temporarios, especialmente con sobrecarga
	de operadores. Si sus constructores y destructores son
	complicados, el coste de la creació y destrucción de temporarios
	puede ser muy alto. Cuando devuelva un valor en una función,
	intente siempre contruir el objeto «en el sitio»
	(<span class="emphasis"><em>in place</em></span>) con una llamada al constructor
	en la sentencia de retorno:
      </p><pre class="programlisting">
<span class="hl kwa">return</span> <span class="hl kwd">MyType</span><span class="hl opt">(</span>i<span class="hl opt">,</span> j<span class="hl opt">);</span>
</pre><p>mejor que</p><pre class="programlisting">
MyType <span class="hl kwd">x</span><span class="hl opt">(</span>i<span class="hl opt">,</span> j<span class="hl opt">);</span>
<span class="hl kwa">return</span> x<span class="hl opt">;</span>
</pre><p>
	La primera sentencia <code class="keyword">return</code> (también llamada
	<span class="emphasis"><em>optimización de valor de retorno</em></span>) evita una
	llamada al constructor de copia y al destructor.
      </p></li><li class="listitem"><p>
	Cuando escriba constructores, considere las excepciones. En el
	mejor caso, el constructor no hará nada que eleve un
	excepción. En ese escenario, la clasé será compuesta y heredará
	solo de clases robustas, de modo que ellas se limpiarán
	automáticamente si se eleva una excepción. Si requiere punteros,
	usted es responsable de capturar sus propias excepciones y de
	liberar los recursos antes de elevar una excepción en su
	constructor. Si un contructor tiene que fallar, la acción apropiada
	es elevar una excepción.
      </p></li><li class="listitem"><p>
	En los constructores, haga lo mínimo necesario. No solo
	producirá una sobrecarga menor al crear objetos (muchas de las
	cuales pueden quedar fuera del control del programador), además
	la probabilidad de que eleven excepciones o causen problemas
	será menor.
      </p></li><li class="listitem"><p>
	La responsabilidad del destructor es la de liberar los recursos
	solicitados durante la vida del objeto, no sólo durante la
	construcción.
      </p></li><li class="listitem"><p>
	Utilice jerarquías de excepciones, preferiblemente derivadas de
	la jerarquía de excepción estándar de C++ y anidelas como clases
	públicas con la clase que eleva la excepción. La persona que
	captue las excepciónes puede capturar los tipos específicos de
	excepciones, seguida del tipo base. Si añade una nueva excepción
	derivada, el código de cliente anterior seguirá capturando la
	excepción por medio del tipo base.
      </p></li><li class="listitem"><p>
	Eleve las excepciones por valor y capturelas por
	referencia. Deje que el mecanismo de gestión de excepciones
	haga la gestión de memoria. Si eleva punteros como objetos en la
	excepción que han sido creados en el montículo, el que capture
	la excepción debe saber como liberar la excepción, lo cual
	implica un acoplamiento perjudicial. Si captura las excepciones por
	valor, causará que se creen temporarios; peor, las partes
	derivadas de sus objetos-excepción se pueden partir al hacer
	upcasting por valor.
      </p></li><li class="listitem"><p>
	No escriba sus propias clases plantilla a menos que debe. Mire
	primero en la Librería Estándar de C++, después en librerías de
	propósito específico. Adquiera habilidad en su uso y
	conseguirá incrementar mucho su productividad.
      </p></li><li class="listitem"><p>
	Cuando cree plantillas, escriba código que no dependa del tipo y
	ponga ese código en una clase base no-plantilla para evitar que
	el código aumente de tamaño sin necesidad. Por medio de herencia
	o composición, puede crear plantillas en las que el volumen de
	código que contienen es dependiente del tipo y por tanto esencial.
      </p></li><li class="listitem"><p>
	No use las funciones de <code class="filename">&lt;stdio&gt;</code>, como
	por ejemplo <code class="function">printf()</code>. Aprenda a usar
	iostreams en su lugar; son FIXME:type-safe y type-extensible, y
	mucho más potentes. El esfuerzo se verá recompensado con
	regularidad. En general, use siempre librerías C++ antes que
	librerías C.
      </p></li><li class="listitem"><p>
	Evite los tipos predefinidos de C. El soporte de C++ es por
	compatibilidad con C, pero son tipos mucho menos robustos que
	las clases C++, de modo que pueden complicar la depuración.
      </p></li><li class="listitem"><p>
	Siempre que use tipos predefinidos para variables globales o
	automáticas, no los defina hasta que pueda
	inicializarlos. Defina una variable por línea. Cuando defina
	punteros, ponga el '*' al lado del nombre del tipo. Puede
	hacerlo de forma segura si define una variable por línea. Este
	estilo suele resultar menos confuso para el lector.
      </p></li><li class="listitem"><p>
	Garantize que tiene lugar la inicialización en todos los
	aspectos de su programa. Inicialice todos los atributos en la
	lista de inicialización del constructor, incluso para los tipo
	predefinidos (usando los pseudo-constructores). Usar la lista de
	inicialización del constructor es normalmente más eficiente
	cuando se inicializan subobjetos; si no se hace se invocará el
	constructor por defecto, y acabará llamando a otros métodos
	(probablemnte el <code class="literal">operator=</code>) para conseguir la
	inicialización que desea.
      </p></li><li class="listitem"><p>
	No use la forma <code class="code">MyType a = b;</code> para definir un
	objeto. Esta es una de la mayores fuentes de confusión porque
	llama a un contructor en lugar de al
	<code class="literal">operator=</code>. Por motivos de claridad, sea específico
	y use mejor la forma <code class="code">MyType a(b);</code>. Los resultados
	son idénticos, pero el lector no se podrá confundir.
      </p></li><li class="listitem"><p>
	Use los moldes explícitos descritos en el Capítulo 3. Un molde
	reemplaza el sistema normal de tipado y es un punto de
	error. Como los moldes explícitos separan los un-molde-lo
	hace-todo de C en clases de moldes bien-marcados, cualquiera que
	depure o mantenga el código podrá encontrar fácilmente todo los
	sitios en los que es más probable que sucedan errores lógicos.
      </p></li><li class="listitem"><p>
	Para que un programa sea robusto, cada componente debe ser
	robusto. Use todas las herramientas que proporciona C++: control
	de acceso, excepciones, constantes, comprobación de tipos, etc
	en cada clase que cree. De ese modo podrá pasar de una forma
	segura al siguiente nivel de abstracción cuando construya su
	sistema.
      </p></li><li class="listitem"><p>
	Use las constantes con corrección. Esto permite que el
	compilador advierta de errores que de otro modo serían sutiles y
	difíciles de encontrar. Esta práctica requiere de cierta
	disciplina y se debe usar de modo consistente en todas sus
	clases, pero merece la pena.
      </p></li><li class="listitem"><p>
	Use la comprobación de tipos del compilador en su
	beneficio. Haga todas las compilaciones con todos los avisos
	habilitados y arregle el código para eliminar todas las
	advertencias. Escriba código que utilice los errores y
	advertencias de compilación (por ejemplo, no use listas
	de argumentos variables, que eliminar todas los comprobaciones
	de tipos). Use <code class="function">assert()</code> para depurar, pero
	use excepciones para los errores de ejecución.
      </p></li><li class="listitem"><p>
	Son preferibles los errores de compilación que los de
	ejecución. Intente manejar un error tan cerca del punto donde
	ocurre como sea posible. Es mejor tratar el error en ese punto
	que elevar una excepción. Capture cualqueir excepción en el
	manejador más cercano que tenga suficiente información para
	tratarla. Haga lo que pueda con la excepción en el nivel actual;
	si no puede resolver el problema, relance la excepción. (Vea el
	Volumen 2 si necesita más detalles.)
      </p></li><li class="listitem"><p>
	Si está usando las especificaciones de excepción (vea el Volumen
	2 de este libro, disponible en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>, para
	aprender sobre manejo de excepciones), instale su propia función
	<code class="function">unexpected()</code> usando
	<code class="function">set_unexpected()</code>. Su
	<code class="function">unexpected()</code> debería registrar el error y
	relanzar la excepción actual. De ese modo, si una función
	existente es reemplazada y eleva excepciones, dispondrá de un
	registro de FIXME:culprint y podrá modificar el código que la
	invoca para manejar la excepción.
      </p></li><li class="listitem"><p>
	Cree un <code class="function">terminate()</code> definida por el usuario
	(indicando un error del programador) para registrar el error que
	causó la excepción, después libere los recursos del sistema, y
	termine el programa.
      </p></li><li class="listitem"><p>
	Si un destructor llama a cualquier función, esas funciones
	podrían elevar excepciones. Un destructor no puede elevar una
	excepción (eso podría ocasionar una llamada a
	<code class="function">terminate()</code>, lo que indica un error de
	programación), así que cualquier destructor que llame a otras
	funciones debe capturar y tratar sus propias excepciones.
      </p></li><li class="listitem"><p>
	No «decore» los nombres de sus atributos privados
	(poniendo guiones bajos, notación húngara, etc.), a menos que
	tenga un montón de valores globales ya existentes; en cualquier
	otro caso, deje que las clases y los espacios de nombres definan
	el ámbito de los nombres por usted.
      </p></li><li class="listitem"><p>
	Ponga atención a la sobrecarga. Una función no debería ejecutar
	código condicionalmente basandose en el valor de un argumento,
	sea por defecto o no. En su lugar, debería crear dos o más
	métodos sobrecargados.
      </p></li><li class="listitem"><p>
	Oculte sus punteros dentro de clases contenedor. Dejelos fuera
	sólo cuando vaya a realizar operaciones con ellos. Los punteros
	ha sido siempre la mayor fuente de errores. Cuando use
	<code class="keyword">new</code>, intente colocar el puntero resultante en un
	contenedor. Es preferible que un contenedor «posea»
	sus punteros y sea responsable de la limpieza. Incluso mejor,
	envuelva un puntero dentro de una clase; si aún así quiere que
	parezca un puntero, sobrecargue <code class="literal">operator-&gt;</code> y
	<code class="literal">operator*</code>. Si necesita tener un puntero
	normal, inicialicelo siempre, preferiblemente con
	la dirección de un objeto, o cero si es necesario. Asignele un
	cero cuando le libere para evitar liberaciones múltiples.
      </p></li><li class="listitem"><p>
	No sobrecargue los <code class="keyword">new</code> y <code class="keyword">delete</code>
	globales. Hágalo siempre en cada clase. Sobrecargar las
	versiones globales affecta la proyecto completo, algo que sólo
	los creadores del proyecto debería controlar. Cuando sobrecargue
	<code class="keyword">new</code> y <code class="keyword">delete</code> en las clases, no asume que
	conoce el tamaño del objeto; alguien puede heredar de esa
	clase. Use el argumento proporcionado. Si hace algo especial,
	considere el efecto que podría tener en las clases derivadas.
      </p></li><li class="listitem"><p>
	Evite el troceado de objetos. Prácticamente nunca tiene sentido
	hacer upcast de un objeto por valor. Para evitar el upcast por
	valor, use métodos virtuales puros en su clase base.
      </p></li><li class="listitem"><p>
	A veces la agregación simple resuelve el problema. Un
	FIXME:«sistema conforme al pasajero» en una línea
	aérea consta en elementos desconectados: asiento, aire
	acondicionado, video, etc., y todavía necesita crear muchos más
	en un avión. ¿Debe crear miembros privados y construir una nueva
	interfaz completa? No - en este caso, los componentes también
	son parte de la interfaz pública, así que deberían ser objetos
	miembros públicos. Esos objetos tienen sus propias
	implementaciones privadas, que continúan seguras. Sea consciente
	de que la agregación simple no es una solución usan a menudo,
	pero que puede ocurrir.
      </p></li></ol></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp8926200" href="#idp8926200" class="para">87</a>] </sup>
	    Que me explicó Andrew Koening.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp8935408" href="#idp8935408" class="para">88</a>] </sup>
	    (N. de T.) Está prevista la traducción del Volumen 2 por
	    parte del mismo equipo que ha traducido este volumen. Visite
	    <a class="ulink" href="FIXME" target="_top">FIXME</a>
	  </p></div></div></div><div class="appendix" title="Apéndice C. Lecturas recomendadas"><div class="titlepage"><div><div><h2 class="title"><a id="ApendiceC"></a>Apéndice C. Lecturas recomendadas</h2></div><div><h3 class="subtitle"><em>Recursos para profundizar en el estudio</em></h3></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp9014904">C.1. Sobre C</a></span></dt><dt><span class="sect1"><a href="#idp9017208">C.2. Sobre C++ en general</a></span></dt><dt><span class="sect1"><a href="#idp9033136">C.3. Los rincones oscuros</a></span></dt><dt><span class="sect1"><a href="#idp9039496">C.4. Sobre Análisis y Diseño</a></span></dt></dl></div><div class="sect1" title="C.1. Sobre C"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9014904"></a>C.1. Sobre C</h2></div></div></div><p>
      <span class="emphasis"><em>Thinking in C: Foundations for Java &amp;
	C++</em></span>,
      por Chuck Allison (un seminario en CDROM de MindView, Inc. , 2000,
      incluido al final de este libro y disponible también en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>). Se
      trata de un curso que incluye lecciones y transparencias sobre los
      conceptos básicos del lenguaje C para preparar al lector a
      aprender Java o C++. No es un curso exhaustivo sobre C; sólo
      contiene lo necesario para cambiarse a esos otros lenguajes. Unas
      secciones adicionales sobre esos lenguajes concretos introducen al
      aspirante a programador en C++ o en Java, a sus características.
      Requisitos previos: alguna experiencia con un lenguaje de alto
      nivel, como Pascal, BASIC, Fortran, o LISP (sería posible avanzar
      por el CD sin ese bagaje, pero el curso no está pensado para
      servir de introducción básica a la programación).
    </p></div><div class="sect1" title="C.2. Sobre C++ en general"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9017208"></a>C.2. Sobre C++ en general</h2></div></div></div><p>
      <span class="emphasis"><em>The C++ Programming Language, 3ª edición</em></span>,
      por Bjarne Stroustrup (Addison-Wesley 1997).Hasta cierto punto, el
      objetivo de la obra que tiene en sus manos es permitirle usarel
      libro de Bjarne a modo de referencia. Dado que contiene la
      descripción del lenguaje por su propio autor, es típicamente ahí
      donde se mira para resolver dudas sobre qué se supone que C++ debe
      o no debe hacer. Cuando empiece a dominar el lenguaje y esté
      preparado para pasar a las cosas serias, lo necesitará.
    </p><p>
      <span class="emphasis"><em>C++ Primer, 3ª Edición</em></span>,
      por Stanley Lippman y Josee Lajoie (Addison-Wesley 1998). Ha
      dejado de ser una introducción; se ha convertido en un voluminoso
      libro muy detallista, y es uno de los que consulto junto con el de
      Stroustrup cuando intento resolver una cuestión.«Pensar En
      C++» debe proporcionar una base para entender <span class="emphasis"><em>C++
      Primer</em></span> así como el libro de Stroustrup.
    </p><p>
      <span class="emphasis"><em>C &amp; C++ Code Capsules</em></span>,
      por Chuck Allison (Prentice-Hall, 1998).Ese libro presupone
      unconocimiento de C y C++, y trata cuestiones que ya hayan sido
      quebraderos decabeza, o que no logró zanjar adecuadamente a la
      primera. La obra soluciona lagunas tanto en C como en C++.
    </p><p>
      <span class="emphasis"><em>The C++ Standard</em></span>.Ese es el
      documento en el que el comité ha trabajado tanto durante
      años. No es gratis, desgraciadamente. Pero por lo menos se puede
      adquirir en formato PDF por sólo $18 en <a class="ulink" href="http://www.cssinfo.com" target="_top">www.cssinfo.com</a>.
    </p><div class="sect2" title="C.2.1. Mi propia lista de libros"><div class="titlepage"><div><div><h3 class="title"><a id="idp9022784"></a>C.2.1. Mi propia lista de libros</h3></div></div></div><p> Aparecen a continuación ordenados por fecha de
	publicación. No todos están a la venta actualmente.
      </p><p>
	<span class="emphasis"><em>Computer Interfacing with Pascal &amp;
	    C</em></span>(publicado por mí, vía Eisys, en
	1988. Disponible únicamente a través de <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>).
	Es una introducción a la electrónica desde los días en los que
	CP/M era aun el rey y MSDoS sólo un principiante. Utilicé
	lenguajes de alto nivel y a menudo el puerto paralelo del
	ordenador para pilotar varios proyectos electrónicos. Se trata
	de una adaptación de mis columnas en la primera y mejor
	revista para la que trabajé, <span class="emphasis"><em>Micro
	  Cornucopia</em></span> (retomando las palabras de Larry
	o_Brien, editor durante muchos años de <span class="emphasis"><em>Software
	  Development Magazine</em></span>: la mejor revista de
	electrónica jamás publicada -¡hasta daban los planos para
	fabricar un robot a partir de una maceta!). Desgraciadamente,
	<span class="emphasis"><em>MicroC</em></span> dejó de existir mucho antes de que
	apareciese el Internet. Crear ese libro fue una experiencia
	editorial muy gratificante para mí.
      </p><p>
	<span class="emphasis"><em>Using C++</em></span>
	(osborne/McGraw-Hill 1989).  Fue uno de los primeros libros
	publicados acerca de C++.  Está agotado y ha sido reemplazado
	por su segunda edición, bajo el nuevo título «C++ Inside
	  &amp; out.»
      </p><p>
	<span class="emphasis"><em>C++ Inside &amp; out</em></span>
	(osborne/McGraw-Hill 1993).Como se indicó antes, es en
	realidad la segunda edición de «Using C++». El
	lenguaje C++ que describe el libro es bastante correcto, pero
	data de 1992 y «Pensar En C++» está llamado a
	sustituirlo. Puede saber más acerca de ese libro y conseguir
	el código fuente en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
      </p><p>
	<span class="emphasis"><em> Thinking in C++, 1ª edition</em></span>
	(Prentice-Hall 1995).
      </p><p>
	 <span class="emphasis"><em>Black Belt C++, the Master's
	    Collection</em></span>, Bruce Eckel, editor (M&amp;T
	Books 1994).Agotado. Está constituido por una serie de
	capítulos escritos por personas de prestigio sobre la base de
	sus presentaciones en el coloquio sobre C++ durante la
	Conferencia sobre Desarrollo de Software que yo presidí. La
	portada del libro me llevó a ejercer desde entonces más
	control sobre el diseño de las portadas.
      </p><p>
	<span class="emphasis"><em>Thinking in Java</em></span>, 2ª
	edición (Prentice-Hall, 2000).  La primera edición de ese
	libro ganó el Premio a la Productividad del <span class="emphasis"><em>Software
	  Development Magazine</em></span> y también el <span class="emphasis"><em>Premio
	  del Editor 1999 </em></span>del <span class="emphasis"><em>Java Developer_s
	  Journal</em></span>. Se puede descargar desde <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
      </p></div></div><div class="sect1" title="C.3. Los rincones oscuros"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9033136"></a>C.3. Los rincones oscuros</h2></div></div></div><p>
      Estos libros profundizan en aspectos del lenguaje, y ayudan a
      evitar los típicos errores inherentes al desarrollo de programas
      en C++.
    </p><p>
      <span class="emphasis"><em>Effective C++</em></span>(2ª Edición,
      Addison-Wesley 1998) y «More Effective C++»
      (Addison-Wesley 1996), por Scott Meyers.  La obra clásica e
      indispensable para resolver los problemas serios y diseñar mejor
      código en C++. He intentado capturar y plasmar muchos de los
      conceptos de esos libros en <span class="emphasis"><em>Pensar en
	  C++</em></span>, pero no pretendo haberlo
      logrado. Cualquiera que dedica tiempo a C++ acaba teniendo esos
      libros.  También disponible en CDRoM.
    </p><p>
      <span class="emphasis"><em>Ruminations on C++</em></span> , por
      Andrew Koenig y Barbara Moo (Addison-Wesley, 1996).Andrew
      trabajó personalmente con Stroustrup en muchos aspectos del
      lenguaje C++ y es por tanto una voz muy autorizada. Me
      encantaron sus incisivos comentarios y he aprendido mucho con
      él, tanto por escrito como en persona, a lo largo de los años.
    </p><p>
      <span class="emphasis"><em>Large-Scale C++ Software
	  Design</em></span> , por John Lakos(Addison-Wesley,
      1996).Trata temas y contesta a preguntas con las que uno se
      encuentra durante la creación de grandes proyectos, y a menudo
      de pequeños también.
    </p><p>
       <span class="emphasis"><em>C++ Gems</em></span>
      editor (SIGS Publications, 1996).  Una selección de artículos
      extraídos de <span class="emphasis"><em>The C++ Report</em></span>.
    </p><p>
      <span class="emphasis"><em> The Design &amp; Evolution of C++</em></span>
       , por Bjarne Stroustrup (Addison-Wesley
      1994).Aclaraciones del inventor de C++ acerca de por qué tomó
      ciertas decisiones durante su diseño. No es esencial, pero
      resulta interesante.
    </p></div><div class="sect1" title="C.4. Sobre Análisis y Diseño"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp9039496"></a>C.4. Sobre Análisis y Diseño</h2></div></div></div><p>
      <span class="emphasis"><em>Extreme Programming Explained
	</em></span>por Kent Beck (Addison-Wesley 2000).¡Adoro
      ese libro! Si,sé que tengo tendencia a tomar posturas radicales,
      pero siempre había intuido que podía haber un proceso de
      desarrollo de programas muy diferente, y mucho mejor, y pienso
      que <span class="emphasis"><em>XP</em></span> se acerca bastante a ello. El único
      libro que me impactó de forma similar, fue
      <span class="emphasis"><em>PeopleWare</em></span> (descrito a continuación), que
      trata de los entornos y la interacción con la cultura de las
      empresas. <span class="emphasis"><em>Extreme Programming Explained</em></span>
      habla de programación, y echa abajo la mayoría de las cosas,
      incluso los recientes «hallazgos». Llega al punto
      de decir que los dibujos están bien mientras que no se les
      dedique demasiado tiempo y se esté dispuesto a tirarlos a la
      basura. (observen que ese libro no lleva el «sello de
	certificación UML» en su portada). Comprendería que
      alguien decidiese si quiere trabajar o no para una compañía,
      basándose sólo en el hecho que usan XP. Es un libro pequeño, con
      capítulos cortos, fácil de leer, y que da mucho que pensar.  Uno
      empieza a imaginarse trabajando en esa atmósfera y vienen a la
      mente visiones de un mundo nuevo.
    </p><p>
      <span class="emphasis"><em>UML Distilled </em></span> por Martin
      Fowler (2ª edición, Addison-Wesley, 2000).Cuando se descubre UML
      por primera vez, resulta intimidante porque hay tantos diagramas
      y detalles. Según Fowler, la mayoría de esa parafernalia es
      innecesaria, así que se queda sólo con lo esencial. Para la
      mayoría de los proyectos, sólo se necesitan unos pocos
      instrumentos gráficos, y el objetivo de Fowler es llegar a un
      buen diseño en lugar de preocuparse por todos los artefactos que
      permiten alcanzarlo. Es un libro corto, muy legible; el primer
      libro que debería conseguir si necesita entender UML.
    </p><p>
      <span class="emphasis"><em> The Unified Software Development
	  Process</em></span> por Ivar Jacobsen, Grady Booch, y
      James Rumbaugh (Addison-Wesley 1999).  Estaba mentalizado para
      que no me gustase ese libro. Parecía tener todos los
      ingredientes de un aburrido texto universitario. Me quedé
      gratamente sorprendido - solo unos islotes dentro del libro
      contienen explicaciones que dan la impresión que los conceptos
      no han quedado claros para los propios autores. La mayoría del
      libro es no solamente claro, sino agradable. Y lo mejor de todo,
      es que el proceso tiene realmente sentido. Esto no es
      <span class="emphasis"><em>Extreme Programming</em></span> (y no tiene su claridad
      acerca de los tests) pero también forma parte del mastodonte UML
      - incluso si usted no consigue hacer adoptar
      <span class="emphasis"><em>XP</em></span>, la mayoría de la gente se ha subido al
      carro de "UML es bueno" (independientemente de su nivel de
      experiencia real con él) así que podría conseguir que lo
      adopten. Pienso que ese libro debería ser el buque insignia del
      UML, y es el que se debe de leer después del <span class="emphasis"><em>UML
	Distilled</em></span> de Fowler en cuanto se desee tener más
      nivel de detalle.
    </p><p>
      Antes de elegir método alguno, es útil enriquecer su perspectiva
      través de los que no están intentando vender ninguno. Es fácil
      adoptar un método sin entender realmente lo que se desea
      conseguir con él o lo que puede hacer por uno. otras personas lo
      están usando, lo cual parece una buena razón. Sin embargo, los
      humanos tienen un extraño perfil psicológico: si quieren creer
      que algo va a solucionar sus problemas, lo van a probar. (Eso se
      llama experimentación, que es una cosa buena) Pero si eso no les
      resuelve nada, redoblarán sus esfuerzos y empezarán a anunciar
      por todo lo alto su fabuloso descubrimiento. (Eso es negación de
      la realidad, que no es bueno) La idea parece consistir en que si
      usted consigue meter a más gente en el mismo barco, no se
      sentirá solo, incluso si no va a ninguna parte (o se hunde).  No
      estoy insinuando que todas las metodologías no llevan a ningún
      lado, pero hay que estar armado hasta los dientes con
      herramientas mentales que ayuden a seguir en el modo de
      experimentación («Esto no funciona, vamos a probar otra
	cosa») y no en el de negación («No, no es
	problema. Todo va maravillosamente, no necesitamos
	cambiar»). Creo que los libros siguientes, leídos antes
      de elegir un método, le proporcionarán esas herramientas.
    </p><p>
      <span class="emphasis"><em>Software Creativity</em></span>, por
      Robert Glass (Prentice-Hall, 1995).Ese es el mejor libro que he
      leído que describa una visión de conjunto sobre el debate de las
      metodologías. Consta de una serie de ensayos cortos y artículos
      que Glass ha escrito o comprado (P.J.  Plauger es uno de los que
      contribuyen al libro), que reflejan sus numerosos años dedicados
      a pensar y estudiar el tema. Son amenos y de la longitud justa
      para decir lo necesario; no divaga ni aburre al lector. Pero
      tampoco vende simplemente aire; hay centenares de referencias a
      otros artículos y estudios.  Todos los programadores y jefes de
      proyecto deberían leer ese libro antes de caer en el espejismo
      de las metodologías.
    </p><p>
      <span class="emphasis"><em>Software Runaways: Monumental Software
	  Disasters</em></span>, por Robert Glass (Prentice-Hall
      1997).Lo realmente bueno de ese libro es que expone a la luz lo
      que nunca contamos: la cantidad de proyectos que no solo
      fracasan, sino que lo hacen espectacularmente. Veo que la
      mayoría de nosotros aún piensa «Eso no me va a pasar a
	mí» (o «Eso no volverá a pasarme») y creo
      que eso nos desfavorece. Al tener siempre en mente que las cosas
      pueden salir mal, se está en mejor posición para hacerlas ir
      bien.
    </p><p>
      <span class="emphasis"><em>Object Lessons</em></span> por Tom Love
      (SIGS Books, 1993).  otro buen libro para tener
      «perspectiva».
    </p><p>
      <span class="emphasis"><em>Peopleware</em></span> , por Tom Demarco
      y Timothy Lister (Dorset House, 2ª edición 1999).A pesar de que
      tiene elementos de desarrollo de software, ese libro trata de
      proyectos y equipos de trabajo en general. Pero el énfasis está
      puesto en las personas y sus necesidades, y no en las
      tecnologías. Se habla de crear un entorno en el que la gente
      esté feliz y productiva, en lugar de decidir las reglas que
      deben seguir para convertirse perfectos engranajes de una
      máquina. Esta última actitud, pienso yo, es lo que más
      contribuye a que los programadores sonrían y digan sí con la
      cabeza cuando un método es adoptado y sigan tranquilamente
      haciendo lo mismo que siempre.
    </p><p>
      <span class="emphasis"><em>Complexity</em></span>, by M. Mitchell
      Waldrop (Simon &amp; Schuster, 1992). Relata el encuentro entre
      un grupo de científicos de diferentes disciplinas en Santa Fe,
      Nuevo Méjico, para discutir sobre problemas reales que como
      especialistas no podían resolver aisladamente (el mercado
      bursátil en economía, la formación inicial de la vida en
      biología, por qué la gente se comporta de cierta manera en
      sociología, etc.). Al reunir la física, la economía, la química,
      las matemáticas, la informática, la sociología, y otras
      ciencias, se está desarrollando un enfoque multidisciplinar a
      esos problemas. Pero más importante aun, una nueva forma de
      pensar en esos problemas extremadamente complejos está
      apareciendo: alejándose del determinismo matemático y de la
      ilusión de poder escribir una fórmula que prediga todos los
      comportamientos, hacia la necesidad de observar primero y buscar
      un patrón para después intentar emularlo por todos los medios
      posibles. (El libro cuenta, por ejemplo, la aparición de los
      algoritmos genéticos). Ese tipo de pensamiento, creo yo, es útil
      a medida que investigamos formas de gestionar proyectos de
      software cada vez más complejos.
    </p></div></div></div></body></html>
