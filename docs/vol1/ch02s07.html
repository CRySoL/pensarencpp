<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>2.7. Introducción a los vectores</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C02.html" title="2: Construir y usar objetos" />
    <link rel="prev" href="ch02s06.html" title="2.6. Lectura y escritura de ficheros" />
    <link rel="next" href="ch02s08.html" title="2.8. Resumen" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch02s06.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch02s06.html">2.6. Lectura y escritura de ficheros</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch02s08.html">2.8. Resumen</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch02s08.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="2.7. Introducción a los vectores">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp4181464"></a>2.7. Introducción a los vectores</h2>
          </div>
        </div>
      </div>
      <p>
      Con cadenas, podemos rellenar un objeto
      <code class="classname">string</code> sin saber cuanta memoria se va a
      necesitar. El problema de introducir líneas de un fichero en
      objetos <code class="classname">string</code> es que se sabe cuántas
      cadenas habrá - solamente lo sabemos cuando ya hemos leido el
      fichero entero. Para resolver este problema necesitamos un nuevo
      tipo de datos que pueda crecer automáticamente para contener las
      cadenas que le vayamos introduciendo.
    </p>
      <p>
      De hecho, ¿por qué limitarnos a manejar objetos
      <code class="classname">string</code>? Parece que este tipo de problema -
      no saber la cantidad de cosas a manejar mientras está escribiendo
      el problema - ocurre a menudo. Y este objeto
      «contenedor» podría resultar más útil si pudiera
      manejar <span class="emphasis"><em>cualquier clase de
      objeto</em></span>. Afortunadamente, la Librería Estándar de C++
      tiene una solución: las clases contenedor
      (<span class="foreignphrase"><em class="foreignphrase">container</em></span>). Las clases contenedor
      son uno de los puntos fuertes del Estándar C++.
    </p>
      <p>
      A menudo existe un poco de confusión entre los contenedores y
      los algoritmos en la librería Estándar de C++, y la STL. La
      <span class="foreignphrase"><em class="foreignphrase">Standard Template Library</em></span> fue el
      nombre que usó <span class="personname"><span class="firstname"> Alex</span> <span class="surname">Stepanov</span></span> (que en aquella época
      estaba trabajando en Hewlett-Packard) cuando presentó su
      librería al Comité del Estándar C++ en el encuentro en San
      Diego, California, en la primavera de 1994. El nombre
      sobrevivió, especialmente después de que HP decidiera dejarlo
      disponible para la descarga pública. Posteriormente el comité
      integró las STL en la Librería Estándar de C++ haciendo un gran
      número de cambios. El desarrollo de las STL continúa en Silicon
      Graphics (SGI; ver <a class="ulink" href="http://www.sgi.com/Technology/STL" target="_top">www.sgi.com/Technology/STL)</a>. Las
      SGI STL divergen de la Librería Estándar de C++ en muchos
      detalles sutiles. Aunque es una creencia ampliamente
      generalizada, el C++ Estándar no "incluye" las STL. Puede ser
      confuso debido a que los contenedores y los algoritmos en el C++
      Estándar tienen la misma raíz (y a menudo el mismo nombre) que
      en el SGI STL. En este libro, intentaré decir «la librería
      Estándar de C++» o «Librería Estándar de
      contenedores», o algo similar y eludiré usar el término
      STL.
    </p>
      <p>
      A pesar de que la implementación de los contenedores y algoritmos
      de la Librería Estándar de C++ usa algunos conceptos avanzados,
      que se cubren ampliamente en dos largos capítulos en el segundo
      volumen de este libro, esta librería también puede ser potente sin
      saber mucho sobre ella. Es tan útil que el más básico de los
      contenedores estándar, el <code class="classname">vector</code>, se
      introduce en este capítulo y se usará a lo largo de todo el
      libro. Verá que puede hacer muchas cosas con el
      <code class="classname">vector</code> y no saber cómo está implementado
      (de nuevo, uno de los objetivos de la POO). Los programas que usan
      <code class="classname">vector</code> en estos primeros capítulos del
      libro no son exactamente como los haría un programador
      experimentado, como comprobará en el volumen 2. Aún así,
      encontrará que en la mayoría de los casos el uso que se hace es
      adecuado.
    </p>
      <p>
      La clase <code class="classname">vector</code> es una
      <span class="emphasis"><em>plantilla</em></span>, lo que significa que se puede
      aplicar a tipos de datos diferentes. Es decir, se puede crear un
      <code class="classname">vector</code> de <code class="classname">figuras</code>,
      un <code class="classname">vector</code> de <code class="classname">gatos</code>,
      un <code class="classname">vector</code> de
      <code class="classname">strings</code>, etc. Básicamente, con una
      plantilla se puede crear un vector de «cualquier
      clase». Para decirle al compilador con qué clase trabajará
      (en este caso que va a manejar el vector), hay que poner el nombre
      del tipo deseado entre «llaves angulares». Por lo que
      un <code class="classname">vector</code> de <code class="classname">string</code>
      se denota como <code class="code">vector&lt;string&gt;</code>. Con eso, se crea
      un vector a medida que solamente contendrá objetos
      <code class="classname">string</code>, y recibirá un mensaje de error del
      compilador si intenta poner otra cosa en él.
    </p>
      <p>
      Como el <code class="classname">vector</code> expresa el concepto de
      «contenedor», debe existir una manera de meter cosas
      en él y sacar cosas de él. Para añadir un nuevo elemento al final
      del vector, se una el método
      <code class="function">push_back()</code>. Recuerde que, como es un método,
      hay que usar un '.' para invocarlo desde un objeto particular. La
      razón de que el nombre de la función parezca un poco verboso -
      <code class="function">push_back()</code> en vez de algo más simple como
      <code class="function">put</code> - es porque existen otros contenedores y
      otros métodos para poner nuevos elementos en los contenedores. Por
      ejemplo, hay un <code class="function">insert()</code> para poner algo en
      medio de un contenedor. <code class="classname">vector</code> la soporta
      pero su uso es más complicado y no necesitamos explorarla hasta el
      segundo volumen del libro. También hay un
      <code class="function">push_front()</code> (que no es parte de
      <code class="classname">vector</code>) para poner cosas al principio. Hay
      muchas más funciones miembro en <code class="classname">vector</code> y
      muchos más contenedores en la Librería Estándar, pero le
      sorprenderá ver la de cosas que se pueden hacer con sólo un par de
      características básicas.
    </p>
      <p>
      Así que se pueden introducir elementos en un
      <code class="classname">vector</code> con <code class="function">push_back()</code>
      pero ¿cómo puede sacar esos elementos? La solución es inteligente
      y elegante: se usa la sobrecarga de operadores para que el
      <code class="classname">vector</code> se parezca a un
      <code class="type">array</code>. El array (que será descrito de forma más
      completa en el siguiente capítulo) es un tipo de datos que está
      disponible prácticamente en cualquier lenguaje de programación por
      lo que debería estar familiarizado con él. Los arrays son
      <span class="emphasis"><em>agregados</em></span> lo que significa que consisten en
      un número de elementos agrupados. La característica distintiva de
      un array es que estos elementos tienen el mismo tamaño y están
      organizados uno junto a otro. Y todavía más importante, que se
      pueden seleccionar mediante un índice, lo que significa que puede
      decir: «Quiero el elemento número n» y el elemento
      será producido, normalmente de forma rápida. A pesar de que
      existen excepciones en los lenguajes de programación, normalmente
      se indica la «indexación» mediante corchetes, de tal
      forma que si se tiene un array <code class="varname">a</code> y quiere
      obtener el quinto elemento, sólo tiene que escribir
      <code class="varname">a[4]</code> (fíjese en que la indexación siempre
      empieza en cero).
    </p>
      <p>
      Esta forma compacta y poderosa de notación indexada se ha
      incorporado al <code class="classname">vector</code> mediante la
      sobrecarga de operadores como el <code class="literal">&lt;&lt;</code> y el
      <code class="literal">&gt;&gt;</code> de los <code class="classname">iostreams</code>. De
      nuevo, no hay que saber cómo se ha implementado la
      sobrecarga de operadores - lo dejamos para un capítulo posterior -
      pero es útil que sea consciente que hay algo de magia detrás de
      todo esto para conseguir que los corchetes funcionen con el
      <code class="classname">vector</code>.
    </p>
      <p>
      Con todo esto en mente, ya puede ver un programa que usa la clase
      <code class="classname">vector</code>. Para usar un vector, hay que
      incluir el fichero de cabecera
      <code class="filename">&lt;vector&gt;:</code>
    </p>
      <div class="example">
        <a id="idp4207696"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C02:Fillvector.cpp</span>
<span class="hl slc">// Copy an entire file into a vector of string</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Fillvector.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>line<span class="hl opt">);</span> <span class="hl slc">// Add the line to the end</span>
  <span class="hl slc">// Add line numbers:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 2.10. C02/Fillvector.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
      Casi todo este programa es similar al anterior; se abre un fichero
      abierto y se leen las líneas en objetos
      <code class="classname">string</code> (uno cada vez). Sin embargo, estos
      objetos <code class="classname">string</code> se introducen al final
      del <code class="classname">vector</code> <code class="varname">v</code>. Una vez
      que el bucle <code class="keyword">while</code> ha terminado, el fichero entero se
      encuentra en memoria dentro de <code class="varname">v</code>.
    </p>
      <p>
      La siguiente sentencia en el programa es un bucle <code class="keyword">for</code>. Es
      parecido a un bucle <code class="keyword">while</code> aunque añade un control
      extra. Como en el bucle <code class="keyword">while</code>, en el <code class="keyword">for</code> hay una
      «expresión de control» dentro del paréntesis. Sin
      embargo, esta expresión está dividida en tres partes: una parte
      que inicializa, una que comprueba si hay que salir del bucle, y
      otra que cambia algo, normalmente da un paso en una secuencia de
      elementos. Este programa muestra el bucle <code class="keyword">for</code> de la
      manera más habitual: la parte de inicialización <code class="code">int i =
      0</code> crea un entero <code class="varname">i</code> para usarlo como
      contador y le da el valor inicial de cero. La comprobación
      consiste en ver si <code class="varname">i</code> es menor que el número de
      elementos del <code class="classname">vector</code>
      <code class="varname">v</code>. (Esto se consigue usando la función miembro
      <code class="function">size()</code> -tamaño- que hay que admitir que tiene
      un significado obvio) El último trozo, usa el operador de
      «autoincremento» para aumentar en uno el valor de
      <code class="varname">i</code>. Efectivamente, <code class="code">i++</code> dice
      «coge el valor de <code class="varname">i</code> añádele uno y guarda
      el resultado en <code class="varname">i</code>». Conclusión: el
      efecto del bucle <code class="keyword">for</code> es aumentar la variable
      <code class="varname">i</code> desde cero hasta el tamaño del
      <code class="literal">vector</code> menos uno. Por cada nuevo valor de
      <code class="varname">i</code> se ejecuta la sentencia del
      <code class="varname">cout</code>, que construye un linea con el valor de
      <code class="varname">i</code> (mágicamente convertida a un array de
      caracteres por <code class="varname">cout</code>), dos puntos, un espacio,
      la línea del fichero y el carácter de nueva línea que nos
      proporciona <code class="function">endl</code>. Cuando lo compile y lo
      ejecute verá el efecto de numeración de líneas del fichero.
    </p>
      <p>
      Debido a que el operador <code class="literal">&gt;&gt;</code> funciona con
      <code class="classname">iostreams</code>, se puede modificar fácilmente el
      programa anterior para que convierta la entrada en palabras
      separadas por espacios, en vez de líneas:
    </p>
      <div class="example">
        <a id="idp4221896"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C02:GetWords.cpp</span>
<span class="hl slc">// Break a file into whitespace-separated words</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> words<span class="hl opt">;</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;GetWords.cpp&quot;</span><span class="hl opt">);</span>
  string word<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>in <span class="hl opt">&gt;&gt;</span> word<span class="hl opt">)</span>
    words<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>word<span class="hl opt">);</span> 
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> words<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> words<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 2.11. C02/GetWords.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
      La expresión:
    </p>
      <pre class="programlisting">
<span class="hl kwa">while</span> <span class="hl opt">(</span>in <span class="hl opt">&gt;&gt;</span> word<span class="hl opt">)</span>
</pre>
      <p>
      es la que consigue que se lea una «palabra» cada vez,
      y cuando la expresión se evalúa como «falsa»
      significa que ha llegado al final del fichero. De acuerdo,
      delimitar una palabra mediante caracteres en blanco es un poco
      tosco, pero sirve como ejemplo sencillo. Más tarde, en este libro,
      verá ejemplos más sofisticados que le permiten dividir la entrada
      de la forma que quiera.
    </p>
      <p>
      Para demostrar lo fácil que es usar un
      <code class="classname">vector</code> con cualquier tipo, aquí tiene
      un ejemplo que crea un vector de enteros:
    </p>
      <div class="example">
        <a id="idp4225856"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C02:Intvector.cpp</span>
<span class="hl slc">// Creating a vector that holds integers</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">&quot;, &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    v<span class="hl opt">[</span>i<span class="hl opt">] =</span> v<span class="hl opt">[</span>i<span class="hl opt">] *</span> <span class="hl num">10</span><span class="hl opt">;</span> <span class="hl slc">// Assignment  </span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">&quot;, &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 2.12. C02/Intvector.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
      Para crear un <code class="classname">vector</code> que maneje un tipo
      diferente basta con poner el tipo entre las llaves angulares (el
      argumento de las plantillas). Las plantillas y las librerías de
      plantillas pretenden ofrecer precisamente esta facilidad de uso.
    </p>
      <p>
      Además este ejemplo demuestra otra característica esencial
      del <code class="classname">vector</code> en la expresión
    </p>
      <pre class="programlisting">
v<span class="hl opt">[</span>i<span class="hl opt">] =</span> v<span class="hl opt">[</span>i<span class="hl opt">] *</span> <span class="hl num">10</span><span class="hl opt">;</span>
</pre>
      <p>
      Puede observar que el <code class="classname">vector</code> no está
      limitado a meter cosas y sacarlas. También puede
      <span class="emphasis"><em>asignar</em></span> (es decir, cambiar) cualquier
      elemento del vector mediante el uso de los corchetes. Eso
      significa que el <code class="classname">vector</code> es un objeto útil,
      flexible y de propósito general para trabajar con colecciones de
      objetos, y haremos uso de él en los siguientes capítulos.
    </p>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch02s06.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch02s06.html">2.6. Lectura y escritura de ficheros</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch02s08.html">2.8. Resumen</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch02s08.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
