<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>1.2. Cada objeto tiene una interfaz</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C01.html" title="1: Introducción a los Objetos" />
    <link rel="prev" href="C01.html" title="1: Introducción a los Objetos" />
    <link rel="next" href="ch01s03.html" title="1.3. La implementación oculta" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="C01.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="C01.html">1: Introducción a los Objetos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C01.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch01s03.html">1.3. La implementación oculta</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch01s03.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="1.2. Cada objeto tiene una interfaz">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp3592680"></a>1.2. Cada objeto tiene una interfaz</h2>
          </div>
        </div>
      </div>
      <p>
      Aristóteles fue probablemente el primero en hacer un estudio
      minucioso del concepto de <span class="emphasis"><em>tipo</em></span>; él habló de
      «la clase de peces y la clase de pájaros». La idea
      de que todos los objetos, aún siendo únicos, también son parte
      de una clase de objetos que tienen características y
      comportamientos comunes se utilizó directamente en el primer
      lenguaje orientado a objetos, Simula-67, con su palabra
      reservada <code class="keyword">class</code> que introduce un nuevo tipo en un
      programa.
    </p>
      <p>
      Simula, como su nombre indica, fue creado para desarrollar
      simulaciones como el clásico «problema del cajero»
      <sup>[<a id="idp3595584" href="#ftn.idp3595584" class="footnote">12</a>]</sup>.  Tiene un grupo de cajeros, clientes, cuentas,
      transacciones, y unidades de moneda - un montón de
      «objetos». Los objetos idénticos, exceptuando su
      estado durante la ejecución del programa, se agrupan en
      «clases de objetos» y de ahí viene la palabra
      reservada <code class="keyword">class</code>. Crear tipos de datos abstractos
      (clases) es un concepto fundamental en la programación orientada
      a objetos. Los tipos de datos abstractos trabajan casi
      exactamente como tipos predefinidos: puede crear variables de un
      tipo (llamadas <span class="emphasis"><em>objetos</em></span> o
      <span class="emphasis"><em>instancias</em></span> en el argot de la programación
      orientada a objetos) y manipular estas variables (llamado
      <span class="emphasis"><em>envío de mensajes</em></span> o
      <span class="emphasis"><em>peticiones</em></span>; envía un mensaje y el objeto
      decide qué hacer con él). Los miembros (elementos) de cada clase
      tienen algo en común: cada cuenta tiene un balance, cada
      cajero puede aceptar un depósito, etc. Al mismo tiempo, cada
      miembro tiene su propio estado, cada cuenta tiene un balance
      diferente, cada cajero tiene un nombre. De este modo, cada
      cajero, cliente, cuenta, transacción, etc., se puede
      representar con una única entidad en el programa de
      computador. Esta entidad es un objeto, y cada objeto pertenece a
      una clase particular que define sus características y
      comportamientos.
    </p>
      <p>
      Por eso, lo que hace realmente un programa orientado a objetos es
      crear nuevos tipos de datos, prácticamente todos los lenguajes de
      programación orientados a objetos usan la palabra reservada
      <code class="keyword">class</code>. Cuando vea la palabra «type», piense
      en «class» y viceversa
      <sup>[<a id="idp3602256" href="#ftn.idp3602256" class="footnote">13</a>]</sup>.
    </p>
      <p>
      Dado que una clase describe un conjunto de objetos que tienen
      idénticas características (elementos de datos) y comportamientos
      (funcionalidad), una clase es realmente un tipo de datos porque
      un número de punto flotante, por ejemplo, también tiene un
      conjunto de características y comportamientos. La diferencia
      está en que el programador define una clase para resolver un
      problema en lugar de estar obligado a usar un tipo de dato
      existente diseñado para representar una unidad de almacenamiento
      en una máquina. Amplía el lenguaje de programación añadiendo
      nuevos tipos de datos específicos según sus necesidades. El
      sistema de programación acoge las nuevas clases y les presta
      toda la atención y comprobación de tipo que da a los tipos
      predefinidos.
    </p>
      <p>
      El enfoque orientado a objetos no está limitado a la
      construcción de simulaciones. Esté o no de acuerdo con que
      cualquier problema es una simulación del sistema que está
      diseñando, el uso de técnicas POO puede reducir fácilmente un
      amplio conjunto de problemas a una solución simple.
    </p>
      <p>
      Una vez establecida una clase, puede hacer tantos objetos de esta
      clase como quiera, y manipularlos como si fueran elementos que
      existen en el problema que está intentando resolver. De hecho, uno
      de los desafíos de la programación orientada a objetos es crear
      una correspondencia unívoca entre los elementos en el espacio del
      problema y objetos en el espacio de la solución.
    </p>
      <p>
      Pero, ¿cómo se consigue que un objeto haga algo útil por usted?
      Debe haber una forma de hacer una petición al objeto para que
      haga algo, como completar una transacción, dibujar algo en la
      pantalla o activar un interruptor. Y cada objeto puede
      satisfacer sólo ciertas peticiones. Las peticiones que puede
      hacer un objeto están definidas por
      su <span class="emphasis"><em>intefaz</em></span>, y es el tipo lo que determina
      la interfaz. Un ejemplo simple puede ser una representación de
      una bombilla:
    </p>
      <div class="figure">
        <a id="idp3609120"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_03.png" align="middle" alt="Clase Luz" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 1.1. Clase <code class="classname">Luz</code></strong>
        </p>
      </div>
      <br class="figure-break" />
      <pre class="programlisting">
Luz luz1<span class="hl opt">;</span>
luz1<span class="hl opt">.</span><span class="hl kwd">encender</span><span class="hl opt">();</span>
</pre>
      <p>
      La interfaz establece qué peticiones se pueden hacer a un objeto
      particular. Sin embargo, se debe codificar en algún sitio para
      satisfacer esta petición. Ésta, junto con los datos ocultos,
      constituyen la <span class="emphasis"><em>implementación</em></span>. Desde el punto
      de vista de la programación procedural, no es complicado. Un tipo
      tiene una función asociada para cada posible petición, y cuando se
      hace una petición particular a un objeto, se llama a esa
      función. Este proceso normalmente se resume diciendo que ha
      «enviado un mensaje» (ha hecho una petición) a un
      objeto, y el objeto sabe qué hacer con este mensaje (ejecuta
      código).
    </p>
      <p>
      Aquí, el nombre del tipo/clase es <code class="classname">Luz</code>, el
      nombre de este objeto particular de <code class="classname">Luz</code> es
      <code class="varname">luz1</code>, y las peticiones que se le pueden hacer a
      un objeto <code class="classname">Luz</code> son encender, apagar,
      intensificar o atenuar. Puede crear un objeto
      <code class="classname">Luz</code> declarando un nombre
      (<code class="varname">luz1</code>) para ese objeto. Para enviar un mensaje
      al objeto, escriba el nombre del objeto y conéctelo al mensaje de
      petición con un punto. Desde el punto de vista del usuario de una
      clase predefinida, eso es prácticamente todo lo que necesita para
      programar con objetos.
    </p>
      <p>
      El diagrama mostrado arriba sigue el formato del Lenguaje
      Unificado de Modelado (UML). Cada clase se representa con una
      caja, con el nombre del tipo en la parte de arriba, los atributos
      que necesite describir en la parte central de la caja, y los
      <span class="emphasis"><em>métodos</em></span> (las funciones que pertenecen a este
      objeto, que reciben cualquier mensaje que se envíe al objeto) en
      la parte inferior de la caja. A menudo, en los diagramas de diseño
      UML sólo se muestra el nombre de la clase y el nombre de los
      métodos públicos, y por eso la parte central no se muestra. Si
      sólo está interesado en el nombre de la clase, tampoco es
      necesario mostrar la parte inferior.
    </p>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp3595584" href="#idp3595584" class="para">12</a>] </sup>
          Puede encontrar una implementación interesante de este
          problema en el Volumen 2 de este libro, disponible en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>
        </p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp3602256" href="#idp3602256" class="para">13</a>] </sup>
          Hay quien hace una distinción, afirmando que <code class="keyword">type</code>
          determina la interfaz mientras <code class="keyword">class</code> es una
          implementación particular de esta interfaz.
        </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="C01.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="C01.html">1: Introducción a los Objetos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C01.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch01s03.html">1.3. La implementación oculta</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch01s03.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
