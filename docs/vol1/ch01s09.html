<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>1.9. Análisis y diseño</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C01.html" title="1: Introducción a los Objetos" />
    <link rel="prev" href="ch01s08.html" title="1.8. Gestión de excepciones: tratamiento de errores" />
    <link rel="next" href="ch01s09s02.html" title="1.9.2. Fase 1: ¿Qué estamos haciendo?" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch01s08.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch01s08.html">1.8. Gestión de excepciones: tratamiento de errores</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C01.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch01s09s02.html">1.9.2.  Fase 1: ¿Qué estamos haciendo? </a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch01s09s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="1.9. Análisis y diseño">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp3740888"></a>1.9. Análisis y diseño</h2>
          </div>
        </div>
      </div>
      <p>
      El paradigma orientado a objetos es una nueva forma de pensar
      sobre programación y mucha gente tiene problemas la primera vez
      que escucha cómo se aborda un proyecto POO. Una vez que se sabe
      que, supuestamente, todo es un objeto, y cómo aprender a pensar
      al estilo orientado a objetos, puede empezar a crear
      «buenos» diseños que aprovechen las ventajas de
      todos los beneficios que ofrece la POO.
    </p>
      <p>
      Un <span class="emphasis"><em>método</em></span> (llamado a menudo
      <span class="emphasis"><em>metodología</em></span>) es un conjunto de procesos y
      heurísticas usados para tratar la complejidad de un problema de
      programación. Desde el comienzo de la programación orientada a
      objetos se han formulado muchos métodos. Esta sección le dará una
      idea de cuál es el objetivo que se intenta conseguir cuando se usa
      una metodología.
    </p>
      <p>
      Especialmente en POO, la metodología es un campo de muchos
      experimentos, así que antes de elegir un método, es importante que
      comprenda cuál es el problema que resuelve. Eso es particularmente
      cierto con C++, en el que el lenguaje de programación pretende
      reducir la complejidad (comparado con C) que implica expresar un
      programa. De hecho, puede aliviar la necesidad de metodologías aún
      más complejas. En cambio, otras más simples podrían ser
      suficientes en C++ para muchos tipos de problemas grandes que
      podría manejar usando metodologías simples con lenguajes
      procedurales.
    </p>
      <p>
      También es importante darse cuenta de que el término
      «metodología» a menudo es demasiado grande y
      prometedor. A partir de ahora, cuando diseñe y escriba un programa
      estará usando una metodología. Puede ser su propia metodología, y
      puede no ser consciente, pero es un proceso por el que pasa cuando
      crea un programa. Si es un proceso efectivo, puede que sólo necesite un
      pequeño ajuste para que funcione con C++. Si no está satisfecho
      con su productividad y con el camino que sus programas han tomado,
      puede considerar adoptar un método formal, o elegir trozos de
      entre muchos métodos formales.
    </p>
      <p>
      Mientras pasa por el proceso de desarrollo, el uso más importante
      es éste: no perderse. Eso es fácil de hacer. La mayoría de los
      análisis y métodos de diseño pretenden resolver los problemas más
      grandes. Recuerde que la mayoría de los proyectos no encajan en
      esta categoría, normalmente puede tener un análisis y diseño
      exitoso con un subconjunto relativamente pequeño de lo que
      recomienda el método <sup>[<a id="idp3746880" href="#ftn.idp3746880" class="footnote">17</a>]</sup>
      . Pero muchos tipos de procesos, sin importar lo
      limitados que sean, generalmente le ofrecerán un camino mucho
      mejor que simplemente empezar a codificar.
    </p>
      <p>
      También es fácil quedarse estancado, caer en
      <span class="emphasis"><em>análisis-parálisis</em></span>, donde sentirá que no
      puede avanzar porque en la plataforma que está usando no está
      especificado cada pequeño detalle. Recuerde, no importa cuánto
      análisis haga, hay algunas cosas sobre el sistema que no se
      revelan hasta el momento del diseño, y más cosas que no se
      revelarán hasta que esté codificando, o incluso hasta que el
      programa esté funcionando. Por eso, es crucial moverse bastante
      rápido durante del análisis y diseño, e implementar un test del
      sistema propuesto.
    </p>
      <p>
      Este punto merece la pena enfatizarlo. Debido a nuestra
      experiencia con los lenguajes procedurales, es encomiable que un
      equipo quiera proceder con cuidado y entender cada pequeño detalle
      antes de pasar al diseño y a la implementación. Desde luego,
      cuando crea un SGBD (Sistema Gestor de Bases de Datos), conviene
      entender la necesidad de un cliente a fondo. Pero un SGBD está en
      una clase de problemas que son muy concretos y bien entendidos; en
      muchos programas semejantes, la estructura de la base de datos
      <span class="emphasis"><em>es</em></span> el problema que debe afrontarse. El tipo
      de problema de programación tratado en este capítulo es de la
      variedad «comodín» (con mis palabras), en el que la
      solución no es simplemente adaptar una solución bien conocida,
      en cambio involucra uno o más «factores
      comodín» -elementos para los que no hay solución previa
      bien entendida, y para los que es necesario investigar
      <sup>[<a id="idp3752208" href="#ftn.idp3752208" class="footnote">18</a>]</sup>
      . Intentar analizar minuciosamente un problema comodín
      antes de pasar al diseño y la implementación provoca un
      análisis-parálisis porque no se tiene suficiente información
      para resolver este tipo de problema durante la fase de
      análisis. Resolver estos problemas requiere interacción a través
      del ciclo completo, y eso requiere comportamientos arriesgados (lo
      cual tiene sentido, porque está intentando hacer algo nuevo y los
      beneficios potenciales son mayores). Puede parecer que el riesgo
      está compuesto por «prisas» en una implementación
      preliminar, pero en cambio puede reducir el riesgo en un proyecto
      comodín porque está descubriendo pronto si es viable un enfoque
      particular para el problema. El desarrollo del producto es gestión
      de riesgos.
    </p>
      <p>
      A menudo se propone que «construya uno desechable».
      Con la POO, todavía debe andar <span class="emphasis"><em>parte</em></span> de
      este camino, pero debido a que el código está encapsulado en
      clases, durante la primera iteración inevitablemente producirá
      algunos diseños de clases útiles y desarrollará algunas ideas
      válidas sobre el diseño del sistema que no necesariamente son
      desechables. De esta manera, la primera pasada rápida al
      problema no produce sólo información crítica para la siguiente
      iteración de análisis, diseño, e implementación, sino que además
      crea el código base para esa iteración.
    </p>
      <p>
      Es decir, si está buscando una metodología que contenga detalles
      tremendos y sugiera muchos pasos y documentos, es aún más difícil
      saber cuándo parar. Tenga presente lo que está intentando
      encontrar:
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	 ¿Cuáles son los objetos? (¿Cómo divide su proyecto en sus
	 partes componentes?)
	</p>
          </li>
          <li class="listitem">
            <p>
	 ¿Cuáles son sus interfaces? (¿Qué mensajes necesita enviar a
	 otros objetos?)
	</p>
          </li>
        </ol>
      </div>
      <p>
      Si sólo cuenta con los objetos y sus interfaces, entonces puede
      escribir un programa. Por varias razones podría necesitar más
      descripciones y documentos, pero no puede hacerlo con menos.
    </p>
      <p>
      El proceso se puede realizar en cinco fases, y una fase 0 que es
      simplemente el compromiso inicial de usar algún tipo de
      estructura.
    </p>
      <div class="sect2" title="1.9.1. Fase 0: Hacer un plan">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="idp3759400"></a>1.9.1.  Fase 0: Hacer un plan </h3>
            </div>
          </div>
        </div>
        <p>
	Primero debe decidir qué pasos va a dar en su proceso. Parece
	fácil (de hecho, todo esto parece fácil) y sin embargo la gente
	a menudo no toma esta decisión antes de ponerse a programar. Si
	su plan es «ponerse directamente a programar», de
	acuerdo (a veces es adecuado cuando es un problema bien
	conocido). Al menos estará de acuerdo en que eso es el plan.
      </p>
        <p>
	También debe decidir en esta fase si necesita alguna estructura
	de proceso adicional, pero no las nueve yardas
	completas. Bastante comprensible, algunos programadores
	prefieren trabajar en «modo vacaciones» en cuyo
	caso no se impone ninguna estructura en el proceso de desarrollo
	de su trabajo; «Se hará cuando se haga». Eso puede
	resultar atractivo durante un tiempo, pero se ha descubierto que
	tener unos pocos hitos a lo largo del camino ayuda a enfocar e
	impulsar sus esfuerzos en torno a esos hitos en lugar de empezar
	a atascarse con el único objetivo de «finalizar el
	proyecto». Además, divide el proyecto en piezas más
	pequeñas y hace que dé menos miedo (y además los hitos ofrecen
	más oportunidades para celebraciones).
      </p>
        <p>
	Cuando empecé a estudiar la estructura de la historia (por eso
	algún día escribiré una novela) inicialmente me resistía a la
	idea de una estructura, sentía que cuando escribía simplemente
	permitía que fluyera en la página. Pero más tarde me di cuenta
	de que cuando escribo sobre computadoras la estructura es
	bastante clara, pero no pienso mucho sobre ello. Pero aún así
	estructuro mi trabajo, aunque sólo semi-inconscientemente en mi
	cabeza. Si aún piensa que su plan es sólo ponerse a codificar,
	de algún modo, usted pasará por las posteriores fases mientras
	pregunta y responde ciertas cuestiones.
      </p>
        <div class="sect3" title="Declaración de objetivos">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp3764504"></a>Declaración de objetivos</h4>
              </div>
            </div>
          </div>
          <p>
	  Cualquier sistema construido, no importa cuan complicado
	  sea, tiene un propósito fundamental, el negocio que hay en
	  él, la necesidad básica que satisface. Si puede ver la
	  interfaz de usuario, el hardware o los detalles específicos
	  del sistema, los algoritmos de codificación y los problemas
	  de eficiencia, finalmente encontrará el núcleo de su
	  existencia, simple y sencillo. Como el así llamado
	  <span class="emphasis"><em>concepto de alto nivel</em></span> de una película
	  de Hollywood, puede describirlo en una o dos frases. Esta
	  descripción pura es el punto de partida.
	</p>
          <p>
	  El concepto de alto nivel es bastante importante porque le da
	  el tono a su proyecto; es una declaración de principios. No
	  tiene porqué conseguirlo necesariamente la primera vez (podría
	  tener que llegar a una fase posterior del proyecto antes de
	  tenerlo completamente claro), pero siga intentándolo hasta que
	  lo consiga. Por ejemplo, en un sistema de control de tráfico
	  aéreo puede empezar con un concepto de alto nivel centrado en
	  el sistema que está construyendo: «El programa de la
	  torre sigue la pista a los aviones». Pero considere qué
	  ocurre cuando adapta el sistema para un pequeño aeropuerto;
	  quizá sólo haya un controlador humano o ninguno. Un modelo más
	  útil no se preocupará de la solución que está creando tanto
	  como la descripción del problema: «Llega un avión,
	  descarga, se revisa y recarga, y se marcha».
	</p>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp3746880" href="#idp3746880" class="para">17</a>] </sup>
	  Un ejemplo excelente es <em class="citetitle">UML Distilled</em>,
	  de <span class="personname"><span class="firstname">Martin</span> <span class="surname">Fowler</span></span> (Addison-Wesley 2000),
	  que reduce el, a menudo, insoportable proceso UML a un
	  subconjunto manejable.
	</p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp3752208" href="#idp3752208" class="para">18</a>] </sup>
	  Mi regla general para el cálculo de semejantes proyectos: Si
	  hay más de un comodín, no intente planear cuánto tiempo le
	  llevará o cuánto costará hasta que haya creado un prototipo
	  funcional. También hay muchos grados de libertad.
	</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch01s08.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch01s08.html">1.8. Gestión de excepciones: tratamiento de errores</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C01.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch01s09s02.html">1.9.2.  Fase 1: ¿Qué estamos haciendo? </a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch01s09s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
