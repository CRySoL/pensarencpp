<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>3: C en C++</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="prev" href="ch02s09.html" title="2.9. Ejercicios" />
    <link rel="next" href="ch03s02.html" title="3.2. Control de flujo" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch02s09.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch02s09.html">2.9. Ejercicios</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s02.html">3.2. Control de flujo</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="chapter" title="3: C en C++">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="C03"></a>3: C en C++</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <strong>Tabla de contenidos</strong>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="C03.html#idp4255712">3.1. Creación de funciones</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s02.html">3.2. Control de flujo</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s03.html">3.3. Introducción a los operadores</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s04.html">3.4. Introducción a los tipos de datos</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s05.html">3.5. Alcance</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s06.html">3.6.  Especificar la ubicación del espacio de almacenamiento</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s07.html">3.7. Los operadores y su uso</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s08.html">3.8. Creación de tipos compuestos</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s09.html">3.9. Consejos para depuración</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="C03-punteros-a-funcion.html">3.10. Direcciones de función</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s11.html">3.11. Make: cómo hacer compilación separada</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s12.html">3.12. Resumen</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch03s13.html">3.13. Ejercicios</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="highlights">
        <p>
      Como C++ está basado en C, debería estar familiarizado con la
      sintaxis de C para poder programar en C++, del mismo modo que
      debería tener una fluidez razonable en álgebra para poder hacer
      cálculos.
    </p>
      </div>
      <p>
    Si nunca antes ha visto C, este capítulo le dará una buena base
    sobre el estilo de C usado en C++. Si está familiarizado con el
    estilo de C descrito en la primera edición de Kernighan &amp;
    Ritchie (también llamado K&amp;R) encontrará algunas
    características nuevas o diferentes tanto en C++ como en el
    estándar C. Si está familiarizado con el estándar C debería
    echar un vistazo al capítulo en busca de las características
    particulares de C++. Note que hay algunas características
    fundamentales de C++ que se introducen aquí, que son ideas
    básicas parecidas a características de C o a menudo
    modificaciones en el modo en que C hace las cosas. Las
    características más sofisticadas de C++ se explicarán en
    capítulos posteriores
  </p>
      <p>
    Este capítulo trata por encima las construcciones de C e introduce
    algunas construcciones básicas de C++, suponiendo que tiene alguna
    experiencia programando en otro lenguaje. En el CD-ROM que acompaña
    a este libro hay una introducción más suave a C,
    titulada <em class="citetitle">Thinking in C: Foundations for Java &amp;
    C++</em> de Chuck Alison (publicada por MidView, Inc. y
    disponible también en <a class="ulink" href="http://www.MindView.net" target="_top">www.MindView.net</a>). Se trata de
    un seminario en CD-ROM cuyo objetivo es guiarle
    cuidadosamente a través de los fundamentos del lenguaje C. Se
    concentra en el conceptos necesarios para permitirle pasarse a C++
    o a Java, en lugar de intentar convertirle en un experto en todos los
    oscuros recovecos de C (una de las razones para usar un lenguaje de
    alto nivel como C++ o Java es precisamente evitar muchos de estos
    recovecos). También contiene ejercicios y soluciones guiadas. Tenga
    presente que este capítulo va después del CD <em class="citetitle">Thinking in
      C</em>, el CD no reemplaza a este capítulo, sino que debería
    tomarse como una preparación para este capítulo y para el libro.
  </p>
      <div class="sect1" title="3.1. Creación de funciones">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="idp4255712"></a>3.1. Creación de funciones</h2>
            </div>
          </div>
        </div>
        <p>
      En el antiguo C (previo al estándar), se podía invocar una función
      con cualquier número y tipo de argumentos sin que el compilador se
      quejase. Todo parecía ir bien hasta que ejecutabas el programa. El
      programa acababa con resultados misteriosos (o peor, el programa
      fallaba) sin ninguna pista del motivo. La falta de ayuda
      acerca del paso de argumentos y los enigmáticos bugs que
      resultaban es, probablemente, la causa de que C se considerase
      «un lenguaje ensamblador de alto nivel». Los
      programadores de pre-Estándar C simplemente se adaptaron.
    </p>
        <p>
      C y C++ Estándar usan una característica llamada
      <span class="emphasis"><em>prototipado de funciones</em></span>. Con esta
      herramienta se han de describir los tipos de argumentos al
      declarar y definir una función. Esta descripción es el
      «prototipo». Cuando la función es llamada, el
      compilador usa el prototipo para asegurar que los argumentos
      pasados son los apropiados, y que el valor retornado es tratado
      correctamente. Si el programador comete un error al llamar a la
      función, el compilador detecta el error.
    </p>
        <p>
      Esencialmente, aprendió sobre prototipado de funciones
      (sin llamarlas de ese modo) en el capítulo previo, ya que la forma
      de declararlas en C++ requiere de un prototipado apropiado. En un
      prototipo de función, la lista de argumentos contiene los tipos de
      argumentos que se deben pasar a la función y (opcionalmente
      para la declaración), identificadores para los argumentos. El
      orden y tipo de los argumentos debe coincidir en la declaración,
      definición y llamada a la función. A continuación se muestra un
      ejemplo de un prototipo de función en una declaración:
    </p>
        <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">translate</span><span class="hl opt">(</span><span class="hl kwb">float</span> x<span class="hl opt">,</span> <span class="hl kwb">float</span> y<span class="hl opt">,</span> <span class="hl kwb">float</span> z<span class="hl opt">);</span>
</pre>
        <p>
      No se puede usar la misma sintaxis para declarar los argumentos en
      el prototipo de una función que en las definiciones ordinarias de
      variables. Esto significa que no se puede escribir: <code class="code">float x, y,
      z.</code> Se debe indicar el tipo de cada argumento. En una declaración
      de función, lo siguiente también es correcto:
    </p>
        <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">translate</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">);</span>
</pre>
        <p>
      Ya que el compilador no hace más que chequear los tipos cuando se
      invoca la función, los identificadores se incluyen solamente para
      mejorar la claridad del código cuando alguien lo está leyendo.
    </p>
        <p>
      En la definición de la función, los nombres son necesarios ya que
      los argumentos son referenciados dentro de la función:
    </p>
        <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">translate</span><span class="hl opt">(</span><span class="hl kwb">float</span> x<span class="hl opt">,</span> <span class="hl kwb">float</span>  y<span class="hl opt">,</span> <span class="hl kwb">float</span> z<span class="hl opt">) {</span>
    x <span class="hl opt">=</span> y <span class="hl opt">=</span> z<span class="hl opt">;</span>
    <span class="hl slc">// ...</span>
<span class="hl opt">}</span>
</pre>
        <p>
      Esta regla sólo se aplica a C. En C++, un argumento puede no tener
      nombrado en la lista de argumentos de la definición de la
      función. Como no tiene nombre, no se puede utilizar en el cuerpo
      de la función, por supuesto. Los argumentos sin nombre se permiten
      para dar al programador una manera de «reservar espacio en
      la lista de argumentos». De cualquier modo, la persona que
      crea la función aún así debe llamar a la función con los
      parámetros apropiados. Sin embargo, la persona que crea la función
      puede utilizar el argumento en el futuro sin forzar una
      modificación en el código que llama a la función. Esta opción de
      ignorar un argumento en la lista también es posible si se indica
      el nombre, pero siempre aparecería un molesto mensaje de
      advertencia, informando que el valor no se utiliza, cada vez que se
      compila la función. La advertencia desaparece si se quita el
      nombre del argumento.
    </p>
        <p>
      C y C++ tienen otras dos maneras de declarar una lista de
      argumentos. Si se tiene una lista de argumentos vacía, se puede
      declarar esta como <code class="function">func()</code> en C++, lo que
      indica al compilador que hay exactamente cero argumentos. Hay que
      tener en cuenta que esto sólo significa una lista de argumentos
      vacía en C++. En C significa «un número indeterminado de
      argumentos» (lo que es un «agujero» en C ya
      que deshabilita la comprobación de tipos en ese caso). En ambos, C
      y C++, la declaración <code class="function">func(void);</code> significa
      una lista de argumentos vacía. La palabra clave <code class="type">void</code>
      significa «nada» en este caso (también puede
      significar «sin tipo» en el caso de los punteros,
      como se verá mas adelante en este capítulo).
    </p>
        <p>
      La otra opción para las listas de argumentos se produce cuando no
      se sabe cuantos argumentos o qué tipos tendrán los argumentos;
      esto se conoce como <span class="emphasis"><em>lista de argumentos
      variable</em></span>. Esta «lista incierta de
      argumentos» se representada con puntos suspensivos
      (...). Definir una función con una lista de argumentos variable es
      significativamente más complicado que definir una función
      normal. Se puede utilizar una lista de argumentos variable para
      una función que tiene un grupo de argumentos fijos si (por alguna
      razón) se quiere deshabilitar la comprobación del prototipo
      de función. Por eso, se debe restringir el uso de listas
      de argumentos variables en C y evitarlas en C++ (en el cual, como
      aprenderá, hay alternativas mucho mejores). El manejo de listas
      de argumentos variables se describe en la sección de librerías de
      la documentación de su entorno C particular.
    </p>
        <div class="sect2" title="3.1.1. Valores de retorno de las funciones">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp4270016"></a>3.1.1. Valores de retorno de las funciones</h3>
              </div>
            </div>
          </div>
          <p>
        Un prototipo de función C++ debe especificar el tipo de valor
        devuelto de la función (en C, si no se especifica será por
        defecto un <code class="type">int</code>). La especificación del tipo de
        retorno precede al nombre de la función. Para especificar que no
        se devolverá valor alguno, se utiliza la palabra reservada
        <code class="type">void</code>. Esto provocará un error si se intenta devolver
        un valor desde la función. A continuación hay algunos prototipos
        completos de funciones:
      </p>
          <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">f1</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span> <span class="hl slc">// Devuelve un entero, no tiene argumentos</span>
<span class="hl kwb">int</span> <span class="hl kwd">f2</span><span class="hl opt">();</span> <span class="hl slc">//  igual que f1() en C++ pero no en C Stantard</span>
<span class="hl kwb">float</span> <span class="hl kwd">f3</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">);</span> <span class="hl slc">// Devuelve un float</span>
<span class="hl kwb">void</span> <span class="hl kwd">f4</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span> <span class="hl slc">// No toma argumentos, no devuelve nada</span>
</pre>
          <p>
        Para devolver un valor desde una función, se utiliza la
        sentencia <code class="keyword">return</code>. Esta sentencia termina la función y
        salta hasta la sentencia que se halla justo después de la
        llamada a la función. Si <code class="keyword">return</code> tiene un argumento, se
        convierte en el valor de retorno de la función. Si una función
        indica que retornara un tipo en particular, entonces cada
        sentencia <code class="keyword">return</code> debe retornar un valor de ese
        tipo. Puede haber más de una sentencia <code class="keyword">return</code> en una
        definición de función:
      </p>
          <div class="example">
            <a id="idp4275584"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C03:Return.cpp</span>
<span class="hl slc">// Use of &quot;return&quot;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">char</span> <span class="hl kwd">cfunc</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl str">'g'</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">5</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl str">'z'</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl str">'c'</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type an integer: &quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> val<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> val<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">cfunc</span><span class="hl opt">(</span>val<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 3.1. C03/Return.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
        En <code class="function">cfunc()</code>, el primer <code class="keyword">if</code> que
        comprueba que la condición sea <code class="keyword">true</code> sale de la función
        con la sentencia <code class="keyword">return</code>. Fíjese que la declaración de
        la función no es necesaria puesto que la definición aparece
        antes de ser utilizada en <code class="function">main()</code>, de modo
        que el compilador sabe de su existencia desde dicha definición.
      </p>
        </div>
        <div class="sect2" title="3.1.2. Uso de funciones de librerías C">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp4279832"></a>3.1.2. Uso de funciones de librerías C</h3>
              </div>
            </div>
          </div>
          <p>
        Todas las funciones en la librería local de funciones de C están
        disponibles cuando se programa en C++. Se debería buscar bien en
        la librería de funciones antes de definir una propia - hay muchas
        probabilidades de que alguien haya resuelto el problema antes, y
        probablemente haya dedicado más tiempo pensando y depurando.
      </p>
          <p>
        Una advertencia, del mismo modo: muchos compiladores incluyen
        muchas funciones extra que hacen la vida mucho mas fácil y
        resultan tentadoras, pero no son parte de la Librería C
        Estándar. Si está seguro de que jamás deseará portar la
        aplicación a otra plataforma (¿y quién está seguro de eso?),
        adelante -utilice esas funciones y haga su vida más fácil. Si
        desea que la aplicación pueda ser portada, debería ceñirse
        únicamente al uso de funciones de la Librería Estándar. Si
        debe realizar actividades específicas de la plataforma,
        debería intentar aislar este código de tal modo que pueda
        cambiarse fácilmente al migrarlo a otra plataforma. En C++,
        las actividades de una plataforma específica a menudo se
        encapsulan en una clase, que es la solución ideal.
      </p>
          <p>
        La fórmula para usar una librería de funciones es la siguiente:
        primero, encontrar la función en la referencia de programación
        (muchas referencias de programación ordenan las funciones por
        categoría además de alfabéticamente). La descripción de la
        función debería incluir una sección que demuestre la sintaxis
        del código. La parte superior de esta sección tiene al menos una
        línea <code class="keyword">#include</code>, mostrando el fichero principal que
        contiene el prototipo de función. Debe copiar este
        <code class="keyword">#include</code> en su fichero para que la función esté
        correctamente declarada. Ahora puede llamar la función de la
        misma manera que aparece en la sección de sintaxis. Si comete un
        error, el compilador lo descubrirá comparando la llamada a la
        función con el prototipo de la cabecera e informará de dicho
        error. El enlazador busca en la Librería Estándar por defecto,
        de modo que lo único que hay que hacer es: incluir el fichero de
        cabecera y llamar a la función.
      </p>
        </div>
        <div class="sect2" title="3.1.3. Creación de librerías propias">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp4286000"></a>3.1.3. Creación de librerías propias</h3>
              </div>
            </div>
          </div>
          <p>
        Puede reunir funciones propias juntas en una librería. La
        mayoría de paquetes de programación vienen con un
        FIXME:bibliotecario que maneja grupos de módulos objeto. Cada
        FIXME:bibliotecario tiene sus propios comandos, pero la idea
        general es la siguiente: si se desea crear una librería, se debe
        hacer un fichero cabecera que contenga prototipos de todas las
        funciones de la librería. Hay que ubicar este fichero de
        cabecera en alguna parte de la ruta de búsqueda del
        preprocesador, ya sea en el directorio local (de modo que se
        podrá encontrar mediante <code class="code">#include "header"</code>) o bien
        en el directorio <code class="filename">include</code> (por lo que se
        podrá encontrar mediante <code class="code">#include
        &lt;header&gt;</code>). Luego se han de juntar todos los módulos
        objeto y pasarlos al FIXME:bibliotecario junto con un nombre
        para la librería recién construida (la mayoría de los
        bibliotecarios requieren una extensión común, como por ejemplo
        <code class="filename">.lib</code> o <code class="filename">.a</code>). Se ha de
        ubicar la librería completa donde residan todas las demás, de
        manera que el enlazador sabrá buscar esas funciones en dicha
        librería al ser invocadas. Pueden encontrar todos los detalles
        en su documentación particular, ya que pueden variar de un
        sistema a otro.
      </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch02s09.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch02s09.html">2.9. Ejercicios</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s02.html">3.2. Control de flujo</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
