<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>3.13. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C03.html" title="3: C en C++" />
    <link rel="prev" href="ch03s12.html" title="3.12. Resumen" />
    <link rel="next" href="C04.html" title="4: Abstracción de Datos" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s12.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s12.html">3.12. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C03.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C04.html">4: Abstracción de Datos</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C04.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="3.13. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp5115208"></a>3.13. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	  Cree un fichero de cabecera (con extensión
	  «.h»). En este fichero, declare un grupo de
	  funciones variando las listas de argumentos y valores de
	  retorno de entre los siguientes: <code class="keyword">void</code>, <code class="keyword">char</code>,
	  <code class="keyword">int</code> y <code class="keyword">float</code>. Ahora cree un fichero
	  <code class="filename">.cpp</code> que incluya su fichero de cabecera
	  y haga definiciones para todas esas funciones. Cada definición
	  simplemente debe imprimir en nombre de la función, la lista de
	  argumentos y el tipo de retorno para que se sepa que ha sido
	  llamada. Cree un segundo fichero <code class="filename">.cpp</code> que
	  incluya el fichero de cabecera y defina una <code class="code">int
	  main()</code>, que contenga llamadas a todas sus
	  funciones. Compile y ejecute su programa.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa que use dos bucles <code class="keyword">for</code> anidados y
	  el operador módulo (<code class="literal">%</code>) para detectar e imprimir
	  números enteros (números enteros sólo divisibles entre si mismos
	  y entre 1).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa que utilice un bucle <code class="keyword">while</code>
	  para leer palabras de la entrada estándar
	  (<code class="varname">cin</code>) y las guarde en un
	  <code class="type">string</code>. Este es un bucle <code class="keyword">while</code>
	  «infinito», que debe romper (y salir del
	  programa) usando la sentencia <code class="keyword">break</code>. Por cada palabra
	  que lea, evalúela primero usando una secuencia de sentencias
	  <code class="keyword">if</code> para «mapear» un valor entero de la
	  palabra, y después use una sentencia <code class="keyword">switch</code> que
	  utilice ese valor entero como selector (esta secuencia de
	  eventos no es un buen estilo de programación; solamente es un
	  supuesto para que practique con el control de flujo). Dentro
	  de cada <code class="keyword">case</code>, imprima algo con sentido. Debe decidir
	  cuales son las palabras interesantes y qué significan. También
	  debe decidir qué palabra significa el fin del programa. Pruebe
	  el programa redireccionando un fichero como entrada (si quiere
	  ahorrarse tener que escribir, ese fichero puede ser el propio
	  código fuente del programa).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Menu.cpp</code> para usar sentencias
	  <code class="keyword">switch</code> en lugar de <code class="keyword">if</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa que evalúe las dos expresiones de la
	  sección llamada «precedencia».
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">YourPets2.cpp</code> para que use
	  varios tipos de datos distintos (<code class="type">char</code>,
	  <code class="type">int</code>, <code class="type">float</code>, <code class="type">double</code>, y
	  sus variantes). Ejecute el programa y cree un mapa del esquema
	  de memoria resultante. Si tiene acceso a más de un tipo de
	  máquina, sistema operativo, o compilador, intente este
	  experimento con tantas variaciones como pueda manejar.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree dos funciones, una que tome un <code class="type">string*</code> y una
	  que tome un <code class="type">string&amp;</code>. Cada una de estas funciones
	  debería modificar el objeto <code class="type">externo</code> a su
	  manera. En <code class="function">main()</code>, cree e inicialice un
	  objeto <code class="type">string</code>, imprímalo, después páselo a cada
	  una de las dos funciones, imprimiendo los resultados.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa que use todos los trígrafos para ver si su
	  compilador los soporta.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Compile y ejecute <code class="filename">Static.cpp</code>. Elimine la
	  palabra reservada <code class="keyword">static</code> del código, compile y
	  ejecútelo de nuevo, y explique lo que ocurre.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Intente compilar y enlazar <code class="filename">FileStatic.cpp</code>
	  con <code class="filename">FileStatic2.cpp</code>. ¿Qué significan los
	  mensajes de error que aparecen?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Boolean.cpp</code> para que funcione
	  con valores <code class="type">double</code> en lugar de <code class="type">int</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Boolean.cpp</code> y
	  <code class="filename">Bitwise.cpp</code> de modo que usen los
	  operadores explícitos (si su compilador es conforme al
	  Estándar C++ los soportará).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Bitwise.cpp</code> para usar las
	  funciones de <code class="filename">Rotation.cpp</code>. Asegúrese de
	  que muestra los resultados que deje claro qué ocurre durante
	  las rotaciones.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Ifthen.cpp</code> para usar el
	  operador <code class="keyword">if-else</code> ternario(<code class="literal">?:</code>).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una <code class="keyword">struct</code> que contenga dos objetos
	  <code class="classname">string</code> y uno <code class="type">int</code>. Use un
	  <code class="keyword">typedef</code> para el nombre de la <code class="keyword">struct</code>. Cree
	  una instancia de la <code class="keyword">struct</code>, inicialice los tres
	  valores de la instancia, y muestrelos en pantalla. Tome la
	  dirección de su instancia y asígnela a un puntero a tipo de la
	  <code class="keyword">struct</code>. Usando el puntero, Cambie los tres valores de
	  la instancia y muestrelos.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un programa que use un enumerado de colores. Cree una
	  variable de este tipo <code class="keyword">enum</code> y, utilizando un bucle,
	  muestre todos los números que corresponden a los nombres de
	  los colores.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Experimente con <code class="filename">Union.cpp</code> eliminando
	  varios elementos de la <code class="keyword">union</code> para ver el efecto que
	  causa en el tamaño de la <code class="keyword">union</code> resultante. Intente
	  asignar un elemento (por tanto un tipo) de la <code class="keyword">union</code> y
	  muéstrelo por medio de un elemento diferente (por tanto, un
	  tipo diferente) para ver que ocurre.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un programa que defina dos arrays de <code class="type">int</code>,
	  uno a continuación del otro. Indexe el primer array más allá
	  de su tamaño para caer sobre el segundo, haga una
	  asignación. Muestre el segundo array para ver los cambios que
	  eso ha causado. Ahora intente definir una variable
	  <code class="type">char</code> entre las definiciones de los arrays, y
	  repita el experimento. Quizá quiera crear una función para
	  imprimir arrays y así simplificar el código.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">ArrayAddresses.cpp</code> para que
	  funcione con los tipos de datos <code class="type">char</code>, <code class="type">long
	  int</code>, <code class="type">float</code> y <code class="type">double</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Aplique la técnica de <code class="filename">ArrayAddresses.cpp</code>
	  para mostrar el tamaño de la <code class="keyword">struct</code> y las direcciones
	  de los elementos del array de
	  <code class="filename">StructArray.cpp</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un array de objetos <code class="type">string</code> y asigne una
	  cadena a cada elemento. Muestre el array usando un bucle
	  <code class="keyword">for</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree dos nuevos programas a partir de
	  <code class="filename">ArgsToInts.cpp</code> que usen
	  <code class="function">atol()</code> y <code class="function">atof()</code>
	  respectivamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">PointerIncrement2.cpp</code> de modo
	  que use una <code class="keyword">union</code> en lugar de una <code class="keyword">struct</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">PointerArithmetic.cpp</code> para que
	  funcione con <code class="type">long</code> y <code class="type">long double</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Defina una variable <code class="type">float</code>. Tome su dirección,
	  moldee esa dirección a un <code class="type">unsigned char</code>, y
	  asígnela a un puntero <code class="type">unsigned char</code>. Usando este
	  puntero y <code class="literal">[]</code>, indexe la variable
	  <code class="type">float</code> y use la función
	  <code class="function">printBinary()</code> definida en este capítulo
	  para mostrar un mapa de cada <code class="type">float</code> (vaya desde 0
	  hasta <code class="code">sizeof(float)</code>). Cambie el valor del
	  <code class="type">float</code> y compruebe si puede averiguar que hay en el
	  float (el <code class="type">float</code> contiene datos codificados).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Defina un array de <code class="type">int</code>. Tome la dirección de
	  comienzo de ese array y utilice <code class="literal">static_cast</code> para
	  convertirlo a un <code class="type">void*</code>. Escriba una función que
	  tome un <code class="type">void*</code>, un número (que indica el número de
	  bytes), y un valor (indicando el valor que debería ser
	  asignado a cada byte) como argumentos. La función debería
	  asignar a cada byte en el rango especificado el valor dado
	  como argumento. Pruebe la función con su array de
	  <code class="type">int</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un array <code class="keyword">const</code> de <code class="type">double</code> y un array
	  <code class="keyword">volatile</code> de <code class="type">double</code>. Indexe cada array y
	  utilice <code class="keyword">const_cast</code> para moldear cada elemento de
	  no-<code class="keyword">const</code> y no-<code class="keyword">volatile</code>, respectivamente, y
	  asigne un valor a cada elemento.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una función que tome un puntero a un array de
	  <code class="type">double</code> y un valor indicando el tamaño de ese
	  array. La función debería mostrar cada valor del array. Ahora
	  cree un array de <code class="type">double</code> y inicialice cada
	  elemento a cero, después utilice su función para mostrar el
	  array. Después use <code class="keyword">reinterpret_cast</code> para moldear la
	  dirección de comienzo de su array a un <code class="type">unsigned
	  char*</code>, y ponga a 1 cada byte del array (aviso:
	  necesitará usar <code class="literal">sizeof</code> para calcular el número de
	  bytes que tiene un <code class="type">double</code>). Ahora use su función
	  de impresión de arrays para mostrar los resultados. ¿Por qué
	  cree los elementos no tienen el valor 1.0?
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Reto) Modifique <code class="filename">FloatingAsBinary.cpp</code>
	  para que muestra cada parte del <code class="type">double</code> como un
	  grupo separado de bits. Tendrá que reemplazar las llamadas a
	  <code class="function">printBinary()</code> con su propio código
	  específico (que puede derivar de
	  <code class="function">printBinary()</code>) para hacerlo, y también
	  tendrá que buscar y comprender el formato de punto flotante
	  incluyendo el ordenamiento de bytes para su compilador (esta
	  parte es el reto).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un <code class="filename">makefile</code> que no sólo compile
	  <code class="filename">YourPets1.cpp</code> y
	  <code class="filename">YourPets2.cpp</code> (para cada compilador
	  particular) sino que también ejecute ambos programas como
	  parte del comportamiento del objetivo
	  predeterminado. Asegúrese de usar las reglas de sufijo.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">StringizingExpressions.cpp</code> para
	  que <code class="code">P(A)</code> sea condicionalmente definida con
	  <code class="keyword">#ifdef</code> para permitir que el código de depuración sea
	  eliminado automáticamente por medio de una bandera en línea de
	  comandos. Necesitará consultar la documentación de su
	  compilador para ver cómo definir y eliminar valores del
	  preprocesador en el compilador de línea de comandos.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Defina una función que tome un argumento <code class="type">double</code> y
	  retorne un <code class="type">int</code>. Cree e inicialice un puntero a
	  esta función, e invoque la función por medio del puntero.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Declare un puntero a un función que toma un argumento
	  <code class="type">int</code> y retorna un puntero a una función que toma
	  un argumento <code class="type">char</code> y retorna un
	  <code class="type">float</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">FunctionTable.cpp</code> para que cada
	  función retorne un <code class="type">string</code> (en lugar de mostrar un
	  mensaje) de modo que este valor se imprima en
	  <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un <code class="filename">makefile</code> para uno de los
	  ejercicios previos (a su elección) que le permita escribir
	  <span class="command"><strong>make</strong></span> para construir una versión en
	  producción del programa y <span class="command"><strong>make debug</strong></span> para
	  construir una versión del programa que incluye información de
	  depuración.
	</p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s12.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s12.html">3.12. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C03.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C04.html">4: Abstracción de Datos</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C04.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
