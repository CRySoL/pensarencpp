<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>4: Abstracción de Datos</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="prev" href="ch03s13.html" title="3.13. Ejercicios" />
    <link rel="next" href="ch04s02.html" title="4.2. ¿Qué tiene de malo?" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s13.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s13.html">3.13. Ejercicios</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch04s02.html">4.2. ¿Qué tiene de malo?</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch04s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="chapter" title="4: Abstracción de Datos">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="C04"></a>4: Abstracción de Datos</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <strong>Tabla de contenidos</strong>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="C04.html#idp5190288">4.1. Una librería pequeña al estilo C</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s02.html">4.2. ¿Qué tiene de malo?</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s03.html">4.3. El objeto básico</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s04.html">4.4. ¿Qué es un objeto?</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s05.html">4.5. Tipos abstractos de datos</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s06.html">4.6. Detalles del objeto</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s07.html">4.7. Conveciones para los ficheros de cabecera</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s08.html">4.8. Estructuras anidadas</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s09.html">4.9. Resumen</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch04s10.html">4.10. Ejercicios</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="highlights">
        <p>
      C++ es una herramienta de mejora de la productividad. ¿Por qué
      si no haría el esfuerzo (y es un esfuerzo, a pesar de lo fácil que
      intetemos hacer la transición)
    </p>
      </div>
      <p>
    de cambiar de algún lenguaje que ya conoce y con el cual ya es
    productivo a un nuevo lenguaje con el que será menos productivo
    durante un tiempo, hasta que se haga con él? Se debe a que está
    convencido de que conseguirá grandes ventajas usando esta nueva
    herramienta.
  </p>
      <p>
    En términos de programación, productividad significa que menos
    personas, en menos tiempo, puedan realizar programas más complejos y
    significativos. Desde luego, hay otras cuestiones que nos deben
    importar a la hora de escoger un lenguaje de programación. Aspectos
    a tener en cuenta son la eficiencia (¿la naturaleza del lenguaje
    hace que nuestros programas sean lentos o demasiado grandes?), la
    seguridad (¿nos ayuda el lenguaje a asegurarnos de que nuestros
    programas hagan siempre lo que queremos?  ¿maneja el lenguaje los
    errores apropiadamente?)  y el mantenimiento (¿el lenguaje ayuda a
    crear código fácil de entender, modificar y extender?). Estos son,
    con certeza, factores importantes que se examinarán en este libro.
  </p>
      <p>
    Pero la productividad real significa que un programa que para ser escrito, antes
    requería de tres personas trabajando una semana, ahora le lleve sólo un día o dos a
    una sola persona. Esto afecta a varios niveles de la esfera económica. A usted le
    agrada ver que es capaz de construir algo en menos tiempo, sus clientes (o jefe) están
    contentos porque los productos les llegan más rápido y utilizando menos mano
    de obra y finalmente los compradores se alegran porque pueden obtener productos más
    baratos. La única manera de obtener incrementos masivos en productividad es apoyándose
    en el código de otras personas; o sea, usando librerías.
  </p>
      <p>
    Una librería es simplemente un montón de código que alguien ha
    escrito y empaquetado todo junto. Muchas veces, el paquete mínimo es
    tan sólo un archivo con una extensión especial como
    <code class="filename">lib</code> y uno o más archivos de cabecera que le
    dicen al compilador qué contiene la librería. El enlazador sabrá cómo
    buscar el archivo de la librería y extraer el código compilado
    correcto. Sin embargo, ésta es sólo una forma de entregar una
    librería. En plataformas que abarcan muchas arquitecturas, como
    GNU o Unix, el único modo sensato de entregar una libraría es con
    código fuente para que así pueda ser reconfigurado y reconstruido en
    el nuevo objetivo.
  </p>
      <p>
    De esta forma, las librerías probablemente sean la forma más
    importante de progresar en términos de productividad y uno de los
    principales objetivos del diseño de C++ es hacer más fácil el uso de
    librerías. Esto implica entonces, que hay algo difícil al usar
    librerías en C. Entender este factor le dará una primera idea sobre
    el diseño de C++, y por lo tanto, de cómo usarlo.
  </p>
      <div class="sect1" title="4.1. Una librería pequeña al estilo C">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="idp5190288"></a>4.1. Una librería pequeña al estilo C</h2>
            </div>
          </div>
        </div>
        <p>
      Aunque muchas veces, una librería comienza como una colección de
      funciones, si ha usado alguna librería C de terceros habrá
      observado que la cosa no termina ahí porque hay más que
      comportamiento, acciones y funciones. También hay características
      (azul, libras, textura, luminiscencia), las cuales están
      representadas por datos. En C, cuando debemos representar
      características, es muy conveniente agruparlas todas juntas en una
      <span class="emphasis"><em>estructura</em></span>, especialmente cuando queremos
      representar más de un tipo de cosa en el problema. Así, se puede
      trabajar con una variable de esta
      <span class="emphasis"><em>estructuras</em></span> para representar cada cosa.
    </p>
        <p>
      Por eso, la mayoría de las librerías en C están formadas por un
      conjunto de estructuras y funciones que actúan sobre las
      primeras. Como ejemplo de esta técnica, considere una herramienta
      de programación que se comporta como un array, pero cuyo tamaño se
      puede fijar en tiempo de ejecución, en el momento de su
      creación. La llamaremos <code class="type">CStash</code>
      <sup>[<a id="idp5193280" href="#ftn.idp5193280" class="footnote">46</a>]</sup>. Aunque está escrito en C++, tiene el estilo clásico
      de una librería escrita en C:
    </p>
        <div class="example">
          <a id="idp5194392"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C04:CLib.h</span>
<span class="hl slc">// Header file for a C-like library</span>
<span class="hl slc">// An array-like entity created at runtime</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> CStashTag <span class="hl opt">{</span>
  <span class="hl kwb">int</span> size<span class="hl opt">;</span>      <span class="hl slc">// Size of each space</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>  <span class="hl slc">// Number of storage spaces</span>
  <span class="hl kwb">int</span> next<span class="hl opt">;</span>      <span class="hl slc">// Next empty space</span>
  <span class="hl slc">// Dynamically allocated array of bytes:</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> storage<span class="hl opt">;</span>
<span class="hl opt">}</span> CStash<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">);</span>
<span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">const void</span><span class="hl opt">*</span> element<span class="hl opt">);</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> index<span class="hl opt">);</span>
<span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> increase<span class="hl opt">);</span>
<span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 4.1. C04/CLib.h</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      Normalmente se utiliza un «rótulo» como
      <code class="type">CStashTag</code> en aquellas estructuras que necesitan
      referenciarse dentro de si mismas. Ese es el caso de una
      <span class="emphasis"><em>lista enlazada</em></span> (cada elemento de la lista
      contiene un puntero al siguiente elemento) se necesita un puntero a
      la siguiente variable estructura, o sea, una manera de identificar
      el tipo de ese puntero dentro del cuerpo de la propia
      estructura. En la declaración de las estructuras de una librería
      escrita en C también es muy común ver el uso de <code class="keyword">typedef</code>
      como el del ejemplo anterior. Esto permite al programador tratar
      las estructuras como un nuevo tipo de dato y así definir nuevas
      variables (de esa estructura) del siguiente modo:
    </p>
        <pre class="programlisting">
CStash A<span class="hl opt">,</span> B<span class="hl opt">,</span> C<span class="hl opt">;</span>
</pre>
        <p>
      El puntero <code class="varname">storage</code> es un <code class="type">unsigned
      char*</code>. Un <code class="type">unsigned char</code> es la menor pieza de
      datos que permite un compilador C, aunque en algunas máquinas
      puede ser de igual tamaño que la mayor. Aunque es dependiente de
      la implementación, por lo general un <code class="type">unsigned char</code>
      tiene un tamaño de un byte. Dado que <code class="type">CStash</code> está
      diseñado para almacenar cualquier tipo de estructura, el lector se
      puede preguntar si no sería más apropiado un puntero <code class="type">void
      *</code>. Sin embargo, el objetivo no es tratar este puntero de
      almacenamiento como un bloque de datos de tipo desconocido, sino
      como un bloque de bytes contiguos.
    </p>
        <p>
      El archivo de código fuente para la implementación (del que no se
      suele disponer si fuese una librería comercial &#8212;normalmente sólo
      dispondrá de un <code class="filename">.obj</code>,
      <code class="filename">.lib</code> o <code class="filename">.dll</code>, etc) tiene
      este aspecto:
    </p>
        <div class="example">
          <a id="idp5202928"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C04:CLib.cpp {O}</span>
<span class="hl slc">// Implementation of example C-like library</span>
<span class="hl slc">// Declare structure and functions:</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt; </span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl slc">// Quantity of elements to add</span>
<span class="hl slc">// when increasing storage:</span>
<span class="hl kwb">const int</span> increment <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">initialize</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  s<span class="hl opt">-&gt;</span>size <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  s<span class="hl opt">-&gt;</span>storage <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  s<span class="hl opt">-&gt;</span>next <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">add</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">const void</span><span class="hl opt">*</span> element<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>s<span class="hl opt">-&gt;</span>next <span class="hl opt">&gt;=</span> s<span class="hl opt">-&gt;</span>quantity<span class="hl opt">)</span> <span class="hl slc">//Enough space left?</span>
    <span class="hl kwd">inflate</span><span class="hl opt">(</span>s<span class="hl opt">,</span> increment<span class="hl opt">);</span>
  <span class="hl slc">// Copy element into storage,</span>
  <span class="hl slc">// starting at next empty space:</span>
  <span class="hl kwb">int</span> startBytes <span class="hl opt">=</span> s<span class="hl opt">-&gt;</span>next <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> e <span class="hl opt">= (</span><span class="hl kwb">unsigned char</span><span class="hl opt">*)</span>element<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    s<span class="hl opt">-&gt;</span>storage<span class="hl opt">[</span>startBytes <span class="hl opt">+</span> i<span class="hl opt">] =</span> e<span class="hl opt">[</span>i<span class="hl opt">];</span>
  s<span class="hl opt">-&gt;</span>next<span class="hl opt">++;</span>
  <span class="hl kwa">return</span><span class="hl opt">(</span>s<span class="hl opt">-&gt;</span>next <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Index number</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">fetch</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> index<span class="hl opt">) {</span>
  <span class="hl slc">// Check index boundaries:</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl num">0</span> <span class="hl opt">&lt;=</span> index<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>index <span class="hl opt">&gt;=</span> s<span class="hl opt">-&gt;</span>next<span class="hl opt">)</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// To indicate the end</span>
  <span class="hl slc">// Produce pointer to desired element:</span>
  <span class="hl kwa">return</span> <span class="hl opt">&amp;(</span>s<span class="hl opt">-&gt;</span>storage<span class="hl opt">[</span>index <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">]);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> s<span class="hl opt">-&gt;</span>next<span class="hl opt">;</span>  <span class="hl slc">// Elements in CStash</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">inflate</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> increase<span class="hl opt">) {</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>increase <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> newQuantity <span class="hl opt">=</span> s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">+</span> increase<span class="hl opt">;</span>
  <span class="hl kwb">int</span> newBytes <span class="hl opt">=</span> newQuantity <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span>
  <span class="hl kwb">int</span> oldBytes <span class="hl opt">=</span> s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">*</span> s<span class="hl opt">-&gt;</span>size<span class="hl opt">;</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> b <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> oldBytes<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> s<span class="hl opt">-&gt;</span>storage<span class="hl opt">[</span>i<span class="hl opt">];</span> <span class="hl slc">// Copy old to new</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[](</span>s<span class="hl opt">-&gt;</span>storage<span class="hl opt">);</span> <span class="hl slc">// Old storage</span>
  s<span class="hl opt">-&gt;</span>storage <span class="hl opt">=</span> b<span class="hl opt">;</span> <span class="hl slc">// Point to new memory</span>
  s<span class="hl opt">-&gt;</span>quantity <span class="hl opt">=</span> newQuantity<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">cleanup</span><span class="hl opt">(</span>CStash<span class="hl opt">*</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>s<span class="hl opt">-&gt;</span>storage <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
   cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;freeing storage&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
   <span class="hl kwa">delete</span> <span class="hl opt">[]</span>s<span class="hl opt">-&gt;</span>storage<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 4.2. C04/CLib.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      <code class="function">initialize()</code> realiza las operaciones
      iniciales necesarias para la <code class="type">struct CStash</code>, poniendo
      los valores apropiados en las variables internas. Inicialmente, el
      puntero <code class="varname">storage</code> tiene un cero dado que aún no
      se ha almacenado nada.
    </p>
        <p>
      La función <code class="function">add()</code> inserta un elemento en el
      siguiente lugar disponible de la <code class="type">CStash</code>. Para
      lograrlo, primero verifica que haya suficiente espacio
      disponible. Si no lo hay, expande el espacio de almacenamiento
      (<code class="varname">storage</code>) usando la función
      <code class="function">inflate()</code> que se describe después.
    </p>
        <p>
      Como el compilador no conoce el tipo específico de la variable que
      está siendo almacenada (todo lo que obtiene la función es un
      <code class="type">void*</code>), no se puede hacer una asignación simple, que
      sería lo más conveniente. En lugar de eso, la variable se copia
      byte a byte. La manera más directa de hacerlo es utilizando el
      indexado de arrays. Lo habitual es que en
      <code class="varname">storage</code> ya haya bytes almacenados, lo cual es
      indicado por el valor de <code class="varname">next</code>. Para obtener la
      posición de inserción correcta en el array, se multiplica
      <code class="varname">next</code> por el tamaño de cada elemento (en bytes)
      lo cual produce el valor de <code class="varname">startBytes</code>. Luego
      el argumento <code class="varname">element</code> se moldea a <code class="type">unsigned
      char*</code> para que se pueda direccionar y copiar byte a byte en
      el espacio disponible de <code class="varname">storage</code>. Se incrementa
      <code class="varname">next</code> de modo que indique el siguiente lugar de
      almacenamiento disponible y el «índice» en el que ha
      almacenado el elemento para que el valor se puede recuperar
      utilizando el índice con <code class="function">fetch()</code>.
    </p>
        <p>
      <code class="function">fetch()</code> verifica que el índice tenga un valor
      correcto y devuelve la dirección de la variable deseada, que se
      calcula en función del argumento <code class="varname">index</code>. Dado
      que <code class="varname">index</code> es un desplazamiento desde el
      principio en la <code class="type">CStash</code>, se debe multiplicar por el
      tamaño en bytes que ocupa cada elemento para obtener dicho
      desplazamiento en bytes. Cuando utilizamos este desplazamiento
      como índice del array <code class="varname">storage</code> lo que obtenemos
      no es la dirección, sino el byte almacenado. Lo que hacemos
      entonces es utilizar el operador dirección-de <code class="literal">&amp;</code>.
    </p>
        <p>
      <code class="function">count()</code> puede parecer un poco extraña a los
      programadores experimentados en C. Podría parecer demasiado
      complicada para una tarea que probablemente sea mucho más fácil de
      hacer a mano. Por ejemplo, si tenemos una <code class="type">CStash</code>
      llamada <code class="varname">intStash</code>, es mucho más directo
      preguntar por la cantidad de elementos utilizando
      <code class="varname">intStash.next</code>, que llamar a una función (que
      implica sobrecarga), como
      <code class="function">count(&amp;intStash)</code>. Sin embargo, la
      cantidad de elementos se calcula en función tanto del puntero
      <code class="varname">next</code> como del tamaño en bytes de cada elemento
      de la <code class="type">CStash</code>; por eso la interfaz de la función
      <code class="function">count()</code> permite la flexibilidad necesaria
      para no tener que preocuparnos por estas cosas. Pero, ¡ay!, la
      mayoría de los programadores no se preocuparán por descubrir lo
      que para nosotros es el «mejor» diseño para la
      librería. Probablemente lo que harán es mirar dentro de la
      estructura y obtener el valor de <code class="varname">next</code>
      directamente. Peor aún, podrían incluso cambiar el valor de
      <code class="varname">next</code> sin nuestro permiso. ¡Si hubiera alguna
      forma que permitiera al diseñador de la librería tener un mejor
      control sobre este tipo de cosas! (Sí, esto es un presagio).
    </p>
        <div class="sect2" title="4.1.1. Asignación dinámica de memoria">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp5221312"></a>4.1.1. Asignación dinámica de memoria</h3>
              </div>
            </div>
          </div>
          <p>
	Nunca se puede saber la cantidad máxima de almacenamiento que se
	necesitará para una <code class="type">CStash</code>, por eso la memoria a la
	que apuntan los elementos de <code class="varname">storage</code> se
	asigna desde el <span class="emphasis"><em>montículo</em></span>
	(<span class="foreignphrase"><em class="foreignphrase">heap</em></span>)
	<sup>[<a id="idp5222992" href="#ftn.idp5222992" class="footnote">47</a>]</sup>.

	El montículo es un gran bloque de memoria que se utiliza para
	asignar en pequeños trozos en tiempo de ejecución. Se usa el
	heap cuando no se conoce de antemano la cantidad de memoria que
	necesitará el programa que está escribiendo. Por ejemplo, eso
	ocurre en un programa en el que sólo en el momento de la
	ejecución se sabe si se necesia memoria para 200 variables
	<code class="type">Avión</code> o para 20. En C Estándar, las funciones para
	asignación dinámica de memoria incluyen
	<code class="function">malloc()</code>, <code class="function">calloc()</code>,
	<code class="function">realloc()</code> y <code class="function">free()</code>. En
	lugar de llamadas a librerías, C++ cuenta con una técnica más
	sofisticada (y por lo tanto más fácil de usar) para tratar la
	memoria dinámica. Esta técnica está integrada en el lenguaje por
	medio de las palabras reservadas <code class="keyword">new</code> y <code class="keyword">delete</code>.
      </p>
          <p>
	La función <code class="function">inflate()</code> usa <code class="keyword">new</code> para
	obtener más memoria para la <code class="type">CStash</code>. En este caso el
	espacio de memoria sólo se amplia y nunca se
	reduce. <code class="function">assert()</code> garantiza que no se pase
	un número negativo como argumento a
	<code class="function">inflate()</code> como valor de incremento. La
	nueva cantidad de elmentos que se podrán almacenar (una vez se
	haya terminado <code class="function">inflate()</code>) se determina en la
	variable <code class="varname">newQuantity</code> que se multiplica por
	el número de bytes que ocupa cada elemento, para obtener el
	nuevo número total de bytes de la asignación en la variable
	<code class="varname">newBytes</code>. Dado que se sabe cuántos bytes hay
	que copiar desde la ubicación anterior,
	<code class="varname">oldBytes</code> se calcula usando la cantidad
	antigua de bytes (<code class="varname">quantity</code>).
      </p>
          <p>
	La petición de memoria ocurre realmente en la
	<span class="emphasis"><em>expresión-new</em></span> que involucra la palabra
	reservada <code class="keyword">new</code>:
      </p>
          <pre class="programlisting">
<span class="hl kwa">new</span> <span class="hl kwb">unsigned char</span><span class="hl opt">[</span>newBytes<span class="hl opt">];</span>
</pre>
          <p>
	La forma general de una <span class="emphasis"><em>expresión-new</em></span>
	es:
      </p>
          <pre class="programlisting">
<span class="hl kwa">new</span> Tipo<span class="hl opt">;</span>
</pre>
          <p>
	donde <code class="type">Tipo</code> describe el tipo de variable para la
	cual se solicita memoria en el
	<span class="emphasis"><em>montículo</em></span>. Dado que en este caso, se desea
	asignar memoria para un array de <code class="type">unsigned char</code> de
	<code class="varname">newBytes</code> elementos, eso es lo que aparece como
	<code class="type">Tipo</code>. Del mismo modo, se puede asignar memoria para
	algo más simple como un <code class="type">int</code> con la expresión:
      </p>
          <pre class="programlisting">
<span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">;</span>
</pre>
          <p>
	y aunque esto se utiliza muy poco, demuestra que la sintaxis es
	consistente.
      </p>
          <p>
	Una <span class="emphasis"><em>expresión-new</em></span> devuelve un
	<span class="emphasis"><em>puntero</em></span> a un objeto del tipo exacto que se
	le pidió. De modo que con <code class="code">new Tipo</code> se obtendrá un
	puntero a un objeto de tipo <code class="type">Tipo</code>, y con <code class="code">new
	int</code> obtendrá un puntero a un <code class="type">int</code>. Si quiere
	un nuevo array de <code class="type">unsigned char</code> la expresión
	devolverá un puntero al primer elemento de dicho array. El
	compilador verificará que se asigne lo que devuelve la
	<span class="emphasis"><em>expresión-new</em></span> a una variable puntero del
	tipo adecuado.
      </p>
          <p>
	Por supuesto, es posible que al pedir memoria, la petición
	falle, por ejemplo, si no hay más memoria libre en el
	sistema. Como verá más adelante, C++ cuenta con mecanismos que
	entran en juego cuando la operación de asignación de memoria no
	se puede satisfacer.
      </p>
          <p>
	Una vez que se ha obtenido un nuevo espacio de almacenamiento,
	los datos que estaban en el antiguo se deben copiar al
	nuevo. Esto se hace, nuevamente, en un bucle, utilizando la
	notación de índexado de arrays, copiando un byte en cada
	iteración del bucle. Una vez finalizada esta copia, ya no se
	necesitan los datos que están en el espacio de almacenamiento
	original por lo que se pueden liberar de la memoria para que
	otras partes del programa puedan usarlo cuando lo necesiten. La
	palabra reservada <code class="keyword">delete</code> es el complemento de
	<code class="keyword">new</code> y se debe utilizar sobre todas aquellas variables a
	las cuales se les haya asignado memoria con <code class="keyword">new</code>. (Si se
	olvida de utilizar <code class="keyword">delete</code> esa memoria queda
	in-utilizable. Si estas fugas de memoria (<span class="foreignphrase"><em class="foreignphrase">memory
	leak</em></span>) son demasiado abundantes, la memoria
	disponible se acabará.)  Existe una sintaxis especial cuando se
	libera un array. Es como si recordara al compilador que ese
	puntero no apunta sólo a un objeto, sino a un array de objetos;
	se deben poner un par de corchetes delante del puntero que se
	quiere liberar:
      </p>
          <pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[]</span>myArray<span class="hl opt">;</span>
</pre>
          <p>
	Una vez liberado el antiguo espacio de almacenamiento, se puede
        asignar el puntero del nuevo espacio de memoria al puntero
        <code class="varname">storage</code>, se actualiza
        <code class="varname">quantity</code> y con eso
        <code class="function">inflate()</code> ha terminado su trabajo.
      </p>
          <p>
	En este punto es bueno notar que el administrador de memoria del
	montículo&gt; es bastante primitivo. Nos facilita trozos de memoria
	cuando se lo pedimos con <code class="keyword">new</code> y los libera cuando
	invocamos a <code class="keyword">delete</code>. Si un programa asigna y libera
	memoria muchas veces, terminaremos con un montículo
	<span class="emphasis"><em>fragmentado</em></span>, es decir un montículo en el
	que si bien puede haber memoria libre utilizable, los trozos de
	memoria están divididos de tal modo que no exista un trozo que
	sea lo suficientemente grande para las necesidades concretas en
	un momento dado. Lamentablemente no existe una capacidad
	inherente del lenguaje para efectuar <span class="emphasis"><em>defragmentaciones
	del montículo</em></span>. Un defragmentador del montículo
	complica las cosas dado que tiene que mover pedazos de memoria,
	y por lo tanto, hacer que los punteros dejen de apuntar a
	valores válidos. Algunos entornos operativos vienen con este
	tipo de facilidades pero obligan al programador a utilizar
	manejadores de memoria especiales en lugar de punteros (estos
	manipuladores se pueden convertir temporalmente en punteros una
	vez bloqueada la memoria para que el defragmentador del
	montículo no la modifique). También podemos construir nosotros
	mismos uno de estos artilugios, aunque no es una tarea sencilla.
      </p>
          <p>
	Cuando creamos una variable en la pila en tiempo de compilación,
	el mismo compilador es quien se encarga de crearla y liberar la
	memoria ocupada por ella automáticamente. Conoce exactamente el
	tamaño y la duración de este tipo de variables dada por las
	reglas de ámbito. Sin embargo, en el caso de las variables
	almacenadas dinámicamente, el compilador no poseerá información
	ni del tamaño requerido por las mismas, ni de su duración. Esto
	significa que el compilador no puede encargarse de liberar
	automáticamente la memoria ocupada por este tipo de variables y
	de aquí que el responsable de esta tarea sea el programador (o
	sea usted). Para esto se debe utilizar <code class="keyword">delete</code>, lo cual
	le indica al administrador del montículo que ese espacio de
	memoria puede ser utilizado por próximas llamadas a
	<code class="keyword">new</code>. En nuestra librería de ejemplo, el lugar lógico
	para esta tarea es la función <code class="function">cleanup()</code>
	dado que allí es dónde se deben realizar todas las labores de
	finalización de uso del objeto.
      </p>
          <p>
	Para probar la librería se crean dos <code class="type">Cstash</code>, uno
        que almacene enteros y otro para cadenas de 80 caracteres:
      </p>
          <div class="example">
            <a id="idp5253528"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C04:CLibTest.cpp</span>
<span class="hl slc">//{L} CLib</span>
<span class="hl slc">// Test the C-like library</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CLib.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Define variables at the beginning</span>
  <span class="hl slc">// of the block, as in C:</span>
  CStash intStash<span class="hl opt">,</span> stringStash<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> cp<span class="hl opt">;</span>
  ifstream in<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">80</span><span class="hl opt">;</span>
  <span class="hl slc">// Now remember to initialize the variables:</span>
  <span class="hl kwd">initialize</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">,</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwd">add</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">, &amp;</span>i<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwd">count</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">);</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fetch(&amp;intStash, &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt; *(</span><span class="hl kwb">int</span><span class="hl opt">*)</span><span class="hl kwd">fetch</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">,</span> i<span class="hl opt">)</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Holds 80-character strings:</span>
  <span class="hl kwd">initialize</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">)*</span>bufsize<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">(</span><span class="hl str">&quot;CLibTest.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>in<span class="hl opt">);</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">))</span>
    <span class="hl kwd">add</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span> line<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span><span class="hl kwd">fetch</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span>i<span class="hl opt">++))!=</span><span class="hl num">0</span><span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fetch(&amp;stringStash, &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">cleanup</span><span class="hl opt">(&amp;</span>intStash<span class="hl opt">);</span>
  <span class="hl kwd">cleanup</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 4.3. C04/CLibTest.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	Dado que debemos respetar la sintaxis de C, todas las variables
        se deben declarar al comienzo de
        <code class="function">main()</code>. Obviamente, no nos podemos olvidar
        de inicializar todas las variables <code class="type">Cstash</code> más
        adelante en el bloque main(), pero antes de usarlas, llamando a
        <code class="function">initialize()</code>. Uno de los problemas con las
        librerías en C es que uno debe asegurarse de convencer al
        usuario de la importancia de las funciones de inicialización y
        destrucción.  ¡Habrá muchos problemas si estas funciones se
        omiten!  Lamentablemente el usuario no siempre se preguntará si
        la inicialización y el limpiado de los objetos son
        obligatorios. Ellos le darán importancia a lo que
        <span class="emphasis"><em>ellos</em></span> quieren hacer y no nos darán tanta
        importancia a nosotros (el programador de la librería) cuando
        les digamos «¡Hey! ¡espera un poco! ¡Debes hacer
        <span class="emphasis"><em>esto</em></span> primero!». Otro problema que
        puede presentarse es el hecho de que algunos usuarios quieran
        inicializar los elementos (datos internos) de una estructura por
        su cuenta. En C no hay un mecanismo para prevenir este tipo de
        conductas (más presagios de los temás que vendrán...).
      </p>
          <p>
	La <code class="varname">intStash</code> se va llenando con enteros
        mientras que el <code class="varname">stringStash</code> se va llenando
        con arrays de caracteres. Estos arrays de caracteres son
        producidos leyendo el archivo fuente
        <code class="filename">CLibTest.cpp</code> y almacenando las líneas de
        este archivo en el <code class="type">string</code>
        <code class="varname">line</code>. Obtenemos la representación
        «puntero a carácter» de <code class="varname">line</code> con
        el método <code class="function">c_str()</code>. </p>
          <p>
	Una vez cargados los <code class="type">Stash</code> ambos se muestran en
	pantalla. <code class="varname">intStash</code> se imprime usando un bucle
	<code class="keyword">for</code> en el cual se usa <code class="function">count()</code> para
	determinar la cantidad de elementos. El
	<code class="varname">stringStash</code> se muestra utilizando un bucle
	<code class="keyword">while</code> dentro del cual se va llamando a
	<code class="function">fetch()</code>. Cuando esta función devuelve cero
	se rompe el bucle ya que esto significará que se han sobrepasado
	los límites de la estructura.
      </p>
          <p>
	El lector también pudo haber visto un molde adicional en la
	línea:
      </p>
          <pre class="programlisting">
cp <span class="hl opt">= (</span><span class="hl kwb">char</span><span class="hl opt">*)</span><span class="hl kwd">fetch</span><span class="hl opt">(&amp;</span>stringStash<span class="hl opt">,</span> i<span class="hl opt">++)</span>
</pre>
          <p>
	Esto se debe a la comprobación estricta de tipos en C++, que no
	permite asignar un <code class="type">void *</code> a una variable de
	cualquier tipo, mientras que C sí lo hubiera permitido.
      </p>
        </div>
        <div class="sect2" title="4.1.2. Malas suposiciones">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp5267360"></a>4.1.2. Malas suposiciones</h3>
              </div>
            </div>
          </div>
          <p>
	Antes de abordar los problemas generales de la creación de una
	librería C, discutiremos otro asunto importante que se debe
	tener claro. Fíjese que el archivo de cabecera
	<code class="filename">CLib.h</code> <span class="emphasis"><em>debe</em></span> incluirse
	en cada archivo fuente que haga referencia al tipo
	<code class="type">CStash</code> ya que el compilador no puede adivinar qué
	aspecto tiene la estructura. Sin embargo,
	<span class="emphasis"><em>sí</em></span> puede adivinar el aspecto de una
	función. Aunque eso pueda parecer una ventaja, veremos que en
	realidad, es un grave problema de C.
      </p>
          <p>
	Aunque siempre debería declarar las funciones incluyendo un
	archivo de cabecera, en C las declaraciones de funciones no son
	esenciales. En este lenguaje (pero no en C++), es posible llamar
	a una función que no ha sido declarada. Un buen compilador
	seguramente avisará de que deberíamos declarar la función antes
	de usarla, pero nos permitirá seguir dado que no es obligatorio
	hacerlo en C estándar. Esta es una práctica peligrosa ya que el
	compilador puede asumir que una función que ha sido llamada con
	un <code class="type">int</code> como argumento, tenga un <code class="type">int</code>
	como argumento cuando, en realidad, es un
	<code class="type">float</code>. Como veremos, esto puede producir errores
	que pueden ser muy difíciles de depurar.
      </p>
          <p>
	Se dice que cada archivo de implementación C (los archivos de
	extensión <code class="filename">.c</code>) es una unidad de traducción
	(<span class="foreignphrase"><em class="foreignphrase">translation unit</em></span>). El compilador
	se ejecuta independientemente sobre cada unidad de traducción
	ocupándose, en ese momento, solamente en ese archivo. Por eso,
	la información que le demos al compilador por medio de los
	archivos de cabecera es muy importante dado que determina la
	forma enq que ese archivo se relaciona con las demás partes del
	programa. Por eso motivo, las declaraciones en los archivos de
	cabecera son particularmente importantes dado que, en cada lugar
	que se incluyen, el compilador sabrá exactamente qué hacer. Por
	ejemplo, si en un archivo de cabecera tenemos la declaración
	<code class="function">void func(float) </code>, si llamamos a
	<code class="function">func()</code> con un <code class="type">int</code> como
	argumento, el compilador sabrá que deberá convertir el
	<code class="type">int</code> a <code class="type">float</code> antes de pasarle el valor
	a la función (a esto se le llama <span class="emphasis"><em>promoción</em></span>
	de tipos). Sin la declaración, el compilador asumiría que la
	función tiene la forma <code class="function">func(int)</code>, no
	realizaría la promoción y pasaría, por lo tanto, datos
	incorrectos a la función.
      </p>
          <p>
	Para cada unidad de traducción, el compilador crea un archivo
	objeto, de extensión <code class="filename">.o</code>,
	<code class="filename">.obj</code> o algo por el estilo. Estos archivos
	objeto, junto con algo de código de arranque se unens por el
	enlazador(<span class="foreignphrase"><em class="foreignphrase">linker</em></span>) para crear el
	programa ejecutable. Todas las referencias externas se deben
	resolver en la fase de enlazado. En archivos como
	<code class="filename">CLibTest.cpp</code>, se declaran funciones como
	<code class="function">initialize()</code> y <code class="function">fetch()</code>
	(o sea, se le informa al compilador qué forma tienen estas
	funciones), pero no se definen. Están definidas en otro lugar,
	en este caso en el archivo <code class="filename">CLib.cpp</code>. De ese
	modo, las llamadas que se hacen en
	<code class="filename">CLibTest.cpp</code> a estas funciones son
	referencias externas. Cuando se unen los archivos objeto para
	formar el programa ejecutable, el enlazador debe, para cada
	referencia externa no resuelta, encontrar la dirección a la que
	hace referencia y reemplazar cada referencia externa con su
	dirección correspondiente.
      </p>
          <p>
	Es importante señalar que en C, estas referencias externas que
	el enlazador busca son simples nombres de funciones,
	generalmente precedidos por un guión bajo. De esta forma, la
	única tarea del enlazador es hacer corresponder el nombre de la
	función que se llama, con el cuerpo (definición, código) de la
	función del archivo objeto, en el lugar exacto de la llamada a
	dicha función. Si, por ejemplo, accidentalmente hacemos una
	llamada a una función que el compilador interprete como
	<code class="function">func(int)</code> y existe una definición de
	función para <code class="function">func(float)</code> en algún archivo
	objeto, el enlazador verá <code class="function">_func</code> en un lugar
	y <code class="function">_func</code> en otro, por lo que
	<span class="emphasis"><em>pensará</em></span> que todo está bien. En la llamada a
	<code class="function">func()</code> se pasará un <code class="type">int</code> en la
	pila pero el cuerpo de la función <code class="function">func()</code>
	esperará que la pila tenga un <code class="type">float</code>. Si la función
	sólo lee el valor de este dato y no lo escribe, la pila no
	sufrirá datos. De hecho, el supuesto <code class="type">float</code> leído de
	la pila puede tener algo de sentido: la función seguirá
	funcionando aunque sobre basura, y es por eso que los fallos
	originadas por esta clase de errores son muy difíciles de
	encontrar.
      </p>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp5193280" href="#idp5193280" class="para">46</a>] </sup>
          N de T:«Stash» se podría traducir como
          «Acumulador».
        </p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp5222992" href="#idp5222992" class="para">47</a>] </sup>N. de T.: <span class="foreignphrase"><em class="foreignphrase">heap</em></span> se suele
	    traducir al castellano como «montón» o
	    «montículo».
	  </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s13.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s13.html">3.13. Ejercicios</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch04s02.html">4.2. ¿Qué tiene de malo?</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch04s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
