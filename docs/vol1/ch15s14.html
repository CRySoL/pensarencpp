<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>15.14. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C15.html" title="15: Polimorfismo y Funciones virtuales" />
    <link rel="prev" href="ch15s13.html" title="15.13. Resumen" />
    <link rel="next" href="C16.html" title="16: Introducción a las Plantillas" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch15s13.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch15s13.html">15.13. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C15.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C16.html">16: Introducción a las Plantillas</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C16.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="15.14. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp8368080"></a>15.14. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	  Cree una jerarquía simple "figura": una clase base llamada
	  <code class="classname">Figura</code> y una clases derivadas llamadas
	  <code class="classname">Circulo</code>,
	  <code class="classname">Cuadrado</code>, y
	  <code class="classname">Triangulo</code>. En la clase base, hay que
	  hacer una función virtual llamada
	  <code class="function">dibujar()</code>, y sobreescribirla en las
	  clases derivadas. Hacer un array de punteros a objetos
	  <code class="classname">Figura</code> que se creen en el montón (heap)
	  y que obligue a realizar upcasting de los punteros, y llamar a
	  <code class="function">dibujar()</code> a través de la clase base para
	  verificar el comportamiento de las funciones virtuales. Si el
	  depurador lo soporta, intente ver el programa paso a paso.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique el Ejercicio 1 de tal forma que
	  <code class="function">dibujar()</code> sea una función virtual
	  pura. Intente crear un objeto de tipo
	  <code class="classname">Figura</code>. Intente llamar a la función
	  virtual pura dentro del constructor y mire lo que
	  ocurre. Dejándolo como una función virtual pura cree una
	  definición para <code class="function">dibujar()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Aumentando el Ejercicio 2, cree una función que use un objeto
	  <code class="classname">Figura</code> <span class="emphasis"><em>por valor</em></span> e
	  intente hacer un upcast de un objeto derivado como
	  argumento. Vea lo que ocurre. Arregle la función usando una
	  referencia a un objeto <code class="classname">Figura</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">C14:Combined.cpp</code> para que
	  <code class="function">f()</code> sea <code class="keyword">virtual</code> en la
	  clase base. Cambie el <code class="function">main()</code> para que se
	  haga un <span class="foreignphrase"><em class="foreignphrase">upcast</em></span> y una llamada virtual.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Instrument3.cpp</code> añadiendo una
	  función virtual <code class="function">preparar()</code>. Llame a
	  <code class="function">preparar()</code> dentro de
	  <code class="function">tune()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una jerarquía de herencia de
	  <code class="classname">Roedor</code>es: <code class="classname">Raton</code>,
	  <code class="classname">Gerbo</code>, <code class="classname">Hamster</code>,
	  etc. En la clase base, proporcione los métodos que son comunes
	  a todos los roedores, y redefina aquellos en las clases
	  derivadas para que tengan diferentes comportamientos
	  dependiendo del tipo específico de roedor. Cree un array de
	  punteros a <code class="classname">Roedor</code>, rellenelo con distintos
	  tipos de roedores y llame a los métodos de la clase base para
	  ver lo que ocurre.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique el Ejercicio 6 para que use un
	  <code class="literal">vector&lt;Roedor*&gt; </code> en vez de un array
	  de punteros. Asegurese que se hace un limpiado correcto de la
	  memoria.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Empezando con la jerarquía anterior de
	  <code class="classname">Roedor</code>, herede un
	  <code class="classname">HamsterAzul</code> de
	  <code class="classname">Hamster</code> (si, existe algo así, tuve uno
	  cuando era niño), sobreescriba los métodos de la clase base y
	  muestre que el código que llama a los métodos de clase base no
	  necesitan cambiar para adecuarse el nuevo tipo.
	</p>
          </li>
          <li class="listitem">
            <p>
	  A partir de la jerarquía <code class="classname">Roedor</code> anterior,
	  añadaun destructor no virtual, cree un objeto de la
	  <code class="classname">Hamster</code> usando <code class="keyword">new</code>,
	  haga un upcast del puntero a <code class="type">Roedor*</code>, y
	  borre el puntero con <code class="keyword">delete</code> para ver si no
	  se llama a los destructores en la jerarquía. Cambie el
	  destructor a <code class="keyword">virtual</code> y demuestre que el
	  comportamiento es ahora correcto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="classname">Roedor</code> para convertirlo en una
	  clase base pura abstracta.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un sistema de control aéreo con la clase base
	  <code class="classname">Avion</code> y varios tipos derivados. Cree
	  una clase <code class="classname">Torre</code> con un
	  <code class="literal">vector&lt;Avion*&gt; </code> que envie los
	  mensajes adecuados a los distintos aviones que están bajo su
	  control.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un modelo de invernadero heredando varios tipos de
	  <code class="classname">Planta</code>s y construyendo mecanismos en el
	  invernadero que se ocupen de las plantas.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">Early.cpp</code>, haga a
	  <code class="classname">Pet</code> una clase base abstracta pura.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">AddingVirtuals.cpp</code>, haga a todas las
	  funciones miembro de <code class="classname">Pet</code> virtuales
	  puras, pero proporcione una definición para
	  <code class="function">name()</code>. Arregle <code class="classname">Dog</code>
	  como sea necesario, usando la definición de
	  <code class="function">name()</code> que se encuentra en la clase base.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un pequeño programa para mostrar la diferencia entre
	  llamar a una función virtual dentro de una función miembro
	  normal y llamar a una función virtual dentro de un
	  constructor. El programa de probar que las dos llamadas
	  producen diferentes resultados.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">VirtualsInDestructors.cpp</code> por
	  heredando una clase de <code class="classname">Derived</code> y
	  sobreescribiendo <code class="function">f()</code> y el destructor. En
	  <code class="function">main()</code>, cree y haga un upcast de un objeto
	  de su nuevo tipo, después borrelo.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Use el Ejercicio 16 y añada llamadas a <code class="function">f()</code>
	  en cada destructor. Explique que ocurre.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un clase que tenga un dato miembro y una clase derivada
	  que añada otro dato miembro. Escriba una función no miembro
	  que use un objeto de la clase base <span class="emphasis"><em>por
	  valor</em></span> e imprima el tamaño del objeto usando
	  <code class="literal">sizeof</code>. En el <code class="function">main()</code>
	  cree un objeto de la clase derivada, imprima su tamaño, y
	  llame a su función. Explique lo que ocurre.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un ejemplo sencillo de una llamada a una función virtual
	  y genere su salida en ensamblador. Localize el código en
	  ensamblador para la llamada a la función virtual y explique el
	  código.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una clase con una función virtual y una función no
	  virtual. Herede una nueva clase, haga un objeto de esa clase,
	  y un upcast a un puntero del tipo de la clase base. Use la
	  función <code class="function">clock()</code> que se encuentra en
	  <code class="filename">&lt;ctime&gt;</code> (necesitará echar un vistazo
	  a su librerí C) para medir la diferencia entre una llamada
	  virtual y una llamada no virtual. Será necesario realizar
	  multiples llamadas a cada función para poder ver la
	  diferencia.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">C14:Order.cpp </code> añadiendo una
	  función virtual en la clase base de la macro
	  <code class="literal">CLASS</code> (que pinte algo) y haciendo el
	  destructor virtual. Cree objetos de las distintas subclases y
	  hagales un upcast a la clase base. Verifique que el
	  comportamiento virtual funciona y que se realiza de forma
	  correcta la construcción y la destrucción del objeto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una clase con tres funciones virtuales
	  sobrecargadas. Herede una nueva clase y sobreescriba una de
	  las funciones. Cree un objeto de la clase derivada. ¿Se puede
	  llamar a todas las funciones de la clase base a través del
	  objeto derivado? Haga un <span class="foreignphrase"><em class="foreignphrase">upcast</em></span>
	  de la dirección del objeto a la base. ¿Se pueden llamar a las
	  tres funciones a través de la base? Elimine la definición
	  sobreescrita en la clase derivada. Ahora ¿Se puede llamar a
	  todas las funciones de la clase base a través del objeto
	  derivado?.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">VariantReturn.cpp</code> para que
	  muestre que su comportamiento funciona con referencias igual
	  que con punteros.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">Early.cpp</code>, ¿Cómo se le puede indicar
	  al compilador que haga la llamada usando ligadura estática o
	  ligadura dinámica? Determine el caso para su propio
	  compilador.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase base que contenga una función
	  <code class="function">clone()</code> que devuelva un puntero a una
	  <span class="emphasis"><em>copia</em></span> del objeto actual. Derive dos
	  subclases que sobreescriban <code class="function">clone()</code> para
	  devolver copias de sus tipos específicos. En el
	  <code class="function">main()</code>, cree y haga
	  <span class="foreignphrase"><em class="foreignphrase">upcast</em></span> de sus dos tipos
	  derivados, y llame a <code class="function">clone()</code> para cada
	  uno y verifique que las copias clonadas son de los subtipos
	  correctos. Experimente con su función
	  <code class="function">clone()</code> para que se pueda ir al tipo
	  base, y después intente regresar al tipo exacto derivado. ¿Se
	  le ocurre alguna situación en la que sea necesario esta
	  aproximación?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">OStackTest.cpp</code> creando su
	  propia clase, después haga multiple herencia con
	  <code class="classname">Object</code> para crear algo que pueda ser
	  introducido en la pila. Pruebe su clase en el
	  <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Añada un tipo llamado <code class="classname">Tensor</code> a
	  <code class="filename">OperartorPolymorphism.cpp</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Intermedio) Cree una clase base <code class="classname">X</code> sin
	  datos miembro y sin constructor, pero con una función
	  virtual. Cree una <code class="classname">Y</code> que herede de
	  <code class="classname">X</code>, pero sin un constructor
	  explícito. Genere código ensamblador y examinelo para
	  deteriminar si se crea y se llama un constructor de
	  <code class="classname">X</code> y, si eso ocurre, qué código lo
	  hace. Explique lo que haya
	  descubierto. <code class="classname">X</code> no tiene constructor por
	  defecto, entonces ¿por qué no se queja el compilador?
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Intermedio) Modifique el Ejercicio 28 escribiendo
	  constructores para ambas clases de tal forma que cada
	  constructor llame a una función virtual. Genere el código
	  ensamblador. Determine donde se encuentra asignado el VPTR
	  dentro del constructor. ¿El compilador está usando el
	  mecanismo virtual dentro del constructor? Explique por qué se
	  sigue usando la version local de la función.
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Avanzado) Si una función llama a un objeto pasado por valor
	  si ligadura estática, una llamada virtual accede a partes que
	  no existen. ¿Es posible? Escriba un código para forzar una
	  llamada virtual y vea si se produce un cuelgue de la
	  aplicación. Para explicar el comportamiento, observe que
	  ocurre si se pasa un objeto por valor.
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Avanzado) Encuentre exactamente cuanto tiempo más es
	  necesario para una llamada a una función virtual buscando en
	  la información del lenguaje ensamblador de su procesador o
	  cualquier otro manual técnico y encontrando los pulsos de
	  reloj necesarios para una simple llamada frente al número
	  necesario de las instrucciones de las funciones virtuales.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Determine el tamaño del VPTR (usando
	  <code class="literal">sizeof</code>) en su implementación. Ahora herede
	  de dos clases (herencia múltiple) que contengan funciones
	  virtuales. ¿Se tiene una o dos VPTR en la clase derivada?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase con datos miembros y funciones
	  virtuales. Escriba una función que mire en la memoria de un
	  objeto de su clase y que imprima sus distintos
	  fragmentos. Para hacer esto será necesario experimentar y de
	  forma iterativa descubrir donde se encuentra alojado el VPTR
	  del objeto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Imagine que las funciones virtuales no existen, y modifique
	  <code class="filename">Instrument4.cpp</code> para que use
	  <span class="emphasis"><em>moldeado dinámico</em></span> para hacer el
	  equivalente de las llamadas virtuales. Esplique porque es una
	  mala idea.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">StaicHierarchyNavigation.cpp</code>
	  para que en vez de usar el RTTI de C++ use su propio RTTI via
	  una función virtual en la clase base llamada
	  <code class="function">whatAmI()</code> y un <code class="literal">enum type {
	  Circulos, Cuadrados };</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Comience con <code class="filename">PointerToMemberOperator.cpp </code>
	  del capítulo 12 y demuestre que el polimorfismo todavía
	  funciona con punteros a miembros, incluso si
	  <code class="literal">operator-&gt;*</code> está sobrecargado.
	</p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch15s13.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch15s13.html">15.13. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C15.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C16.html">16: Introducción a las Plantillas</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C16.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
