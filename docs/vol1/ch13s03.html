<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>13.3. new y delete para vectores</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C13.html" title="13: Creación dinámica de objetos" />
    <link rel="prev" href="ch13s02s03.html" title="13.2.3. Stash para punteros" />
    <link rel="next" href="ch13s03s02.html" title="13.3.2. Cuando se supera el espacio de almacenamiento" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch13s02s03.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch13s02s03.html">13.2.3. Stash para punteros</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C13.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch13s03s02.html">13.3.2. Cuando se supera el espacio de almacenamiento</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch13s03s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="13.3. new y delete para vectores">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp7632832"></a>13.3. 
      <code class="keyword">new</code> y <code class="keyword">delete</code> para vectores
    </h2>
          </div>
        </div>
      </div>
      <p>
      En C++ es igual de fácil crear vectores de objetos en la pila o en el montículo, con
      la certeza de que se producirá la llamada al constructor para cada uno de los
      objetos del vector. Hay una restricción: debe existir un constructor por defecto, o
      sea, sin argumentos, que será invocado para cada objeto.
    </p>
      <p>
      Cuando se crean vectores de objetos dinámicamente, usando <code class="keyword">new</code>, hay otras
      cosas que hay que tener en cuenta. Como ejemplo de este tipo de vectores véase
    </p>
      <pre class="programlisting">
MyType<span class="hl opt">*</span> fp <span class="hl opt">=</span> <span class="hl kwa">new</span> MyType<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
</pre>
      <p>
      Esta sentencia asigna espacio suficiente en el montículo para 100 objetos
      <code class="classname">MyType</code> y llama al constructor para cada uno de ellos. Lo que
      se ha obtenido es simplemente un <code class="type">MyType*</code>, exactamente lo mismo que
      hubiera obtenido de esta otra forma, que crea un único objeto:
    </p>
      <pre class="programlisting">
MyType<span class="hl opt">*</span> fp2 <span class="hl opt">=</span> <span class="hl kwa">new</span> MyType<span class="hl opt">;</span>
</pre>
      <p>
      El escritor del programa sabe que <code class="varname">fp</code> es la dirección del primer
      elemento de un vector, por lo que tiene sentido seleccionar elementos del mismo
      mediante una expresión como <code class="code">fp[3]</code>, pero ¿qué pasa cuando
      destruimos el vector?. Las sentencias
    </p>
      <pre class="programlisting">
<span class="hl kwa">delete</span> fp2<span class="hl opt">;</span>  <span class="hl slc">// Correcta</span>
	<span class="hl kwa">delete</span> fp<span class="hl opt">;</span>   <span class="hl slc">// Ésta no tendrá el efecto deseado</span>
</pre>
      <p>
      parecen iguales, y sus efectos serán los mismos. Se llamará al destructor del objeto
      <code class="classname">MyType</code> al que apunta el puntero dado y después se liberará el
      bloque asignado. Esto es correcto para <code class="varname">fp2</code>, pero no lo es para
      <code class="varname">fp</code>, significa que los destructores de los 99 elementos restantes
      del vector no se invocarán. Sin embargo, sí se liberará toda la memoria asignada al
      vector, ya que fue obtenida como un único gran bloque cuyo tamaño quedó anotado en
      alguna parte por las rutinas de asignación.
    </p>
      <p>
      Esto se soluciona indicando al compilador que el puntero que pasamos es la dirección
      de inicio de un vector, usando la siguiente sintaxis:
    </p>
      <pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[]</span> fp<span class="hl opt">;</span>
</pre>
      <p>
      Los corchetes indican al compilador la necesidad de generar el código para obtener
      el número de objetos en el vector, que fue guardado en alguna parte cuando se creó,
      y llamar al destructor para cada uno de dichos elementos. Esta es una mejora sobre
      la sintaxis primitiva, que puede verse ocasionalmente en el código de viejos
      programas:
    </p>
      <pre class="programlisting">
<span class="hl kwa">delete</span> <span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">]</span> fp<span class="hl opt">;</span>
</pre>
      <p>
      que forzaba al programador a incluir el número de objetos contenidos en el vector,
      introduciendo con ello una posible fuente de errores. El esfuerzo adicional que
      supone para el compilador tener en esto en cuenta es pequeño, y por eso se consideró
      preferible especificar el número de objetos en un lugar y no en dos.
    </p>
      <div class="sect2" title="13.3.1. Cómo hacer que un puntero sea más parecido a un vector">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="idp7644544"></a>13.3.1. Cómo hacer que un puntero sea más parecido a un vector</h3>
            </div>
          </div>
        </div>
        <p>
		Como defecto colateral, existe la posibilidad de modificar el puntero
		<code class="varname">fp</code> anteriormente definido, para que apunte a cualquier otra
		cosa, lo que no es consistente con el hecho de ser la dirección de inicio de un
		vector. Tiene más sentido definirlo como una constante, de modo que cualquier
		intento de modificación sea señalado como un error. Para conseguir este efecto se
		podría probar con:
      </p>
        <pre class="programlisting">
<span class="hl kwb">int const</span><span class="hl opt">*</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre>
        <p>
	o bien:
      </p>
        <pre class="programlisting">
<span class="hl kwb">const int</span><span class="hl opt">*</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre>
        <p>
		pero en ambos casos el especificador <code class="keyword">const</code> quedaría asociado al
		<code class="type">int</code>, es decir, al valor al que apunta, en lugar de al puntero en
		sí. Si se quiere conseguir el efecto deseado, en lugar de las anteriores, se debe
		poner:
      </p>
        <pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> <span class="hl kwb">const</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre>
        <p>
		Ahora es posible modificar el valor de los elementos del vector, siendo ilegal
		cualquier intento posterior de modificar <code class="varname">q</code>, como
		<code class="literal">q++</code> por ejemplo, al igual que ocurre con el identificador de un
		vector ordinario.
	  </p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch13s02s03.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch13s02s03.html">13.2.3. Stash para punteros</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C13.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch13s03s02.html">13.3.2. Cuando se supera el espacio de almacenamiento</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch13s03s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
