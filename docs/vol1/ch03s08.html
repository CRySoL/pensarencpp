<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>3.8. Creación de tipos compuestos</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C03.html" title="3: C en C++" />
    <link rel="prev" href="ch03s07s15.html" title="3.7.15. Operadores explícitos" />
    <link rel="next" href="ch03s08s02.html" title="3.8.2. Usar struct para combinar variables" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s07s15.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s07s15.html">3.7.15. Operadores explícitos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C03.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s08s02.html">3.8.2. 
        Usar <code class="keyword">struct</code> para combinar variables
      </a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s08s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="3.8. Creación de tipos compuestos">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp4804488"></a>3.8. Creación de tipos compuestos</h2>
          </div>
        </div>
      </div>
      <p>
      Los tipos de datos fundamentales y sus variantes son esenciales,
      pero más bien primitivos. C y C++ incorporan herramientas que
      permiten construir tipos de datos más sofisticados a partir de los
      tipos de datos fundamentales. Como se verá, el más importante de
      estos es <code class="keyword">struct</code>, que es el fundamento para las
      <code class="keyword">class</code> en C++.  Sin embargo, la manera más simple de crear
      tipos más sofisticados es simplemente poniendo un alias a otro nombre
      mediante <code class="keyword">typedef</code>.
    </p>
      <div class="sect2" title="3.8.1. Creación de alias usando typedef">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="idp4807328"></a>3.8.1. Creación de alias usando <code class="keyword">typedef</code></h3>
            </div>
          </div>
        </div>
        <p>
        Esta palabra reservada promete más de lo que da:
        <code class="keyword">typedef</code> sugiere «definición de tipo»
        cuando «alias» habría sido probablemente una
        descripción más acertada, ya que eso es lo que hace
        realmente. La sintaxis es:
      </p>
        <p>
	<code class="keyword">typede</code>f descripción-de-tipo-existente nombre-alias
      </p>
        <p>
	La gente a menudo utiliza <code class="keyword">typedef</code> cuando los tipos de
	datos se vuelven complicados, simplemente para evitar escribir
	más de lo necesario. A continuación, una forma común de utilizar
	typedef:
      </p>
        <pre class="programlisting">
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned long</span> ulong<span class="hl opt">;</span>
</pre>
        <p>
        Ahora si pone <code class="type">ulong</code>, el compilador sabe que se está
        refiriendo a <code class="type">unsigned long</code>. Puede pensar que esto
        se puede lograr fácilmente utilizando sustitución en el
        preprocesador, pero hay situaciones en las cuales el compilador
        debe estar advertido de que está tratando un nombre como si
        fuese un tipo, y por eso <code class="keyword">typedef</code> es esencial.
      </p>
        <pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> x<span class="hl opt">,</span> y<span class="hl opt">;</span>
</pre>
        <p>
	Esto genera en realidad un <code class="type">int*</code> que es
	<code class="varname">x</code>, y un <code class="type">int</code> (no un
	<code class="type">int*</code>) que es <code class="varname">y</code>. Esto significa
	que el <span class="token">*</span> añade a la derecha, no a la
	izquierda. Pero, si utiliza un <code class="keyword">typedef</code>:
      </p>
        <pre class="programlisting">
<span class="hl kwc">typedef</span> <span class="hl kwb">int</span><span class="hl opt">*</span> IntPtr<span class="hl opt">;</span>
IntPtr x<span class="hl opt">,</span> y<span class="hl opt">;</span>
</pre>
        <p>
        Entonces ambos, <code class="varname">x</code> e <code class="varname">y</code> son
        del tipo <code class="type">int*</code>.
      </p>
        <p>
        Se puede discutir sobre ello y decir que es más explícito y por
        consiguiente mas legible evitar <code class="keyword">typedef</code>s para los tipos
        primitivos, y de hecho los programas se vuelven difíciles de
        leer cuando se utilizan demasiados <code class="keyword">typedef</code>s. De todos
        modos, los <code class="keyword">typedef</code>s se vuelven especialmente
        importantes en C cuando se utilizan con <code class="keyword">struct</code>.
      </p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s07s15.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s07s15.html">3.7.15. Operadores explícitos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C03.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s08s02.html">3.8.2. 
        Usar <code class="keyword">struct</code> para combinar variables
      </a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s08s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
