<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>4.10. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C04.html" title="4: Abstracción de Datos" />
    <link rel="prev" href="ch04s09.html" title="4.9. Resumen" />
    <link rel="next" href="C05.html" title="5: Ocultar la implementación" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch04s09.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch04s09.html">4.9. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C04.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C05.html">5: Ocultar la implementación</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C05.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="4.10. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp5494960"></a>4.10. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	  En la librería C estándar, la función
	  <code class="function">puts()</code> imprime un array de caracteres a
	  la consola (de modo que puede escribir
	  <code class="code">puts("Hola")</code>). Escriba un program C que use
	  <code class="function">puts()</code> pero que no incluya
	  <code class="filename">&lt;stdio.h&gt;</code> o de lo contrario declare
	  la función. Compile ese programa con su compilador de
	  C. (algunos compiladores de C++ no son programas distintos
	  de sus compiladores de C, es ese caso puede que necesite
	  averiguar que opción de línea de comando fuerza una
	  compilación C.)  Ahora compílelo con el compilador C++ y
	  preste atención a la diferencia.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una declaración de <code class="keyword">struct</code> con un único
	  método, entonces cree una definición para ese método. Cree un
	  objeto de su nuevo tipo de dato, e invoque el método.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cambie su solución al Ejercicio 2 para que la
	  <code class="keyword">struct</code> sea declarada en un fichero de
	  cabecera convenientemente «guardado», con la
	  definición en un fichero <code class="filename">cpp</code> y el
	  <code class="function">main()</code> en otro.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una <code class="keyword">struct</code> con un único atributo de
	  tipo entero, y dos funciones globales, cada una de las cuales
	  acepta un puntero a ese <code class="keyword">struct</code>. La primera
	  función tiene un segundo argumento de tipo entero y asigna
	  al entero de l  <code class="keyword">struct</code> el valor del
	  argumento, la segunda muestra el entero de la
	  <code class="keyword">struct</code>. Prueba las funciones.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repita el Ejercicio 4 pero mueva las función de modo que sean
	  métodos de la <code class="keyword">struct</code>, y pruebe de nuevo.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que (de forma redundante) efectúe la
	  selección de atributos y una llamada a método usando la
	  palabra reservada <code class="keyword">this</code> (que indica a la dirección
	  del objeto actual)
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una <code class="classname">Stach</code> que mantenga
	  <code class="type">doubles</code>. Rellénela con 25 valores
	  <code class="type">double</code>, después muéstrelos en consola.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repita el Ejercicio 7 con <code class="classname">Stack</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un fichero que contenga una función
	  <code class="function">f()</code> que acepte un argumento entero y lo
	  imprima en consola usando la función
	  <code class="function">printf()</code> de
	  <code class="filename">&lt;stdio&gt;</code> escribiendo:
	  <code class="code">printf("%d\n", i)</code> donde <code class="varname">i</code> es
	  el entero que desea imprimir. Cree un fichero separado que
	  contenga <code class="function">main()</code>, y este fichero declare
	  <code class="function">f()</code> pero aceptando un argumento
	  <code class="type">float</code>. Invoque <code class="function">f()</code> desde
	  <code class="function">main()</code>. Intente compilar y enlazar el
	  programa con el compilador C++ y vea qué ocurre. Ahora
	  compile y enlace el programa usando el compilador C, y vea
	  que ocurre cuando se ejecuta. Explique el comportamiento.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Averigüe cómo generar lenguaje ensamblador con su compilador C
	  y C++. Escriba una función en C y una
	  <code class="keyword">struct</code> con un único miembro en C++. Genere
	  la salida en lenguaje ensamblador para cada una de ellas y
	  encuentre los nombres de ambas funciones, de modo que pueda
	  ver qué tipo de «decoración» aplica el compilador
	  a dichos nombres.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa con código condicionalmente-compilado en
	  <code class="function">main()</code>, para que cuando se defina un
	  valor del preprocesador, se muestre un mensaje, pero cuando no
	  se defina, se imprima otra mensaje distinto. Compile este
	  experimentando con un <code class="keyword">#define</code> en el
	  programa, después averigüe la forma de indicar al compilador
	  definiciones de preprocesador en la línea de comandos y
	  experimente con ello.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa que use <code class="function">assert()</code> con
	  un argumento que siempre sea falso (cero) y vea que ocurre
	  cuando lo ejecuta. Ahora compílelo con <code class="code">#define
	  NDEBUG</code> y ejecútelo de nuevo para ver la
	  diferencia.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un tipo abstracto de dato que represente un cinta de
	  vídeo en una tienda de alquiler. Considere todos los datos y
	  operaciones que serían necesarias para que el tipo
	  <code class="classname">Video</code> funcione con el sistema de
	  gestión de la tienda. Incluya un método
	  <code class="methodname">print()</code> que muestre información sobre
	  el <code class="classname">Video</code>
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un objeto <code class="classname">Pila</code> que almacene
	  objetos <code class="classname">Video</code> del Ejercicio 13. Cree
	  varios objetos <code class="classname">Video</code>, guárdelos en la
	  <code class="classname">Stack</code> y entonces muéstrelos usando
	  <code class="methodname">Video::print()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa que muestre todos los tamaños de los tipos
	  de datos fundamentales de su computadora usando
	  <code class="literal">sizeof</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="classname">Stash</code> para usar
	  <code class="code">vector&lt;char&gt;</code> como
	  estructura de datos subyacente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree dinámicamente espacio de almacenamiento para los
	  siguiente tipos usando <code class="keyword">new</code>:
	  <code class="type">int</code>, <code class="type">long</code>, un array de 100
	  <code class="type">char</code>, un array de 100 <code class="type">float</code>. Muestre
	  sus direcciones y libérelos usando <code class="keyword">delete</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una función que tome un argumento
	  <code class="type">char*</code>. Usando <code class="keyword">new</code>, pida
	  alojamiento dinámico para un array de <code class="type">char</code> con un
	  tamaño igual al argumento pasado a la función. Usando
	  indexación de array, copie los caracteres del argumento al
	  array dinámico (no olvide el terminador nulo) y devuelva el
	  puntero a la copia. En su <code class="function">main()</code>, pruebe
	  la función pasando una cadena estática entre comillas, después
	  tome el resultado y páselo de nuevo a la función. Muestre
	  ambas cadenas y punteros para poder ver que tienen distinta
	  ubicación. Mediante <code class="keyword">delete</code> libere todo el
	  almacenamiento dinámico.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Haga un ejemplo de estructura declarada con otra estructura
	  dentro (un estructura anidada). Declare atributos en ambas
	  <code class="keyword">structs</code>, y declare y defina métodos en
	  ambas <code class="keyword">structs</code>. Escriba un
	  <code class="function">main()</code> que pruebe los nuevos tipos.
	</p>
          </li>
          <li class="listitem">
            <p>
	  ¿Cómo de grande es una estructura? Escriba un trozo de código
	  que muestre el tamaño de varias estructuras. Cree estructuras
	  que tengan sólo atributos y otras que tengan atributos y
	  métodos. Después cree una estructura que no tenga ningún
	  miembro. Muestre los tamaños de todas ellas. Explique el
	  motivo del tamaño de la estructura que no tiene ningún
	  miembro.
	</p>
          </li>
          <li class="listitem">
            <p>
	  C++ crea automáticamente el equivalente de <code class="keyword">typedef</code>
	  para <code class="keyword">structs</code>, tal como ha visto en este
	  capítulo. También lo hace para las enumeraciones y las
	  uniones. Escriba un pequeño programa que lo demuestre.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una <code class="classname">Stack</code> que maneje
	  <code class="classname">Stash</code>es. Cada
	  <code class="classname">Stash</code> mantendrá cinco líneas
	  procedentes de un fichero. Cree las
	  <code class="classname">Stash</code> usando
	  <code class="keyword">new</code>. Lea un fichero en su
	  <code class="classname">Stack</code>, después muéstrelo en su forma
	  original extrayéndolo de la <code class="classname">Stack</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique el Ejercicio 22 de modo que cree una estructura que
	  encapsule la <code class="classname">Stack</code> y las
	  <code class="classname">Stash</code>. El usuario sólo debería añadir y
	  pedir líneas a través de sus métodos, pero debajo de la
	  cubierta la estructura usa una
	  <code class="classname">Stack</code>(pila) de
	  <code class="classname">Stash</code>es.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una <code class="keyword">struct</code> que mantenga un
	  <code class="type">int</code> y un puntero a otra instancia de la misma
	  <code class="keyword">struct</code>. Escriba una función que acepte como
	  parámetro la dirección de una de estas
	  <code class="keyword">struct</code> y un <code class="type">int</code> indicando la
	  longitud de la lista que se desea crear. Esta función creará
	  una cadena completa de estas <code class="keyword">struct</code> (una
	  lista enlazada), empezando por el argumento (la cabeza de la
	  lista), con cada una apuntando a la siguiente. Cree las nuevas
	  <code class="keyword">struct</code> usando <code class="keyword">new</code>, y
	  ponga la posición (que número de objeto es) en el
	  <code class="type">int</code>. En la última <code class="keyword">struct</code> de la
	  lista, ponga un valor cero en el puntero para indicar que es
	  el último. Escriba una segunda función que acepte la cabeza de
	  la lista y la recorra hasta el final, mostrando los valores
	  del puntero y del <code class="type">int</code> para cada una.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repita el ejercicio 24, pero poniendo las funciones dentro de
	  una <code class="keyword">struct</code> en lugar de usar <code class="keyword">struct</code> y
	  funciones «crudas».
	</p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch04s09.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch04s09.html">4.9. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C04.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C05.html">5: Ocultar la implementación</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C05.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
