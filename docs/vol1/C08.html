<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>8: Constantes</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="prev" href="ch07s07.html" title="7.7. Ejercicios" />
    <link rel="next" href="ch08s02.html" title="8.2. Punteros" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch07s07.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch07s07.html">7.7. Ejercicios</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch08s02.html">8.2. Punteros</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch08s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="chapter" title="8: Constantes">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="C08"></a>8: Constantes</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <strong>Tabla de contenidos</strong>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="C08.html#idp6012592">8.1. Sustitución de valores</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch08s02.html">8.2. Punteros</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch08s03.html">8.3. Argumentos de funciones y valores de retorno</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch08s04.html">8.4. Clases</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch08s05.html">8.5. Volatile</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch08s06.html">8.6. Resumen</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch08s07.html">8.7. Ejercicios</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="highlights">
        <p>
      El concepto de constante (expresión con la palabra reservada
      <code class="keyword">const</code>) se creó para permitir a los programadores marcar
      la diferencia entre lo que puede cambiar y lo que no. Esto
      facilita el control y la seguridad en un proyecto de
      programación.
    </p>
      </div>
      <p>
    Desde su origen, <code class="keyword">const</code> ha sido utilizada para diferentes
    propósitos. Mientras tanto FIXME:it trickled back en el lenguaje C
    en el que su significado cambió. Todo esto puede parecer un poco
    confuso al principio, y en este capítulo aprenderá cuándo, porqué
    y cómo usar la palabra reservada <code class="keyword">const</code>. Hacia el final se
    expone una disertación sobre <span class="emphasis"><em>volatile</em></span>, que es
    familia de <code class="keyword">const</code> (ambos se refieren a los cambios) y su
    sintaxis es idéntica.
  </p>
      <p>
    El primer motivo para la creación de <code class="keyword">const</code> parece que fue
    eliminar el uso de la directiva del preprocesador <code class="keyword">#define</code>
    para sustitución de valores. Desde entonces se usa para punteros,
    argumentos de funciones, tipos de retorno, objetos y funciones
    miembro. Todos ellos tienen pequeñas diferencias pero su
    significado es conceptualmente compatible. Se tratarán en las siguientes
    secciones de este capítulo.
  </p>
      <div class="sect1" title="8.1. Sustitución de valores">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="idp6012592"></a>8.1. Sustitución de valores</h2>
            </div>
          </div>
        </div>
        <p>
      Cuando se programa en C, se usa libremente el preprocesador para
      crear macros y sustituir valores. El preprocesador simplemente
      hace un reemplazo textual y no realiza ninguna comprobación de
      tipo. Por ello, la sustitución de valores introduce pequeños
      problemas que se pueden evitar usando valores constantes.
    </p>
        <p>
      El uso más frecuente del preprocesador es la sustitución de
      valores por nombres, en C es algo como:
    </p>
        <pre class="programlisting">
<span class="hl ppc">#define BUFSIZE 100</span>
</pre>
        <p>
      <code class="varname">BUFSIZE</code> es un nombre que sólo existe durante
      el preprocesado. Por tanto, no ocupa memoria y se puede colocar
      en un fichero de cabecera para ofrecer un valor único a todas
      las unidades que lo utilicen. Es muy importante para el
      mantenimiento del código el uso de sustitución de valores en
      lugar de los también llamados «números mágicos». Si
      usa números mágicos en su código. no solamente impedirá al
      lector conocer su procedencia o significado si no que complicará
      innecesariamente la edición del código si necesita cambiar
      dicho valor.
    </p>
        <p>
      La mayor parte del tiempo, <code class="varname">BUFSIZE</code> se
      comportará como un valor ordinario, pero no siempre. No tiene
      información de tipo. Eso puede esconder errores difíciles de
      localizar. C++ utiliza <code class="keyword">const</code> para eliminar estos
      problemas llevando la sustitución de valores al terreno del
      compilador. Ahora, puede escribir:
    </p>
        <pre class="programlisting">
<span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
</pre>
        <p>
      Puede colocar <code class="varname">bufsize</code> en cualquier lugar
      donde se necesite conocer el valor en tiempo de compilación. El
      compilador utiliza <code class="varname">bufsize</code> para hacer
      <span class="emphasis"><em>propagación de constantes</em></span><sup>[<a id="idp6019416" href="#ftn.idp6019416" class="footnote">61</a>]</sup>, que significa que el
      compilador reduce una expresión constante complicada a un valor
      simple realizando los cálculos necesarios en tiempo de
      compilación. Esto es especialmente importante en las
      definiciones de vectores:
    </p>
        <pre class="programlisting">
<span class="hl kwb">char</span> buf<span class="hl opt">[</span>bufsize<span class="hl opt">];</span>
</pre>
        <p>
      Puede usar <code class="keyword">const</code> con todos los tipos
      básicos(<code class="type">char</code>, <code class="type">int</code>, <code class="type">float</code>
      y <code class="type">double</code>) y sus variantes (así como clases y todo
      lo que verá después en este capítulo). Debido a los problemas
      que introduce el preprocesador deberá utilizar siempre
      <code class="keyword">const</code> en lugar de <code class="keyword">#define</code> para la sustitución
      de valores.
    </p>
        <div class="sect2" title="8.1.1. const en archivos de cabecera">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp6023976"></a>8.1.1. <code class="keyword">const</code> en archivos de cabecera</h3>
              </div>
            </div>
          </div>
          <p>
	Para poder usar <code class="keyword">const</code> en lugar de <code class="keyword">#define</code>,
	debe ser posible colocar las definiciones <code class="keyword">const</code> en
	los archivos de cabecera como se hacía con los
	<code class="keyword">#define</code>.  De este modo, puede colocar la definición
	de una constante en un único lugar y distribuirla incluyendo
	el archivo de cabecera en las unidades del programa que la
	necesiten.  Una constante en C++ utiliza <span class="emphasis"><em>enlazado
	interno</em></span>, es decir, es visible sólo desde el archivo
	donde se define y no puede verse en tiempo de enlazado por
	otros módulos. Deberá asignar siempre un valor a las
	constantes cuando las defina, excepto cuando explícitamente
	use la declaración <code class="keyword">extern</code>:
      </p>
          <pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> bufsize<span class="hl opt">;</span>
</pre>
          <p>
	Normalmente el compilador de C++ evita la asignación de
	memoria para las constantes, pero en su lugar ocupa una
	entrada en la tabla de símbolos.  Cuando se utiliza
	<code class="keyword">extern</code> con una constante, se fuerza el alojamiento en
	memoria (esto también ocurre en otros casos, como cuando se
	solicita la dirección de una constante). El uso de la memoria
	debe hacerse porque <code class="keyword">extern</code> dice «usa enlazado
	externo», es decir, que varios módulos deben ser
	capaces de hacer referencia al elemento, algo que requiere su
	almacenamiento en memoria.
      </p>
          <p>
	Por lo general, cuando <code class="keyword">extern</code> no forma parte de
	la definición, no se pide memoria. Cuando la constante se utiliza
	simplemente se incorpora en tiempo de compilación.
      </p>
          <p>
	El objetivo de no almacenar en memoria las constantes tampoco
	se cumple con estructuras complicadas. Cuando el compilador se
	ve obligado a pedir memoria no puede realizar
	<span class="emphasis"><em>propagación de constantes</em></span> (ya que el
	compilador no tiene forma de conocer con seguridad que valor
	debe almacenar; si lo conociese, no necesitaría pedir
	memoria).
      </p>
          <p>
	Como el compilador no siempre puede impedir el almacenamiento
	para una constante, las definiciones de constantes utilizan
	enlace interno, es decir, se enlazan sólo con el módulo en que
	se definen. En caso contrario, los errores de enlace podrían
	ocurrir con las expresiones constantes complicadas ya que
	causarían petición de almacenamiento en diferentes
	módulos. Entonces, el enlazador vería la misma definición en
	múltiples archivos objeto, lo que causaría un error en el
	enlace. Como las constantes utilizan enlace interno, el
	enlazador no intenta enlazar esas definiciones a través de los
	módulos, y así no hay colisiones.  Con los tipos básicos, que
	son los se ven involucrados en la mayoría de los casos, el
	compilador siempre realiza propagación de constantes.
      </p>
        </div>
        <div class="sect2" title="8.1.2. constantes seguras">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp6034680"></a>8.1.2. constantes seguras</h3>
              </div>
            </div>
          </div>
          <p>
        El uso de las constantes no está limitado a la sustitución de
        los <code class="keyword">#define</code> por expresiones constantes. Si inicializa
        una variable con un valor que se produce en tiempo de ejecución
        y sabe que no cambiará durante la
	 vida de la variable, es una buena práctica
        de programación hacerla constante para que de ese modo el
        compilador produzca un mensaje de error si accidentalmente
        alguien intenta modificar dicha variable. Aquí hay un ejemplo:
      </p>
          <div class="example">
            <a id="idp6036704"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C08:Safecons.cpp</span>
<span class="hl slc">// Using const for safety</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">const int</span> i <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>  <span class="hl slc">// Typical constant</span>
<span class="hl kwb">const int</span> j <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">;</span> <span class="hl slc">// Value from const expr</span>
<span class="hl kwb">long</span> address <span class="hl opt">= (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>j<span class="hl opt">;</span> <span class="hl slc">// Forces storage</span>
<span class="hl kwb">char</span> buf<span class="hl opt">[</span>j <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">];</span> <span class="hl slc">// Still a const expression</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type a character &amp; CR:&quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">const char</span> c <span class="hl opt">=</span> cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span> <span class="hl slc">// Can't change</span>
  <span class="hl kwb">const char</span> c2 <span class="hl opt">=</span> c <span class="hl opt">+</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> c2<span class="hl opt">;</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 8.1. C08/Safecons.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
        Puede ver que <code class="constant">i</code> es una constante en
        tiempo de compilación, pero <code class="constant">j</code> se calcula
        a partir de <code class="constant">i</code>. Sin embargo, como
        <code class="constant">i</code> es una constante, el valor calculado
        para <code class="constant">j</code> es una expresión constante y es en
        si mismo otra constante en tiempo de compilación. En la
        siguiente línea se necesita la dirección de
        <code class="constant">j</code> y por lo tanto el compilador se ve
        obligado a pedir almacenamiento para
        <code class="constant">j</code>. Ni siquiera eso impide el uso de
        <code class="constant">j</code> para determinar el tamaño de
        <code class="varname">buf</code> porque el compilador sabe que
        <code class="constant">j</code> es una constante y que su valor es
        válido aunque se asigne almacenamiento, ya que eso se hace
        para mantener el valor en algún punto en el programa.
      </p>
          <p>
        En <code class="function">main()</code>, aparece un tipo diferente de
        constante en el identificador <code class="constant">c</code>, porque el
        valor no puede ser conocido en tiempo de compilación. Eso
        significa que se requiere almacenamiento, y por eso el
        compilador no intenta mantener nada en la tabla de símbolos (el
        mismo comportamiento que en C). La inicialización debe ocurrir,
        aún así, en el punto de la definición, y una vez que ocurre la
        inicialización, el valor ya no puede ser cambiado. Puede ver que
        <code class="constant">c2</code> se calcula a partir de
        <code class="constant">c</code> y además las reglas de ámbito funcionan
        para las constantes igual que para cualquier otro tipo, otra
        ventaja respecto al uso de <code class="keyword">#define</code>.
      </p>
          <p>
	En la práctica, si piensa que una variable no debería cambiar,
	debería hacer que fuese una constante. Esto no sólo da seguridad
	contra cambios inadvertidos, también permite al compilador
	generar código más eficiente ahorrando espacio de almacenamiento
	y lecturas de memoria en la ejecución del programa.
      </p>
        </div>
        <div class="sect2" title="8.1.3. Vectores">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp6045240"></a>8.1.3. Vectores</h3>
              </div>
            </div>
          </div>
          <p>
	Es posible usar constantes para los vectores, pero
	prácticamente está dando por hecho que el compilador no será
	lo suficientemente sofisticado para mantener un vector en la
	tabla de símbolos, así que le asignará espacio de
	almacenamiento. En estas situaciones, <code class="keyword">const</code> significa
	«un conjunto de datos en memoria que no pueden
	modificarse». En cualquier caso, sus valores no puede
	usarse en tiempo de compilación porque el compilador no conoce
	en ese momento los contenidos de las variables que tienen
	espacio asignado. En el código siguiente puede ver algunas
	declaraciones incorrectas.
      </p>
          <div class="example">
            <a id="idp6047608"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C08:Constag.cpp</span>
<span class="hl slc">// Constants and aggregates</span>
<span class="hl kwb">const int</span> i<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">};</span>
<span class="hl slc">//! float f[i[3]]; // Illegal</span>
<span class="hl kwb">struct</span> S <span class="hl opt">{</span> <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">; };</span>
<span class="hl kwb">const</span> S s<span class="hl opt">[] = { {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span> <span class="hl opt">}, {</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">} };</span>
<span class="hl slc">//! double d[s[1].j]; // Illegal</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 8.2. C08/Constag.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	En la definición de un vector, el compilador debe ser capaz de
	generar código que mueva el puntero de pila para dar cabida al
	vector. En las definiciones incorrectas anteriores, el
	compilador se queja porque no puede encontrar una expresión
	constante en la definición del tamaño del vector.
      </p>
        </div>
        <div class="sect2" title="8.1.4. Diferencias con C">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp6049608"></a>8.1.4. Diferencias con C</h3>
              </div>
            </div>
          </div>
          <p>
	Las constantes se introdujeron en las primeras versiones de
	C++ mientras la especificación del estándar C estaba siendo
	terminada. Aunque el comité a cargo de C decidió entonces
	incluir <code class="keyword">const</code> en C, por alguna razón, vino
	a significar para ellos «una variable ordinaria que no
	puede cambiarse». En C, una constante siempre ocupa
	espacio de almacenamiento y su ámbito es global. El compilador
	C no puede tratar <code class="keyword">const</code> como una constante
	en tiempo de compilación. En C, si escribe:
      </p>
          <pre class="programlisting">
<span class="hl kwb">const int</span> bufsize <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
<span class="hl kwb">char</span> buf<span class="hl opt">[</span>bufsize<span class="hl opt">];</span>
</pre>
          <p>
	aparecerá un error, aunque parezca algo
	razonable. <code class="constant">bufsize</code> está guardado en algún
	sitio y el compilador no conoce su valor en tiempo de
	compilación. Opcionalmente puede escribir:
      </p>
          <pre class="programlisting">
<span class="hl kwb">const int</span> bufsize<span class="hl opt">;</span>
</pre>
          <p>
	en C, pero no en C++, y el compilador C lo acepta como una
	declaración que indica que se almacenará en alguna parte. Como
	C utiliza enlace externo para las constantes, esa semántica
	tiene sentido. C++ utiliza normalmente enlace interno, así
	que, si quiere hacer lo mismo en C++, debe indicar
	expresamente que se use enlace externo usando <code class="keyword">extern</code>.
      </p>
          <pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> bufsize<span class="hl opt">;</span>  <span class="hl slc">// es declaración, no definición</span>
</pre>
          <p>
        Esta declaración también es válida en C.
      </p>
          <p>
        En C++, <code class="keyword">const</code> no implica necesariamente
        almacenamiento. En C, las constantes siempre necesitan
        almacenamiento. El hecho de que se necesite almacenamiento o no
        depende de cómo se use la constante. En general, si una
        constante se usa simplemente para reemplazar un número por un
        nombre (como hace <code class="keyword">#define</code>), entonces no requiere
        almacenamiento. Si es así (algo que depende de la complejidad
        del tipo de dato y de lo sofisticación del compilador) los
        valores pueden expandirse en el código para conseguir mayor
        eficiencia después de la comprobación de los tipos, no como con
        <code class="keyword">#define</code>. Si de todas formas, se necesita la dirección
        de una constante (aún desconocida, para pasarla a una función
        como argumento por referencia) o se declara como
        <code class="keyword">extern</code>, entonces se requiere asignar almacenamiento
        para la constante.
      </p>
          <p>
        En C++, una constante que esté definida fuera de todas las
        funciones tiene ámbito de archivo (es decir, es inaccesible
        fuera del archivo). Esto significa que usa enlace
        interno. Esto es diferente para el resto de identificadores en
        C++ (y que las constantes en C) que utilizan siempre enlace
        externo. Por eso, si declara una constante con el mismo nombre
        en dos archivos diferentes y no toma sus
	
        direcciones ni los define como <code class="keyword">extern</code>, el compilador
        C++ ideal no asignará almacenamiento para la constante,
        simplemente la expandirá en el código. Como las constantes
        tienen implícito el ámbito a su archivo, puede ponerlas en un
        archivo de cabecera de C++ sin que origine conflictos en el
        enlace.
      </p>
          <p>
	Dado que las constante en C++ utilizan por defecto enlace
	interno, no puede definir una constante en un archivo y
	utilizarla desde otro. Para conseguir enlace externo para la
	constante y así poder usarla desde otro archivo, debe
	definirla explícitamente como <code class="keyword">extern</code>, algo
	así:
      </p>
          <pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> x <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>  <span class="hl slc">// definición, no declaración</span>
</pre>
          <p>
	Señalar que dado un identificador, si se dice que es
	<code class="keyword">extern</code>, se fuerza el almacenamiento para la
	constante (aunque el compilador tenga la opción de hacer la
	expansión en ese punto). La inicialización establece que la
	sentencia es una definición, no una declaración. La
	declaración:
      </p>
          <pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">const int</span> x<span class="hl opt">;</span>
</pre>
          <p>
	en C++ significa que la definición existe en algún sitio
	(mientras que en C no tiene porqué ocurrir así). Ahora puede
	ver porqué C++ requiere que las definiciones de constantes
	incluyan la inicialización: la inicialización diferencia una
	declaración de una definición (en C siempre es una definición,
	aunque no esté inicializada). Con una declaración <code class="keyword">const
	extern</code>, el compilador no hace expansión de la constante
	porque no conoce su valor.
      </p>
          <p>
	La aproximación de C a las constantes es poco útil, y si quiere
	usar un valor simbólico en una expresión constante (que deba
	evaluarse en tiempo de compilación) casi está obligado a usar
	<code class="keyword">#define</code>.
      </p>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp6019416" href="#idp6019416" class="para">61</a>] </sup>N. del T.: del inglés <span class="foreignphrase"><em class="foreignphrase">constant
      folding</em></span></p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch07s07.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch07s07.html">7.7. Ejercicios</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch08s02.html">8.2. Punteros</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch08s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
