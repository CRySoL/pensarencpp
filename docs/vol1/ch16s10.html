<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>16.10. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C16.html" title="16: Introducción a las Plantillas" />
    <link rel="prev" href="ch16s09.html" title="16.9. Resumen" />
    <link rel="next" href="ApendiceA.html" title="Apéndice A. Estilo de codificación" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch16s09.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch16s09.html">16.9. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C16.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ApendiceA.html">Apéndice A. Estilo de codificación</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ApendiceA.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="16.10. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp8729808"></a>16.10. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	  Implemente la jerarquía de herencia del diagrama de
	  <code class="classname">OShape </code> de este capítulo.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique el resultado del Ejercicio 1 del capítulo 15 para
	  usar la <code class="classname">Stack </code> y el
	  <code class="classname">iterator </code> en <code class="filename">TStack2.h
	  </code> en vez de un array de punteros a
	  <code class="classname">Shape</code>. Añada destructores a la
	  jerarquía de clases para que se pueda ver que los objetos
	  <code class="classname">Shape </code> han sido destruidos cuando la
	  <code class="classname">Stack </code> se sale del ámbito.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">TPStash.h </code> para que el valor
	  de incremento usado por <code class="function">inflate() </code>
	  pueda ser cambiado durante la vida de un objeto contenedor
	  particular.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">TPStash.h </code> para que el valor de
	  incremento usado por <code class="function">inflate() </code>
	  automáticamente cambie de tamaño para que reduzca el número
	  de veces que debe ser llamado. Por ejemplo, cada vez que se
	  llama podría doblar el valor de incremento para su uso en la
	  siguiente llamada. Demuestre la funcionalidad mostrando cada
	  vez que se llama a <code class="function">inflate()</code>, y escriba
	  código de prueba en <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Convierta en plantilla la función de <code class="function">fibonacci()
	  </code> con los tipos que puede producir (puede generar
	  <code class="type">long</code>, <code class="type">float</code>, etc.  en vez de sólo
	  <code class="type">int</code>).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Usar el <code class="classname">vector </code> de la STL como
	  implementación subyacente, para crear una platilla
	  <code class="classname">Set </code> que acepte solo uno de cada tipo
	  de objeto que se aloje en él. Cree un iterador anidado que
	  soporte el concepto de "marcador final" de este
	  capítulo. Escriba código de prueba para el <code class="classname">Set
	  </code> en el <code class="function">main()</code>, y entonces
	  sustituyalo por la plantilla <code class="classname">set </code> de
	  la STL para comprobar que el comportamiento es correcto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">AutoCounter.h </code> para que pueda
	  ser usado como un objeto miembro dentro de cualquier clase
	  cuya creación y destrucción quiera comprobar. Añada un
	  miembro <code class="type">string </code> para que contenga el
	  nombre de la clase. Compruebe esta herramienta dentro una
	  clase suya.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una versión de <code class="filename">OwnerStack.h </code> que use
	  un <code class="classname">vector </code> de la Librería Estándar de C++
	  como su implementación subyacente.  Será necesario conocer
	  algunas de las funciones miembro de <code class="classname">vector
	  </code> para poder hacerlo (sólo hay que mirar en el
	  archivo cabecera &lt;vector&gt;).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">ValueStack.h </code> para que pueda
	  expandirse dinámicamente según se introduzcan más objetos y
	  se quede sin espacio. Cambie <code class="filename">ValueStackTest.cpp
	  </code> para comprobar su nueva funcionalidad.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repita el ejercicio 9 pero use el <code class="classname">vector
	  </code> de la STL como la implementación interna de
	  <code class="classname">ValueStack</code>. Note lo sencillo que es.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">ValueStackTest.cpp </code> para que
	  use un <code class="classname">vector </code> de la STL en vez de un
	  <code class="classname">Stack </code> en el
	  <code class="function">main()</code>. Dése cuenta del comportamiento
	  en tiempo de ejecución: ¿Se genera un grupo de objetos por
	  defecto cuando se crea el <code class="classname">vector</code>?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">TStack2.h </code> para que use un
	  <code class="classname">vector </code> de la STL.  Asegurese de que no
	  cambia la interfaz, para que <code class="filename">TStack2Test.cpp
	  </code> funcione sin cambiarse.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repita el Ejercicio 12 usando una <code class="classname">stack </code>
	  de la Librería Estándar de C++ en vez de un
	  <code class="classname">vector</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">TPStash2.h </code> para que use un
	  <code class="classname">vector </code> de la STL como su
	  implementación interna. Asegurese que no cambia la interfaz,
	  por lo que <code class="filename">TPStash2Test.cpp </code> funciona
	  sin modificarse.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">IterIntStack.cpp</code>, modifique
	  <code class="classname">IntStackIter </code> para darle un
	  constructor de «marcador final», y añada el
	  <code class="literal">operator== </code> y el <code class="literal">operator!=</code>. En el
	  <code class="function">main()</code>, use un iterador para moverse a
	  través de los elementos del contenedor hasta que se
	  encuentre el marcador.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Use <code class="filename">TStack2.h</code>,
	  <code class="filename">TPSTash2.h</code>, y
	  <code class="filename">Shape.h</code>, instancie los contenedores
	  <code class="classname">PStash </code> y <code class="classname">Stack
	  </code> para que contenga
	  <code class="classname">Shape*</code>, rellene cada uno con punteros
	  a <code class="classname">Shape</code>, entonces use iteradores para
	  moverse a través de cada contenedor y llame a
	  <code class="function">draw() </code> para cada objeto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una plantilla en la clase <code class="type">Int </code> para
	  que pueda alojar cualquier tipo de objetos (Siéntase libre
	  de cambiar el nombre de la clase a algo más apropiado).
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una plantilla de la clase <code class="classname">IntArray
	  </code> en <code class="filename">IostreamOperatorOverloading.cpp
	  </code> del capítulo 12, introduzca en plantilla ambos
	  tipos de objetos que están contenidos y el tamaño del array
	  interno
	</p>
          </li>
          <li class="listitem">
            <p>
	  Convierta <code class="classname">ObjContainer </code> en
	  <code class="filename">NestedSmartPointer.cpp </code> del Capítulo 12
	  en una plantilla. Compruebelo con dos clases diferentes.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">C15:OStack.h </code> y
	  <code class="filename">C15:OStackTest.cpp </code> consiguiendo que
	  <code class="classname">class Stack </code> pueda tener múltiple
	  herencia automáticamente de la clase contenida y de
	  <code class="classname">Object</code>. La <code class="classname">Stack
	  </code> contenida debe aceptar y producir sólo punteros
	  del tipo contenido.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repita el ejercicio 20 usando <code class="classname">vector </code>
	  en vez de <code class="classname">Stack</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Herede una clase <code class="classname">StringVector </code> de
	  <code class="classname">vector&lt;void&gt; </code> y redefina las
	  funciones miembro <code class="function">push_back() </code> y el
	  <code class="literal">operator[] </code> para que acepten y produzcan
	  únicamente <code class="type">string* </code> (y realizen el
	  moldeado adecuado). Ahora creee una plantilla que haga
	  automáticamente lo mismo a una clase contenedora para
	  punteros de cualquier tipo. Esta técnica es a menudo usada
	  para reducir el código producido por muchas instanciaciones
	  de templates.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">TPStash2.h</code>, añada y compruebe un
	  <code class="literal">operator- </code> para
	  <code class="classname">PStash::iterator</code>, siguiendo la lógica
	  de <code class="literal">operator+</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">Drawing.cpp</code>, añada y compruebe una
	  plantilla de función que llame a funciones miembro
	  <code class="function">erase()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Avanzado) Modifique la clase <code class="classname">Stack </code>
	  en <code class="filename">TStack2.h </code> para permitir una
	  granularidad de la propiedad: Añada una bandera para cada
	  enlace indicando si el enlace posee el objeto al que apunta,
	  y de soporte a esta información la función <code class="function">push()
	  </code> y en el destructor. Añada funciones miembro para
	  leer y cambiar la propiedad de cada enlace.
	</p>
          </li>
          <li class="listitem">
            <p>
	  (Avanzado) Modifique <code class="filename">PointerToMemberOperator.cpp
	  </code> del Capítulo 12 para que la
	  <code class="classname">FunctionObject </code> y el <code class="literal">operator-&gt;* </code> sean convertidos en
	  plantillas para que funcionen con cualquier tipo de retorno
	  (para <code class="literal">operator-&gt;*</code>, tendrá
	  que usar <span class="emphasis"><em>plantillas miembro </em></span> descritas
	  en el Volumen 2). Añada soporte y compruebe para cero, uno y
	  dos argumentos en las funciones miembro
	  <code class="classname">Dog</code>.
	</p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch16s09.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch16s09.html">16.9. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C16.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ApendiceA.html">Apéndice A. Estilo de codificación</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ApendiceA.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
