<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>2: Construir y usar objetos</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="prev" href="ch01s13.html" title="1.13. Resumen" />
    <link rel="next" href="ch02s02.html" title="2.2. Herramientas para compilación modular" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch01s13.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch01s13.html">1.13. Resumen</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch02s02.html">2.2. Herramientas para compilación modular</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch02s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="chapter" title="2: Construir y usar objetos">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="C02"></a>2: Construir y usar objetos</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <strong>Tabla de contenidos</strong>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="C02.html#idp3965904">2.1. El proceso de traducción del lenguaje</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s02.html">2.2. Herramientas para compilación modular</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s03.html">2.3. Su primer programa en C++</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s04.html">2.4. Más sobre iostreams</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s05.html">2.5. Introdución a las cadenas</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s06.html">2.6. Lectura y escritura de ficheros</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s07.html">2.7. Introducción a los vectores</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s08.html">2.8. Resumen</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch02s09.html">2.9. Ejercicios</a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="highlights">
        <p>
      Este capítulo presenta la suficiente sintaxis y
      los conceptos de construcción de programas de C++ como para
      permitirle crear y ejecutar algunos programas simples orientados a
      objetos. El siguiente capítulo cubre la sintaxis
      básica de C y C++ en detalle.
    </p>
      </div>
      <p>
    Leyendo primero este capítulo, le cogerá el gustillo a lo que
    supone programar con objetos en C++, y también descubrirá
    algunas de las razones por las que hay tanto entusiasmo
    alrededor de este lenguaje. Debería ser suficiente para
    pasar al <a class="link" href="C03.html" title="3: C en C++">Capítulo 3</a>, que puede ser un poco
    agotador debido a que contiene la mayoría de los detalles del
    lenguaje C.
  </p>
      <p>
    Los tipos de datos definidos por el usuario, o
    <span class="emphasis"><em>clases</em></span> es lo que diferencia a C++ de los
    lenguajes procedimentales tradicionales.  Una clase es un nuevo tipo
    de datos que usted o alguna otra persona crea para resolver un
    problema particular. Una vez que se ha creado una clase, cualquiera
    puede utilizarla sin conocer los detalles de su funcionamiento, o
    incluso de la forma en que se han construído.  Este capítulo trata
    las clases como si sólo fueran otro tipo de datos predefinido
    disponible para su uso en programas.
  </p>
      <p>
    Las clases creadas por terceras personas se suelen empaquetar en
    librerías.  Este capítulo usa algunas de las librerías que vienen en
    todas las implementaciones de C++. Una librería especialmente
    importante es FIXME:iostreams, que le permite (entre otras cosas)
    leer desde ficheros o teclado, y escribir a ficheros o
    pantalla. También verá la clase <code class="classname">string</code>, que
    es muy práctica, y el contenedor <code class="classname">vector</code> de la
    Libreria Estándar de C++. Al final del capítulo, verá lo sencillo
    que resulta utilizar una librería de clases predefinida.
  </p>
      <p>
    Para que pueda crear su primer programa debe conocer primero las
    herramientas utilizadas para construir aplicaciones.
  </p>
      <div class="sect1" title="2.1. El proceso de traducción del lenguaje">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="idp3965904"></a>2.1. El proceso de traducción del lenguaje</h2>
            </div>
          </div>
        </div>
        <p>
      Todos los lenguajes de programación se traducen de algo que
      suele ser fácilmente entendible por una persona
      (<span class="emphasis"><em>código fuente</em></span>) a algo que es ejecutado
      por una computadora (<span class="emphasis"><em>código máquina</em></span>). Los
      traductores se dividen tradicionalmente en dos
      categorías: <span class="emphasis"><em>intérpretes</em></span> y
      <span class="emphasis"><em>compiladores</em></span>.
    </p>
        <div class="sect2" title="2.1.1. Intérpretes">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp3967776"></a>2.1.1. Intérpretes</h3>
              </div>
            </div>
          </div>
          <p>
	Un intérprete traduce el código fuente en actividades (las
	cuales pueden comprender grupos de instrucciones máquina) y
	ejecuta inmediatamente estas actividades.  El BASIC, por
	ejemplo, fue un lenguaje interpretado bastante popular. Los
	intérpretes de BASIC tradicionales traducen y ejecutan una línea
	cada vez, y después olvidan la línea traducida. Esto los hace
	lentos debido a que deben volver a traducir cualquier código que
	se repita. BASIC también ha sido compilado para ganar en
	velocidad. La mayoría de los intérpretes modernos, como los de
	Python, traducen el programa entero en un lenguaje intermedio
	que es ejecutable por un intérprete mucho más
	rápido
	<sup>[<a id="idp3969632" href="#ftn.idp3969632" class="footnote">33</a>]</sup>.
      </p>
          <p>
	Los intérpretes tienen muchas ventajas. La transición del
	código escrito al código ejecutable es casi inmediata, y el
	código fuente está siempre disponible, por lo que el intérprete
	puede ser mucho más específico cuando ocurre un error. Los
	beneficios que se suelen mencionar de los intérpretes es la
	facilidad de interacción y el rápido desarrollo (pero no
	necesariamente ejecución) de los programas.
      </p>
          <p>
	Los lenguajes interpretados a menudo tienen severas limitaciones
	cuando se construyen grandes proyectos (Python parece ser una
	excepción). El intérprete (o una versión reducida) debe estar
	siempre en memoria para ejecutar el código e incluso el
	intérprete más rápido puede introducir restricciones de
	velocidad inaceptables. La mayoría de los intérpretes requieren
	que todo el código fuente se les envíe de una sola vez. Esto no
	sólo introduce limitaciones de espacio, sino que puede causar
	errores difíciles de detectar si el lenguaje no incluye
	facilidades para localizar el efecto de las diferentes porciones
	de código.
      </p>
        </div>
        <div class="sect2" title="2.1.2. Compiladores">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp3972616"></a>2.1.2. Compiladores</h3>
              </div>
            </div>
          </div>
          <p>
	Un compilador traduce el código fuente directamente a
	lenguaje ensamblador o instrucciones máquina. El producto final
	suele ser uno o varios ficheros que contienen código
	máquina. La forma de realizarlo suele ser un proceso que
	consta de varios pasos. La transición del código escrito al
	código ejecutable es significativamente más larga con un
	compilador.
      </p>
          <p>
        Dependiendo de la perspicacia del escritor del compilador, los
        programas generados por un compilador tienden a requerir mucho
        menos espacio para ser ejecutados, y se ejecutan mucho más
        rápido. Aunque el tamaño y la velocidad son probablemente las
        razones más citadas para usar un compilador, en muchas
        situaciones no son las más importantes. Algunos lenguajes (como
        el C) están diseñados para admitir trozos de programas
        compilados independientemente. Estas partes terminan combinando
        en un programa <span class="emphasis"><em>ejecutable</em></span> final mediante
        una herramienta llamada <span class="emphasis"><em>enlazador</em></span>
        (<span class="foreignphrase"><em class="foreignphrase">linker</em></span>). Este proceso se
        conoce como <span class="emphasis"><em>compilación separada</em></span>.
      </p>
          <p>
	La compilación separada tiene muchos beneficios. Un programa
	que, tomado de una vez, excedería los límites del compilador o
	del entorno de compilación puede ser compilado por piezas. Los
	programas se pueden ser construir y probar pieza a pieza.  Una
	vez que una parte funciona, se puede guardar y tratarse como un
	bloque. Los conjuntos de piezas ya funcionales y probadas se
	pueden combinar en <span class="emphasis"><em>librerías</em></span> para que otros
	programadores puedan usarlos. Como se crean piezas, la
	complejidad de las otras piezas se mantiene oculta.  Todas estas
	características ayudan a la creación de programas grandes,
	<sup>[<a id="idp3977296" href="#ftn.idp3977296" class="footnote">34</a>]</sup>.
      </p>
          <p>
	Las características de depuración del compilador han mejorado
	considerablemente con el tiempo. Los primeros compiladores
	simplemente generaban código máquina, y el programador insertaba
	sentencias de impresión para ver qué estaba ocurriendo, lo que
	no siempre era efectivo. Los compiladores modernos pueden
	insertar información sobre el código fuente en el programa
	ejecutable. Esta información se usa por poderosos
	<span class="emphasis"><em>depuradores a nivel de código</em></span> que muestran
	exactamente lo que pasa en un programa rastreando su progreso
	mediante su código fuente.
      </p>
          <p>
	Algunos compiladores solucionan el problema de la velocidad
	de compilación mediante <span class="emphasis"><em>compilación en
	  memoria</em></span>. La mayoría de los compiladores trabajan
	con ficheros, leyéndolos y escribiéndolos en cada paso de
	los procesos de compilación. En la compilación en memoria el
	compilador se mantiene en RAM. Para programas pequeños,
	puede parecerse a un intérprete.
      </p>
        </div>
        <div class="sect2" title="2.1.3. El proceso de compilación">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp3980512"></a>2.1.3. El proceso de compilación</h3>
              </div>
            </div>
          </div>
          <p>
	Para programar en C y en C++, es necesario entender los
	pasos y las herramientas del proceso de compilación. Algunos
	lenguajes (C y C++, en particular) empiezan la compilación
	ejecutando un <span class="emphasis"><em>preprocesador</em></span> sobre el código
	fuente. El preprocesador es un programa simple que sustituye
	patrones que se encuentran en el código fuente con otros que
	ha definido el programador (usando las <span class="emphasis"><em>directivas
	  de preprocesado</em></span>). Las directivas de
	preprocesado se utilizan para ahorrar escritura y para aumentar
	la legilibilidad del código (posteriormente en este libro,
	aprenderá cómo el diseño de C++ desaconseja en gran medida el uso
	del preprocesador, ya que puede causar errores sutiles). El
	código preprocesado se suele escribir en un fichero
	intermedio.
      </p>
          <p>
	Normalmente, los compiladores hacen su trabajo en dos
	pasadas. La primera pasada consiste en analizar sintácticamente
	el código generado por el preprocesador. El compilador trocea
	el código fuente en pequeñas partes y lo organiza en una
	estructura llamada <span class="emphasis"><em>árbol</em></span>. En la
	expresión FIXME:«A+B», los elementos
	«A», «+», «B» son
	hojas del árbol.
      </p>
          <p>
	A menudo se utiliza un <span class="emphasis"><em>optimizador global</em></span>
	entre el primer y el segundo paso para producir código más
	pequeño y rápido.
      </p>
          <p>
	En la segunda pasada, el <span class="emphasis"><em>generador de código</em></span>
	  recorre el árbol sintáctico y genera lenguaje ensamblador o
	  código máquina para los nodos del árbol. Si el generador de
	  código crea lenguaje ensamblador, entonces se debe ejecutar el
	  programa ensamblador. El resultado final en ambos casos es un
	  módulo objeto (un fichero que típicamente tiene una extensión
	  de <code class="filename">.o</code> o <code class="filename">.obj</code>. A
	  veces se utiliza un <span class="emphasis"><em>optimizador de
	  mirilla</em></span> en esta segunda pasada para buscar trozos de
	  código que contengan sentencias redundantes de lenguaje
	  ensamblador.
      </p>
          <p>
	Usar la palabra «objeto» para describir pedazos de
	código máquina es un hecho desafortunado. La palabra comenzó a
	usarse antes de que la programación orientada a objetos tuviera
	un uso generalizado. «Objeto» significa lo mismo
	que «FIXME:meta» en este contexto, mientras que en la
	programación orientada a objetos significa «una cosa con
	límites».
      </p>
          <p>
	El <span class="emphasis"><em>enlazador</em></span> combina una lista de módulos
	objeto en un programa ejecutable que el sistema operativo puede
	cargar y ejecutar. Cuando una función en un módulo objeto hace
	una referencia a una función o variable en otro módulo objeto,
	el enlazador resuelve estas referencias; se asegura de que todas
	las funciones y los datos externos solicitados durante el
	proceso de compilación existen realmente. Además, el enlazador
	añade un módulo objeto especial para realizar las actividades de
	inicialización.
      </p>
          <p>
	El enlazador puede buscar en unos archivos especiales llamados
	<span class="emphasis"><em>librerías</em></span> para resolver todas sus
	referencias. Una librería contiene una colección de módulos
	objeto en un único fichero. Una librería se crea y mantiene por
	un programa conocido como <span class="emphasis"><em>bibliotecario</em></span>
	(<span class="foreignphrase"><em class="foreignphrase">librarian</em></span>).
      </p>
          <div class="sect3" title="Comprobación estática de tipos">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title"><a id="idp3991384"></a>Comprobación estática de tipos</h4>
                </div>
              </div>
            </div>
            <p>
	  El compilador realiza una <span class="emphasis"><em>comprobación de
	  tipos</em></span> durante la primera pasada. La comprobación de
	  tipos asegura el correcto uso de los argumentos en las
	  funciones y previene muchos tipos de errores de
	  programación. Como esta comprobación de tipos ocurre se hace
	  la compilación y no cuando el programa se está ejecutado, se
	  conoce como <span class="emphasis"><em>comprobación estática de
	  tipos</em></span>.
	</p>
            <p>
	  Algunos lenguajes orientados a objetos (Java por ejemplo)
	  realizan comprobaciones en tiempo de ejecución
	  (<span class="emphasis"><em>comprobación dinámica de tipos</em></span>). Si se
	  combina con la estática, la comprobación dinámica es más
	  potente que sólo la estática. Sin embargo, añade una
	  sobrecarga a la ejecución del programa.
	</p>
            <p>
	  C++ usa la comprobación estática de tipos debido a que el
	  lenguaje no puede asumir ningún soporte particular durante la
	  ejecución. La comprobación estática de tipos notifica al
	  programador malos usos de los tipos durante la compilación, y
	  así maximiza la velocidad de ejecución. A medida que aprenda
	  C++, comprobará que la mayoría de las decisiones de diseño del
	  lenguaje están tomadas en favor de la mejora del rendimiento,
	  motivo por el cual C es famoso en la programación orientada a
	  la producción.
	</p>
            <p>
	  Se puede deshabilitar la comprobación estática de tipos en
	  C++, e incluso permite al programador usar su propia
	  comprobación dinámica de tipos - simplemente necesita escribir
	  el código.
	</p>
          </div>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp3969632" href="#idp3969632" class="para">33</a>] </sup>
	    Los límites entre los compiladores y los intérpretes tienden
	    a ser difusos, especialmente con Python, que tiene muchas de
	    las caractéristicas y el poder de un lenguaje compilado pero
	    también tiene parte de las ventajas de los lenguajes
	    interpretados.
	  </p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp3977296" href="#idp3977296" class="para">34</a>] </sup>
	    Python vuelve a ser una excepción, debido a que permite
	    compilación separada.
	  </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch01s13.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch01s13.html">1.13. Resumen</a>
          </td>
          <td width="10%" align="center"> </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch02s02.html">2.2. Herramientas para compilación modular</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch02s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
