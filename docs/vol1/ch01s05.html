<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>1.5. Herencia: reutilización de interfaces</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C01.html" title="1: Introducción a los Objetos" />
    <link rel="prev" href="ch01s04.html" title="1.4. Reutilizar la implementación" />
    <link rel="next" href="ch01s06.html" title="1.6. Objetos intercambiables gracias al polimorfismo" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch01s04.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch01s04.html">1.4. Reutilizar la implementación</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C01.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch01s06.html">1.6. Objetos intercambiables gracias al polimorfismo</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch01s06.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="1.5. Herencia: reutilización de interfaces">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp3639664"></a>1.5. Herencia: reutilización de interfaces</h2>
          </div>
        </div>
      </div>
      <p>
      En sí misma, la idea de objeto es una herramienta útil. Permite
      empaquetar datos y funcionalidad junto al propio
      concepto<span class="emphasis"><em></em></span>, además puede representar una idea
      apropiada del espacio del problema en vez de estar forzado a usar
      el vocabulario de la máquina subyacente. Esos conceptos se
      expresan como unidades fundamentales en el lenguaje de
      programación mediante la palabra reservada <code class="keyword">class</code>.
    </p>
      <p>
      Sin embargo, es una pena tomarse tantas molestias en crear una
      clase y verse obligado a crear una más para un nuevo tipo que
      tiene una funcionalidad similar. Es más sencillo si se puede usar
      la clase existente, clonarla, y hacerle añadidos y modificaciones
      a ese clon. Esto es justamente lo que hace la
      <span class="emphasis"><em>herencia</em></span>, con la excepción de que si cambia
      la clase original (llamada clase <span class="emphasis"><em>base</em></span>,
      <span class="emphasis"><em>super</em></span> o <span class="emphasis"><em>padre</em></span>), el
      «clon» modificado (llamado clase
      <span class="emphasis"><em>derivada</em></span>, <span class="emphasis"><em>heredada</em></span>,
      <span class="emphasis"><em>sub</em></span> o <span class="emphasis"><em>hija</em></span>) también
      refleja esos cambios.
    </p>
      <div class="figure">
        <a id="idp3644616"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_05.png" align="middle" alt="subclases" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 1.3. subclases</strong>
        </p>
      </div>
      <br class="figure-break" />
      <p>
      (En el diagrama UML anterior, la flecha apunta desde la clase
      derivada hacia la clase base. Como puede ver, puede haber más de una
      clase derivada.)
    </p>
      <p>
      Un tipo hace algo más que describir las restricciones de un
      conjunto de objetos; también tiene una relación con otros
      tipos. Dos tipos pueden tener características y comportamientos en
      común, pero un tipo puede contener más características que otro y
      también puede manipular más mensajes (o hacerlo de forma
      diferente). La herencia lo expresa de forma similar entre tipos
      usando el concepto de tipos base y tipos derivados. Un tipo base
      contiene todas las características y comportamientos compartidos
      entre los tipos derivados de él. Cree un tipo base para
      representar lo esencial de sus ideas sobre algunos objetos en su
      sistema. A partir del tipo base, derive otros tipos para expresar
      caminos diferentes que puede realizar esa parte común.
    </p>
      <p>
      Por ejemplo, una máquina de reciclado de basura clasifica piezas
      de basura. El tipo base es «basura», y cada pieza de
      basura tiene un peso, un valor, y también, se puede triturar,
      fundir o descomponer. A partir de ahí, se obtienen más tipos
      específicos de basura que pueden tener características adicionales
      (una botella tiene un color) o comportamientos (el aluminio puede
      ser aplastado, el acero puede ser magnético). Además, algunos
      comportamientos pueden ser diferentes (el valor del papel depende
      del tipo y condición). Usando la herencia, se puede construir una
      jerarquía de tipos que exprese el problema que se intenta resolver
      en términos de sus tipos.
    </p>
      <p>
      Un segundo ejemplo es el clásico ejemplo «figura»,
      tal vez usado en un sistema de diseño asistido por computador o
      juegos de simulación. El tipo base es
      <code class="classname">figura</code>, y cada figura tiene un tamaño, un
      color, una posición y así sucesivamente. Cada figura se puede
      dibujar, borrar, mover, colorear, etc. A partir de ahí, los tipos
      específicos de figuras derivan (heredan) de ella: círculo,
      cuadrado, triángulo, y así sucesivamente, cada uno de ellos puede
      tener características y comportamientos adicionales. Ciertas
      figuras pueden ser, por ejemplo, rotadas. Algunos comportamientos
      pueden ser diferentes, como cuando se quiere calcular el área de
      una figura. La jerarquía de tipos expresa las similitudes y las
      diferencias entre las figuras.
    </p>
      <div class="figure">
        <a id="idp3652256"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_06.png" align="middle" alt="Jerarquía de Figura" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 1.4. Jerarquía de <code class="classname">Figura</code></strong>
        </p>
      </div>
      <br class="figure-break" />
      <p>
      Modelar la solución en los mismos términos que el problema es
      tremendamente beneficioso porque no se necesitan un montón de
      modelos intermedios para transformar una descripción del problema
      en una descripción de la solución. Con objetos, la jerarquía de
      tipos es el principal modelo, lleva directamente desde la
      descripción del sistema en el mundo real a la descripción del
      sistema en código. Efectivamente, una de las dificultades que la
      gente tiene con el diseño orientado a objetos es que es demasiado
      fácil ir desde el principio hasta el final. Una mente entrenada
      para buscar soluciones complejas a menudo se confunde al principio
      a causa de la simplicidad.
    </p>
      <p>
      Cuando se hereda de un tipo existente, se está creando un tipo
      nuevo. Este nuevo tipo contiene no sólo todos los miembros del
      tipo base (aunque los datos privados <code class="keyword">private</code> están
      ocultos e inaccesibles), sino que además, y lo que es más
      importante, duplica la interfaz de la clase base. Es decir,
      todos los mensajes que se pueden enviar a los objetos de la
      clase base se pueden enviar también a los objetos de la clase
      derivada. Dado que se conoce el tipo de una clase por los
      mensajes que se le pueden enviar, eso significa que la clase
      derivada <span class="emphasis"><em>es del mismo tipo que la clase
      base</em></span>. En el ejemplo anterior, «un círculo es
      una figura». Esta equivalencia de tipos vía herencia es
      uno de las claves fundamentales para comprender la programación
      orientada a objetos.
    </p>
      <p>
      Por lo que tanto la clase base como la derivada tienen la misma
      interfaz, debe haber alguna implementación que corresponda a esa
      interfaz. Es decir, debe haber código para ejecutar cuando un
      objeto recibe un mensaje particular. Si simplemente hereda de una
      clase y no hace nada más, los métodos de la interfaz de la clase
      base están disponibles en la clase derivada. Esto significa que
      los objetos de la clase derivada no sólo tienen el mismo tipo,
      también tienen el mismo comportamiento, lo cual no es
      particularmente interesante.
    </p>
      <p>
      Hay dos caminos para diferenciar la nueva clase derivada de la
      clase base original. El primero es bastante sencillo: simplemente
      hay que añadir nuevas funciones a la clase derivada. Estas nuevas
      funciones no son parte de la interfaz de la clase base. Eso
      significa que la clase base simplemente no hace todo lo que
      necesitamos, por lo que se añaden más funciones. Este uso simple y
      primitivo de la herencia es, a veces, la solución perfecta a
      muchos problemas. Sin embargo, quizá debería pensar en la
      posibilidad de que su clase base puede necesitar también funciones
      adicionales. Este proceso de descubrimiento e iteración de su
      diseño ocurre regularmente en la programación orientada a objetos.
    </p>
      <div class="figure">
        <a id="idp3660968"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_07.png" align="middle" alt="Especialización de Figura" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 1.5. Especialización de <code class="classname">Figura</code></strong>
        </p>
      </div>
      <br class="figure-break" />
      <p>
      Aunque la herencia algunas veces supone que se van a añadir
      nuevas funciones a la interfaz, no es necesariamente cierto. El
      segundo y más importante camino para diferenciar su nueva clase
      es <span class="emphasis"><em>cambiar</em></span> el comportamiento respecto de
      una función de una clase base existente. A esto se le llama
      <span class="emphasis"><em>reescribir</em></span>
      (<span class="foreignphrase"><em class="foreignphrase">override</em></span>) una función.
    </p>
      <div class="figure">
        <a id="idp3664856"></a>
        <div class="figure-contents">
          <div class="mediaobject" align="center">
            <img src="./images/V1_08.png" align="middle" alt="Reescritura de métodos" />
          </div>
        </div>
        <p class="title">
          <strong>Figura 1.6. Reescritura de métodos</strong>
        </p>
      </div>
      <br class="figure-break" />
      <p>
      Para reescribir una función, simplemente hay que crear una nueva
      definición para esa función en la clase derivada. Está diciendo,
      «Estoy usando la misma función de interfaz aquí, pero quiero
      hacer algo diferente para mi nuevo tipo».
    </p>
      <div class="sect2" title="1.5.1. Relaciones es-un vs. es-como-un">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="idp3668128"></a>1.5.1.  Relaciones es-un vs. es-como-un </h3>
            </div>
          </div>
        </div>
        <p>
	Hay cierta controversia que puede ocurrir con la herencia: ¿la
	herencia debería limitarse a anular <span class="emphasis"><em>sólo</em></span>
	funciones de la clase base (y no añadir nuevos métodos que no
	estén en la clase base)?  Esto puede significar que el tipo
	derivado es <span class="emphasis"><em>exactamente</em></span> el mismo tipo que
	la clase base dado que tiene exactamente la misma interfaz. Como
	resultado, se puede sustituir un objeto de una clase derivada
	por un objeto de la clase base. Se puede pensar como una
	<span class="emphasis"><em>sustitución pura</em></span>, y se suele llamar
	<span class="emphasis"><em>principio de sustitución</em></span>. En cierto modo,
	esta es la forma ideal de tratar la herencia. A menudo nos
	referimos a las relaciones entre la clase base y clases
	derivadas en este caso como una relación es-un, porque se dice
	«un círculo es una figura». Un modo de probar la
	herencia es determinar si se puede considerar la relación es-un
	sobre las clases y si tiene sentido.
    </p>
        <p>
	Hay ocasiones en las que se deben añadir nuevos elementos a la
	interfaz de un tipo derivado, de esta manera se amplía la
	interfaz y se crea un tipo nuevo. El nuevo tipo todavía puede
	ser sustituido por el tipo base, pero la sustitución no es
	perfecta porque sus nuevas funciones no son accesibles desde el
	tipo base. Esta relación se conoce como
	<span class="emphasis"><em>es-como-un</em></span>; el nuevo tipo tiene la interfaz
	del viejo tipo, pero también contiene otras funciones, por lo
	que se puede decir que es exactamente el mismo. Por ejemplo,
	considere un aire acondicionado. Suponga que su casa está
	conectada con todos los controles para refrigerar; es decir,
	tiene una interfaz que le permite controlar la
	temperatura. Imagine que el aire acondicionado se avería y lo
	reemplaza por una bomba de calor, la cual puede dar calor y
	frío. La bomba de calor <span class="emphasis"><em>es-como-un</em></span> aire
	acondicionado, pero puede hacer más cosas. Como el sistema de
	control de su casa está diseñado sólo para controlar el frío,
	está rentringida a comunicarse sólo con la parte de frío del
	nuevo objeto. La interfaz del nuevo objeto se ha extendido, y el
	sistema existente no conoce nada excepto la interfaz original.
    </p>
        <div class="figure">
          <a id="idp3673856"></a>
          <div class="figure-contents">
            <div class="mediaobject" align="center">
              <img src="./images/V1_09.png" align="middle" alt="Relaciones" />
            </div>
          </div>
          <p class="title">
            <strong>Figura 1.7. Relaciones</strong>
          </p>
        </div>
        <br class="figure-break" />
        <p>
	Por supuesto, una vez que vea este diseño queda claro que la
	clase base «sistema de frío» no es bastante
	general, y se debería renombrar a «sistema de control de
	temperatura», además también puede incluir calor, en
	este punto se aplica el principio de sustitución. Sin embargo,
	el diagrama de arriba es un ejemplo de lo que puede ocurrir en
	el diseño y en el mundo real.
      </p>
        <p>
	Cuando se ve el principio de sustitución es fácil entender
	cómo este enfoque (sustitución pura) es la única forma de
	hacer las cosas, y de hecho es bueno para que sus diseños
	funcionen de esta forma. Pero verá que hay ocasiones en que
	está igualmente claro que se deben añadir nuevas funciones a
	la interfaz de la clase derivada. Con experiencia, ambos casos
	puede ser razonablemente obvios.
      </p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch01s04.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch01s04.html">1.4. Reutilizar la implementación</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C01.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch01s06.html">1.6. Objetos intercambiables gracias al polimorfismo</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch01s06.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
