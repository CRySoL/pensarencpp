<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>A.4. Paréntesis, llaves e indentación</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="ApendiceA.html" title="Apéndice A. Estilo de codificación" />
    <link rel="prev" href="apas03.html" title="A.3. Marcas comentadas de inicio y fin" />
    <link rel="next" href="apas05.html" title="A.5. Nombres para identificadores" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="apas03.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="apas03.html">A.3. Marcas comentadas de inicio y fin</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="ApendiceA.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="apas05.html">A.5. Nombres para identificadores</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="apas05.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="A.4. Paréntesis, llaves e indentación">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp8808568"></a>A.4. Paréntesis, llaves e indentación</h2>
          </div>
        </div>
      </div>
      <p>
      Habrá notado que el estilo de este libro es diferente a la mayoría
      de los estilos C tradicionales. Por supuesto, cualquiera puede
      pensar que su propio estilo es más racional. Sin embargo, el
      estilo que se emplea aquí tiene una lógica más simple, que se
      presentará mezclada con las de otros estilos desarrollados.
    </p>
      <p>
      El estilo está motivado por una cosa: la presentación, tanto
      impresa como en un seminario. Quizá sus necesidades sean
      diferentes porque no realiza muchas presentaciones. Sin embargo,
      el código real se lee muchas más veces de las que se escribe, y por
      eso debería ser fácil de leer. Mis dos criterios más importantes
      son la «escaneabilidad» (que se refiere a la facilidad
      con la que el lector puede comprender el significado de una única
      línea) y el número de líneas que caben en una página. Lo segundo
      puede sonar gracioso, pero cuando uno da una charla, distrae mucho
      a la audiencia que el ponente tenga que avanzar y retroceder
      diapositivas, y sólo unas pocas líneas de más puede provocar este
      efecto.
    </p>
      <p>
      Todo el mundo parece estar de acuerdo en que el código que se
      pone dentro de llaves debe estar indentado. En lo que la gente
      no está de acuerdo - y es el sitio donde más inconsistencia
      tienen los estilos - es: ¿Dónde debe ir la llave de apertura?
      Esta única cuestión, creo yo, es la que causa la mayoría de las
      variaciones en los estilos de codificación (Si quiere ver una
      enumeración de estilos de codificación vea <em class="citetitle">C++
      Programming Guidelines</em>, de [FIXME:autores] Tom Plum
      y Dan Saks, Plum Hall 1991), Intentaré convencerle de que muchos
      de los estilos de codificación actuales provienen de la
      restricciones previas al C Estándar (antes de los prototipos de
      función) de manera que no son apropiadas actualmente.
    </p>
      <p>
      Lo primero, mi respuesta a esa pregunta clave: la llave de
      apertura debería ir siempre en la misma línea que el
      «precursor» (es decir «cualquier cosa de la que
      sea cuerpo: una clase, función, definición de objeto, sentencia
      <code class="keyword">if</code>, etc». Es una regla única y
      consistente que aplico a todo el código que escribo, y hace que
      el formateo de código sea mucho más sencillo. Hace más sencilla la
      «escaneabilidad» - cuando se lee esta línea:
    </p>
      <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">);</span>
</pre>
      <p>
      Se sabe, por el punto y coma al final de la línea, que esto es una
      declaración y no hay nada más, pero al leer la línea:
    </p>
      <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span>
</pre>
      <p>
      inmediatamente se sabe que se trata de una definición porque la
      línea termina con una llave de apertura, y no un punto y
      coma. Usando este enfoque, no hay diferencia a la hora de
      colocar el paréntesis de apertura en una definición de múltiples
      líneas.
    </p>
      <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span>
      <span class="hl kwb">int</span> b <span class="hl opt">=</span> a <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">return</span> b <span class="hl opt">*</span> <span class="hl num">2</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre>
      <p>
      y para una definición de una sola línea que a menudo se usa para inlines:
    </p>
      <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) *</span> <span class="hl num">2</span><span class="hl opt">; }</span>
</pre>
      <p>
      Igualmente, para una clase:
    </p>
      <pre class="programlisting">
<span class="hl kwc">class</span> Thing<span class="hl opt">;</span>
</pre>
      <p>
      es una declaración del nombre de una clase, y
    </p>
      <pre class="programlisting">
<span class="hl kwc">class</span> Thing <span class="hl opt">{</span>
</pre>
      <p>
      es una definición de clase. En todos los casos, se puede saber
      mirando una sola línea si se trata de una declaración o una
      definición. Y por supuesto, escribir la llave de apertura en la
      misma línea, en lugar de una línea propia, permite ahorrar
      espacio en la página.
    </p>
      <p>
      Así que ¿por qué tenemos tantos otros estilos? En concreto, verá
      que mucha gente crea clases siguiente el estilo anterior (que
      Stroustrup usa en todas las ediciones de su libro <em class="citetitle">The
      C++ Programming Language</em> de Addison-Wesley) pero crean
      definiciones de funciones poniendo la llave de apertura en una
      línea aparte (lo que da lugar a muchos estilos de indentación
      diferentes). Stroustrup lo hace excepto para funciones inline
      cortas. Con el enfoque que yo describo aquí, todo es consistente -
      se nombra lo que sea (<code class="keyword">class</code>, functión, <code class="keyword">enum</code>, etc)
      y en la misma línea se pone la llave de apertura para indicar que
      el cuerpo de esa cosa está debajo. Y también, la llave de apertura
      se pone en el mismo sitio para funciones inline que para
      definiciones de funciones ordinarias.
    </p>
      <p>
      Creo que el estilo de definición de funciones que utiliza mucha
      gente viene de el antiguo prototipado de funciones de C, en el que
      no se declaraban los argumentos entre los paréntesis, si no entre
      el paréntesis de cierre y la llave de apertura (esto demuestra que
      las raíces de C son el lenguaje ensamblador):
    </p>
      <pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">bar</span><span class="hl opt">()</span>
     <span class="hl kwb">int</span> x<span class="hl opt">;</span>
     <span class="hl kwb">float</span> y<span class="hl opt">;</span>
    <span class="hl opt">{</span>
     <span class="hl com">/* body here */</span>
    <span class="hl opt">}</span>
</pre>
      <p>
      Aquí, quedaría bastante mal poner la llave de apertura en la
      misma línea, así que nadie lo hacía. Sin embargo, había
      distintas opiniones sobre si las llaves debían
      indentarse con el cuerpo del código o debían dejarse a nivel con
      el «precursor». De modo que tenemos muchos estilos
      diferentes.
    </p>
      <p>
      Hay otros argumentos para poner la llave en la línea
      siguiente a la declaración (de una clase, <code class="keyword">struct</code>,
      función, etc). Lo siguiente proviene de un lector, y lo presento
      aquí para que sepa a qué se refiere.
    </p>
      <p>
      Los usuarios experimentado de <span class="command"><strong>vi</strong></span> (vim)
      saben que pulsar la tecla «]» dos veces lleva el
      cursor a la siguiente ocurrencia de «{» (o ^L) en la
      columna 0. Esta característica es extremadamente útil para moverse
      por el código (saltando a la siguiente defición de función o
      clase). [Mi comentario: cuando yo trabajaba en Unix, GNU
      Emacs acababa de aparecer y yo me convertí en un fan suyo. Como
      resultado, <span class="command"><strong>vi</strong></span> nunca ha tenido sentido
      para mí, y por eso yo no pienso en términos de «situación
      de columna 0». Sin embargo, hay una buena cantidad de
      usuarios de <span class="command"><strong>vi</strong></span> ahí fuera, a los que les
      afecta esta característica.]
    </p>
      <p>
      Poniendo la «{» en la siguiente línea se eliminan
      algunas confusiones en sentencias condicionales complejas,
      ayudando a la escaneabilidad.
    </p>
      <pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>cond1
       <span class="hl opt">&amp;&amp;</span> cond2
       <span class="hl opt">&amp;&amp;</span> cond3<span class="hl opt">) {</span>
       statement<span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre>
      <p>
      Lo anterior [dice el lector] tiene una escaneabilidad pobre. Sin embargo,
    </p>
      <pre class="programlisting">
<span class="hl kwa">if</span> <span class="hl opt">(</span>cond1
    <span class="hl opt">&amp;&amp;</span> cond2
    <span class="hl opt">&amp;&amp;</span> cond3<span class="hl opt">)</span>
    <span class="hl opt">{</span>
    statement<span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre>
      <p>
      separa el <code class="keyword">if</code> del cuerpo, mejorando la
      legibilidad. [Sus opiniones sobre si eso es cierto variarán
      dependiendo para qué lo haya usado.]
    </p>
      <p>
      Finalmente, es mucho más fácil visualizar llaves emparejadas
      si están alineadas en la misma columna. Visualmente destacan mucho
      más. [Fin del comentario del lector]
    </p>
      <p>
      El tema de dónde poner la llave de apertura es probablemente el
      asunto en el que hay menos acuerdo. He aprendido a leer ambas
      formas, y al final cada uno utiliza la que le resulta más
      cómoda. Sin embargo, he visto que el estándar oficial de
      codificación de Java (que se puede encontar en la página de Java
      de Sun) efectivamente es el mismo que yo he presentado aquí - dado
      que más personas están empezando a programar en ambos lenguajes,
      la consistencia entre estilos puede ser útil.
    </p>
      <p>
      Mi enfoque elimina todas las excepciones y casos especiales, y
      lógicamente produce un único estilo de indentación, Incluso con
      un cuerpo de función, la consistencia se mantiene, como en:
    </p>
      <pre class="programlisting">
<span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      cout <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">*</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
</pre>
      <p>
      El estilo es fácil de enseñar y recordar - use una regla simple y
      consistente para todo sus formatos, no una para clases, dos para
      funciones (funciones inline de una línea vs. multi-línea), y
      posiblemente otras para bucles, sentencias <code class="keyword">if</code>,
      etc. La consistencia por si sola merece ser tenida en
      cuenta. Sobre todo, C++ es un lenguaje más nuevo que C, y aunque
      debemos hacer muchas concesiones a C, no deberíamos acarrear demasiados
      FIXME:artifacts que nos causen problemas en el futuro. Problemas
      pequeños multiplicados por muchas líneas de código se convierten en
      grandes problemas. Para un examen minucioso del asunto, aunque
      trata de C, vea <em class="citetitle">C Style: Standards and
      Guidelines</em>, de David Straker (Prentice-Hall 1992).
    </p>
      <p>
      La otra restricción bajo la que debo trabajar es la longitud de la
      línea, dado que el libro tiene una limitación de 50
      caracteres. ¿Qué ocurre si algo es demasiado largo para caber en
      una línea? Bien, otra vez me esfuerzo en tener una política
      consistente para las líneas partidas, de modo que sean fácilmente
      visibles. Siempre que sean parte de una única definición, lista de
      argumentos, etc., las líneas de continuación deberían indentarse
      un nivel respecto al comienzo de la definición, lista de
      argumentos, etc.
    </p>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="apas03.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="apas03.html">A.3. Marcas comentadas de inicio y fin</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="ApendiceA.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="apas05.html">A.5. Nombres para identificadores</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="apas05.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
