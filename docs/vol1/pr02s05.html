<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>5. Capítulos</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="prefacio.html" title="Prefacio" />
    <link rel="prev" href="pr02s04.html" title="4. Objetivos" />
    <link rel="next" href="pr02s06.html" title="6. Ejercicios" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="pr02s04.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="pr02s04.html">4. Objetivos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="prefacio.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="pr02s06.html">6. Ejercicios</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="pr02s06.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="5. Capítulos">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp3458768"></a>5. Capítulos</h2>
          </div>
        </div>
      </div>
      <p>
      C++ es un lenguaje en el que se construyen características nuevas
      y diferentes sobre una sintaxis existente (por esta razón, nos
      referiremos a él como un lenguaje de programación orientado a
      objetos híbrido). Como mucha gente pasa por una curva de
      aprendizaje, hemos comenzado por adaptarnos a la forma en que los
      programadores pasan por las etapas de las cualidades del lenguaje
      C++. Como parece que la progresión natural es la de una mente
      entrenada de forma procedural, he decidido comprender y seguir el
      mismo camino y acelerar el proceso proponiendo y resolviendo las
      preguntas que se me ocurrieron cuando yo aprendía el lenguaje y
      también las que se les ocurrieron a la gente a la que lo enseñaba.
    </p>
      <p>
      El curso fue diseñado con algo en mente: hacer más eficiente el
      proceso de aprender C++. La reacción de la audiencia me ayudó a
      comprender qué partes eran difíciles y necesitaban una aclaración
      extra. En las áreas en las que me volvía ambicioso e incluía
      demasiadas cosas de una vez, me dí cuenta -mediante la
      presentación de material- de que si incluyes demasiadas
      características, tendrás que explicarlas todas, y es fácil que la
      confusión de los estudiantes se agrave. Como resultado, he tenido
      muchos problemas para introducir las características tan
      lentamente como ha sido posible; idealmente, sólo un concepto
      importante a la vez por capítulo.
    </p>
      <p>
      Así pues, el objetivo en cada capítulo es enseñar un concepto
      simple, o un pequeño grupo de conceptos asociados, en caso de que
      no haya más conceptos adicionales. De esa forma puede digerir cada
      parte en el contexto de su conocimiento actual antes de
      continuar. Para llevarlo a cabo, dejé algunas partes de C para más
      adelante de lo que me hubiese gustado. La ventaja es que se evita
      la confusión al no ver todas las características de C++ antes de
      que éstas sean explicadas, así su introducción al lenguaje será
      tranquila y reflejará la forma en que asimile las características
      que dejo en sus manos.
    </p>
      <p>
      He aquí una breve descripción de los capítulos que contiene
      este libro:
    </p>
      <p title="Capítulo 1: Introducción a los objetos."><strong><a class="link" href="C01.html" title="1: Introducción a los Objetos">Capítulo 1: Introducción a los objetos.</a> </strong>
	Cuando los proyectos se vuelven demasiado grandes y difíciles de
	mantener, nace la «crisis del software», que es
	cuando los programadores dicen: «¡No podemos terminar los
	proyectos, y cuando podemos, son demasiado caros!». Eso
	provocó gran cantidad de reacciones, que se discuten en este
	capítulo mediante las ideas de Programación Orientada a Objetos
	(<acronym class="acronym">POO</acronym>) y cómo intenta ésta resolver la crisis
	del software. El capítulo le lleva a través de las
	características y conceptos básicos de la POO y también
	introduce los procesos de análisis y diseño. Además, aprenderá
	acerca de los beneficios y problemas de adaptar el lenguaje,
	y obtendrá sugerencias para adentrarse en el mundo de C++.
      </p>
      <p title="Capítulo 2: Crear y usar objetos."><strong><a class="link" href="C02.html" title="2: Construir y usar objetos">Capítulo 2: Crear y usar objetos.</a> </strong>
	Este capítulo explica el proceso de construir programas usando
	compiladores y librerías. Presenta el primer programa C++ del
	libro y muestra cómo se construyen y compilan los
	programas. Después se presentan algunas de las librerías de
	objetos básicas disponibles en C++ Estándar. Para
	cuando acabe el capítulo, dominará lo que se refiere a escribir
	un programa C++ utilizando las librerías de objetos
	predefinidas.
      </p>
      <p title="Capítulo 3: El C de C++."><strong><a class="link" href="C03.html" title="3: C en C++">Capítulo 3: El C de C++.</a> </strong>
	Este capítulo es una densa vista general de las
	características de C que se utilizan en C++, así como gran
	número de características básicas que sólo están disponibles
	en C++. Además introduce la utilidad
	<span class="application">make</span>, que es habitual en el
	desarrollo software de todo el mundo y que se utiliza para
	construir todos los ejemplos de este libro (el código fuente
	de los listados de este libro, que está disponible en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>,
	contiene los <code class="filename">makefiles</code> correspondientes a
	cada capítulo). En el capítulo 3 supongo que el lector tiene
	unos conocimientos básicos sólidos en algún lenguaje de
	programación procedural como Pascal, C, o incluso algún tipo
	de Basic (basta con que haya escrito algo de código en ese
	lenguaje, especialmente funciones). Si encuentra este capítulo
	demasiado difícil, debería mirar primero el seminario
	<em class="citetitle">Pensar en C</em> del CD que acompaña este
	libro (también disponible en <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>).
      </p>
      <p title="Capítulo 4: Abstracción de datos."><strong><a class="link" href="C04.html" title="4: Abstracción de Datos">Capítulo 4: Abstracción de datos.</a> </strong>
	La mayor parte de las características de C++ giran entorno a la
	capacidad de crear nuevos tipos de datos. Esto no sólo ofrece
	una mayor organización del código, también es la base preliminar
	para las capacidades de POO más poderosas. Verá cómo esta idea
	es posible por el simple hecho de poner funciones dentro de las
	estructuras, los detalles de cómo hacerlo, y qué tipo de código
	se escribe. También aprenderá la mejor manera de organizar su
	código mediante archivos de cabecera y archivos de
	implementación.
      </p>
      <p title="Capítulo 5: Ocultar la implementación."><strong><a class="link" href="C05.html" title="5: Ocultar la implementación">Capítulo 5: Ocultar la implementación.</a> </strong>
	El programador puede decidir que algunos de los datos y
	funciones de su estructura no estén disponibles para el usuario
	del nuevo tipo haciéndolas <span class="emphasis"><em>privadas</em></span>. Eso
	significa que se puede separar la implementación principal de la
	interfaz que ve el programador cliente, y de este modo permitir
	que la implementación se pueda cambiar fácilmente sin afectar al
	código del cliente. La palabra clave <code class="keyword">class</code> también se
	presenta como una manera más elaborada de describir un tipo de
	datos nuevo, y se desmitifica el significado de la palabra
	«objeto» (es una variable elaborada).
      </p>
      <p title="Capítulo 6: Inicialización y limpieza."><strong><a class="link" href="C06.html" title="6: Inicialización y limpieza">Capítulo 6: Inicialización y limpieza.</a> </strong>
	Uno de los errores más comunes en C se debe a las variables no
	inicializadas. El <span class="emphasis"><em>constructor</em></span> de C++
	permite garantizar que las variables de su nuevo tipo de datos
	(«objetos de su clase») siempre se inicializarán
	correctamente. Si sus objetos también requieren algún tipo de
	reciclado, usted puede garantizar que ese reciclado se realice
	siempre mediante el <span class="emphasis"><em>destructor</em></span> C++.
      </p>
      <p title="Capítulo 7: Sobrecarga de funciones y argumentos por defecto."><strong><a class="link" href="C07.html" title="7: Sobrecarga de funciones y argumentos por defecto">Capítulo 7: Sobrecarga de funciones y
	  argumentos por defecto.</a> </strong>
	C++ está pensado para ayudar a construir proyectos grandes
	y complejos. Mientras lo hace, puede dar lugar a múltiples
	librerías que utilicen el mismo nombre de función, y también
	puede decidir utilizar un mismo nombre con diferentes
	significados en la misma biblioteca. Con C++ es sencillo gracias
	a la «sobrecarga de funciones», lo que le permite
	reutilizar el mismo nombre de función siempre que la lista de
	argumentos sea diferente. Los argumentos por defecto le permiten
	llamar a la misma función de diferentes maneras proporcionando,
	automáticamente, valores por defecto para algunos de sus
	argumentos.
      </p>
      <p title="Capítulo 8: Constantes."><strong><a class="link" href="C08.html" title="8: Constantes">Capítulo 8: Constantes.</a> </strong>
	Este capítulo cubre las palabras reservadas <code class="keyword">const</code>
	y <code class="keyword">volatile</code>, que en C++ tienen un significado adicional,
	especialmente dentro de las clases. Aprenderá lo que significa
	aplicar <code class="keyword">const</code> a una definición de puntero. El capítulo
	también muestra cómo varía el significado de <code class="keyword">const</code>
	según se utilice dentro o fuera de las clases y cómo crear
	constantes dentro de clases en tiempo de compilación.
      </p>
      <p title="Capítulo 9: Funciones inline."><strong><a class="link" href="C09.html" title="9: Funciones inline">Capítulo 9: Funciones inline.</a> </strong>
	Las macros del preprocesador eliminan la sobrecarga de
	llamada a función, pero el preprocesador también elimina la
	valiosa comprobación de tipos de C++. La función <code class="keyword">inline</code> le
	ofrece todos los beneficios de una macro de preprocesador
	además de los beneficios de una verdadera llamada a
	función. Este capítulo explora minuciosamente la implementación
	y uso de las funciones <code class="keyword">inline</code>.
      </p>
      <p title="Capítulo 10: Control de nombres."><strong><a class="link" href="C10.html" title="10: Control de nombres">Capítulo 10: Control de nombres.</a> </strong>
	La elección de nombres es una actividad fundamental en la
	programación y, cuando un proyecto se vuelve grande, el número
	de nombres puede ser arrollador. C++ le permite un gran control
	de los nombres en función de su creación, visibilidad, lugar de
	almacenamiento y enlazado. Este capítulo muestra cómo se
	controlan los nombres en C++ utilizando dos técnicas. Primero,
	la palabra reservada <code class="keyword">static</code> se utiliza para controlar
	la visibilidad y enlazado, y se explora su significado especial
	para clases. Una técnica mucho más útil para controlar los
	nombres a nivel global es el <code class="keyword">namespace</code> de C++, que le
	permite dividir el espacio de nombres global en distintas
	regiones.
      </p>
      <p title="Capítulo 11: Las referencias y el constructor de copia."><strong><a class="link" href="C11.html" title="11: Las referencias y el constructor de copia">Capítulo 11: Las referencias y el
	  constructor de copia.</a> </strong>
	Los punteros de C++ trabajan como los punteros de C con el
	beneficio adicional de la comprobación de tipos más fuerte de
	C++. C++ también proporciona un método adicional para manejar
	direcciones: C++ imita la <span class="emphasis"><em>referencia</em></span> de
	Algol y Pascal, que permite al compilador manipular las
	direcciones, pero utilizando la notación ordinaria. También
	encontrará el constructor-de-copia, que controla la manera en
	que los objetos se pasan por valor hacia o desde las
	funciones. Finalmente, se explica el puntero-a-miembro de C++.
      </p>
      <p title="Capítulo 12: Sobrecarga de operadores."><strong><a class="link" href="C12.html" title="12: Sobrecarga de operadores">Capítulo 12: Sobrecarga de
      operadores.</a> </strong>
	Esta característica se llama algunas veces «azúcar
	sintáctico»; permite dulcificar la sintaxis de uso de su
	tipo permitiendo operadores así como llamadas a funciones. En
	este capítulo aprenderá que la sobrecarga de operadores sólo es
	un tipo de llamada a función diferente y aprenderá cómo escribir
	sus propios operadores, manejando el -a veces confuso- uso de los
	argumentos, devolviendo tipos, y la decisión de si implementar
	el operador como método o función amiga.
      </p>
      <p title="Capítulo 13: Creación dinámica de objetos."><strong><a class="link" href="C13.html" title="13: Creación dinámica de objetos">Capítulo 13: Creación dinámica de
      objetos.</a> </strong>
	¿Cuántos aviones necesitará manejar un sistema de tráfico aéreo?
	¿Cuántas figuras requerirá un sistema CAD? En el problema de la
	programación genérica, no se puede saber la cantidad, tiempo de
	vida o el tipo de los objetos que necesitará el programa una vez
	lanzado. En este capítulo aprenderá cómo <code class="keyword">new</code> y
	<code class="keyword">delete</code> solventan de modo elegante este problema en C++
	creando objetos en el montón. También verá cómo <code class="keyword">new</code> y
	<code class="keyword">delete</code> se pueden sobrecargar de varias maneras, de
	forma que puedan controlar cómo se asigna y se recupera el
	espacio de almacenamiento.
      </p>
      <p title="Capítulo 14: Herencia y composición."><strong><a class="link" href="C14.html" title="14: Herencia y Composición">Capítulo 14: Herencia y
      composición.</a> </strong>
	La abstracción de datos le permite crear tipos nuevos de la
	nada, pero con composición y herencia, se puede crear tipos
	nuevos a partir de los ya existentes. Con la composición, se puede
	ensamblar un tipo nuevo utilizando otros tipos como piezas
	y, con la herencia, puede crear una versión más específica de un
	tipo existente. En este capítulo aprenderá la sintaxis, cómo
	redefinir funciones y la importancia de la construcción y
	destrucción para la herencia y la composición.
      </p>
      <p title="Capítulo 15: Polimorfismo y funciones virtuales."><strong><a class="link" href="C15.html" title="15: Polimorfismo y Funciones virtuales">Capítulo 15: Polimorfismo y
	  funciones virtuales.</a> </strong>
	Por su cuenta, podría llevarle nueve meses descubrir y
	comprender esta piedra angular de la POO. A través de ejercicios
	pequeños y simples, verá cómo crear una familia de tipos con
	herencia y manipular objetos de esa familia mediante su clase
	base común. La palabra reservada <code class="keyword">virtual</code> le permite
	tratar todos los objetos de su familia de forma genérica, lo que
	significa que el grueso del código no depende de información de
	tipo específica. Esto hace extensibles sus programas, de manera
	que construir programas y mantener el código sea más sencillo y
	más barato.
      </p>
      <p title="Capítulo 16: Introducción a las plantillas."><strong><a class="link" href="C16.html" title="16: Introducción a las Plantillas">Capítulo 16: Introducción a las
      plantillas.</a> </strong>
	La herencia y la composición permiten reutilizar el código
	objeto, pero eso no resuelve todas las necesidades de
	reutilización. Las plantillas permiten reutilizar el código
	fuente proporcionando al compilador un medio para sustituir el
	nombre de tipo en el cuerpo de una clase o función. Esto da
	soporte al uso de bibliotecas de <span class="emphasis"><em>clase
	contenedor</em></span>, que son herramientas importantes para el
	desarrollo rápido y robusto de programas orientados a objetos
	(la Biblioteca Estándar de C++ incluye una biblioteca
	significativa de clases contenedor). Este capítulo ofrece una
	profunda base en este tema esencial.
      </p>
      <p>
      Temas adicionales (y materias más avanzadas) están disponibles en
      el Volumen 2 del libro, que se puede descargar del sitio web
      <a class="ulink" href="http://www.BruceEckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="pr02s04.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="pr02s04.html">4. Objetivos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="prefacio.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="pr02s06.html">6. Ejercicios</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="pr02s06.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
