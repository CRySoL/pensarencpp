<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>11.6. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C11.html" title="11: Las referencias y el constructor de copia" />
    <link rel="prev" href="ch11s05.html" title="11.5. Resumen" />
    <link rel="next" href="C12.html" title="12: Sobrecarga de operadores" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch11s05.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch11s05.html">11.5. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C11.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C12.html">12: Sobrecarga de operadores</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C12.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="11.6. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp7064904"></a>11.6. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	  Convierta el fragmento de código «bird &amp;
	    rock» del principio de este capítulo a un programa
	    C (utilizando estructuras para los tipos de datos), y que
	    compile.  Ahora intente compilarlo con un compilador de
	    C++ y vea qué ocurre.
	</p>
          </li>
          <li class="listitem">
            <p>
	    Coja los fragmentos de código al principio de la sección
	  titulada «Referencias en C++» y póngalos en un
	  <code class="function">main()</code>.  Añada sentencias para imprimir
	  en la salida para que pueda demostrar usted mismo que las
	  referencias son como punteros que se dereferencian
	  automáticamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba un programa en el cual intente (1) Crear una
	  referencia que no esté inicializada cuando se crea. (2)
	  Cambiar una referencia para que se refiera a otro objeto
	  después de que se haya inicializado. (3) Crear una
	  referencia nula.
	  </p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una función que tome un puntero por argumento,
	  modifique el contenido de lo que el apunta puntero, y
	  retorne ese mismo contenido como si de una referencia se
	  tratara.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una nueva clase con algunos métodos, y haga que el
	  objeto sea apuntado por el argumento del Ejercicio 4. Haga
	  que el puntero pasado como argumento y algunos métodos sean
	  constantes y pruebe que sólo puede llamar a los métodos
	  constantes dentro de su función. Haga que el argumento de su
	  función sea una referencia en vez de un puntero.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Coja los fragmentos de código al principio de la sección
	  «referencias a puntero» y conviértalos en un
	  programa.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una función que tome como argumento una referencia a
	  un puntero que apunta a otro puntero y modifique ese argumento. En
	  <code class="function">main()</code>, llame a la función.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una función que toma un argumento del tipo
	  <code class="type">char&amp;</code> y lo modifica. En el
	  <code class="function">main()</code> imprima a la salida una variable
	  <code class="type">char</code>, llame a su función con esa variable e
	  imprima la variable de nuevo para demostrar que ha sido cambiada.
	  ¿Cómo afecta esto a la legibilidad del programa?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una clase que tiene un método constante y otra que
	  no lo tiene. Escriba tres funciones que toman un objeto de
	  esa clase como argumento; la primera lo toma por valor, la
	  segunda lo toma por referencia y la tercera lo toma mediante
	  una referencia constante. Dentro de las funciones, intente
	  llamar a las dos funciones de su clase y explique los
	  resultados.
	</p>
          </li>
          <li class="listitem">
            <p>
	    (Algo difícil) Escriba una función simple que toma un
	    entero como argumento, incrementa el valor, y lo retorna. En
	    <code class="function">main()</code>, llame a su función. Intente que el
	    compilador genere el código ensamblador e intente entender cómo
	    los argumentos se pasan y se retornan, y cómo las variables locales
	    se colocan en la pila.
	  </p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una función que tome como argumentos un
	  <code class="type">char</code>, <code class="type">int</code>, <code class="type">float</code> y
	  <code class="type">double</code>. Genere el código ensamblador con su
	  compilador y busque las instrucciones que apilan los
	  argumentos en la pila antes de efectuar la llamada a
	  función.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una función que devuelva un <code class="type">double</code>.
	  Genere el código ensamblador y explique cómo se retorna el
	  valor.
	</p>
          </li>
          <li class="listitem">
            <p>
	    Genere el código ensamblador de
	    <code class="filename">PassingBigStructures.cpp</code>. Recorra y
	    desmitifique la manera en que su compilador genera el
	    código para pasar y devolver estructuras grandes.
	  </p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una simple función recursiva que disminuya su
	  argumento y retorne cero si el argumento llega a cero, o
	  en otro caso que se llame a sí misma. Genere el código
	  ensamblador para esta función y explique la forma en el
	  compilador implementa la recurrencia.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba código para demostrar que el compilador genera un
	  constructor de copia automáticamente en caso de que no lo
	  haga el programador. Demuestre que el constructor de copia
	  generado por el compilador realiza una copia bit a bit de
	  tipos primitivos y llama a los constructores de copia de los
	  tipos definidos por el usuario.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una clase en la que el constructor de copia se
	  anuncia a sí mismo a través de
	  <code class="varname">cout</code>. Ahora cree una función que pasa un
	  objeto de su nueva clase por valor y otra más que crea un
	  objeto local de su nueva clase y lo devuelve por valor.
	  Llame a estas funciones para demostrar que el constructor de
	  copia es, en efecto, llamado cuando se pasan y retornan
	  objetos por valor.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un objeto que contenga un <code class="type">double*</code>.  Que el
	  constructor inicialice el <code class="type">double*</code> llamando a
	  <code class="code">new double</code> y asignando un valor. Entonces, que
	  el destructor imprima el valor al que apunta, asigne ese
	  valor a -1, llame a <code class="keyword">delete</code> para liberar la memoria
	  y ponga el puntero a cero. Ahora cree una función que tome
	  un objeto de su clase por valor, y llame a esta función
	  desde <code class="function">main()</code>. ¿Qué ocurre?  Solucione
	  el problema escribiendo un constructor de copia.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase con un constructor que parezca un constructor
	  de copia, pero que tenga un argumento adicional con un valor
	  por defecto. Muestre que a pesar de eso se utiliza como
	  constructor de copia.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase con un constructor de copia que se anuncie a
	  sí mismo (es decir que imprima por la salida que ha sido
	  llamado).  Haga una segunda clase que contenga un objeto
	  miembro de la primera clase, pero no cree un constructor de
	  copia. Demuestre que el constructor de copia, que genera
	  automáticamente el compilador en la segunda clase, llama al
	  constructor de copia de la primera.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase muy simple, y una función que devuelva un
	  objeto de esa clase por valor. Cree una segunda función que
	  tome una referencia de un objeto de su clase. Llame a la
	  segunda función pasándole como argumento una llamada a la
	  primera función, y demuestre que la segunda función debe
	  utilizar una referencia constante como argumento.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase simple sin constructor de copia, y una
	  función simple que tome un objeto de esa clase por
	  valor. Ahora cambie su clase añadiéndole una declaración
	  (sólo declare, no defina) privada de un constructor de
	  copia. Explique lo que ocurre cuando compila la función.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Este ejercicio crea una alternativa a la utilización del
	  constructor de copia. Cree una clase
	  <code class="classname">X</code> y declare (pero no defina) un
	  constructor de copia privado. Haga una función
	  <code class="function">clone()</code> pública como un método
	  constante que devuelve una copia del objeto creado
	  utilizando <code class="keyword">new</code>. Ahora escriba una función que tome
	  como argumento un <code class="type">const X&amp;</code> y clone una
	  copia local que puede modificarse. El inconveniente de esto
	  es que es el programador el responsable de destruir
	  explícitamente el objeto clonado (utilizando
	  <code class="keyword">delete</code>) cuando haya terminado con él.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Explique qué está mal en <code class="filename">Mem.cpp</code> y
	  <code class="filename">MemTest.cpp</code> del <a class="link" href="C07.html" title="7: Sobrecarga de funciones y argumentos por defecto">Capítulo 7</a>. Solucione el problema.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un <code class="type">double</code> y una
	  función <code class="function">print()</code> que imprima el
	  <code class="type">double</code>. Cree punteros a miembro tanto
	  para el atributo como al método de su clase. Cree un objeto
	  de su clase y un puntero a ese objeto, y manipule ambos
	  elementos de la clase a través de los punteros a miembro,
	  utilizando tanto el objeto como el puntero al objeto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un array de enteros. ¿Puede
	  recorrer el array mediante un puntero a miembro?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">PmemFunDefinition.cpp</code>
	  añadiendo un método <code class="function">f()</code> sobrecargado
	  (puede determinar la lista de argumentos que cause la
	  sobrecarga).  Ahora cree un segundo puntero a miembro,
	  asígnelo a la versión sobrecargada de
	  <code class="function">f()</code>, y llame al método a través del
	  puntero. ¿Cómo sucede la resolución de la función
	  sobrecargada en este caso?
	</p>
          </li>
          <li class="listitem">
            <p>
	  Empiece con la función
	  <code class="filename">FunctionTable.cpp</code> del <a class="link" href="C03.html" title="3: C en C++">Capítulo 3</a>. Cree una clase que contenga
	  un <code class="type">vector</code> de punteros a funciones, con métodos
	  <code class="function">add()</code> y <code class="function">remove()</code>
	  para añadir y quitar punteros a función. Añada una función
	  denominada <code class="function">run()</code> que recorra el
	  <code class="type">vector</code> y llame a todas la funciones.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique el Ejercicio 27 para que funcione con punteros a
	  métodos.
	</p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch11s05.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch11s05.html">11.5. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C11.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C12.html">12: Sobrecarga de operadores</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C12.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
