<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>12.8. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C12.html" title="12: Sobrecarga de operadores" />
    <link rel="prev" href="ch12s07.html" title="12.7. Resumen" />
    <link rel="next" href="C13.html" title="13: Creación dinámica de objetos" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch12s07.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch12s07.html">12.7. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C12.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C13.html">13: Creación dinámica de objetos</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C13.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="12.8. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp7437328"></a>12.8. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
		  Cree una clase sencilla con un operador sobrecargado <code class="literal">++</code>. Intente
		  llamar a este operador en la forma prefija y postfija y vea qué clase de
		  advertencia obtiene del compilador.
		</p>
          </li>
          <li class="listitem">
            <p>
		  Cree una clase sencilla que contenga un <code class="type">int</code> y sobrecargue
		  el operador <code class="literal">+</code> como un método. Cree también un método
		  <code class="function">print()</code> que tome un
		  <code class="classname">ostream&amp;</code> como un argumento y lo imprima a
		  un <code class="classname">ostream&amp;</code>. Pruebe su clase para comprobar
		  que funciona correctamente.
		</p>
          </li>
          <li class="listitem">
            <p>
		  Añada un operador binario <code class="literal">-</code> al ejercicio 2 como un
		  método. Demuestre que puede usar sus objetos en expresiones complejas
		  como <code class="code">a + b -c</code>.
		</p>
          </li>
          <li class="listitem">
            <p>
		  Añada un operador <code class="literal">++</code> y otro <code class="literal">--</code> al ejercicio
	      2, ambos con las versiones prefijas y postfijas, tales que devuelvan
	      el objeto incrementado o decrementado. Asegúrese de que la versión
	      postfija devuelve el valor correcto.
	    </p>
          </li>
          <li class="listitem">
            <p>
		  Modifique los operadores de incremento y decremento del ejercicio 4
		  para que la versión prefija devuelva una referencia no <code class="keyword">const</code> y
		  la postfija devuelva un objeto <code class="keyword">const</code>. Muestre que funcionan
		  correctamente y explique porqué esto se puede hacer en la práctica.
	    </p>
          </li>
          <li class="listitem">
            <p>
		  Cambie la función <code class="function">print()</code> del ejercicio2 para que
		  use el operador sobrecargado <code class="literal">&lt;&lt;</code> como en
		  <code class="filename">IostreamOperatorOverloading.cpp</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique el ejercicio 3 para que los operadores <code class="literal">+</code> y
	  <code class="literal">-</code> no sean métodos. Demuestre que todavía funcionan
	  correctamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Añada el operador unario <code class="literal">-</code> al ejercicio 2 y demuestre que
	  funciona correctamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un único <code class="type">private
	    char</code>. Sobrecargue los operadores de flujos de entrada/salida
	    <code class="literal">&lt;&lt;</code> y <code class="literal">&gt;&gt;</code> (como en
	    <code class="filename">IostreamOperatorOverloading.cpp</code>) y pruébelos. Puede
	    probarlos con <code class="literal">fstreams</code>,
	    <code class="literal">stringstreams</code> y <code class="literal">cin</code> y
	    <code class="literal">cout</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Determine el valor constante ficticio que su compilador pasa
	  a los operadores postfijos <code class="literal">++</code> y
	  <code class="literal">--</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
		Escriba una clase <code class="classname">Number</code> que contenga un
		<code class="type">double</code> y añada operadores sobrecargados para
		<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code> y la
		asignación. Elija los valores de retorno para estas funciones para que
		las expresiones se puedan encadenar y que sea eficiente.
		Escriba una conversión automática de tipos <code class="type">operator int()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
		Modifique el ejercicio 11 para que use la <span class="emphasis"><em>optimización del
		valor de retorno</em></span>, si todavía no lo ha hecho.
	  </p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un puntero, y demuestre que si permite al
	  compilador sintetizar el operador <code class="literal">=</code> el resultado de usar ese
	  operador serán punteros que estarán solapados en la misma ubicación de
	  memoria. Ahora arregle el problema definiendo su propio operador
	  <code class="literal">=</code> y demuestre que corrige el solapamiento. Asegúrese que
	  comprueba la auto-asignación y que maneja el caso apropiadamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una clase llamada <code class="classname">Bird</code> que contenga un
	  miembro <code class="type">string</code> y un <code class="type">static int</code>. En el
	  constructor por defecto, use el <code class="type">int</code> para generar
	  automáticamente un identificador que usted construya en el
	  <code class="type">string</code> junto con el nombre de la clase(<code class="varname">Bird
	  #1</code>, <code class="varname">Bird #2</code>, etc). Añada un operador
	  <code class="literal">&lt;;&lt;</code> para flujos de salida para imprimir los objetos
	  <code class="classname">Bird</code>-Escriba un operador de asignación
	  <code class="literal">=</code> y un constructor de copia. En <code class="function">main()</code>
	  verifique que todo funciona correctamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba una clase llamada <code class="classname">BirdHouse</code> que contenga un
	  objeto, un puntero y una referencia para la clase
	  <code class="classname">Bird</code> del ejercicio 14. El constructor debería tomar
	  3 <code class="classname">Birds</code> como argumentos. Añada un operador
	  <code class="literal">&lt;&lt;</code> de flujo de salida para
	  <code class="classname">BirdHouse</code>. Deshabilite el operador de asignación
	  <code class="literal">=</code> y el constructor de copia. En <code class="function">main()</code>
	  verifique que todo funciona correctamente.
	</p>
          </li>
          <li class="listitem">
            <p>
		Añada un miembro de datos <code class="type">int</code> a <code class="classname">Bird</code>
		y a <code class="classname">BirdHouse</code> en el ejercicio 15. Añada
		operadores miembros <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code> y
		<code class="literal">/</code> que usen el miembro <code class="type">int</code> para realizar las
		operaciones en los respectivos miembros. Verifique que funcionan.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Repita el ejercicio 16 usando operadores no miembro.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Añada un operador <code class="literal">-</code> a <code class="filename">SmartPointer.cpp</code>
		y a <code class="filename">NestedSmartPointer.cpp</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
		Modifique <code class="filename">CopyingVsInitialization.cpp</code> para que
		todos los constructores impriman un mensaje que explique qué está
		pasando. Ahora verifique que las dos maneras de llamar al constructor de
		copia (la de asignación y la de paréntesis) son equivalentes.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Intente crear un operador no miembro <code class="literal">=</code> para una clase y vea qué clase
		de mensaje del compilador recibe.
	  </p>
          </li>
          <li class="listitem">
            <p>
		  Cree una clase con un operador de asignación que tenga un segundo argumento, un
		  <code class="classname">string</code> que tenga un valor por defecto que diga <code class="code">op =
		  call</code>. Cree una función que asigne un objeto de su clase a otro y muestre
		  que su operador de asignación es llamado correctamente.
		</p>
          </li>
          <li class="listitem">
            <p>
		En <code class="filename">CopyingWithPointers.cpp</code> elimine el operador
		<code class="literal">=</code> en <code class="classname">DogHouse</code> y muestre que el
		operador <code class="literal">=</code> sintetizado por el compilador copia
		correctamente <code class="classname">string</code> pero es simplemente un alias
		del puntero <code class="classname">Dog</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
		En <code class="filename">ReferenceCounting.cpp</code> añada un <code class="type">static
		  int</code> y un <code class="type">int</code> ordinario como atributos a
		  <code class="classname">Dog</code> y a <code class="classname">DogHouse</code>. En
		  todos los constructores para ambas clases, incremente el <code class="type">static
		  int</code> y asigne el resultado al <code class="type">int</code> ordinario para
		  mantener un seguimiento del número de objetos que están siendo
		  creados. Haga las modificaciones necesarias para que todas las
		  sentencias de impresión muestren los identificadores <code class="type">int</code>
		  de los objetos involucrados.
	</p>
          </li>
          <li class="listitem">
            <p>
		Cree una clase que contenga un <code class="classname">string</code> como
		atributo. Inicialice el <code class="classname">string</code> en el constructor,
		pero no cree un constructor de copia o un operador <code class="literal">=</code>. Haga
		una segunda clase que tenga un atributo de su primera clase; no cree un
		constructor de copia o un operador <code class="literal">=</code> para esta clase
		tampoco. Demuestre que el constructor de copia y el operador
		<code class="literal">=</code> son sintetizados correctamente por el compilador.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Combine las clases en <code class="filename">OverloadingUnaryOperators.cpp</code>
		y en <code class="filename">Integer.cpp</code>.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Modifique <code class="filename">PointerToMemmberOperator.cpp</code> añadiendo
		dos nuevas funciones miembro a <code class="classname">Dog</code> que no tomen
		argumentos y devuelvan <code class="type">void</code>. Cree y compruebe un operador
		sobrecargado <code class="literal">-&gt;*</code> que funcione con sus dos nuevas funciones.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Añada un operador <code class="literal">-&gt;*</code> a
		<code class="filename">NestedSmartPointer.cpp</code>.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Cree dos clases, <code class="classname">Apple</code> y
		<code class="classname">Orange</code>. En <code class="classname">Apple</code>, cree un
		constructor que tome una <code class="classname">Orange</code> como
		argumento. Cree una función que tome un <code class="classname">Apple</code> y
		llame a esa función con una una <code class="classname">Orange</code> para
		demostrar que funciona. Ahora haga explícito el constructor de
		<code class="classname">Apple</code> para demostrar que así se evita la
		conversión automática de tipos. Modifique la llamada a su función para
		que la la conversión se haga explícitamente y de ese modo, funcione.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Añada un operador global <code class="literal">*</code> a
		<code class="filename">ReflexivityInOverloading.cpp</code> y demuestre que es
		reflexivo.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Cree dos clases y un operador <code class="literal">+</code> y las funciones de
		conversión de tal manera que la adicción sea reflexiva para las dos
		clases.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Arregle <code class="filename">TypeConversionFanout.cpp</code> creando una
		función explícita para realizar la conversión de tipo, en lugar de uno
		de los operadores de conversión automáticos.
	  </p>
          </li>
          <li class="listitem">
            <p>
		Escriba un código simple que use los operadores <code class="literal">+</code>,
		<code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code> para
		<code class="type">double</code>. Imagine cómo el compilador genera el codigo
		ensamblador y mire el ensamblador que se genera en realidad para
		descubrir y explicar qué está ocurriendo «bajo el capó».
	  </p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch12s07.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch12s07.html">12.7. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C12.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C13.html">13: Creación dinámica de objetos</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C13.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
