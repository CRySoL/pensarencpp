<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>10.7. Ejercicios</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C10.html" title="10: Control de nombres" />
    <link rel="prev" href="ch10s06.html" title="10.6. Resumen" />
    <link rel="next" href="C11.html" title="11: Las referencias y el constructor de copia" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch10s06.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch10s06.html">10.6. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C10.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C11.html">11: Las referencias y el constructor de copia</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C11.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="10.7. Ejercicios">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp6784520"></a>10.7. Ejercicios</h2>
          </div>
        </div>
      </div>
      <p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p>
      <div class="orderedlist">
        <ol class="orderedlist" type="1">
          <li class="listitem">
            <p>
	  Cree una función con una variable estática que sea un
	  puntero (con un argumento por defecto igual cero).  Cuando
	  la función que realice la llamada proporcione un valor para
	  ese argumento se usará para apuntar al principio de un
	  array de <code class="type">int</code>. Si se llama a la función con el
	  argumento cero (utilizando el argumento por defecto), la
	  función devuelve el siguiente valor del array, hasta que
	  llegue a un valor <code class="literal">-1</code> en el array (que
	  actuará como señal de final). Experimente con esta función en
	  <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una función que devuelva el siguiente valor de una
	  serie de Fibonacci cada vez que sea llamada. Añada un
	  argumento que de tipo <code class="type">bool</code> con valor por
	  defecto <code class="keyword">false</code> tal que cuando el argumento valga
	  <code class="keyword">true</code> «reinicie» la función al
	  principio de la serie de Fibonacci. Experimente con esta función en
	  <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un array de
	  <code class="type">int</code>. Especifique la dimensión del array
	  utilizando <code class="code">static const int</code> dentro de la
	  clase. Añada una variable <code class="code">const int</code> e
	  inicialícela en la lista de inicialización del
	  constructor. Haga al constructor <code class="keyword">inline</code>. Añada un
	  atributo <code class="type">static int</code> e inicialícelo a un valor
	  específico. Añada un método estático que imprima el atributo
	  estático. Añada un miembro <code class="keyword">inline</code> llamado
	  <code class="function">print()</code> que imprima todos los valores
	  del array y que llame al método estático. Experimente con esta
	  clase en <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase llamada <code class="classname">Monitor</code> que
	  mantenga el registro del número de veces que ha sido llamado
	  su método <code class="function">incident()</code>. Añada un método
	  <code class="function">print()</code> que muestre por pantalla el
	  número de incidentes. Ahora cree una función global (no un
	  método) que contenga un objeto estático
	  <code class="classname">Monitor</code>. Cada vez que llame a la
	  función debe llamar a <code class="function">incident()</code>,
	  después al método <code class="function">print()</code> para sacar
	  por pantalla el contador de incidentes. Experimente con la función
	  en <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique la clase <code class="classname">Monitor</code> del
	  Ejercicio 4 de forma que pueda decrementar
	  (<code class="function">decrement()</code>) el contador de
	  incidentes. Cree una clase llamada
	  <code class="classname">Monitor2</code> que tome como argumento del
	  constructor un puntero a <code class="classname">Monitor1</code>, y
	  que almacene ese puntero y llame a
	  <code class="function">incident()</code> y
	  <code class="function">print()</code>. En el destructor para
	  <code class="classname">Monitor2</code>, llame a
	  <code class="function">decrement()</code> y
	  <code class="function">print()</code>. Cree ahora un objeto estático
	  de <code class="classname">Monitor2</code> dentro de una
	  función. Dentro de <code class="function">main()</code>, experimente
	  llamando y no llamando a la función para ver qué pasa con el
	  destructor de <code class="classname">Monitor2</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un objeto global de clase
	  <code class="classname">Monitor2</code> y vea qué sucede.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase con un destructor que imprima un mensaje y
	  después llame a <code class="function">exit()</code>. Cree un objeto
	  global de esa clase y vea qué pasa.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">StaticDestructors.cpp</code>, experimente
	  con el orden de llamada de los constructores y destructores
	  llamando a <code class="function">f()</code> y
	  <code class="function">g()</code> dentro de
	  <code class="function">main()</code> en diferentes órdenes. ¿Su
	  compilador inicializa los objetos de la forma correcta?
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">StaticDestructors.cpp</code>, pruebe el
	  manejo de errores por defecto de su implementación
	  convirtiendo la definición original de
	  <code class="varname">out</code> dentro de una declaración
	  <code class="keyword">extern</code>, y poniendo la definición real después de la
	  definición de <code class="varname">a</code> (donde el constructor de
	  <code class="classname">Obj</code> manda información a
	  <code class="varname">out</code>). Asegúrese que no hay ningún otro
	  programa importante funcionando en su máquina cuando ejecute
	  el código o que su máquina maneje las faltas robustamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Pruebe que las variables estáticas de fichero en los
	  archivos de cabecera no chocan entre sí cuando son incluidas
	  en más de un archivo <code class="filename">cpp</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una única clase que contenga un <code class="type">int</code>, un
	  constructor que inicialice el <code class="type">int</code> con su
	  argumento, un método que cambie el valor del
	  <code class="type">int</code> con su argumento y una función
	  <code class="function">print()</code> que muestre por pantalla el
	  <code class="type">int</code>. Coloque su clase en un archivo de cabecera
	  e incluya dicho archivo en dos archivos
	  <code class="filename">cpp</code>. En uno de ellos cree una instancia
	  de la clase y en la otra declare ese identificador como
	  <code class="keyword">extern</code> y pruebe dentro de
	  <code class="function">main()</code>. Recuerde, debe enlazar los dos
	  archivos objeto o de lo contrario el enlazador no encontrará
	  el objeto.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree la instancia del objeto del Ejercicio 11 como <code class="keyword">static</code> y
	  verifique que, debido a eso, el enlazador es incapaz de encontrarla.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Declare una función en un archivo de cabecera. Defina la
	  función en un archivo <code class="filename">cpp</code> y llámela
	  desde <code class="function">main()</code> en un segundo archivo
	  <code class="filename">cpp</code>. Compile y verifique que
	  funciona. Ahora cambie la definición de la función de forma
	  que sea <code class="keyword">static</code> y verifique que el enlazador no
	  puede encontrarla.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">Volatile.cpp</code> del Capítulo 8
	  para hacer que <code class="function">comm::isr()</code> funcione
	  realmente como una rutina de servicio de
	  interrupción. Pista: una rutina de servicio de interrupción
	  no toma ningún argumento.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Escriba y compile un único programa que utilice las palabras
	  clave <code class="keyword">auto</code> y <code class="keyword">register</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un archivo de cabecera que contenga un espacio de
	  nombres. Dentro del espacio de nombres cree varias
	  declaraciones de funciones. Cree ahora un segundo archivo de
	  cabecera que incluya el primero y continúe el espacio de
	  nombres, añadiendo varias declaraciones de funciones
	  más. Cree ahora un archivo <code class="filename">cpp</code> que
	  incluya el segundo archivo de cabecera. Cambie su espacio de
	  nombres a otro nombre (más corto). Dentro de una definición
	  de función, llame a una de sus funciones utilizando la
	  resolución de ámbito. Dentro de una definición de función
	  separada, escriba una directiva <code class="keyword">using</code> para
	  introducir su espacio de nombres en el ámbito de esa
	  función, y demuestre que no necesita utilizar la resolución
	  de ámbito para llamar a las funciones desde su espacio de
	  nombres.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un archivo de cabecera con un espacio de nombres sin
	  nombre. Incluya la cabecera en dos archivos
	  <code class="filename">cpp</code> diferentes y demuestre que un
	  espacio sin nombre es único para cada :unidad de traducción.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Utilizando el archivo de cabecera del Ejercicio 17,
	  demuestre que los nombres de un espacio de nombres sin
	  nombre están disponibles automáticamente en una :unidad de
	  traducción sin calificación.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Modifique <code class="filename">FriendInjection.cpp</code> para
	  añadir una definición para la función amiga y para llamar a
	  la función desde <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En <code class="filename">Arithmetic.cpp</code>, demuestre que la
	  directiva <code class="keyword">using</code> no se extiende fuera de la función en
	  la que fue creada.
    	</p>
          </li>
          <li class="listitem">
            <p>
	  Repare el problema de
	  <code class="filename">OverridingAmbiguity.cpp</code>, primero con
	  resolución de ámbito y luego, con una declaración
	  <code class="keyword">using</code> que fuerce al compilador a escojer uno de los
	  nombres de función idénticos.
    	</p>
          </li>
          <li class="listitem">
            <p>
	  En dos archivos de cabecera, cree dos espacios de nombres,
	  cada uno conteniendo una clase (con todas las definiciones
	  <code class="keyword">inline</code>) con idéntico nombre que el del otro espacio
	  de nombres. Cree un archivo <code class="filename">cpp</code> que
	  incluya ambos archivos. Cree una función y, dentro de la
	  función, utilice la directiva <code class="keyword">using</code> para introducir
	  ambos espacios de nombres. Pruebe a crear un objeto de la
	  clase y vea que sucede. Haga las directivas <code class="keyword">using</code>
	  globales (fuera de la función) para ver si existe alguna
	  diferencia. Repare el problema usando la resolución de
	  ámbito, y cree objetos de ambas clases.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repare el problema del Ejercicio 22 con una declaración
	  <code class="keyword">using</code> que fuerce al compilador a escojer uno de los
	  nombres de clase idénticos.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Extraiga las declaraciones de espacios de nombres de
	  <code class="filename">BobsSuperDuperLibrary.cpp</code> y
	  <code class="filename">UnnamedNamespaces.cpp</code> y póngalos en
	  archivos separados, dando un nombre al espacio de nombres
	  sin nombre en el proceso. En un tercer archivo de cabecera,
	  cree un nuevo espacio de nombres que combine los elementos
	  de los otros dos espacios de nombres con declaraciones
	  <code class="keyword">using</code>. En <code class="function">main()</code>, introduzca
	  su nuevo espacio de nombres con una directiva <code class="keyword">using</code>
	  y acceda a todos los elementos de su espacio de nombres.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree un archivo de cabecera que incluya
	  <code class="filename">&lt;string&gt;</code> y
	  <code class="filename">&lt;iostream&gt;</code> pero que no use ninguna
	  directiva <code class="keyword">using</code> ni ninguna declaración
	  <code class="keyword">using</code>. Añada guardas de inclusión como ha visto en
	  los archivos de cabecera del libro. Cree una clase con todas
	  las funciones <code class="keyword">inline</code> que muestre por pantalla el
	  <code class="type">string</code>. Cree un archivo
	  <code class="filename">cpp</code> y ejercite su clase en
	  <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un <code class="type">static double</code> y
	  <code class="type">long</code>. Escriba un método estático que imprima
	  los valores.
   	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un <code class="type">int</code>, un
	  constructor que inicialice el <code class="type">int</code> con su
	  argumento, y una función <code class="function">print()</code> que
	  muestre por pantalla el <code class="type">int</code>. Cree ahora una
	  segunda clase que contenga un objeto estático de la
	  primera. Añada un método estático que llame a la función
	  <code class="function">print()</code> del objeto estático.  Ejercitu
	  su clase en <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un array estático de
	  <code class="type">int</code> constante y otro no constante. Escriba
	  métodos estáticos que impriman los arrays. Experimente con su clase
	  en <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que contenga un <code class="type">string</code>, con un
	  constructor que inicialice el <code class="type">string</code> a partir
	  de su argumento, y una función <code class="function">print()</code>
	  que imprima el <code class="type">string</code>. Cree otra clase que
	  contenga un array estático, tanto constante como no
	  constante, de objetos de la primera clase, y métodos
	  estáticos para imprimir dichos arrays. Experimente con la
	  segunda clase en <code class="function">main()</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una <code class="keyword">struct</code> que contenga un <code class="type">int</code> y
	  un constructor por defecto que inicialice el
	  <code class="type">int</code> a cero.  Haga ese <code class="keyword">struct</code> local a
	  una función. Dentro de dicha función, cree un array de
	  objetos de su <code class="keyword">struct</code> y demuestre que cada
	  <code class="type">int</code> del array ha sido inicializado a cero
	  automáticamente.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Cree una clase que represente una conexión a impresora, y que
	  sólo le permita tener una impresora.
	</p>
          </li>
          <li class="listitem">
            <p>
	  En un archivo de cabecera, cree una clase
	  <code class="classname">Mirror</code> que contiene dos atributos:
	  un puntero a un objeto <code class="classname">Mirror</code> y un
	  <code class="type">bool</code>. Déle dos constructores: el constructor
	  por defecto inicializa el <code class="type">bool</code> a <code class="keyword">true</code>
	  y el puntero a <code class="classname">Mirror</code> a cero. El
	  segundo constructor toma como argumento un puntero a un
	  objeto <code class="classname">Mirror</code>, que asigna al puntero
	  interno del objeto; pone el <code class="type">bool</code> a
	  <code class="keyword">false</code>. Añada un método <code class="function">test()</code>:
	  si el puntero del objeto es distinto de cero, devuelve el
	  valor de <code class="function">test()</code> llamado a través del
	  puntero. Si el puntero es cero, devuelve el
	  <code class="type">bool</code>. Cree ahora cinco archivos
	  <code class="filename">cpp</code>, cada uno incluyendo la cabecera
	  <code class="classname">Mirror</code>. El primer archivo
	  <code class="filename">cpp</code> define un objeto
	  <code class="classname">Mirror</code> global utilizando el
	  constructor por defecto. El segundo archivo declara el
	  objeto del primer archivo como <code class="keyword">extern</code>, y define un
	  objeto <code class="classname">Mirror</code> global utilizando el
	  segundo constructor, con un puntero al primer objeto. Siga
	  haciendo lo mismo hasta que llegue al último archivo, que
	  también contendrá una definición de objeto global. En este
	  archivo, <code class="function">main()</code> debe llamar a la
	  función <code class="function">test()</code> e informar del
	  resultado. Si el resultado es <code class="keyword">true</code>, encuentre la
	  forma de cambiar el orden de enlazado de su enlazador y
	  cámbielo hasta que el resultado sea <code class="keyword">false</code>.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Repare el problema del Ejercicio 32 utilizando la técnica uno
          mostrada en este libro.
      	</p>
          </li>
          <li class="listitem">
            <p>
	  Repare el problema del Ejercicio 32 utilizando la técnica dos
	  mostrada en este libro.
	</p>
          </li>
          <li class="listitem">
            <p>
	  Sin incluir ningún archivo de cabecera, declare la función
	  <code class="function">puts()</code> de la Librería Estándar de C.
	  Llame a esa función desde <code class="function">main()</code>.
	</p>
          </li>
        </ol>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch10s06.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch10s06.html">10.6. Resumen</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C10.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="C11.html">11: Las referencias y el constructor de copia</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="C11.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
