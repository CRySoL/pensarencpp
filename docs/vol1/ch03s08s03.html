<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>3.8.3. Programas más claros gracias a enum</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="ch03s08.html" title="3.8. Creación de tipos compuestos" />
    <link rel="prev" href="ch03s08s02.html" title="3.8.2. Usar struct para combinar variables" />
    <link rel="next" href="ch03s08s04.html" title="3.8.4. Cómo ahorrar memoria con union" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s08s02.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s08s02.html">3.8.2. 
        Usar <code class="keyword">struct</code> para combinar variables
      </a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="ch03s08.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s08s04.html">3.8.4. Cómo ahorrar memoria con <code class="keyword">union</code></a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s08s04.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect2" title="3.8.3. Programas más claros gracias a enum">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a id="idp4847920"></a>3.8.3. Programas más claros gracias a <code class="keyword">enum</code></h3>
          </div>
        </div>
      </div>
      <p>
        Un tipo de datos enumerado es una manera de asociar nombres a
        números, y por consiguiente de ofrecer más significado a alguien
        que lea el código. La palabra reservada <code class="keyword">enum</code> (de C)
        enumera automáticamente cualquier lista de identificadores que
        se le pase, asignándoles valores de 0, 1, 2, etc. Se pueden
        declarar variables <code class="keyword">enum</code> (que se representan siempre
        como valores enteros). La declaración de un <code class="keyword">enum</code> se
        parece a la declaración de un <code class="keyword">struct</code>.
     </p>
      <p>
        Un tipo de datos enumerado es útil cuando se quiere poder seguir
        la pista de alguna característica:
      </p>
      <div class="example">
        <a id="idp4852080"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C03:Enum.cpp</span>
<span class="hl slc">// Keeping track of shapes</span>

<span class="hl kwb">enum</span> ShapeType <span class="hl opt">{</span>
  circle<span class="hl opt">,</span>
  square<span class="hl opt">,</span>
  rectangle
<span class="hl opt">};</span>  <span class="hl slc">// Must end with a semicolon like a struct</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ShapeType shape <span class="hl opt">=</span> circle<span class="hl opt">;</span>
  <span class="hl slc">// Activities here....</span>
  <span class="hl slc">// Now do something based on what the shape is:</span>
  <span class="hl kwa">switch</span><span class="hl opt">(</span>shape<span class="hl opt">) {</span>
    <span class="hl kwa">case</span> circle<span class="hl opt">:</span>  <span class="hl com">/* circle stuff */</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> square<span class="hl opt">:</span>  <span class="hl com">/* square stuff */</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> rectangle<span class="hl opt">:</span>  <span class="hl com">/* rectangle stuff */</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 3.48. C03/Enum.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
        <code class="varname">shape</code> es una variable del tipo de datos
        enumerado <code class="type">ShapeType</code>, y su valor se compara con el
        valor en la enumeración. Ya que <code class="varname">shape</code> es
        realmente un <code class="type">int</code>, puede albergar cualquier valor
        que corresponda a <code class="type">int</code> (incluyendo un número
        negativo). También se puede comparar una variable
        <code class="type">int</code> con un valor de una enumeración.
      </p>
      <p>
        Se ha de tener en cuenta que el ejemplo anterior de intercambiar
        los tipos tiende a ser una manera problemática de programar. C++
        tiene un modo mucho mejor de codificar este tipo de cosas, cuya
        explicación se pospondrá para mucho mas adelante en este libro.
     </p>
      <p>
        Si el modo en que el compilador asigna los valores no es de su
        agrado, puede hacerlo manualmente, como sigue:
      </p>
      <pre class="programlisting">
<span class="hl kwb">enum</span> ShapeType <span class="hl opt">{</span>
  circle <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">,</span> square <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">,</span> rectangle <span class="hl opt">=</span> <span class="hl num">50</span>
<span class="hl opt">};</span>
</pre>
      <p>
	Si da valores a algunos nombres y a otros no, el compilador
	utilizará el siguiente valor entero. Por ejemplo,
      </p>
      <pre class="programlisting">
<span class="hl kwb">enum</span> snap <span class="hl opt">{</span> crackle <span class="hl opt">=</span> <span class="hl num">25</span><span class="hl opt">,</span> pop <span class="hl opt">};</span>
</pre>
      <p>
        El compilador le da a <code class="varname">pop</code> el valor
        <code class="literal">26</code>.
     </p>
      <p>
        Es fácil comprobar que el código es más legible cuando se
        utilizan tipos de datos enumerados. No obstante, en cierto
        grado esto sigue siendo un intento (en C) de lograr las cosas
        que se pueden lograr con una <code class="keyword">class</code> en C++, y por eso
        verá que <code class="keyword">enum</code> se utiliza menos en C++.
      </p>
      <div class="sect3" title="Comprobación de tipos para enumerados">
        <div class="titlepage">
          <div>
            <div>
              <h4 class="title"><a id="idp4860024"></a>Comprobación de tipos para enumerados</h4>
            </div>
          </div>
        </div>
        <p>
          Las enumeraciones en C son bastante primitivas, simplemente
          asocian valores enteros a nombres, pero no aportan
          comprobación de tipos. En C++, como era de esperar a estas
          alturas, el concepto de tipos es fundamental, y eso se cumple
          con las enumeraciones. Cuando crea una enumeración nombrada,
          crea efectivamente un nuevo tipo, tal como se hace con una
          clase: El nombre de la enumeración se convierte en una palabra
          reservada durante esa unidad de traducción.
        </p>
        <p>
          Además, hay una comprobación de tipos mas estricta para la
          enumeración en C++ que en C. En particular, resulta evidente
          si tiene una instancia de la enumeración <code class="type">color</code>
          llamada <code class="varname">a</code>. En C puede decir
          <code class="code">a++</code>, pero en C++ no es posible. Eso se debe a que
          el incrementar una enumeración se realizan dos conversiones de
          tipo, una de ellas es legal en C++ y la otra no. Primero, el
          valor de la enumeración se convierte del tipo
          <code class="type">color</code> a <code class="type">int</code>, luego el valor se
          incrementa, y finalmente el <code class="type">int</code> se vuelve a
          convertir a tipo <code class="type">color</code>. En C++ esto no está
          permitido, porque <code class="type">color</code> es un tipo diferente de
          <code class="type">int</code>. Eso tiene sentido, porque ¿cómo saber si el
          incremento de <code class="literal">blue</code> siquiera estará en la
          lista de colores?  Si quiere poder incrementar un
          <code class="type">color</code>, debería ser una clase (con una operación
          de incremento) y no un <code class="keyword">enum,</code> porque en la clase se
          puede hacer de modo que sea mucho más seguro. Siempre que
          escriba código que asuma una conversión implícita a un tipo
          <code class="keyword">enum</code>, el compilador alertará de que se trata de una
          actividad inherentemente peligrosa.
        </p>
        <p>
          Las uniones (descriptas a continuación) tienen una comprobación
          adicional de tipo similar en C++.
        </p>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s08s02.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s08s02.html">3.8.2. 
        Usar <code class="keyword">struct</code> para combinar variables
      </a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="ch03s08.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s08s04.html">3.8.4. Cómo ahorrar memoria con <code class="keyword">union</code></a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s08s04.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
