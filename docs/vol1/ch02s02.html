<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>2.2. Herramientas para compilación modular</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="C02.html" title="2: Construir y usar objetos" />
    <link rel="prev" href="C02.html" title="2: Construir y usar objetos" />
    <link rel="next" href="ch02s02s02.html" title="2.2.2. Enlazado" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="C02.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="C02.html">2: Construir y usar objetos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch02s02s02.html">2.2.2. Enlazado</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch02s02s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect1" title="2.2. Herramientas para compilación modular">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="idp3995848"></a>2.2. Herramientas para compilación modular</h2>
          </div>
        </div>
      </div>
      <p>
      La compilación modular es particularmente importante cuando se
      construyen grandes proyectos. En C y en C++, un programa se puede
      crear en pequeñas piezas, manejables y comprobables de forma
      independiente. La herramienta más importante para dividir un
      programa en piezas más pequeñas es la capacidad de crear
      subrutinas o subprogramas que tengan un nombre que las
      identifique. En C y en C++, estos subprogramas se llamana
      <span class="emphasis"><em>funciones</em></span>, que son las piezas de código que
      se pueden almacenar en diferentes ficheros, permitiendo la
      compilación separada. Dicho de otra forma, una función es la
      unidad atómica de código, debido a que no se puede tener una parte
      de una función en un fichero y el resto en otro (aunque los
      ficheros pueden contener más de una función).
    </p>
      <p>
      Cuando se invoca una función, se le suelen pasar una serie de
      <span class="emphasis"><em>argumentos</em></span>, que son valores que desea que la
      función utilice durante su ejecución. Cuando la función termina,
      normalmente devuelve un <span class="emphasis"><em>valor de retorno</em></span>,
      que equivale al resultado. También es posible crear funciones que
      no tengan ni argumentos ni valor de retorno.
    </p>
      <p>
      Para crear un programa con múltiples ficheros, las funciones de un
      fichero deben acceder a las funciones y los datos de otros
      ficheros. Cuando se compila un fichero, el compilador de C o C++
      debe conocer las funciones y los datos de los otros ficheros, en
      particular sus nombres y su uso apropiado. El compilador asegura
      que las funciones y los datos son usados correctamente. El proceso
      de "decirle al compilador" los nombres de las funciones externas y
      los datos que necesitan es conocido como
      <span class="emphasis"><em>declaración</em></span>.  Una vez declarada una función o
      una variable, el compilador sabe cómo comprobar que la función se
      utiliza adecuadamente.
    </p>
      <div class="sect2" title="2.2.1. Declaraciones vs definiciones">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="idp4000600"></a>2.2.1. Declaraciones vs definiciones</h3>
            </div>
          </div>
        </div>
        <p>
      	Es importante comprender la diferencia entre
        <span class="emphasis"><em>declaraciones</em></span> y
        <span class="emphasis"><em>definiciones</em></span> porque estos términos se
        usarán de forma precisa en todo el libro. Básicamente todos los
        programas escritos en C o en C++ requieren declaraciones. Antes
        de poder escribir su primer programa, necesita comprender la
        manera correcta de escribir una declaración.
      </p>
        <p>
	Una <span class="emphasis"><em>declaración</em></span> presenta un nombre
	-identificador- al compilador. Le dice al compilador «Esta
	función o esta variable existe en algún lugar, y éste es el
	aspecto que debe tener». Una
	<span class="emphasis"><em>definición</em></span>, sin embargo, dice: «Crea
	esta variable aquí» o «Crea esta función
	aquí». Eso reserva memoria para el nombre. Este
	significado sirve tanto para una variable que para una función;
	en ambos casos, el compilador reserva espacio en el momento de
	la definición. Para una variable, el compilador determina su
	tamaño y reserva el espacio en memoria para contener los datos
	de la variable. Para una función, el compilador genera el código
	que finalmente ocupará un espacio en memoria.
      </p>
        <p>
	Se puede declarar una variable o una función en muchos sitios diferentes, pero en
	C o en C++ sólo se puede definir una vez (se conoce a veces como Regla de
	Definición Única (ODR)
	<sup>[<a id="idp4005088" href="#ftn.idp4005088" class="footnote">35</a>]</sup>). Cuando el enlazador une todos los módulos objeto,
	normalmente se quejará si encuentra más de una definición para
	la misma función o variable.
      </p>
        <p>
	Una definición puede ser también una declaración. Si el
	compilador no ha visto antes el nombre <code class="varname">x</code> y
	hay una definición <code class="code">int x;</code>, el compilador ve el
	nombre también como una declaración y asigna memoria al mismo
	tiempo.
      </p>
        <div class="sect3" title="Sintaxis de declaración de funciones">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp4007112"></a>Sintaxis de declaración de funciones</h4>
              </div>
            </div>
          </div>
          <p>
	  La declaración de una función en C y en C++ consiste en
	  escribir el nombre de la función, los tipos de argumentos que
	  se pasan a la función, y el valor de retorno de la misma. Por
	  ejemplo, aquí tenemos la declaración de una función llamada
	  <code class="function">func1()</code> que toma dos enteros como
	  argumentos (en C/C++ los enteros se denotan con la palabra
	  reservada <code class="type">int</code>) y que devuelve un entero:
	</p>
          <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">);</span>
</pre>
          <p>
	  La primera palabra reservada es el valor de retorno:
	  <code class="literal">int</code>. Los argumentos están encerrados
	  entre paréntesis después del nombre de la función en el
	  orden en que se utilizan. El punto y coma indica el final
	  de la sentencia; en este caso le dice al compilador
	  «esto es todo - ¡aquí no está la definición de la
	    función!».
	</p>
          <p>
	  Las declaraciones en C y C++ tratan de mimetizar la forma en
	  que se utilizará ese elemento. Por ejemplo, si
	  <code class="varname">a</code> es otro entero la función de arriba se
	  debería usar de la siguiente manera:
	</p>
          <pre class="programlisting">
a <span class="hl opt">=</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span>
</pre>
          <p>
	  Como <code class="function">func1()</code> devuelve un entero, el
	  compilador de C/C++ comprobará el uso de
	  <code class="function">func1()</code> para asegurarse que
	  <code class="varname">a</code> puede aceptar el valor devuelto y que
	  los argumentos son válidos.
	</p>
          <p>
	  Los argumentos de las declaraciones de funciones pueden tener
	  nombres. El compilador los ignora pero pueden ser útilies como
	  nemotécnicos para el usuario. Por ejemplo, se puede declarar
	  <code class="function">func1()</code> con una apariencia diferente pero
	  con el mismo significado:
	</p>
          <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> length<span class="hl opt">,</span> <span class="hl kwb">int</span> width<span class="hl opt">);</span>
</pre>
        </div>
        <div class="sect3" title="Una puntualización">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp4014520"></a>Una puntualización</h4>
              </div>
            </div>
          </div>
          <p>
	  Existe una diferencia significativa entre C y el C++
	  para las funciones con lista de argumentos vacía. En C, la
	  declaración:
	</p>
          <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func2</span><span class="hl opt">();</span>
</pre>
          <p>
	  significa «una funcion con cualquier número y tipo de
	  argumentos», lo cual anula la comprobación de tipos. En
	  C++, sin embargo, significa «una función sin
	  argumentos».
	</p>
        </div>
        <div class="sect3" title="Definición de funciones">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp4016720"></a>Definición de funciones</h4>
              </div>
            </div>
          </div>
          <p>
	  La definición de funciones se parece a la declaración
	  excepto en que tienen cuerpo. Un cuerpo es un conjunto de
	  sentencias encerradas entre llaves. Las llaves indican el
	  comienzo y el final del código. Para dar a
	  <code class="function">func1()</code> una definición con un cuerpo
	  vacío (un cuerpo que no contiene código), escriba:
	</p>
          <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> ancho<span class="hl opt">,</span> <span class="hl kwb">int</span> largo<span class="hl opt">) {}</span>
</pre>
          <p>
	  Note que en la definición de la función las llaves
	  sustituyen el punto y coma. Como las llaves contienen una
	  sentencia o grupo de sentencias, no es necesario un punto
	  y coma. Tenga en cuenta además que los argumentos en la
	  definición de la función deben nombres si los
	  quiere usar en el cuerpo de la función (como aquí no se
	  usan, son opcionales).
	</p>
        </div>
        <div class="sect3" title="Sintaxis de declaración de variables">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp4019552"></a>Sintaxis de declaración de variables</h4>
              </div>
            </div>
          </div>
          <p>
	  El significado atribuido a la frase «declaración de
	  variables» históricamente ha sido confuso y
	  contradictorio, y es importante que entienda el significado
	  correcto para poder leer el código correctamente. Una
	  declaración de variable dice al compilador cómo es la
	  variable. Dice al compilador, «Sé que no has visto este
	  nombre antes, pero te prometo que existe en algún lugar, y que
	  es una variable de tipo X».
	</p>
          <p>
	  En una declaración de función, se da un tipo (el valor de
	  retorno), el nombre de la función, la lista de argumentos, y
	  un punto y coma. Con esto el compilador ya tiene suficiente
	  información para saber cómo será la función. Por inferencia,
	  una declaración de variable consistirá en un tipo seguido por
	  un nombre. Por ejemplo:
	</p>
          <pre class="programlisting">
<span class="hl kwb">int</span> a<span class="hl opt">;</span>
</pre>
          <p>
	  podría declarar la variable <code class="varname">a</code> como un
	  entero usando la lógica usada anteriormente. Pero aquí está el
	  conflicto: existe suficiente información en el código anterior
	  como para que el compilador pueda crear espacio para un entero
	  llamado <code class="varname">a</code> y es exactamente lo que
	  ocurre. Para resolver el dilema, fue necesaria una palabra
	  reservada en C y C++ para decir «Esto es sólo una
	  declaración; esta variable estará definida en algún otro
	  lado». La palabra reservada es <code class="keyword">extern</code> que
	  puede significar que la definición es externa al fichero, o
	  que la definición se encuentra después en este fichero.
	</p>
          <p>
	  Declarar una variable sin definirla implica usar la palabra
	  reservada <code class="keyword">extern</code> antes de una descripción de la
	  variable, como por ejemplo:
	</p>
          <pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> a<span class="hl opt">;</span>
</pre>
          <p>
	  <code class="keyword">extern</code> también se puede aplicar a la declaración de
	  funciones. Para <code class="function">func1()</code> sería algo así:
	</p>
          <pre class="programlisting">
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> length<span class="hl opt">,</span> <span class="hl kwb">int</span> width<span class="hl opt">);</span>
</pre>
          <p>
	  Esta sentencia es equivalente a las declaraciones anteriores
	  para <code class="function">func1()</code> . Como no hay cuerpo de
	  función, el compilador debe tratarla como una declaración de
	  función en lugar de como definición. La palabra reservada
	  <code class="keyword">extern</code> es bastante superflua y opcional para la
	  declaración de funciones. Probablemente sea desafortunado que
	  los diseñadores de C no obligaran al uso de <code class="keyword">extern</code>
	  para la declaración de funciones; hubiera sido más consistente
	  y menos confuso (pero hubiera requerido teclear más, lo cual
	  probablemente explica la decisión).
	</p>
          <p>
	  Aquí hay algunos ejemplos más de declaraciones:
	</p>
          <div class="example">
            <a id="idp4030376"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C02:Declare.cpp</span>
<span class="hl slc">// Declaration &amp; definition examples</span>
<span class="hl kwc">extern</span> <span class="hl kwb">int</span> i<span class="hl opt">;</span> <span class="hl slc">// Declaration without definition</span>
<span class="hl kwc">extern</span> <span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">);</span> <span class="hl slc">// Function declaration</span>

<span class="hl kwb">float</span> b<span class="hl opt">;</span>  <span class="hl slc">// Declaration &amp; definition</span>
<span class="hl kwb">float</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">float</span> a<span class="hl opt">) {</span>  <span class="hl slc">// Definition</span>
  <span class="hl kwa">return</span> a <span class="hl opt">+</span> <span class="hl num">1.0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> i<span class="hl opt">;</span> <span class="hl slc">// Definition</span>
<span class="hl kwb">int</span> <span class="hl kwd">h</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl slc">// Declaration &amp; definition</span>
  <span class="hl kwa">return</span> x <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  b <span class="hl opt">=</span> <span class="hl num">1.0</span><span class="hl opt">;</span>
  i <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
  <span class="hl kwd">h</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 2.1. C02/Declare.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
          En la declaración de funciones, los identificadores de los argumentos
          son opcionales. En la definición son necesarios (los identificadores
          se requieren solamente en C, no en C++).
        </p>
        </div>
        <div class="sect3" title="Incluir ficheros de cabecera">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp4032384"></a>Incluir ficheros de cabecera</h4>
              </div>
            </div>
          </div>
          <p>
          La mayoría de las librerías contienen un número importante de
          funciones y variables. Para ahorrar trabajo y asegurar la
          consistencia cuando se hacen declaraciones externas para estos
          elementos, C y C++ utilizan un artefacto llamado
          <span class="emphasis"><em>fichero de cabecera</em></span>. Un fichero de
          cabecera es un fichero que contiene las declaraciones externas
          de una librería; convencionalmente tiene un nombre de fichero
          con extensión <code class="filename">.h</code>, como
          <code class="filename">headerfile.h</code> (no es difícil encontrar
          código más antiguo con extensiones diferentes, como
          <code class="filename">.hxx</code> o <code class="filename">.hpp</code>, pero es
          cada vez más raro).
        </p>
          <p>
          El programador que crea la librería proporciona el fichero de
          cabecera. Para declarar las funciones y variables externas de
          la librería, el usuario simplemente incluye el fichero de
          cabecera. Para ello se utiliza la directiva de preprocesado
          <code class="keyword">#include</code>. Eso le dice al preprocesador que abra el
          fichero de cabecera indicado e incluya el contenido en el
          lugar donde se encuentra la sentencia <code class="keyword">#include</code>. Un
          <code class="keyword">#include</code> puede indicar un fichero de dos maneras:
          mediante paréntesis angulares ( &lt; &gt; ) o comillas dobles.
	</p>
          <p>
          Los ficheros entre paréntesis angulares, como:
        </p>
          <pre class="programlisting">
<span class="hl ppc">#include &lt;header&gt;</span>
</pre>
          <p>
          hacen que el preprocesador busque el fichero como si fuera
          particular a un proyecto, aunque normalmente hay un camino de
          búsqueda que se especifica en el entorno o en la línea de
          comandos del compilador. El mecanismo para cambiar el camino
          de búsqueda (o ruta) varía entre maquinas, sistemas
          operativos, e implementaciones de C++ y puede que requiera un
          poco de investigación por parte del programador.
        </p>
          <p>
          Los ficheros entre comillas dobles, como:
        </p>
          <pre class="programlisting">
<span class="hl ppc">#include</span> <span class="hl pps">&quot;header&quot;</span><span class="hl ppc"></span>
</pre>
          <p>
          le dicen al preprocesador que busque el fichero en (de acuerdo a la
          especificación) «un medio de definición de
          implementación», que normalmente significa buscar el fichero de
          forma relativa al directorio actual. Si no lo encuentra, entonces la
          directiva se preprocesada como si tuviera paréntesis angulares
          en lugar de comillas.
        </p>
          <p>
          Para incluir el fichero de cabecera
          <code class="filename">iostream</code>, hay que escribir:
        </p>
          <pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
</pre>
          <p>
          El preprocesador encontrará el fichero de cabecera
          <code class="filename">iostream</code> (a menudo en un subdirectorio llamado
          «include») y lo incluirá.
        </p>
        </div>
        <div class="sect3" title="Formato de inclusión del estándar C++">
          <div class="titlepage">
            <div>
              <div>
                <h4 class="title"><a id="idp4043744"></a>Formato de inclusión del estándar C++</h4>
              </div>
            </div>
          </div>
          <p>
	  A medida que C++ evolucionaba, los diferentes fabricantes de
	  compiladores elegían diferentes extensiones para los nombres
	  de ficheros. Además, cada sistema operativo tiene sus propias
	  restricciones para los nombres de ficheros, en particular la
	  longitud. Estas características crearon problemas de
	  portabilidad del código fuente. Para limar estos problemas, el
	  estándar usa un formato que permite los nombres de ficheros
	  más largos que los famosos ocho caracteres y permite eliminar
	  la extensión. Por ejemplo en vez de escribir
	  <code class="filename">iostream.h</code> en el estilo antiguo, que se
	  asemejaría a algo así:
	</p>
          <pre class="programlisting">
<span class="hl ppc">#include &lt;iostream.h&gt;</span>
</pre>
          <p>
	  ahora se puede escribir:
	</p>
          <pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
</pre>
          <p>
	  El traductor puede implementar la sentencia del
	  <code class="keyword">include</code> de tal forma que se amolde a las necesidades
	  de un compilador y sistema operativo particular, aunque sea
	  necesario truncar el nombre y añadir una
	  extensión. Evidentemente, también puede copiar las cabeceras
	  que ofrece el fabricante de su compilador a otras sin
	  extensiones si quiere usar este nuevo estilo antes de que su
	  fabricante lo soporte.
	</p>
          <p>
	  Las librerías heredadas de C aún están disponibles con la
	  extensión tradicional
	  «<code class="filename">.h</code>». Sin embargo, se pueden
	  usar con el estilo de inclusión más moderno colocando una
	  «<span class="emphasis"><em>c</em></span>» al nombre. Es decir:
	</p>
          <pre class="programlisting">
<span class="hl ppc">#include &lt;stdio.h&gt;</span>
<span class="hl ppc">#include &lt;stdlib.h&gt;</span>
</pre>
          <p>
	  Se transformaría en:
	</p>
          <pre class="programlisting">
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
</pre>
          <p>
          Y así para todas cabeceras del C Estándar. Eso proporciona al
          lector una distinción interesante entre el uso de librerías C
          versus C++.
	</p>
          <p>
          El efecto del nuevo formato de include no es idéntico al
          antiguo: usar el «<code class="filename">.h</code>» da
          como resultado una versión más antigua, sin plantillas, y
          omitiendo el «<code class="filename">.h</code>» le ofrece
          la nueva versión con plantillas. Normalmente podría tener
          problemas si intenta mezclar las dos formas de inclusión en un
          mismo programa.
        </p>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp4005088" href="#idp4005088" class="para">35</a>] </sup>
	    <span class="foreignphrase"><em class="foreignphrase">One Definition Rule</em></span>
	  </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="C02.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="C02.html">2: Construir y usar objetos</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="C02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch02s02s02.html">2.2.2. Enlazado</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch02s02s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
