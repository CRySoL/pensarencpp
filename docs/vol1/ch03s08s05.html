<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>3.8.5. Arrays</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 1)" />
    <link rel="up" href="ch03s08.html" title="3.8. Creación de tipos compuestos" />
    <link rel="prev" href="ch03s08s04.html" title="3.8.4. Cómo ahorrar memoria con union" />
    <link rel="next" href="ch03s09.html" title="3.9. Consejos para depuración" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s08s04.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s08s04.html">3.8.4. Cómo ahorrar memoria con <code class="keyword">union</code></a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="ch03s08.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s09.html">3.9. Consejos para depuración</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s09.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="sect2" title="3.8.5. Arrays">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a id="idp4880952"></a>3.8.5. Arrays</h3>
          </div>
        </div>
      </div>
      <p>
	Los vectores son un tipo compuesto porque permiten
	agrupar muchas variables, una a continuación de la otra,
	bajo un identificador único. Si dice:
      </p>
      <pre class="programlisting">
<span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
</pre>
      <p>
        Se crea espacio para 10 variables <code class="type">int</code> colocadas una
        después de la otra, pero sin identificadores únicos para cada
        variable. En su lugar, todas están englobadas por el nombre
        <code class="varname">a</code>.
     </p>
      <p>
        Para acceder a cualquiera de los <span class="emphasis"><em>elementos del
        vector</em></span>, se utiliza la misma sintaxis de corchetes que
        se utiliza para definir el vector:
      </p>
      <pre class="programlisting">
a<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">] =</span> <span class="hl num">47</span><span class="hl opt">;</span>
</pre>
      <p>
        Sin embargo, debe recordar que aunque el tamaño de
        <code class="varname">a</code> es <code class="literal">10</code>, se seleccionan
        los elementos del vector comenzando por cero (esto se llama a
        veces <span class="emphasis"><em>indexado a cero</em></span><sup>[<a id="idp4885048" href="#ftn.idp4885048" class="footnote">42</a>]</sup>, de modo que sólo se pueden seleccionar los
        elementos del vector de 0 a 9, como sigue:
      </p>
      <div class="example">
        <a id="idp4885840"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C03:Arrays.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> <span class="hl num">10</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> <span class="hl opt">&lt;&lt;</span> a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 3.50. C03/Arrays.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
        Los accesos a vectores son extremadamente rápidos, Sin embargo,
        si se indexa más allá del final del vector, no hay ninguna red
        de seguridad - se entrará en otras variables. La otra desventaja
        es que se debe definir el tamaño del vector en tiempo de
        compilación; si se quiere cambiar el tamaño en tiempo de
        ejecución no se puede hacer con la sintaxis anterior (C tiene
        una manera de crear un vector dinámicamente, pero es
        significativamente más sucia). El <code class="classname">vector</code>
        de C++ presentado en el capítulo anterior, proporciona un objeto
        parecido al vector que se redimensiona automáticamente , de modo
        que es una solución mucho mejor si el tamaño del vector no puede
        conocer en tiempo de compilación.
     </p>
      <p>
        Se puede hacer un vector de cualquier tipo, incluso de
        <code class="keyword">struct</code>s:
      </p>
      <div class="example">
        <a id="idp4889320"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C03:StructArray.cpp</span>
<span class="hl slc">// An array of struct</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">,</span> j<span class="hl opt">,</span> k<span class="hl opt">;</span>
<span class="hl opt">}</span> ThreeDpoint<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ThreeDpoint p<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    p<span class="hl opt">[</span>i<span class="hl opt">].</span>i <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
    p<span class="hl opt">[</span>i<span class="hl opt">].</span>j <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">;</span>
    p<span class="hl opt">[</span>i<span class="hl opt">].</span>k <span class="hl opt">=</span> i <span class="hl opt">+</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 3.51. C03/StructArray.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
        Fíjese como el identificador de <code class="keyword">struct</code>
        <code class="varname">i</code> es independiente del <code class="varname">i</code>
        del bucle <code class="keyword">for</code>.
     </p>
      <p>
        Para comprobar que cada elemento del vector es contiguo con el
        siguiente, puede imprimir la dirección de la siguiente manera:
      </p>
      <div class="example">
        <a id="idp4892512"></a>
        <div class="example-contents">
          <pre class="programlisting">
<span class="hl slc">//: C03:ArrayAddresses.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(int) = &quot;</span><span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;a[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> 
         <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)&amp;</span>a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
        </div>
        <p class="title">
          <strong>Listado 3.52. C03/ArrayAddresses.cpp</strong>
        </p>
      </div>
      <br class="example-break" />
      <p>
	Cuando se ejecuta este programa, se ve que cada elemento está
	separado por el tamaño de un <code class="type">int</code> del anterior. Esto
	significa, que están colocados uno a continuación del otro.
      </p>
      <div class="sect3" title="Punteros y arrays">
        <div class="titlepage">
          <div>
            <div>
              <h4 class="title"><a id="idp4894416"></a>Punteros y arrays</h4>
            </div>
          </div>
        </div>
        <p>
	  El identificador de un vector es diferente de los
	  identificadores de las variables comunes. Un identificador de
	  un vector no es un <span class="emphasis"><em>lvalue</em></span>; no se le puede
	  asignar nada. En realidad es FIXME:gancho dentro de la
	  sintaxis de corchetes, y cuando se usa el nombre de un vector,
	  sin los corchetes, lo que se obtiene es la dirección inicial
	  del vector:
        </p>
        <div class="example">
          <a id="idp4895736"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:ArrayIdentifier.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;a = &quot;</span> <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;a[0] =&quot;</span> <span class="hl opt">&lt;&lt; &amp;</span>a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.53. C03/ArrayIdentifier.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          Cuando se ejecuta este programa, se ve que las dos direcciones
          (que se imprimen en hexadecimal, ya que no se moldea a
          <code class="type">long</code>) son las misma.
        </p>
        <p>
          De modo que una manera de ver el identificador de un vector es
          como un puntero de sólo lectura al principio de éste. Y aunque
          no se pueda hacer que el identificador del vector apunte a
          cualquier otro sitio, se puede crear otro puntero y utilizarlo
          para moverse dentro del vector. De hecho, la sintaxis de
          corchetes también funciona con punteros convencionales:
        </p>
        <div class="example">
          <a id="idp4898432"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:PointersAndBrackets.cpp</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    ip<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> <span class="hl num">10</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.54. C03/PointersAndBrackets.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          El hecho de que el nombre de un vector produzca su dirección
          de inicio resulta bastante importante cuando hay que pasar un
          vector a una función. Si declara un vector como un argumento
          de una función, lo que realmente está declarando es un
          puntero. De modo que en el siguiente ejemplo,
          <code class="function">fun1()</code> y <code class="function">func2()</code>
          tienen la misma lista de argumentos:
        </p>
        <div class="example">
          <a id="idp4901064"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:ArrayArguments.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">func1</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">[],</span> <span class="hl kwb">int</span> size<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> i <span class="hl opt">-</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">func2</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">*</span> a<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i <span class="hl opt">*</span> i <span class="hl opt">+</span> i<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">[],</span> string name<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> size<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> name <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> 
         <span class="hl opt">&lt;&lt;</span> a<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">],</span> b<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">];</span>
  <span class="hl slc">// Probably garbage values:</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl slc">// Initialize the arrays:</span>
  <span class="hl kwd">func1</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">func1</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl slc">// Notice the arrays are always modified:</span>
  <span class="hl kwd">func2</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">func2</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.55. C03/ArrayArguments.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          A pesar de que <code class="function">func1()</code> y
          <code class="function">func2()</code> declaran sus argumentos de
          distinta forma, el uso es el mismo dentro de la función. Hay
          otros hechos que revela este ejemplo: los vectores no se pueden
          pasados por valor<sup>[<a id="idp4905224" href="#ftn.idp4905224" class="footnote">43</a>]</sup>, es decir, que nunca se puede obtener
          automáticamente una copia local del vector que se pasa a una
          función. Por eso, cuando se modifica un vector, siempre se
          está modificando el objeto externo. Eso puede resultar un poco
          confuso al principio, si lo que se espera es el paso-por-valor
          como en los argumentos ordinarios.
        </p>
        <p>
          Fíjese que <code class="function">print()</code> utiliza la sintaxis de
          corchetes para los argumentos de tipo vector. Aunque la
          sintaxis de puntero y la sintaxis de corchetes efectivamente
          es la mismo cuando se están pasando vectores como argumentos,
          la sintaxis de corchetes deja más clara al lector que se
          pretende enfatizar que dicho argumento es un vector.
        </p>
        <p>
          Observe también que el argumento <code class="varname">size</code> se
          pasa en cada caso. La dirección no es suficiente información
          al pasar un vector; siempre se debe ser posible obtener el
          tamaño del vector dentro de la función, de manera que no se
          salga de los límites de dicho vector.
        </p>
        <p>
          Los vectores pueden ser de cualquier tipo, incluyendo vectores
          de punteros. De hecho, cuando se quieren pasar argumentos de
          tipo línea de comandos dentro del programa, C y C++ tienen una
          lista de argumentos especial para <code class="function">main()</code>,
          que tiene el siguiente aspecto:
        </p>
        <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span> <span class="hl slc">// ...</span>
</pre>
        <p>
          El primer argumento es el número de elementos en el vector,
          que es el segundo argumento. El segundo argumento es siempre
          un vector de <code class="type">char*</code>, porque los argumentos se
          pasan desde la línea de comandos como vectores de caracteres
          (y recuerde, un vector sólo se puede pasar como un
          puntero). Cada bloque de caracteres delimitado por un espacio
          en blanco en la línea de comandos se aloja en un elemento
          separado en el vector. El siguiente programa imprime todos los
          argumentos de línea de comandos recorriendo el vector:
        </p>
        <div class="example">
          <a id="idp4913760"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:CommandLineArgs.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;argc = &quot;</span> <span class="hl opt">&lt;&lt;</span> argc <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> argc<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;argv[&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;] = &quot;</span> 
         <span class="hl opt">&lt;&lt;</span> argv<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.56. C03/CommandLineArgs.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          Observe que <code class="code">argv[0]</code> es la ruta y el nombre del
          programa en sí mismo. Eso permite al programa descubrir
          información de sí mismo. También añade un argumento más al
          vector de argumentos del programa, de modo que un error común
          al recoger argumentos de línea de comandos es tomar argv[0]
          como si fuera el primer argumento.
        </p>
        <p>
          No es obligatorio utilizar <code class="varname">argc</code> y
          <code class="varname">argv</code> como identificadores de los parámetros
          de <code class="function">main()</code>; estos identificadores son sólo
          convenciones (pero puede confundir al lector si no se
          respeta). También, hay un modo alternativo de declarar argv:
        </p>
        <pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">**</span> argv<span class="hl opt">) {</span> <span class="hl slc">// ...</span>
</pre>
        <p>
          Las dos formas son equivalentes, pero la versión utilizada en
          este libro es la más intuitiva al leer el código, ya que dice,
          directamente, «Esto es un vector de punteros a
          carácter».
        </p>
        <p>
          Todo lo que se obtiene de la línea de comandos son vectores de
          caracteres; si quiere tratar un argumento como algún otro
          tipo, ha de convertirlos dentro del programa. Para facilitar
          la conversión a números, hay algunas funciones en la librería
          de C Estándar, declaradas en <code class="filename">&lt;cstdlib&gt;</code>. Las más fáciles de
          utilizar son <code class="function">atoi()</code>,
          <code class="function">atol()</code>, y <code class="function">atof()</code>
          para convertir un vector de caracteres ASCII a
          <code class="type">int</code>, <code class="type">long</code> y <code class="type">double</code>,
          respectivamente. A continuación, un ejemplo utilizando
          <code class="function">atoi()</code> (las otras dos funciones se
          invocan del mismo modo):
        </p>
        <div class="example">
          <a id="idp4922224"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:ArgsToInts.cpp</span>
<span class="hl slc">// Converting command-line arguments to ints</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> argc<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">atoi</span><span class="hl opt">(</span>argv<span class="hl opt">[</span>i<span class="hl opt">]) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.57. C03/ArgsToInts.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          En este programa, se puede poner cualquier número de
          argumentos en la línea de comandos. Fíjese que el bucle
          <code class="keyword">for</code> comienza en el valor <code class="literal">1</code> para
          saltar el nombre del programa en
          <code class="code">argv[0]</code>. También, si se pone un número decimal
          que contenga un punto decimal en la línea de comandos,
          <code class="function">atoi()</code> sólo toma los dígitos hasta el
          punto decimal. Si pone valores no numéricos en la línea de
          comandos, <code class="function">atoi()</code> los devuelve como ceros.
        </p>
      </div>
      <div class="sect3" title="El formato de punto flotante">
        <div class="titlepage">
          <div>
            <div>
              <h4 class="title"><a id="idp4926288"></a>El formato de punto flotante</h4>
            </div>
          </div>
        </div>
        <p>
          La función <code class="function">printBinary()</code> presentada
          anteriormente en este capítulo es útil para indagar en la
          estructura interna de varios tipos de datos. El más
          interesante es el formato de punto-flotante que permite a C y
          C++ almacenar números que representan valores muy grandes y
          muy pequeños en un espacio limitado. Aunque los detalles no se
          pueden exponer completamente expuestos, los bits dentro de los
          <code class="type">float</code>s y <code class="type">double</code>s están divididos en
          tres regiones: el exponente, la mantisa, y el bit de signo;
          así almacena los valores utilizando notación científica. El
          siguiente programa permite jugar con ello imprimiendo los
          patrones binarios de varios números en punto-flotante de modo
          que usted mismo pueda deducir el esquema del formato de punto
          flotante de su compilador (normalmente es el estándar IEEE
          para números en punto-flotante, pero su compilador puede no
          seguirlo):
        </p>
        <div class="example">
          <a id="idp4928912"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:FloatingAsBinary.cpp</span>
<span class="hl slc">//{L} printBinary</span>
<span class="hl slc">//{T} 3.14159</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;printBinary.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">!=</span> <span class="hl num">2</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Must provide a number&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">double</span> d <span class="hl opt">=</span> <span class="hl kwd">atof</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwb">unsigned char</span><span class="hl opt">*</span> cp <span class="hl opt">=</span> 
    <span class="hl kwa">reinterpret_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">unsigned char</span><span class="hl opt">*&gt;(&amp;</span>d<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">)-</span><span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">;</span> i <span class="hl opt">-=</span> <span class="hl num">2</span><span class="hl opt">){</span>
    <span class="hl kwd">printBinary</span><span class="hl opt">(</span>cp<span class="hl opt">[</span>i<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">]);</span>
    <span class="hl kwd">printBinary</span><span class="hl opt">(</span>cp<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.58. C03/FloatingAsBinary.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          Primero, el programa garantiza que se le haya pasado un
          argumento comprobando el valor de <code class="varname">argc</code>, que
          vale dos si hay un solo argumento (es uno si no hay
          argumentos, ya que el nombre del programa siempre es el primer
          elemento de <code class="varname">argv</code>). Si eso falla, imprime un
          mensaje e invoca la función <code class="function">exit()</code> de la
          librería Estándar de C para finalizar el programa.
        </p>
        <p>
          El programa toma el argumento de la línea de comandos y
          convierte los caracteres a <code class="type">double</code> utilizando
          <code class="function">atof()</code>. Luego el <code class="type">double</code> se
          trata como un vector de bytes tomando la dirección y
          moldeándola a un <code class="type">unsigned char*</code>. Para cada uno de
          estos bytes se llama a <code class="function">printBinary()</code> para
          mostrarlos.
        </p>
        <p>
          Este ejemplo se ha creado para imprimir los bytes en un orden
          tal que el bit de signo aparece al principio - en mi
          máquina. En otras máquinas puede ser diferente, por lo que
          puede querer re-organizar el modo en que se imprimen los
          bytes. También debería tener cuidado porque los formatos en
          punto-flotante no son tan triviales de entender; por ejemplo,
          el exponente y la mantisa no se alinean generalmente entre los
          límites de los bytes, en su lugar un número de bits se reserva
          para cada uno y se empaquetan en la memoria tan apretados como
          se pueda. Para ver lo que esta pasando, necesitaría averiguar
          el tamaño de cada parte del número (los bit de signo siempre
          son de un bit, pero los exponentes y las mantisas pueden ser
          de diferentes tamaños) e imprimir separados los bits de cada
          parte.
        </p>
      </div>
      <div class="sect3" title="Aritmética de punteros">
        <div class="titlepage">
          <div>
            <div>
              <h4 class="title"><a id="idp4936216"></a>Aritmética de punteros</h4>
            </div>
          </div>
        </div>
        <p>
          Si todo lo que se pudiese hacer con un puntero que apunta a un
          vector fuese tratarlo como si fuera un alias para ese vector,
          los punteros a vectores no tendrían mucho interés. Sin
          embargo, los punteros son mucho más flexibles que eso, ya que
          se pueden modificar para apuntar a cualquier otro sitio (pero
          recuerde, el identificador del vector no se puede modificar
          para apuntar a cualquier otro sitio).
        </p>
        <p>
          La <span class="emphasis"><em>aritmética de punteros</em></span> se refiere a la
          aplicación de alguno de los operadores aritméticos a los
          punteros. Las razón por la cual la aritmética de punteros es
          un tema separado de la aritmética ordinaria es que los
          punteros deben ajustarse a cláusulas especiales de modo que se
          comporten apropiadamente. Por ejemplo, un operador común para
          utilizar con punteros es ++, lo que "añade uno al puntero." Lo
          que de hecho significa esto es que el puntero se cambia para
          moverse al "siguiente valor," Lo que sea que ello
          signifique. A continuación, un ejemplo:
        </p>
        <div class="example">
          <a id="idp4938880"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:PointerIncrement.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwb">double</span> d<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> i<span class="hl opt">;</span>
  <span class="hl kwb">double</span><span class="hl opt">*</span> dp <span class="hl opt">=</span> d<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ip = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>ip <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  ip<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ip = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>ip <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;dp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>dp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  dp<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;dp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>dp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.59. C03/PointerIncrement.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          Para una ejecución en mi máquina, la salida es:
        </p>
        <pre class="programlisting">
ip <span class="hl opt">=</span> <span class="hl num">6684124</span>
ip <span class="hl opt">=</span> <span class="hl num">6684128</span>
dp <span class="hl opt">=</span> <span class="hl num">6684044</span>
dp <span class="hl opt">=</span> <span class="hl num">6684052</span>
</pre>
        <p>
          Lo interesante aquí es que aunque la operación <code class="literal">++</code>
          parece la misma tanto para el <code class="type">int*</code> como para el
          <code class="type">double*</code>, se puede comprobar que el puntero de
          <code class="type">int*</code> ha cambiado 4 bytes mientras que para el
          <code class="type">double*</code> ha cambiado 8. No es coincidencia, que
          estos sean los tamaños de <code class="type">int</code> y
          <code class="type">double</code> en esta máquina. Y ese es el truco de la
          aritmética de punteros: el compilador calcula la cantidad
          apropiada para cambiar el puntero de modo que apunte al
          siguiente elemento en el vector (la aritmética de punteros
          sólo tiene sentido dentro de los vectores). Esto funciona incluso
          con vectores de <code class="keyword">struct</code>s:
        </p>
        <div class="example">
          <a id="idp4944152"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:PointerIncrement2.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> <span class="hl opt">{</span>
  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  <span class="hl kwb">short</span> s<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">long</span> l<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  <span class="hl kwb">double</span> d<span class="hl opt">;</span>
  <span class="hl kwb">long double</span> ld<span class="hl opt">;</span>
<span class="hl opt">}</span> Primitives<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Primitives p<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  Primitives<span class="hl opt">*</span> pp <span class="hl opt">=</span> p<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(Primitives) = &quot;</span> 
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>Primitives<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;pp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>pp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  pp<span class="hl opt">++;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;pp = &quot;</span> <span class="hl opt">&lt;&lt; (</span><span class="hl kwb">long</span><span class="hl opt">)</span>pp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.60. C03/PointerIncrement2.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          La salida en esta máquina es:
        </p>
        <pre class="programlisting">
<span class="hl kwa">sizeof</span><span class="hl opt">(</span>Primitives<span class="hl opt">) =</span> <span class="hl num">40</span>
pp <span class="hl opt">=</span> <span class="hl num">6683764</span>
pp <span class="hl opt">=</span> <span class="hl num">6683804</span>
</pre>
        <p>
          Como puede ver, el compilador también hace lo adecuado para
          punteros a <code class="keyword">struct</code>s (y con <code class="keyword">class</code> y
          <code class="keyword">union</code>).
        </p>
        <p>
          La aritmética de punteros también funciona con los operadores
          <code class="literal">--</code>, <code class="literal">+</code> y <code class="literal">-</code>, pero los dos
          últimos están limitados: no se puede sumar dos punteros, y si
          se restan punteros el resultado es el número de elementos
          entre los dos punteros. Sin embargo, se puede sumar o restar
          un valor entero y un puntero. A continuación, un ejemplo
          demostrando el uso de la aritmética de punteros:
        </p>
        <div class="example">
          <a id="idp4950280"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C03:PointerArithmetic.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define P(EX) cout &lt;&lt; #EX &lt;&lt;</span> <span class="hl pps">&quot;: &quot;</span><span class="hl ppc"> &lt;&lt; EX &lt;&lt; endl;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    a<span class="hl opt">[</span>i<span class="hl opt">] =</span> i<span class="hl opt">;</span> <span class="hl slc">// Give it index values</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip <span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwd">P</span><span class="hl opt">(*</span>ip<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(*++</span>ip<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(*(</span>ip <span class="hl opt">+</span> <span class="hl num">5</span><span class="hl opt">));</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> ip2 <span class="hl opt">=</span> ip <span class="hl opt">+</span> <span class="hl num">5</span><span class="hl opt">;</span>
  <span class="hl kwd">P</span><span class="hl opt">(*</span>ip2<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(*(</span>ip2 <span class="hl opt">-</span> <span class="hl num">4</span><span class="hl opt">));</span>
  <span class="hl kwd">P</span><span class="hl opt">(*--</span>ip2<span class="hl opt">);</span>
  <span class="hl kwd">P</span><span class="hl opt">(</span>ip2 <span class="hl opt">-</span> ip<span class="hl opt">);</span> <span class="hl slc">// Yields number of elements</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 3.61. C03/PointerArithmetic.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
          Comienza con otra macro, pero esta utiliza una característica
          del preprocesador llamada
          <span class="foreignphrase"><em class="foreignphrase">stringizing</em></span> (implementada
          mediante el signo <span class="token">#</span> antes de una expresión) que
          toma cualquier expresión y la convierte a un vector de
          caracteres. Esto es bastante conveniente, ya que permite
          imprimir la expresión seguida de dos puntos y del valor de la
          expresión. En <code class="function">main()</code> puede ver lo útil
          que resulta este atajo.
        </p>
        <p>
          Aunque tanto la versión prefijo como sufijo de <code class="literal">++</code>
          y <code class="literal">--</code> son válidas para los punteros, en este
          ejemplo sólo se utilizan las versiones prefijo porque se
          aplican antes de referenciar el puntero en las expresiones
          anteriores, de modo que permite ver los efectos en las
          operaciones. Observe que se han sumado y restado valores
          enteros; si se combinasen de este modo dos punteros, el
          compilador no lo permitiría.
        </p>
        <p>
          Aquí se ve la salida del programa anterior:
        </p>
        <pre class="programlisting">
<span class="hl opt">*</span>ip<span class="hl opt">:</span> <span class="hl num">0</span>
<span class="hl opt">*++</span>ip<span class="hl opt">:</span> <span class="hl num">1</span>
<span class="hl opt">*(</span>ip <span class="hl opt">+</span> <span class="hl num">5</span><span class="hl opt">):</span> <span class="hl num">6</span>
<span class="hl opt">*</span>ip2<span class="hl opt">:</span> <span class="hl num">6</span>
<span class="hl opt">*(</span>ip2 <span class="hl opt">-</span> <span class="hl num">4</span><span class="hl opt">):</span> <span class="hl num">2</span>
<span class="hl opt">*--</span>ip2<span class="hl opt">:</span> <span class="hl num">5</span>
</pre>
        <p>
          En todos los casos, el resultado de la aritmética de punteros
          es que el puntero se ajusta para apuntar al «sitio
          correcto», basándose en el tamaño del tipo de los
          elementos a los que está apuntado.
        </p>
        <p>
          Si la aritmética de punteros le sobrepasa un poco al
          principio, no tiene porqué preocuparse. La mayoría de las
          veces sólo la necesitará para crear vectores e indexarlos con
          <code class="literal">[]</code>, y normalmente la aritmética de punteros más
          sofisticada que necesitará es <code class="literal">++</code> y
          <code class="literal">--</code> . La aritmética de punteros generalmente está
          reservada para programas más complejos e ingeniosos, y
          muchos de los contenedores en la librería de Estándar C++
          esconden muchos de estos inteligentes detalles, por lo que no
          tiene que preocuparse de ellos.
        </p>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp4885048" href="#idp4885048" class="para">42</a>] </sup>(N. de T.) <span class="emphasis"><em>zero indexing</em></span></p>
        </div>
        <div class="footnote">
          <p><sup>[<a id="ftn.idp4905224" href="#idp4905224" class="para">43</a>] </sup>
	      A menos que tome la siguiente aproximación estricta:
	      «todos los argumentos pasado en C/C++ son por valor,
	      y el «valor» de un vector es el producido por
	      su identificador: su dirección». Eso puede parecer
	      correcto desde el punto de vista del lenguaje ensamblador,
	      pero yo no creo que ayude cuando se trabaja con conceptos
	      de alto nivel. La inclusión de referencias en C++ hace que
	      el argumento «todo se pasa por valor» sea más
	      confuso, hasta el punto de que siento que es más adecuado
	      pensar en términos de «paso por valor» vs
	      «paso por dirección».
	    </p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch03s08s04.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch03s08s04.html">3.8.4. Cómo ahorrar memoria con <code class="keyword">union</code></a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="ch03s08.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch03s09.html">3.9. Consejos para depuración</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch03s09.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
