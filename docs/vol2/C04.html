<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>5: Iostreams</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 2)" />
    <link rel="up" href="pt02.html" title="Parte II. La librería Estándar de C++" />
    <link rel="prev" href="ch04s06.html" title="4.6. Ejercicios" />
    <link rel="next" href="ch05s02.html" title="5.2. Iostreams al rescate" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch04s06.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch04s06.html">4.6. Ejercicios</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="pt02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch05s02.html">5.2. <code class="classname">Iostreams</code> al rescate</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch05s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="chapter" title="5: Iostreams">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="C04"></a>5: Iostreams</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <strong>Tabla de contenidos</strong>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="C04.html#idp3970944">5.1. ¿Por que <code class="classname">iostream</code>? </a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s02.html">5.2. <code class="classname">Iostreams</code> al rescate</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s03.html">5.3. Manejo errores de <code class="classname">stream</code></a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s04.html">5.4. Iostreams de fichero</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s05.html">5.5. Almacenamiento de <code class="classname">iostream</code></a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s06.html">5.6. Buscar en iostreams</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s07.html">5.7. Iostreams de <code class="classname">string</code></a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s08.html">5.8. Formateo de stream de salida</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s09.html">5.9. Manipuladores</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s10.html">5.10.  </a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s11.html">5.11.  </a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s12.html">5.12.  </a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch05s13.html">5.13.  </a>
            </span>
          </dt>
        </dl>
      </div>
      <div class="highlights">
        <p>
      Puedes hacer mucho más con el problema general de E/S que
      simplemente coger el E/S estándar y convertirlo en una clase.
    </p>
      </div>
      <p>
    ¿No seria genial si pudiera hacer que todos los 'receptáculos' -E/S
    estándar, ficheros, e incluso boques de memoria- parecieran iguales de
    manera que solo tuviera que recordar una interficie? Esta es la idea que hay
    detrás de los <code class="classname">iostreams</code>. Son mucho más sencillos,
    seguros, y a veces incluso más eficientes que el conjunto de funciones de la
    libreria estándar de C <code class="classname">stdio.</code>
  </p>
      <p>
    Las clases de <code class="classname">iostream</code> son generalmente la
    primera parte de la libreria de C++ que los nuevos programadores de C++
    parender a usar. En este capítulo se discute sobre las mejoras que
    representan los <code class="classname">iostream</code> sobre las funciones de
    <code class="classname">stdio</code> de C y explora el comprotamiento de los
    ficheros y streams de strings además de los streams de consola.
  </p>
      <div class="sect1" title="5.1. ¿Por que iostream?">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="idp3970944"></a>5.1. ¿Por que <code class="classname">iostream</code>? </h2>
            </div>
          </div>
        </div>
        <p>
      Se debe estar preguntando que hay de malo en la buena y vieja
      librería de C. ¿Por que no 'incrustar' la libreria de C en una clase y ya
      está? A veces esta solución es totalmente válida. Por ejemplo, suponga que
      quiere estar seguro que un fichero representado por un puntero de
      <code class="classname">stdio</code> <code class="varname">FILE</code> siempre es abierto de
      forma segura y cerrado correctamente sin tener que confiar en que el usuario
      se acuerde de llamar a la función <code class="function">close()</code>. El siguiente
      programa es este intento:
    </p>
        <div class="example">
          <a id="idp3973336"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C04:FileClass.h</span>
<span class="hl slc">// stdio files wrapped.</span>
<span class="hl ppc">#ifndef FILECLASS_H</span>
<span class="hl ppc">#define FILECLASS_H</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>

<span class="hl kwc">class</span> FileClass <span class="hl opt">{</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> f<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">struct</span> FileClassError <span class="hl opt">:</span> std<span class="hl opt">::</span>runtime_error <span class="hl opt">{</span>
    <span class="hl kwd">FileClassError</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> msg<span class="hl opt">)</span>
    <span class="hl opt">:</span> std<span class="hl opt">::</span><span class="hl kwd">runtime_error</span><span class="hl opt">(</span>msg<span class="hl opt">) {}</span>
  <span class="hl opt">};</span>
  <span class="hl kwd">FileClass</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode <span class="hl opt">=</span> <span class="hl str">&quot;r&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">FileClass</span><span class="hl opt">();</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> <span class="hl kwd">fp</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// FILECLASS_H ///:~</span><span class="hl ppc"></span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 5.1. C04/FileClass.h</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      Cuando trabaja con ficheros E/S en C, usted trabaja con punteros
      desnudos a una <code class="varname">struct</code> de <code class="varname">FILE</code>, pero
      esta clase envuelve los punteros y garantiza que es correctamente
      inicializada y destruida usando el constructor y el destructor. El segundo
      parámetro del constructor es el modo del fichero, que por defecto es 'r'
      para 'leer'
    </p>
        <p>
      Para pedir el valor del puntero para usarlo en las funciones de
      fichero de E/S, use la función de acceso <code class="function">fp()</code>. Aquí
      están las definiciones de las funciones miembro:
    </p>
        <div class="example">
          <a id="idp3977296"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C04:FileClass.cpp {O}</span>
<span class="hl slc">// FileClass Implementation.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;FileClass.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

FileClass<span class="hl opt">::</span><span class="hl kwd">FileClass</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">((</span>f <span class="hl opt">=</span> <span class="hl kwd">fopen</span><span class="hl opt">(</span>fname<span class="hl opt">,</span> mode<span class="hl opt">)) ==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">FileClassError</span><span class="hl opt">(</span><span class="hl str">&quot;Error opening file&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

FileClass<span class="hl opt">::~</span><span class="hl kwd">FileClass</span><span class="hl opt">() {</span> <span class="hl kwd">fclose</span><span class="hl opt">(</span>f<span class="hl opt">); }</span>

<span class="hl kwb">FILE</span><span class="hl opt">*</span> FileClass<span class="hl opt">::</span><span class="hl kwd">fp</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> f<span class="hl opt">; }</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 5.2. C04/FileClass.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      El constructor llama a <code class="function">fopen()</code>, tal como se
      haría normalmente, pero además se asegura que el resultado no es cero, que
      indica un error al abrir el fichero. Si el fichero no se abre correctamente,
      se lanza una excepción.
    </p>
        <p>
      El destructor cierra el fichero, y la función de acceso
      <code class="function">fp()</code> retorna <code class="varname">f</code>. Este es un ejemplo
      de uso de <code class="classname">FileClass</code>:
    </p>
        <div class="example">
          <a id="idp3981120"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C04:FileClassTest.cpp</span>
<span class="hl slc">//{L} FileClass</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;FileClass.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    FileClass <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl str">&quot;FileClassTest.cpp&quot;</span><span class="hl opt">);</span>
    <span class="hl kwb">const int</span> BSIZE <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
    <span class="hl kwb">char</span> buf<span class="hl opt">[</span>BSIZE<span class="hl opt">];</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">fgets</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> BSIZE<span class="hl opt">,</span> f<span class="hl opt">.</span><span class="hl kwd">fp</span><span class="hl opt">()))</span>
      <span class="hl kwd">fputs</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> stdout<span class="hl opt">);</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>FileClass<span class="hl opt">::</span>FileClassError<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> EXIT_SUCCESS<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">// File automatically closed by destructor</span>
<span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 5.3. C04/FileClassTest.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      Se crea el objeto <code class="classname">FileClass</code> y se usa en
      llamadas a funciones E/S de fichero normal de C, llamando a
      <code class="function">fp()</code>. Cuando haya acabado con ella, simplemente
      olvídese; el fichero será cerrado por el destructor al final del ámbito de
      la variable.
    </p>
        <p>
      Incluso teniendo en cuenta que <code class="varname">FILE</code> es un
      puntero privado, no es particularmente seguro porque
      <code class="function">fp()</code> lo recupera. Ya que el único efecto que parece
      estar garantizado es la inicialización y la liberación, ¿por que no hacerlo
      público o usar una <code class="code">struct </code>en su lugar? Nótese que mientras se
      puede obtener una copia de <code class="varname">f </code>usando
      <code class="function">fp()</code>, no se puede asignar a <code class="varname">f</code> -que
      está completamente bajo el control de la clase. Después de capturar el
      puntero retornado por <code class="function">fp()</code>, el programador cliente
      todavía puede asignar a la estructura elementos o incluso cerrarlo, con lo
      que la seguridad esta en la garantía de un puntero a FILE válido mas que en
      el correcto contenido de la estructura.
    </p>
        <p>
      Si quiere completa seguridad, tiene que evitar que el usuario
      acceda directamente al puntero <code class="code">FILE</code>. Cada una de las versiones
      de las funciones normales de E/S a ficheros deben ser mostradas como
      miembros de clase para que todo lo que se pueda hacer desde el acercamiento
      de C esté disponible en la clase de C++.
    </p>
        <div class="example">
          <a id="idp3988016"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C04:Fullwrap.h</span>
<span class="hl slc">// Completely hidden file IO.</span>
<span class="hl ppc">#ifndef FULLWRAP_H</span>
<span class="hl ppc">#define FULLWRAP_H</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#undef getc</span>
<span class="hl ppc">#undef putc</span>
<span class="hl ppc">#undef ungetc</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">fpos_t</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> File <span class="hl opt">{</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> f<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> <span class="hl kwd">F</span><span class="hl opt">();</span> <span class="hl slc">// Produces checked pointer to f</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">File</span><span class="hl opt">();</span> <span class="hl slc">// Create object but don't open file</span>
  <span class="hl kwd">File</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> path<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode <span class="hl opt">=</span> <span class="hl str">&quot;r&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">File</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">open</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> path<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode <span class="hl opt">=</span> <span class="hl str">&quot;r&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">reopen</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> path<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getc</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">ungetc</span><span class="hl opt">(</span><span class="hl kwb">int</span> c<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">putc</span><span class="hl opt">(</span><span class="hl kwb">int</span> c<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> s<span class="hl opt">);</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">gets</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> format<span class="hl opt">, ...);</span>
  <span class="hl kwb">size_t</span> <span class="hl kwd">read</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> ptr<span class="hl opt">,</span> <span class="hl kwb">size_t</span> size<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">size_t</span> <span class="hl kwd">write</span><span class="hl opt">(</span><span class="hl kwb">const void</span><span class="hl opt">*</span> ptr<span class="hl opt">,</span> <span class="hl kwb">size_t</span> size<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">eof</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">close</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">flush</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">seek</span><span class="hl opt">(</span><span class="hl kwb">long</span> offset<span class="hl opt">,</span> <span class="hl kwb">int</span> whence<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getpos</span><span class="hl opt">(</span><span class="hl kwb">fpos_t</span><span class="hl opt">*</span> pos<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">setpos</span><span class="hl opt">(</span><span class="hl kwb">const fpos_t</span><span class="hl opt">*</span> pos<span class="hl opt">);</span>
  <span class="hl kwb">long</span> <span class="hl kwd">tell</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rewind</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setbuf</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> buf<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">setvbuf</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> buf<span class="hl opt">,</span> <span class="hl kwb">int</span> type<span class="hl opt">,</span> <span class="hl kwb">size_t</span> sz<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">error</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">clearErr</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// FULLWRAP_H ///:~</span><span class="hl ppc"></span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 5.4. C04/Fullwrap.h</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      Esta clase contiene casi todas las funciones de E/S de fichero
      de <code class="code">&lt;cstdio&gt;</code>. (<code class="function">vfprintf()</code> no esta; se
      implementa en la función miembro <code class="function">printf()</code> )
    </p>
        <p>
      El fichero tiene el mismo constructor que en el ejemplo
      anterior, y también tiene un constructor por defecto. El constructor por
      defecto es importante si se crea un array de objetos
      <code class="classname">File</code> o se usa un objeto <code class="classname">File</code>
      como miembro de otra clase donde la inicialización no se realiza en el
      contructor, sino cierto tiempo después de que el objeto envolvente se
      cree.
    </p>
        <p>
      El constructor por defecto pone a cero el puntero a
      <code class="varname">FILE</code> privado <code class="varname">f</code>. Pero ahora , antes de
      cualquier referencia a <code class="function">f</code>, el valor debe ser comprobado
      para asegurarse que no es cero. Esto se consigue con
      <code class="function">F()</code>, que es privado porque está pensado para ser usado
      solamente por otras funciones miembro. (No queremos dar acceso directo a
      usuarios a la estructura de <code class="varname">FILE</code> subyacente en esta
      clase).
    </p>
        <p>
      Este acercamiento no es terrible en ningún sentido. Es bastante
      funcional, y se puede imaginar haciendo clases similares para la E/S
      estándar (consola) y para los formateos en el core (leer/escribir un trozo
      de la memoria en vez de un fichero o la consola).
    </p>
        <p>
      Este bloque de código es el interprete en tiempo de ejecución usado
      para las listas variables de argumentos. Este es el código que analiza el
      formato de su cadena en tiempo de ejecución y recoge e interpreta argumentos
      desde una lista variable de argumentos. Es un problema por cuatro
      razones:
    </p>
        <div class="orderedlist">
          <ol class="orderedlist" type="1">
            <li class="listitem">
              <p>
	    Incluso si solo se usa una fracción de la funcionalidad del
	    interprete, se carga todo en el ejecutable. Luego si quiere usar un
	    <code class="code">printf("%c", 'x'); </code>, usted tendrá todo el paquete, incluido las
	    partes que imprimen números en coma flotante y cadenas. No hay una opción
	    estándar para reducir el la cantidad de espacio usado por el
	    programa.
	  </p>
            </li>
            <li class="listitem">
              <p>
	    Como la interpretación pasa en tiempo de ejecución, no se
	    puede evitar un empeoramiento del rendimiento. Esto es frustrante por que
	    toda la información está allí, en el formato de la cadena, en tiempo de
	    compilación, pero no se evalua hasta la ejecución. Por otro lado, si se
	    pudieran analizar los argumentos en el formateo de la cadena durante la
	    compilación, se podrían hacer llamadas directas a funciones que tuvieran el
	    potencial de ser mucho más rápidas que un interprete en tiempo de ejecución
	    (aunque la familia de funciones de printf() acostumbran a estar bastante
	    bien optimizadas).
	  </p>
            </li>
            <li class="listitem">
              <p>
	    Como el formateo de la cadena no se evalua hasta la
	    ejecución, no se hace una comprobación de errores al compilar.
	    Probalblemente está familiarizado con este problema si ha intentado buscar
	    errores que provienen del uso de un número o tipo de argumentos incorrecto
	    en una sentencia <code class="function">printf()</code>. C++ ayuda mucho a encontrar
	    rápidamente errores durante la compilación y hacerle la vida más fácil.
	    Parece una tonteria desechar la seguridad en los tipos de datos para la
	    libreria de E/S, especialmente cuando usamos intensivamente las E/S.
	  </p>
            </li>
            <li class="listitem">
              <p>
	    Para C++, el más crucial de los problemas es que la familia
	    de funciones de printf() no es particularmente extensible. Esta realmente
	    diseñada para manejar solo los tipos básicos de datos en C (char, int,
	    float, double, wchar_t, char*, wchar_t*, y void*) y sus variaciones. Debe
	    estar pensando que cada vez que añade una nueva clase, puede añadir
	    funciones sobrecargadas printf() y scanf() (y sus variaciones para ficheros
	    y strings), pero recuerde: las funciones sobrecargadas deben tener
	    diferentes tipos de listas de argumentos, y la familia de funciones de
	    printf() esconde esa información en la cadena formateada y su lista variable
	    de argumentos. Para un lenguage como C++, cuya virtud es que se pueden
	    añadir fácilmente nuevos tipos de datos, esta es una restricción
	    inaceptable.
	  </p>
            </li>
          </ol>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch04s06.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch04s06.html">4.6. Ejercicios</a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="pt02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch05s02.html">5.2. <code class="classname">Iostreams</code> al rescate</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch05s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
