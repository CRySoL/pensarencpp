<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
    <title>7: Algoritmos genéricos</title>
    <link rel="stylesheet" type="text/css" href="common.css" />
    <link rel="stylesheet" type="text/css" href="chunk.css" />
    <link rel="stylesheet" type="text/css" href="highlight.css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1" />
    <link rel="home" href="index.html" title="Pensar en C++ (Volumen 2)" />
    <link rel="up" href="pt02.html" title="Parte II. La librería Estándar de C++" />
    <link rel="prev" href="ch06s08.html" title="6.8." />
    <link rel="next" href="ch07s02.html" title="7.2. Objetos-función" />
  </head>
  <body>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch06s08.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch06s08.html">6.8.  </a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="pt02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch07s02.html">7.2. Objetos-función</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch07s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
      </table>
    </div>
    <div class="chapter" title="7: Algoritmos genéricos">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="C06"></a>7: Algoritmos genéricos</h2>
          </div>
        </div>
      </div>
      <div class="toc">
        <p>
          <strong>Tabla de contenidos</strong>
        </p>
        <dl>
          <dt>
            <span class="sect1">
              <a href="C06.html#idp4601944">7.1. Un primer vistazo</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch07s02.html">7.2. Objetos-función</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch07s03.html">7.3. Un catálogo de algoritmos STL</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch07s04.html">7.4. Creando sus propios algoritmos tipo STL</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch07s05.html">7.5. Resumen</a>
            </span>
          </dt>
          <dt>
            <span class="sect1">
              <a href="ch07s06.html">7.6. Ejercicios</a>
            </span>
          </dt>
        </dl>
      </div>
      <p>
    Los algoritmos son la base de la computación. Ser capaz de escribir un algoritmo que
    funcione con cualquier tipo de se secuencia hace que sus programas sean simples y
    seguros. La habilidad para adaptar algoritmos en tiempo de ejecución a revolucionado
    el desarrollo de software.
  </p>
      <p>
    El subconjunto de la Librería Estándar de C++ conocido como Standard Template Library
    (STL)<sup>[<a id="idp4600160" href="#ftn.idp4600160" class="footnote">17</a>]</sup> fue
    diseñado entorno a algoritmos genéricos &#8212;código que procesa secuencias de
    cualquier tipo de valores de un modo seguro. El objetivo era usar algoritmos
    predefinidos para casi cualquier tarea, en lugar de codificar a mano cada vez que se
    necesitara procesar una colección de datos. Sin embargo, ese potencial requiere cierto
    aprendizaje. Para cuando llegue al final de este capítulo, debería ser capaz de
    decidir por sí mismo si los algoritmos le resultan útiles o demasiado confusos de
    recordar. Si es como la mayoría de la gente, se resistirá al principio pero entonces
    tenderá a usarlos más y más con el tiempo.
  </p>
      <div class="sect1" title="7.1. Un primer vistazo">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both"><a id="idp4601944"></a>7.1. Un primer vistazo</h2>
            </div>
          </div>
        </div>
        <p>
      Entre otras cosas, los algoritmos genéricos de la librería estándar proporcionan un
      vocabulario con el que desribir soluciones. Una vez que los algoritmos le sean
      familiares, tendrá un nuevo conjunto de palabras con el que discutir que está
      haciendo, y esas palabras son de un nivel mayor que las que tenía antes. No
      necesitará decir «Este bucle recorre y asigna de aquí a ahí... oh, ya veo, ¡está
      copiando!» En su lugar dirá simplemente <code class="function">copy()</code>. Esto es lo que
      hemos estado haciendo desde el principio de la programación de computadores
      &#8212;creando abstracciones de alto nivel para expresar lo que está haciendo y
      perder menos tiempo diciendo cómo hacerlo. El «cómo» se ha resuelto una vez y para
      todo y está oculto en el código del algoritmo, listo para ser reutilizado cuando se
      necesite.
    </p>
        <p>
      Vea aquí un ejemplo de cómo utilizar el algoritmo <code class="function">copy</code>:
    </p>
        <div class="example">
          <a id="idp4604864"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C06:CopyInts.cpp</span>
<span class="hl slc">// Copies ints without an explicit loop.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>  <span class="hl slc">// For size_t</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SIZE<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>a<span class="hl opt">[</span>i<span class="hl opt">] ==</span> b<span class="hl opt">[</span>i<span class="hl opt">]);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 7.1. C06/CopyInts.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      Los dos primeros parámetros de <code class="function">copy</code> representan el rango de la
      secuencia de entrada &#8212;en este caso del array <code class="varname">a</code>. Los rangos
      se especifican con un par de punteros. El primero apunta al primer elemento de la
      secuencia, y el segungo apunta una posición después del final del array (justo
      después del último elemento). Esto puede parecer extraño al principio, pero es una
      antigua expresión idiomática de C que resulta bastante práctica. Por ejemplo, la
      diferencia entre esos dos punteros devuelve el número de elementos de la
      secuencia. Más importante, en la implementación de <code class="function">copy()</code>, el
      segundo puntero puede actual como un centinela para para la iteración a través de la
      secuencia. El tercer argumento hace referencia al comienzo de la secuencia de
      salida, que es el array <code class="varname">b</code> en el ejemplo. Se asume que el array
      <code class="varname">b</code> tiene suficiente espacio para recibir los elementos copiados.
    </p>
        <p>
      El algotirmo <code class="function">copy()</code> no parece muy excitante if solo puediera
      procesar enteros. Puede copiar cualquier tipo de secuencia. El siguiente ejemplo
      copia objetos <code class="classname">string</code>.
    </p>
        <div class="example">
          <a id="idp4610368"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C06:CopyStrings.cpp</span>
<span class="hl slc">// Copies strings.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string a<span class="hl opt">[] = {</span><span class="hl str">&quot;read&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;my&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;lips&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  string b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">equal</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 7.2. C06/CopyStrings.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      Este ejmeplo presenta otro algoritmo, <code class="function">equal()</code>, que devuelve
      cierto solo si cada elemento de la primera secuencia es igual (usando su
      <code class="function">operator==()</code>) a su elemento correspondiente en la segunda
      secuencia. Este ejemplo recorre cada secuencia 2 veces, una para copiar, y otra para
      comparar, sin ningún bucle explícito.
    </p>
        <p>
      Los algoritmos genéricos consiguen esta flexibilidad porque son funciones
      parametrizadas (plantillas). Si piensa en la implementación de
      <code class="function">copy()</code> verá que es algo como lo siguiente, que es «casi»
      correcto:
    </p>
        <pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">copy</span><span class="hl opt">(</span>T<span class="hl opt">*</span> begin<span class="hl opt">,</span> T<span class="hl opt">*</span> end<span class="hl opt">,</span> T<span class="hl opt">*</span> dest<span class="hl opt">) {</span>
  <span class="hl kwa">while</span> <span class="hl opt">(</span>begin <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    <span class="hl opt">*</span>dest<span class="hl opt">++ = *</span>begin<span class="hl opt">++;</span>
<span class="hl opt">}</span>
</pre>
        <p>
      Decimos «casi» porque <code class="function">copy()</code> puede procesar secuencias
      delimitadas por cualquier cosa que actúe como un puntero, tal como un iterador. De
      ese modo, <code class="function">copy()</code> se puede utilizar para duplicar un
      <code class="classname">vector</code>, como en el siguiente ejemplo.
    </p>
        <div class="example">
          <a id="idp4616304"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C06:CopyVector.cpp</span>
<span class="hl slc">// Copies the contents of a vector.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v2</span><span class="hl opt">(</span>SIZE<span class="hl opt">);</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">equal</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 7.3. C06/CopyVector.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      El primer vector, <code class="varname">v1</code>, es inicializado a partir de una secuencia
      de enteros en el array <code class="varname">a</code>. La definición del vector
      <code class="varname">v2</code> usa un contructor diferente de <code class="classname">vector</code>
      que reserva sitio para <code class="constant">SIZE</code> elementos, inicializados a cero (el
      valor por defecto para enteros).
    </p>
        <p>
      Igual que con el ejemplo anterior con el array, es importante que
      <code class="varname">v2</code> tenga suficiente espacio para recibir una copia de los
      contenidos de <code class="varname">v1</code>. Por conveniencia, una función de librería
      especial, <code class="function">back_inserter()</code>, retorna un tipo especial de iterador
      que inserta elementos en lugar de sobre-escribirlos, de modo que la memoria del
      contenedor se expande conforme se necesita. El siguiente ejemplo usa
      <code class="function">back_inserter()</code>, y por eso no hay que establecer el tamaño del
      vector de salida, <code class="varname">v2</code>, antes de tiempo.
    </p>
        <div class="example">
          <a id="idp4621248"></a>
          <div class="example-contents">
            <pre class="programlisting">
<span class="hl slc">//: C06:InsertVector.cpp</span>
<span class="hl slc">// Appends the contents of a vector to another.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v2<span class="hl opt">;</span>  <span class="hl slc">// v2 is empty here</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>v2<span class="hl opt">));</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">equal</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
          </div>
          <p class="title">
            <strong>Listado 7.4. C06/InsertVector.cpp</strong>
          </p>
        </div>
        <br class="example-break" />
        <p>
      La función <code class="function">back_inserter()</code> está definida en el fichero de
      cabecera <code class="filename">&lt;iterator&gt;</code>. Explicaremos los iteradores de
      inserción en profundidad en el próximo capítulo.
    </p>
        <p>
      Dado que los iteradores son idénticos a punteros en todos los sentidos importantes,
      puede escribir los algoritmos de la librería estándar de modo que los argumentos
      puedan ser tanto punteros como iteradores. Por esta razón, la implementación de
      <code class="function">copy()</code> se parece más al siguiente código:
    </p>
        <pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename Iterator<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">copy</span><span class="hl opt">(</span>Iterator begin<span class="hl opt">,</span> Iterator end<span class="hl opt">,</span> Iterator dest<span class="hl opt">) {</span>
  <span class="hl kwa">while</span> <span class="hl opt">(</span>begin <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    <span class="hl opt">*</span>begin<span class="hl opt">++ = *</span>dest<span class="hl opt">++;</span>
<span class="hl opt">}</span>
</pre>
        <p>
      Para cualquier tipo de argumento que use en la llamada, <code class="function">copy()</code>
      asume que implementa adecuadamente la indirección y los operadores de incremento. Si
      no lo hace, obtendrás un error de compilación.
    </p>
        <div class="sect2" title="7.1.1. Predicados">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp4626560"></a>7.1.1. Predicados</h3>
              </div>
            </div>
          </div>
          <p>
	A veces, podría querer copiar solo un subconjunto bien definido de una secuencia a
	otra; solo aquellos elementos que satisfagan una condición particular. Para
	conseguir esta flexibilidad, muchos algoritmos tienen una forma alternativa de
	llamada que permite proporcionar un predicado, que es simplemente una función que
	retorna un valor booleano basado en algún criterio. Suponga por ejemplo, que solo
	quiere extraer de una secuencia de enteros, aquellos que son menores o iguales de
	15. Una versión de <code class="function">copy()</code> llamada
	<code class="function">remove_copy_if()</code> puede hacer el trabajo, tal que así:
      </p>
          <div class="example">
            <a id="idp4628432"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C06:CopyInts2.cpp</span>
<span class="hl slc">// Ignores ints that satisfy a predicate.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// You supply this predicate</span>
<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> endb <span class="hl opt">=</span> <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a<span class="hl opt">+</span>SIZE<span class="hl opt">,</span> b<span class="hl opt">,</span> gt15<span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> beginb <span class="hl opt">=</span> b<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>beginb <span class="hl opt">!=</span> endb<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>beginb<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Prints 10 only</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 7.5. C06/CopyInts2.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	La función <code class="function">remove_copy_if()</code> acepta los rangos definidos por
	punteros habituales, seguidos de un predicado de su elección. El predicado debe
	ser un puntero a función[FIXME] que toma un argumento simple del mismo tipo que
	los elementos de la secuencia, y que debe retornar un booleano. Aquí, la función
	<code class="function">gt15</code> returna verdadero si su argumento es mayor que 15. El
	algoritmo <code class="function">remove_copy_if()</code> aplica <code class="function">gt15()</code>
	a cada elemento en la secuencia de entrada e ignora aquellos elementos para los
	cuales el predicado devuelve verdad cuando escribe la secuencia de salida.
      </p>
          <p>
	El siguiente programa ilustra otra variación más del algoritmo de copia.
      </p>
          <div class="example">
            <a id="idp4632440"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C06:CopyStrings2.cpp</span>
<span class="hl slc">// Replaces strings that satisfy a predicate.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// The predicate</span>
<span class="hl kwb">bool</span> <span class="hl kwd">contains_e</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'e'</span><span class="hl opt">) !=</span> string<span class="hl opt">::</span>npos<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string a<span class="hl opt">[] = {</span><span class="hl str">&quot;read&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;my&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;lips&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  string b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  string<span class="hl opt">*</span> endb <span class="hl opt">=</span> <span class="hl kwd">replace_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">,</span>
    contains_e<span class="hl opt">,</span> <span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;kiss&quot;</span><span class="hl opt">));</span>
  string<span class="hl opt">*</span> beginb <span class="hl opt">=</span> b<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>beginb <span class="hl opt">!=</span> endb<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>beginb<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 7.6. C06/CopyStrings2.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	En lugar de simplemente ignorar elementos que no satisfagan el predicado,
	<code class="function">replace_copy_if()</code> substituye un valor fijo para esos
	elementos cuando escribe la secuencia de salida. La salida es:
      </p>
          <pre class="screen">
kiss
my
lips
</pre>
          <p>
	como la ocurrencia original de «read», la única cadena de entrada que
	contiene la letra «e», es reemplazada por la palabra
	«kiss», como se especificó en el último argumento en la llamada a
	<code class="function">replace_copy_if()</code>.
      </p>
          <p>
	El algoritmo <code class="function">replace_if()</code> cambia la secuencia original in
	situ, en lugar de escribir en una secuencia de salida separada, tal como muestra
	el siguiente programa:
      </p>
          <div class="example">
            <a id="idp4637976"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C06:ReplaceStrings.cpp</span>
<span class="hl slc">// Replaces strings in-place.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">contains_e</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'e'</span><span class="hl opt">) !=</span> string<span class="hl opt">::</span>npos<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string a<span class="hl opt">[] = {</span><span class="hl str">&quot;read&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;my&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;lips&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">replace_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> contains_e<span class="hl opt">,</span> <span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;kiss&quot;</span><span class="hl opt">));</span>
  string<span class="hl opt">*</span> p <span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>p <span class="hl opt">!=</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>p<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 7.7. C06/ReplaceStrings.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
        </div>
        <div class="sect2" title="7.1.2. Iteradores de flujo">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp4640216"></a>7.1.2. Iteradores de flujo</h3>
              </div>
            </div>
          </div>
          <p>
	Como cualquier otra buena librería, la Librería Estándar de C++ intenta
	proporcionar modos convenientes de automatizar tareas comunes. Mencionamos al
	principio de este capítulo puede usar algoritmos genéricos en lugar de
	bucles. Hasta el momento, sin embargo, nuestros ejemplos siguen usando un bucle
	explícito para imprimir su salida. Dado que imprimir la salida es una de las
	tareas más comunes, es de esperar que haya una forma de automatizar eso también.
      </p>
          <p>
	Ahí es donde los iteradores de flujo entran en juego. Un iterador de flujo usa un
	flujo como secuencia de entrada o salida. Para eliminar el bucle de salida en el
	programa <code class="filename">CopyInts2.cpp</code>, puede hacer algo como lo siguiente:
      </p>
          <div class="example">
            <a id="idp4642328"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C06:CopyInts3.cpp</span>
<span class="hl slc">// Uses an output stream iterator.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span> gt15<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 7.8. C06/CopyInts3.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	En este ejemplo, reemplazaremos la secuencia de salida <code class="varname">b</code> en el
	tercer argumento de <code class="function">remove_copy_if()</code> con un iterador de flujo
	de salida, que es una instancia de la clase
	<code class="classname">ostream_iterator</code> declarada en el fichero
	<code class="filename">&lt;iterator&gt;</code>. Los iteradores de flujo de salida sobrecargan
	sus operadores de copia-asignación para escribir a sus flujos. Esta instancia en
	particular de <code class="classname">ostream_iterator</code> está vinculada al flujo de
	salida <code class="varname">cout</code>. Cada vez que <code class="function">remove_copy_if()</code>
	asigna un entero de la secuencia <code class="varname">a</code> a <code class="varname">cout</code> a
	través de este iterador, el iterador escribe el entero a <code class="varname">cout</code> y
	automáticamente escribe también una instancia de la cada de separador indicada en
	su segundo argumento, que en este caso contiene el carácter de nueva linea.
      </p>
          <p>
	Es igual de fácil escribir en un fichero proporcionando un flujo de salida
	asociado a un fichero en lugar de <code class="varname">cout</code>.
      </p>
          <div class="example">
            <a id="idp4647760"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C06:CopyIntsToFile.cpp</span>
<span class="hl slc">// Uses an output file stream iterator.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  ofstream <span class="hl kwd">outf</span><span class="hl opt">(</span><span class="hl str">&quot;ints.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>outf<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span> gt15<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 7.9. C06/CopyIntsToFile.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	Un iterador de flujo de entrada permite a un algoritmo leer su secuencia de
	entrada desde un flujo de entrada. Esto se consigue haciendo que tanto el
	constructor como <code class="function">operator++()</code> lean el siguiente elemento del
	flujo subyacente y sobrecargando <code class="function">operator*()</code> para conseguir
	el valor leído previamente. Dado que los algoritmos requieren dos punteros para
	delimitar la secuencia de entrada, puede construir un
	<code class="classname">istream_iterator</code> de dos formas, como puede ver en el
	siguiente programa.
      </p>
          <div class="example">
            <a id="idp4650696"></a>
            <div class="example-contents">
              <pre class="programlisting">
<span class="hl slc">//: C06:CopyIntsFromFile.cpp</span>
<span class="hl slc">// Uses an input stream iterator.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ofstream <span class="hl kwd">ints</span><span class="hl opt">(</span><span class="hl str">&quot;someInts.dat&quot;</span><span class="hl opt">);</span>
  ints <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;1 3 47 5 84 9&quot;</span><span class="hl opt">;</span>
  ints<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  ifstream <span class="hl kwd">inf</span><span class="hl opt">(</span><span class="hl str">&quot;someInts.dat&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>inf<span class="hl opt">,</span> <span class="hl str">&quot;someInts.dat&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>istream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>inf<span class="hl opt">),</span>
                 istream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span> gt15<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre>
            </div>
            <p class="title">
              <strong>Listado 7.10. C06/CopyIntsFromFile.cpp</strong>
            </p>
          </div>
          <br class="example-break" />
          <p>
	El primer argumento de <code class="function">replace_copy_if()</code> en este programa
	asocia un objeto <code class="classname">istream_iterator</code> al fichero de entrada que
	contiene enteros. El segundo argumento usa el constructor por defecto de la clase
	<code class="classname">istream_iterator</code>. Esta llamada construye un valor especial
	de <code class="function">istream_iterator</code> que indica el fin de fichero, de modo que
	cuando el primer iterador encuentra el final del fichero físico, se compara con el
	valor de <code class="code">istream_iterator&lt;int&gt;()</code>, permitiendo al algoritmo terminar
	correctamente. Fíjese que este ejemplo evita usar un array explícito.
      </p>
        </div>
        <div class="sect2" title="7.1.3. Complejidad algorítmica">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a id="idp4654840"></a>7.1.3. Complejidad algorítmica</h3>
              </div>
            </div>
          </div>
          <p>
	Usar una librería es una cuestión de confianza. Debe confiar en que los
	desarrolladores no solo proporcionan la funcionalidad correcta, sino también
	esperar que las funciones se ejecutan tan eficientemente como sea posible. Es
	mejor escribir sus propios bucles que usar algoritmos que degradan el rendimiento.
      </p>
          <p>
	Para garantizar la calidad de las implementaciones de la librería, la estándar de
	C++ no solo especifica lo que debería hacer un algoritmo, también cómo de rápido
	debería hacerlo y a veces cuánto espacio debería usar. Cualquier algoritmo que no
	cumpla con los requisitos de rendimiento no es conforma al estándar. La medida de
	la eficiencia operacional de un algoritmo se llama complejidad.
      </p>
          <p>
	Cuando es posible, el estándar especifica el número exacto de operaciones que un
	algoritmo debería usar. El algoritmo <code class="function">count_if()</code>, por ejemplo,
	retorna el número de elementos de una secuencia que cumplan el predicado
	especificado. La siguiente llamada a <code class="function">count_if()</code>, si se aplica
	a una secuencia de enteros similar a los ejemplos anteriores de este capítulo,
	devuelve el número de elementos mayores que 15:
      </p>
          <pre class="programlisting">
<span class="hl kwb">size_t</span> n <span class="hl opt">=</span> <span class="hl kwd">count_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> gt15<span class="hl opt">);</span>
</pre>
          <p>
	Dado que <code class="function">count_if()</code> debe comprobar cada elemento exactamente
	una vez, se especificó hacer un número de comprobaciones que sea exactamente igual
	que el número de elementos en la secuencia. El algoritmo
	<code class="function">copy()</code> tiene la misma especificación.
      </p>
          <p>
	Otros algoritmos pueden estar especificados para realizar cierto número máximo de
	operaciones. El algoritmo <code class="function">find()</code> busca a través de una
	secuencia hasta encontrar un elemento igual a su tercer argumento.
      </p>
          <pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwd">find</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">);</span>
</pre>
          <p>
	Para tan pronto como encuentre el elemento y devuelve un puntero a la primera
	ocurrencia. Si no encuentra ninguno, retorna un puntero a una posición pasado el
	final de la secuencia (<code class="code">a+SIZE</code> en este ejemplo). De modo que
	<code class="function">find()</code> realiza como máximo tantas comparaciones como
	elementos tenga la secuencia.
      </p>
          <p>
	A veces el número de operaciones que realiza un algoritmo no se puede medir con
	tanta precisión. En esos casos, el estándar especifica la complejidad asintótica
	del algoritmo, que es una medida de cómo se comportará el algoritmo con secuencias
	largas comparadas con formulas bien conocidas. Un buen ejemplo es el algoritmo
	<code class="function">sort()</code>, del que el estándar dice que requiere
	«aproximadamente n log n comparaciones de media» (n es el número de
	elementos de la secuencia). [FIXME]. Esta medida de complejidad da una idea del
	coste de un algoritmo y al menos le da una base fiable para comparar
	algoritmos. Como verá en el siguiente capítulo, el método
	<code class="function">find()</code> para el contendor <code class="classname">set</code> tiene
	complejidad logarítmica, que implica que el coste de una búsqueda de un elemento
	en un <code class="classname">set</code> será, para conjuntos grandes, proporcional al
	logaritmo del número de elementos. Eso es mucho menor que el número de elementos
	para un n grande, de modo que siempre es mejor buscar en un
	<code class="classname">set</code> utilizando el método en lugar del algoritmo genérico.
      </p>
        </div>
      </div>
      <div class="footnotes">
        <br />
        <hr width="100" align="left" />
        <div class="footnote">
          <p><sup>[<a id="ftn.idp4600160" href="#idp4600160" class="para">17</a>] </sup>N. de T.: Librería Estándar de Plantillas.</p>
        </div>
      </div>
    </div>
    <div class="navfooter">
      <hr />
      <table width="100%" summary="Navigation footer">
        <tr>
          <td class="navititle" width="1%">
            <a accesskey="p" href="ch06s08.html">
              <img src="./images/prev.png" alt="Anterior" />
            </a>
          </td>
          <td class="navititle" width="40%" align="left">
            <a accesskey="p" href="ch06s08.html">6.8.  </a>
          </td>
          <td width="10%" align="center">
            <a accesskey="u" href="pt02.html">
              <img src="./images/up.png" alt="Subir" />
            </a>
          </td>
          <td class="navititle" width="40%" align="right">
            <a accesskey="n" href="ch07s02.html">7.2. Objetos-función</a>
          </td>
          <td class="navititle" width="1%" align="right">
            <a accesskey="n" href="ch07s02.html">
              <img src="./images/next.png" alt="Siguiente" />
            </a>
          </td>
        </tr>
        <tr>
          <td valign="top"> </td>
          <td> </td>
          <td width="10%" align="center">
            <a accesskey="h" href="index.html">
              <img src="./images/home.png" alt="Inicio" />
            </a>
          </td>
          <td> </td>
          <td valign="top"> </td>
        </tr>
      </table>
    </div>
  </body>
</html>
