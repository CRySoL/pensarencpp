<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Pensar en C++ (Volumen 2)</title><link rel="stylesheet" type="text/css" href="common.css" /><link rel="stylesheet" type="text/css" href="single.css" /><link rel="stylesheet" type="text/css" href="highlight.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div xml:lang="es" class="book" title="Pensar en C++ (Volumen 2)" lang="es"><div class="titlepage"><div><div><h1 class="title"><a id="pecpp_v2"></a>Pensar en C++ <em class="parameter"><code>(Volumen 2)</code></em></h1></div><div><h2 class="subtitle">
      Traducción (INACABADA) del libro <span class="emphasis"><em>Thinking in C++,
	Volumen 2</em></span>
    </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Bruce</span> <span class="surname">Eckel</span></h3><div class="affiliation"><span class="orgname">Mindview, Inc.<br /></span></div></div></div></div><div><p class="copyright">Copyright © 2004 Bruce Eckel</p></div></div><hr /></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="chapter"><a href="#Intro">1. Introducción</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp1581792">1.1. Objetivos</a></span></dt><dt><span class="sect1"><a href="#idp94848">1.2. Capítulos</a></span></dt><dt><span class="sect1"><a href="#idp27528">1.3. Ejercicios</a></span></dt><dt><span class="sect1"><a href="#idp30656">1.4. Código fuente</a></span></dt><dt><span class="sect1"><a href="#idp32872">1.5. Compiladores</a></span></dt><dt><span class="sect1"><a href="#idp64112">1.6. Estándares del lenguaje</a></span></dt><dt><span class="sect1"><a href="#idp66392">1.7. Seminarios, CD-ROMs y consultoría</a></span></dt><dt><span class="sect1"><a href="#idp68472">1.8. Errores</a></span></dt><dt><span class="sect1"><a href="#idp69840">1.9. Sobre la portada</a></span></dt><dt><span class="sect1"><a href="#idp3453080">1.10. Agradecimientos</a></span></dt></dl></dd><dt><span class="part"><a href="#idp3467944">I. Construcción de Sistemas estables</a></span></dt><dd><dl><dt><span class="chapter"><a href="#C01">2. Tratamiento de excepciones</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3475240">2.1. Tratamiento tradicional de errores</a></span></dt><dt><span class="sect1"><a href="#idp3484424">2.2. Lanzar una excepción</a></span></dt><dt><span class="sect1"><a href="#idp3489904">2.3. Capturar una excepción</a></span></dt><dt><span class="sect1"><a href="#idp3497128">2.4. </a></span></dt><dt><span class="sect1"><a href="#idp3507464">2.5. Limpieza</a></span></dt><dt><span class="sect1"><a href="#idp3527200">2.6. Excepciones estándar</a></span></dt><dt><span class="sect1"><a href="#idp3532880">2.7. Especificaciones de excepciones</a></span></dt><dt><span class="sect1"><a href="#idp3548464">2.8. Seguridad de la excepción</a></span></dt><dt><span class="sect1"><a href="#idp3557392">2.9. Programar con excepciones</a></span></dt><dt><span class="sect1"><a href="#idp3566360">2.10. Sobrecarga</a></span></dt><dt><span class="sect1"><a href="#idp3569880">2.11. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp3570840">2.12. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C02">3. Programación defensiva</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3587224">3.1. Aserciones </a></span></dt><dt><span class="sect1"><a href="#idp3605256">3.2. Un framework de pruebas unitarias sencillo </a></span></dt><dt><span class="sect1"><a href="#idp3672264">3.3. Técnicas de depuración </a></span></dt><dt><span class="sect1"><a href="#idp3711160">3.4. Resumen </a></span></dt><dt><span class="sect1"><a href="#idp3713288">3.5. Ejercicios </a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#idp3722024">II. La librería Estándar de C++</a></span></dt><dd><dl><dt><span class="chapter"><a href="#C3">4. Las cadenas a fondo</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3742400">4.1. ¿Qué es un <code class="classname">string</code>?</a></span></dt><dt><span class="sect1"><a href="#idp3754520">4.2. Operaciones con cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3817824">4.3. Buscar en cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3949480">4.4. Una aplicación con cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3977376">4.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp3983032">4.6. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C04">5. Iostreams</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4010792">5.1. ¿Por que <code class="classname">iostream</code>? </a></span></dt><dt><span class="sect1"><a href="#idp4044104">5.2. <code class="classname">Iostreams</code> al rescate</a></span></dt><dt><span class="sect1"><a href="#idp4110296">5.3. Manejo errores de <code class="classname">stream</code></a></span></dt><dt><span class="sect1"><a href="#idp4146624">5.4. Iostreams de fichero</a></span></dt><dt><span class="sect1"><a href="#idp4178936">5.5. Almacenamiento de <code class="classname">iostream</code></a></span></dt><dt><span class="sect1"><a href="#idp4201664">5.6. Buscar en iostreams</a></span></dt><dt><span class="sect1"><a href="#idp4227208">5.7. Iostreams de <code class="classname">string</code></a></span></dt><dt><span class="sect1"><a href="#idp4265304">5.8. Formateo de stream de salida</a></span></dt><dt><span class="sect1"><a href="#idp4318832">5.9. Manipuladores</a></span></dt><dt><span class="sect1"><a href="#idp4358632">5.10.  </a></span></dt><dt><span class="sect1"><a href="#idp4388304">5.11.  </a></span></dt><dt><span class="sect1"><a href="#idp4400344">5.12.  </a></span></dt><dt><span class="sect1"><a href="#idp4400920">5.13.  </a></span></dt></dl></dd><dt><span class="chapter"><a href="#C05">6. Las plantillas en profundidad</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4410728">6.1.  </a></span></dt><dt><span class="sect1"><a href="#idp4459360">6.2.  </a></span></dt><dt><span class="sect1"><a href="#idp4497464">6.3.  </a></span></dt><dt><span class="sect1"><a href="#idp4524448">6.4.  </a></span></dt><dt><span class="sect1"><a href="#idp4550120">6.5.  </a></span></dt><dt><span class="sect1"><a href="#idp4575968">6.6.  </a></span></dt><dt><span class="sect1"><a href="#idp4617776">6.7.  </a></span></dt><dt><span class="sect1"><a href="#idp4632064">6.8.  </a></span></dt></dl></dd><dt><span class="chapter"><a href="#C06">7. Algoritmos genéricos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4641792">7.1. Un primer vistazo</a></span></dt><dt><span class="sect1"><a href="#idp4706488">7.2. Objetos-función</a></span></dt><dt><span class="sect1"><a href="#idp4765784">7.3. Un catálogo de algoritmos STL</a></span></dt><dt><span class="sect1"><a href="#idp4879440">7.4. Creando sus propios algoritmos tipo STL</a></span></dt><dt><span class="sect1"><a href="#idp4883000">7.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp4883960">7.6. Ejercicios</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#idp4898296">III. Temas especiales</a></span></dt><dd><dl><dt><span class="chapter"><a href="#C09">8. Herencia múltiple</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4905016">8.1. Perspectiva</a></span></dt><dt><span class="sect1"><a href="#idp4931136">8.2. Herencia de interfaces</a></span></dt><dt><span class="sect1"><a href="#idp4945776">8.3. Herencia de implementación</a></span></dt><dt><span class="sect1"><a href="#idp4963152">8.4. Subobjetos duplicados</a></span></dt><dt><span class="sect1"><a href="#idp4969320">8.5. Clases base virtuales</a></span></dt><dt><span class="sect1"><a href="#idp4985016">8.6. Cuestión sobre búsqueda de nombres</a></span></dt><dt><span class="sect1"><a href="#idp4992112">8.7. Evitar la MI</a></span></dt><dt><span class="sect1"><a href="#idp4993456">8.8. Extender una interface</a></span></dt><dt><span class="sect1"><a href="#idp5003216">8.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5004176">8.10. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C10">9. Patrones de Diseño</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5011344">9.1. El Concepto de Patrón </a></span></dt><dt><span class="sect1"><a href="#idp5022176">9.2. Clasificación de los patrones</a></span></dt><dt><span class="sect1"><a href="#idp5031576">9.3.  Simplificación de modismos</a></span></dt><dt><span class="sect1"><a href="#idp5041816">9.4. Singleton</a></span></dt><dt><span class="sect1"><a href="#idp5088232">9.5. Comando: elegir la operación </a></span></dt><dt><span class="sect1"><a href="#idp5115784">9.6. Desacoplamiento de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5134736">9.7. Adaptador</a></span></dt><dt><span class="sect1"><a href="#idp5145976">9.8. Template Method</a></span></dt><dt><span class="sect1"><a href="#idp5150296">9.9. Estrategia: elegir el algoritno en tiempo de ejecución</a></span></dt><dt><span class="sect1"><a href="#idp5156064">9.10. Cadena de Responsabilidad: intentar una secuencia de estrategias</a></span></dt><dt><span class="sect1"><a href="#idp5166728">9.11. Factorías: encapsular la creación de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5206568">9.12. Builder: creación de objetos complejos</a></span></dt><dt><span class="sect1"><a href="#idp5224808">9.13. Observador</a></span></dt><dt><span class="sect1"><a href="#idp5242824">9.14. Despachado múltiple</a></span></dt><dt><span class="sect1"><a href="#idp5256456">9.15. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5257224">9.16. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C11">10. Concurrencia</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5268520">10.1. Motivación</a></span></dt><dt><span class="sect1"><a href="#idp5277184">10.2. Concurrencia en C++</a></span></dt><dt><span class="sect1"><a href="#idp5301632">10.3. Utilización de los hilos</a></span></dt><dt><span class="sect1"><a href="#idp5367656">10.4. Comparición de recursos limitados</a></span></dt><dt><span class="sect1"><a href="#idp5445456">10.5. Finalización de tareas</a></span></dt><dt><span class="sect1"><a href="#idp5503488">10.6. Cooperación entre hilos</a></span></dt><dt><span class="sect1"><a href="#idp5544856">10.7. Bloqueo letal</a></span></dt><dt><span class="sect1"><a href="#idp5556744">10.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5561544">10.9. Ejercicios</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><strong>Lista de figuras</strong></p><dl><dt>8.1. <a href="#idp4915992"></a></dt><dt>8.2. <a href="#idp4927064"></a></dt></dl></div><div class="list-of-examples"><p><strong>Índice de listados</strong></p><dl><dt>2.1. <a href="#idp3481264">C01/Nonlocal.cpp</a></dt><dt>2.2. <a href="#idp3485616">C01/MyError.cpp</a></dt><dt>2.3. <a href="#idp3494152">C01/Nonlocal2.cpp</a></dt><dt>2.4. <a href="#idp3497768">C01/Autoexcp.cpp</a></dt><dt>2.5. <a href="#idp3499448">C01/Basexcpt.cpp</a></dt><dt>2.6. <a href="#idp3505432">C01/Terminator.cpp</a></dt><dt>2.7. <a href="#idp3508168">C01/Cleanup.cpp</a></dt><dt>2.8. <a href="#idp3511360">C01/Rawp.cpp</a></dt><dt>2.9. <a href="#idp3514888">C01/Wrapped.cpp</a></dt><dt>2.10. <a href="#idp3519792">C01/Auto_ptr.cpp</a></dt><dt>2.11. <a href="#idp3523416">C01/InitExcept.cpp</a></dt><dt>2.12. <a href="#idp3525760">C01/FunctionTryBlock.cpp</a></dt><dt>2.13. <a href="#idp3527952">C01/StdExcept.cpp</a></dt><dt>2.14. <a href="#idp3535216">C01/Unexpected.cpp</a></dt><dt>2.15. <a href="#idp3539256">C01/BadException.cpp</a></dt><dt>2.16. <a href="#idp3544728">C01/Covariance.cpp</a></dt><dt>2.17. <a href="#idp3552104">C01/SafeAssign.cpp</a></dt><dt>2.18. <a href="#idp3567640">C01/HasDestructor.cpp</a></dt><dt>3.1. <a href="#idp3582616">C02/HiLo.cpp</a></dt><dt>3.2. <a href="#idp3620936">C02/Date1.h</a></dt><dt>3.3. <a href="#idp3623288">C02/SimpleDateTest.cpp</a></dt><dt>3.4. <a href="#idp3626944">C02/SimpleDateTest2.cpp</a></dt><dt>3.5. <a href="#idp3633768">C02/DateTest.h</a></dt><dt>3.6. <a href="#idp3637824">C02/DateTest.cpp</a></dt><dt>3.7. <a href="#idp3647320">C03/StringSuite.cpp</a></dt><dt>3.8. <a href="#idp3653968"></a></dt><dt>3.9. <a href="#idp3661352"></a></dt><dt>3.10. <a href="#idp3664264"></a></dt><dt>3.11. <a href="#idp3667720"></a></dt><dt>3.12. <a href="#idp3682184">C03/Trace.h</a></dt><dt>3.13. <a href="#idp3683968">C03/Tracetst.cpp</a></dt><dt>3.14. <a href="#idp3692576">C02/MemCheck.h</a></dt><dt>3.15. <a href="#idp3696608">C02/MemCheck.cpp</a></dt><dt>3.16. <a href="#idp3706456">C02/MemTest.cpp</a></dt><dt>3.17. <a href="#idp3716080">C02/Rational.h</a></dt><dt>4.1. <a href="#idp3749488">C03/StringStorage.h</a></dt><dt>4.2. <a href="#idp3763208">C03/StrSize.cpp</a></dt><dt>4.3. <a href="#idp3778744">C03/StringReplace.cpp</a></dt><dt>4.4. <a href="#idp3783592">C03/Replace.cpp</a></dt><dt>4.5. <a href="#idp3791056">C03/ReplaceAndGrow.cpp</a></dt><dt>4.6. <a href="#idp3796512">C03/ReplaceAll.h</a></dt><dt>4.7. <a href="#idp3797728">C03/ReplaceAll.cpp</a></dt><dt>4.8. <a href="#idp3801896">C03/ReplaceAllTest.cpp</a></dt><dt>4.9. <a href="#idp3807432">C03/StringCharReplace.cpp</a></dt><dt>4.10. <a href="#idp3814584">C03/AddStrings.cpp</a></dt><dt>4.11. <a href="#idp3832504">C03/Sieve.h</a></dt><dt>4.12. <a href="#idp3836472">C03/Sieve.cpp</a></dt><dt>4.13. <a href="#idp3840504">C03/Find.h</a></dt><dt>4.14. <a href="#idp3845000">C03/Find.cpp</a></dt><dt>4.15. <a href="#idp3848936">C03/Rparse.h</a></dt><dt>4.16. <a href="#idp3853496">C03/Rparse.cpp</a></dt><dt>4.17. <a href="#idp3857904">C03/Trim.h</a></dt><dt>4.18. <a href="#idp3861200">C03/TrimTest.h</a></dt><dt>4.19. <a href="#idp3862744">C03/TrimTest.cpp</a></dt><dt>4.20. <a href="#idp3863936">C03/TrimTestMain.cpp</a></dt><dt>4.21. <a href="#idp3869504">C03/HTMLStripper.cpp</a></dt><dt>4.22. <a href="#idp3884912">C03/CompStr.h</a></dt><dt>4.23. <a href="#idp3886544">C03/CompStr.cpp</a></dt><dt>4.24. <a href="#idp3889368">C03/Equivalence.cpp</a></dt><dt>4.25. <a href="#idp3898448">C03/Compare.cpp</a></dt><dt>4.26. <a href="#idp3902440">C03/Compare2.cpp</a></dt><dt>4.27. <a href="#idp3905816">C03/StringIndexing.cpp</a></dt><dt>4.28. <a href="#idp3909040">C03/BadStringIndexing.cpp</a></dt><dt>4.29. <a href="#idp3932248">C03/ichar_traits.h</a></dt><dt>4.30. <a href="#idp3936976">C03/ICompare.cpp</a></dt><dt>4.31. <a href="#idp3943928">C03/iwchar_traits.h</a></dt><dt>4.32. <a href="#idp3947656">C03/IWCompare.cpp</a></dt><dt>4.33. <a href="#idp3959144">C03/ExtractCode.cpp</a></dt><dt>5.1. <a href="#idp4013184">C04/FileClass.h</a></dt><dt>5.2. <a href="#idp4017144">C04/FileClass.cpp</a></dt><dt>5.3. <a href="#idp4020968">C04/FileClassTest.cpp</a></dt><dt>5.4. <a href="#idp4027864">C04/Fullwrap.h</a></dt><dt>5.5. <a href="#idp4152256">C04/Strfile.cpp</a></dt><dt>5.6. <a href="#idp4188464">C04/Stype.cpp</a></dt><dt>5.7. <a href="#idp4193584">C04/Sbufget.cpp</a></dt><dt>5.8. <a href="#idp4212992">C04/Seeking.cpp</a></dt><dt>5.9. <a href="#idp4222656">C04/Iofile.cpp</a></dt><dt>5.10. <a href="#idp4233280">C04/Istring.cpp</a></dt><dt>5.11. <a href="#idp4244088">C04/DateIOTest.cpp</a></dt><dt>5.12. <a href="#idp4249640">C04/Ostring.cpp</a></dt><dt>5.13. <a href="#idp4255496">C04/HTMLStripper2.cpp</a></dt><dt>5.14. <a href="#idp4259832">C04/StringSeeking.cpp</a></dt><dt>5.15. <a href="#idp4282960">C04/Unitbuf.cpp</a></dt><dt>5.16. <a href="#idp4311888">C04/Format.cpp</a></dt><dt>5.17. <a href="#idp4343104">C04/Manips.cpp</a></dt><dt>5.18. <a href="#idp4348056">C04/InputWidth.cpp</a></dt><dt>5.19. <a href="#idp4352544">C04/nl.cpp</a></dt><dt>5.20. <a href="#idp4355552">C04/Effector.cpp</a></dt><dt>5.21. <a href="#idp4359848">C04/Cppcheck.cpp</a></dt><dt>5.22. <a href="#idp4370136">C04/Showerr.cpp</a></dt><dt>5.23. <a href="#idp4376440">C04/DataLogger.h</a></dt><dt>5.24. <a href="#idp4379056">C04/DataLogger.cpp</a></dt><dt>5.25. <a href="#idp4382744">C04/Datagen.cpp</a></dt><dt>5.26. <a href="#idp4386680">C04/Datascan.cpp</a></dt><dt>5.27. <a href="#idp4395472">C04/Locale.cpp</a></dt><dt>5.28. <a href="#idp4398256">C04/Facets.cpp</a></dt><dt>5.29. <a href="#idp4404504">C04/Exercise14.cpp</a></dt><dt>5.30. <a href="#idp4406248">C04/Exercise15.txt</a></dt><dt>6.1. <a href="#idp4415560">C05/Urand.h</a></dt><dt>6.2. <a href="#idp4418120">C05/UrandTest.cpp</a></dt><dt>6.3. <a href="#idp4423224">C05/FuncDef.cpp</a></dt><dt>6.4. <a href="#idp4425456">C05/TempTemp.cpp</a></dt><dt>6.5. <a href="#idp4430920">C05/TempTemp2.cpp</a></dt><dt>6.6. <a href="#idp4433576">C05/TempTemp3.cpp</a></dt><dt>6.7. <a href="#idp4437080">C05/TempTemp4.cpp</a></dt><dt>6.8. <a href="#idp4439800">C05/TypenamedID.cpp</a></dt><dt>6.9. <a href="#idp4442584">C05/PrintSeq.cpp</a></dt><dt>6.10. <a href="#idp4446608">C05/UsingTypename.cpp</a></dt><dt>6.11. <a href="#idp4448464">C05/DotTemplate.cpp</a></dt><dt>6.12. <a href="#idp4456456">C05/MemberClass.cpp</a></dt><dt>6.13. <a href="#idp4464408">C05/StringConv.h</a></dt><dt>6.14. <a href="#idp4466040">C05/StringConvTest.cpp</a></dt><dt>6.15. <a href="#idp4468424">C05/ImplicitCast.cpp</a></dt><dt>6.16. <a href="#idp4469968">C05/ArraySize.cpp</a></dt><dt>6.17. <a href="#idp4472104">C05/MinTest.cpp</a></dt><dt>6.18. <a href="#idp4475984">C05/TemplateFunctionAddress.cpp</a></dt><dt>6.19. <a href="#idp4478648">C05/FailedTransform.cpp</a></dt><dt>6.20. <a href="#idp4481952">C05/StrTolower.cpp</a></dt><dt>6.21. <a href="#idp4483472">C05/Tolower.cpp</a></dt><dt>6.22. <a href="#idp4484944">C05/ToLower2.cpp</a></dt><dt>6.23. <a href="#idp4487304">C05/ApplySequence.h</a></dt><dt>6.24. <a href="#idp4490496">C05/Gromit.h</a></dt><dt>6.25. <a href="#idp4492288">C05/ApplyGromit.cpp</a></dt><dt>6.26. <a href="#idp4495232">C05/PartialOrder.cpp</a></dt><dt>6.27. <a href="#idp4499360">C05/MinTest2.cpp</a></dt><dt>6.28. <a href="#idp4504672">C05/PartialOrder2.cpp</a></dt><dt>6.29. <a href="#idp4508320">C05/Sortable.h</a></dt><dt>6.30. <a href="#idp4512040">C05/Sortable.cpp</a></dt><dt>6.31. <a href="#idp4515560">C05/DelayedInstantiation.cpp</a></dt><dt>6.32. <a href="#idp4517232">C05/Nobloat.h</a></dt><dt>6.33. <a href="#idp4522528">C05/NobloatTest.cpp</a></dt><dt>6.34. <a href="#idp4529704">C05/Lookup.cpp</a></dt><dt>6.35. <a href="#idp4532096">C05/Lookup2.cpp</a></dt><dt>6.36. <a href="#idp4537056">C05/FriendScope.cpp</a></dt><dt>6.37. <a href="#idp4538704">C05/FriendScope2.cpp</a></dt><dt>6.38. <a href="#idp4540872">C05/FriendScope3.cpp</a></dt><dt>6.39. <a href="#idp4543288">C05/Box1.cpp</a></dt><dt>6.40. <a href="#idp4545528">C05/Box2.cpp</a></dt><dt>6.41. <a href="#idp4558344">C05/BearCorner.h</a></dt><dt>6.42. <a href="#idp4565544">C05/BearCorner2.cpp</a></dt><dt>6.43. <a href="#idp4569112">C05/CountedClass.cpp</a></dt><dt>6.44. <a href="#idp4571624">C05/CountedClass2.cpp</a></dt><dt>6.45. <a href="#idp4573896">C05/CountedClass3.cpp</a></dt><dt>6.46. <a href="#idp4576480">C05/Factorial.cpp</a></dt><dt>6.47. <a href="#idp4579152">C05/Fibonacci.cpp</a></dt><dt>6.48. <a href="#idp4582216">C05/Power.cpp</a></dt><dt>6.49. <a href="#idp4583904">C05/Accumulate.cpp</a></dt><dt>6.50. <a href="#idp4588520">C05/Unroll.cpp</a></dt><dt>6.51. <a href="#idp4590472">C05/Max.cpp</a></dt><dt>6.52. <a href="#idp4591896">C05/Conditionals.cpp</a></dt><dt>6.53. <a href="#idp4594880">C05/StaticAssert1.cpp</a></dt><dt>6.54. <a href="#idp4596504">C05/StaticAssert2.cpp</a></dt><dt>6.55. <a href="#idp4604448">C05/MyVector.cpp</a></dt><dt>6.56. <a href="#idp4610104">C05/MyVector2.cpp</a></dt><dt>6.57. <a href="#idp4621680">C05/OurMin.h</a></dt><dt>6.58. <a href="#idp4623088">C05/MinInstances.cpp</a></dt><dt>6.59. <a href="#idp4624728">C05/OurMin.cpp</a></dt><dt>6.60. <a href="#idp4628112">C05/OurMin2.h</a></dt><dt>6.61. <a href="#idp4629456">C05/OurMin2.cpp</a></dt><dt>6.62. <a href="#idp4633344">C05/Exercise4.cpp</a></dt><dt>6.63. <a href="#idp4635120">C05/Exercise7.cpp</a></dt><dt>6.64. <a href="#idp4636496">C05/Exercise8.cpp</a></dt><dt>7.1. <a href="#idp4644712">C06/CopyInts.cpp</a></dt><dt>7.2. <a href="#idp4650216">C06/CopyStrings.cpp</a></dt><dt>7.3. <a href="#idp4656152">C06/CopyVector.cpp</a></dt><dt>7.4. <a href="#idp4661096">C06/InsertVector.cpp</a></dt><dt>7.5. <a href="#idp4668280">C06/CopyInts2.cpp</a></dt><dt>7.6. <a href="#idp4672288">C06/CopyStrings2.cpp</a></dt><dt>7.7. <a href="#idp4677824">C06/ReplaceStrings.cpp</a></dt><dt>7.8. <a href="#idp4682176">C06/CopyInts3.cpp</a></dt><dt>7.9. <a href="#idp4687608">C06/CopyIntsToFile.cpp</a></dt><dt>7.10. <a href="#idp4690544">C06/CopyIntsFromFile.cpp</a></dt><dt>7.11. <a href="#idp4707616">C06/GreaterThanN.cpp</a></dt><dt>7.12. <a href="#idp4713216">C06/CopyInts4.cpp</a></dt><dt>7.13. <a href="#idp4716488">C06/CountNotEqual.cpp</a></dt><dt>7.14. <a href="#idp4723016">C06/Generators.h</a></dt><dt>7.15. <a href="#idp4724944">C06/Generators.cpp</a></dt><dt>7.16. <a href="#idp4726176">C06/FunctionObjects.cpp</a></dt><dt>7.17. <a href="#idp4734824">C06/FBinder.cpp</a></dt><dt>7.18. <a href="#idp4737352">C06/BinderValue.cpp</a></dt><dt>7.19. <a href="#idp4740824">C06/PtrFun1.cpp</a></dt><dt>7.20. <a href="#idp4743528">C06/PtrFun2.cpp</a></dt><dt>7.21. <a href="#idp4746040">C06/MemFun1.cpp</a></dt><dt>7.22. <a href="#idp4748968">C06/MemFun2.cpp</a></dt><dt>7.23. <a href="#idp4750920">C06/FindBlanks.cpp</a></dt><dt>7.24. <a href="#idp4754800">C06/NumStringGen.h</a></dt><dt>7.25. <a href="#idp4757528">C06/MemFun3.cpp</a></dt><dt>7.26. <a href="#idp4760528">C06/ComposeTry.cpp</a></dt><dt>7.27. <a href="#idp4762784">C06/ComposeFinal.cpp</a></dt><dt>7.28. <a href="#idp4769680">C06/PrintSequence.h</a></dt><dt>7.29. <a href="#idp4772824">C06/NString.h</a></dt><dt>7.30. <a href="#idp4777976">C06/FillGenerateTest.cpp</a></dt><dt>7.31. <a href="#idp4782776">C06/Counting.cpp</a></dt><dt>7.32. <a href="#idp4789992">C06/Manipulations.cpp</a></dt><dt>7.33. <a href="#idp4800040">C06/SearchReplace.cpp</a></dt><dt>7.34. <a href="#idp4812952">C06/Comparison.cpp</a></dt><dt>7.35. <a href="#idp4820568">C06/Removing.cpp</a></dt><dt>7.36. <a href="#idp4830120">C06/SortedSearchTest.cpp</a></dt><dt>7.37. <a href="#idp4835760">C06/MergeTest.cpp</a></dt><dt>7.38. <a href="#idp4841632">C06/SetOperations.cpp</a></dt><dt>7.39. <a href="#idp4849016">C06/Counted.h</a></dt><dt>7.40. <a href="#idp4850968">C06/ForEach.cpp</a></dt><dt>7.41. <a href="#idp4853024">C06/Transform.cpp</a></dt><dt>7.42. <a href="#idp4856200">C06/Inventory.h</a></dt><dt>7.43. <a href="#idp4859352">C06/CalcInventory.cpp</a></dt><dt>7.44. <a href="#idp4862488">C06/TransformNames.cpp</a></dt><dt>7.45. <a href="#idp4865328">C06/SpecialList.cpp</a></dt><dt>7.46. <a href="#idp4872520">C06/NumericTest.cpp</a></dt><dt>7.47. <a href="#idp4881000">C06/copy_if.h</a></dt><dt>8.1. <a href="#idp4934336">C09/Interfaces.cpp</a></dt><dt>8.2. <a href="#idp4940944">C09/Interfaces2.cpp</a></dt><dt>8.3. <a href="#idp4946544">C09/Database.h</a></dt><dt>8.4. <a href="#idp4948976">C09/UseDatabase.cpp</a></dt><dt>8.5. <a href="#idp4950224">C09/Countable.h</a></dt><dt>8.6. <a href="#idp4952256">C09/DBConnection.h</a></dt><dt>8.7. <a href="#idp4955096">C09/UseDatabase2.cpp</a></dt><dt>8.8. <a href="#idp4957592">C09/DBConnection2.h</a></dt><dt>8.9. <a href="#idp4959992">C09/UseDatabase3.cpp</a></dt><dt>8.10. <a href="#idp4963664">C09/Offset.cpp</a></dt><dt>8.11. <a href="#idp4966664">C09/Duplicate.cpp</a></dt><dt>8.12. <a href="#idp4969832">C09/VirtualBase.cpp</a></dt><dt>8.13. <a href="#idp4974592">C09/VirtualBase2.cpp</a></dt><dt>8.14. <a href="#idp4976880">C09/VirtualBase3.cpp</a></dt><dt>8.15. <a href="#idp4981288">C09/VirtInit.cpp</a></dt><dt>8.16. <a href="#idp4985608">C09/AmbiguousName.cpp</a></dt><dt>8.17. <a href="#idp4986944">C09/BreakTie.cpp</a></dt><dt>8.18. <a href="#idp4988496">C09/Dominance.cpp</a></dt><dt>8.19. <a href="#idp4990024">C09/Dominance2.cpp</a></dt><dt>8.20. <a href="#idp4994352">C09/Vendor.h</a></dt><dt>8.21. <a href="#idp4996336">C09/Vendor.cpp</a></dt><dt>8.22. <a href="#idp4998968">C09/Paste.cpp</a></dt><dt>9.1. <a href="#idp5033528">C10/MessengerDemo.cpp</a></dt><dt>9.2. <a href="#idp5039160">C10/CollectingParameterDemo.cpp</a></dt><dt>9.3. <a href="#idp5043568">C10/SingletonPattern.cpp</a></dt><dt>9.4. <a href="#idp5057464">C10/LogFile.h</a></dt><dt>9.5. <a href="#idp5059280">C10/LogFile.cpp</a></dt><dt>9.6. <a href="#idp5061832">C10/UseLog1.h</a></dt><dt>9.7. <a href="#idp5063464">C10/UseLog1.cpp</a></dt><dt>9.8. <a href="#idp5065160">C10/UseLog2.cpp</a></dt><dt>9.9. <a href="#idp5068048">C10/SingletonPattern2.cpp</a></dt><dt>9.10. <a href="#idp5070760">C10/FunctionStaticSingleton.cpp</a></dt><dt>9.11. <a href="#idp5075720">C10/CuriousSingleton.cpp</a></dt><dt>9.12. <a href="#idp5093704">C10/CommandPattern.cpp</a></dt><dt>9.13. <a href="#idp5104792">C10/MulticastCommand.cpp</a></dt><dt>9.14. <a href="#idp5120408">C10/ProxyDemo.cpp</a></dt><dt>9.15. <a href="#idp5129568">C10/KissingPrincess.cpp</a></dt><dt>9.16. <a href="#idp5131720">C10/KissingPrincess2.cpp</a></dt><dt>9.17. <a href="#idp5136336">C10/FibonacciGenerator.h</a></dt><dt>9.18. <a href="#idp5137944">C10/FibonacciGeneratorTest.cpp</a></dt><dt>9.19. <a href="#idp5140104">C10/FibonacciAdapter.cpp</a></dt><dt>9.20. <a href="#idp5147888">C10/TemplateMethod.cpp</a></dt><dt>9.21. <a href="#idp5152992">C10/Strategy.cpp</a></dt><dt>9.22. <a href="#idp5162752">C10/ChainOfReponsibility.cpp</a></dt><dt>9.23. <a href="#idp5171424">C10/ShapeFactory1.cpp</a></dt><dt>9.24. <a href="#idp5180952">C10/ShapeFactory2.cpp</a></dt><dt>9.25. <a href="#idp5191552">C10/AbstractFactory.cpp</a></dt><dt>9.26. <a href="#idp5198160">C10/VirtualConstructor.cpp</a></dt><dt>9.27. <a href="#idp5207360">C10/Bicycle.h</a></dt><dt>9.28. <a href="#idp5214240">C10/Bicycle.cpp</a></dt><dt>9.29. <a href="#idp5219232">C10/BuildBicycles.cpp</a></dt><dt>9.30. <a href="#idp5225896">C10/Observer.h</a></dt><dt>9.31. <a href="#idp5227664">C10/Observable.h</a></dt><dt>9.32. <a href="#idp5232552">C10/InnerClassIdiom.cpp</a></dt><dt>9.33. <a href="#idp5236312">C10/ObservedFlower.cpp</a></dt><dt>9.34. <a href="#idp5243768">C10/PaperScissorsRock.cpp</a></dt><dt>9.35. <a href="#idp5251872">C10/BeeAndFlowers.cpp</a></dt><dt>10.1. <a href="#idp5296704">C11/LiftOff.h</a></dt><dt>10.2. <a href="#idp5299696">C11/NoThread.cpp</a></dt><dt>10.3. <a href="#idp5303072">C11/BasicThreads.cpp</a></dt><dt>10.4. <a href="#idp5306960">C11/MoreBasicThreads.cpp</a></dt><dt>10.5. <a href="#idp5313952">C11/UnresponsiveUI.cpp</a></dt><dt>10.6. <a href="#idp5315904">C11/ResponsiveUI.cpp</a></dt><dt>10.7. <a href="#idp5325200">C11/ThreadedExecutor.cpp</a></dt><dt>10.8. <a href="#idp5331008">C11/PoolExecutor.cpp</a></dt><dt>10.9. <a href="#idp5337176">C11/ConcurrentExecutor.cpp</a></dt><dt>10.10. <a href="#idp5342888">C11/SynchronousExecutor.cpp</a></dt><dt>10.11. <a href="#idp5347544">C11/YieldingTask.cpp</a></dt><dt>10.12. <a href="#idp5351904">C11/SleepingTask.cpp</a></dt><dt>10.13. <a href="#idp5360360">C11/SimplePriorities.cpp</a></dt><dt>10.14. <a href="#idp5375904">C11/Incrementer.cpp</a></dt><dt>10.15. <a href="#idp5383712">C11/ReferenceCounting.cpp</a></dt><dt>10.16. <a href="#idp5391824">C11/EvenChecker.h</a></dt><dt>10.17. <a href="#idp5406064">C11/EvenGenerator.cpp</a></dt><dt>10.18. <a href="#idp5416128">C11/MutexEvenGenerator.cpp</a></dt><dt>10.19. <a href="#idp5425024">C11/GuardedEvenGenerator.cpp</a></dt><dt>10.20. <a href="#idp5428616">C11/TemporaryUnlocking.cpp</a></dt><dt>10.21. <a href="#idp5430616">C11/TimedLocking.cpp</a></dt><dt>10.22. <a href="#idp5433640">C11/SynchronizedClass.cpp</a></dt><dt>10.23. <a href="#idp5439328">C11/ThreadLocalVariables.cpp</a></dt><dt>10.24. <a href="#idp5450072">C11/Display.h</a></dt><dt>10.25. <a href="#idp5455592">C11/OrnamentalGarden.cpp</a></dt><dt>10.26. <a href="#idp5490208">C11/Interrupting.cpp</a></dt><dt>10.27. <a href="#idp5495152">C11/Interrupting2.cpp</a></dt><dt>10.28. <a href="#idp5499880">C11/Interrupting3.cpp</a></dt><dt>10.29. <a href="#idp5505720">C11/WaxOMatic.cpp</a></dt><dt>10.30. <a href="#idp5511176">C11/ToastOMatic.cpp</a></dt><dt>10.31. <a href="#idp5516336">C11/TQueue.h</a></dt><dt>10.32. <a href="#idp5519552">C11/TestTQueue.cpp</a></dt><dt>10.33. <a href="#idp5522240">C11/ToastOMaticMarkII.cpp</a></dt><dt>10.34. <a href="#idp5532312">C11/CarBuilder.cpp</a></dt><dt>10.35. <a href="#idp5545944">C11/DiningPhilosophers.h</a></dt><dt>10.36. <a href="#idp5551088">C11/DeadlockingDiningPhilosophers.cpp</a></dt><dt>10.37. <a href="#idp5554472">C11/FixedDiningPhilosophers.cpp</a></dt></dl></div><div class="chapter" title="1: Introducción"><div class="titlepage"><div><div><h2 class="title"><a id="Intro"></a>1: Introducción</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp1581792">1.1. Objetivos</a></span></dt><dt><span class="sect1"><a href="#idp94848">1.2. Capítulos</a></span></dt><dt><span class="sect1"><a href="#idp27528">1.3. Ejercicios</a></span></dt><dt><span class="sect1"><a href="#idp30656">1.4. Código fuente</a></span></dt><dt><span class="sect1"><a href="#idp32872">1.5. Compiladores</a></span></dt><dt><span class="sect1"><a href="#idp64112">1.6. Estándares del lenguaje</a></span></dt><dt><span class="sect1"><a href="#idp66392">1.7. Seminarios, CD-ROMs y consultoría</a></span></dt><dt><span class="sect1"><a href="#idp68472">1.8. Errores</a></span></dt><dt><span class="sect1"><a href="#idp69840">1.9. Sobre la portada</a></span></dt><dt><span class="sect1"><a href="#idp3453080">1.10. Agradecimientos</a></span></dt></dl></div><p>
    En el volumen 1 de este libro, aprendió los fundamentos de C y
    C++. En este volumen, veremos características más avanzadas, con
    miras hacia técnicas e ideas para realizar programas robustos en
    C++.

  </p><p>
    Asumimos que está familiarizado con el material presentado en el
    Volumen 1.
  </p><div class="sect1" title="1.1. Objetivos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp1581792"></a>1.1. Objetivos</h2></div></div></div><p>
      Nuestros objetivos en este libros son:
    </p><p>
      1. Presentar el material como un sencillo paso cada vez, de este
      modo el lector puede asimilar cada concepto antes de seguir
      adelante.
    </p><p>
      2. Enseñar técnicas de "programación práctica" que puede usar en
      la base del día a día.
    </p><p>
      3. Darle lo que pensamos que es importante para que entienda el
      lenguaje, más bien que todo lo que sabemos. Creemos que hay una
      "jerarquía de importancia de la información", y hay algunos hechos
      que el 95% de los programadores nunca necesitarán conocer, sino
      que sólo confundiría a la gente y añade complejidad a su
      percepción del lenguaje. Tomando un ejemplo de C, si
      memoriza la tabla de prioridad de operadores (nosotros nunca lo
      hicimos) puede escribir código ingenioso. Pero si debe
      pensarlo, confundirá al lector/mantenedor de ese código. De modo
      que olvide las precedencias y use paréntesis cuando las cosas no
      estén claras.
    </p><p>
      4. Manténgase suficientemente centrado en cada sección de modo que el
       tiempo de lectura -y el tiempo entre ejercicios- sea
       pequeño. Esto no sólo hace mantener las mentes de los lectores
       más activas e involucradas durante un seminario práctico sino
       que da al lector un mayor sentido de éxito.
    </p><p>
      Hemos procurado no usar ninguna versión de un vendedor
      particular de C++. Hemos probado el código sobre todas las
      implementaciones que pudimos (descriptas posteriormente en esta
      introducción), y cuando una implementación no funciona en
      absoluto porque no cumple el Estándar C++, lo hemos señalado en
      el ejemplo(verá las marcas en el código fuente) para excluirlo
      del proceso de construcción.

    </p><p>
      6. Automatizar la compilación y las pruebas del código en el
      libro. Hemos descubierto que el código que no está compilado y
      probado probablemente no funcione correctamente, de este modo en
      este volumen hemos provisto a los ejemplos con código de
      pruebas. Además, el código que puede descargar desde
      http://www.MindView.net ha sido extraído directamente del texto
      del libro usando programas que automáticamente crean makefiles
      para compilar y ejecutar las pruebas. De esta forma sabemos que
      el código en el libro es correcto.
    </p></div><div class="sect1" title="1.2. Capítulos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp94848"></a>1.2. Capítulos</h2></div></div></div><p>
      Aquí está una breve descripción de los capítulos que contiene
      este libro:
    </p><p>
      Parte 1: Construcción de sistemas estables
    </p><p>
      1. Manejar excepciones. Manejar errores ha sido siempre un problema
      en programación. Incluso si obedientemente devuelve información
      del error o pone una bandera, la función que llama puede
      simplemente ignorarlo. Manejar excepciones es una cualidad
      primordial en C++ que soluciona este problema permitiéndole
      "lanzar" un objeto fuera de su función cuando ocurre un error
      crítico. Tire diferentes tipos de objetos para diferentes
      errores, y la función que llama "coge" estos objetos en rutinas
      separadas de gestión de errores. Si lanza una excepción, no puede
      ser ignorada, de modo que puede garantizar que algo ocurrirá en
      respuesta a su error. La decisión de usar excepciones afecta
      al diseño del código positivamente, de modo fundamental.
    </p><p>
      2. Programación defensiva. Muchos problemas de software pueden ser
      prevenidos. Programar de forma defensiva es realizar cuidadosamente
      código de tal modo que los bugs son encontrados y arreglados
      pronto antes que puedan dañar en el campo. Usar aserciones es
      la única y más importante forma para validar su código durante el
      desarrollo, dejando al mismo tiempo seguimiento ejecutable de la
      documentación en su código que muestra sus pensamientos mientras
      escribe el código en primer lugar. Pruebe rigurosamente su
      código antes de darlo a otros. Un marco de trabajo de pruebas
      unitario automatizado es una herramienta indispensable para el
      éxito, en el desarrollo diario de software.
    </p><p>
      Parte 2: La biblioteca estándar de C++
    </p><p>
      3. Cadenas en profundidad. La actividad más común de programación
      es el procesamiento de texto. La clase string de C++ libera al
      programador de los temas de gestión de memoria, mientras al
      mismo tiempo proporciona una fuente de recursos para el
      procesamiento de texto. C++ también facilita el uso de una gran
      variedad de caracteres y locales para las aplicaciones de
      internacionalización.

    </p><p>
      4. Iostreams. Una de las bibliotecas original de C++-la que
      proporciona la facilidad básica de I/O-es llamada
      iostreams. Iostreams está destinado a reemplazar stdio.h de C
      con una biblioteca I/O que es más fácil de usar, más flexible, y
      extensible- que puede adaptarla para trabajar con sus nuevas
      clases. Este capítulo le enseña cómo hacer el mejor uso de la
      biblioteca actual I/O, fichero I/O, y formateo en memoria.
    </p><p>
      5. Plantillas en profundidad. La distintiva cualidad del "C++
      moderno" es el extenso poder de las plantillas. Las plantillas
      hacen algo más que sólo crear contenedores genéricos. Sostienen
      el desarrollo de bibliotecas robustas, genéricas y de alto
      rendimiento.Hay mucho por saber sobre plantillas-constituyen,
      como fue, un sub-lenguaje dentro del lenguaje C++, y da al
      programador un grado impresionante de control sobre el proceso
      de compilación. No es una exageración decir que las plantillas
      han revolucionado la programación de C++.
    </p><p>
      6. Algoritmos genéricos. Los algoritmos son el corazón de la
      informática, y C++, por medio de la facilidad de las plantillas,
      facilita un impresionante entorno de poder, eficiencia, y
      facilidad de uso de algoritmos genéricos. Los algoritmos
      estándar son también personalizables a través de objetos de
      función. Este capítulo examina cada algoritmo de la
      biblioteca. (Capítulos 6 y 7 abarcan esa parte de la biblioteca
      Estándar de C++ comúnmente conocida como Biblioteca de Plantilla
      Estándar, o STL.)
    </p><p>
      7. Contenedores genéricos e Iteradores. C++ proporciona todas las
      estructuras comunes de datos de modo de tipado fuerte. Nunca
      necesita preocuparse sobre qué tiene tal contenedor. La
      homogenidad de sus objetos está garantizada. Separar la #FIXME
      traversing de un contenedor del propio contenedor, otra
      realización de plantillas, se hace posible por medio de los
      iteradores. Este ingenioso arreglo permite una aplicación
      flexible de algoritmos a contenedores usando el más sencillo de
      los diseños.
    </p><p>
      Parte 3: Temas especiales
    </p><p>
      8. Identificación de tipo en tiempo de ejecución. La identificación
      de tipo en tiempo de ejecución (RTTI) encuentra el tipo exacto
      de un objeto cuando sólo tiene un puntero o referencia al tipo
      base. Normalmente, tendrá que ignorar a propósito el tipo exacto
      de un objeto y permitir al mecanismo de función virtual
      implementar el comportamiento correcto para ese tipo. Pero
      ocasionalmente (como las herramientas de escritura de
      software tales como los depuradores) es útil para conocer el
      tipo exacto de un objeto-con su información, puede realizar con
      frecuencia una operación en casos especiales de forma más
      eficiente. Este capítulo explica para qué es RTTT y como usarlo.
    </p><p>
      9. Herencia múltiple. Parece sencillo al principio: Una nueva clase
      hereda de más de una clase existente. Sin embargo, puede
      terminar con copias ambiguas y múltiples de objetos de la clase
      base. Ese problema está resuelto con clases bases virtuales,
      pero la mayor cuestión continua: ¿Cuándo usarla? La herencia
      múltiple es sólo imprescindible cuando necesite manipular un
      objeto por medio de más de un clase base común. Este capítulo
      explica la sintaxis para la herencia múltiple y muestra enfoques
      alternativos- en particular, como las plantillas solucionan un
      problema típico. Usar herencia múltiple para reparar un interfaz
      de clase "dañada" demuestra un uso valioso de esta cualidad.
    </p><p>
      10. Patrones de diseño. El más revolucionario avance en programación
      desde los objetos es la introducción de los patrones de
      diseño. Un patrón de diseño es una codificación independiente
      del lenguaje de una solución a un problema de programación
      común, expresado de tal modo que puede aplicarse a muchos
      contextos. Los patrones tales como Singleton, Factory Method, y
      Visitor ahora tienen lugar en discusiones diarias
      alrededor del teclado. Este capítulo muestra como implementar y
      usar algunos de los patrones de diseño más usados en C++.
    </p><p>
      11. Programación concurrente. La gente ha llegado a esperar
      interfaces de usuario sensibles que (parece que) procesan
      múltiples tareas simultáneamente. Los sistemas operativos
      modernos permiten a los procesos tener múltiples hilos que
      comparten el espacio de dirección del proceso. La programación
      multihilo requiere una perspectiva diferente, sin embargo, y
      viene con su propio conjunto de dificultades. Este capítulo
      utiliza un biblioteca disponible gratuitamente (la biblioteca
      ZThread por Eric Crahen de IBM) para mostrar como gestionar
      eficazmente aplicaciones multihilo en C++.
    </p></div><div class="sect1" title="1.3. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp27528"></a>1.3. Ejercicios</h2></div></div></div><p>
      Hemos descubierto que los ejercicios sencillos son
      excepcionalmente útiles durante un seminario para completar la
      comprensión de un estudiante. Encontrará una colección al final de
      cada capítulo.
    </p><p>
      Estos son bastante sencillos, de modo que puedan ser acabados en
      una suma de tiempo razonable en una situación de clase mientras
      el profesor observa, asegurándose que todos los estudiantes están
      absorbiendo el material. Algunos ejercicios son un poco más
      exigentes para mantener entretenidos a los estudiantes
      avanzados. Están todos diseñados para ser resueltos en un tiempo
      corto y sólo están allí para probar y refinar su conocimiento
      más bien que presentar retos mayores (presumiblemente, podrá
      encontrarlos o más probablemente ellos le encontrarán a usted).
    </p><div class="sect2" title="1.3.1. Soluciones de los ejercicios"><div class="titlepage"><div><div><h3 class="title"><a id="idp29568"></a>1.3.1. Soluciones de los ejercicios</h3></div></div></div><p>
	Las soluciones a los ejercicios pueden encontrarse en el
	documento electrónico La Guía de Soluciones Comentada de C++,
	Volumen 2, disponible por una cuota simbólica en
	http://www.MindView.net.
      </p></div></div><div class="sect1" title="1.4. Código fuente"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp30656"></a>1.4. Código fuente</h2></div></div></div><p>
      El código fuente para este libro está autorizado como software
      gratuito, distribuido por medio del sitio web
      http://www.MindView.net. Los derechos de autor le impiden volver
      a publicar el código impreso sin permiso.

    </p><p>
      En el directorio inicial donde desempaqueta el código encontrará
      el siguiente aviso de derechos de autor:
    </p><p>
      
    </p><p>
      Puede usar el código en sus proyectos y en clase siempre que el
      aviso de los derechos de autor se conserve.
    </p></div><div class="sect1" title="1.5. Compiladores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp32872"></a>1.5. Compiladores</h2></div></div></div><p>
      Su compilador podría no soportar todas las cualidades discutidas
      en este libro, especialmente si no tiene la versión más
      nueva de su compilador. Implementar un lenguaje como C++ es un
      tarea Hercúlea, y puede suponer que las cualidades aparecen por
      partes en lugar de todas juntas. Pero si intenta uno de los
      ejemplos del libro y obtiene muchos errores del compilador, no
      es necesariamente un error en el código o en el compilador-puede
      que sencillamente no esté implementado todavía en su compilador
      concreto.
    </p><p>
      Empleamos un número de compiladores para probar el código de
      este libro, en un intento para asegurar que nuestro código
      cumple el Estándar C++ y funcionará con todos los compiladores
      posibles. Desafortunadamente, no todos los compiladores cumplen
      el Estándar C++, y de este modo tenemos un modo de excluir
      ciertos ficheros de la construcción con esos compiladores. Estas
      exclusiones se reflejadas automáticamente en los makefiles
      creados para el paquete de código para este libro que puede
      descargar desde www.MindView.net. Puede ver las etiquetas de
      exclusión incrustadas en los comentarios al inicio de cada
      listado, de este modo sabrá si exigir a un compilador concreto
      que funcione con ese código (en pocos casos, el compilador
      realmente compilará el código pero el comportamiento de
      ejecución es erróneo, y excluimos esos también).
    </p><p>
      Aquí están las etiquetas y los compiladores que se excluyen
      de la construcción.
    </p><p>
      · {-dmc} El Compilador de Mars Digital de Walter Bright para
        Windows, descargable gratuitamente en
        www.DigitalMars.com. Este compilador es muy tolerante y así
        no verá casi ninguna de estas etiquetas en todo el libro.
    </p><p>
      · {-g++} La versión libre Gnu C++ 3.3.1, que viene preinstalada
    en la mayoría de los paquetes Linux y Macintosh OSX. También es
    parte de Cygwin para Windows (ver abajo). Está disponible para la
    mayoría de las plataformas en gcc.gnu.org.
    </p><p>
      · {-msc} Microsoft Version 7 con Visual C++ .NET (viene sólo con
    Visual Studio .NET; no descargable gratuitamente).
    </p><p>
      · {-bor} Borland C++ Version 6 (no la versión gratuita; éste
    está más actualizado).
    </p><p>
      · {-edg} Edison Design Group (EDG) C++. Este es el compilador de
    referencia para la conformidad con los estándares. Esta etiqueta
    existe a causa de los temas de biblioteca, y porque estábamos
    usando un copia gratis de la interfaz EDG con una implementación de la
    biblioteca gratuita de Dinkumware, Ltd. No aparecieron errores de
    compilación a causa sólo del compilador.
    </p><p>
      · {-mwcc} Metrowerks Code Warrior para Macintosh OS X. Fíjese que OS X
      viene con Gnu C++ preinstalado, también.
    </p><p>
      Si descarga y desempaqueta el paquete de código de este libro de
      www.MindView.net, encontrará los makefiles para construir el
      código para los compiladores de más arriba. Usabamos GNU-make
      disponible gratuitamente, que viene con Linux, Cygwin (una
      consola gratis de Unix que corre encima de Windows; ver
      www.Cygwin.com), o puede instalar en su plataforma, ver
      www.gnu.org/software/make. (Otros makes pueden o no funcionar
      con estos ficheros, pero no están soportados.) Una vez que
      instale make, si teclea make en la línea de comando obtendrá
      instrucciones de cómo construir el código del libro para los
      compiladores de más arriba.
    </p><p>
      Fíjese que la colocación de estas etiquetas en los ficheros en
      este libro indica el estado de la versión concreta del
      compilador en el momento que lo probamos. Es posible y
      probable que el vendedor del compilador haya mejorado el
      compilador desde la publicación de este libro. Es posible
      también que mientras que realizamos el libro con tantos compiladores, hayamos
      desconfigurado un compilador en concreto que en otro caso habría
      compilado el código correctamente. Por consiguiente, debería
      probar el código usted mismo con su compilador, y comprobar
      también el código descargado de www.MindView.net para ver que
      es actual.
    </p></div><div class="sect1" title="1.6. Estándares del lenguaje"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp64112"></a>1.6. Estándares del lenguaje</h2></div></div></div><p>
      A lo largo de este libro, cuando se hace referencia a la
      conformidad con el ANSI/ISO C estándar, estaremos haciendo
      referencia al estándar de 1989, y de forma general diremos
      solamente 'C.'. Sólo si es necesario distinguir entre el
      Estándar de C de 1989 y anteriores, versiones pre-Estándares de
      C haremos la distinción. No hacemos referencia a c99 en este libro.
    </p><p>
      El Comité de ANSI/ISO C++ hace mucho acabó el trabajo sobre el
      primer Estándar C++, comunmente conocido como C++98. Usaremos el
      término Standard C++ para referirnos a este lenguaje
      normalizado. Si nos referimos sencillamente a C++, asuma que
      queremos decir "Standard C++". El Comité de Estándares de C++
      continua dirigiendo cuestiones importantes para la comunidad de
      C++ que se convertirá en C++0x, un futuro Estándar de C++ que no
      estará probablemente disponible durante muchos años.
    </p></div><div class="sect1" title="1.7. Seminarios, CD-ROMs y consultoría"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp66392"></a>1.7. Seminarios, CD-ROMs y consultoría</h2></div></div></div><p>
      La compañía de Bruce Eckel, MindView, Inc., proporciona
      seminarios públicos prácticos de formación  basados en el
      material de este libro, y también para temas avanzados. El
      material seleccionado de cada capítulo representa una lección,
      que es sucedida por un periodo de ejercicios guiado de tal modo que
      cada estudiante recibe atención personalizada. También
      facilitamos formación en el lugar, consultoría, tutoría y
      comprobación de diseño y código. La información y los
      formularios de inscripción para los seminarios próximos y otra
      información de contacto se puede encontrar en http://www.MindView.net.
    </p></div><div class="sect1" title="1.8. Errores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp68472"></a>1.8. Errores</h2></div></div></div><p>
      No importa cuantos trucos usen los escritores para detectar
      errores, algunos siempre pasan desapercibidos y éstos a menudo
      destacan para un nuevo lector. Si descubre algo que cree ser un
      error, por favor use el sistema de respuesta incorporado en la
      versión electrónica de este libro, que encontrará en
      http://www.MindView.net. Su ayuda se valora.
    </p></div><div class="sect1" title="1.9. Sobre la portada"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp69840"></a>1.9. Sobre la portada</h2></div></div></div><p>
      El arte de la portada fue realizado por la mujer de Larry
      O'Brien, Tina Jensen (sí, el Larry O'Brien quien fue el editor
      de Software Development Magazine durante muchos años). No
      solamente los dibujos son bonitos, son también sugerencias
      excelentes de polimorfismo. La idea de usar estas imágenes viene de
      Daniel Will-Harris, el diseñador de portadas
      (www.Will-Harris.com), trabajando con Bruce.
    </p></div><div class="sect1" title="1.10. Agradecimientos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3453080"></a>1.10. Agradecimientos</h2></div></div></div><p>
      El volumen 2 de este libro se descuidó a mitad de estar acabado
      durante mucho tiempo mientras Bruce se distraía con otras
      cosas, en particular con Java, Patrones de Diseño y especialmente
      con Python (ver www.Python.org). Si Chuck no hubiera estado
      dispuesto (tontamente, él reflexiona algunas veces) a acabar la
      otra mitad y llevar las cosas al día, este libro casi
      seguramente no habría existido. No hay mucha gente a quien Bruce
      habría confiado tranquilamente este libro. La
      afición de Chuck por la precisión, la corrección y la
      explicación clara es lo que ha hecho que este libro sea tan
      bueno como es.
    </p><p>
      Jamie King trabajó como persona de prácticas bajo la dirección
      de Chuck durante la finalización de este libro. El fue una parte
      esencial en asegurarse que el libro se finalizaba, no sólo
      proporcionando contestación a Chuck, sino especialmente por
      su interrogatorio implacable y siendo puntilloso con cada
      elección que él no comprendía por completo. Si sus preguntas son
      respondidas por este libro, es probablemente porque Jamie las
      preguntó primero. Jamie también mejoró unos cuantos programas de
      ejemplo y creó muchos de los ejercicios al final de cada
      capítulo. Scott Baker, otro trabajador en prácticas de Chuck
      patrocinado por MindView, Inc., ayudó con los ejercicios del
      capítulo 3.
    </p><p>
      Eric Crahen de IBM fue decisivo en la finalización del
      capítulo 11 (Concurrencia). Cuando estábamos buscando un paquete
      de hilos, buscamos uno que fuese intuitivo y fácil de usar,
      mientras fuese suficientemente robusto para hacer el
      trabajo. Con Eric conseguimos esto y posteriormente- él estuvo
      sumamente cooperativo y ha usado nuestras contestaciones
      para mejorar su biblioteca, mientras nosotros también nos hemos
      beneficiado de su conocimiento.
    </p><p>
      Estamos agradecidos a Pete Becker por ser nuestro editor
      técnico. Pocas personas son tan elocuentes y exigentes como Pete,
      ni mencionar como experto en C++ y desarrollo de software
      en general. También dar gracias a Bjorn Karlsson por su cortés y
      oportuna asistencia técnica revisando el manuscrito entero con
      escaso aviso.
    </p><p>
      Walter Bright hizo esfuerzos Hercúleos para asegurarse que su
      compilador Digital Mars C++ compilaría los ejemplos de este
      libro. Puso disponible el compilador mediante descarga gratuita
      en http://www.DigitalMars.com. ¡Gracias, Walter!
    </p><p>
      Las ideas y conocimientos de este libro provienen también de
      muchas otras fuentes: amigos como Andrea Provaglio, Dan
      Saks, Scott Meyers, Charles Petzold, y Michael Wilk; los
      pioneros del lenguaje como Bjarne Stroustrup, Andrew Koening,
      y Rob Murray; los miembros del Comité de Estándares de C++ como
      Nathan Myers (quien fue especialmente servicial y generoso con
      sus perspicacias), Herb Sutter, PJ Plauger,  Kevlin Henney,
      David Abrahams, Tom Plum, Reg Charney, Tom Penello, Sam Druker,
      Uwe Steinmueller, John Spicer, Steve Adamczyk, y Daveed
      Vandevoorde; la gente que ha hablado en el apartado de C++ de la
      Conferencia de Desarrollo de Software (que Bruce creó y
      desarrolló, y en la que habló Chuck); Compañeros de Chuck como
      Michael Seaver, Huston Franklin, David Wagstaff, y muchos
      estudiantes en seminarios, quienes realizaron las preguntas que
      necesitamos escuchar para hacer el material más claro.
    </p><p>
      El diseño del libro, la elección de la fuente, el diseño de la
      portada, y la foto de la portada ha sido realizada por el amigo
      de Bruce Daniel Will-Harris, célebre autor y desiñador, que
      solía jugar con cartas temporales en el primer ciclo de
      secundaria mientras esperaba la invención de los ordenadores y
      la publicación asistida por ordenador. Sin embargo, presentamos
      las páginas listas para imprimir nosotros mismos, por lo tanto
      los errores de composición tipográfica son nuestros. Se ha usado
      Microsoft® Word XP para escribir el libro y crear la versión
      lista para imprimir. El cuerpo del texto está en Verdana y los
      títulos está en Verdana. El tipo de letra del código es Courier
      New.
    </p><p>
      Deseamos también dar las gracias a los múltiples profesionales
      en el Edison Design Group y Dinkumware, Ltd., por darnos copias
      gratis de su compilador y biblioteca (respectivamente). Sin su
      experta asistencia, dada gentilmente, algunos de los ejemplos de
      este libro no podrían haber sido probados- También queremos
      agradecer a Howard Hinnant y a la gente de Metrowerks por la
      copia de su compilador, y a Sandy Smith y la gente de SlickEdit
      por facilitar a Chuck un entorno de edición durante muchos
      años. Greg Comeau también facilitó un copia de su exitoso
      compilador basado en EDG, Comeau C++.
    </p><p>
      Gracias especialmente a todos nuestros profesores, y a todos
      nuestros estudiantes (que son también nuestros profesores).
    </p><p>
      Evan Cofsky (Evan@TheUnixMan.com) facilitó todo tipo de
      asistencia en el servidor también con el desarrollo de programas
      en su ahora lenguaje favorito, Python. Sharlynn Cobaugh y Paula
      Steuer fueron ayudantes decisivos, evitando que Bruce fuese
      sumergido en una avalancha de proyectos.
    </p><p>
      La pareja de Bruce Dawn McGee aportó una inspiración muy
      valiosa y un gran entusiasmo durante este proyecto. El elenco
      de amigos que han ayudado, pero no limitado a ellos: Mark
      Western, Gen Kiyooka, Kraig Brockschmidt, Zack Urlocker, Andrew
      Binstock, Neil Rubenking, Steve Sinofsky, JD Hildebrandt, Brian
      McElhinney, Brinkley Barr, Bill Gates en el Midnight Engineering
      Magazine, Larry Constantine y Lucy Lockwood, Tom Keffer, Greg
      Perry, Dan Putterman, Christi Westphal, Gene Wang, Dave Mayer,
      David Intersimone, Claire Sawyers, los italianos (Andrea
      Provaglio, Laura Fallai, Marco Cantu, Corrado, Ilsa and
      Christina Giustozzi), Chris y Laura Strand, The Almquists, Brad
      Jerbic, John Kruth y Marilyn Cvitanic, Holly Payne (¡sí, el
      famoso novelista!), Mark Mabry, The Robbins Families, The Moelter
      Families (y the McMillans), The Wilks, Dave Stoner, Laurie
      Adams, The Cranstons, Larry Fogg, Mike y Karen Sequeira, Gary
      Entsminger y Allison Brody, Chester Andersen, Joe Lordi, Dave y
      Brenda Bartlett, The Rentschlers, The Sudeks, Lynn y Todd, y sus
      familias. Y por supuesto, mamá y papá, Sandy, James y
      Natalie, Kim y Jared, Isaac, y Abbi.
    </p></div></div><div class="part" title="Parte I. Construcción de Sistemas estables"><div class="titlepage"><div><div><h1 class="title"><a id="idp3467944"></a>Parte I. Construcción de Sistemas estables</h1></div></div></div><div class="partintro" title="Construcción de Sistemas estables"><div></div><div class="highlights"><p>
	  Los ingenieros de software gastan tanto tiempo en validar código como el que
	  tardan en crearlo. La calidad es, o debería ser, el objetivo de todo
	  programador, y se puede recorrer un largo camino hacia ese objetivo eliminando
	  problemas antes de que aparezcan. Además, los sistemas software deberían ser lo
	  suficientemente robustos como para comportarse razonablemente en presencia de
	  problemas imprevistos.
	</p></div><p>
	Las excepciones se introdujeron en C++ para facilitar una
	gestión de errores sofisticada sin trocear el código con una
	innumerable cantidad de lógica de error. El Capítulo 1 explica
	cómo el uso apropiado de las excepciones puede hacer software
	FIXME:well-behaved, y también introduce los principios de diseño
	que subyacen al código seguro. En el Capítulo 2 cubrimos las
	pruebas unitarias y las técnicas de depuración que prevén
	maximizar la calidad del código antes de ser entregado. El uso
	de aserciones para expresar y reforzar las invariantes de un
	programa es una señal inequívoca de un ingeniero de software
	experimentado. También introducimos un entorno simple para dar
	soporte a las pruebas unitarias.
      </p><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="chapter"><a href="#C01">2. Tratamiento de excepciones</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3475240">2.1. Tratamiento tradicional de errores</a></span></dt><dt><span class="sect1"><a href="#idp3484424">2.2. Lanzar una excepción</a></span></dt><dt><span class="sect1"><a href="#idp3489904">2.3. Capturar una excepción</a></span></dt><dt><span class="sect1"><a href="#idp3497128">2.4. </a></span></dt><dt><span class="sect1"><a href="#idp3507464">2.5. Limpieza</a></span></dt><dt><span class="sect1"><a href="#idp3527200">2.6. Excepciones estándar</a></span></dt><dt><span class="sect1"><a href="#idp3532880">2.7. Especificaciones de excepciones</a></span></dt><dt><span class="sect1"><a href="#idp3548464">2.8. Seguridad de la excepción</a></span></dt><dt><span class="sect1"><a href="#idp3557392">2.9. Programar con excepciones</a></span></dt><dt><span class="sect1"><a href="#idp3566360">2.10. Sobrecarga</a></span></dt><dt><span class="sect1"><a href="#idp3569880">2.11. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp3570840">2.12. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C02">3. Programación defensiva</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3587224">3.1. Aserciones </a></span></dt><dt><span class="sect1"><a href="#idp3605256">3.2. Un framework de pruebas unitarias sencillo </a></span></dt><dt><span class="sect1"><a href="#idp3672264">3.3. Técnicas de depuración </a></span></dt><dt><span class="sect1"><a href="#idp3711160">3.4. Resumen </a></span></dt><dt><span class="sect1"><a href="#idp3713288">3.5. Ejercicios </a></span></dt></dl></dd></dl></div></div><div class="chapter" title="2: Tratamiento de excepciones"><div class="titlepage"><div><div><h2 class="title"><a id="C01"></a>2: Tratamiento de excepciones</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp3475240">2.1. Tratamiento tradicional de errores</a></span></dt><dt><span class="sect1"><a href="#idp3484424">2.2. Lanzar una excepción</a></span></dt><dt><span class="sect1"><a href="#idp3489904">2.3. Capturar una excepción</a></span></dt><dt><span class="sect1"><a href="#idp3497128">2.4. </a></span></dt><dt><span class="sect1"><a href="#idp3507464">2.5. Limpieza</a></span></dt><dt><span class="sect1"><a href="#idp3527200">2.6. Excepciones estándar</a></span></dt><dt><span class="sect1"><a href="#idp3532880">2.7. Especificaciones de excepciones</a></span></dt><dt><span class="sect1"><a href="#idp3548464">2.8. Seguridad de la excepción</a></span></dt><dt><span class="sect1"><a href="#idp3557392">2.9. Programar con excepciones</a></span></dt><dt><span class="sect1"><a href="#idp3566360">2.10. Sobrecarga</a></span></dt><dt><span class="sect1"><a href="#idp3569880">2.11. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp3570840">2.12. Ejercicios</a></span></dt></dl></div><p>
  Mejorar la recuperación de errores es una de las maneras más potentes
  de incrementar la robustez de su código.
  </p><p>

  </p><p>

  </p><p>
  Una de las principales características de C++ es el tratamiento o
  manejo de excepciones, el cual es una manera mejor de pensar acerca
  de los errores y su tratamiento. Con el tratamiento de excepciones:
  </p><p>
  1.  El código de manejo de errores no resulta tan tedioso de escribir
  y no se entremezcla con su código «normal». Usted escribe el código
  que desea que se ejecute, y más tarde, en una sección aparte, el código
  que se encarga de los problemas. Si realiza varias llamadas a la misma
  función, el manejo de errores de esa función se hará una sola vez, en un
  solo lugar.
  </p><p>
  2. Los errores no pueden ser ignorados. Si una función necesita enviar
  un mensaje de error al invocador de esa función, ésta «lanza» un objeto
  que representa a ese error fuera de la función. Si el invocador no
  «captura» el error y lo trata, éste pasa al siguiente ámbito abarcador,
  y así hasta que el error es capturado o el programa termina al no existir
  un manejador adecuado para ese tipo de excepción.
  </p><p>

  </p><div class="sect1" title="2.1. Tratamiento tradicional de errores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3475240"></a>2.1. Tratamiento tradicional de errores</h2></div></div></div><p>
    En la mayoría de ejemplos de estos volúmenes, usamos la función assert()
    para lo que fue concebida: para la depuración durante el desarrollo
    insertando código que puede deshabilitarse con #define NDEBUG en un producto
    comercial. Para la comprobación de errores en tiempo de ejecución
    se utilizan las funciones de require.h (assure( ) y require( ))
    desarrolladas en el capítulo 9 del Volumen 1 y repetidas aquí en el
    Apéndice B. Estas funciones son un modo conveniente de decir, «Hay un
    problema aquí que probablemente quiera manejar con un código algo
    más sofisticado, pero no es necesario que se distraiga con eso en
    este ejemplo.» Las funciones de require.h pueden parecer suficientes
    para programas pequeños, pero para productos complicados deseará
    escribir un código de manejo de errores más sofisticado.
    </p><p>
    El tratamiento de errores es bastante sencillo cuando uno sabe
    exactamente qué hacer, puesto que se tiene toda la información
    necesaria en ese contexto. Simplemente se trata el error en ese punto.
    </p><p>
    El problema ocurre cuando no se tiene suficiente información en ese
    contexto, y se necesita pasar la información sobre el error a un
    contexto diferente donde esa información sí que existe. En C, esta
    situación puede tratarse usando tres enfoques:
    </p><p>

    </p><p>
    2.  Usar el poco conocido sistema de manejo de señales de la biblioteca
    estándar de C, implementado en las funciones signal( ) (para determinar
    lo que ocurre cuando se presenta un evento) y raise( ) (para generar un evento).
    De nuevo, esta alternativa supone un alto acoplamiento debido a que
    requiere que el usuario de cualquier biblioteca que genere señales
    entienda e instale el mecanismo de manejo de señales adecuado. En proyectos
    grandes los números de las señales de las diferentes bibliotecas puede llegar
    a entrar en conflicto.
    </p><p>

    </p><p>
    Cuando se consideran los esquemas de tratamiento de errores para C++,
    hay un problema adicional que es crítico: Las técnicas de C de señales
    y setjmp( )/longjmp( ) no llaman a los destructores, por lo que los objetos
    no se limpian adecuadamente. (De hecho, si longjmp( ) salta más allá
    del final de un ámbito donde los destructores deben ser llamados, el
    comportamiento del programa es indefinido.) Esto hace casi imposible
    recuperarse efectivamente de una condición excepcional, puesto que
    siempre se están dejando objetos detrás sin limpiar y a los que ya
    no se tiene acceso. El siguiente ejemplo lo demuestra con setjmp/longjmp:
    </p><div class="example"><a id="idp3481264"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Nonlocal.cpp</span>
<span class="hl slc">// setjmp() &amp; longjmp().</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;csetjmp&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Rainbow <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Rainbow</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Rainbow()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Rainbow</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Rainbow()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">jmp_buf</span> kansas<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">oz</span><span class="hl opt">() {</span>
  Rainbow rb<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">3</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;there's no place like home&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">longjmp</span><span class="hl opt">(</span>kansas<span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">setjmp</span><span class="hl opt">(</span>kansas<span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;tornado, witch, munchkins...&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">oz</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Auntie Em! &quot;</span>
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I had the strangest dream...&quot;</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.1. C01/Nonlocal.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>
    El problema con C++ es que longjmp( ) no respeta los objetos; en particular
    no llama a los destructores cuando salta fuera de un ámbito.[1]
    Puesto que las llamadas a los destructores son esenciales, esta
    propuesta no es válida para C++. De hecho, el estándar de C++ aclara
    que saltar a un ámbito con goto (pasando por alto las llamadas a los
    constructores), o saltar fuera de un ámbito con longjmp( ) donde un
    objeto en la pila posee un destructor, constituye un comportamiento
    indefinido.
    </p></div><div class="sect1" title="2.2. Lanzar una excepción"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3484424"></a>2.2. Lanzar una excepción</h2></div></div></div><p>
    Si usted se encuentra en su código con una situación excepcional-es decir,
    si no tiene suficiente información en el contexto actual para decidir
    lo que hacer- puede enviar información acerca del error a un contexto
    mayor creando un objeto que contenga esa información y «lanzándolo»
    fuera de su contexto actual. Esto es lo que se llama lanzar una
    excepción. Este es el aspecto que tiene:
    </p><div class="example"><a id="idp3485616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:MyError.cpp {RunByHand}</span>

<span class="hl kwc">class</span> MyError <span class="hl opt">{</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwb">const</span> data<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MyError</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwb">const</span> msg <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">data</span><span class="hl opt">(</span>msg<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  <span class="hl slc">// Here we &quot;throw&quot; an exception object:</span>
  <span class="hl kwa">throw</span> <span class="hl kwd">MyError</span><span class="hl opt">(</span><span class="hl str">&quot;something bad happened&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// As you'll see shortly, we'll want a &quot;try block&quot; here:</span>
  <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.2. C01/MyError.cpp</strong></p></div><br class="example-break" /><p>
    MyError es una clase normal, que en este caso acepta un char*
    como argumento del constructor. Usted puede usar cualquier tipo
    para lanzar (incluyendo los tipos predefinidos), pero normalmente
    creará clases especial para lanzar excepciones.
    </p><p>
    La palabra clave throw hace que suceda una serie de cosas relativamente
    mágicas. En primer lugar se crea una copia del objeto que se está
    lanzando y se «devuelve» desde la función que contiene la
    expresión throw, aun cuando ese tipo de objeto no es lo que normalmente
    la función está diseñada para devolver. Un modo simplificado de pensar
    acerca del tratamiento de excepciones es como un mecanismo alternativo
    de retorno (aunque llegará a tener problemas si lleva esta analogía
    demasiado lejos). También es posible salir de ámbitos normales lanzando
    una excepción. En cualquier caso se devuelve un valor y se sale de la
    función o ámbito.
    </p><p>

    </p><p>
    Además es posible lanzar tantos tipos de objetos diferentes como se
    quiera. Típicamente, para cada categoría de error se lanzará un tipo
    diferente. La idea es almacenar la información en el objeto y en el
    nombre de la clase con el fin de quien esté en el contexto invocador
    pueda averiguar lo que hacer con esa excepción.
    </p></div><div class="sect1" title="2.3. Capturar una excepción"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3489904"></a>2.3. Capturar una excepción</h2></div></div></div><p>

    </p><div class="sect2" title="2.3.1. El bloque try"><div class="titlepage"><div><div><h3 class="title"><a id="idp3490472"></a>2.3.1. El bloque <code class="keyword">try</code></h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl slc">// Code that may generate exceptions</span>
<span class="hl opt">}</span>
</pre><p>

      </p></div><div class="sect2" title="2.3.2. Manejadores de excepción"><div class="titlepage"><div><div><h3 class="title"><a id="idp3492000"></a>2.3.2. Manejadores de excepción</h3></div></div></div><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl slc">// Code that may generate exceptions</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>type1 id1<span class="hl opt">) {</span>
    <span class="hl slc">// Handle exceptions of type1</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>type2 id2<span class="hl opt">) {</span>
    <span class="hl slc">// Handle exceptions of type2</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>type3 id3<span class="hl opt">)</span>
    <span class="hl slc">// Etc...</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>typeN idN<span class="hl opt">)</span>
    <span class="hl slc">// Handle exceptions of typeN</span>
<span class="hl opt">}</span>
<span class="hl slc">// Normal execution resumes here...</span>
</pre><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp3494152"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Nonlocal2.cpp</span>
<span class="hl slc">// Illustrates exceptions.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Rainbow <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Rainbow</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Rainbow()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Rainbow</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Rainbow()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">oz</span><span class="hl opt">() {</span>
  Rainbow rb<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">3</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;there's no place like home&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">throw</span> <span class="hl num">47</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;tornado, witch, munchkins...&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">oz</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Auntie Em! I had the strangest dream...&quot;</span>
         <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.3. C01/Nonlocal2.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="2.3.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp3496168"></a>2.3.3. </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="2.4."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3497128"></a>2.4. </h2></div></div></div><p>

    </p><p>

    </p><div class="example"><a id="idp3497768"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Autoexcp.cpp</span>
<span class="hl slc">// No matching conversions.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Except1 <span class="hl opt">{};</span>

<span class="hl kwc">class</span> Except2 <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Except2</span><span class="hl opt">(</span><span class="hl kwb">const</span> Except1<span class="hl opt">&amp;) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span> <span class="hl kwd">Except1</span><span class="hl opt">(); }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Except2<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside catch(Except2)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Except1<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside catch(Except1)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.4. C01/Autoexcp.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><div class="example"><a id="idp3499448"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Basexcpt.cpp</span>
<span class="hl slc">// Exception hierarchies.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> Trouble <span class="hl opt">{};</span>
  <span class="hl kwc">class</span> Small <span class="hl opt">:</span> <span class="hl kwc">public</span> Trouble <span class="hl opt">{};</span>
  <span class="hl kwc">class</span> Big <span class="hl opt">:</span> <span class="hl kwc">public</span> Trouble <span class="hl opt">{};</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span> <span class="hl kwd">Big</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X x<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    x<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>X<span class="hl opt">::</span>Trouble<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;caught Trouble&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Hidden by previous handler:</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>X<span class="hl opt">::</span>Small<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;caught Small Trouble&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>X<span class="hl opt">::</span>Big<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;caught Big Trouble&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.5. C01/Basexcpt.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><div class="sect2" title="2.4.1. Capturar cualquier excepción"><div class="titlepage"><div><div><h3 class="title"><a id="idp3501376"></a>2.4.1. Capturar cualquier excepción</h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwa">catch</span><span class="hl opt">(...) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;an exception was thrown&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>

      </p><p>

      </p></div><div class="sect2" title="2.4.2. Relanzar una excepción"><div class="titlepage"><div><div><h3 class="title"><a id="idp3502904"></a>2.4.2. Relanzar una excepción</h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwa">catch</span><span class="hl opt">(...) {</span>
cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;an exception was thrown&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl slc">// Deallocate your resource here, and then rethrow</span>
    <span class="hl kwa">throw</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>

      </p></div><div class="sect2" title="2.4.3. Excepciones no capturadas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3504344"></a>2.4.3. Excepciones no capturadas</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp3505432"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Terminator.cpp</span>
<span class="hl slc">// Use of set_terminate(). Also shows uncaught exceptions.</span>
<span class="hl ppc">#include &lt;exception&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">terminator</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I'll be back!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl opt">(*</span>old_terminate<span class="hl opt">)() =</span> <span class="hl kwd">set_terminate</span><span class="hl opt">(</span>terminator<span class="hl opt">);</span>

<span class="hl kwc">class</span> Botch <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> Fruit <span class="hl opt">{};</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Botch::f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">Fruit</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Botch</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span> <span class="hl str">'c'</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Botch b<span class="hl opt">;</span>
    b<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(...) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside catch(...)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.6. C01/Terminator.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div></div><div class="sect1" title="2.5. Limpieza"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3507464"></a>2.5. Limpieza</h2></div></div></div><p>

    </p><p>

    </p><div class="example"><a id="idp3508168"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Cleanup.cpp</span>
<span class="hl slc">// Exceptions clean up complete objects only.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Trace <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> counter<span class="hl opt">;</span>
  <span class="hl kwb">int</span> objid<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Trace</span><span class="hl opt">() {</span>
    objid <span class="hl opt">=</span> counter<span class="hl opt">++;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;constructing Trace #&quot;</span> <span class="hl opt">&lt;&lt;</span> objid <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>objid <span class="hl opt">==</span> <span class="hl num">3</span><span class="hl opt">)</span> <span class="hl kwa">throw</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Trace</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;destructing Trace #&quot;</span> <span class="hl opt">&lt;&lt;</span> objid <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> Trace<span class="hl opt">::</span>counter <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Trace n1<span class="hl opt">;</span>
    <span class="hl slc">// Throws exception:</span>
    Trace array<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">];</span>
    Trace n2<span class="hl opt">;</span>  <span class="hl slc">// Won't get here.</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;caught &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.7. C01/Cleanup.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><pre class="screen">
constructing Trace #0
constructing Trace #1
constructing Trace #2
constructing Trace #3
destructing Trace #2
destructing Trace #1
destructing Trace #0
caught 3
</pre><p>

    </p><div class="sect2" title="2.5.1. Gestión de recursos"><div class="titlepage"><div><div><h3 class="title"><a id="idp3510656"></a>2.5.1. Gestión de recursos</h3></div></div></div><p>

      </p><p>

      </p><div class="example"><a id="idp3511360"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Rawp.cpp</span>
<span class="hl slc">// Naked pointers.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Cat <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Cat</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Cat()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Cat</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Cat()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> sz<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;allocating a Dog&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">throw</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;deallocating a Dog&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">::</span><span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> UseResources <span class="hl opt">{</span>
  Cat<span class="hl opt">*</span> bp<span class="hl opt">;</span>
  Dog<span class="hl opt">*</span> op<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">UseResources</span><span class="hl opt">(</span><span class="hl kwb">int</span> count <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;UseResources()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    bp <span class="hl opt">=</span> <span class="hl kwa">new</span> Cat<span class="hl opt">[</span>count<span class="hl opt">];</span>
    op <span class="hl opt">=</span> <span class="hl kwa">new</span> Dog<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">UseResources</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~UseResources()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span> bp<span class="hl opt">;</span> <span class="hl slc">// Array delete</span>
    <span class="hl kwa">delete</span> op<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    UseResources <span class="hl kwd">ur</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside handler&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.8. C01/Rawp.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="screen">
UseResources()
Cat()
Cat()
Cat()
allocating a Dog
inside handler
</pre><p>

      </p></div><div class="sect2" title="2.5.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp3513864"></a>2.5.2. </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp3514888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Wrapped.cpp</span>
<span class="hl slc">// Safe, atomic pointers.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Simplified. Yours may have other arguments.</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">int</span> sz <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> PWrap <span class="hl opt">{</span>
  T<span class="hl opt">*</span> ptr<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> RangeError <span class="hl opt">{};</span> <span class="hl slc">// Exception class</span>
  <span class="hl kwd">PWrap</span><span class="hl opt">() {</span>
    ptr <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">[</span>sz<span class="hl opt">];</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;PWrap constructor&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">PWrap</span><span class="hl opt">() {</span>
    <span class="hl kwa">delete</span><span class="hl opt">[]</span> ptr<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;PWrap destructor&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">int</span> i<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>RangeError<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&gt;=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">)</span> <span class="hl kwa">return</span> ptr<span class="hl opt">[</span>i<span class="hl opt">];</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">RangeError</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Cat <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Cat</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Cat()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Cat</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Cat()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Dog <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Allocating a Dog&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">throw</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">[](</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Deallocating a Dog&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">::</span><span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">[](</span>p<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> UseResources <span class="hl opt">{</span>
  PWrap<span class="hl opt">&lt;</span>Cat<span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">&gt;</span> cats<span class="hl opt">;</span>
  PWrap<span class="hl opt">&lt;</span>Dog<span class="hl opt">&gt;</span> dog<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">UseResources</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;UseResources()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">UseResources</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~UseResources()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cats<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">].</span><span class="hl kwd">g</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    UseResources ur<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside handler&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(...) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inside catch(...)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.9. C01/Wrapped.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><pre class="screen">
Cat()
Cat()
Cat()
PWrap constructor
allocating a Dog
~Cat()
~Cat()
~Cat()
PWrap destructor
inside handler
</pre><p>

      </p></div><div class="sect2" title="2.5.3. auto_ptr"><div class="titlepage"><div><div><h3 class="title"><a id="idp3518976"></a>2.5.3. <code class="keyword">auto_ptr</code></h3></div></div></div><p>

      </p><div class="example"><a id="idp3519792"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Auto_ptr.cpp</span>
<span class="hl slc">// Illustrates the RAII nature of auto_ptr.</span>
<span class="hl ppc">#include &lt;memory&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> TraceHeap <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> siz<span class="hl opt">) {</span>
    <span class="hl kwb">void</span><span class="hl opt">*</span> p <span class="hl opt">= ::</span><span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span>siz<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Allocating TraceHeap object on the heap &quot;</span>
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;at address &quot;</span> <span class="hl opt">&lt;&lt;</span> p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> p<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Deleting TraceHeap object at address &quot;</span>
         <span class="hl opt">&lt;&lt;</span> p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">::</span><span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">TraceHeap</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>i<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getVal</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  auto_ptr<span class="hl opt">&lt;</span>TraceHeap<span class="hl opt">&gt;</span> <span class="hl kwd">pMyObject</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">TraceHeap</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> pMyObject<span class="hl opt">-&gt;</span><span class="hl kwd">getVal</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// Prints 5</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.10. C01/Auto_ptr.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div><div class="sect2" title="2.5.4. Bloques try a nivel de función"><div class="titlepage"><div><div><h3 class="title"><a id="idp3522424"></a>2.5.4. Bloques <code class="keyword">try</code> a nivel de función</h3></div></div></div><p>

      </p><div class="example"><a id="idp3523416"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:InitExcept.cpp {-bor}</span>
<span class="hl slc">// Handles exceptions from subobjects.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> BaseExcept <span class="hl opt">{};</span>
  <span class="hl kwd">Base</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>i<span class="hl opt">) {</span> <span class="hl kwa">throw</span> <span class="hl kwd">BaseExcept</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> DerivedExcept <span class="hl opt">{</span>
    <span class="hl kwb">const char</span><span class="hl opt">*</span> msg<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">DerivedExcept</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> msg<span class="hl opt">) :</span> <span class="hl kwd">msg</span><span class="hl opt">(</span>msg<span class="hl opt">) {}</span>
    <span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwd">what</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> msg<span class="hl opt">; }</span>
  <span class="hl opt">};</span>
  <span class="hl kwd">Derived</span><span class="hl opt">(</span><span class="hl kwb">int</span> j<span class="hl opt">)</span> <span class="hl kwa">try</span> <span class="hl opt">:</span> <span class="hl kwd">Base</span><span class="hl opt">(</span>j<span class="hl opt">) {</span>
    <span class="hl slc">// Constructor body</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;This won't print&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>BaseExcept<span class="hl opt">&amp;) {</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">DerivedExcept</span><span class="hl opt">(</span><span class="hl str">&quot;Base subobject threw&quot;</span><span class="hl opt">);;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Derived <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Derived<span class="hl opt">::</span>DerivedExcept<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> d<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// &quot;Base subobject threw&quot;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.11. C01/InitExcept.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp3525760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:FunctionTryBlock.cpp {-bor}</span>
<span class="hl slc">// Function-level try blocks.</span>
<span class="hl slc">// {RunByHand} (Don't run automatically by the makefile)</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">()</span> <span class="hl kwa">try</span> <span class="hl opt">{</span>
  <span class="hl kwa">throw</span> <span class="hl str">&quot;main&quot;</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> msg<span class="hl opt">) {</span>
   cout <span class="hl opt">&lt;&lt;</span> msg <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
   <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.12. C01/FunctionTryBlock.cpp</strong></p></div><br class="example-break" /><p>

      </p></div></div><div class="sect1" title="2.6. Excepciones estándar"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3527200"></a>2.6. Excepciones estándar</h2></div></div></div><p>

    </p><p>

    </p><div class="example"><a id="idp3527952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:StdExcept.cpp</span>
<span class="hl slc">// Derives an exception class from std::runtime_error.</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> MyError <span class="hl opt">:</span> <span class="hl kwc">public</span> runtime_error <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MyError</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> msg <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">) :</span> <span class="hl kwd">runtime_error</span><span class="hl opt">(</span>msg<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">MyError</span><span class="hl opt">(</span><span class="hl str">&quot;my message&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>MyError<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.13. C01/StdExcept.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="2.7. Especificaciones de excepciones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3532880"></a>2.7. Especificaciones de excepciones</h2></div></div></div><p>

    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>toobig<span class="hl opt">,</span> toosmall<span class="hl opt">,</span> divzero<span class="hl opt">);</span>
</pre><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
</pre><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp3535216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Unexpected.cpp</span>
<span class="hl slc">// Exception specifications &amp; unexpected(),</span>
<span class="hl slc">//{-msc} (Doesn't terminate properly)</span>
<span class="hl ppc">#include &lt;exception&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Up <span class="hl opt">{};</span>
<span class="hl kwc">class</span> Fit <span class="hl opt">{};</span>
<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">();</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>Up<span class="hl opt">,</span> Fit<span class="hl opt">) {</span>
  <span class="hl kwa">switch</span><span class="hl opt">(</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">case</span> <span class="hl num">1</span><span class="hl opt">:</span> <span class="hl kwa">throw</span> <span class="hl kwd">Up</span><span class="hl opt">();</span>
    <span class="hl kwa">case</span> <span class="hl num">2</span><span class="hl opt">:</span> <span class="hl kwa">throw</span> <span class="hl kwd">Fit</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl slc">// void g() {}         // Version 1</span>
<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span> <span class="hl num">47</span><span class="hl opt">; }</span> <span class="hl slc">// Version 2</span>

<span class="hl kwb">void</span> <span class="hl kwd">my_unexpected</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;unexpected exception thrown&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">set_unexpected</span><span class="hl opt">(</span>my_unexpected<span class="hl opt">);</span> <span class="hl slc">// (Ignores return value)</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;=</span><span class="hl num">3</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwd">f</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Up<span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Up caught&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Fit<span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Fit caught&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.14. C01/Unexpected.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp3539256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:BadException.cpp {-bor}</span>
<span class="hl ppc">#include &lt;exception&gt;</span>    <span class="hl slc">// For std::bad_exception</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Exception classes:</span>
<span class="hl kwc">class</span> A <span class="hl opt">{};</span>
<span class="hl kwc">class</span> B <span class="hl opt">{};</span>

<span class="hl slc">// terminate() handler</span>
<span class="hl kwb">void</span> <span class="hl kwd">my_thandler</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;terminate called&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// unexpected() handlers</span>
<span class="hl kwb">void</span> <span class="hl kwd">my_uhandler1</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span> <span class="hl kwd">A</span><span class="hl opt">(); }</span>
<span class="hl kwb">void</span> <span class="hl kwd">my_uhandler2</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span><span class="hl opt">; }</span>

<span class="hl slc">// If we embed this throw statement in f or g,</span>
<span class="hl slc">// the compiler detects the violation and reports</span>
<span class="hl slc">// an error, so we put it in its own function.</span>
<span class="hl kwb">void</span> <span class="hl kwd">t</span><span class="hl opt">() {</span> <span class="hl kwa">throw</span> <span class="hl kwd">B</span><span class="hl opt">(); }</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>A<span class="hl opt">) {</span> <span class="hl kwd">t</span><span class="hl opt">(); }</span>
<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>A<span class="hl opt">,</span> bad_exception<span class="hl opt">) {</span> <span class="hl kwd">t</span><span class="hl opt">(); }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">set_terminate</span><span class="hl opt">(</span>my_thandler<span class="hl opt">);</span>
  <span class="hl kwd">set_unexpected</span><span class="hl opt">(</span>my_uhandler1<span class="hl opt">);</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>A<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;caught an A from f&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">set_unexpected</span><span class="hl opt">(</span>my_uhandler2<span class="hl opt">);</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwd">g</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>bad_exception<span class="hl opt">&amp;) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;caught a bad_exception from g&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(...) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;This will never print&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.15. C01/BadException.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="sect2" title="2.7.1. ¿Mejores especificaciones de excepciones?"><div class="titlepage"><div><div><h3 class="title"><a id="idp3542624"></a>2.7.1. ¿Mejores especificaciones de excepciones?</h3></div></div></div><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(...);</span> <span class="hl slc">// Not in C++</span>
</pre><p>

      </p><p>

      </p></div><div class="sect2" title="2.7.2. Especificación de excepciones y herencia"><div class="titlepage"><div><div><h3 class="title"><a id="idp3544128"></a>2.7.2. Especificación de excepciones y herencia</h3></div></div></div><p>

      </p><div class="example"><a id="idp3544728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:Covariance.cpp {-xo}</span>
<span class="hl slc">// Should cause compile error. {-mwcc}{-msc}</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> BaseException <span class="hl opt">{};</span>
  <span class="hl kwc">class</span> DerivedException <span class="hl opt">:</span> <span class="hl kwc">public</span> BaseException <span class="hl opt">{};</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>DerivedException<span class="hl opt">) {</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">DerivedException</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>BaseException<span class="hl opt">) {</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">BaseException</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Derived <span class="hl opt">:</span> <span class="hl kwc">public</span> Base <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>BaseException<span class="hl opt">) {</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">BaseException</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>DerivedException<span class="hl opt">) {</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">DerivedException</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.16. C01/Covariance.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="2.7.3. Cuándo no usar especificaciones de excepción"><div class="titlepage"><div><div><h3 class="title"><a id="idp3547160"></a>2.7.3. Cuándo no usar especificaciones de excepción</h3></div></div></div><p>

      </p><pre class="programlisting">
T <span class="hl kwd">pop</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>logic_error<span class="hl opt">);</span>
</pre><p>

      </p></div></div><div class="sect1" title="2.8. Seguridad de la excepción"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3548464"></a>2.8. Seguridad de la excepción</h2></div></div></div><p>

    </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">pop</span><span class="hl opt">();</span>
</pre><p>

    </p><p>

    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> T stack<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span><span class="hl kwd">pop</span><span class="hl opt">() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">logic_error</span><span class="hl opt">(</span><span class="hl str">&quot;stack underflow&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">else</span>
    <span class="hl kwa">return</span> data<span class="hl opt">[--</span>count<span class="hl opt">];</span>
<span class="hl opt">}</span>
</pre><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp3552104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:SafeAssign.cpp</span>
<span class="hl slc">// An Exception-safe operator=.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;new&gt;</span>       <span class="hl slc">// For std::bad_alloc</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A class that has two pointer members using the heap</span>
<span class="hl kwc">class</span> HasPointers <span class="hl opt">{</span>
  <span class="hl slc">// A Handle class to hold the data</span>
  <span class="hl kwb">struct</span> MyData <span class="hl opt">{</span>
    <span class="hl kwb">const char</span><span class="hl opt">*</span> theString<span class="hl opt">;</span>
    <span class="hl kwb">const int</span><span class="hl opt">*</span> theInts<span class="hl opt">;</span>
    <span class="hl kwb">size_t</span> numInts<span class="hl opt">;</span>
    <span class="hl kwd">MyData</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> pString<span class="hl opt">,</span> <span class="hl kwb">const int</span><span class="hl opt">*</span> pInts<span class="hl opt">,</span>
      <span class="hl kwb">size_t</span> nInts<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">theString</span><span class="hl opt">(</span>pString<span class="hl opt">),</span> <span class="hl kwd">theInts</span><span class="hl opt">(</span>pInts<span class="hl opt">),</span> <span class="hl kwd">numInts</span><span class="hl opt">(</span>nInts<span class="hl opt">) {}</span>
  <span class="hl opt">} *</span>theData<span class="hl opt">;</span>  <span class="hl slc">// The handle</span>
  <span class="hl slc">// Clone and cleanup functions:</span>
  <span class="hl kwb">static</span> MyData<span class="hl opt">*</span> <span class="hl kwd">clone</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> otherString<span class="hl opt">,</span>
      <span class="hl kwb">const int</span><span class="hl opt">*</span> otherInts<span class="hl opt">,</span> <span class="hl kwb">size_t</span> nInts<span class="hl opt">) {</span>
    <span class="hl kwb">char</span><span class="hl opt">*</span> newChars <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">char</span><span class="hl opt">[</span><span class="hl kwd">strlen</span><span class="hl opt">(</span>otherString<span class="hl opt">)+</span><span class="hl num">1</span><span class="hl opt">];</span>
    <span class="hl kwb">int</span><span class="hl opt">*</span> newInts<span class="hl opt">;</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      newInts <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span>nInts<span class="hl opt">];</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>bad_alloc<span class="hl opt">&amp;) {</span>
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span> newChars<span class="hl opt">;</span>
      <span class="hl kwa">throw</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl slc">// This example uses built-in types, so it won't</span>
      <span class="hl slc">// throw, but for class types it could throw, so we</span>
      <span class="hl slc">// use a try block for illustration. (This is the</span>
      <span class="hl slc">// point of the example!)</span>
      <span class="hl kwd">strcpy</span><span class="hl opt">(</span>newChars<span class="hl opt">,</span> otherString<span class="hl opt">);</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> nInts<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
        newInts<span class="hl opt">[</span>i<span class="hl opt">] =</span> otherInts<span class="hl opt">[</span>i<span class="hl opt">];</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(...) {</span>
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span> newInts<span class="hl opt">;</span>
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span> newChars<span class="hl opt">;</span>
      <span class="hl kwa">throw</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return new</span> <span class="hl kwd">MyData</span><span class="hl opt">(</span>newChars<span class="hl opt">,</span> newInts<span class="hl opt">,</span> nInts<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static</span> MyData<span class="hl opt">*</span> <span class="hl kwd">clone</span><span class="hl opt">(</span><span class="hl kwb">const</span> MyData<span class="hl opt">*</span> otherData<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">clone</span><span class="hl opt">(</span>otherData<span class="hl opt">-&gt;</span>theString<span class="hl opt">,</span> otherData<span class="hl opt">-&gt;</span>theInts<span class="hl opt">,</span>
                 otherData<span class="hl opt">-&gt;</span>numInts<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">cleanup</span><span class="hl opt">(</span><span class="hl kwb">const</span> MyData<span class="hl opt">*</span> theData<span class="hl opt">) {</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span> theData<span class="hl opt">-&gt;</span>theString<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> <span class="hl opt">[]</span> theData<span class="hl opt">-&gt;</span>theInts<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> theData<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">HasPointers</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> someString<span class="hl opt">,</span> <span class="hl kwb">const int</span><span class="hl opt">*</span> someInts<span class="hl opt">,</span>
              <span class="hl kwb">size_t</span> numInts<span class="hl opt">) {</span>
    theData <span class="hl opt">=</span> <span class="hl kwd">clone</span><span class="hl opt">(</span>someString<span class="hl opt">,</span> someInts<span class="hl opt">,</span> numInts<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">HasPointers</span><span class="hl opt">(</span><span class="hl kwb">const</span> HasPointers<span class="hl opt">&amp;</span> source<span class="hl opt">) {</span>
    theData <span class="hl opt">=</span> <span class="hl kwd">clone</span><span class="hl opt">(</span>source<span class="hl opt">.</span>theData<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  HasPointers<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> HasPointers<span class="hl opt">&amp;</span> rhs<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span> <span class="hl opt">!= &amp;</span>rhs<span class="hl opt">) {</span>
      MyData<span class="hl opt">*</span> newData <span class="hl opt">=</span> <span class="hl kwd">clone</span><span class="hl opt">(</span>rhs<span class="hl opt">.</span>theData<span class="hl opt">-&gt;</span>theString<span class="hl opt">,</span>
        rhs<span class="hl opt">.</span>theData<span class="hl opt">-&gt;</span>theInts<span class="hl opt">,</span> rhs<span class="hl opt">.</span>theData<span class="hl opt">-&gt;</span>numInts<span class="hl opt">);</span>
      <span class="hl kwd">cleanup</span><span class="hl opt">(</span>theData<span class="hl opt">);</span>
      theData <span class="hl opt">=</span> newData<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">HasPointers</span><span class="hl opt">() {</span> <span class="hl kwd">cleanup</span><span class="hl opt">(</span>theData<span class="hl opt">); }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> HasPointers<span class="hl opt">&amp;</span> obj<span class="hl opt">) {</span>
    os <span class="hl opt">&lt;&lt;</span> obj<span class="hl opt">.</span>theData<span class="hl opt">-&gt;</span>theString <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> obj<span class="hl opt">.</span>theData<span class="hl opt">-&gt;</span>numInts<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      os <span class="hl opt">&lt;&lt;</span> obj<span class="hl opt">.</span>theData<span class="hl opt">-&gt;</span>theInts<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> os<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> someNums<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span> <span class="hl opt">};</span>
  <span class="hl kwb">size_t</span> someCount <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> someNums <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> someNums<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span> someMoreNums<span class="hl opt">[] = {</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">,</span> <span class="hl num">7</span> <span class="hl opt">};</span>
  <span class="hl kwb">size_t</span> someMoreCount <span class="hl opt">=</span>
  <span class="hl kwa">sizeof</span> someMoreNums <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> someMoreNums<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  HasPointers <span class="hl kwd">h1</span><span class="hl opt">(</span><span class="hl str">&quot;Hello&quot;</span><span class="hl opt">,</span> someNums<span class="hl opt">,</span> someCount<span class="hl opt">);</span>
  HasPointers <span class="hl kwd">h2</span><span class="hl opt">(</span><span class="hl str">&quot;Goodbye&quot;</span><span class="hl opt">,</span> someMoreNums<span class="hl opt">,</span> someMoreCount<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> h1 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// Hello: 1 2 3 4</span>
  h1 <span class="hl opt">=</span> h2<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> h1 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// Goodbye: 5 6 7</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.17. C01/SafeAssign.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p></div><div class="sect1" title="2.9. Programar con excepciones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3557392"></a>2.9. Programar con excepciones</h2></div></div></div><p>

    </p><div class="sect2" title="2.9.1. Cuándo evitar las excepciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp3557904"></a>2.9.1. Cuándo evitar las excepciones</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="2.9.2. Usos típicos de excepciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp3560088"></a>2.9.2. Usos típicos de excepciones</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="2.10. Sobrecarga"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3566360"></a>2.10. Sobrecarga</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp3567640"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C01:HasDestructor.cpp {O}</span>
<span class="hl kwc">class</span> HasDestructor <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">HasDestructor</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">();</span> <span class="hl slc">// For all we know, g may throw.</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  HasDestructor h<span class="hl opt">;</span>
  <span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 2.18. C01/HasDestructor.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="2.11. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3569880"></a>2.11. Resumen</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="2.12. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3570840"></a>2.12. Ejercicios</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div></div><div class="chapter" title="3: Programación defensiva"><div class="titlepage"><div><div><h2 class="title"><a id="C02"></a>3: Programación defensiva</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp3587224">3.1. Aserciones </a></span></dt><dt><span class="sect1"><a href="#idp3605256">3.2. Un framework de pruebas unitarias sencillo </a></span></dt><dt><span class="sect1"><a href="#idp3672264">3.3. Técnicas de depuración </a></span></dt><dt><span class="sect1"><a href="#idp3711160">3.4. Resumen </a></span></dt><dt><span class="sect1"><a href="#idp3713288">3.5. Ejercicios </a></span></dt></dl></div><p>
    Escribir software puede ser un objetivo difícil para
    desarrolladores, pero unas pocas técnicas defensivas, aplicadas
    rutinariamente, pueden dirigir a un largo camino hacia la mejora
    de la calidad de su código.
  </p><p>
    Aunque la complejidad de la producción típica de software
    garantiza que los probadores tendrán siempre trabajo, esperamos
    que anheles producir software sin defectos. Las técnicas de diseño
    orientada a objetos hacen mucho para limitar la dificultad de
    proyectos grandes, pero finalmente debe escribir bucles y
    funciones. Estos pequeños detalles de programación se convierten
    en los bloques de construcción de componentes mayores necesarios
    para sus diseños. Si sus blucles fallan por uno o sus funciones
    calculan los valores correctos sólo la mayoría de las veces, tiene
    problemas no importa como de elaborada sea su metodología
    general. En este capítulo, verá prácticas que ayudan a crear código
    robusto sin importar el tamaño de su proyecto.
  </p><p>
  Su código es, entre otras cosas, una expresión de su intento de
  resolver un problema. Sería claro para el lector (incluyendo usted)
  exactamente lo que estaba pensando cuando diseño aquel bucle. En
  ciertos puntos de su programa, deberá crear atreverse con sentencias
  que considera alguna u otra condición. (Si no puede, no ha realmente
  solucionado todavía el problema.) Tales sentencias se llaman invariantes, puesto
  que deberían ser invariablemente verdad en el punto donde aparecen
  en el código; si no, o su diseño es defectuoso, o su código no
  refleja con precisión su diseño.
  </p><p>
     Considere un programa que juega al juego de adivinanza
     mayor-menor. Una persona piensa un número entre el 1 y 100,y la
     otra persona adivina el número. (Permitirá al ordenador hacer la
     adivinanza.) La persona que piensa el número le dice al
     adivinador si su conjetura es mayor, menor o correcta. La mejor
     estrategia para el adivinador es la búsqueda binaria, que elige
     el punto medio del rango de los números donde el número buscado
     reside. La respuesta mayor-menor dice al adivinador que mitad de
     la lista ocupa el número, y el proceso se repite, reduciendo el
     tamaño del rango de búsqueda activo en cada iteración. ¿Entonces
     cómo escribe un bucle para realizar la repetición correctamente?
     No es suficiente simplemente decir
  </p><p>
    bool adivinado = false;
  </p><p>
    while(!adivinado) {
    ...
    }
  </p><p>
    porque un usuario malintencionado podría responder engañosamente,
    y podría pasarse todo el día adivinando. ¿ Qué suposición, que sea
    sencilla, está haciendo cada vez que adivina? En otras palabras,
    ¿qué condición debería cumplir por diseño en cada iteración del bucle?
  </p><p>
    La suposición sencilla es que el número secreto está dentro del
    actual rango activo de números sin adivinar: [1, 100]. Suponga que
    etiquetamos los puntos finales del rango con las variables bajo y
    alto. Cada vez que pasa por el bucle necesita asegurarse que si el
    número estaba en el rango [bajo, alto] al principio del bucle,
    calcule el nuevo rango de modo que todavía contenga el número al
    final de la iteración en curso.
  </p><p>
    El objetivo es expresar el invariante del bucle en código de modo
    que una violación pueda ser detectada en tiempo de
    ejecución. Desafortunadamente, ya que el ordenador no conoce el
    número secreto, no puede expresar esta condición directamente en
    código, pero puede al menos hacer un comentario para este efecto:
  </p><p>
    while(!adivinado) {
    // INVARIANTE: el número está en el rango [low, high]
  </p><p>
    ¿Qué ocurre cuando el usuario dice que una conjetura es demasiado
    alta o demasiado baja cuando no lo es? El engaño excluiría el
    número secreto del nuevo subrango. Porque una mentira siempre
    dirige a otra, finalmente su rango disminuirá a nada (puesto que se
    reduce a la mitad cada vez y el número secreto no está
    allí). Podemos expresar esta condición en el siguiente programa:
  </p><div class="example"><a id="idp3582616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:HiLo.cpp {RunByHand}</span>
<span class="hl slc">// Plays the game of Hi-Lo to illustrate a loop invariant.</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Think of a number between 1 and 100&quot;</span> <span class="hl opt">&lt;&lt;</span> endl
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I will make a guess; &quot;</span>
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;tell me if I'm (H)igh or (L)ow&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">int</span> low <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">,</span> high <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
  <span class="hl kwb">bool</span> guessed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(!</span>guessed<span class="hl opt">) {</span>
    <span class="hl slc">// Invariant: the number is in the range [low, high]</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>low <span class="hl opt">&gt;</span> high<span class="hl opt">) {</span>  <span class="hl slc">// Invariant violation</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;You cheated! I quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">int</span> guess <span class="hl opt">= (</span>low <span class="hl opt">+</span> high<span class="hl opt">) /</span> <span class="hl num">2</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;My guess is &quot;</span> <span class="hl opt">&lt;&lt;</span> guess <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;. &quot;</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;(H)igh, (L)ow, or (E)qual? &quot;</span><span class="hl opt">;</span>
    string response<span class="hl opt">;</span>
    cin <span class="hl opt">&gt;&gt;</span> response<span class="hl opt">;</span>
    <span class="hl kwa">switch</span><span class="hl opt">(</span><span class="hl kwd">toupper</span><span class="hl opt">(</span>response<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">])) {</span>
      <span class="hl kwa">case</span> <span class="hl str">'H'</span><span class="hl opt">:</span>
        high <span class="hl opt">=</span> guess <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">;</span>
        <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'L'</span><span class="hl opt">:</span>
        low <span class="hl opt">=</span> guess <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
        <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl str">'E'</span><span class="hl opt">:</span>
        guessed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        <span class="hl kwa">break</span><span class="hl opt">;</span>
      <span class="hl kwa">default</span><span class="hl opt">:</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Invalid response&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">continue</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I got it!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">return</span> EXIT_SUCCESS<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.1. C02/HiLo.cpp</strong></p></div><br class="example-break" /><p>
    La violación del invariante se detecta con la condición if(menor &gt;
    mayor), porque si el usuario siempre dice la verdad, siempre
    encontraremos el número secreto antes que agotásemos los intentos.
  </p><p>
    Usamos también una técnica del estándar C para informar sobre el
    estado de un programa al contexto llamante devolviendo diferentes
    valores desde main( ). Es portable para usar la sentencia return
    0; para indicar éxito, pero no hay un valor portable para indicar
    fracaso. Por esta razón usamos la macro declarada para este
    propósito en &lt;cstdlib&gt;:EXIT_FAILURE. Por consistencia, cuando
    usamos EXIT_FAILURE también usamos EXIT_SUCCESS, a pesar de que
    éste es siempre definido como cero.
  </p><div class="sect1" title="3.1. Aserciones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3587224"></a>3.1. Aserciones </h2></div></div></div><p>
      La condición en el programa mayor-menor depende de la entrada
      del usuario, por lo tanto no puede prevenir una violación del
      invariante. Sin embargo, los invariantes normalmente dependen
      solo del código que escribe, por eso comprobarán siempre si ha
      implementado su diseño correctamente. En este caso, es más claro
      hacer una aserción, que es un sentencia positiva que muestra sus
      decisiones de diseño.
    </p><p>
      Suponga que está implementando un vector de enteros: un array
      expandible que crece a petición. La función que añade un
      elemento al vector debe primero verificar que hay un espacio
      vacío en el array subyacente que contiene los elementos; de lo
      contrario, necesita solicitar más espacio en la pila y copiar
      los elementos existentes al nuevo espacio antes de añadir el
      nuevo elemento (y borrar el viejo array). Tal función podría ser
      de la siguiente forma:
    </p><pre class="programlisting">
<span class="hl kwb">void</span> MyVector<span class="hl opt">::</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span>
<span class="hl kwa">if</span><span class="hl opt">(</span>nextSlot <span class="hl opt">==</span> capacity<span class="hl opt">)</span>
<span class="hl kwd">grow</span><span class="hl opt">();</span>
<span class="hl kwa">assert</span><span class="hl opt">(</span>nextSlot <span class="hl opt">&lt;</span> capacity<span class="hl opt">);</span>
data<span class="hl opt">[</span>nextSlot<span class="hl opt">++] =</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>
      En este ejemplo, la información es un array dinámico de ints con
      capacidad espacios y espacioSiguiente espacios en uso. El
      propósito de grow( ) es expandir el tamaño de la información
      para que el nuevo valor de capacidad sea estrictamente mayor
      que espacioSiguiente. El comportamiento correcto de MiVector
      depende de esta decisión de diseño, y nunca fallará si el resto
      del código secundario es correcto. Afirmamos la condición con la
      macro assert( ), que está definido en la cabecera &lt;cassert&gt;.
    </p><p>
      La macro assert( ) de la biblioteca Estándar de C es breve, que
      resulta, portable. Si la condición en su parámetro no evalúa a
      cero, la ejecución continúa ininterrumpidamente; si no, un
      mensaje contiene el texto de la expresión culpable con su nombre
      de fichero fuente y el número de línea impreso en el canal de
      error estándar y el programa se suspende. ¿Es eso tan drástico?
      En la práctica, es mucho más drástico permitir que la ejecución
      continue cuando un supuesto de diseño básico ha fracasado. Su
      programa necesita ser arreglado.
    </p><p>
      Si todo va bien, probará a conciencia su código con todas las
      aserciones intactas hasta el momento en que se haga uso del
      producto final. (Diremos más sobre pruebas más tarde.) Depende
      de la naturaleza de su aplicación, los ciclos de máquina
      necesarios para probar todas las aserciones en tiempo de
      ejecución podrían tener demasiado impacto en el rendimiento en
      producción. En ese caso, puede eliminar todas las aserciones del
      código automáticamente definiendo la macro NDEBUG y reconstruir
      la aplicación.
    </p><p>
      Para ver como funciona esto, observe que una implementación
      típica de assert( ) se parece a esto:
    </p><pre class="programlisting">
<span class="hl ppc">#ifdef NDEBUG</span>
<span class="hl ppc">#define assert(cond) ((void)0)</span>
<span class="hl ppc">#else</span>
<span class="hl kwb">void</span> <span class="hl kwd">assertImpl</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*,</span> <span class="hl kwb">const char</span><span class="hl opt">*,</span> <span class="hl kwb">long</span><span class="hl opt">);</span>
<span class="hl ppc">#define assert(cond) \</span>
<span class="hl ppc">((cond) ? (void)0 : assertImpl(???))</span>
<span class="hl ppc">#endif</span>
</pre><p>
      Cuando la macro NDEBUG está definida, el código se descompone a la
      expresión (void) 0, todo lo que queda en la cadena de
      compilación es una sentencia esencialmente vacía como un
      resultado de la semicolumna que añade a cada invocación de
      assert( ). Si NDEBUG no está definido, assert(cond) se expande a
      una sentencia condicional que, cuando cond es cero, llama a una
      función dependiente del compilador (que llamamos assertImpl( ))
      con argumento string representando el texto de cond, junto con
      el nombre de fichero y el número de línea donde aparece la
      aserción. (Usamos como un marcador de posición en el ejemplo,
      pero la cadena mencionada es de hecho computada allí, junto con
      el nombre del fichero y el número de línea donde la macro
      aparece en ese fichero. Como estos valores se obtienen es
      irrelevante para nuestra discusión.) Si quiere activar y
      desactivar aserciones en diferentes puntos de su programa, no
      debe solo #define o #undef NDEBUG, sino que debe también reincluir
      &lt;cassert&gt;. Las macros son evaluadas cuando el preprocesador los
      encuentra y así usa cualquier estado NDEBUG se aplica en el punto
      de inclusión. El camino más común define NDEBUG una vez para
      todo el programa es como una opción del compilador, o mediante
      la configuración del proyecto en su entorno visual o mediante la
      línea de comandos, como en:
    </p><pre class="screen">
mycc NDEBUG myfile.cpp
</pre><p>
      La mayoría de los compiladores usan la bandera para definir los
      nombres de las macros. (Substituya el nombre del ejecutable de su
      compiladores por mycc arriba.) La ventaja de este enfoque es que
      puede dejar sus aserciones en el código fuente como un
      inapreciable parte de documentación, y no hay aún castigo en
      tiempo de ejecución. Porque el código en una aserción desaparece
      cuando NDEBUG está definido, es importante que no haga trabajo
      en una aserción. Sólo las condiciones de prueba que no cambien
      el estado de su programa.
    </p><p>
      Si usar NDEBUG para liberar código es una buena idea queda un
      tema de debate. Tony Hoare, una de los más influyentes expertos
      en informática de todos los tiempos,[15] ha sugerido que
      desactivando las comprobaciones en tiempo de ejecución como las
      aserciones es similar a un entusiasta de navegación que lleva un
      chaleco salvavidas mientras entrena en tierra y luego se deshace
      de él cuando va al mar.[16] Si una aserción falla en producción,
      tiene un problema mucho peor que la degradación en rendimiento,
      así que elija sabiamente.
    </p><p>
      No todas las condiciones deberían ser cumplidas por
      aserciones. Los errores de usuario y los fallos de los
      recursos en tiempos de ejecución deberían ser señalados lanzando
      excepciones, como explicamos en detalle en el Capítulo 1. Es
      tentador usar aserciones para la mayoría de las condiciones de
      error mientras esbozamos código, con el propósito de remplazar
      muchos de ellos después con un manejador de excepciones
      robusto. Como cualquier otra tentación, úsese con moderación, pues
      podría olvidar hacer todos los cambios necesarios más
      tarde. Recuerde: las aserciones tienen la intención de verificar
      decisiones de diseño que fallarán sólo por lógica
      defectuosa del programador. Lo ideal es solucionar todas las
      violaciones de aserciones durante el desarrollo. No use
      aserciones para condiciones que no están totalmente en su
      control (por ejemplo, condiciones que dependen de la entrada del
      usuario). En particular, no querría usar aserciones para validar
      argumentos de función; lance un logic_error en su lugar.
    </p><p>
      El uso de aserciones como una herramienta para asegurar la
      corrección de un programa fue formalizada por Bertran Meyer en
      su Diseño mediante metodología de contrato.[17] Cada función
      tiene un contrato implícito con los clientes que, dadas ciertas
      precondiciones, garantiza ciertas postcondiciones. En otras
      palabras, las precondiciones son los requerimientos para usar la
      función, como los argumentos que se facilitan dentro de ciertos
      rangos, y las postcondiciones son los resultados enviados por la
      función o por retorno por valor o por efecto colateral.
    </p><p>
      Cuando los programas clientes fallan al darle un entrada válida,
      debe comentarles que han roto el contrato. Este no es el mejor
      momento para suspender el programa (aunque está justificado
      hacerlo desde que el contrato fue violado), pero una excepción
      es desde luego apropiada. Esto es porque la librería Estándar de
      C++ lanza excepciones derivadas de logic_error, como
      out_of_range.[18] Si hay funciones que sólo usted llama, no
      obstante, como funciones privadas en una clase de su propio
      diseño, la macro assert( ) es apropiada, puesto que tiene total
      control sobre la situación y desde luego quiere depurar su
      código antes de enviarlo.
    </p><p>
      Una postcondición fallada indica un error de programa, y es
      apropiado usar aserciones para cualquier invariante en cualquier
      momento, incluyendo la postcondición de prueba al final de una
      función. Esto se aplica en particular a las funciones de una
      clase que mantienen el estado de un objeto. En el ejemplo
      MyVector previo, por ejemplo, un invariante razonable para todas
      las funciones sería:
    </p><p>
      assert(0 &lt;= siguienteEspacio &amp;&amp; siguienteEspacio &lt;= capacidad);
    </p><p>
      o, si siguienteEspacio es un integer sin signo, sencillamente
    </p><p>
      assert(siguienteEspacio &lt;= capacidad);
    </p><p>
      Tal tipo de invariante se llama invariante de clase y puede ser
      razonablemente forzada por una aserción. Las subclases juegan un
      papel de subcontratista para sus clases base porque deben
      mantener el contrato original entre la clase base y sus
      clientes. Por esta razón, las precondiciones en clases derivadas
      no deben imponer requerimientos adicionales más allá de aquellos
      del contrato base, y las postcondiciones deben cumplir al menos como
      mucho.[19]
    </p><p>
      Validar resultados devueltos por el cliente, sin embargo, no es
      más o menos que probar, de manera que usar aserciones de postcondición
      en este caso sería duplicar trabajo. Sí, es buena documentación,
      pero más de un desarrollador has sido engañado usando
      incorrectamente las aserciones de post-condición como un
      substituto para pruebas de unidad.
    </p></div><div class="sect1" title="3.2. Un framework de pruebas unitarias sencillo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3605256"></a>3.2. Un framework de pruebas unitarias sencillo </h2></div></div></div><p>
      Escribir software es todo sobre encontrar requerimientos.[20]
      Crear estos requerimientos es difícil, y pueden cambiar de un
      día a otro; podría descubrir en una reunión de proyecto semanal
      que lo que ha empleado la semana haciendo no es exactamente lo
      que los usuarios realmente quieren.
    </p><p>
      Las personas no pueden articular requerimientos de software sin
      muestrear un sistema de trabajo en evolución. Es mucho mejor
      especificar un poco, diseñar un poco, codificar un poco y probar
      un poco. Entonces, después de evaluar el resultado, hacerlo todo
      de nuevo. La habilidad para desarrollar con una moda iterativa
      es uno de los mejores avances del enfoque orientado a objetos,
      pero requiere programadores ágiles que pueden hacer código
      fuerte. El cambio es duro.
    </p><p>
      Otro ímpetu para el cambio viene de usted, el programador. El
      artífice que hay en usted quiere continuamente mejorar el diseño
      de su código. ¿Qué programador de mantenimiento no ha maldecido
      el envejecimiento, el producto de la compañía insignia como un
      mosaico de espaguetis inmodificable, enrevesado? La reluctancia
      de los supervisores en permitir que uno interfiera con un
      sistema que funciona le roba al código la
      flexibilidad que necesita para que perdure. Si no
      está roto, no arreglarlo finalmente le da el camino para, no
      podemos arreglarlo reescribámoslo. El cambio es necesario.
    </p><p>
      Afortunadamente, nuestra industria está creciendo acostumbrada
      a la disciplina de refactoring, el arte de reestructura
      internamente código para mejorar su diseño, sin cambiar su
      comportamiento.[21] Tales mejoras incluyen extraer una nueva
      función de otra, o de forma inversa, combinar funciones,
      reemplazar una función con un objeto; parametrizar una función o
      clase; y reemplazar condicionales con polimorfismo. Refactorizar
      ayuda al código evolucionar.
    </p><p>
      Si la fuerza para el cambio viene de los usuarios o
      programadores, los cambios hoy pueden destrozar lo trabajado
      ayer. Necesitamos un modo para construir código que resista el
      cambio y mejoras a lo largo del tiempo.
    </p><p>
      La Programación Extrema (XP)[22] es sólo uno de las muchas
      prácticas que motivan la agilidad. En esta
      sección exploramos lo que pensamos es la clave para hacer un
      desarrollo flexible, incremental que tenga éxito: un framework
      de pruebas unitarias automatizada fácil de usar. (Note que los
      probadores, profesionales de software que prueban el código de
      otros para ganarse la vida, son todavía indispensables. Aquí,
      estamos simplemente describiendo un modo para ayudar a los
      desarrolladores a escribir mejor código.)
    </p><p>
      Los desarrolladores escriben pruebas unitarias para conseguir
      confianza para decir las dos cosas más importantes que
      cualquier desarrollador puede decir:
    </p><p>
      1. Entiendo los requerimientos.
    </p><p>
      Mi código cumple esos requerimientos (hasta donde yo sé)
    </p><p>
      No hay mejor modo para asegurar que sabe lo que el código que está por
      escribir debería hacer mejor que escribir primero pruebas
      unitarias. Este ejercicio sencillo ayuda a centrar la mente en las
      tareas siguientes y probablemente guiará a código que
      funcionalmente más rápido mejor que sólo saltar a codificar. O,
      expresarlo en términos XP:
    </p><p>
      Probar + programar es más rápido que sólo programar.
    </p><p>
      Escribir primero pruebas sólo le protegen contra condiciones
      límite que podrían destrozar su código, por lo tanto su código
      es más robusto.
    </p><p>
      Cuando su código pasa todas sus pruebas, sabe que si el sistema no
      está funcionando, su código no es probablemente el problema. La
      frase todas mis pruebas funcionan es un fuerte razonamiento.
    </p><div class="sect2" title="3.2.1. Pruebas automatizadas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3615072"></a>3.2.1.  Pruebas automatizadas </h3></div></div></div><p>
	Por lo tanto, ¿qué aspecto tiene una prueba unitaria? Demasiado
	a menudo los desarrolladores simplemente usan alguna entrada
	correcta para producir alguna salida esperada, que examinan
	visualmente. Existen dos peligros en este enfoque. Primero,
	los programas no siempre reciben sólo entradas
	correctas. Todos sabemos que deberíamos probar los límites de
	entrada de un programa, pero es duro pensar esto cuando está
	intentando simplemente hacer que las cosas funcionar. Si escribe
	primero la prueba para una función antes de comenzar a
	codificar, puede ponerse su traje de probador y preguntarse a
	si mismo, ¿qué haría posiblemente destrozar esto? Codificar
	una prueba que probará la función que escribirá no es erróneo,
	y luego ponerte el traje de desarrollador y hacerlo
	pasar. Escribirá mejor código que si no había escrito la
	prueba primero.
      </p><p>
	El segundo peligro es que esperar una salida visualmente es
	tedioso y propenso a error. La mayoría de cualquier tipo de cosas que un
	humano puede hacer un ordenador puede hacerlas, pero sin el
	error humano. Es mejor formular pruebas como colecciones
	de expresiones boolean y tener un programa de prueba que
	informa de cualquier fallo.
      </p><p>
	Por ejemplo, suponga que necesita construir una clase Fecha
	que tiene las siguientes propiedades:
      </p><p>
	Una fecha puede estar inicializada con una cadena (AAAAMMDD),
	3 enteros (A, M, D), o nada (dando la fecha de hoy).
      </p><p>
	Un objecto fecha puede producir su año, mes y día o una cadena
	de la forma AAAAMMDD.
      </p><p>
	Todas las comparaciones relacionales están disponibles, además
	de calcular la duración entre dos fechas (en años, meses, y
	días).
      </p><p>
	Las fechas para ser comparadas necesitan poder extenderse un
	número arbitrario de siglos(por ejemplo, 16002200).
      </p><p>
	Su clase puede almacenar tres enteros que representan el año, mes
	y día. (Sólo asegúrese que el año es al menos de 16 bits de
	tamaño para satisfacer el último punto.) La interfaz de su
	clase Fecha se podría parecer a esto:
      </p><div class="example"><a id="idp3620936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Date1.h</span>
<span class="hl slc">// A first pass at Date.h.</span>
<span class="hl ppc">#ifndef DATE1_H</span>
<span class="hl ppc">#define DATE1_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>

<span class="hl kwc">class</span> Date <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// A struct to hold elapsed time:</span>
  <span class="hl kwb">struct</span> Duration <span class="hl opt">{</span>
    <span class="hl kwb">int</span> years<span class="hl opt">;</span>
    <span class="hl kwb">int</span> months<span class="hl opt">;</span>
    <span class="hl kwb">int</span> days<span class="hl opt">;</span>
    <span class="hl kwd">Duration</span><span class="hl opt">(</span><span class="hl kwb">int</span> y<span class="hl opt">,</span> <span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> d<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">years</span><span class="hl opt">(</span>y<span class="hl opt">),</span> <span class="hl kwd">months</span><span class="hl opt">(</span>m<span class="hl opt">),</span> <span class="hl kwd">days</span><span class="hl opt">(</span>d<span class="hl opt">) {}</span>
  <span class="hl opt">};</span>
  <span class="hl kwd">Date</span><span class="hl opt">();</span>
  <span class="hl kwd">Date</span><span class="hl opt">(</span><span class="hl kwb">int</span> year<span class="hl opt">,</span> <span class="hl kwb">int</span> month<span class="hl opt">,</span> <span class="hl kwb">int</span> day<span class="hl opt">);</span>
  <span class="hl kwd">Date</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getYear</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getMonth</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getDay</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  std<span class="hl opt">::</span>string <span class="hl kwd">toString</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
   <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
   <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
   <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;=(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
   <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;=(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
   <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
   <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> Duration <span class="hl kwd">duration</span><span class="hl opt">(</span><span class="hl kwb">const</span> Date<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DATE1_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.2. C02/Date1.h</strong></p></div><br class="example-break" /><p>
	Antes de que implemente esta clase, puede solidificar sus
	conocimientos de los requerimientos escribiendo el principio
	de un programa de prueba. Podría idear algo como lo siguiente:
      </p><div class="example"><a id="idp3623288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:SimpleDateTest.cpp</span>
<span class="hl slc">//{L} Date</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Date.h&quot;</span><span class="hl ppc"></span> <span class="hl slc">// From Appendix B</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Test machinery</span>
<span class="hl kwb">int</span> nPass <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> nFail <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl kwb">void</span> <span class="hl kwd">test</span><span class="hl opt">(</span><span class="hl kwb">bool</span> t<span class="hl opt">) {</span> <span class="hl kwa">if</span><span class="hl opt">(</span>t<span class="hl opt">)</span> nPass<span class="hl opt">++;</span> <span class="hl kwa">else</span> nFail<span class="hl opt">++; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Date <span class="hl kwd">mybday</span><span class="hl opt">(</span><span class="hl num">1951</span><span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getYear</span><span class="hl opt">() ==</span> <span class="hl num">1951</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getMonth</span><span class="hl opt">() ==</span> <span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getDay</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Passed: &quot;</span> <span class="hl opt">&lt;&lt;</span> nPass <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, Failed: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> nFail <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl com">/* Expected output:</span>
<span class="hl com">Passed: 3, Failed: 0</span>
<span class="hl com">*/</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.3. C02/SimpleDateTest.cpp</strong></p></div><br class="example-break" /><p>
	En este caso trivial, la función test( ) mantiene las
	variables globales nAprobar y nSuspender. La única revisión
	visual que hace es leer el resultado final. Si una prueba falla,
	un test( ) más sofisticado muestra un mensaje apropiado. El
	framework descrito más tarde en este capítulo tiene un función
	de prueba, entre otras cosas.
      </p><p>
	Puede ahora implementar la clase Fecha para hacer pasar estas
	pruebas, y luego puede proceder iterativamente hasta que se
	satisfagan todos los requerimientos. Escribiendo primero
	pruebas, es más probable que piense en casos límite que podrían
	destrozar su próxima implementación, y es más probable que
	escriba el código correctamente la primera vez. Como ejercicio
	podría realizar la siguiente versión de una prueba
	para la clase Fecha:
      </p><div class="example"><a id="idp3626944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:SimpleDateTest2.cpp</span>
<span class="hl slc">//{L} Date</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Date.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Test machinery</span>
<span class="hl kwb">int</span> nPass <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> nFail <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl kwb">void</span> <span class="hl kwd">test</span><span class="hl opt">(</span><span class="hl kwb">bool</span> t<span class="hl opt">) {</span> <span class="hl kwa">if</span><span class="hl opt">(</span>t<span class="hl opt">) ++</span>nPass<span class="hl opt">;</span> <span class="hl kwa">else</span> <span class="hl opt">++</span>nFail<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Date <span class="hl kwd">mybday</span><span class="hl opt">(</span><span class="hl num">1951</span><span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
  Date today<span class="hl opt">;</span>
   Date <span class="hl kwd">myevebday</span><span class="hl opt">(</span><span class="hl str">&quot;19510930&quot;</span><span class="hl opt">);</span>

  <span class="hl slc">// Test the operators</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">&lt;</span> today<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">&lt;=</span> today<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">!=</span> today<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">==</span> mybday<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">&gt;=</span> mybday<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">&lt;=</span> mybday<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>myevebday <span class="hl opt">&lt;</span> mybday<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">&gt;</span> myevebday<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">&gt;=</span> myevebday<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday <span class="hl opt">!=</span> myevebday<span class="hl opt">);</span>

  <span class="hl slc">// Test the functions</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getYear</span><span class="hl opt">() ==</span> <span class="hl num">1951</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getMonth</span><span class="hl opt">() ==</span> <span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getDay</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">getYear</span><span class="hl opt">() ==</span> <span class="hl num">1951</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">getMonth</span><span class="hl opt">() ==</span> <span class="hl num">9</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">getDay</span><span class="hl opt">() ==</span> <span class="hl num">30</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">() ==</span> <span class="hl str">&quot;19511001&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">() ==</span> <span class="hl str">&quot;19510930&quot;</span><span class="hl opt">);</span>

  <span class="hl slc">// Test duration</span>
  Date <span class="hl kwd">d2</span><span class="hl opt">(</span><span class="hl num">2003</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
  Date<span class="hl opt">::</span>Duration dur <span class="hl opt">=</span> <span class="hl kwd">duration</span><span class="hl opt">(</span>mybday<span class="hl opt">,</span> d2<span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>dur<span class="hl opt">.</span>years <span class="hl opt">==</span> <span class="hl num">51</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>dur<span class="hl opt">.</span>months <span class="hl opt">==</span> <span class="hl num">9</span><span class="hl opt">);</span>
  <span class="hl kwd">test</span><span class="hl opt">(</span>dur<span class="hl opt">.</span>days <span class="hl opt">==</span> <span class="hl num">3</span><span class="hl opt">);</span>

  <span class="hl slc">// Report results:</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Passed: &quot;</span> <span class="hl opt">&lt;&lt;</span> nPass <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, Failed: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> nFail <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.4. C02/SimpleDateTest2.cpp</strong></p></div><br class="example-break" /><p>
	Esta prueba puede ser desarrollada por completo. Por ejemplo,
	no hemos probado que duraciones grandes son manejadas
	correctamente. Pararemos aquí, pero coja la idea. La
	implementación entera para la case Fecha está disponible en
	los ficheros Date.h y Date.cpp en el apéndice.[23]
      </p></div><div class="sect2" title="3.2.2. El Framework TestSuite"><div class="titlepage"><div><div><h3 class="title"><a id="idp3631264"></a>3.2.2. El Framework TestSuite </h3></div></div></div><p>
	Algunas herramientas de pruebas unitarias automatizadas de C++
	están disponibles en la World Wide Web para descargar, como
	CppUnit.[24] Nuestra intención aquí no es sólo presentar un
	mecanismo de prueba que sea fácil de usar, sino también fácil
	de entender internamente e incluso modificar si es
	necesario. Por lo tanto, en el espíritu de Hacer Lo Más Simple
	Que Podría Posiblemente Funcionar,[25] hemos desarrollado el
	Framework TestSuite, un espacio de nombres llamado TestSuite
	que contiene dos clases principales: Test y Suite.
      </p><p>
	La clase Test es una clase base abstracta de la cual deriva un
	objeto test. Tiene constancia del número de éxitos y
	fracasos y muestra el texto de cualquier condición de prueba
	que falla. Simplemente para sobreescribir la función run( ),
	que debería llamar en turnos a la macro test_() para cada
	condición de prueba boolean que defina.
      </p><p>
	Para definir una prueba para la clase Fecha usando el
	framework, puede heredar de Test como se muetra en el
	siguiente programa:
      </p><div class="example"><a id="idp3633768"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:DateTest.h</span>
<span class="hl ppc">#ifndef DATETEST_H</span>
<span class="hl ppc">#define DATETEST_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Date.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> DateTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
  Date mybday<span class="hl opt">;</span>
  Date today<span class="hl opt">;</span>
  Date myevebday<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DateTest</span><span class="hl opt">():</span> <span class="hl kwd">mybday</span><span class="hl opt">(</span><span class="hl num">1951</span><span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">myevebday</span><span class="hl opt">(</span><span class="hl str">&quot;19510930&quot;</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwd">testOps</span><span class="hl opt">();</span>
    <span class="hl kwd">testFunctions</span><span class="hl opt">();</span>
    <span class="hl kwd">testDuration</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testOps</span><span class="hl opt">() {</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">&lt;</span> today<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">&lt;=</span> today<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">!=</span> today<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">==</span> mybday<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">&gt;=</span> mybday<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">&lt;=</span> mybday<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>myevebday <span class="hl opt">&lt;</span> mybday<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">&gt;</span> myevebday<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">&gt;=</span> myevebday<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday <span class="hl opt">!=</span> myevebday<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testFunctions</span><span class="hl opt">() {</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getYear</span><span class="hl opt">() ==</span> <span class="hl num">1951</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getMonth</span><span class="hl opt">() ==</span> <span class="hl num">10</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">getDay</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">getYear</span><span class="hl opt">() ==</span> <span class="hl num">1951</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">getMonth</span><span class="hl opt">() ==</span> <span class="hl num">9</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">getDay</span><span class="hl opt">() ==</span> <span class="hl num">30</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>mybday<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">() ==</span> <span class="hl str">&quot;19511001&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>myevebday<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">() ==</span> <span class="hl str">&quot;19510930&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testDuration</span><span class="hl opt">() {</span>
    Date <span class="hl kwd">d2</span><span class="hl opt">(</span><span class="hl num">2003</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
    Date<span class="hl opt">::</span>Duration dur <span class="hl opt">=</span> <span class="hl kwd">duration</span><span class="hl opt">(</span>mybday<span class="hl opt">,</span> d2<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>dur<span class="hl opt">.</span>years <span class="hl opt">==</span> <span class="hl num">51</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>dur<span class="hl opt">.</span>months <span class="hl opt">==</span> <span class="hl num">9</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>dur<span class="hl opt">.</span>days <span class="hl opt">==</span> <span class="hl num">3</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DATETEST_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.5. C02/DateTest.h</strong></p></div><br class="example-break" /><p>
	Ejecutar la prueba es una sencilla cuestión de instaciación
	de un objeto DateTest y llamar a su función run( ):
      </p><div class="example"><a id="idp3637824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:DateTest.cpp</span>
<span class="hl slc">// Automated testing (with a framework).</span>
<span class="hl slc">//{L} Date ../TestSuite/Test</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DateTest.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  DateTest test<span class="hl opt">;</span>
  test<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> test<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl com">/* Output:</span>
<span class="hl com">Test &quot;DateTest&quot;:</span>
<span class="hl com">        Passed: 21,      Failed: 0</span>
<span class="hl com">*/</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.6. C02/DateTest.cpp</strong></p></div><br class="example-break" /><p>
	La función Test::report( ) muestra la salida previa y devuelve
	el número de fallos, de este modo es conveniente usarlo como
	valor de retorno desde el main( ).
      </p><p>
	La clase Test usa RTTI[26] para obtener el nombre de su
	clase(por ejemplo, DateTest) para el informe. Hay también una
	función setStream() si quiere enviar los resultados de la
	prueba a un fichero en lugar de la salida estándar (por
	defecto). Verá la implementación de la clase Test más tarde en
	este capítulo.
      </p><p>
	La macro test_( ) puede extraer el texto de la condición
	booleana que falla, junto con el nombre del fichero y número
	de línea.[27] Para ver lo que ocurre cuando un fallo aparece,
	puede insertar un error intencionado en el código, por ejemplo
	invirtiendo la condición en la primera llamda a test_( ) en
	DateTest::testOps( ) en el código de ejemplo previo. La salida
	indica exactamente que la prueba tenía un error y dónde ocurrió:
      </p><p>
	DateTest fallo: (mybday &gt; hoy) , DateTest.h (línea 31)
	Test "DateTest":
	Passados: 20  Fallados: 1
      </p><p>
	Además de test_( ), el framework incluye las funciones
	succed_( ) y fail_( ), para casos donde una prueba Boolean no
	funcionará. Estas funciones se aplican cuando la clase que está
	probando podría lanzar excepciones. Durante la prueba, crear
	un conjunto de entrada que causará que la excepción aparezca. Si
	no, es un error y puede llamar a fail_( ) explicitamente para
	mostrar un mensaje y actualizar el contador de fallos. Si
	lanza la excecpión como se esperaba, llame a succeed_( ) para
	actualizar el contador de éxitos.
      </p><p>
	Para ilustrar, suponga que modificamos la especificación de
	los dos constructor no por defecto de Date para lanzar una
	excepción DateError (un tipo anidado dentro de Date y derivado
	de std::logic_error) si los parámetros de entrada no representa
	un fecha válida: Date(const string&amp; s) throw(DateError);
	Date(int year, int month, int day) throw(DateError);
      </p><p>
	La función DateTest::run( ) puede ahora llamar a la siguiente
	función para probar el manejo de excepciones:
      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">testExceptions</span><span class="hl opt">() {</span>
<span class="hl kwa">try</span> <span class="hl opt">{</span>
Date <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span><span class="hl num">0</span><span class="hl opt">,</span><span class="hl num">0</span><span class="hl opt">);</span>  <span class="hl slc">// Invalid</span>
<span class="hl kwd">fail_</span><span class="hl opt">(</span><span class="hl str">&quot;Invalid date undetected in Date int ctor&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Date<span class="hl opt">::</span>DateError<span class="hl opt">&amp;) {</span>
<span class="hl kwd">succeed_</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl kwa">try</span> <span class="hl opt">{</span>
Date <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>  <span class="hl slc">// Invalid</span>
<span class="hl kwd">fail_</span><span class="hl opt">(</span><span class="hl str">&quot;Invalid date undetected in Date string ctor&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Date<span class="hl opt">::</span>DateError<span class="hl opt">&amp;) {</span>
<span class="hl kwd">succeed_</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl opt">}</span>
</pre><p>
	En ambos casos, si una excepción no se lanza, es un
	error. Fíjese que debe pasar manualmente un mensaje a
	fail_( ), pues no se está evaluando una expresión booleana.
      </p></div><div class="sect2" title="3.2.3. Suites de test"><div class="titlepage"><div><div><h3 class="title"><a id="idp3645880"></a>3.2.3. Suites de test </h3></div></div></div><p>
	Los proyectos reales contienen normalmente muchas clases, por lo
	tanto necesita un modo para agrupar pruebas para que pueda
	simplemente pulsar un solo botón para probar el proyecto
	entero.[28] La clase Suite recoge pruebas en una unidad
	funcional. Añada objetos Test a Suite con la función addTest(
	), o puede incluir una suite existente entera con addSuite(
	). Para ilustrar, el siguiente ejemplo reúna los programas del
	Capítulo 3 que usa la clase Test en una sola suite. Fíjese
	que este fichero aparecerá en el subdirectorio del Capítulo 3:
      </p><div class="example"><a id="idp3647320"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StringSuite.cpp</span>
<span class="hl slc">//{L} ../TestSuite/Test ../TestSuite/Suite</span>
<span class="hl slc">//{L} TrimTest</span>
<span class="hl slc">// Illustrates a test suite for code from Chapter 3</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Suite.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;StringStorage.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Sieve.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Find.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Rparse.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TrimTest.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CompStr.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> TestSuite<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
    Suite <span class="hl kwd">suite</span><span class="hl opt">(</span><span class="hl str">&quot;String Tests&quot;</span><span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">addTest</span><span class="hl opt">(</span><span class="hl kwa">new</span> StringStorageTest<span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">addTest</span><span class="hl opt">(</span><span class="hl kwa">new</span> SieveTest<span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">addTest</span><span class="hl opt">(</span><span class="hl kwa">new</span> FindTest<span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">addTest</span><span class="hl opt">(</span><span class="hl kwa">new</span> RparseTest<span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">addTest</span><span class="hl opt">(</span><span class="hl kwa">new</span> TrimTest<span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">addTest</span><span class="hl opt">(</span><span class="hl kwa">new</span> CompStrTest<span class="hl opt">);</span>
    suite<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
    <span class="hl kwb">long</span> nFail <span class="hl opt">=</span> suite<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
    suite<span class="hl opt">.</span><span class="hl kwd">free</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> nFail<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl com">/* Output:</span>
<span class="hl com">s1 = 62345</span>
<span class="hl com">s2 = 12345</span>
<span class="hl com">Suite &quot;String Tests&quot;</span>
<span class="hl com">====================</span>
<span class="hl com">Test &quot;StringStorageTest&quot;:</span>
<span class="hl com">   Passed: 2   Failed: 0</span>
<span class="hl com">Test &quot;SieveTest&quot;:</span>
<span class="hl com">   Passed: 50  Failed: 0</span>
<span class="hl com">Test &quot;FindTest&quot;:</span>
<span class="hl com">   Passed: 9   Failed: 0</span>
<span class="hl com">Test &quot;RparseTest&quot;:</span>
<span class="hl com">   Passed: 8   Failed: 0</span>
<span class="hl com">Test &quot;TrimTest&quot;:</span>
<span class="hl com">   Passed: 11  Failed: 0</span>
<span class="hl com">Test &quot;CompStrTest&quot;:</span>
<span class="hl com">   Passed: 8   Failed: 0</span>
<span class="hl com">*/</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.7. C03/StringSuite.cpp</strong></p></div><br class="example-break" /><p>
	5 de los tests de más arriba están completamente contenidos en
	los ficheros de cabecera. TrimTest no lo está, porque contiene
	datos estáticos que deben estar definidos en un fichero de
	implementación. Las dos primeras líneas de salida son trazos
	de la prueba StringStorage. Debe dar a la suite un nombre como
	argumento del constructor. La función Suite::run( ) llama a
	Test::run( ) po cada una de las pruebas que tiene. Más de
	lo mismo pasa con Suite::report( ), excepto que puede enviar
	los informes de pruebas individuales a cadenas destinaciones
	diferentes  mejor que el informe de la suite. Si la prueba pasa
	a addSuite( ) ya tiene un puntero de cadena asignado, que
	lo guarda. En otro caso, obtiene su cadena del objeto
	Suite. (Como con Test, hay un segundo argumento opcional  para
	el constructor suite que no se presenta a std::cout.) El
	destructor para Suite no borra automáticamente los punteros
	contenidos en Test porque no necesitan residir en la pila;
	este es el trabajo de Suite::free( ).
      </p></div><div class="sect2" title="3.2.4. El código del framework de prueba"><div class="titlepage"><div><div><h3 class="title"><a id="idp3652760"></a>3.2.4. El código del framework de prueba </h3></div></div></div><p>
	El código del framework de pruebas es un subdirectorio llamado
	TestSuite en la distribución de código disponible en
	www.MindView.net. Para usarlo, incluya la ruta de búsqueda
	para el subdirectorio TestSuite en la ruta de búsqueda de la
	biblioteca. Aquí está la cabecera para Test.h:
      </p><div class="example"><a id="idp3653968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: TestSuite:Test.h</span>
<span class="hl ppc">#ifndef TEST_H</span>
<span class="hl ppc">#define TEST_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>ostream<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>cout<span class="hl opt">;</span>

<span class="hl slc">// fail_() has an underscore to prevent collision with</span>
<span class="hl slc">// ios::fail(). For consistency, test_() and succeed_()</span>
<span class="hl slc">// also have underscores.</span>

<span class="hl ppc">#define test_(cond) \</span>
<span class="hl ppc">  do_test(cond, #cond, __FILE__, __LINE__)</span>
<span class="hl ppc">#define fail_(str) \</span>
<span class="hl ppc">  do_fail(str, __FILE__, __LINE__)</span>

<span class="hl kwa">namespace</span> TestSuite <span class="hl opt">{</span>

<span class="hl kwc">class</span> Test <span class="hl opt">{</span>
  ostream<span class="hl opt">*</span> osptr<span class="hl opt">;</span>
  <span class="hl kwb">long</span> nPass<span class="hl opt">;</span>
  <span class="hl kwb">long</span> nFail<span class="hl opt">;</span>
  <span class="hl slc">// Disallowed:</span>
  <span class="hl kwd">Test</span><span class="hl opt">(</span><span class="hl kwb">const</span> Test<span class="hl opt">&amp;);</span>
  Test<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Test<span class="hl opt">&amp;);</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">do_test</span><span class="hl opt">(</span><span class="hl kwb">bool</span> cond<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> lbl<span class="hl opt">,</span>
    <span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">long</span> lineno<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">do_fail</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> lbl<span class="hl opt">,</span>
    <span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">long</span> lineno<span class="hl opt">);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Test</span><span class="hl opt">(</span>ostream<span class="hl opt">*</span> osptr <span class="hl opt">= &amp;</span>cout<span class="hl opt">) {</span>
    <span class="hl kwa">this</span><span class="hl opt">-&gt;</span>osptr <span class="hl opt">=</span> osptr<span class="hl opt">;</span>
    nPass <span class="hl opt">=</span> nFail <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Test</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">long</span> <span class="hl kwd">getNumPassed</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> nPass<span class="hl opt">; }</span>
  <span class="hl kwb">long</span> <span class="hl kwd">getNumFailed</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> nFail<span class="hl opt">; }</span>
  <span class="hl kwb">const</span> ostream<span class="hl opt">*</span> <span class="hl kwd">getStream</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> osptr<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setStream</span><span class="hl opt">(</span>ostream<span class="hl opt">*</span> osptr<span class="hl opt">) {</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span>osptr <span class="hl opt">=</span> osptr<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">succeed_</span><span class="hl opt">() { ++</span>nPass<span class="hl opt">; }</span>
  <span class="hl kwb">long</span> <span class="hl kwd">report</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">reset</span><span class="hl opt">() {</span> nPass <span class="hl opt">=</span> nFail <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl opt">}</span> <span class="hl slc">// namespace TestSuite</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TEST_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.8. </strong></p></div><br class="example-break" /><p>
	Hay tres funciones virtuales en la clase Test:
      </p><p>
	Un destructor virtual
      </p><p>
	La función reset( )
      </p><p>
	La función virtual pura run( )
      </p><p>
	Como se explicó en el Volumen 1, es un error eliminar un
	objeto derivado de la pila a través de un puntero base a
	menos que la clase base tenga un destructor virtual. Cualquier
	clase propuesta para ser una clase base (normalmente
	evidenciadas por la presencia de al menos una de las otras
	funciones virtuales) tendría un destructor virtual. La
	implementación por defecto de Test::reset( ) pone los
	contadores de éxitos y fallos a cero. Podría querer
	sobreescribir esta función para poner el estado de los datos
	en su objeto de test derivado; sólo asegúrese de llamar a
	Test::rest( ) explícitamente en su sobreescritura de modo que
	los contadores se reajusten. La función Test::run( ) es
	virtual pura ya que es necesario para sobreescribirla en su
	clase derivada.
      </p><p>
	Las macros test_( ) y fail_( ) pueden incluir la información
	disponible del nombre del fichero y el número de línea del
	preprocesador. Originalmente omitimos el guión bajo en los
	nombres, pero la macro fail colisiona con ios::fail( ),
	provocando errores de compilación.
      </p><p>
	Aquí está la implementación del resto de las funciones Test:
      </p><div class="example"><a id="idp3661352"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: TestSuite:Test.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;typeinfo&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> TestSuite<span class="hl opt">;</span>

<span class="hl kwb">void</span> Test<span class="hl opt">::</span><span class="hl kwd">do_test</span><span class="hl opt">(</span><span class="hl kwb">bool</span> cond<span class="hl opt">,</span> <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> lbl<span class="hl opt">,</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">long</span> lineno<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>cond<span class="hl opt">)</span>
    <span class="hl kwd">do_fail</span><span class="hl opt">(</span>lbl<span class="hl opt">,</span> fname<span class="hl opt">,</span> lineno<span class="hl opt">);</span>
  <span class="hl kwa">else</span>
    <span class="hl kwd">succeed_</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Test<span class="hl opt">::</span><span class="hl kwd">do_fail</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> lbl<span class="hl opt">,</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">long</span> lineno<span class="hl opt">) {</span>
  <span class="hl opt">++</span>nFail<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>osptr<span class="hl opt">) {</span>
    <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">()</span>
           <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;failure: (&quot;</span> <span class="hl opt">&lt;&lt;</span> lbl <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) , &quot;</span> <span class="hl opt">&lt;&lt;</span> fname
           <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; (line &quot;</span> <span class="hl opt">&lt;&lt;</span> lineno <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">long</span> Test<span class="hl opt">::</span><span class="hl kwd">report</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>osptr<span class="hl opt">) {</span>
    <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Test</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">()</span>
           <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;</span><span class="hl str">:</span><span class="hl esc">\n\t</span><span class="hl str">Passed: &quot;</span> <span class="hl opt">&lt;&lt;</span> nPass
           <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">Failed: &quot;</span> <span class="hl opt">&lt;&lt;</span> nFail
           <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> nFail<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.9. </strong></p></div><br class="example-break" /><p>
	La clase Test lleva la cuenta del número de éxitos y fracasos
	además de la cadena donde quiere que Test::report( ) muestre los
	resultados. Las macros test_( ) y fail_() extraen la
	información del nombre del fichero actual y el número de línea
	del preprocesador y pasa el nombre del fichero a do_test( ) y
	el número de línea a do_fail( ), que hacen el mismo trabajo de
	mostrar un mensaje y actualizar el contador apropiado. No
	podemos pensar una buena razón para permitir copiar y asignar
	objetos de prueba, por lo que hemos rechazado estas
	operaciones para hacer sus prototipos privados y omitir el
	cuerpo de sus respectivas funciones.
      </p><p>
	Aquí está el fichero de cabecera para Suite:
      </p><div class="example"><a id="idp3664264"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: TestSuite:Suite.h</span>
<span class="hl ppc">#ifndef SUITE_H</span>
<span class="hl ppc">#define SUITE_H</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>vector<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>logic_error<span class="hl opt">;</span>

<span class="hl kwa">namespace</span> TestSuite <span class="hl opt">{</span>

<span class="hl kwc">class</span> TestSuiteError <span class="hl opt">:</span> <span class="hl kwc">public</span> logic_error <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">TestSuiteError</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">logic_error</span><span class="hl opt">(</span>s<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Suite <span class="hl opt">{</span>
  string name<span class="hl opt">;</span>
  ostream<span class="hl opt">*</span> osptr<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span>Test<span class="hl opt">*&gt;</span> tests<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">reset</span><span class="hl opt">();</span>
  <span class="hl slc">// Disallowed ops:</span>
  <span class="hl kwd">Suite</span><span class="hl opt">(</span><span class="hl kwb">const</span> Suite<span class="hl opt">&amp;);</span>
  Suite<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Suite<span class="hl opt">&amp;);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Suite</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> name<span class="hl opt">,</span> ostream<span class="hl opt">*</span> osptr <span class="hl opt">= &amp;</span>cout<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">name</span><span class="hl opt">(</span>name<span class="hl opt">) {</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span>osptr <span class="hl opt">=</span> osptr<span class="hl opt">; }</span>
  string <span class="hl kwd">getName</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> name<span class="hl opt">; }</span>
  <span class="hl kwb">long</span> <span class="hl kwd">getNumPassed</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">long</span> <span class="hl kwd">getNumFailed</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">const</span> ostream<span class="hl opt">*</span> <span class="hl kwd">getStream</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> osptr<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setStream</span><span class="hl opt">(</span>ostream<span class="hl opt">*</span> osptr<span class="hl opt">) {</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span>osptr <span class="hl opt">=</span> osptr<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addTest</span><span class="hl opt">(</span>Test<span class="hl opt">*</span> t<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>TestSuiteError<span class="hl opt">);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addSuite</span><span class="hl opt">(</span><span class="hl kwb">const</span> Suite<span class="hl opt">&amp;);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">();</span>  <span class="hl slc">// Calls Test::run() repeatedly</span>
  <span class="hl kwb">long</span> <span class="hl kwd">report</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">free</span><span class="hl opt">();</span>  <span class="hl slc">// Deletes tests</span>
<span class="hl opt">};</span>

<span class="hl opt">}</span> <span class="hl slc">// namespace TestSuite</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// SUITE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.10. </strong></p></div><br class="example-break" /><p>
	La clase Suite tiene punteros a sus objetos Test en un
	vector. Fíjese en la especificación de la excepción en
	la función addTest( ). Cuando añada una prueba a una suite,
	Suite::addTest( ) verifique que el puntero que pasa no sea null;
	si es null, se lanza una excepción TestSuiteError. Puesto que
	esto hace imposible añadir un puntero null a una suite,
	addSuite( ) afirma esta condición en cada prueba, como hacen
	las otras funciones que atraviesan el vector de pruebas (vea
	la siguiente implementación). Copiar y asignar están
	desestimados como están en la clase Test.
      </p><div class="example"><a id="idp3667720"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: TestSuite:Suite.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Suite.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> TestSuite<span class="hl opt">;</span>

<span class="hl kwb">void</span> Suite<span class="hl opt">::</span><span class="hl kwd">addTest</span><span class="hl opt">(</span>Test<span class="hl opt">*</span> t<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>TestSuiteError<span class="hl opt">) {</span>
  <span class="hl slc">// Verify test is valid and has a stream:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>t <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">TestSuiteError</span><span class="hl opt">(</span><span class="hl str">&quot;Null test in Suite::addTest&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">else if</span><span class="hl opt">(</span>osptr <span class="hl opt">&amp;&amp; !</span>t<span class="hl opt">-&gt;</span><span class="hl kwd">getStream</span><span class="hl opt">())</span>
    t<span class="hl opt">-&gt;</span><span class="hl kwd">setStream</span><span class="hl opt">(</span>osptr<span class="hl opt">);</span>
  tests<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>t<span class="hl opt">);</span>
  t<span class="hl opt">-&gt;</span><span class="hl kwd">reset</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Suite<span class="hl opt">::</span><span class="hl kwd">addSuite</span><span class="hl opt">(</span><span class="hl kwb">const</span> Suite<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
   <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> s<span class="hl opt">.</span>tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
     <span class="hl kwa">assert</span><span class="hl opt">(</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
      <span class="hl kwd">addTest</span><span class="hl opt">(</span>s<span class="hl opt">.</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Suite<span class="hl opt">::</span><span class="hl kwd">free</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">delete</span> tests<span class="hl opt">[</span>i<span class="hl opt">];</span>
    tests<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Suite<span class="hl opt">::</span><span class="hl kwd">run</span><span class="hl opt">() {</span>
  <span class="hl kwd">reset</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
    tests<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">long</span> Suite<span class="hl opt">::</span><span class="hl kwd">report</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>osptr<span class="hl opt">) {</span>
    <span class="hl kwb">long</span> totFail <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Suite</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> name
             <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;\n</span><span class="hl str">=======&quot;</span><span class="hl opt">;</span>
    <span class="hl kwb">size_t</span> i<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> name<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
      <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">'='</span><span class="hl opt">;</span>
    <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;=&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
      totFail <span class="hl opt">+=</span> tests<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">report</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
    <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;=======&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span>i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> name<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
      <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">'='</span><span class="hl opt">;</span>
    <span class="hl opt">*</span>osptr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;=&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> totFail<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">else</span>
    <span class="hl kwa">return</span> <span class="hl kwd">getNumFailed</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">long</span> Suite<span class="hl opt">::</span><span class="hl kwd">getNumPassed</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwb">long</span> totPass <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
    totPass <span class="hl opt">+=</span> tests<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">getNumPassed</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> totPass<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">long</span> Suite<span class="hl opt">::</span><span class="hl kwd">getNumFailed</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  <span class="hl kwb">long</span> totFail <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
    totFail <span class="hl opt">+=</span> tests<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">getNumFailed</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> totFail<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> Suite<span class="hl opt">::</span><span class="hl kwd">reset</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> tests<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>tests<span class="hl opt">[</span>i<span class="hl opt">]);</span>
    tests<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">reset</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.11. </strong></p></div><br class="example-break" /><p>
	Usaremos el framework TestSuite donde sea pertinente a lo largo
	del resto de este libro.
      </p></div></div><div class="sect1" title="3.3. Técnicas de depuración"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3672264"></a>3.3. Técnicas de depuración </h2></div></div></div><p>
      La mejor costumbre para eliminar fallos es usar aserciones como
      se explica al principio de este capítulo; haciendo esto le
      ayudará a encontrar errores lógicos antes de que causen
      problemas reales. Esta sección contiene otros consejos y
      técnicas que podrían ayudar durante la depuración.
    </p><div class="sect2" title="3.3.1. Macros de seguimiento"><div class="titlepage"><div><div><h3 class="title"><a id="idp3673496"></a>3.3.1. Macros de seguimiento </h3></div></div></div><p>
	Algunas veces es útil imprimir el código de cada sentencia
	cuando es ejecutada, o cout o trazar un fichero. Aquí esta una
	macro de preprocesaor para llevar a cabo esto:
      </p><p>
	#define TRACE(ARG) cout &lt;&lt; #ARG &lt;&lt; endl; ARG
      </p><p>
	Ahora puede ir a través y alrededor de las sentencias que
	traceé con esta macro. Sin embargo, esto puede introducir
	problemas. Por ejemplo, si coge la sentencia:
      </p><p>
      for(int i = 0; i &lt; 100; i++)
      cout &lt;&lt; i &lt;&lt; endl;
      </p><p>
	y ponga ambas líneas dentro de la macro TRACE( ), obtiene esto:
      </p><p>
      TRACE(for(int i = 0; i  &lt; 100; i++))
      TRACE(  cout &lt;&lt; i &lt;&lt; endl;)
      </p><p>
	que se expande a esto:
      </p><p>
      cout &lt;&lt; "for(int i = 0; i &lt; 100; i++)" &lt;&lt; endl;
      for(int i = 0; i &lt; 100; i++)
      cout &lt;&lt; "cout &lt;&lt; i &lt;&lt; endl;" &lt;&lt; endl;
      cout &lt;&lt; i &lt;&lt; endl;
      </p><p>
	que no es exactamente lo que quiere. Por lo tanto, debe usar
	esta técnica cuidadosamente.
      </p><p>
	Lo siguiente es una variación en la macro TRACE( ):
      </p><p>
	#define D(a) cout &lt;&lt; #a "=[" &lt;&lt; a &lt;&lt; "]" &lt;&lt; endl;
      </p><p>
	Si quiere mostrar una expresión, simplemente póngala dentro de
	una llamada a D( ). La expresión se muestra, seguida de su
	valor ( asumiendo que hay un operador sobrecargado &lt;&lt; para el
	tipo de resultado). Por ejemplo, puede decir D(a + b). Puede
	usar esta macro en cualquier momento que quiera comprobar un
	valor intermedio.
      </p><p>
	Estas dos macros representan las dos cosas fundamentales que
	hace con un depurador: trazar la ejecución de código y
	mostrar valores. Un buen depurador es una herramienta de
	productividad excelente, pero a veces los depuradores no están
	disponibles, o no es conveniente usarlos. Estas técnicas
	siempre funcionan, sin tener en cuenta la situación.
      </p></div><div class="sect2" title="3.3.2. Fichero de rastro"><div class="titlepage"><div><div><h3 class="title"><a id="idp3679368"></a>3.3.2. Fichero de rastro </h3></div></div></div><p>
	ADVERTENCIA: Esta sección y la siguiente contienen código que
	está oficialmente sin aprobación por el Estándar C++. En
	particular, redefinimos cout y new mediante macros, que puede
	provocar resultados sorprendentes si no tiene
	cuidado. Nuestros ejemplos funcionan en todos los compiladores
	que usamos, comoquiera, y proporcionan información útil. Este
	es el único lugar en este libro donde nos desviaremos de la
	inviolabilidad de la práctica de codificar cumpliendo el
	estándar. ¡Úsalo bajo tu propio riesgo! Dese cuenta que para
	este trabajo, usar delcaraciones debe ser realizado, para que
	cout no esté prefijado por su nombre de espacio,
	p.e. std::cout no funcionará.
      </p><p>
	El siguiente código crea fácilmente un fichero de seguimiento
	y envía todas las salidas que irían normalmente a cout a ese
	fichero. Todo lo que debe hacer es #define TRACEON e incluir
	el fichero de cabecera (por supuesto, es bastante fácil sólo
	escribir las dos líneas claves correctamente en su fichero):
      </p><div class="example"><a id="idp3682184"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Trace.h</span>
<span class="hl slc">// Creating a trace file.</span>
<span class="hl ppc">#ifndef TRACE_H</span>
<span class="hl ppc">#define TRACE_H</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>

<span class="hl ppc">#ifdef TRACEON</span>
std<span class="hl opt">::</span>ofstream <span class="hl kwd">TRACEFILE__</span><span class="hl opt">(</span><span class="hl str">&quot;TRACE.OUT&quot;</span><span class="hl opt">);</span>
<span class="hl ppc">#define cout TRACEFILE__</span>
<span class="hl ppc">#endif</span>

<span class="hl ppc">#endif</span> <span class="hl slc">// TRACE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.12. C03/Trace.h</strong></p></div><br class="example-break" /><p>
	Aquí esta una prueba sencilla del fichero anterior:
      </p><div class="example"><a id="idp3683968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Tracetst.cpp {-bor}</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define TRACEON</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Trace.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl str">&quot;Tracetst.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>f<span class="hl opt">,</span> <span class="hl str">&quot;Tracetst.cpp&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> f<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span> <span class="hl slc">// Dumps file contents to file</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.13. C03/Tracetst.cpp</strong></p></div><br class="example-break" /><p>
	Porque cout ha sido textualmente convertido en algo más por
	Trace.h, todas las sentencias cout en su programa ahora envían
	información al fichero de seguimiento. Esto es una forma
	conveniente de capturar su salida en un fichero, en caso de
	que su sistema operativo no haga una fácil redirección de la salida.
      </p></div><div class="sect2" title="3.3.3. Encontrar agujeros en memoria"><div class="titlepage"><div><div><h3 class="title"><a id="idp3686240"></a>3.3.3. Encontrar agujeros en memoria </h3></div></div></div><p>
	Las siguientes técnicas sencillas de depuración están
	explicadas en el Volumen 1:
      </p><p>
	1. Para comprobar los límites de un array, usa la plantilla
	Array en C16:Array3.cpp del Volumen 1 para todos los
	arrays. Puede desactivar la comprobación e incrementar la
	eficiencia cuando esté listo para enviar. (Aunque esto no trata
	con el caso de coger un puntero a un array.)
      </p><p>
	2. Comprobar destructores no virtuales en clases
	base. Seguirle la pista a new/delete y malloc/free
      </p><p>
	Los problemas comunes con la asignación de memoria incluyen
	llamadas por error a delete para memoria que no está libre,
	borrar el espacio libre más de una vez, y más a menudo,
	olvidando borrar un puntero. Esta sección discute un sistema
	que puede ayudarle a localizar estos tipos de problemas.
      </p><p>
	Como cláusula adicional de exención de responsabilidad más
	allá de la sección precedente: por el modo que sobrecargamos
	new, la siguiente técnica puede no funcionar en todas las
	plataformas, y funcionará sólo para programas que no llaman
	explicitamente al operador de función new( ). Hemos sido
	bastante cuidadosos en este libro para presentar sólo código
	que se ajuste completamente al Estándar C++, pero en este
	ejemplo estamos haciendo una excepción por las siguientes
	razones:
      </p><p>
	1. A pesar de que es técnicamente ilegal, funciona en muchos
	compiladores.[29]
      </p><p>
	2. Ilustramos algunos pensamientos útiles en el trascurso del
	camino.
      </p><p>
	Para usar el sistema de comprobación de memoria, simplemente
	incluya el fichero de cabecera MemCheck.h, conecte el fichero
	MemCheck.obj a su aplicación para interceptar todas las
	llamadas a new y delete, y llame a la macro MEM_ON( )
	(se explica más tarde en esta sección) para iniciar el
	seguimiento de la memoria. Un seguimiento de todas las
	asignaciones y desasignaciones es impreso en la salida
	estándar (mediante stdout). Cuando use este sistema, todas las
	llamadas a new almacenan información sobre el fichero y la
	línea donde fueron llamados. Esto está dotado usando la
	sintaxis de colocación para el operador new.[30] Aunque
	normalmente use la sintaxis de colocación cuando necesite
	colocar objetos en un punto de memoria específico, puede
	también crear un operador new( ) con cualquier número de
	argumentos. Esto se usa en el siguiente ejemplo para almacenar
	los resultados de las macros __FILE__ y __LINE__ cuando se
	llama a new:
      </p><div class="example"><a id="idp3692576"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:MemCheck.h</span>
<span class="hl ppc">#ifndef MEMCHECK_H</span>
<span class="hl ppc">#define MEMCHECK_H</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>  <span class="hl slc">// For size_t</span>
<span class="hl ppc"></span>
<span class="hl slc">// Usurp the new operator (both scalar and array versions)</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*,</span> <span class="hl kwb">long</span><span class="hl opt">);</span>
<span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">[](</span>std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*,</span> <span class="hl kwb">long</span><span class="hl opt">);</span>
<span class="hl ppc">#define new new (__FILE__, __LINE__)</span>

<span class="hl kwc">extern</span> <span class="hl kwb">bool</span> traceFlag<span class="hl opt">;</span>
<span class="hl ppc">#define TRACE_ON() traceFlag = true</span>
<span class="hl ppc">#define TRACE_OFF() traceFlag = false</span>

<span class="hl kwc">extern</span> <span class="hl kwb">bool</span> activeFlag<span class="hl opt">;</span>
<span class="hl ppc">#define MEM_ON() activeFlag = true</span>
<span class="hl ppc">#define MEM_OFF() activeFlag = false</span>

<span class="hl ppc">#endif</span> <span class="hl slc">// MEMCHECK_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.14. C02/MemCheck.h</strong></p></div><br class="example-break" /><p>
	Es importante incluir este fichero en cualquier fichero fuente
	en el que quiera seguir la actividad de la memoria libre, pero
	inclúyalo al final (después de sus otras directivas
	#include). La mayoría de las cabeceras en la biblioteca
	estándar son plantillas, y puesto que la mayoría de los
	compiladores usan el modelo de inclusión de compilación de
	plantilla (significa que todo el código fuente está en las
	cabeceras), la macro que reemplaza new en MemCheck.h usurpará
	todas las instancias del operador new en el código fuente de
	la biblioteca (y casi resultaría en errores de
	compilación). Además, está sólo interesado en seguir sus
	propios errores de memoria, no los de la biblioteca.
      </p><p>
	En el siguiente fichero, que contiene la implementación del
	seguimiento de memoria, todo está hecho con C estándar I/O más
	que con iostreams C++. No debería influir, puesto
	que no estamos interfiriendo con el uso de iostream en la
	memoria libre, pero cuando lo intentamos, algunos compiladores
	se quejaron. Todos los compiladores estaban felices con la
	versión &lt;cstdio&gt;.
      </p><div class="example"><a id="idp3696608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:MemCheck.cpp {O}</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl ppc">#undef new</span>

<span class="hl slc">// Global flags set by macros in MemCheck.h</span>
<span class="hl kwb">bool</span> traceFlag <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
<span class="hl kwb">bool</span> activeFlag <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>

<span class="hl kwa">namespace</span> <span class="hl opt">{</span>

<span class="hl slc">// Memory map entry type</span>
<span class="hl kwb">struct</span> Info <span class="hl opt">{</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> ptr<span class="hl opt">;</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">;</span>
  <span class="hl kwb">long</span> line<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl slc">// Memory map data</span>
<span class="hl kwb">const size_t</span> MAXPTRS <span class="hl opt">=</span> <span class="hl num">10000u</span><span class="hl opt">;</span>
Info memMap<span class="hl opt">[</span>MAXPTRS<span class="hl opt">];</span>
<span class="hl kwb">size_t</span> nptrs <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl slc">// Searches the map for an address</span>
<span class="hl kwb">int</span> <span class="hl kwd">findPtr</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> nptrs<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>memMap<span class="hl opt">[</span>i<span class="hl opt">].</span>ptr <span class="hl opt">==</span> p<span class="hl opt">)</span>
      <span class="hl kwa">return</span> i<span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">delPtr</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
  <span class="hl kwb">int</span> pos <span class="hl opt">=</span> <span class="hl kwd">findPtr</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>pos <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Remove pointer from map</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> pos<span class="hl opt">;</span> i <span class="hl opt">&lt;</span> nptrs<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    memMap<span class="hl opt">[</span>i<span class="hl opt">] =</span> memMap<span class="hl opt">[</span>i<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">];</span>
  <span class="hl opt">--</span>nptrs<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// Dummy type for static destructor</span>
<span class="hl kwb">struct</span> Sentinel <span class="hl opt">{</span>
  <span class="hl opt">~</span><span class="hl kwd">Sentinel</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>nptrs <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">) {</span>
      <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Leaked memory at:</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> nptrs<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
        <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">%p (file: %s, line %ld)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
          memMap<span class="hl opt">[</span>i<span class="hl opt">].</span>ptr<span class="hl opt">,</span> memMap<span class="hl opt">[</span>i<span class="hl opt">].</span>file<span class="hl opt">,</span> memMap<span class="hl opt">[</span>i<span class="hl opt">].</span>line<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">else</span>
      <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;No user memory leaks!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Static dummy object</span>
Sentinel s<span class="hl opt">;</span>

<span class="hl opt">}</span> <span class="hl slc">// End anonymous namespace</span>

<span class="hl slc">// Overload scalar new</span>
<span class="hl kwb">void</span><span class="hl opt">*</span>
<span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> siz<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">long</span> line<span class="hl opt">) {</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwd">malloc</span><span class="hl opt">(</span>siz<span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>activeFlag<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>nptrs <span class="hl opt">==</span> MAXPTRS<span class="hl opt">) {</span>
      <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;memory map too small (increase MAXPTRS)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
      <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>
    memMap<span class="hl opt">[</span>nptrs<span class="hl opt">].</span>ptr <span class="hl opt">=</span> p<span class="hl opt">;</span>
    memMap<span class="hl opt">[</span>nptrs<span class="hl opt">].</span>file <span class="hl opt">=</span> file<span class="hl opt">;</span>
    memMap<span class="hl opt">[</span>nptrs<span class="hl opt">].</span>line <span class="hl opt">=</span> line<span class="hl opt">;</span>
    <span class="hl opt">++</span>nptrs<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>traceFlag<span class="hl opt">) {</span>
    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Allocated %u bytes at address %p &quot;</span><span class="hl opt">,</span> siz<span class="hl opt">,</span> p<span class="hl opt">);</span>
    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;(file: %s, line: %ld)</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> file<span class="hl opt">,</span> line<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> p<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// Overload array new</span>
<span class="hl kwb">void</span><span class="hl opt">*</span>
<span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> siz<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">long</span> line<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwc">operator</span> <span class="hl kwa">new</span><span class="hl opt">(</span>siz<span class="hl opt">,</span> file<span class="hl opt">,</span> line<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// Override scalar delete</span>
<span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">findPtr</span><span class="hl opt">(</span>p<span class="hl opt">) &gt;=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    <span class="hl kwd">free</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>nptrs <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl kwd">delPtr</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>traceFlag<span class="hl opt">)</span>
      <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Deleted memory at address %p</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> p<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">else if</span><span class="hl opt">(!</span>p <span class="hl opt">&amp;&amp;</span> activeFlag<span class="hl opt">)</span>
    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Attempt to delete unknown pointer: %p</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> p<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// Override array delete</span>
<span class="hl kwb">void</span> <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">[](</span><span class="hl kwb">void</span><span class="hl opt">*</span> p<span class="hl opt">) {</span>
  <span class="hl kwc">operator</span> <span class="hl kwa">delete</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.15. C02/MemCheck.cpp</strong></p></div><br class="example-break" /><p>
	Las banderas booleanas de traceFalg y activeFlag son globales,
	por lo que pueden ser modificados en su código por las macros
	TRACE_ON( ), TRACE_OFF( ), MEM_ON( ), y MEM_OFF( ). En
	general, encierre todo el código en su main( ) dentro una
	pareja MEM_ON( )-MEM_OFF( ) de modo que la memoria sea siempre
	trazada. Trazar, que repite la actividad de las funciones de
	sustitución por el operador new( ) y el operador delete( ), es
	por defecto, pero puede desactivarlo con TRACE_OFF( ). En
	cualquier caso, los resultados finales son siempre impresos
	(vea la prueba que se ejecuta más tarde en este capítulo).
      </p><p>
	La facilidad MemCheck rastrea la memoria guardando todas las
	direcciones asignadas por el operador new( ) en un array de
	estructuras Info, que también tiene el nombre del fichero y el
	número de línea donde la llamada new se encuentra. Para prevenir la
	colisión con cualquier nombre que haya colocado en el espacio
	de nombres global, tanta información como sea posible se guarda
	dentro del espacio de nombre anónimo. La clase Sentinel existe
	únicamente para llamar a un destructor de objetos con estático
	cuando el programa termina. Este destructor inspecciona memMap
	para ver si algún puntero está esperando a ser borrado
	(indicando una perdida de memoria).
      </p><p>
	Nuestro operador new( ) usa malloc( ) para conseguir memoria,
	y luego añade el puntero y su información de fichero asociado
	a memMap. La función de operador delete( ) deshace todo el
	trabajo llamando a free( ) y decrementando nptrs, pero primero
	se comprueba para ver si el puntero en cuestión está en el mapa
	en el primer lugar. Si no es así, o reintenta borrar una
	dirección que no está en el almacén libre, o re intenta borrar
	la que ya ha sido borrada y eliminada del mapa. La variable
	activeFlag es importante aquí porque no queremos procesar
	ninguna desasignación de alguna actividad del cierre del
	sistema. Llamando a MEM_OFF( ) al final de su código, activeFlag
	será puesta a falso, y posteriores llamadas para borrar serán
	ignoradas. (Está mal en un programa real, pero nuestra
	intención aquí es encontrar agujeros, no está depurando la
	biblioteca.) Por simplicidad, enviamos todo el trabajo por
	array new y delete a sus homólogos escalares.
      </p><p>
	Lo siguiente es un test sencillo usando la facilidad MemCheck:
      </p><div class="example"><a id="idp3706456"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:MemTest.cpp</span>
<span class="hl slc">//{L} MemCheck</span>
<span class="hl slc">// Test of MemCheck system.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;MemCheck.h&quot;</span><span class="hl ppc"></span>   <span class="hl slc">// Must appear last!</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Foo <span class="hl opt">{</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> s<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Foo</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span>s <span class="hl opt">) {</span>
    <span class="hl kwa">this</span><span class="hl opt">-&gt;</span>s <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">char</span><span class="hl opt">[</span><span class="hl kwd">strlen</span><span class="hl opt">(</span>s<span class="hl opt">) +</span> <span class="hl num">1</span><span class="hl opt">];</span>
    <span class="hl kwd">strcpy</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">-&gt;</span>s<span class="hl opt">,</span> s<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Foo</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> <span class="hl opt">[]</span> s<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">MEM_ON</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;hello&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">;</span>
  <span class="hl kwa">delete</span> p<span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> q <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">int</span><span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">];</span>
  <span class="hl kwa">delete</span> <span class="hl opt">[]</span> q<span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> r<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> r<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  Foo <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;goodbye&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">MEM_OFF</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 3.16. C02/MemTest.cpp</strong></p></div><br class="example-break" /><p>
	Este ejemplo verifica que puede usar MemCheck en presencia
	de streams, contenedores estándar, y clases que asignan
	memoria en constructores. Los punteros p y q son asignados y
	desasignados sin ningún problema, pero r no es un puntero de
	pila válido, así que la salida indica el error como un intento
	de borrar un puntero desconocido:
      </p><p>
      hola
      Asignados 4 bytes en la dirección 0xa010778 (fichero: memtest.cpp, línea: 25)
      Deleted memory at address 0xa010778
      Asignados 12 bytes en la dirección 0xa010778 (fichero: memtest.cpp, línea: 27)
      Memoria borrada en la dirección 0xa010778
      Intento de borrar puntero desconocido: 0x1
      Asignados 8 bytes en la dirección 0xa0108c0 (fichero: memtest.cpp, línea: 14)
      Memoria borrada en la dirección 0xa0108c0
      ¡No hay agujeros de memoria de usuario!
      </p><p>
	A causa de la llamada a MEM_OFF( ), no se procesan posteriores
	llamadas al operador delete( ) por vector o ostream. Todavía
	podría conseguir algunas llamadas a delete realizadas dsede
	reasignaciones por los contenedores.
      </p><p>
	Si llama a TRACE_OFF( ) al principio del programa, la salida es
      </p><p>
	Hola
	Intento de borrar puntero desconocido: 0x1
	¡No hay agujeros de memoria de usuario!
      </p></div></div><div class="sect1" title="3.4. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3711160"></a>3.4. Resumen </h2></div></div></div><p>
      Muchos de los dolores de cabeza de la ingenería del software
      pueden ser evitados reflexionando sobre lo que está
      haciendo. Probablemente ha estado usando aserciones mentales
      cuando ha navegado por sus blucles y funciones, incluso si no ha
      usado rutinariamente la macro assert( ). Si usa assert( ),
      encontrará errores lógicos más pronto y acabará con código más
      legible también. Recuerde usar solo aserciones para invariantes,
      aunque, no para el manejo de error en tiempo de ejecución.
    </p><p>
      Nada le dará más tranquilidad que código probado
      rigurosamente. Si ha sido un lío en el pasado, use un framework
      automatizado, como el que hemos presentado aquí, para integrar
      la rutina de pruebas en su trabajo diario. Usted (¡y sus usarios!)
      estarán contentos de que lo haga.
    </p></div><div class="sect1" title="3.5. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3713288"></a>3.5. Ejercicios </h2></div></div></div><p>
      Las soluciones para ejercicios seleccionados pueden encontrarse
      en el documento electrónico Pensar en C++ Volumen 2 Guía de
      Soluciones Comentadas disponible por una pequeña cuota en
      www.MindView.net.
    </p><p>
      1. Escriba un programa de prueba usando el Framework TestSuite
      para la clase estándar vector que prueba rigurosamente prueba
      las siguientes funciones con un vector de enteros: push_back( )
      (añade un elemento al final del vector) front( ) (devuelve el
      primer elemento en el vector), back( ) (devuelve el último elemento en
      el vector), pop_back( ) (elimina el último elemento sin
      devolverlo), at( ) (devuelve el elemento en una posición
      específica), y size( ) (devuelve el número de
      elementos). Asegúrese de verificar que vector::at( ) lanza una
      excepción std::out_of_range si el índice facilitado está fuera
      de rango.
    </p><p>
      2. Supóngase que le piden desarrollar un clase llamada Rational
      que da soporte a números racionales (fracciones). La fracción
      en un objecto Rational debería siempre almacenarse en los
      términos más bajos, y un denominador de cero es un error. Aquí
      está una interfaz de ejemplo para esa clase Rational:
    </p><div class="example"><a id="idp3716080"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C02:Rational.h {-xo}</span>
<span class="hl ppc">#ifndef RATIONAL_H</span>
<span class="hl ppc">#define RATIONAL_H</span>
<span class="hl ppc">#include &lt;iosfwd&gt;</span>

<span class="hl kwc">class</span> Rational <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Rational</span><span class="hl opt">(</span><span class="hl kwb">int</span> numerator <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> denominator <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">);</span>
  Rational <span class="hl kwc">operator</span><span class="hl opt">-()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwc">friend</span> Rational <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                            <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> Rational <span class="hl kwc">operator</span><span class="hl opt">-(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                            <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> Rational <span class="hl kwc">operator</span><span class="hl opt">*(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                            <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> Rational <span class="hl kwc">operator</span><span class="hl opt">/(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                            <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>istream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span>std<span class="hl opt">::</span>istream<span class="hl opt">&amp;,</span> Rational<span class="hl opt">&amp;);</span>
  Rational<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">+=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  Rational<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">-=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  Rational<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">*=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  Rational<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">/=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                        <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                        <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                         <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                         <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                         <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> Rational<span class="hl opt">&amp;,</span>
                         <span class="hl kwb">const</span> Rational<span class="hl opt">&amp;);</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// RATIONAL_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 3.17. C02/Rational.h</strong></p></div><br class="example-break" /><p>
      Escriba una especificación completa para esta clase, incluyendo
      especificaciones de precondiciones, postcondiciones, y de excepción.
    </p><p>
      3. Escriba un prueba usando el framework TestSuite que pruebe
      rigurosamente todas las especificaciones del ejercicio anterior,
      incluyendo probar las excepciones.
    </p><p>
      4. Implemente la clase Rational de modo que pase todas las pruebas
      del ejercicio anterior. Use aserciones sólo para las invariantes.
    </p><p>
      5. El fichero BuggedSearch.cpp de abajo contiene un función de
      búsqueda binaria que busca para el rango [pedir, final). Hay
      algunos errores en el algoritmo. Use las técnicas de seguimiento
      de este capítulo para depurar la función de búsqueda.
    </p></div></div></div><div class="part" title="Parte II. La librería Estándar de C++"><div class="titlepage"><div><div><h1 class="title"><a id="idp3722024"></a>Parte II. La librería Estándar de C++</h1></div></div></div><div class="partintro" title="La librería Estándar de C++"><div></div><div class="highlights"><p>
	  El C++ Estándar no solo incorpora todas las librerías de
	  Estándar C (con pequeños añadidos y cambios para permitir
	  tipos seguros), también añade sus propias librerías. Estas
	  librerías son mucho más potentes que las de C. La mejora al
	  usarlas es análoga a la que se consigue al cambiar de C a C++.
	</p></div><p>
	Esta sección del libro le da una introducción en profundidad a
	las partes clave de la librería Estándar de C++.
      </p><p>
	La referencia más completa y también la más oscura para las
	librerías es el propio Estándar. <em class="citetitle">The C++
	Programming Language, Third Edition (Addison Wesley,
	2000)</em> de <span class="author"><span class="firstname">Bjarne</span> <span class="surname">Stroustrup</span></span> sigue siendo una
	referencia fiable tanto para el lenguaje como para la
	librería. La referencia más aclamada en cuanto a la librería
	es <em class="citetitle">The C++ Standard Library: A Tutorial and
	Reference, by Nicolai Josuttis (Addison Wesley,
	1999)</em>. El objetivo de los capítulos de esta parte
	del libro es ofrecer un catálogo de descripciones y ejemplos
	para que disponga de un buen punto de partida para resolver
	cualquier problema que requiera el uso de las librerías
	Estándar. Sin embargo, algunas técnicas y temas se usan poco y
	no se tratan aquí. Si no puede encontrar algo en estos
	capítulos, mire en los dos libros que se citan anteriormente;
	esto libro no pretende reemplazarlos, más bien
	completarlos. En particular, esperamos que después de consular
	el material de los siguientes capítulos pueda comprender mejor
	esos libros.
      </p><p>
	El lector notará que estos capítulos no contienen
	documentación exhaustiva describiendo cada función o clase del
	la Librería Estándar C++. Hemos dejado las descripciones
	completas a otros; en particular a <a class="ulink" href="http://www.dinkumware.com" target="_top"><em class="citetitle">Dinkumware C/C++
	Library Reference</em></a> de
	<span class="author"><span class="firstname">P.J.</span> <span class="surname">
	Plauger</span></span>. Esta es una excelente
	documentación que puede puede ver con un navegador web cada
	vez que necesite buscar algo. Puede verla on-line o comprarla
	para verla en local. Contiene una referencia completa para las
	librerías de C y C++ (de modo que es buena para cualquier
	cuestión de programación en C/C++ Estándar). La documentación
	electrónica no sólo es efectiva porque pueda tenerla siempre a
	mano, sino porque también puede hacer búsquedas electrónicas.
      </p><p>
	Cuando usted está programando activamente, estos recursos
	deberían satisfacer sus necesidades de referencias (y puede
	usarlas para buscar algo de este capítulo que no tenga
	claro). El Apéndice A incluye referencias adicionales.
      </p><p>
	El primer capítulo de esta sección introduce la clase
	<code class="classname">string</code> del Estándar C++, que es una
	herramienta potente que simplifica la mayoría de las tareas de
	procesamiento de texto que podría tener que realizar. Casi
	cualquier cosas que tenga hecho para cadenas de caracteres en C
	puede hacerse con una llamada a un método de la clase
	<code class="classname">string</code>.
      </p><p>
	El capítulo 4 cubre la librería <code class="literal">iostreams</code>,
	que contiene clases para procesar entrada y salida con ficheros,
	cadenas, y la consola del sistema.
      </p><p>
	Aunque el Capítulo 5: «Las plantillas a fondo» no es
	explícitamente un capítulo de la librería, es una preparación
	necesaria para los dos siguientes capítulos. En el capítulo 6
	examinaremos los algoritmos genéricos que ofrece la librería
	Estándar C++. Como están implementados con plantillas, esos
	algoritmos se pueden aplicar a cualquier secuencia de
	objetos. El Capítulo 7 cubre los contenedores estándar y sus
	iteradores asociados Vemos los algoritmos primero porque se
	pueden utilizar usando únicamente arrays y el contenedor
	<code class="classname">vector</code> (que vimos en el Volumen
	1). También es normal el uso de algoritmos estándar junto con
	contenedores, y es bueno que le resulten familiares antes de
	estudiar los contenedores.
      </p><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="chapter"><a href="#C3">4. Las cadenas a fondo</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp3742400">4.1. ¿Qué es un <code class="classname">string</code>?</a></span></dt><dt><span class="sect1"><a href="#idp3754520">4.2. Operaciones con cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3817824">4.3. Buscar en cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3949480">4.4. Una aplicación con cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3977376">4.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp3983032">4.6. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C04">5. Iostreams</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4010792">5.1. ¿Por que <code class="classname">iostream</code>? </a></span></dt><dt><span class="sect1"><a href="#idp4044104">5.2. <code class="classname">Iostreams</code> al rescate</a></span></dt><dt><span class="sect1"><a href="#idp4110296">5.3. Manejo errores de <code class="classname">stream</code></a></span></dt><dt><span class="sect1"><a href="#idp4146624">5.4. Iostreams de fichero</a></span></dt><dt><span class="sect1"><a href="#idp4178936">5.5. Almacenamiento de <code class="classname">iostream</code></a></span></dt><dt><span class="sect1"><a href="#idp4201664">5.6. Buscar en iostreams</a></span></dt><dt><span class="sect1"><a href="#idp4227208">5.7. Iostreams de <code class="classname">string</code></a></span></dt><dt><span class="sect1"><a href="#idp4265304">5.8. Formateo de stream de salida</a></span></dt><dt><span class="sect1"><a href="#idp4318832">5.9. Manipuladores</a></span></dt><dt><span class="sect1"><a href="#idp4358632">5.10.  </a></span></dt><dt><span class="sect1"><a href="#idp4388304">5.11.  </a></span></dt><dt><span class="sect1"><a href="#idp4400344">5.12.  </a></span></dt><dt><span class="sect1"><a href="#idp4400920">5.13.  </a></span></dt></dl></dd><dt><span class="chapter"><a href="#C05">6. Las plantillas en profundidad</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4410728">6.1.  </a></span></dt><dt><span class="sect1"><a href="#idp4459360">6.2.  </a></span></dt><dt><span class="sect1"><a href="#idp4497464">6.3.  </a></span></dt><dt><span class="sect1"><a href="#idp4524448">6.4.  </a></span></dt><dt><span class="sect1"><a href="#idp4550120">6.5.  </a></span></dt><dt><span class="sect1"><a href="#idp4575968">6.6.  </a></span></dt><dt><span class="sect1"><a href="#idp4617776">6.7.  </a></span></dt><dt><span class="sect1"><a href="#idp4632064">6.8.  </a></span></dt></dl></dd><dt><span class="chapter"><a href="#C06">7. Algoritmos genéricos</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4641792">7.1. Un primer vistazo</a></span></dt><dt><span class="sect1"><a href="#idp4706488">7.2. Objetos-función</a></span></dt><dt><span class="sect1"><a href="#idp4765784">7.3. Un catálogo de algoritmos STL</a></span></dt><dt><span class="sect1"><a href="#idp4879440">7.4. Creando sus propios algoritmos tipo STL</a></span></dt><dt><span class="sect1"><a href="#idp4883000">7.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp4883960">7.6. Ejercicios</a></span></dt></dl></dd></dl></div></div><div class="chapter" title="4: Las cadenas a fondo"><div class="titlepage"><div><div><h2 class="title"><a id="C3"></a>4: Las cadenas a fondo</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp3742400">4.1. ¿Qué es un <code class="classname">string</code>?</a></span></dt><dt><span class="sect1"><a href="#idp3754520">4.2. Operaciones con cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3817824">4.3. Buscar en cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3949480">4.4. Una aplicación con cadenas</a></span></dt><dt><span class="sect1"><a href="#idp3977376">4.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp3983032">4.6. Ejercicios</a></span></dt></dl></div><div class="highlights"><p>
      El procesamiento de cadenas de caracteres en C es una de las
      mayores pérdidas de tiempo. Las cadenas de caracteres requieren
      que el programador tenga en cuenta las diferencias entre cadenas
      estáticas y las cadenas creadas en la pila y en el montón,
      además del hecho que a veces pasa como argumento un
      <code class="type">char*</code> y a veces hay que copiar el arreglo entero.
    </p></div><p>
    Precisamente porque la manipulación de cadenas es muy común, las
    cadenas de caracteres son una gran fuente de confusiones y
    errores. Es por ello que la creación de clases de cadenas sigue
    siendo desde hace años un ejercicio común para programadores
    novatos. La clase <code class="classname">string</code> de la biblioteca
    estándar de C++ resuelve el problema de la manipulación de
    caracteres de una vez por todas, gestionando la memoria incluso
    durante las asignaciones y las construcciones de
    copia. Simplemente no tiene que preocuparse por ello.
  </p><p>
    Este capítulo<sup>[<a id="idp3736344" href="#ftn.idp3736344" class="footnote">1</a>]</sup> examina la clase
    <code class="classname">string</code> del Estándar C++; empieza con un
    vistazo a la composición de las <code class="classname">string</code> de
    C++ y como la versión de C++ difiere del tradicional arreglo de
    caracteres de C. Aprenderá sobre las operaciones y la manipulación
    usando objetos <code class="classname">string</code>, y verá como éstas se
    FIXME[acomodan a la variación] de conjuntos de caracteres y
    conversión de datos.
  </p><p>
    Manipular texto es una de las aplicaciones más antiguas de la
    programación, por eso no resulta sorprendente que las
    <code class="classname">string</code> de C++ estén fuertemente inspiradas
    en las ideas y la terminología que ha usado continuamente en C y
    otros lenguajes. Conforme vaya aprendiendo sobre los
    <code class="classname">string</code> de C++, este hecho se debería ir
    viendo más claramente. Da igual el lenguaje de programación que
    escoja, hay tres cosas comunes que querrá hacer con las cadenas:
  </p><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Crear o modificar secuencias de caracteres almacenados en una
        cadena</p></li><li class="listitem"><p>Detectar la presencia o ausencia de elementos dentro de la
        cadena</p></li><li class="listitem"><p>Traducir entre diversos esquemas para representar cadenas de
	  caracteres</p></li></ul></div><p>
  </p><p>
    Verá como cada una de estas tareas se resuelve usando objetos
    <code class="classname">string</code> en C++.
  </p><div class="sect1" title="4.1. ¿Qué es un string?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3742400"></a>4.1. ¿Qué es un <code class="classname">string</code>?</h2></div></div></div><p>
      En C, una cadena es simplemente un arreglo de caracteres que
      siempre incluye un 0 binario (frecuentemente llamado terminador
      nulo) como elemento final del arreglo. Existen diferencias
      significativas entre los <code class="classname">string</code> de C++ y
      sus progenitoras en C. Primero, y más importante, los
      <code class="classname">string</code> de C++ esconden la implementación
      física de la secuencia de caracteres que contiene. No debe
      preocuparse de las dimensiones del arreglo o del terminador
      nulo. Un <code class="classname">string</code> también contiene cierta
      información para uso interno sobre el tamaño y la localización
      en memoria de los datos.  Específicamente, un objeto
      <code class="classname">string</code> de C++ conoce su localización en
      memoria, su contenido, su longitud en caracteres, y la cantidad
      de caracteres que puede crecer antes de que el objeto
      <code class="classname">string</code> deba redimensionar su buffer
      interno de datos.  Las <code class="classname">string</code> de C++, por
      tanto, reducen enormemente las probabilidades de cometer uno de
      los tres errores de programación en C más comunes y
      destructivos: sobrescribir los límites del arreglo, intentar
      acceder a un arreglo no inicializado o con valores de puntero
      incorrectos, y dejar punteros colgando después de que el arreglo
      deje de ocupar el espacio que estaba ocupando.
    </p><p>
      La implementación exacta del esquema en memoria para una clase
      string no esta definida en el estándar C++. Esta arquitectura
      esta pensada para ser suficientemente flexible para permitir
      diferentes implementaciones de los fabricantes de compiladores,
      garantizando igualmente un comportamiento predecible por los
      usuarios. En particular, las condiciones exactas de cómo situar
      el almacenamiento para alojar los datos para un objeto
      <code class="classname">string</code> no están definidas. FIXME: Las
      reglas de alojamiento de un <code class="classname">string</code> fueron
      formuladas para permitir, pero no requerir, una implementación
      con referencias múltiples, pero dependiendo de la implementación
      usar referencias múltiples sin variar la semántica. Por decirlo
      de otra manera, en C, todos los arreglos de char ocupan una
      única región física de memoria. En C++, los objetos
      <code class="classname">string</code> individuales pueden o no ocupar
      regiones físicas únicas de memoria, pero si su conjunto de
      referencias evita almacenar copias duplicadas de datos, los
      objetos individuales deben parecer y actuar como si tuvieran sus
      propias regiones únicas de almacenamiento.
    </p><div class="example"><a id="idp3749488"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StringStorage.h</span>
<span class="hl ppc">#ifndef STRINGSTORAGE_H</span>
<span class="hl ppc">#define STRINGSTORAGE_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>cout<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>

<span class="hl kwc">class</span> StringStorageTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    string <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;12345&quot;</span><span class="hl opt">);</span>
    <span class="hl slc">// This may copy the first to the second or</span>
    <span class="hl slc">// use reference counting to simulate a copy:</span>
    string s2 <span class="hl opt">=</span> s1<span class="hl opt">;</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">==</span> s2<span class="hl opt">);</span>
    <span class="hl slc">// Either way, this statement must ONLY modify s1:</span>
    s1<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl str">'6'</span><span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;s1 = &quot;</span> <span class="hl opt">&lt;&lt;</span> s1 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 62345</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;s2 = &quot;</span> <span class="hl opt">&lt;&lt;</span> s2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 12345</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">!=</span> s2<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STRINGSTORAGE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.1. C03/StringStorage.h</strong></p></div><br class="example-break" /><p>
      Decimos que cuando una implementación  solo hace una sola copia
      al modificar el  <code class="classname">string</code> usa una
      estrategia de copiar  al escribir.  Esta  aproximación ahorra
      tiempo y  espacio cuando  usamos <code class="classname">string</code>
      como  parámetros por valor o en otras situaciones de solo
      lectura.
    </p><p>
      El uso de referencias múltiples en la implementación de una
      librería debería ser transparente al usuario de la clase
      string. Desgraciadamente, esto no es siempre el caso. En
      programas multihilo, es prácticamente imposible usar
      implementaciones con múltiples referencias de forma
      segura[32].<sup>[<a id="idp3753496" href="#ftn.idp3753496" class="footnote">2</a>]</sup>
    </p></div><div class="sect1" title="4.2. Operaciones con cadenas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3754520"></a>4.2. Operaciones con cadenas</h2></div></div></div><p>
      Si ha programado en C, estará acostumbrado a la familia de
      funciones que leen, escriben, modifican y copian
      cadenas. Existen dos aspectos poco afortunados en la funciones
      de la librería estándar de C para manipular cadenas. Primero,
      hay dos familias pobremente organizadas: el grupo plano, y
      aquellos que requieren que se les suministre el número de
      caracteres para ser consideradas en la operación a mano. La
      lista de funciones en la librería de cadenas de C sorprende al
      usuario desprevenido con una larga lista de nombres crípticos y
      mayoritariamente impronunciables. Aunque el tipo y número de
      argumentos es algo consistente, para usarlas adecuadamente debe
      estar atento a los detalles de nombres de la función y a los
      parámetros que le pasas.
    </p><p>
      La segunda trampa inherente a las herramientas para cadenas del
      estándar de C es que todas ellas explícitamente confían en la
      asunción de que cada cadena incluye un terminador nulo. Si por
      confusión o error el terminador nulo es omitido o sobrescrito,
      poco se puede hacer para impedir que las funciones de cadena de
      C manipulen la memoria más allá de los límites del espacio de
      alojamiento, a veces con resultados desastrosos.
    </p><p>
      C++ aporta una vasta mejora en cuanto a conveniencia y seguridad
      de los objetos <code class="classname">string</code>. Para los
      propósitos de las actuales operaciones de manipulación, existe
      el mismo número de funciones que la librería de C, pero gracias
      a la sobrecarga, la funcionalidad es mucho mayor. Además, con
      una nomenclatura más sensata y un acertado uso de los argumentos
      por defecto, estas características se combinan para hacer de la
      clase <code class="classname">string</code> mucho más fácil de usar que
      la biblioteca de funciones de cadena de C.
    </p><div class="sect2" title="4.2.1. Añadiendo, insertando y concatenando cadenas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3759256"></a>4.2.1. Añadiendo, insertando y concatenando cadenas</h3></div></div></div><p>
	Uno de los aspectos más valiosos y convenientes de los
	<code class="classname">string</code> en C++ es que crecen cuando lo
	necesitan, sin intervención por parte del programador. No solo
	hace el código de manejo del <code class="classname">string</code> sea
	inherentemente mas confiable, además elimina por completo las
	tediosas funciones "caseras" para controlar los limites del
	almacenamiento en donde nuestra cadena reside.  Por ejemplo,
	si	crea un objeto <code class="classname">string</code> e
	inicializa este	<code class="classname">string</code> con 50 copias de
	"X", y después	copia en el 50 copias de "Zowie", el objeto,
	por sí mismo,	readecua suficiente almacenamiento para
	acomodar el crecimiento	de los datos. Quizás en ningún otro
	lugar es más apreciada esta	propiedad que cuando las
	cadenas manipuladas por su	código	cambian de tamaño y no
	sabe cuan grande puede ser este	cambio. La función miembro
	<code class="function">append()</code> e <code class="function">insert()</code>
	de <code class="classname">string</code>	reubican de manera
	transparente el almacenamiento cuando un
	<code class="classname">string</code> crece:
      </p><div class="example"><a id="idp3763208"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StrSize.cpp</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">bigNews</span><span class="hl opt">(</span><span class="hl str">&quot;I saw Elvis in a UFO. &quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> bigNews <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// How much data have we actually got?</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Size = &quot;</span> <span class="hl opt">&lt;&lt;</span> bigNews<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// How much can we store without reallocating?</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Capacity = &quot;</span> <span class="hl opt">&lt;&lt;</span> bigNews<span class="hl opt">.</span><span class="hl kwd">capacity</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Insert this string in bigNews immediately</span>
  <span class="hl slc">// before bigNews[1]:</span>
  bigNews<span class="hl opt">.</span><span class="hl kwd">insert</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl str">&quot; thought I&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> bigNews <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Size = &quot;</span> <span class="hl opt">&lt;&lt;</span> bigNews<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Capacity = &quot;</span> <span class="hl opt">&lt;&lt;</span> bigNews<span class="hl opt">.</span><span class="hl kwd">capacity</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Make sure that there will be this much space</span>
  bigNews<span class="hl opt">.</span><span class="hl kwd">reserve</span><span class="hl opt">(</span><span class="hl num">500</span><span class="hl opt">);</span>
  <span class="hl slc">// Add this to the end of the string:</span>
  bigNews<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl str">&quot;I've been working too hard.&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> bigNews <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Size = &quot;</span> <span class="hl opt">&lt;&lt;</span> bigNews<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Capacity = &quot;</span> <span class="hl opt">&lt;&lt;</span> bigNews<span class="hl opt">.</span><span class="hl kwd">capacity</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.2. C03/StrSize.cpp</strong></p></div><br class="example-break" /><p>
	Aquí la salida desde un compilador cualquiera:
      </p><pre class="screen">
I saw Elvis in a UFO.
Size = 22
Capacity = 31
I thought I saw Elvis in a UFO.
Size = 32
Capacity = 47
I thought I saw Elvis in a UFO. I've been
working too hard.
Size = 59
Capacity = 511
</pre><p>
	Este ejemplo demuestra que aunque puede ignorar con seguridad
	muchas de las responsabilidades de reserva y gestión de la
	memoria que tus  <code class="classname">string</code> ocupan, C++
	provee a los <code class="classname">string</code> con varias
	herramientas para monitorizar y  gestionar su tamaño. Nótese
	la facilidad con la que hemos cambiado el tamaño de la memoria
	reservada para los <code class="classname">string</code>. La función
	<code class="function">size()</code> retorna el numero de caracteres
	actualmente almacenados en el <code class="classname">string</code> y
	es idéntico a la función miembro
	<code class="function">lenght()</code>. La función
	<code class="function">capacity()</code> retorna el tamaño de la
	memoria subyacente actual, es decir, el número de caracteres
	que el <code class="classname">string</code> puede almacenar sin tener
	que reservar más memoria. La función
	<code class="function">reserve()</code> es una optimización del
	mecanismo que indica su intención de especificar cierta
	cantidad de memoria para un futuro uso;
	<code class="function">capacity()</code> siempre retorna un valor al
	menos tan largo como la ultima llamada a
	<code class="function">reserve()</code>. La función
	<code class="function">resize()</code> añade espacio si el nuevo tamaño
	es mayor que el tamaño actual del
	<code class="classname">string</code>; sino trunca el
	<code class="classname">string</code>. (Una sobrecarga de
	<code class="function">resize()</code> puede especificar una adición
	diferente de caracteres).
      </p><p>
	La manera exacta en que las funciones miembro de
	<code class="classname">string</code> reservan espacio para sus datos
	depende de la implementación de la librería. Cuando testeamos
	una implementación con el ejemplo anterior, parece que se
	hacia una reserva de una palabra de memoria (esto es, un
	entero) dejando un byte en blanco entre cada una de ellas. Los
	arquitectos de la clase string se esforzaron para poder
	mezclar el uso de las cadenas de caracteres de C y los objetos
	<code class="classname">string</code>, por lo que es probable por lo
	que se puede observar en <span class="emphasis"><em>StrSize.cpp</em></span>, en
	esta implementación en particular, el byte esté añadido para
	acomodar fácilmente la inserción de un terminador nulo.
      </p></div><div class="sect2" title="4.2.2. Reemplazar caracteres en cadenas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3774568"></a>4.2.2. Reemplazar caracteres en cadenas </h3></div></div></div><p>
	La función <code class="function">insert()</code> es particularmente
	útil por que te evita el tener que estar seguro de que la
	inserción de caracteres en un <code class="classname">string</code> no
	sobrepasa el espacio reservado o sobrescribe los caracteres
	que inmediatamente siguientes al punto de inserción. El
	espacio crece y los caracteres existentes se mueven
	graciosamente para acomodar a los nuevos elementos. A veces,
	puede que no sea esto exactamente lo que quiere. Si quiere que
	el tamaño del <code class="classname">string</code> permanezca sin
	cambios, use la función <code class="function">replace()</code> para
	sobrescribir los caracteres. Existe un número de versiones
	sobrecargadas de <code class="function">replace()</code>, pero la más
	simple toma tres argumentos: un entero indicando donde empezar
	en el <code class="classname">string</code>, un entero indicando
	cuantos caracteres para eliminar del
	<code class="classname">string</code> original, y el
	<code class="classname">string</code> con el que reemplazaremos (que
	puede ser diferente en numero de caracteres que la cantidad
	eliminada). Aquí un ejemplo simple:
      </p><div class="example"><a id="idp3778744"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StringReplace.cpp</span>
<span class="hl slc">// Simple find-and-replace in strings.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;A piece of text&quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">tag</span><span class="hl opt">(</span><span class="hl str">&quot;$tag$&quot;</span><span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">insert</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">,</span> tag <span class="hl opt">+</span> <span class="hl str">' '</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s <span class="hl opt">==</span> <span class="hl str">&quot;A piece $tag$ of text&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> start <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>tag<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>start <span class="hl opt">==</span> <span class="hl num">8</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>tag<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() ==</span> <span class="hl num">5</span><span class="hl opt">);</span>
  s<span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span>start<span class="hl opt">,</span> tag<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(),</span> <span class="hl str">&quot;hello there&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s <span class="hl opt">==</span> <span class="hl str">&quot;A piece hello there of text&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.3. C03/StringReplace.cpp</strong></p></div><br class="example-break" /><p>
	<code class="varname">Tag</code> es insertada en <code class="varname">s</code>
	(notese que la inserción ocurre <span class="emphasis"><em>antes</em></span> de
	que el valor indicando el punto de inserción y de que el
	espacio extra haya sido añadido despues de
	<code class="varname">Tag</code>), y entonces es encontrada y
	reemplazada.
      </p><p>
	Debería cerciorarse de que ha encontrado algo antes de
	realizar el <code class="function">replace()</code>. En los ejemplos
	anteriores se reemplaza con un <code class="type">char*</code>, pero existe
	una versión sobrecargada que reemplaza con un
	<code class="classname">string</code>. Aqui hay un ejempl más completo
	de demostración de <code class="function">replace()</code>:
      </p><div class="example"><a id="idp3783592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Replace.cpp</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>  <span class="hl slc">// For size_t</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">replaceChars</span><span class="hl opt">(</span>string<span class="hl opt">&amp;</span> modifyMe<span class="hl opt">,</span>
  <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> findMe<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> newChars<span class="hl opt">) {</span>
  <span class="hl slc">// Look in modifyMe for the &quot;find string&quot;</span>
  <span class="hl slc">// starting at position 0:</span>
  <span class="hl kwb">size_t</span> i <span class="hl opt">=</span> modifyMe<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>findMe<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Did we find the string to replace?</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">)</span>
    <span class="hl slc">// Replace the find string with newChars:</span>
    modifyMe<span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span>i<span class="hl opt">,</span> findMe<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(),</span> newChars<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string bigNews <span class="hl opt">=</span> <span class="hl str">&quot;I thought I saw Elvis in a UFO. &quot;</span>
                   <span class="hl str">&quot;I have been working too hard.&quot;</span><span class="hl opt">;</span>
  string <span class="hl kwd">replacement</span><span class="hl opt">(</span><span class="hl str">&quot;wig&quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">findMe</span><span class="hl opt">(</span><span class="hl str">&quot;UFO&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Find &quot;UFO&quot; in bigNews and overwrite it:</span>
  <span class="hl kwd">replaceChars</span><span class="hl opt">(</span>bigNews<span class="hl opt">,</span> findMe<span class="hl opt">,</span> replacement<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>bigNews <span class="hl opt">==</span> <span class="hl str">&quot;I thought I saw Elvis in a &quot;</span>
         <span class="hl str">&quot;wig. I have been working too hard.&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.4. C03/Replace.cpp</strong></p></div><br class="example-break" /><p>
	Si <code class="function">replace()</code> no encuentra la cadena
	buscada, retorna un
	<code class="classname">string::</code><code class="varname">npos</code>. El
	dato miembro <code class="varname">npos</code> es una constante estatica
	de la clase <code class="classname">string</code> que representa una
	posición de carácter que no existe[33].
	<sup>[<a id="idp3787584" href="#ftn.idp3787584" class="footnote">3</a>]</sup>
      </p><p>
	A diferencia de <code class="function">insert()</code>,
	<code class="function">replace()</code> no aumentará el espacio de
	alamcenamiento de <code class="classname">string</code> si copia
	nuevos caracteres en el medio de una serie de elementos de
	array existentes. Sin embargo, sí que cerecerá su espacio si
	es necesario, por ejemplo, cuando hace un
	<span class="emphasis"><em>"reemplazamiento"</em></span> que pueda expandir el
	<code class="classname">string</code> más allá del final de la memoria
	reservada actual. Aquí un ejemplo:
      </p><div class="example"><a id="idp3791056"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ReplaceAndGrow.cpp</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">bigNews</span><span class="hl opt">(</span><span class="hl str">&quot;I have been working the grave.&quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">replacement</span><span class="hl opt">(</span><span class="hl str">&quot;yard shift.&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// The first argument says &quot;replace chars</span>
  <span class="hl slc">// beyond the end of the existing string&quot;:</span>
  bigNews<span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span>bigNews<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() -</span> <span class="hl num">1</span><span class="hl opt">,</span>
    replacement<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(),</span> replacement<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>bigNews <span class="hl opt">==</span> <span class="hl str">&quot;I have been working the &quot;</span>
         <span class="hl str">&quot;graveyard shift.&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.5. C03/ReplaceAndGrow.cpp</strong></p></div><br class="example-break" /><p>
	La llamada a <code class="function">replace()</code> empieza
	<span class="emphasis"><em>"reemplazando"</em></span> más allá del final del
	array existente, que es equivalente a la operación
	<code class="function">append()</code>. Nótese que en este ejemplo
	<code class="function">replace()</code> expande el array
	coherentemente.
      </p><p>
	Puede que haya estado buscando a través del capítulo;
	intentando hacer algo relativamente fácil como reemplazar
	todas las ocurrencias de un carácter con diferentes
	caracteres. Al buscar el material previo sobre reemplazar,
	puede que haya encontrado la respuesta, pero entonces ha
	empezaro viendo grupos de caracteres y contadores y otras
	cosas que parecen un poco demasiado complejas. ¿No tiene
	<code class="classname">string</code> una manera para reemplazar un
	carácter con otro simplemente?
      </p><p>
	Puede escribir fácilmente cada funcin usando las funciones
	miembro <code class="function">find()</code> y
	<code class="function">replace()</code> como se muestra acontinuacion.
      </p><div class="example"><a id="idp3796512"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ReplaceAll.h</span>
<span class="hl ppc">#ifndef REPLACEALL_H</span>
<span class="hl ppc">#define REPLACEALL_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>

std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> context<span class="hl opt">,</span>
  <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> from<span class="hl opt">,</span> <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> to<span class="hl opt">);</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// REPLACEALL_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.6. C03/ReplaceAll.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp3797728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ReplaceAll.cpp {O}</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ReplaceAll.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

string<span class="hl opt">&amp;</span> <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>string<span class="hl opt">&amp;</span> context<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> from<span class="hl opt">,</span>
  <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> to<span class="hl opt">) {</span>
  <span class="hl kwb">size_t</span> lookHere <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">size_t</span> foundHere<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>foundHere <span class="hl opt">=</span> context<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>from<span class="hl opt">,</span> lookHere<span class="hl opt">))</span>
    <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
    context<span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span>foundHere<span class="hl opt">,</span> from<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(),</span> to<span class="hl opt">);</span>
    lookHere <span class="hl opt">=</span> foundHere <span class="hl opt">+</span> to<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> context<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.7. C03/ReplaceAll.cpp</strong></p></div><br class="example-break" /><p>
	La versión de <code class="function">find()</code> usada aquí toma como
	segundo argumento la posición donde empezar a buscar y retorna
	<code class="classname">string::</code><code class="varname">npos</code> si no
	lo encuentra. Es importante avanzar en la posición contenida
	por la variable <code class="varname">lookHere</code> pasada como
	subcadena, en caso de que <code class="varname">from</code> es una
	subcadena de <code class="varname">to</code>. El siguiente programa
	comprueba la funcion <code class="function">replaceAll()</code>:
      </p><div class="example"><a id="idp3801896"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ReplaceAllTest.cpp</span>
<span class="hl slc">//{L} ReplaceAll</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ReplaceAll.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string text <span class="hl opt">=</span> <span class="hl str">&quot;a man, a plan, a canal, Panama&quot;</span><span class="hl opt">;</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>text<span class="hl opt">,</span> <span class="hl str">&quot;an&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;XXX&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>text <span class="hl opt">==</span> <span class="hl str">&quot;a mXXX, a plXXX, a cXXXal, PXXXama&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.8. C03/ReplaceAllTest.cpp</strong></p></div><br class="example-break" /><p>
	Como puede comprobar, la clase <code class="classname">string</code>
	por ella sola no resuelve todos los posibles problemas. Muchas
	soluciones se han dejado en los algoritmos de la librería
	estándar<sup>[<a id="idp3804064" href="#ftn.idp3804064" class="footnote">4</a>]</sup> por que la clase
	<code class="classname">string</code> puede parece justamente como una
	secuencia STL(gracias a los iteradores descritos antes). Todos
	los algoritmos genéricos funcionan en un
	<span class="emphasis"><em>"rango"</em></span> de elementos dentro de un
	contenedor. Generalmente este rango es justamente desde el
	principio del contenedor hasta el final. Un objeto
	<code class="classname">string</code> se parece a un contenedor de
	caracteres: para obtener el principio de este rango use
	<code class="classname">string::</code><code class="function">begin()</code>, y
	para obtener el final del rango use
	<code class="classname">string::</code><code class="function">end()</code>. El
	siguiente ejemplomuestra el uso del algoritmo
	<code class="function">replace()</code> para reemplazar todas las
	instancias de un determinado carácter <span class="emphasis"><em>"X"</em></span>
	con <span class="emphasis"><em>"Y"</em></span>
      </p><div class="example"><a id="idp3807432"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StringCharReplace.cpp</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;aaaXaaaXXaaXXXaXXXXaaa&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replace</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">'X'</span><span class="hl opt">,</span> <span class="hl str">'Y'</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s <span class="hl opt">==</span> <span class="hl str">&quot;aaaYaaaYYaaYYYaYYYYaaa&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.9. C03/StringCharReplace.cpp</strong></p></div><br class="example-break" /><p>
	Nótese que esta función <code class="function">replace()</code> no es
	llamada como función miembro de
	<code class="classname">string</code>. Además, a diferencia de la
	función
	<code class="classname">string::</code><code class="function">replace()</code>,
	que solo realiza un reemplazo, el algoritmo
	<code class="function">replace()</code> reemplaza todas las instancias
	de un carácter con otro.
      </p><p>
	El algoritmo <code class="function">replace()</code> solo funciona con
	objetos individuales (en este caso, objetos <code class="type">char</code>)
	y no reemplazará arreglos constantes o objetos
	<code class="classname">string</code>. Desde que un
	<code class="classname">string</code> se copmporta como una secuencia
	STL, un conjunto de algoritmos pueden serle aplicados, que
	resolverán otros problemas que las funciones miembro de
	<code class="classname">string</code> no resuelven.
      </p></div><div class="sect2" title="4.2.3. Concatenación usando operadores no-miembro sobrecargados"><div class="titlepage"><div><div><h3 class="title"><a id="idp3812536"></a>4.2.3. Concatenación usando operadores no-miembro sobrecargados</h3></div></div></div><p>
	Uno de los descubrimientos más deliciosos que esperan al
	programador de C que está aprendiendo sobre el manejo de
	cadenas en C++, es lo simple que es combinar y añadir
	<code class="classname">string</code> usando los operadores
	<code class="function">operator+</code> y
	<code class="function">operator+=</code>. Estos operadores hacen
	combinaciones de cadenas sintacticamente parecidas a la suma
	de datos numéricos:
      </p><div class="example"><a id="idp3814584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:AddStrings.cpp</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;This &quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">s2</span><span class="hl opt">(</span><span class="hl str">&quot;That &quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">s3</span><span class="hl opt">(</span><span class="hl str">&quot;The other &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// operator+ concatenates strings</span>
  s1 <span class="hl opt">=</span> s1 <span class="hl opt">+</span> s2<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s1 <span class="hl opt">==</span> <span class="hl str">&quot;This That &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Another way to concatenates strings</span>
  s1 <span class="hl opt">+=</span> s3<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s1 <span class="hl opt">==</span> <span class="hl str">&quot;This That The other &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// You can index the string on the right</span>
  s1 <span class="hl opt">+=</span> s3 <span class="hl opt">+</span> s3<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">] +</span> <span class="hl str">&quot;ooh lala&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s1 <span class="hl opt">==</span> <span class="hl str">&quot;This That The other The other oooh lala&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.10. C03/AddStrings.cpp</strong></p></div><br class="example-break" /><p>
	Usar los operadores <code class="function">operator+</code> y
	<code class="function">operator+=</code> es una manera flexible y
	conveniente de combinar los datos de las cadenas. En la parte
	derecha de la sentencia, puede usar casi cualquier tipo que
	evalúe a un grupo de uno o más caracteres.
      </p></div></div><div class="sect1" title="4.3. Buscar en cadenas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3817824"></a>4.3. Buscar en cadenas</h2></div></div></div><p>
      La familia de funciones miembro de <code class="classname">string</code>
      <code class="function">find</code> localiza un carácter o grupo de
      caracteres en una cadena dada. Aquí los miembros de la familia
      <code class="function">find()</code> y su uso general:
    </p><p>
      Función miembro de búsqueda en un <code class="classname">string</code>
    </p><p>
      ¿Qué/Cómo lo encuentra?
    </p><p>
      <code class="function">find()</code>
    </p><p>
      Busca en un <code class="classname">string</code> un carácter
      determinado o un grupo de caracteres y retorna la posición de
      inicio de la primera ocurrencia o <code class="varname">npos</code> si ha
      sido encontrado.
    </p><p>
      <code class="function">find_first_of()</code>
    </p><p>
      Busca en un <code class="classname">string</code> y retorna la posición
      de la primera ocurrencia de cualquier carácter en un grupo
      especifico. Si no encuentra ocurrencias, retorna
      <code class="varname">npos</code>.
    </p><p>
      <code class="function">find_last_of()</code>
    </p><p>
      Busca en un <code class="classname">string</code> y retorna la posición
      de la última ocurrencia de cualquier carácter en un grupo
      específico. Si no encuentra ocurrencias, retorna
      <code class="varname">npos</code>.
    </p><p>
      <code class="function">find_first_not_of( )</code>
    </p><p>
      Busca en un <code class="classname">string</code> y retorna la posición
      de la primera ocurrencia que no pertenece a un grupo
      específico. Si no encontramos ningún elemento, retorna un
      <code class="varname">npos</code>
    </p><p>
      <code class="function">find_last_not_of( )</code>
    </p><p>
      Busca en un <code class="classname">string</code> y retorna la posición
      del elemento con el indice mayor que no pertenece a un grupo
      específico. Si no encontramos ningún elemento, retorna un
      <code class="varname">npos</code>
    </p><p>
      <code class="function">rfind()</code>
    </p><p>
      Busca en un <code class="classname">string</code>, desde el final hasta
      el origen, un carácter o grupo de caracteres y retorna la
      posición inicial de la ocurrencia si se ha encontrado alguna. Si
      no encuentra ocurrencias, retorna <code class="varname">npos</code>.
    </p><p>
      El uso más simple de <code class="function">find()</code>, busca uno o
      más caracteres en un <code class="classname">string</code>. La versión
      sobrecargada de <code class="function">find()</code> toma un parámetro
      que especifica el/los carácter(es) que buscar y opcionalmente un
      parámetro que dice donde empezar a buscar en el
      <code class="classname">string</code> la primera ocurrencia. (Por
      defecto la posición de incio es 0). Insertando la llamada a la
      función <code class="function">find()</code> dentro de un bucle puede
      buscar fácilmente todas las ocurrencias de un carácter dado o un
      grupo de caracteres dentro de un <code class="classname">string</code>.
    </p><p>
      El siguiente programa usa el método del Tamiz de Eratostenes
      para hallar los números primos menores de 50. Este método
      empieza con el número 2, marca todos los subsecuentes múltiplos
      de 2 ya que no son primos, y repite el proceso para el siguiente
      candidato a primo. El constructor de sieveTest inicializa
      sieveChars poniendo el tamaño inicial del arreglo de carácter y
      escribiendo el valor <span class="emphasis"><em>'P'</em></span> para cada miembro.
    </p><div class="example"><a id="idp3832504"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Sieve.h</span>
<span class="hl ppc">#ifndef SIEVE_H</span>
<span class="hl ppc">#define SIEVE_H</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>sqrt<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>

<span class="hl kwc">class</span> SieveTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
  string sieveChars<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Create a 50 char string and set each</span>
  <span class="hl slc">// element to 'P' for Prime:</span>
  <span class="hl kwd">SieveTest</span><span class="hl opt">() :</span> <span class="hl kwd">sieveChars</span><span class="hl opt">(</span><span class="hl num">50</span><span class="hl opt">,</span> <span class="hl str">'P'</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwd">findPrimes</span><span class="hl opt">();</span>
    <span class="hl kwd">testPrimes</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">isPrime</span><span class="hl opt">(</span><span class="hl kwb">int</span> p<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>p <span class="hl opt">==</span> <span class="hl num">0</span> <span class="hl opt">||</span> p <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">)</span> <span class="hl kwa">return false</span><span class="hl opt">;</span>
    <span class="hl kwb">int</span> root <span class="hl opt">=</span> <span class="hl kwb">int</span><span class="hl opt">(</span><span class="hl kwd">sqrt</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">(</span>p<span class="hl opt">)));</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span> i <span class="hl opt">&lt;=</span> root<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>p <span class="hl opt">%</span> i <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return false</span><span class="hl opt">;</span>
    <span class="hl kwa">return true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">findPrimes</span><span class="hl opt">() {</span>
    <span class="hl slc">// By definition neither 0 nor 1 is prime.</span>
    <span class="hl slc">// Change these elements to &quot;N&quot; for Not Prime:</span>
    sieveChars<span class="hl opt">.</span><span class="hl kwd">replace</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl str">&quot;NN&quot;</span><span class="hl opt">);</span>
    <span class="hl slc">// Walk through the array:</span>
    <span class="hl kwb">size_t</span> sieveSize <span class="hl opt">=</span> sieveChars<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span>
    <span class="hl kwb">int</span> root <span class="hl opt">=</span> <span class="hl kwb">int</span><span class="hl opt">(</span><span class="hl kwd">sqrt</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">(</span>sieveSize<span class="hl opt">)));</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span> i <span class="hl opt">&lt;=</span> root<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      <span class="hl slc">// Find all the multiples:</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> factor <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span> factor <span class="hl opt">*</span> i <span class="hl opt">&lt;</span> sieveSize<span class="hl opt">;</span>
           <span class="hl opt">++</span>factor<span class="hl opt">)</span>
        sieveChars<span class="hl opt">[</span>factor <span class="hl opt">*</span> i<span class="hl opt">] =</span> <span class="hl str">'N'</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testPrimes</span><span class="hl opt">() {</span>
    <span class="hl kwb">size_t</span> i <span class="hl opt">=</span> sieveChars<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'P'</span><span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>i <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
      <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">isPrime</span><span class="hl opt">(</span>i<span class="hl opt">++));</span>
      i <span class="hl opt">=</span> sieveChars<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'P'</span><span class="hl opt">,</span> i<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    i <span class="hl opt">=</span> sieveChars<span class="hl opt">.</span><span class="hl kwd">find_first_not_of</span><span class="hl opt">(</span><span class="hl str">'P'</span><span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>i <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
      <span class="hl kwd">test_</span><span class="hl opt">(!</span><span class="hl kwd">isPrime</span><span class="hl opt">(</span>i<span class="hl opt">++));</span>
      i <span class="hl opt">=</span> sieveChars<span class="hl opt">.</span><span class="hl kwd">find_first_not_of</span><span class="hl opt">(</span><span class="hl str">'P'</span><span class="hl opt">,</span> i<span class="hl opt">);</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// SIEVE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.11. C03/Sieve.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp3836472"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Sieve.cpp</span>
<span class="hl slc">//{L} ../TestSuite/Test</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Sieve.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  SieveTest t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> t<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.12. C03/Sieve.cpp</strong></p></div><br class="example-break" /><p>
      La función <code class="function">find()</code> puede recorrer el
      <code class="classname">string</code>, detectando múltiples ocurrencias
      de un carácter o un grupo de caracteres, y
      <code class="function">find_first_not_of()</code> encuentra otros
      caracteres o subcadenas.
    </p><p>
      No existen funciones en la clase <code class="classname">string</code>
      para cambiar entre mayúsculas/minúsculas en una cadena, pero
      puede crear esa función fácilmente usando la función de la
      libreria estándar de C <code class="function">toupper()</code> y
      <code class="function">tolower()</code>, que cambian los caracteres entre
      mayúsculas/minúsculas de uno en uno. El ejemplo siguiente
      ilustra una búsqueda sensible a mayúsculas/minúsculas.
    </p><div class="example"><a id="idp3840504"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Find.h</span>
<span class="hl ppc">#ifndef FIND_H</span>
<span class="hl ppc">#define FIND_H</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>tolower<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>toupper<span class="hl opt">;</span>

<span class="hl slc">// Make an uppercase copy of s</span>
<span class="hl kwc">inline</span> string <span class="hl kwd">upperCase</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  string <span class="hl kwd">upper</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    upper<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>upper<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl kwa">return</span> upper<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// Make a lowercase copy of s</span>
<span class="hl kwc">inline</span> string <span class="hl kwd">lowerCase</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  string <span class="hl kwd">lower</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    lower<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwd">tolower</span><span class="hl opt">(</span>lower<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl kwa">return</span> lower<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> FindTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
  string chooseOne<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">FindTest</span><span class="hl opt">() :</span> <span class="hl kwd">chooseOne</span><span class="hl opt">(</span><span class="hl str">&quot;Eenie, Meenie, Miney, Mo&quot;</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testUpper</span><span class="hl opt">() {</span>
    string upper <span class="hl opt">=</span> <span class="hl kwd">upperCase</span><span class="hl opt">(</span>chooseOne<span class="hl opt">);</span>
    <span class="hl kwb">const</span> string LOWER <span class="hl opt">=</span> <span class="hl str">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="hl opt">;</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>upper<span class="hl opt">.</span><span class="hl kwd">find_first_of</span><span class="hl opt">(</span>LOWER<span class="hl opt">) ==</span> string<span class="hl opt">::</span>npos<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testLower</span><span class="hl opt">() {</span>
    string lower <span class="hl opt">=</span> <span class="hl kwd">lowerCase</span><span class="hl opt">(</span>chooseOne<span class="hl opt">);</span>
    <span class="hl kwb">const</span> string UPPER <span class="hl opt">=</span> <span class="hl str">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="hl opt">;</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>lower<span class="hl opt">.</span><span class="hl kwd">find_first_of</span><span class="hl opt">(</span>UPPER<span class="hl opt">) ==</span> string<span class="hl opt">::</span>npos<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testSearch</span><span class="hl opt">() {</span>
    <span class="hl slc">// Case sensitive search</span>
    <span class="hl kwb">size_t</span> i <span class="hl opt">=</span> chooseOne<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;een&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">8</span><span class="hl opt">);</span>
    <span class="hl slc">// Search lowercase:</span>
    string test <span class="hl opt">=</span> <span class="hl kwd">lowerCase</span><span class="hl opt">(</span>chooseOne<span class="hl opt">);</span>
    i <span class="hl opt">=</span> test<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;een&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">);</span>
    i <span class="hl opt">=</span> test<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;een&quot;</span><span class="hl opt">, ++</span>i<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">8</span><span class="hl opt">);</span>
    i <span class="hl opt">=</span> test<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;een&quot;</span><span class="hl opt">, ++</span>i<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> string<span class="hl opt">::</span>npos<span class="hl opt">);</span>
    <span class="hl slc">// Search uppercase:</span>
    test <span class="hl opt">=</span> <span class="hl kwd">upperCase</span><span class="hl opt">(</span>chooseOne<span class="hl opt">);</span>
    i <span class="hl opt">=</span> test<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;EEN&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">);</span>
    i <span class="hl opt">=</span> test<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;EEN&quot;</span><span class="hl opt">, ++</span>i<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">8</span><span class="hl opt">);</span>
    i <span class="hl opt">=</span> test<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;EEN&quot;</span><span class="hl opt">, ++</span>i<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>i <span class="hl opt">==</span> string<span class="hl opt">::</span>npos<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwd">testUpper</span><span class="hl opt">();</span>
    <span class="hl kwd">testLower</span><span class="hl opt">();</span>
    <span class="hl kwd">testSearch</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// FIND_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.13. C03/Find.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp3845000"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Find.cpp</span>
<span class="hl slc">//{L} ../TestSuite/Test</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Find.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  FindTest t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> t<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.14. C03/Find.cpp</strong></p></div><br class="example-break" /><p>
      Tanto las funciones <code class="function">upperCase()</code> como
      <code class="function">lowerCase()</code> siguen la misma forma: hacen
      una copia de la cadena argumento y cambian entre
      mayúsculas/minúsculas. El programa Find.cpp no es la mejor
      solución para el problema para las mayúsculas/minúsculas, por lo
      que lo revisitaremos cuando examinemos la comparación entre
      cadenas.
    </p><div class="sect2" title="4.3.1. Busqueda inversa"><div class="titlepage"><div><div><h3 class="title"><a id="idp3847456"></a>4.3.1. Busqueda inversa</h3></div></div></div><p>
	Si necesita buscar en una cadena desde el final hasta el
	principio (para encontrar datos en orden <span class="emphasis"><em>"último
	entra / primero sale"</em></span>), puede usar la función
	miembro de <code class="classname">string</code>
	<code class="function">rfind()</code>.
      </p><div class="example"><a id="idp3848936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Rparse.h</span>
<span class="hl ppc">#ifndef RPARSE_H</span>
<span class="hl ppc">#define RPARSE_H</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>vector<span class="hl opt">;</span>

<span class="hl kwc">class</span> RparseTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
  <span class="hl slc">// To store the words:</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> strings<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">parseForData</span><span class="hl opt">() {</span>
    <span class="hl slc">// The ';' characters will be delimiters</span>
    string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;now.;sense;make;to;going;is;This&quot;</span><span class="hl opt">);</span>
    <span class="hl slc">// The last element of the string:</span>
    <span class="hl kwb">int</span> last <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span>
    <span class="hl slc">// The beginning of the current word:</span>
    <span class="hl kwb">size_t</span> current <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">rfind</span><span class="hl opt">(</span><span class="hl str">';'</span><span class="hl opt">);</span>
    <span class="hl slc">// Walk backward through the string:</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>current <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
      <span class="hl slc">// Push each word into the vector.</span>
      <span class="hl slc">// Current is incremented before copying</span>
      <span class="hl slc">// to avoid copying the delimiter:</span>
      <span class="hl opt">++</span>current<span class="hl opt">;</span>
      strings<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">substr</span><span class="hl opt">(</span>current<span class="hl opt">,</span> last <span class="hl opt">-</span> current<span class="hl opt">));</span>
      <span class="hl slc">// Back over the delimiter we just found,</span>
      <span class="hl slc">// and set last to the end of the next word:</span>
      current <span class="hl opt">-=</span> <span class="hl num">2</span><span class="hl opt">;</span>
      last <span class="hl opt">=</span> current <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl slc">// Find the next delimiter:</span>
      current <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">rfind</span><span class="hl opt">(</span><span class="hl str">';'</span><span class="hl opt">,</span> current<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Pick up the first word -- it's not</span>
    <span class="hl slc">// preceded by a delimiter:</span>
    strings<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">substr</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> last<span class="hl opt">));</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testData</span><span class="hl opt">() {</span>
    <span class="hl slc">// Test them in the new order:</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] ==</span> <span class="hl str">&quot;This&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] ==</span> <span class="hl str">&quot;is&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">] ==</span> <span class="hl str">&quot;going&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">] ==</span> <span class="hl str">&quot;to&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">] ==</span> <span class="hl str">&quot;make&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">] ==</span> <span class="hl str">&quot;sense&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>strings<span class="hl opt">[</span><span class="hl num">6</span><span class="hl opt">] ==</span> <span class="hl str">&quot;now.&quot;</span><span class="hl opt">);</span>
    string sentence<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> strings<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() -</span> <span class="hl num">1</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      sentence <span class="hl opt">+=</span> strings<span class="hl opt">[</span>i<span class="hl opt">] +=</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">;</span>
    <span class="hl slc">// Manually put last word in to avoid an extra space:</span>
    sentence <span class="hl opt">+=</span> strings<span class="hl opt">[</span>strings<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() -</span> <span class="hl num">1</span><span class="hl opt">];</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>sentence <span class="hl opt">==</span> <span class="hl str">&quot;This is going to make sense now.&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwd">parseForData</span><span class="hl opt">();</span>
    <span class="hl kwd">testData</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// RPARSE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.15. C03/Rparse.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp3853496"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Rparse.cpp</span>
<span class="hl slc">//{L} ../TestSuite/Test</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Rparse.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  RparseTest t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> t<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.16. C03/Rparse.cpp</strong></p></div><br class="example-break" /><p>
	La función miembro de <code class="classname">string</code>
	<code class="function">rfind()</code> vuelve por la cadena buscando
	elementos y reporta el indice del arreglo de las coincidencias
	de caracteres o
	<code class="classname">string::</code><code class="varname">npos</code> si no
	tiene éxito.
      </p></div><div class="sect2" title="4.3.2. Encontrar el primero/último de un conjunto de caracteres"><div class="titlepage"><div><div><h3 class="title"><a id="idp3855800"></a>4.3.2. Encontrar el primero/último de un conjunto de caracteres</h3></div></div></div><p>
	La función miembro <code class="function">find_first_of( )</code> y
	<code class="function">find_last_of( )</code> pueden ser
	convenientemente usadas para crear una pequeña utilidad the
	ayude a deshechar los espacion en blanco del final e inicio de
	la cadena. Nótese que no se toca el
	<code class="classname">string</code> originar sino que se devuelve
	una nuevo <code class="classname">string</code>:
      </p><div class="example"><a id="idp3857904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Trim.h</span>
<span class="hl slc">// General tool to strip spaces from both ends.</span>
<span class="hl ppc">#ifndef TRIM_H</span>
<span class="hl ppc">#define TRIM_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>

<span class="hl kwc">inline</span> std<span class="hl opt">::</span>string <span class="hl kwd">trim</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">() ==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">return</span> s<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> beg <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find_first_not_of</span><span class="hl opt">(</span><span class="hl str">&quot;</span> <span class="hl esc">\a\b\f\n\r\t\v</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> end <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find_last_not_of</span><span class="hl opt">(</span><span class="hl str">&quot;</span> <span class="hl esc">\a\b\f\n\r\t\v</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>beg <span class="hl opt">==</span> std<span class="hl opt">::</span>string<span class="hl opt">::</span>npos<span class="hl opt">)</span> <span class="hl slc">// No non-spaces</span>
    <span class="hl kwa">return</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> std<span class="hl opt">::</span><span class="hl kwd">string</span><span class="hl opt">(</span>s<span class="hl opt">,</span> beg<span class="hl opt">,</span> end <span class="hl opt">-</span> beg <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TRIM_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.17. C03/Trim.h</strong></p></div><br class="example-break" /><p>
	La primera prueba checkea si el string esta vacío; en ese
	caso, ya no se realizan más test, y se retorna una
	copia. Nótese que una vez los puntos del final son
	encontrados, el constructor de <code class="classname">string</code>
	construye un nuevo <code class="classname">string</code> desde el
	viejo, dándole  el contador incial y la longitud.
      </p><p>
	Las pruebas de una herramienta tan general den ser cuidadosas
      </p><div class="example"><a id="idp3861200"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:TrimTest.h</span>
<span class="hl ppc">#ifndef TRIMTEST_H</span>
<span class="hl ppc">#define TRIMTEST_H</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Trim.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> TrimTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span>NTESTS <span class="hl opt">=</span> <span class="hl num">11</span><span class="hl opt">};</span>
  <span class="hl kwb">static</span> std<span class="hl opt">::</span>string s<span class="hl opt">[</span>NTESTS<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">testTrim</span><span class="hl opt">() {</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;abcdefghijklmnop&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;abcdefghijklmnop&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;abcdefghijklmnop&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;ab&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;abc&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">6</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;a b c&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">7</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;a b c&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">8</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;a</span> <span class="hl esc">\t</span> <span class="hl str">b</span> <span class="hl esc">\t</span> <span class="hl str">c&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">9</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span><span class="hl kwd">trim</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">]) ==</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwd">testTrim</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TRIMTEST_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.18. C03/TrimTest.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp3862744"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:TrimTest.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TrimTest.h&quot;</span><span class="hl ppc"></span>

<span class="hl slc">// Initialize static data</span>
std<span class="hl opt">::</span>string TrimTest<span class="hl opt">::</span>s<span class="hl opt">[</span>TrimTest<span class="hl opt">::</span>NTESTS<span class="hl opt">] = {</span>
  <span class="hl str">&quot;</span> <span class="hl esc">\t</span> <span class="hl str">abcdefghijklmnop</span> <span class="hl esc">\t</span> <span class="hl str">&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;abcdefghijklmnop</span> <span class="hl esc">\t</span> <span class="hl str">&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;</span> <span class="hl esc">\t</span> <span class="hl str">abcdefghijklmnop&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;ab&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;abc&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;a b c&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;</span> <span class="hl esc">\t</span> <span class="hl str">a b c</span> <span class="hl esc">\t</span> <span class="hl str">&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;</span> <span class="hl esc">\t</span> <span class="hl str">a</span> <span class="hl esc">\t</span> <span class="hl str">b</span> <span class="hl esc">\t</span> <span class="hl str">c</span> <span class="hl esc">\t</span> <span class="hl str">&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;</span><span class="hl esc">\t \n \r \v \f</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;&quot;</span> <span class="hl slc">// Must also test the empty string</span>
<span class="hl opt">};</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.19. C03/TrimTest.cpp</strong></p></div><br class="example-break" /><div class="example"><a id="idp3863936"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:TrimTestMain.cpp</span>
<span class="hl slc">//{L} ../TestSuite/Test TrimTest</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TrimTest.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  TrimTest t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> t<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.20. C03/TrimTestMain.cpp</strong></p></div><br class="example-break" /><p>
	En el arrglo de <code class="classname">string</code>, puede ver que
	los arreglos de carácter son automáticamente convertidos a
	objetos <code class="classname">string</code>. Este arreglo provee
	casos para checkear el borrado de espacios en blanco y
	tabuladores en los extremos, además de asegurar que los
	espacios y tabuladores no son borrados de la mitad de un
	<code class="classname">string</code>.
      </p></div><div class="sect2" title="4.3.3. Borrar caracteres de cadenas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3866344"></a>4.3.3. Borrar caracteres de cadenas </h3></div></div></div><p>
	Borrar caracteres es fácil y eficiente con la función miembro
	<code class="function">erase()</code>, que toma dos argumentos: donde
	empezar a borrar caracteres (que por defecto es 0), y cuantos
	caracteres borrar (que por defecto es
	<code class="classname">string::</code><code class="varname">npos</code>). Si
	especifica más caracteres que los que quedan en el string, los
	caracteres restantes se borran igualmente (llamando
	<code class="function">erase()</code> sin argumentos borra todos los
	caracteres del <code class="classname">string</code>). A veces es útil
	abrir un fichero HTML y borrar sus etiquetas y caracteres
	especiales de manera que tengamos algo aproximadamente igual
	al texto que obtendríamos en el navegador Web, sólo como un
	fichero de texto plano. El siguiente ejemplo usa
	<code class="function">erase()</code> para hacer el trabajo:
      </p><div class="example"><a id="idp3869504"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:HTMLStripper.cpp {RunByHand}</span>
<span class="hl slc">//{L} ReplaceAll</span>
<span class="hl slc">// Filter to remove html tags and markers.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ReplaceAll.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

string<span class="hl opt">&amp;</span> <span class="hl kwd">stripHTMLTags</span><span class="hl opt">(</span>string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwb">static bool</span> inTag <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">bool</span> done <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(!</span>done<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>inTag<span class="hl opt">) {</span>
      <span class="hl slc">// The previous line started an HTML tag</span>
      <span class="hl slc">// but didn't finish. Must search for '&gt;'.</span>
      <span class="hl kwb">size_t</span> rightPos <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'&gt;'</span><span class="hl opt">);</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>rightPos <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
        inTag <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
        s<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> rightPos <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else</span> <span class="hl opt">{</span>
        done <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        s<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">else</span> <span class="hl opt">{</span>
      <span class="hl slc">// Look for start of tag:</span>
      <span class="hl kwb">size_t</span> leftPos <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'&lt;'</span><span class="hl opt">);</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>leftPos <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
        <span class="hl slc">// See if tag close is in this line:</span>
        <span class="hl kwb">size_t</span> rightPos <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'&gt;'</span><span class="hl opt">);</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>rightPos <span class="hl opt">==</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
          inTag <span class="hl opt">=</span> done <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
          s<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(</span>leftPos<span class="hl opt">);</span>
        <span class="hl opt">}</span>
        <span class="hl kwa">else</span>
          s<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(</span>leftPos<span class="hl opt">,</span> rightPos <span class="hl opt">-</span> leftPos <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else</span>
        done <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Remove all special HTML characters</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;lt;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&lt;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;gt;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&gt;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;amp;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&amp;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;nbsp;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Etc...</span>
  <span class="hl kwa">return</span> s<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span>
    <span class="hl str">&quot;usage: HTMLStripper InputFile&quot;</span><span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  string s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> s<span class="hl opt">))</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span><span class="hl kwd">stripHTMLTags</span><span class="hl opt">(</span>s<span class="hl opt">).</span><span class="hl kwd">empty</span><span class="hl opt">())</span>
      cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.21. C03/HTMLStripper.cpp</strong></p></div><br class="example-break" /><p>
	Este ejemplo borrará incluso las etiquetas HTML que se
	extienden a lo largo de varias líneas.<sup>[<a id="idp3872432" href="#ftn.idp3872432" class="footnote">5</a>]</sup> Esto se cumple gracias a la
	bandera estática <code class="varname">inTag</code>, que evalúa a cierto
	si el principio de una etiqueta es encontrada, pero la
	etiqueta de finalización correspondiente no es encontrada en
	la misma línea. Todas la formas de
	<code class="function">erase()</code> aparecen en la función
	<code class="function">stripHTMLFlags()</code>.<sup>[<a id="idp3874320" href="#ftn.idp3874320" class="footnote">6</a>]</sup> La
	versión de <code class="function">getline()</code> que usamos aquí es
	una función (global) declarada en la cabecera de
	<code class="classname">string</code> y es útil porque guarda una
	línea arbitrariamente larga en su argumento
	<code class="classname">string</code>. No necesita preocuparse de las
	dimensiones de un arreglo cuando trabaja con
	<code class="classname">istream::</code><code class="function">getline()</code>. Nótese
	que este programa usa la función
	<code class="function">replaceAll()</code> vista antes en este
	capítulo. En el póximo capitulo, usaremos los flujos de cadena
	para crear una solución más elegante.
      </p></div><div class="sect2" title="4.3.4. Comparar cadenas"><div class="titlepage"><div><div><h3 class="title"><a id="idp3878112"></a>4.3.4. Comparar cadenas </h3></div></div></div><p>
	Comparar cadenas es inherentemente diferente a comparar
	enteros. Los nombres tienen un significado universal y
	constante. Para evaluar la relación entre las magnitudes de
	dos cadenas, se necesita hacer una comparación léxica. Una
	comparación léxica significa que cuando se comprueba un
	carácter para saber si es <span class="emphasis"><em>"mayor que"</em></span> o
	<span class="emphasis"><em>"menor que"</em></span> otro carácter, está en
	realidad comparando la representación numérica de aquellos
	caracteres tal como están especificados en el orden del
	conjunto de caracteres que está siendo usado. La ordenación
	más habitual suele ser la secuencia ASCII, que asigna a los
	caracteres imprimibles para el lenguaje inglés números en un
	rango del 32 al 127 decimal. En la codificación ASCII, el
	primer <span class="emphasis"><em>"carácter"</em></span> en la lista es el
	espacio, seguido de diversas marcas de puntuación común, y
	después las letras mayúsculas y minúsculas. Respecto al
	alfabeto, esto significa que las letras cercanas al principio
	tienen un valor ASCII menor a aquellos más cercanos al
	final. Con estos detalles en mente, se vuelve más fácil
	recordar que cuando una comparació léxica reporta que
	<code class="varname">s1</code> es <span class="emphasis"><em>"mayor que"</em></span>
	<code class="varname">s2</code>, simplemente significa que cuando fueron
	comparados, el primer carácter diferente en
	<code class="varname">s1</code> estaba atrás en el alfabeto que el
	carácter en la misma posición en <code class="varname">s2</code>.
      </p><p>
	C++ provee varias maneras de comparar cadenas, y cada una
	tiene ventajas. La más simple de usar son las funciones
	no-miembro sobrecargadas de operador:
	<code class="function">operator==</code>,
	<code class="function">operator!=</code>
	<code class="function">operator&gt;</code>,
	<code class="function">operator&lt;</code>,
	<code class="function">operator&gt;=</code> y
	<code class="function">operator&lt;=</code>.
      </p><div class="example"><a id="idp3884912"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:CompStr.h</span>
<span class="hl ppc">#ifndef COMPSTR_H</span>
<span class="hl ppc">#define COMPSTR_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../TestSuite/Test.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>

<span class="hl kwc">class</span> CompStrTest <span class="hl opt">:</span> <span class="hl kwc">public</span> TestSuite<span class="hl opt">::</span>Test <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl slc">// Strings to compare</span>
    string <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;This&quot;</span><span class="hl opt">);</span>
    string <span class="hl kwd">s2</span><span class="hl opt">(</span><span class="hl str">&quot;That&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">==</span> s1<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">!=</span> s2<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">&gt;</span> s2<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">&gt;=</span> s2<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">&gt;=</span> s1<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s2 <span class="hl opt">&lt;</span> s1<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s2 <span class="hl opt">&lt;=</span> s1<span class="hl opt">);</span>
    <span class="hl kwd">test_</span><span class="hl opt">(</span>s1 <span class="hl opt">&lt;=</span> s1<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// COMPSTR_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.22. C03/CompStr.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp3886544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:CompStr.cpp</span>
<span class="hl slc">//{L} ../TestSuite/Test</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CompStr.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CompStrTest t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> t<span class="hl opt">.</span><span class="hl kwd">report</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.23. C03/CompStr.cpp</strong></p></div><br class="example-break" /><p>
	Los operadores de comaración sobrecargados son útiles para
	comparar dos cadenas completas y elementos individuales de una
	cadena de caracteres.
      </p><p>
	Nótese en el siguiente ejemplo la flexibilidad de los tipos de
	argumento ambos lados de los operadores de comparación. Por
	eficiencia, la clase <code class="classname">string</code> provee
	operadores sobrecargados para la comparación directa de
	objetos <code class="classname">string</code>, literales de cadena, y
	punteros a cadenas estilo C sin tener que crear objetos
	<code class="classname">string</code> temporales.
      </p><div class="example"><a id="idp3889368"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Equivalence.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s2</span><span class="hl opt">(</span><span class="hl str">&quot;That&quot;</span><span class="hl opt">),</span> <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;This&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// The lvalue is a quoted literal</span>
  <span class="hl slc">// and the rvalue is a string:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl str">&quot;That&quot;</span> <span class="hl opt">==</span> s2<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;A match&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// The left operand is a string and the right is</span>
  <span class="hl slc">// a pointer to a C-style null terminated string:</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>s1 <span class="hl opt">!=</span> s2<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;No match&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.24. C03/Equivalence.cpp</strong></p></div><br class="example-break" /><p>
	La función <code class="function">c_str()</code> retorna un <code class="type">const
	char*</code> que apunta a una cadena estilo C terminada en
	nulo, equivalente en contenidos al objeto
	<code class="classname">string</code>. Esto se vuelve muy útil cuando
	se quiere pasar un strin a una función C, como atoi() o
	cualquiera de las funciones definidas en la cabecera
	<span class="emphasis"><em>cstring</em></span>. Es un error usar el valor
	retornado por <code class="varname">c_str()</code> como un argumento
	constante en cualquier función.
      </p><p>
	No encontrará el operador <span class="emphasis"><em>not</em></span>
	(<code class="function">!</code>) o los operadores de comparación
	lógicos (<code class="function">&amp;&amp;</code> y
	<code class="function">||</code>) entre los operadore para
	<code class="classname">string</code>. (No encontrará ninguna versión
	sobrecargada de los operadores de bits de C: &amp;, |, ^, o
	~.) Los operadores de conversión no miembros sobrecargados
	para la clases <code class="classname">string</code> están limitados a
	un subconjunto que tiene una aplicación clara y no ambigua
	para caracteres individuales o grupos de caracteres.
      </p><p>
	La función miembro <code class="function">compare()</code> le ofrece un
	gran modo de comparación más sofisticado y preciso que el
	conjunto de operadores nomiembro. Provee versiones
	sobrecargadas para comparar:
      </p><p>
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Dos <code class="classname">string</code> completos</p></li><li class="listitem"><p>Parte de un <code class="classname">string</code> con un <code class="classname">string</code> completo</p></li><li class="listitem"><p>Partes de dos <code class="classname">string</code></p></li></ul></div><p>
      </p><div class="example"><a id="idp3898448"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Compare.cpp</span>
<span class="hl slc">// Demonstrates compare() and swap().</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">first</span><span class="hl opt">(</span><span class="hl str">&quot;This&quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">second</span><span class="hl opt">(</span><span class="hl str">&quot;That&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>first<span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>second<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>second<span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Which is lexically greater?</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>second<span class="hl opt">) &gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>second<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>first<span class="hl opt">) &lt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
  first<span class="hl opt">.</span><span class="hl kwd">swap</span><span class="hl opt">(</span>second<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>second<span class="hl opt">) &lt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>second<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>first<span class="hl opt">) &gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.25. C03/Compare.cpp</strong></p></div><br class="example-break" /><p>
      La función <code class="function">swap()</code> en este ejemplo hace lo
      que su nombre implica: cambia el contenido del objeto por el del
      parámetro. Para comparar un subconjunto de caracteres en un o
      ambos <code class="classname">string</code>, añada argumentos que
      definen donde empezar y cuantos caracteres considerar. Por
      ejemplo, puede usar las siguientes versiones sobrecargadas de
      <code class="function">compare()</code>:
    </p><p>
      <code class="code">s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos,
      s2NumberChars);</code>
    </p><p>
      Aqui un ejemplo:
    </p><div class="example"><a id="idp3902440"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:Compare2.cpp</span>
<span class="hl slc">// Illustrate overloaded compare().</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">first</span><span class="hl opt">(</span><span class="hl str">&quot;This is a day that will live in infamy&quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">second</span><span class="hl opt">(</span><span class="hl str">&quot;I don't believe that this is what &quot;</span>
                <span class="hl str">&quot;I signed up for&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Compare &quot;his is&quot; in both strings:</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> second<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Compare &quot;his is a&quot; to &quot;his is w&quot;:</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">,</span> second<span class="hl opt">,</span> <span class="hl num">22</span><span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">) &lt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.26. C03/Compare2.cpp</strong></p></div><br class="example-break" /><p>
      Hasta ahora, en los ejemplos, hemos usado la sintaxis de
      indexación de arrays estilo C para referirnos a un carácter
      individual en un <code class="classname">string</code>. C++ provee de
      una alternativa a la notación <code class="code">s[n]</code>: el miembro
      <code class="function">at()</code>. Estos dos mecanismos de indexación
      producen los mismos resultados si todo va bien:
    </p><div class="example"><a id="idp3905816"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:StringIndexing.cpp</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;1234&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] ==</span> <span class="hl str">'2'</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">at</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">) ==</span> <span class="hl str">'2'</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.27. C03/StringIndexing.cpp</strong></p></div><br class="example-break" /><p>
      Sin embargo, existe una importante diferencia entre <code class="function">[
	]</code> y <code class="function">at() </code>. Cuando usted intenta
      referenciar el elemento de un arreglo que esta fuera de sus
      límites, <code class="function">at()</code> tiene la delicadeza de lanzar
      una excepción, mientras que ordinariamente <code class="function">[
	]</code> le dejará a su suerte.
    </p><div class="example"><a id="idp3909040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:BadStringIndexing.cpp</span>
<span class="hl ppc">#include &lt;exception&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;1234&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// at() saves you by throwing an exception:</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    s<span class="hl opt">.</span><span class="hl kwd">at</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.28. C03/BadStringIndexing.cpp</strong></p></div><br class="example-break" /><p>
      Los programadores responsables no usarán índices erráticos, pero
      puede que quiera beneficiarse de la comprobación automática de
      indices, usando<code class="function">at()</code> en el lugar de
      <code class="function">[ ]</code> le da la oportunidad de recuperar
      diligentemente de las referencias a elementos de un arreglo que
      no existen. La ejecución de sobre uno de nuestros compiladores
      le da la siguiente salida: <span class="foreignphrase"><em class="foreignphrase">"invalid string
      position"</em></span>
    </p><p>
      La función miembro <code class="function">at()</code> lanza un objeto de
      clase <code class="classname">out_of_class</code>, que deriva finalmente
      de<code class="classname"> std::exception</code>. Capturando este objeto
      en un manejador de excepciones, puede tomar las medidas
      adecuadas como recalcular el índice incorrecto o hacer crecer el
      arreglo. Usar
      <code class="classname">string::</code><code class="function">operator[](
	)</code>  no proporciona ningún tipo de protección y es tan
      peligroso como el procesado de arreglos de caracteres en C.[37]
      <sup>[<a id="idp3914232" href="#ftn.idp3914232" class="footnote">7</a>]</sup>
    </p></div><div class="sect2" title="4.3.5. Cadenas y rasgos de caracteres"><div class="titlepage"><div><div><h3 class="title"><a id="idp3916040"></a>4.3.5. Cadenas y rasgos de caracteres</h3></div></div></div><p>
	El programa <span class="emphasis"><em>Find.cpp</em></span> anterior en este
	capítulo nos lleva a hacernos la pregunta obvia: ¿por que la
	comparación sensible a mayúsculas/minúsculas no es parte de la
	clase estándar <code class="classname">string</code>? La respuesta nos
	brinda un interesante transfondo sobre la verdadera naturaleza
	de los objetos <code class="classname">string</code> en C++.
      </p><p>
	Considere qué significa para un carácter tener
	"mayúscula/minúscula". El Hebreo escrito, el Farsi, y el Kanji
	no usan el concepto de "mayúscula/minúscula", con lo que para
	esas lenguas esta idea carece de significado. Esto daria a
	entender que si existiera una manera de designar algunos
	lenguages como "todo mayúsculas" o "todo minúsculas",
	podriamos diseñar una solución generalizada. Sin embargo,
	algunos leguajes que emplean el concepto de
	"mayúscula/minúscula", tambien cambian el significado de
	caracteres particulares con acentos diacríticos, por ejemplo
	la cedilla del Español, el circumflexo en Francés y la
	diéresis en Alemán. Por esta razón, cualquier codificación
	sensible a mayúsculas que intenta ser comprensiva acaba siendo
	una pesadilla en su uso.
      </p><p>
	Aunque tratamos habitualmente el <code class="classname">string</code>
	de C++ como una clase, esto no es del todo cierto. El tipo
	<code class="classname">string</code> es una especialización de algo
	más general, la plantilla <code class="classname">basic_string&lt;
	&gt;</code>. Observe como está declarada
	<code class="classname">string</code> en el fichero de cabecera de C++
	estándar.
      </p><p>
	<code class="code">typedef basic_string&lt;char&gt; string;</code>
      </p><p>
	Para comprender la naturaleza de la clase
	<code class="classname">string</code>, mire la plantilla
	<code class="classname">basic_string&lt; &gt;</code>

      </p><p>
	<code class="code">
	  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
	  class allocator = allocator&lt;charT&gt; &gt; class basic_string;
	</code>
      </p><p>
	En el Capítulo 5, examinamos las plantillas con gran detalle
	(mucho más que en el Capítulo 16 del volúmen  1). Por ahora
	nótese que el tipo <code class="classname">string</code> es creada
	cuando instanciamos la plantilla
	<code class="classname">basic_string</code> con
	<code class="type">char</code>. Dentro de la declaración plantilla
	<code class="classname">basic_string&lt; &gt;</code> la línea:
      </p><p>
			<code class="code">class traits = char_traits&lt;charT&lt;</code>,
      </p><p>
	nos dice que el comportamiento de la clase hecha a partir de
	<code class="classname">basic_string&lt; &gt;</code> es defineida por
	una clase basada en la plantilla <code class="classname">char_traits&lt;
	&gt;</code>. Así, la plantilla
	<code class="classname">basic_string&lt; &gt;</code> produce clases
	orientadas a <code class="classname">string</code> que manipulan otros
	tipos que <code class="type">char</code> (caracteres anchos, por
	ejemplo). Para hacer esto, la plantilla
	<code class="classname">char_traits&lt; &gt;</code> controla el
	contenido y el comportamiento de la ordenación de una variedad
	de conjuntos de caracteres usando las funciones de comparación
	<code class="function">eq()</code>
	(<span class="foreignphrase"><em class="foreignphrase">equal</em></span>),
	<code class="function">ne()</code> (<span class="foreignphrase"><em class="foreignphrase">not
	equal</em></span>), y <code class="function">lt()</code>
	(<span class="foreignphrase"><em class="foreignphrase">less than</em></span>). Las funciones de
	comparación de <code class="classname">basic_string&lt; &gt;</code>
	confian en esto.
      </p><p>
	Es por esto por lo que la clase string no incluye funciones
	miembro sensibles a mayúsculas/minúsculas: eso no esta en la
	descripción de su trabajo. Para cambiar la forma en que la
	clase string trata la comparación de caracteres, tiene que
	suministrar una plantilla <code class="classname">char_traits&lt;
	&gt;</code> diferente ya que define el comportamiento
	individual de las funciones miembro de comparación carácteres.
      </p><p>
	Puede usar esta información para hacer un nuevo tipo de
	<code class="classname">string</code> que ignora las
	mayúsculas/minúsculas. Primero, definiremos una nueva
	plantilla no sensible a mayúsculas/minúsculas de
	<code class="classname">char_traits&lt; &gt;</code> que hereda de una
	plantilla existente. Luego, sobrescribiremos sólo los miembros
	que necesitamos cambiar para hacer la comparación carácter por
	carácter. (Además de los tres miembros de comparación léxica
	mencionados antes, daremos una nueva implementación para
	laspara las funciones de <code class="classname">char_traits</code>
	<code class="classname">find()</code> y
	<code class="classname">compare()</code>). Finalmente, haremos un
	<code class="code">typedef</code> de una nueva clase basada en
	<code class="classname">basic_string</code>, pero usando nuestra
	plantilla insensible a mayúsculas/minúsculas,
	<code class="classname">ichar_traits</code>, como segundo argumento:
      </p><div class="example"><a id="idp3932248"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ichar_traits.h</span>
<span class="hl slc">// Creating your own character traits.</span>
<span class="hl ppc">#ifndef ICHAR_TRAITS_H</span>
<span class="hl ppc">#define ICHAR_TRAITS_H</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;ostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>allocator<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>basic_string<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>char_traits<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>ostream<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>toupper<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>tolower<span class="hl opt">;</span>

<span class="hl kwb">struct</span> ichar_traits <span class="hl opt">:</span> char_traits<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt; {</span>
  <span class="hl slc">// We'll only change character-by-</span>
  <span class="hl slc">// character comparison functions</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">eq</span><span class="hl opt">(</span><span class="hl kwb">char</span> c1st<span class="hl opt">,</span> <span class="hl kwb">char</span> c2nd<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>c1st<span class="hl opt">) ==</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>c2nd<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">ne</span><span class="hl opt">(</span><span class="hl kwb">char</span> c1st<span class="hl opt">,</span> <span class="hl kwb">char</span> c2nd<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl opt">!</span><span class="hl kwd">eq</span><span class="hl opt">(</span>c1st<span class="hl opt">,</span> c2nd<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">lt</span><span class="hl opt">(</span><span class="hl kwb">char</span> c1st<span class="hl opt">,</span> <span class="hl kwb">char</span> c2nd<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>c1st<span class="hl opt">) &lt;</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>c2nd<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static int</span>
  <span class="hl kwd">compare</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> str1<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> str2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> n<span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>str1 <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
        <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span>str2 <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
        <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span><span class="hl kwd">tolower</span><span class="hl opt">(*</span>str1<span class="hl opt">) &lt;</span> <span class="hl kwd">tolower</span><span class="hl opt">(*</span>str2<span class="hl opt">))</span>
        <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span><span class="hl kwd">tolower</span><span class="hl opt">(*</span>str1<span class="hl opt">) &gt;</span> <span class="hl kwd">tolower</span><span class="hl opt">(*</span>str2<span class="hl opt">))</span>
        <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">tolower</span><span class="hl opt">(*</span>str1<span class="hl opt">) ==</span> <span class="hl kwd">tolower</span><span class="hl opt">(*</span>str2<span class="hl opt">));</span>
      <span class="hl opt">++</span>str1<span class="hl opt">; ++</span>str2<span class="hl opt">;</span> <span class="hl slc">// Compare the other chars</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static const char</span><span class="hl opt">*</span>
  <span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> s1<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">,</span> <span class="hl kwb">char</span> c<span class="hl opt">) {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>n<span class="hl opt">-- &gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">toupper</span><span class="hl opt">(*</span>s1<span class="hl opt">) ==</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>c<span class="hl opt">))</span>
        <span class="hl kwa">return</span> s1<span class="hl opt">;</span>
      <span class="hl kwa">else</span>
        <span class="hl opt">++</span>s1<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> basic_string<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">,</span> ichar_traits<span class="hl opt">&gt;</span> istring<span class="hl opt">;</span>

<span class="hl kwc">inline</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> istring<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">string</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">());</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// ICHAR_TRAITS_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.29. C03/ichar_traits.h</strong></p></div><br class="example-break" /><p>
	Proporcionamos un <code class="code">typedef</code> llamado
	<code class="classname">istring</code> ya que nuestra clase actuará
	como un <code class="classname">string</code> ordinario en todas sus
	formas, excepto que realizará todas las comparaciones sin
	respetar las mayúsculas/minúsculas. Por conveniencia, damos un
	operador sobrecargado <code class="function">operator&lt;&lt;()</code>
	para que pueda imprimir los
	<code class="classname">istring</code>. Aque hay un ejemplo:
      </p><div class="example"><a id="idp3936976"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ICompare.cpp</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ichar_traits.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// The same letters except for case:</span>
  istring first <span class="hl opt">=</span> <span class="hl str">&quot;tHis&quot;</span><span class="hl opt">;</span>
  istring second <span class="hl opt">=</span> <span class="hl str">&quot;ThIS&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> first <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> second <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>second<span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'h'</span><span class="hl opt">) ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'I'</span><span class="hl opt">) ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>first<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'x'</span><span class="hl opt">) ==</span> string<span class="hl opt">::</span>npos<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.30. C03/ICompare.cpp</strong></p></div><br class="example-break" /><p>
	Este es solo un ejemplo de prueba. Para hacer
	<code class="classname">istring</code> completamente equivalente a un
	<code class="classname">string</code>, deberiamos haber creado las
	otras funciones necesarias para soportar el nuevo tipo
	<code class="classname">istring</code>.
      </p><p>
	La cabecera <span class="emphasis"><em>&lt;string&gt;</em></span> provee de un
	<code class="classname">string</code> ancho <sup>[<a id="idp3939776" href="#ftn.idp3939776" class="footnote">8</a>]</sup> gracias
	al siguiente <code class="code">typedef</code>:
      </p><p>
	<code class="code">typedef basic_string&lt;wchar_t&gt; wstring;</code>
      </p><p>
	El soporte para <code class="classname">string</code> ancho se revela
	tambien en los <code class="classname">streams</code> anchos
	(<code class="classname">wostream</code> en lugar de
	<code class="classname">ostream</code>, tambien definido en
	<code class="code">&lt;iostream&gt;</code>) y en la especialización de
	<code class="type">wchar_t</code> de los <code class="classname">char_traits</code>
	en la libreria estándar le da la posibilidad de hacer una
	version de carácter ancho de
	<code class="classname">ichar_traits</code>
      </p><div class="example"><a id="idp3943928"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:iwchar_traits.h {-g++}</span>
<span class="hl slc">// Creating your own wide-character traits.</span>
<span class="hl ppc">#ifndef IWCHAR_TRAITS_H</span>
<span class="hl ppc">#define IWCHAR_TRAITS_H</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cwctype&gt;</span>
<span class="hl ppc">#include &lt;ostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>

<span class="hl kwa">using</span> std<span class="hl opt">::</span>allocator<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>basic_string<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>char_traits<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>towlower<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>towupper<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>wostream<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>wstring<span class="hl opt">;</span>

<span class="hl kwb">struct</span> iwchar_traits <span class="hl opt">:</span> char_traits<span class="hl opt">&lt;</span><span class="hl kwb">wchar_t</span><span class="hl opt">&gt; {</span>
  <span class="hl slc">// We'll only change character-by-</span>
  <span class="hl slc">// character comparison functions</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">eq</span><span class="hl opt">(</span><span class="hl kwb">wchar_t</span> c1st<span class="hl opt">,</span> <span class="hl kwb">wchar_t</span> c2nd<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c1st<span class="hl opt">) ==</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c2nd<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">ne</span><span class="hl opt">(</span><span class="hl kwb">wchar_t</span> c1st<span class="hl opt">,</span> <span class="hl kwb">wchar_t</span> c2nd<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c1st<span class="hl opt">) !=</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c2nd<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">lt</span><span class="hl opt">(</span><span class="hl kwb">wchar_t</span> c1st<span class="hl opt">,</span> <span class="hl kwb">wchar_t</span> c2nd<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c1st<span class="hl opt">) &lt;</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c2nd<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">compare</span><span class="hl opt">(</span>
    <span class="hl kwb">const wchar_t</span><span class="hl opt">*</span> str1<span class="hl opt">,</span> <span class="hl kwb">const wchar_t</span><span class="hl opt">*</span> str2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> n<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>str1 <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
        <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span>str2 <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span>
        <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span><span class="hl kwd">towlower</span><span class="hl opt">(*</span>str1<span class="hl opt">) &lt;</span> <span class="hl kwd">towlower</span><span class="hl opt">(*</span>str2<span class="hl opt">))</span>
        <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span><span class="hl kwd">towlower</span><span class="hl opt">(*</span>str1<span class="hl opt">) &gt;</span> <span class="hl kwd">towlower</span><span class="hl opt">(*</span>str2<span class="hl opt">))</span>
        <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">towlower</span><span class="hl opt">(*</span>str1<span class="hl opt">) ==</span> <span class="hl kwd">towlower</span><span class="hl opt">(*</span>str2<span class="hl opt">));</span>
      <span class="hl opt">++</span>str1<span class="hl opt">; ++</span>str2<span class="hl opt">;</span> <span class="hl slc">// Compare the other wchar_ts</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">static const wchar_t</span><span class="hl opt">*</span>
  <span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl kwb">const wchar_t</span><span class="hl opt">*</span> s1<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">,</span> <span class="hl kwb">wchar_t</span> c<span class="hl opt">) {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>n<span class="hl opt">-- &gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">towupper</span><span class="hl opt">(*</span>s1<span class="hl opt">) ==</span> <span class="hl kwd">towupper</span><span class="hl opt">(</span>c<span class="hl opt">))</span>
        <span class="hl kwa">return</span> s1<span class="hl opt">;</span>
      <span class="hl kwa">else</span>
        <span class="hl opt">++</span>s1<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> basic_string<span class="hl opt">&lt;</span><span class="hl kwb">wchar_t</span><span class="hl opt">,</span> iwchar_traits<span class="hl opt">&gt;</span> iwstring<span class="hl opt">;</span>

<span class="hl kwc">inline</span> wostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>wostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span>
  <span class="hl kwb">const</span> iwstring<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">wstring</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">());</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// IWCHAR_TRAITS_H  ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 4.31. C03/iwchar_traits.h</strong></p></div><br class="example-break" /><p>
	Como puede ver, esto es principalmente un ejercicio de poner
	<span class="emphasis"><em>'w'</em></span> en el lugar adecuado del código
	fuente. El programa de prueba podria ser asi:
      </p><div class="example"><a id="idp3947656"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:IWCompare.cpp {-g++}</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;iwchar_traits.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// The same letters except for case:</span>
  iwstring wfirst <span class="hl opt">=</span> L<span class="hl str">&quot;tHis&quot;</span><span class="hl opt">;</span>
  iwstring wsecond <span class="hl opt">=</span> L<span class="hl str">&quot;ThIS&quot;</span><span class="hl opt">;</span>
  wcout <span class="hl opt">&lt;&lt;</span> wfirst <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  wcout <span class="hl opt">&lt;&lt;</span> wsecond <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>wfirst<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span>wsecond<span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>wfirst<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'h'</span><span class="hl opt">) ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>wfirst<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'I'</span><span class="hl opt">) ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>wfirst<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'x'</span><span class="hl opt">) ==</span> wstring<span class="hl opt">::</span>npos<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.32. C03/IWCompare.cpp</strong></p></div><br class="example-break" /><p>
	Desgraciadamente, todavia algunos compiladores siguen sin
	ofrecer un soporte robusto para caracteres anchos.
      </p></div></div><div class="sect1" title="4.4. Una aplicación con cadenas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3949480"></a>4.4. Una aplicación con cadenas</h2></div></div></div><p>
      Si ha observado atentamente los códigos de ejemplo de este
      libro, habrá observado que ciertos elementos en los comentarios
      envuelven el código. Son usados por un programa en Python que
      escribió Bruce para extraer el código en ficheros y configurar
      makefiles para construir el código. Por ejemplo, una doble barra
      segida de dos puntos en el comienzo de una línea denota la
      primera línea de un fichero de código . El resto de la línea
      contiene información describiendo el nombre del fichero y su
      locaización y cuando deberia ser solo compilado en vez
      constituir un fichero ejecutable. Por ejemplo, la primera línea
      del programa anterior contiene la cadena
      <span class="emphasis"><em>C03:IWCompare.cpp</em></span>, indicando que el fichero
      <span class="emphasis"><em>IWCompare.cpp</em></span> deberia ser extraido en el
      directorio C03.
    </p><p>
      La última línea del fichero fuente contiene una triple barra
      seguida de dos puntos y un signo "~". Es la primera línea tiene
      una exclamación inmediatamente después de los dos puntos, la
      primera y la última línea del código fuente no son para ser
      extraídas en un fichero (solo es para ficheros solo de
      datos). (Si se está preguntando por que evitamos mostrar estos
      elementos, es por que no queremos romper el extractor de código
      cuando lo aplicamos al texto del libro!).
    </p><p>
      El programa en Python de Bruce hace muchas más cosas que
      simplemente extraer el código. Si el elemento
      <span class="emphasis"><em>"{O}"</em></span> sigue al nombre del fichero, su
      entrada en el makefile solo será configurada para compilar y no
      para enlazarla en un ejecutable. (El Test Framework en el
      Capítulo 2 está contruida de esta manera). Para enlazar un
      fichero con otro fuente de ejemplo, el fichero fuente del
      ejecutable objetivo contendrá una directiva
      <span class="emphasis"><em>"{L}"</em></span>, como aquí:
    </p><p>
      <code class="code">//{L} ../TestSuite/Test</code>
    </p><p>
      Esta sección le presentará un programa para extraer todo el
      código para que pueda compilarlo e inspeccionarlo
      manualmente. Puede usar este programa para extraer todo el
      codigo de este libro salvando el fichero como un fichero de
      texto<sup>[<a id="idp3955592" href="#ftn.idp3955592" class="footnote">9</a>]</sup> (llamémosle TICV2.txt)y
      ejecutando algo como la siguiente línea de comandos: <code class="code">C:&gt;
      extractCode TICV2.txt /TheCode</code>
    </p><p>
      Este comando lee el fichero de texto TICV2.txt y escribe todos
      los archivos de código fuente en subdirectorios bajo el definido
      <span class="emphasis"><em>/TheCode</em></span>. El arbol de directorios se
      mostrará como sigue:
    </p><p>
    <code class="code">TheCode/
    C0B/
    C01/
    C02/
    C03/
    C04/
    C05/
    C06/
    C07/
    C08/
    C09/
    C10/
    C11/
    TestSuite/</code>
    </p><p>
      Los ficheros de código fuente que contienen los ejemplos de cada
      capítulo estarán en el correspondiente directorio.
    </p><p>
      Aquí está el programa:
    </p><div class="example"><a id="idp3959144"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C03:ExtractCode.cpp {-edg} {RunByHand}</span>
<span class="hl slc">// Extracts code from text.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Legacy non-standard C header for mkdir()</span>
<span class="hl ppc">#if defined(__GNUC__) || defined(__MWERKS__)</span>
<span class="hl ppc">#include &lt;sys/stat.h&gt;</span>
<span class="hl ppc">#elif defined(__BORLANDC__) || defined(_MSC_VER) \</span>
<span class="hl ppc">  || defined(__DMC__)</span>
<span class="hl ppc">#include &lt;direct.h&gt;</span>
<span class="hl ppc">#else</span>
<span class="hl ppc">#error Compiler not supported</span>
<span class="hl ppc">#endif</span>

<span class="hl slc">// Check to see if directory exists</span>
<span class="hl slc">// by attempting to open a new file</span>
<span class="hl slc">// for output within it.</span>
<span class="hl kwb">bool</span> <span class="hl kwd">exists</span><span class="hl opt">(</span>string fname<span class="hl opt">) {</span>
  <span class="hl kwb">size_t</span> len <span class="hl opt">=</span> fname<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">();</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>fname<span class="hl opt">[</span>len<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">] !=</span> <span class="hl str">'/'</span> <span class="hl opt">&amp;&amp;</span> fname<span class="hl opt">[</span>len<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">] !=</span> <span class="hl str">'</span><span class="hl esc">\\</span><span class="hl str">'</span><span class="hl opt">)</span>
    fname<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl str">&quot;/&quot;</span><span class="hl opt">);</span>
  fname<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl str">&quot;000.tmp&quot;</span><span class="hl opt">);</span>
  ofstream <span class="hl kwd">outf</span><span class="hl opt">(</span>fname<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwb">bool</span> existFlag <span class="hl opt">=</span> outf<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>outf<span class="hl opt">) {</span>
    outf<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
    <span class="hl kwd">remove</span><span class="hl opt">(</span>fname<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> existFlag<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl slc">// See if input file name provided</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;usage: extractCode file [dir]&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// See if input file exists</span>
  ifstream <span class="hl kwd">inf</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>inf<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;error opening file: &quot;</span> <span class="hl opt">&lt;&lt;</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Check for optional output directory</span>
  string <span class="hl kwd">root</span><span class="hl opt">(</span><span class="hl str">&quot;./&quot;</span><span class="hl opt">);</span>  <span class="hl slc">// current is default</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">==</span> <span class="hl num">3</span><span class="hl opt">) {</span>
    <span class="hl slc">// See if output directory exists</span>
    root <span class="hl opt">=</span> argv<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">];</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span><span class="hl kwd">exists</span><span class="hl opt">(</span>root<span class="hl opt">)) {</span>
      cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;no such directory: &quot;</span> <span class="hl opt">&lt;&lt;</span> root <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">size_t</span> rootLen <span class="hl opt">=</span> root<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">();</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>root<span class="hl opt">[</span>rootLen<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">] !=</span> <span class="hl str">'/'</span> <span class="hl opt">&amp;&amp;</span> root<span class="hl opt">[</span>rootLen<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">] !=</span> <span class="hl str">'</span><span class="hl esc">\\</span><span class="hl str">'</span><span class="hl opt">)</span>
      root<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl str">&quot;/&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Read input file line by line</span>
  <span class="hl slc">// checking for code delimiters</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> inCode <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">bool</span> printDelims <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  ofstream outf<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>inf<span class="hl opt">,</span> line<span class="hl opt">)) {</span>
    <span class="hl kwb">size_t</span> findDelim <span class="hl opt">=</span> line<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;//&quot;</span> <span class="hl str">&quot;/:~&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>findDelim <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
      <span class="hl slc">// Output last line and close file</span>
      <span class="hl kwa">if</span><span class="hl opt">(!</span>inCode<span class="hl opt">) {</span>
        cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Lines out of order&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>outf<span class="hl opt">);</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>printDelims<span class="hl opt">)</span>
        outf <span class="hl opt">&lt;&lt;</span> line <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      outf<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
      inCode <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
      printDelims <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
      findDelim <span class="hl opt">=</span> line<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">&quot;//&quot;</span> <span class="hl str">&quot;:&quot;</span><span class="hl opt">);</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>findDelim <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">) {</span>
        <span class="hl slc">// Check for '!' directive</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>line<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">] ==</span> <span class="hl str">'!'</span><span class="hl opt">) {</span>
          printDelims <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
          <span class="hl opt">++</span>findDelim<span class="hl opt">;</span>  <span class="hl slc">// To skip '!' for next search</span>
        <span class="hl opt">}</span>
        <span class="hl slc">// Extract subdirectory name, if any</span>
        <span class="hl kwb">size_t</span> startOfSubdir <span class="hl opt">=</span>
          line<span class="hl opt">.</span><span class="hl kwd">find_first_not_of</span><span class="hl opt">(</span><span class="hl str">&quot;</span> <span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">,</span> findDelim<span class="hl opt">+</span><span class="hl num">3</span><span class="hl opt">);</span>
        findDelim <span class="hl opt">=</span> line<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">':'</span><span class="hl opt">,</span> startOfSubdir<span class="hl opt">);</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>findDelim <span class="hl opt">==</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
          cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;missing filename information</span><span class="hl esc">\n</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
          <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
        <span class="hl opt">}</span>
        string subdir<span class="hl opt">;</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>findDelim <span class="hl opt">&gt;</span> startOfSubdir<span class="hl opt">)</span>
          subdir <span class="hl opt">=</span> line<span class="hl opt">.</span><span class="hl kwd">substr</span><span class="hl opt">(</span>startOfSubdir<span class="hl opt">,</span>
                               findDelim <span class="hl opt">-</span> startOfSubdir<span class="hl opt">);</span>
        <span class="hl slc">// Extract file name (better be one!)</span>
        <span class="hl kwb">size_t</span> startOfFile <span class="hl opt">=</span> findDelim <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
        <span class="hl kwb">size_t</span> endOfFile <span class="hl opt">=</span>
          line<span class="hl opt">.</span><span class="hl kwd">find_first_of</span><span class="hl opt">(</span><span class="hl str">&quot;</span> <span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">,</span> startOfFile<span class="hl opt">);</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>endOfFile <span class="hl opt">==</span> startOfFile<span class="hl opt">) {</span>
          cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;missing filename&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
          <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
        <span class="hl opt">}</span>
        <span class="hl slc">// We have all the pieces; build fullPath name</span>
        string <span class="hl kwd">fullPath</span><span class="hl opt">(</span>root<span class="hl opt">);</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>subdir<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">() &gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
          fullPath<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span>subdir<span class="hl opt">).</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl str">&quot;/&quot;</span><span class="hl opt">);</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>fullPath<span class="hl opt">[</span>fullPath<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">] ==</span> <span class="hl str">'/'</span><span class="hl opt">);</span>
        <span class="hl kwa">if</span><span class="hl opt">(!</span><span class="hl kwd">exists</span><span class="hl opt">(</span>fullPath<span class="hl opt">))</span>
<span class="hl ppc">#if defined(__GNUC__) || defined(__MWERKS__)</span>
          <span class="hl kwd">mkdir</span><span class="hl opt">(</span>fullPath<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> <span class="hl num">0</span><span class="hl opt">);</span>  <span class="hl slc">// Create subdir</span>
<span class="hl ppc">#else</span>
          <span class="hl kwd">mkdir</span><span class="hl opt">(</span>fullPath<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>  <span class="hl slc">// Create subdir</span>
<span class="hl ppc">#endif</span>
        fullPath<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span>line<span class="hl opt">.</span><span class="hl kwd">substr</span><span class="hl opt">(</span>startOfFile<span class="hl opt">,</span>
                        endOfFile <span class="hl opt">-</span> startOfFile<span class="hl opt">));</span>
        outf<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">(</span>fullPath<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
        <span class="hl kwa">if</span><span class="hl opt">(!</span>outf<span class="hl opt">) {</span>
          cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;error opening &quot;</span> <span class="hl opt">&lt;&lt;</span> fullPath
               <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; for output&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
          <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_FAILURE<span class="hl opt">);</span>
        <span class="hl opt">}</span>
        inCode <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Processing &quot;</span> <span class="hl opt">&lt;&lt;</span> fullPath <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>printDelims<span class="hl opt">)</span>
          outf <span class="hl opt">&lt;&lt;</span> line <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else if</span><span class="hl opt">(</span>inCode<span class="hl opt">) {</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>outf<span class="hl opt">);</span>
        outf <span class="hl opt">&lt;&lt;</span> line <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// Output middle code line</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">exit</span><span class="hl opt">(</span>EXIT_SUCCESS<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 4.33. C03/ExtractCode.cpp</strong></p></div><br class="example-break" /><p>
      Primero observará algunas directivas de compilación
      condicionales. La función <code class="function">mkdir()</code>, que crea
      un directorio en el sistema de ficheros, se define por el
      estándar POSIX<sup>[<a id="idp3966992" href="#ftn.idp3966992" class="footnote">10</a>]</sup> en la cabecera (&lt;direct.h&gt;). La respectiva
      signatura de <code class="function">mkdir()</code> también difiere: POSIX
      especifica dos argumentos, las viejas versiones sólo uno. Por
      esta razón, existe más de una directiva de compilación
      condicional después en el programa para elegir la llamada
      correcta a <code class="function">mkdir()</code>. Normalmente no usamos
      compilaciones condicionales en los ejemplos de este libro, pero
      en este programa en particular es demasiado útil para no poner
      un poco de trabajo extra dentro, ya que puede usarse para
      extraer todo el código con él.
    </p><p>
      La función <code class="function">exists()</code> en
      <span class="emphasis"><em>ExtractCode.cpp</em></span> prueba que un directorio
      existe abriendo un fiechero temporal en él. Si la obertura
      falla, el directorio no existe. Borre el fichero enviando su
      nombre como un<code class="type">char*</code> a
      <code class="function">std::remove()</code>.
    </p><p>
      El programa principal valida los argumentos de la línea de
      comandos y después lee el fichero de entrada línea por línea,
      mirando por los delimitadores especiales de código fuente. La
      bandera booleana <code class="varname">inCode</code> indica que el
      programa esta en el medio de un fichero fuente, así que las
      lineas deben ser extraídas. La bandera
      <code class="varname">printDelims</code> será verdadero si el elemento de
      obertura no está seguido de un signo de exclamanción; si no la
      primera y la última línea no son escritas. Es importante
      comprobar el último delimitador primero, por que el elemnto
      inicial es un subconjuntom  y buscando  por el elemento inicial
      debería retornar cierto en ambos casos. Si encontramos el
      elemento final, verificamos que estamos en el medio del
      procesamiento de un fichero fuente; sino, algo va mal con la
      manera en que los delimitadores han sido colocados en el fichero
      de texto. Si <code class="varname">inCode</code> es verdadero, todo está
      bien, y escribiremos (opcionalmente) la última linea y
      cerraremos el fichero. Cuando el elemento de obertura se
      encuentra, procesamos el directorio y el nombre del fichero y
      abrimos el fichero. Las siguientes funciones relacionadas con
      <code class="classname">string</code> fueron usadas en este ejemplo:
      <code class="function">length( )</code>, <code class="function">append( )</code>,
      <code class="function">getline( )</code>, <code class="function">find( )</code>
      (dos versiones), <code class="function">find_first_not_of( )</code>,
      <code class="function">substr( )</code>,<code class="function">find_first_of(
      )</code>,<code class="function"> c_str( )</code>, y, por supuesto,
      <code class="function">operator&lt;&lt;( )</code>
    </p></div><div class="sect1" title="4.5. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3977376"></a>4.5. Resumen</h2></div></div></div><p>
      Los objetos <code class="classname">string</code> proporcionan a los
      desarrolladores un gran número de ventajas sobre sus
      contrapartidas en C. La mayoria de veces, la clase
      <code class="classname">string</code> hacen a las cadenas con punteros a
      caracteres innecesarios. Esto elimina por completo una clase de
      defectos de software que radican en el uso de punteros no
      inicializados o con valores incorrectos.
    </p><p>
    FIXME:
      Los <code class="classname">string</code> de C++, de manera transparente
      y dinámica, hacen crecer el espacio de alamcenamiento para
      acomodar los cambios de tamaño de los datos de la cadena. Cuando
      los datos en n <code class="classname">string</code> crece por encima de
      los límites de la memoria asignada inicialmente para ello, el
      objeto <code class="classname">string</code> hará las llamadas para la
      gestión de la memoria para obtener el espacio y retornar el
      espacio al montón. La gestión consistente de la memoria
      previente lagunas de memoria y tiene el potencial de ser mucho
      más eficiente que un <span class="emphasis"><em>"hágalo usted mismo"</em></span>.
    </p><p>
      Las funciones de la clase <code class="classname">string</code>
      proporcionan un sencillo y comprensivo conjunto de herramientas
      para crear, modificar y buscar en cadenas. Las comparaciones
      entre <code class="classname">string</code> siempre son sensibles a
      mayúsculas/minúsculas, pero usted puede solucionar el problema
      copiando los datos a una cadena estilo C acabada en nulo y
      usando funciones no sensibles a mayúsculas/minúsculas,
      convirtiendo temporalmente los datos contenidos a  mayúsculas o
      minúsculas, o creando una clase <code class="classname">string</code>
      sensible que sobreescribe los rasgos de carácter usados para
      crear un objeto <code class="classname">basic_string</code>
    </p></div><div class="sect1" title="4.6. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp3983032"></a>4.6. Ejercicios</h2></div></div></div><p>
      Las soluciones a los ejercicios se pueden encontrar en el
      documento electrónico titulado «The Thinking in C++
      Annotated Solution Guide», disponible por poco dinero
      en <a class="ulink" href="http://www.bruceeckel.com" target="_top">www.BruceEckel.com</a>.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      Escriba y pruebe una función que invierta el orden de los
      caracteres en una cadena.
    </p></li><li class="listitem"><p>
	  2. Un palindromo es una palabra o grupo de palabras que
	  tanto hacia delante hacia atrás se leen igual. Por ejemplo
	  <span class="emphasis"><em>"madam"</em></span> o
	  <span class="emphasis"><em>"wow"</em></span>. Escriba un programa que tome un
	  string como argumento desde la línea de comandos y, usando
	  la función del ejercicio anterior, escriba si el string es
	  un palíndromo o no.
	</p></li><li class="listitem"><p>
	  3. Haga que el programa del Ejercicio 2 retorne verdadero
	  incluso si las letras simetricas difieren en
	  mayúsculas/minúsculas. Por ejemplo,
	  <span class="foreignphrase"><em class="foreignphrase">"Civic"</em></span> debería retornar
	  verdadero aunque la primera letra sea mayúscula.
	</p></li><li class="listitem"><p>
	  4. Cambie el programa del Ejercicio 3 para ignorar la
	  puntuación y los espacios también. Por ejemplo
	  <span class="foreignphrase"><em class="foreignphrase">"Able was I, ere I saw Elba."</em></span>
	  debería retornar verdadero.
	</p></li><li class="listitem"><p>
	  5. Usando las siguientes declaraciones de string y solo char
	  (no literales de cadena o números mágicos):
	</p><p>
	  <code class="code">string one("I walked down the canyon with the moving
	    mountain bikers."); string two("The bikers passed by me too close
	    for comfort."); string three("I went hiking instead.");</code>
	</p><p>
	  produzca la siguiente frase:
	</p><p>
	  <span class="foreignphrase"><em class="foreignphrase">I moved down the canyon with the mountain
	    bikers. The mountain bikers passed by me too close for
	    comfort. So I went hiking instead.
	  </em></span>
	</p></li><li class="listitem"><p>
	  6. Escriba un programa llamado "reemplazo" que tome tres
	  argumentos de la línea de comandos representando un fichero
	  de texto de entrada, una frase para reemplazar (llámela
	  <code class="varname">from</code>), y una cadena de reemplazo (llámela
	  <code class="varname">to</code>). El programa debería escribir un
	  nuevo fichero en la salida estandar con todas las
	  ocurrencias de <code class="varname">from</code> reemplazadas por
	  <code class="varname">to</code>.
	</p></li><li class="listitem"><p>
	  7. Repetir el ejercicio anterior pero reemplazando todas las
	  instancias pero ignorando las mayúsculas/minúsculas.
	</p></li><li class="listitem"><p>
	  8. Haga su programa a partir del Ejercicio 3 tomando un
	  nombre de fichero de la linea de comandos, y despues
	  mostrando todas las palabras que son palíndromos (ignorando
	  las mayúsculas/minúsculas) en el fichero. No intente buscar
	  palabras para palíndromos que son mas largos que una palabra
	  (a diferencia del ejercicio 4).
	</p></li><li class="listitem"><p>
	  9. Modifique <span class="emphasis"><em>HTMLStripper.cpp</em></span> para que
	  cuando encuentre una etiqueta, muestre el nombre de la
	  etiqueta, entonces muestre el contenido del fichero entre la
	  etiqueta y la etiqueta de finalización de fichero. Asuma que
	  no existen etiquetas anidadas, y que todas las etiquetas
	  tienen etiquetas de finalizacion (denotadas con
	  &lt;/TAGNAME&gt;).
	</p></li><li class="listitem"><p>
	  10. Escriba un programa que tome tres argumentos de la línea
	  de comandos (un nombre de fichero y dos cadenas) y muestre
	  en la consola todas la líneas en el fichero que tengan las
	  dos cadenas en la línea, alguna cadena, solo una cadena o
	  ninguna de ellas, basándose en la entreada de un usuario al
	  principio del programa (el usuario elegirá que modo de
	  búsqueda usar). Para todo excepto para la opción "ninguna
	  cadena", destaque la cadena(s) de entrada colocando un
	  asterisco (*) al principio y al final de cada cadena que
	  coincida cuando sea mostrada.
	</p></li><li class="listitem"><p>
	  11. Escriba un programa que tome dos argumentos de la linea
	  de comandos (un nombre de fichero y una cadena) y cuente el
	  numero de veces que la cadena esta en el fichero, incluso si
	  es una subcadena (pero ignorando los solapamientos). Por
	  ejemplo, una cadena de entrada de <span class="emphasis"><em>"ba"</em></span>
	  debería coincidir dos veces en la palabra
	  <span class="foreignphrase"><em class="foreignphrase">"basquetball"</em></span>, pero la cadena
	  de entrada <span class="emphasis"><em>"ana"</em></span> solo deberia coincidir
	  una vez en <span class="foreignphrase"><em class="foreignphrase">"banana"</em></span>. Muestre
	  por la consola el número de veces que la cadena coincide en
	  el fichero, igual que la longitud media de las palabras
	  donde la cadena coincide. (Si la cadena coincide más de una
	  vez en una palabra, cuente solamente la palabra una vez en
	  el cálculo de la media).
	</p></li><li class="listitem"><p>
	  12. Escriba un programa que tome un nombre de fichero de la
	  línea de comandos y perfile el uso del carácter, incluyendo
	  la puntuación y los espacios (todos los valores de
	  caracteres desde el 0x21 [33] hasta el 0x7E [126], además
	  del carácter de espacio). Esto es, cuente el numero de
	  ocurrencias para cada carácter en el fichero, después
	  muestre los resultados ordenados secuencialmente (espacio,
	  despues !, ", #, etc.) o por frecuencia descendente o
	  ascendente basado en una entrada de usuario al principio del
	  programa. Para el espacio, muestre la palabra "espacio" en
	  vez del carácter ' '. Una ejecución de ejemplo debe
	  mostrarse como esto:
	</p><p>
    Formato secuencial, ascendente o descendente (S/A/D): D
    t: 526
    r: 490
    etc.
	</p></li><li class="listitem"><p>
	  13. Usando <code class="function">find()</code> y
	  <code class="function">rfind()</code>, escriba un programa que tome
	  dos argumentos de lánea de comandos (un nombre de fichero y
	  una cadena) y muestre la primera y la última palapra (y sus
	  indices) que no coinciden con la cadena, asi como los indice
	  de la primera y la última instancia de la cadena. Muestre
	  <span class="emphasis"><em>"No Encontrado"</em></span> si alguna de las
	  busquedas fallan.
	</p></li><li class="listitem"><p>
	  14. Usando la familia de fuciones
	  <code class="function">find_first_of</code> (pero no exclusivamente),
	  escriba un programa que borrará todos los caracteres no
	  alfanuméricos excepto los espacios y los puntos de un
	  fichero. Despues convierta a mayúsculas la primera letra que
	  siga a un punto.
	</p></li><li class="listitem"><p>
	  15. Otra vez, usando la familia de funciones
	  <code class="function">find_first_of</code>, escriba un programa que
	  acepte un nombre de fichero como argumentod elinea de
	  comandos y después formatee todos los números en un fichero
	  de moneda. Ignore los puntos decimales después del primero
	  despues de un carácter no mumérico, e redondee al
	</p></li><li class="listitem"><p>
	  16. Escriba un programa que acepte dos argumentos por línea
	  de comandos (un nombre de fichero y un numero) y mezcle cada
	  paralabra en el fichero cambiando aleatoriamente dos de sus
	  letras el número de veces especificado en el segundo
	  parametro. (Esto es, si le pasamos 0 a su programa desde la
	  línea de comandos, las palabras no serán mezcladas; si le
	  pasamos un 1, un par de letras aleatoriamente elegidas deben
	  ser cambiadas, para una entrada de 2, dos parejas aleatorias
	  deben ser intercambiadas, etc.).
	</p></li><li class="listitem"><p>
	  17.  Escriba un  programa que  acepte un  nombre  de fichero
	  desde la  línea de  comandos y muestre  el numero  de frases
	  (definido como el numero de puntos en el fichero), el número
	  medio  de  caracteres  por  frase,  y  el  número  total  de
	  caracteres en el fichero.
	</p></li></ol></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp3736344" href="#idp3736344" class="para">1</a>] </sup>Algunos materiales de este capítulo
    fueron creados originalmente por
    <span class="author"><span class="firstname">Nancy</span> <span class="surname">
    Nicolaisen</span></span></p></div><div class="footnote"><p><sup>[<a id="ftn.idp3753496" href="#idp3753496" class="para">2</a>] </sup>Es dificil hacer implementaciones
      con multiples referencias para trabajar de manera segura en
      multihilo. (Ver [<span class="citation">More Exceptional C++,
      pp.104-14</span>]). Ver Capitulo 10 para más información
      sobre multiples hilos</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3787584" href="#idp3787584" class="para">3</a>] </sup>
	    Es una abrviación de <span class="foreignphrase"><em class="foreignphrase">"no
	    position"</em></span>, y su valor más alto puede ser
	    representado por el ubicador de
	    <code class="classname">string</code> <code class="varname">size_type</code>
	    (<code class="varname">std::size_t</code> por defecto).
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp3804064" href="#idp3804064" class="para">4</a>] </sup> Descrito en profundidad en el
	Capítulo 6.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3872432" href="#idp3872432" class="para">5</a>] </sup>Para mantener la exposición simple, esta version no
	maneja etiquetas anidadas, como los
	comentarios.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3874320" href="#idp3874320" class="para">6</a>] </sup>Es tentador usar aquí las matemáticas para evitar
	algunas llamadas a <code class="function">erase()</code>, pero como en
	algunos casos uno de los operandos es
	<code class="classname">string::</code><code class="varname">npos</code> (el
	entero sin signo más grande posible), ocurre un desbordamiento
	del entero y se cuelga el algoritmo.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3914232" href="#idp3914232" class="para">7</a>] </sup>Por las razones de seguridad mencionadas, el
	  <span class="foreignphrase"><em class="foreignphrase">C++ Standards Committee</em></span> está
	  considerando una propuesta de redefinición del
	  <code class="classname">string::</code><code class="function">operator[]</code>
	  para comportarse de manera idéntica al
	  <code class="classname">string::</code><code class="function">at()</code>
	  para C++0x.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3939776" href="#idp3939776" class="para">8</a>] </sup>(N.del
	T.) Se refiere a <code class="classname">string</code> amplio puesto
	que esta formado por caracteres anchos <code class="type">wchar_t</code>
	que deben soportar la codificación mas grande que soporte el
	compilador. Casi siempre esta codificación es
	<span class="emphasis"><em>Unicode</em></span>, por lo que casi siempre el ancho
	de <code class="type">wchar_t</code> es 2 bytes</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3955592" href="#idp3955592" class="para">9</a>] </sup>Esté alerta porque algunas versiones de
      Microsoft Word que substituyen erroneamente los caracteres con
      comilla simple con un carácter ASCII cuando salva el documento
      como texto, causan un error de compilación. No tenemos idea de
      porqué pasa esto. Simplemente reemplace el carácter manualmente
      con un apóstrofe.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp3966992" href="#idp3966992" class="para">10</a>] </sup>POSIX, un estándar IEEE, es un
      <span class="foreignphrase"><em class="foreignphrase">"Portable Operating System
      Interface"</em></span> (Interficie de Sistema Operativo
      Portable) y es una generalización de muchas de las llamadas a
      sistema de bajo nivel encontradas en los sistemas UNIX.</p></div></div></div><div class="chapter" title="5: Iostreams"><div class="titlepage"><div><div><h2 class="title"><a id="C04"></a>5: Iostreams</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp4010792">5.1. ¿Por que <code class="classname">iostream</code>? </a></span></dt><dt><span class="sect1"><a href="#idp4044104">5.2. <code class="classname">Iostreams</code> al rescate</a></span></dt><dt><span class="sect1"><a href="#idp4110296">5.3. Manejo errores de <code class="classname">stream</code></a></span></dt><dt><span class="sect1"><a href="#idp4146624">5.4. Iostreams de fichero</a></span></dt><dt><span class="sect1"><a href="#idp4178936">5.5. Almacenamiento de <code class="classname">iostream</code></a></span></dt><dt><span class="sect1"><a href="#idp4201664">5.6. Buscar en iostreams</a></span></dt><dt><span class="sect1"><a href="#idp4227208">5.7. Iostreams de <code class="classname">string</code></a></span></dt><dt><span class="sect1"><a href="#idp4265304">5.8. Formateo de stream de salida</a></span></dt><dt><span class="sect1"><a href="#idp4318832">5.9. Manipuladores</a></span></dt><dt><span class="sect1"><a href="#idp4358632">5.10.  </a></span></dt><dt><span class="sect1"><a href="#idp4388304">5.11.  </a></span></dt><dt><span class="sect1"><a href="#idp4400344">5.12.  </a></span></dt><dt><span class="sect1"><a href="#idp4400920">5.13.  </a></span></dt></dl></div><div class="highlights"><p>
      Puedes hacer mucho más con el problema general de E/S que
      simplemente coger el E/S estándar y convertirlo en una clase.
    </p></div><p>
    ¿No seria genial si pudiera hacer que todos los 'receptáculos' -E/S
    estándar, ficheros, e incluso boques de memoria- parecieran iguales de
    manera que solo tuviera que recordar una interficie? Esta es la idea que hay
    detrás de los <code class="classname">iostreams</code>. Son mucho más sencillos,
    seguros, y a veces incluso más eficientes que el conjunto de funciones de la
    libreria estándar de C <code class="classname">stdio.</code>
  </p><p>
    Las clases de <code class="classname">iostream</code> son generalmente la
    primera parte de la libreria de C++ que los nuevos programadores de C++
    parender a usar. En este capítulo se discute sobre las mejoras que
    representan los <code class="classname">iostream</code> sobre las funciones de
    <code class="classname">stdio</code> de C y explora el comprotamiento de los
    ficheros y streams de strings además de los streams de consola.
  </p><div class="sect1" title="5.1. ¿Por que iostream?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4010792"></a>5.1. ¿Por que <code class="classname">iostream</code>? </h2></div></div></div><p>
      Se debe estar preguntando que hay de malo en la buena y vieja
      librería de C. ¿Por que no 'incrustar' la libreria de C en una clase y ya
      está? A veces esta solución es totalmente válida. Por ejemplo, suponga que
      quiere estar seguro que un fichero representado por un puntero de
      <code class="classname">stdio</code> <code class="varname">FILE</code> siempre es abierto de
      forma segura y cerrado correctamente sin tener que confiar en que el usuario
      se acuerde de llamar a la función <code class="function">close()</code>. El siguiente
      programa es este intento:
    </p><div class="example"><a id="idp4013184"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:FileClass.h</span>
<span class="hl slc">// stdio files wrapped.</span>
<span class="hl ppc">#ifndef FILECLASS_H</span>
<span class="hl ppc">#define FILECLASS_H</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>

<span class="hl kwc">class</span> FileClass <span class="hl opt">{</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> f<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">struct</span> FileClassError <span class="hl opt">:</span> std<span class="hl opt">::</span>runtime_error <span class="hl opt">{</span>
    <span class="hl kwd">FileClassError</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> msg<span class="hl opt">)</span>
    <span class="hl opt">:</span> std<span class="hl opt">::</span><span class="hl kwd">runtime_error</span><span class="hl opt">(</span>msg<span class="hl opt">) {}</span>
  <span class="hl opt">};</span>
  <span class="hl kwd">FileClass</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode <span class="hl opt">=</span> <span class="hl str">&quot;r&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">FileClass</span><span class="hl opt">();</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> <span class="hl kwd">fp</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// FILECLASS_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 5.1. C04/FileClass.h</strong></p></div><br class="example-break" /><p>
      Cuando trabaja con ficheros E/S en C, usted trabaja con punteros
      desnudos a una <code class="varname">struct</code> de <code class="varname">FILE</code>, pero
      esta clase envuelve los punteros y garantiza que es correctamente
      inicializada y destruida usando el constructor y el destructor. El segundo
      parámetro del constructor es el modo del fichero, que por defecto es 'r'
      para 'leer'
    </p><p>
      Para pedir el valor del puntero para usarlo en las funciones de
      fichero de E/S, use la función de acceso <code class="function">fp()</code>. Aquí
      están las definiciones de las funciones miembro:
    </p><div class="example"><a id="idp4017144"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:FileClass.cpp {O}</span>
<span class="hl slc">// FileClass Implementation.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;FileClass.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

FileClass<span class="hl opt">::</span><span class="hl kwd">FileClass</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> fname<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">((</span>f <span class="hl opt">=</span> <span class="hl kwd">fopen</span><span class="hl opt">(</span>fname<span class="hl opt">,</span> mode<span class="hl opt">)) ==</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl kwa">throw</span> <span class="hl kwd">FileClassError</span><span class="hl opt">(</span><span class="hl str">&quot;Error opening file&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

FileClass<span class="hl opt">::~</span><span class="hl kwd">FileClass</span><span class="hl opt">() {</span> <span class="hl kwd">fclose</span><span class="hl opt">(</span>f<span class="hl opt">); }</span>

<span class="hl kwb">FILE</span><span class="hl opt">*</span> FileClass<span class="hl opt">::</span><span class="hl kwd">fp</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> f<span class="hl opt">; }</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.2. C04/FileClass.cpp</strong></p></div><br class="example-break" /><p>
      El constructor llama a <code class="function">fopen()</code>, tal como se
      haría normalmente, pero además se asegura que el resultado no es cero, que
      indica un error al abrir el fichero. Si el fichero no se abre correctamente,
      se lanza una excepción.
    </p><p>
      El destructor cierra el fichero, y la función de acceso
      <code class="function">fp()</code> retorna <code class="varname">f</code>. Este es un ejemplo
      de uso de <code class="classname">FileClass</code>:
    </p><div class="example"><a id="idp4020968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:FileClassTest.cpp</span>
<span class="hl slc">//{L} FileClass</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;FileClass.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    FileClass <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl str">&quot;FileClassTest.cpp&quot;</span><span class="hl opt">);</span>
    <span class="hl kwb">const int</span> BSIZE <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span>
    <span class="hl kwb">char</span> buf<span class="hl opt">[</span>BSIZE<span class="hl opt">];</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">fgets</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> BSIZE<span class="hl opt">,</span> f<span class="hl opt">.</span><span class="hl kwd">fp</span><span class="hl opt">()))</span>
      <span class="hl kwd">fputs</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> stdout<span class="hl opt">);</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>FileClass<span class="hl opt">::</span>FileClassError<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> EXIT_SUCCESS<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">// File automatically closed by destructor</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.3. C04/FileClassTest.cpp</strong></p></div><br class="example-break" /><p>
      Se crea el objeto <code class="classname">FileClass</code> y se usa en
      llamadas a funciones E/S de fichero normal de C, llamando a
      <code class="function">fp()</code>. Cuando haya acabado con ella, simplemente
      olvídese; el fichero será cerrado por el destructor al final del ámbito de
      la variable.
    </p><p>
      Incluso teniendo en cuenta que <code class="varname">FILE</code> es un
      puntero privado, no es particularmente seguro porque
      <code class="function">fp()</code> lo recupera. Ya que el único efecto que parece
      estar garantizado es la inicialización y la liberación, ¿por que no hacerlo
      público o usar una <code class="code">struct </code>en su lugar? Nótese que mientras se
      puede obtener una copia de <code class="varname">f </code>usando
      <code class="function">fp()</code>, no se puede asignar a <code class="varname">f</code> -que
      está completamente bajo el control de la clase. Después de capturar el
      puntero retornado por <code class="function">fp()</code>, el programador cliente
      todavía puede asignar a la estructura elementos o incluso cerrarlo, con lo
      que la seguridad esta en la garantía de un puntero a FILE válido mas que en
      el correcto contenido de la estructura.
    </p><p>
      Si quiere completa seguridad, tiene que evitar que el usuario
      acceda directamente al puntero <code class="code">FILE</code>. Cada una de las versiones
      de las funciones normales de E/S a ficheros deben ser mostradas como
      miembros de clase para que todo lo que se pueda hacer desde el acercamiento
      de C esté disponible en la clase de C++.
    </p><div class="example"><a id="idp4027864"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Fullwrap.h</span>
<span class="hl slc">// Completely hidden file IO.</span>
<span class="hl ppc">#ifndef FULLWRAP_H</span>
<span class="hl ppc">#define FULLWRAP_H</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#undef getc</span>
<span class="hl ppc">#undef putc</span>
<span class="hl ppc">#undef ungetc</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">fpos_t</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> File <span class="hl opt">{</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> f<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">FILE</span><span class="hl opt">*</span> <span class="hl kwd">F</span><span class="hl opt">();</span> <span class="hl slc">// Produces checked pointer to f</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">File</span><span class="hl opt">();</span> <span class="hl slc">// Create object but don't open file</span>
  <span class="hl kwd">File</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> path<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode <span class="hl opt">=</span> <span class="hl str">&quot;r&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">~</span><span class="hl kwd">File</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">open</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> path<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode <span class="hl opt">=</span> <span class="hl str">&quot;r&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">reopen</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> path<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> mode<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getc</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">ungetc</span><span class="hl opt">(</span><span class="hl kwb">int</span> c<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">putc</span><span class="hl opt">(</span><span class="hl kwb">int</span> c<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">puts</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> s<span class="hl opt">);</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">gets</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> format<span class="hl opt">, ...);</span>
  <span class="hl kwb">size_t</span> <span class="hl kwd">read</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> ptr<span class="hl opt">,</span> <span class="hl kwb">size_t</span> size<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">size_t</span> <span class="hl kwd">write</span><span class="hl opt">(</span><span class="hl kwb">const void</span><span class="hl opt">*</span> ptr<span class="hl opt">,</span> <span class="hl kwb">size_t</span> size<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">eof</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">close</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">flush</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span> <span class="hl kwd">seek</span><span class="hl opt">(</span><span class="hl kwb">long</span> offset<span class="hl opt">,</span> <span class="hl kwb">int</span> whence<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getpos</span><span class="hl opt">(</span><span class="hl kwb">fpos_t</span><span class="hl opt">*</span> pos<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">setpos</span><span class="hl opt">(</span><span class="hl kwb">const fpos_t</span><span class="hl opt">*</span> pos<span class="hl opt">);</span>
  <span class="hl kwb">long</span> <span class="hl kwd">tell</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">rewind</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setbuf</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> buf<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">setvbuf</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> buf<span class="hl opt">,</span> <span class="hl kwb">int</span> type<span class="hl opt">,</span> <span class="hl kwb">size_t</span> sz<span class="hl opt">);</span>
  <span class="hl kwb">int</span> <span class="hl kwd">error</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">clearErr</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// FULLWRAP_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 5.4. C04/Fullwrap.h</strong></p></div><br class="example-break" /><p>
      Esta clase contiene casi todas las funciones de E/S de fichero
      de <code class="code">&lt;cstdio&gt;</code>. (<code class="function">vfprintf()</code> no esta; se
      implementa en la función miembro <code class="function">printf()</code> )
    </p><p>
      El fichero tiene el mismo constructor que en el ejemplo
      anterior, y también tiene un constructor por defecto. El constructor por
      defecto es importante si se crea un array de objetos
      <code class="classname">File</code> o se usa un objeto <code class="classname">File</code>
      como miembro de otra clase donde la inicialización no se realiza en el
      contructor, sino cierto tiempo después de que el objeto envolvente se
      cree.
    </p><p>
      El constructor por defecto pone a cero el puntero a
      <code class="varname">FILE</code> privado <code class="varname">f</code>. Pero ahora , antes de
      cualquier referencia a <code class="function">f</code>, el valor debe ser comprobado
      para asegurarse que no es cero. Esto se consigue con
      <code class="function">F()</code>, que es privado porque está pensado para ser usado
      solamente por otras funciones miembro. (No queremos dar acceso directo a
      usuarios a la estructura de <code class="varname">FILE</code> subyacente en esta
      clase).
    </p><p>
      Este acercamiento no es terrible en ningún sentido. Es bastante
      funcional, y se puede imaginar haciendo clases similares para la E/S
      estándar (consola) y para los formateos en el core (leer/escribir un trozo
      de la memoria en vez de un fichero o la consola).
    </p><p>
      Este bloque de código es el interprete en tiempo de ejecución usado
      para las listas variables de argumentos. Este es el código que analiza el
      formato de su cadena en tiempo de ejecución y recoge e interpreta argumentos
      desde una lista variable de argumentos. Es un problema por cuatro
      razones:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	    Incluso si solo se usa una fracción de la funcionalidad del
	    interprete, se carga todo en el ejecutable. Luego si quiere usar un
	    <code class="code">printf("%c", 'x'); </code>, usted tendrá todo el paquete, incluido las
	    partes que imprimen números en coma flotante y cadenas. No hay una opción
	    estándar para reducir el la cantidad de espacio usado por el
	    programa.
	  </p></li><li class="listitem"><p>
	    Como la interpretación pasa en tiempo de ejecución, no se
	    puede evitar un empeoramiento del rendimiento. Esto es frustrante por que
	    toda la información está allí, en el formato de la cadena, en tiempo de
	    compilación, pero no se evalua hasta la ejecución. Por otro lado, si se
	    pudieran analizar los argumentos en el formateo de la cadena durante la
	    compilación, se podrían hacer llamadas directas a funciones que tuvieran el
	    potencial de ser mucho más rápidas que un interprete en tiempo de ejecución
	    (aunque la familia de funciones de printf() acostumbran a estar bastante
	    bien optimizadas).
	  </p></li><li class="listitem"><p>
	    Como el formateo de la cadena no se evalua hasta la
	    ejecución, no se hace una comprobación de errores al compilar.
	    Probalblemente está familiarizado con este problema si ha intentado buscar
	    errores que provienen del uso de un número o tipo de argumentos incorrecto
	    en una sentencia <code class="function">printf()</code>. C++ ayuda mucho a encontrar
	    rápidamente errores durante la compilación y hacerle la vida más fácil.
	    Parece una tonteria desechar la seguridad en los tipos de datos para la
	    libreria de E/S, especialmente cuando usamos intensivamente las E/S.
	  </p></li><li class="listitem"><p>
	    Para C++, el más crucial de los problemas es que la familia
	    de funciones de printf() no es particularmente extensible. Esta realmente
	    diseñada para manejar solo los tipos básicos de datos en C (char, int,
	    float, double, wchar_t, char*, wchar_t*, y void*) y sus variaciones. Debe
	    estar pensando que cada vez que añade una nueva clase, puede añadir
	    funciones sobrecargadas printf() y scanf() (y sus variaciones para ficheros
	    y strings), pero recuerde: las funciones sobrecargadas deben tener
	    diferentes tipos de listas de argumentos, y la familia de funciones de
	    printf() esconde esa información en la cadena formateada y su lista variable
	    de argumentos. Para un lenguage como C++, cuya virtud es que se pueden
	    añadir fácilmente nuevos tipos de datos, esta es una restricción
	    inaceptable.
	  </p></li></ol></div></div><div class="sect1" title="5.2. Iostreams al rescate"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4044104"></a>5.2. <code class="classname">Iostreams</code> al rescate</h2></div></div></div><p>
      Estos problemas dejan claro que la E/S es una de las principales
      prioridades para la librería de clases estándar de C++. Como 'hello,
      worlod' es el primer programa que cualquiera escribe en un nuevo lenguaje,
      y porque la E/S es parte de virtualmente cualquier programa, la librería
      de E/S en C++ debe ser particularmente fácil de usar. Tembién tiene el
      reto mucho mayor de acomodar cualquier nueva clase. Por tanto, estas
      restricciones requieren que esta librería de clases fundamentales tengan
      un diseño realmente inspirado. Además de ganar en abstracción y claridad
      en su trabajo con las E/S y el formateo, en este capítulo verá lo potente
      que puede llegar a ser esta librería de C++.
    </p><div class="sect2" title="5.2.1. Insertadores y extractores"><div class="titlepage"><div><div><h3 class="title"><a id="idp4045560"></a>5.2.1. Insertadores y extractores </h3></div></div></div><p>
	Un <code class="classname">stream</code> es un objeto que transporta y
	formatea carácteres de un ancho fijo. Puede tener un
	<code class="classname">stream</code> de entrada (por medio de los descendientes
	de la clase <code class="classname">istream</code>), o un <code class="classname">stream
	</code>de salida (con objetos derivados de
	<code class="classname">ostream</code>), o un <code class="classname">stream</code> que
	hace las dos cosas simultáneamente (con objetos derivados de
	<code class="classname">iostream</code>). La librería
	<code class="classname">iostream</code> provee tipos diferentes de estas clases:
	<code class="classname">ifstream</code>, <code class="classname">ofstream </code>y
	<code class="classname">fstream </code>para ficheros, y
	<code class="classname">istringstream</code>,
	<code class="classname">ostringstream</code>, y
	<code class="classname">stringstream</code> para comunicarese con la clase
	<code class="classname">string</code> del estándar C++. Todas estas clases
	<code class="classname">stream</code> tiene prácticamente la misma interfaz, por
	lo que usted puede usar streams de manera uniforme, aunque esté trabajando
	con un fichero, la E/S estándar, una región de la memoria, o un objeto
	<code class="classname">string</code>. La única interfaz que aprenderá también
	funciona para extensiones añadidas para soportar nuevas clases. Algunas
	funciones implementan sus comandos de formateo, y algunas funciones leen y
	escriben caracteres sin formatear.
      </p><p>
	Las clases <code class="classname">stream</code> mencionadas antes son
	actualmente especializaciones de plantillas, muchas como la clase estándar
	<code class="classname">string</code> son especializaciones de la plantilla
	<code class="classname">basic_string</code>. Las clases básicas en la jerarquia de
	herencias son mostradas en la siguiente figura:
	<sup>[<a id="idp4052024" href="#ftn.idp4052024" class="footnote">11</a>]</sup>
      </p><p>
	La clase <code class="classname">ios_base</code> declara todo aquello que
	es común a todos los <code class="classname">stream</code>, independientemente del
	tipo de carácteres que maneja el <code class="classname">stream</code>. Estas
	declaraciones son principalmente constantes y funciones para manejarlas,
	algunas de ella las verá a durante este capítulo. El resto de clases son
	plantillas que tienen un tipo de caracter subyacente como parámetro. La
	clase <code class="classname">istream</code>, por ejemplo, está definida a
	continuación:
      </p><pre class="programlisting">
<span class="hl kwc">typedef</span> basic_istream<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&lt;</span> istream<span class="hl opt">;</span>
</pre><p>
	Todas las clases mencionadas antes estan definidas de manera
	similar. También hay definiciones de tipo para todas las clases de
	<code class="classname">stream</code> usando <code class="type">wchar_t</code> (la anchura de
	este tipo de carácteres se discute en el Capítulo 3) en lugar de
	<code class="type">char</code>. Miraremos esto al final de este capítulo. La plantilla
	<code class="classname">basic_ios</code> define funciones comunes para la entrada
	y la salida, pero depende del tipo de carácter subyacente (no vamos a
	usarlo mucho). La plantilla <code class="classname">basic_istream</code> define
	funciones genéricas para la entrada y <code class="classname">basic_ostream</code>
	hace lo mismo para la salida. Las clases para ficheros y streams de
	<code class="classname">strings</code> introducidas después añaden funcionalidad
	para sus tipos especificos de <code class="classname">stream</code>.
      </p><p>
	En la librería de <code class="classname">iostream</code>, se han
	sobrecargado dos operadores para simplificar el uso de
	<code class="classname">iostreams</code>. El operador &lt;&lt; se denomina
	frecuentemente instertador para <code class="classname">iostreams</code>, y el
	operador &gt;&gt; se denomina frecuentemente extractor.
      </p><p>
	Los extractores analizan la información esperada por su objeto
	destino de acuerdo con su tipo. Para ver un ejemplo de esto, puede usar el
	objeto <code class="varname">cin</code>, que es el equivalente de
	<code class="classname">iostream</code> de <code class="type">stdin</code> en C, esto es,
	entrada estándar redireccionable. Este objeto viene predefinido cuando
	usted incluye la cabecera <code class="code">&lt;iostream&gt;.</code>
      </p><pre class="programlisting">
<span class="hl kwb">int</span> i<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> i<span class="hl opt">;</span>

  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> f<span class="hl opt">;</span>

  <span class="hl kwb">char</span> c<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> c<span class="hl opt">;</span>

  <span class="hl kwb">char</span> buf<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">];</span>
  cin <span class="hl opt">&gt;&gt;</span> buf<span class="hl opt">;</span>
</pre><p>
	Existe un operador sobrecargado &gt;&gt; para cada tipo
	fundamental de dato. Usted también puede sobrecargar los suyos, como verá
	más adelante.
      </p><p>
	Para recuperar el contenido de las variables, puede usar el
	objeto <code class="classname">cout</code> (correspondiente con la salida
	estándar; también existe un objeto <code class="classname">cerr</code>
	correspondiente con la salida de error estándar) con el insertador
	&lt;&lt;:
      </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;f = &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> f<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;c = &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;buf = &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> buf<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
</pre><p>
	Esto es tedioso y no parece ser un gran avance sobre<code class="function">
	printf()</code>, aparte de la mejora en la comprobación de tipos.
	Afortunadamente, los insertadores y extractores sobrecargados están
	diseñados para ser encadenados dentro de expresiones más complejas que son
	mucho más fáciles de escribir (y leer):
      </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;f = &quot;</span> <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;c = &quot;</span> <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;buf = &quot;</span> <span class="hl opt">&lt;&lt;</span> buf <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
</pre><p>
	Definir insertadores y extractores para sus propias clases es
	simplemente una cuestion de sobrecargar los operadores asociados para
	hacer el trabajo correcto, de la siguente manera:
      </p><p>
	Hacer del primer parámetro una referencia no constante al
	<code class="classname">stream</code> (<code class="classname">istream</code> para la
	entrada, <code class="classname">ostream</code> para la salida).
      </p><p>
	Realizar la operación de insertar/extraer datos hacia/desde
	el <code class="classname">stream</code> (procesando los componentes del
	objeto).
      </p><p>
	Retornar una referencia al <code class="classname">stream</code>
      </p><p>
	El <code class="classname">stream</code> no debe ser constante porque
	el procesado de los datos del <code class="classname">stream</code> cambian el
	estado del <code class="classname">stream</code>. Retornando el
	<code class="classname">stream</code>, usted permite el encadenado de operaciones
	en una sentencia individual, como se mostró antes.
      </p><p>
	Como ejemplo, considere como representar la salida de un
	objeto <code class="classname">Date</code> en formato MM-DD-AAAA . El siguiente
	insertador hace este trabajo:
      </p><pre class="programlisting">
ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Date<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
  <span class="hl kwb">char</span> fillc <span class="hl opt">=</span> os<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">(</span><span class="hl str">'0'</span><span class="hl opt">);</span>
  os <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span><span class="hl kwd">getMonth</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">'-'</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span><span class="hl kwd">getDay</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">'-'</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">) &lt;&lt;</span> <span class="hl kwd">setfill</span><span class="hl opt">(</span>fillc<span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span><span class="hl kwd">getYear</span><span class="hl opt">();</span>
  <span class="hl kwa">return</span> os<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>
	Esta función no puede ser miembro de la clase
	<code class="classname">Date</code> por que el operando de la izquierda &lt;&lt;
	debe ser el <code class="classname">stream</code> de salida. La función miembro
	<code class="function">fill()</code> de <code class="classname">ostream</code> cambia el
	carácter de relleno usado cuando la anchura del campo de salida,
	determinada por el manipulador <code class="function">setw()</code>, es mayor que
	el necesitado por los datos. Usamos un caracter '0' ya que los meses
	anteriores a Octubre mostrarán un cero en primer lugar, como '09' para
	Septiembre. La funcion <code class="function">fill()</code> también retorna el
	caracter de relleno anterior (que por defecto es un espacio en blanco)
	para que podamos recuperarlo después con el manipulador
	<code class="function">setfill()</code>. Discutiremos los manipuladores en
	profundidad más adelante en este capítulo.
      </p><p>
	Los extractores requieren algo más cuidado porque las cosas
	pueden ir mal con los datos de entrada. La manera de avisar sobre errores
	en el <code class="classname">stream</code> es activar el bit de error del
	<code class="classname">stream</code>, como se muestra a continuación:
      </p><pre class="programlisting">
istream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span>istream<span class="hl opt">&amp;</span> is<span class="hl opt">,</span> Date<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
  is <span class="hl opt">&gt;&gt;</span> d<span class="hl opt">.</span>month<span class="hl opt">;</span>
  <span class="hl kwb">char</span> dash<span class="hl opt">;</span>
  is <span class="hl opt">&gt;&gt;</span> dash<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>dash <span class="hl opt">!=</span> <span class="hl str">'-'</span><span class="hl opt">)</span>
    is<span class="hl opt">.</span><span class="hl kwd">setstate</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>failbit<span class="hl opt">);</span>
  is <span class="hl opt">&gt;&gt;</span> d<span class="hl opt">.</span>day<span class="hl opt">;</span>
  is <span class="hl opt">&gt;&gt;</span> dash<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>dash <span class="hl opt">!=</span> <span class="hl str">'-'</span><span class="hl opt">)</span>
    is<span class="hl opt">.</span><span class="hl kwd">setstate</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>failbit<span class="hl opt">);</span>
  is <span class="hl opt">&gt;&gt;</span> d<span class="hl opt">.</span>year<span class="hl opt">;</span>
  <span class="hl kwa">return</span> is<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>
	Cuando se activa el bit de error en un
	<code class="classname">stream</code>, todas las operaciones posteriores serán
	ignoradas hasta que el <code class="classname">stream</code> sea devuelto a un
	estado correcto (explicado brevemente). Esto es porque el código de arriba
	continua extrayendo incluso is <code class="code">ios::failbit</code> está activado.
	Esta implementación es poco estricta ya que permite espacios en blanco
	entre los numeros y guiones en la cadena de la fecha (por que el operador
	&gt;&gt; ignora los espacios en blanco por defecto cuado lee tipos
	fundamentales). La cadena de fecha a continuación es válida para este
	extractor:
      </p><pre class="programlisting">
<span class="hl str">&quot;08-10-2003&quot;</span>
<span class="hl str">&quot;8-10-2003&quot;</span>
<span class="hl str">&quot;08 - 10 - 2003&quot;</span>
</pre><p>
	Pero estas no:
      </p><pre class="programlisting">
<span class="hl str">&quot;A-10-2003&quot;</span> <span class="hl slc">// No alpha characters allowed</span>
<span class="hl str">&quot;08%10/2003&quot;</span> <span class="hl slc">// Only dashes allowed as a delimiter</span>
</pre><p>
	Discutiremos los estados de los <code class="classname">stream</code>
	en mayor profundidad en la sección 'Manejar errores de
	<code class="classname">stream</code>' después en este capítulo.
      </p></div><div class="sect2" title="5.2.2. Uso común"><div class="titlepage"><div><div><h3 class="title"><a id="idp4077752"></a>5.2.2. Uso común</h3></div></div></div><p>
	Como se ilustraba en el extractor de
	<code class="classname">Date</code>, debe estar alerta por las entradas erróneas.
	Si la entrada produce un valor inesperado, el proceso se tuerce y es
	difícil de recuperar. Además, por defecto, la entrada formateada está
	delimitada por espacios en blanco. Considere que ocurre cuando recogemos
	los fragmentos de código anteriores en un solo programa:
      </p><pre class="programlisting">
<span class="hl slc">//: V2C04:Iosexamp.cpp {RunByHand}</span>
</pre><p>
	y le proporcionamos la siguiente entrada:
      </p><pre class="programlisting">
<span class="hl num">12 1.4</span> c <span class="hl kwa">this</span> is a test
</pre><p>
	esperamos la misma salida que si le hubieramos proporcionado esto:
      </p><pre class="programlisting">
<span class="hl num">12</span>
<span class="hl num">1.4</span>
c
<span class="hl kwa">this</span> is a test
</pre><p>
	pero la salida es algo inesperado
      </p><pre class="programlisting">
i <span class="hl opt">=</span> <span class="hl num">12</span>
f <span class="hl opt">=</span> <span class="hl num">1.4</span>
c <span class="hl opt">=</span> c
buf <span class="hl opt">=</span> <span class="hl kwa">this</span> <span class="hl num">0xc</span>
</pre><p>
	Nótese que <code class="varname">buf</code> solo tiene la primera
	palabra porque la rutina de entrada busca un espacio que delimite la
	entrada, que es el que se encuentra después de 'tihs.' Además, si la
	entrada continua de datos es mayor que el espacio reservado por
	<code class="varname">buf</code>, sobrepasamos los limites del buffer.
      </p><p>
	En la práctica, usualmente deseará obtener la entrada desde
	programas interactivos, una linea cada vez como secuencia de carácteres,
	leerla, y después hacer las conversiones necesarias hasta que estén
	seguras en un buffer. De esta manera no deberá preocuparse por la rutina
	de entrada fallando por datos inesperados.
      </p><p>
	Otra consideración es todo el concepto de interfaz de línea de
	comandos. Esto tenia sentido en el pasado cuando la consola era la única
	interfaz con la máquina, pero el mundo está cambiando rápidamente hacia
	otro donde la interfaz gráfica de usuario (GUI) domina. ¿Cual es el
	sentido de la E/S por consola en este mundo? Esto le da mucho más sentido
	a ignorar <code class="classname">cin </code>en general, salvo para ejemplos
	simples y tests, y hacer los siguientes acercamientos:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	  Si su programa requiere entrada, ¿leer esta entrada desde
	  un fichero? Pronto verá que es remarcablemente fácil usar ficheros con
	  <code class="classname">iostream</code>. <code class="classname">Iostream</code> para
	  ficheros todavia funciona perfectamente con una GUI.
	</p></li><li class="listitem"><p>
	  Leer la entrada sin intentar convertirla, como hemos
	  sugerido. Cuando la entrada es algun sitio donde no podemos arriesgarnos
	  durante la conversión, podemos escanearla de manera segura.
	</p></li><li class="listitem"><p>
	  La salida es diferente. Si está usando una interfaz
	  gráfica, <code class="classname">cout</code> no necesariamente funciona, y usted
	  debe mandarlo a un fichero (que es indéntico a mandarlo a un
	  <code class="classname">cout</code>) o usar los componentes del GUI para mostrar
	  los datos. En cualquier otra situacion, a menudo tiene sentido mandarlo a
	  <code class="classname">cout</code>. En ambos casos, la funciones de formateo de
	  la salida de <code class="classname">iostream</code> son muy útiles.
	</p></li></ol></div><p>
	Otra práctica común ahorra tiempo en compilaciones largas. Consideres, por
	ejemplo, cómo quiere declarar los operadores del stream Date introducidos
	antes en el capítulo en un fichero de cabecera. Usted solo necesita incluir los
	prototipos para las funciones, luego no es necesario incluir la cabecera entera
	de &lt;iostream&gt; en Date.h. La práctica estándar es declarar solo las clases,
	algo como esto:
      </p><pre class="programlisting">
<span class="hl kwc">class</span> ostream<span class="hl opt">;</span>
</pre><p>
	Esta es una vieja tecnica para separar la interfaz de la implementación y
	a menudo la llaman declaración avanzada( y <code class="classname">ostream</code> en este punto debe ser
	considerada un tipo incompleto, ya que la definición de la clase no ha sido vista
	todavia por el compilador).
      </p><p>
	Esto con funcionará asi, igualmente, por dos razones:
      </p><p>
	Las clases stream estan definidas en el espacio de nombres <code class="varname">std</code>.
      </p><p>
	Son plantillas.
      </p><p>
	La declaración correcta debería ser:
      </p><pre class="programlisting">
<span class="hl kwa">namespace</span> std <span class="hl opt">{</span>
  <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">,</span> <span class="hl kwc">class</span> traits <span class="hl opt">=</span> char_traits<span class="hl opt">&lt;</span>charT<span class="hl opt">&gt; &gt;</span>
    <span class="hl kwc">class</span> basic_ostream<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> basic_ostream<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;</span> ostream<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>
	(Como puede ver, como las clase string, las clases stream usan las clases
	de rasgos de caracter mencionadas en el Capítulo 3). Como  puede ser terriblemente
	tedioso darle un tipo a todas las clases stream a las que quiere referenciar, el
	estándar provee una cabecera que lo hace por usted:
      </p><pre class="programlisting">
<span class="hl slc">// Date.h</span>
<span class="hl ppc">#include &lt;iosfwd&gt;</span>

<span class="hl kwc">class</span> Date <span class="hl opt">{</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;,</span>
                                  <span class="hl kwb">const</span> Date<span class="hl opt">&amp;);</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>istream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&gt;&gt;(</span>std<span class="hl opt">::</span>istream<span class="hl opt">&amp;,</span> Date<span class="hl opt">&amp;);</span>
  <span class="hl slc">// Etc.</span>
</pre></div><div class="sect2" title="5.2.3. Entrada orientada a líneas"><div class="titlepage"><div><div><h3 class="title"><a id="idp4094200"></a>5.2.3. Entrada orientada a líneas</h3></div></div></div><p>
	Para recoger la entrada de línea en línea, tiene tres opciones:
      </p><p>
	La función miembre <code class="function">get()</code>
      </p><p>
	La función miembro <code class="function">getline()</code>
      </p><p>
	La función global <code class="function">getline()</code> definida en la cabecera &lt;string&gt;
      </p><p>
	Las primeras dos funciones toman tres parámentros:
      </p><p>
	Un puntero a un buffer de carácters donde se guarda el resultado.
      </p><p>
	El tamaño de este buffer (para no sobrepasarlo).
      </p><p>
	El carácter de finalización, para conocer cuando parar de leer la entrada.
      </p><p>
	El carácter de finalización tiene un valor por defecto de '\n', que es el
	que usted usará usualmente. Ambas funciones almacenan un cero en el buffer
	resultante cuando encuentran el caracter de terminación en la entrada.
      </p><p>
	Entonces, ¿cual es la diferencia? Sutil pero importante:
	<code class="function">get()</code> se detiene cuando vee el delimitador en el
	stream de entrada, pero no lo extrae de <code class="classname">stream</code>
	de entrada. Entonces, si usted hace otro <code class="function">get()</code>
	usando el mismo delimitador, retornará inmediatamente sin ninguna entrada
	contenida. (Presumiblemente, en su lugar usará un delimitador diferente
	en la siguiente sentencia <code class="function">get()</code> o una función de
	entrada diferente.) La función <code class="function">getline()</code>, por el
	contrario, extrae el delimitador del <code class="classname">stream</code> de
	entrada, pero tampoco lo almacena en el buffer resultante.
      </p><p>
	La función <code class="function">getline()</code> definida en &lt;string&gt; es conveniente.
	No es una función miembro, sino una función aislada declarada en el espacio
	de nombres <code class="code">std</code>. Sólo toma dos parámetros que no son por defecto, el
	<code class="classname">stream</code> de entrada y el objeto <code class="classname">string</code>
	para rellenar. Como su propio nombre dice, lee carácteres hasta que encuentra la primera
	aparición del delimitador ('\n' por defecto) y consume y descarta el delimitador.
	La ventaja de esta función es que lo lee dentro del objeto <code class="classname">string</code>,
	así que no se tiene que preocuparse del tamaño del buffer.
      </p><p>
	Generalmente, cuando esta procesando un fichero de texto en el que usted
	quiere leer de línea en línea, usted querra usar una de las funciones
	<code class="function">getline()</code>. Versiones sobrecargadas de <code class="function">get()</code>
      </p><div class="sect3" title="Versiones sobrecargadas de get()"><div class="titlepage"><div><div><h4 class="title"><a id="idp4105048"></a>
	Versiones sobrecargadas de <code class="function">get()</code>
      </h4></div></div></div><p>
	  La función <code class="function">get()</code> también viene en tres
	  versiones sobrecargadas: una sin argumentos que retorna el
	  siguiente carácter usando un valor de retorno
	  <code class="type">int</code>; una que recoge un carácter dentro de su
	  argumento <code class="type">char</code> usando una referencia; y una que
	  almacena directamente dentro del buffer subyacente de otro
	  objeto iostream. Este último se explora después en el
	  capítulo.
	</p></div><div class="sect3" title="Leyendo bytes sin formato"><div class="titlepage"><div><div><h4 class="title"><a id="idp4107472"></a>
	Leyendo bytes sin formato
      </h4></div></div></div><p>
	Si usted sabe exactamente con que esta tratando y quiere mover
	los bytes directamente dentro de una variable, un array, o una
	estructura de memoria, puede usar la función de E/S sin
	formatear <code class="function">read()</code>. El primer argumento
	para esta función es un puntero a la destinación en memoria, y
	el segundo es el número de bytes para leer. Es especialmente
	útil su usted ha almacenado previamente la información a un
	fichero, por ejemplo, en formato binario usando la función
	miembro complementaria <code class="function">write()</code> para el
	<code class="classname">stream</code> de salida (usando el mismo
	compilador, por supuesto). Verá ejemplos de todas estas
	funciones más adelante.
      </p></div></div></div><div class="sect1" title="5.3. Manejo errores de stream"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4110296"></a>5.3. Manejo errores de <code class="classname">stream</code></h2></div></div></div><p>
      El extractor de <code class="classname">Date</code> mostrado antes
      activa el bit de error de un <code class="classname">stream</code> bajo
      ciertas condiciones. ¿Como sabe un usuario que este error ha
      ocurrido? Puede detectar errores del
      <code class="classname">stream</code> llamando a ciertas funciones
      miembro del stream para ver si tenemos un estado de error, o si
      a usted no le preocupa qué tipo de error ha pasado, puede
      evaluar el <code class="filename">stream</code> en un contexto
      Booleano. Ambas técnicas derivan del estado del bit de error de
      un <code class="classname">stream</code>.
    </p><div class="sect2" title="5.3.1. Estados del stream"><div class="titlepage"><div><div><h3 class="title"><a id="idp4112904"></a>5.3.1. Estados del <code class="classname">stream</code></h3></div></div></div><p>
	La clase <code class="classname">ios_base</code>, desde la que
	<code class="classname">ios</code> deriva,<sup>[<a id="idp4113864" href="#ftn.idp4113864" class="footnote">12</a>]</sup>define cuatro banderas
	que puede usar para comprobar el estado de un
	<code class="classname">stream</code>:
      </p><p>
      Bandera
    </p><p>
      Significado
    </p><p>
     <code class="code">badbit</code>
    </p><p>
      Algún error fatal (quizás físico) ha ocurrido. El
      <code class="classname">stream</code> debe considerarse no usable.
    </p><p>
      <code class="code">eofbit</code>
    </p><p>
      Ha ocurrido un final de entrada (ya sea por haber encontrado un final físico de un <code class="classname">stream</code> de fichero o por que el usuario ha terminado el <code class="classname">stream</code> de consola, (usando un Ctrl-Z o Ctrl-D).
    </p><p>
      <code class="code">failbit</code>
    </p><p>
      Una operación de E/S ha fallado, casi seguro que por datos inválidos (p.e. encontrar
      letras cuando se intentaba leer un número). El <code class="classname">stream</code> todavía se
      puede usar. El <code class="code">failbit</code> también se activa cuando ocurre un final de entrada.
    </p><p>
      <code class="code">goodbit</code>
    </p><p>
      Todo va bien; no hay errores. La final de la entrada todavía no ha ocurrido.
    </p><p>
      Puede comprobar si alguna de estas condiciones ha ocurrido
      llamando a la función miembro correspondiente que retorna un
      valor Booleano indicando cual de estas ha sido activada.  La
      función miembro de <code class="classname">stream </code>
      <code class="function">good()</code> retorna cierto si ninguno de los
      otros tres bits se han activado. La función
      <code class="function">eof()</code> retorna cierto si <code class="code">eofbit</code>
      está activado, que ocurre con un intento de leer de un
      <code class="classname">stream</code> que ya no tiene datos
      (generalmente un fichero). Como el final de una entrada ocurre
      en C++ cuando tratamos de leer pasado el final del medio físico,
      <code class="code">failbit</code> también se activa para indicar que los
      datos esperados no han sido correctamente leídos. La función
      <code class="function">fail()</code> retorna cierto si
      <code class="code">failbit</code> o <code class="code">badbit</code> están activados, y
      <code class="function">bad()</code> retorna cierto solo si
      <code class="code">badbit</code> está activado.
    </p><p>
      Una vez alguno de los bit de error de un <code class="classname">stream</code> se activa,
      permanece activo, cosa que no siempre es lo que se quiere. Cuando leemos un fichero,
      usted puede querer colocarse en una posición anterior en el fichero antes de su final.
      Simplemenete moviendo el puntero del fichero no se desactiva el <code class="code">eofbit</code> o
      el <code class="code">failbit</code>; debe hacerlo usted mismo con la función <code class="function">clear()</code>,
      haciendo algo así:
    </p><pre class="programlisting">
myStream<span class="hl opt">.</span><span class="hl kwd">clear</span><span class="hl opt">();</span> <span class="hl slc">// Clears all error bits</span>
</pre><p>
      Después de llamar a <code class="function">clear()</code>,
      <code class="function">good()</code> retornará cierto si es llamada
      inmediatamente. Como vió en el extractor de
      <code class="classname">Date</code> antes, la función
      <code class="function">setstate()</code> activa los bits que usted le
      pasa.¿Eso significa que setstate no afecta a los otros bits? Si
      ya esta activo, permanece activo. Si usted quiere activar
      ciertos bits pero en el mismo momento, desactivar el resto,
      usted puede llamar una versión sobrecargada de
      <code class="function">clear()</code>, pasandole una expresion binaria
      representando los bits que quiere que se activen, así:
    </p><pre class="programlisting">
myStream<span class="hl opt">.</span><span class="hl kwd">clear</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>failbit <span class="hl opt">|</span> ios<span class="hl opt">::</span>eofbit<span class="hl opt">);</span>
</pre><p>
      La mayoría del tiempo usted no estará interesado en comprobar los bits de estado
      del <code class="classname">stream</code> individualmente. Generalmente usted simplemente
      quiere conocer si todo va bien. Ese es el caso cuando quiere leer un fichero del
      principio al final; usted quiere saber simplemente cuando la entrada de datos se
      ha agotado. Puede usar una conversion de la función definida para <code class="type">void*</code>
      que es automáticamente llamada cuando un <code class="classname">stream</code> esta en una
      expresión booleana. Leer un <code class="classname">stream</code> hasta el final de la entrada
      usando este idioma se parece a lo siguiente:
    </p><pre class="programlisting">
<span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwa">while</span><span class="hl opt">(</span>myStream <span class="hl opt">&gt;&gt;</span> i<span class="hl opt">)</span>
  cout <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
</pre><p>
      Recuerde que <code class="function">operator&gt;&gt;()</code> retorna su
      argumento <code class="classname">stream</code>, así que la sentencia
      <code class="code">while</code> anterior comprueba el
      <code class="classname">stream</code> como una expresión booleana. Este
      ejemplo particular asume que el <code class="classname">stream</code> de
      entrada myStream contiene enteros separados por un espacio en
      blanco. La función <code class="function">ios_base::operator
      void*()</code> simplemente llama a
      <code class="function">good()</code> en su <code class="classname">stream</code>
      y retorna el resultado.<sup>[<a id="idp4134536" href="#ftn.idp4134536" class="footnote">13</a>]</sup> Como la mayoría de operaciones de
      <code class="classname">stream</code> retornan su
      <code class="classname">stream</code>, usar ese idioma es conveniente.
    </p></div><div class="sect2" title="5.3.2. Streams y excepciones"><div class="titlepage"><div><div><h3 class="title"><a id="idp4137096"></a>5.3.2. Streams y excepciones</h3></div></div></div><p>
      Los <code class="classname">iostream</code> han existido como parte de
      C++ mucho antes que hubieran excepciones, luego comprobar el
      estado de un <code class="classname">stream</code> manualmente era la
      manera en que se hacia. Para mantener la compatibilidad, este es
      todavía el status quo, pero los modernos
      <code class="classname">iostream</code> pueden lanzar excepciones en su
      lugar. La función miembro de <code class="classname">stream</code>
      <code class="function">exceptions()</code> toma un parámetro
      representando los bits de estado para los que usted quiere
      lanzar la excepcion. Siempre que el stream encuentra este
      estado,este lanza una excepcion de tipo
      <code class="function">std::ios_base::failure</code>, que hereda de
      <code class="function">std::exception</code>.
    </p><p>
      Aunque usted puede disparar una excepción para alguno de los
      cuatro estados de un <code class="classname">stream</code>, no es
      necesariamente una buena idea activar las excepciones para cada
      uno de ellos. Tal como explica el Capítulo uno, se usan las
      excepciones para condiciones verdaderamente excepcionales, ¡pero
      el final de un fichero no solo no es excepcional! ¡Es lo que se
      espera! Por esta razón, solo debe querer activar las excepciones
      para errores representados por <code class="code">badbit</code>, que deberia
      ser como esto:
    </p><pre class="programlisting">
myStream<span class="hl opt">.</span><span class="hl kwd">exceptions</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>badbit<span class="hl opt">);</span>
</pre><p>
      Usted activa las excepciones <code class="classname">stream</code> por <code class="classname">stream</code>, ya que <code class="function">exceptions()</code> es una función miembro para los <code class="classname">streams</code>. La función <code class="function">exceptions()</code> retorna una máscara de bits <sup>[<a id="idp4143848" href="#ftn.idp4143848" class="footnote">14</a>]</sup> (de tipo <code class="classname">iostate</code>, que es un tipo dependiente del compilador convertible a int) indicando que estados de stream causarán excepciones. Si estos estados ya han sido activados, la excepción será lanzada inmediatamente. Por supuesto, si usa excepciones en conexiones a streams, debería estar preparado paracapturarlas, lo que quiere decir que necesita envolver todos los stream bon bloques try que tengan un manejador ios::failure. Muchos programadores encuentran tedioso y simplemente comprueban manualmente donde esperan encontrar errores (ya que, por ejemplo, no esperan encontrar bad() al retornar true la mayoria de veces). Esto es otra razón que tienen los streams para que el lanzamiento de excepciones sea opcional y no por defecto. en cualquier caso, usted peude elegir como quiere manejar los errores de stream. Por las mismas razones que recomendamos el uso de excepciones para el manejo de rrores en otros contextos, lo hacemos aqui.
    </p></div></div><div class="sect1" title="5.4. Iostreams de fichero"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4146624"></a>5.4. Iostreams de fichero</h2></div></div></div><p>
      Manipular ficheros con <code class="classname">iostream</code> es mucho más fácil y seguro
      que usar <code class="code">stdio</code> en C. Todo lo que tiene que hacer es crear un objeto - el
      constructor hace el trabajo. No necesita cerrar el fichero explícitamente (aunque puede,
      usando la función miembro <code class="function">close()</code>) porque el destructor lo cerrará cuando
      el objeto salga del ámbito. Para crear un fichero que por defecto sea de entrada, cree un objeto
      <code class="classname">ifstream</code> . Para crear un fichero que por defecto es de salida, cree un
      objeto <code class="classname">ofstream</code>. Un <code class="classname">fstream</code> puede hacer ambas cosas.
    </p><p>
      Las clases de <code class="classname">stream</code> de fichero encajan dentro de las clases <code class="classname">iostream</code> como
      se muestra en la siguiente figura:
    </p><p>
      Como antes, las clases que usted usa en realidad son especializaciones de
      plantillas definidas por definiciones de tipo. Por ejemplo, <code class="classname">ifstream</code>,
      que procesa ficheros de <code class="type">char</code>, es definida como:
    </p><pre class="programlisting">
<span class="hl kwc">typedef</span> basic_ifstream<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;</span> ifstream<span class="hl opt">;</span>
</pre><div class="sect2" title="5.4.1. Un ejemplo de procesado de fichero."><div class="titlepage"><div><div><h3 class="title"><a id="idp4151216"></a>5.4.1. Un ejemplo de procesado de fichero.</h3></div></div></div><p>
	Aqui tiene un ejemplo que muestra algunas de las características discutidas antes. Nótese
	que la inclusión de &lt;fstream&gt; para delarar las clases de fichero de E/S. Aunque en muchas
	plataformas esto también incluye &lt;iostream&gt; automáticamente, los compiladores no están
	obligados a hacer esto. Si usted quiere compatibilidad, incluya siempre ambas cabeceras.
      </p><div class="example"><a id="idp4152256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Strfile.cpp</span>
<span class="hl slc">// Stream I/O with files;</span>
<span class="hl slc">// The difference between get() &amp; getline().</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span> <span class="hl slc">// Buffer size;</span>
  <span class="hl kwb">char</span> buf<span class="hl opt">[</span>SZ<span class="hl opt">];</span>
  <span class="hl opt">{</span>
    ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Strfile.cpp&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Read</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Strfile.cpp&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Verify open</span>
    ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;Strfile.out&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Write</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>out<span class="hl opt">,</span> <span class="hl str">&quot;Strfile.out&quot;</span><span class="hl opt">);</span>
    <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> <span class="hl slc">// Line counter</span>

    <span class="hl slc">// A less-convenient approach for line input:</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>in<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> SZ<span class="hl opt">)) {</span> <span class="hl slc">// Leaves \n in input</span>
      in<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span> <span class="hl slc">// Throw away next character (\n)</span>
      cout <span class="hl opt">&lt;&lt;</span> buf <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Must add \n</span>
      <span class="hl slc">// File output just like standard I/O:</span>
      out <span class="hl opt">&lt;&lt;</span> i<span class="hl opt">++ &lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> buf <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> <span class="hl slc">// Destructors close in &amp; out</span>

  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Strfile.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Strfile.out&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// More convenient line input:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>in<span class="hl opt">.</span><span class="hl kwd">getline</span><span class="hl opt">(</span>buf<span class="hl opt">,</span> SZ<span class="hl opt">)) {</span> <span class="hl slc">// Removes \n</span>
    <span class="hl kwb">char</span><span class="hl opt">*</span> cp <span class="hl opt">=</span> buf<span class="hl opt">;</span>
    <span class="hl kwa">while</span><span class="hl opt">(*</span>cp <span class="hl opt">!=</span> <span class="hl str">':'</span><span class="hl opt">)</span>
      <span class="hl opt">++</span>cp<span class="hl opt">;</span>
    cp <span class="hl opt">+=</span> <span class="hl num">2</span><span class="hl opt">;</span> <span class="hl slc">// Past &quot;: &quot;</span>
    cout <span class="hl opt">&lt;&lt;</span> cp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Must still add \n</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.5. C04/Strfile.cpp</strong></p></div><br class="example-break" /><p>
	La creación tanto del ifstream como del ofstream están seguidas de un
	<code class="function">assure()</code> para garantizar que el fichero ha sido abierto
	exitosamente. El objeto resultante, usado en una situación donde el compilador
	espera un resultado booleano, produce un valor que indica éxito o fracaso.
      </p><p>
	El primer <code class="code">while</code> demuestra el uso de dos formas de la función
	<code class="function">get()</code>. La primera toma los carácteres dentro de un buffer y pone
	un delimitador cero en el buffer cuando bien SZ-1 carácteres han sido leidos o bien el
	tercer argumento (que por defecto es '\n') es encontrado. La función <code class="function">get()</code>
	deja el carácter delimitador en el <code class="classname">stream</code> de entrada, así que este
	delimitador debe ser eliminado via <code class="function">in.get()</code> usando la forma de
	<code class="function">get()</code> sin argumentos. Puede usar tambien la función miembro
	<code class="function">ignore()</code>, que tiene dos parámetros por defecto. El primer argumento es el
	número de carácteres para descartar y por defecto es uno. El segundo argumento es el carácter
	en el que <code class="function">ignore()</code> se detiene (después de extraerlo) y por defecto es EOF.
      </p><p>
	A continuación, se muestran dos sentencias de salida
	similares: una hacia <code class="classname">cout</code> y la otra al
	fichero de salida. Nótese la conveniencia aquí - no necesita
	preocuparse del tipo de objeto porque las sentencias de
	formateo trabajan igual con todos los objetos
	<code class="classname">ostream</code>.  El primero hace eco de la
	linea en la salida estándar, y el segundo escribe la línea
	hacia el fichero de salida e incluye el número de línea.
      </p><p>
	Para demostrar <code class="function">getline()</code>, abra el fichero recién creado y quite los números de linea.
	Para asegurarse que el fichero se cierra correctamente antes de abrirlo para la lectura, usted tiene dos
	opciones. Puede envolver la primera parte del programa con llaves para forzar que el objeto <code class="varname">out</code>
	salga del ámbito, llamando así al destructor y cerrando el fichero, que es lo que se hace aquí. Tambien puede l
	lamar a <code class="function">close()</code> para ambos ficheros; si hace esto, puede despues rehusar el objeto de entrada
	llamando a la función miembro <code class="function">open()</code>.
      </p><p>
	El segundo <code class="code">while</code> muestra como <code class="function">getline()</code> borra el caracter terminador
	(su tercer argumento, que por defecto es '\n') del <code class="classname">stream</code> de entrada cuando este
	es encontrado. Aunque <code class="function">getline()</code>, como <code class="function">get()</code>, pone un cero en
	el buffer, este todavía no inserta el carácter de terminación.
      </p><p>
	Este ejemplo, así como la mayoría de ejemplos en este capítulo, asume que cada llamada a alguna sobrecarga
	de <code class="function">getline()</code> encontrará un carácter de nueva línea. Si este no es el caso, la estado
	<code class="code">eofbit</code> del <code class="classname">stream</code> será activado y la llamada a <code class="function">getline()</code>
	retornará falso, causando que el programa pierda la última línea de la entrada.
      </p></div><div class="sect2" title="5.4.2. Modos de apertura"><div class="titlepage"><div><div><h3 class="title"><a id="idp4166896"></a>5.4.2. Modos de apertura</h3></div></div></div><p>
	Puede controlar la manera en que un fichero es abierto sobreescribiendo los argumentos por defecto del
	constructor. La siguiente tabla muestra las banderas que controlan el modo de un fichero:
      </p><p>
	Bandera
      </p><p>
	Función
      </p><p>
	<code class="varname">ios::in</code>
      </p><p>
	Abre el fichero de entrada. Use esto como un modo de apertura para un <code class="classname">ofstream</code> para
	prevenir que un fichero existente sea truncado.
      </p><p>
	<code class="varname">ios::out</code>
      </p><p>
	Abre un fichero de salida. Cuando es usado por un <code class="classname">ofstream</code> sin <code class="varname">ios::app</code>,
	<code class="varname">ios::ate</code> o <code class="varname">ios::in</code>, <code class="varname">ios::trunc</code> es implicado.
      </p><p>
	<code class="varname">ios::app</code>
      </p><p>
	Abre un fichero de salida para solo añadir .
      </p><p>
	<code class="varname">ios::ate</code>
      </p><p>
	Abre un fichero existente (ya sea de entrada o salida) y busca el final.
      </p><p>
	<code class="varname">ios::trunc</code>
      </p><p>
	Trunca el fichero antiguo si este ya existe.
      </p><p>
	<code class="varname">ios::binary</code>
      </p><p>
	Abre un fichero en modo binario. Por defecto es en modo texto.
      </p><p>
	Puede combinar estas banderas usando la operación <code class="code">or</code> para bits
      </p><p>
	El flag binario, aun siendo portable, solo tiene efecto en algunos sistemas no UNIX, como sistemas operativos
	derivados de MS-DOS, que tiene convenciones especiales para el almacenamiento de delimitadores de final de línea.
	Por ejemplo, en sistemas MS-DOS en modo texto (el cual es por defecto), cada vez que usted inserta un nuevo
	carácter de nueva línea ('\n'), el sistema de ficheros en realidad inserta dos carácteres, un par retorno de
	carro/fin de línea (CRLF), que es el par de carácteres ASCII 0x0D y 0x0A. En sentido opuesto, cuando usted lee este
	fichero de vuelta a memoria en modo texto, cada ocurrencia de este par de bytes causa que un '\n' sea enviado al
	programa en su lugar. Si quiere sobrepasar este procesado especial, puede abrir el fichero en modo binario. El modo
	binario no tiene nada que ver ya que usted puede escribir bytes sin formato en un fichero - siempre puede (llamando a
	<code class="function">write()</code>). Usted debería, por tanto, abrir un fichero en modo binario cuando vaya a usar
	<code class="function">read()</code> o <code class="function">write()</code>, porque estas funciones toman un contador de bytes como
	parámetro. Tener carácteres extra '\r' estropeará su contador de bytes en estas instancias. Usted también puede abrir
	un fichero en formato binario si va a usar comandos de posicionamiento en el <code class="classname">stream</code> que se
	discuten más adelante.
      </p><p>
	Usted puede abrir un fichero tanto para entrada como salida declarando un objeto <code class="classname">fstream</code>.
	cuando declara un objeto <code class="classname">fstream</code>, debe usar suficientes banderas de modos de apertura
	mencionados antes para dejar que el sistema de ficheros sepa si quiere leer, escribir, o ambos. Para cambiar de
	salida a entrada, necesita o bien limpiar el <code class="classname">stream</code> o bien cambiar la posición en el fichero.
	Para cambiar de entrada a salida, cambie la posicion en el fichero. Para crear un fichero usando un objeto
	<code class="classname">fstream</code>, use la bandera de modo de apertura <code class="code">ios::trunc</code> en la llamada al constructor
	para usar entrada y salida.
      </p></div></div><div class="sect1" title="5.5. Almacenamiento de iostream"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4178936"></a>5.5. Almacenamiento de <code class="classname">iostream</code></h2></div></div></div><p>
      Las buenas prácticas de diseño dictan que, cuando cree una nueva clase, debe esforzarse
      en ocultar los detalles de la implementación subyacente tanto como sea posible al usuario
      de la clase. Usted le muestra solo aquello que necesita conocer y el resto se hace privado
      para evitar confusiones. Cuando usamos insertadores y extractores, normalmente usted no conoce
      o tiene cuidado con los bytes que se consumen o se producen, ya que usted está tratando con
      E/S estándar, ficheros, memoria, o alguna nueva clase o dispositivo creado.
    </p><p>
      Llega un momento, no obstante, en el que es importante comunicar
      con la parte del <code class="classname">iostream</code> que produce o
      consume bytes. Para proveer esta parte con una interfaz común y
      esconder todavía su implementación subyacente, la librería
      estándar la abstrae dentro de su clase, llamada
      <code class="classname">streambuf</code>. Cada objeto
      <code class="classname">iostream</code> contiene un puntero a alguna
      clase de <code class="classname">streambuf</code>. (El tipo depende de
      que se esté tratando con E/S estándar, ficheros, memoria,
      etc.). Puede acceder al <code class="classname">streambuf</code>
      directamente; por ejemplo, puede mover bytes sin formatear
      dentro y fuera del <code class="classname">streambuf</code> sin
      formatearlos a través de la encapsulación del
      <code class="classname">iostream</code>.  Esto es posible llamando a las
      funciones miembro del objeto <code class="classname">streambuf</code>.
    </p><p>
      Actualmente, la cosa más importante que debe conocer es que cada
      objeto <code class="classname">iostream</code> contiene un puntero a un
      objeto <code class="classname">streambuf</code>, y el objeto
      <code class="classname">streambuf</code> tiene algunas funciones miembro
      que puede llamar si es necesario. Para ficheros y
      <code class="classname">streams</code> de string, hay tipos
      especializados de buffers de <code class="classname">stream</code>, como
      ilustra la figura siguiente:
    </p><p>
      Para permitirle el acceso al <code class="classname">streambuf</code>, cada objeto <code class="classname">iostream</code> tiene una
      función miembro llamada <code class="function">rdbuf()</code> que retorna el puntero a un objeto <code class="classname">streambuf</code>.
      De esta manera usted puede llamar cualquier función miembro del <code class="classname">streambuf</code> subyacente. No obstante,
      una de las cosas más interesantes que usted puede hacer con el puntero al <code class="classname">streambuf</code> es conectarlo
      con otro objeto <code class="classname">iostream</code> usando el operador &lt;&lt;. Esto inserta todos los carácteres del objeto
      dentro del que está al lado izquierdo del &lt;&lt;. Si quiere mover todos los carácteres de un <code class="classname">iostream</code>
      a otro, no necesita ponerse con el tedioso (y potencialmente inclinado a errores de código) proceso de leer de carácter
      por carácter o línea por línea. Este es un acercamiento mucho más elegante.
    </p><p>
      Aqui está un programa muy simple que abre un fichero y manda el contenido a la salida estándar (similar al ejemplo previo):
    </p><div class="example"><a id="idp4188464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Stype.cpp</span>
<span class="hl slc">// Type a file to standard output.</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Stype.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Stype.cpp&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> in<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span> <span class="hl slc">// Outputs entire file</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.6. C04/Stype.cpp</strong></p></div><br class="example-break" /><p>
      Un ifstream se crea usando el fichero de código fuente  para este programa como argumento. La función
      <code class="function">assure()</code> reporta un fallo si el fichero no puede ser abierto. Todo el trabajo pasa
      realmente en la sentencia
    </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> in<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
</pre><p>
      que manda todo el contenido del fichero a <code class="classname">cout</code>. No solo es un código más sucinto,
      a menudo es más eficiente que mover los byte de uno en uno.
    </p><p>
      Una forma de <code class="function">get()</code> escribe directamente dentro del <code class="classname">streambuf</code>
      de otro objeto. El primer argumento es una referencia al <code class="classname">streambuf</code> de destino, y el
      segundo es el carácter de terminación ('\n' por defecto), que detiene la función <code class="function">get()</code>.
      Así que existe todavía otra manera de imprimir el resultado de un fichero en la salida estándar:
    </p><div class="example"><a id="idp4193584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Sbufget.cpp</span>
<span class="hl slc">// Copies a file to standard output.</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Sbufget.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">);</span>
  streambuf<span class="hl opt">&amp;</span> sb <span class="hl opt">= *</span>cout<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(!</span>in<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">(</span>sb<span class="hl opt">).</span><span class="hl kwd">eof</span><span class="hl opt">()) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>in<span class="hl opt">.</span><span class="hl kwd">fail</span><span class="hl opt">())</span>          <span class="hl slc">// Found blank line</span>
      in<span class="hl opt">.</span><span class="hl kwd">clear</span><span class="hl opt">();</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwb">char</span><span class="hl opt">(</span>in<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">());</span> <span class="hl slc">// Process '\n'</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.7. C04/Sbufget.cpp</strong></p></div><br class="example-break" /><p>
      La función <code class="function">rdbuf()</code> retorna un puntero, que tiene que ser desreferenciado para satisfacer las
      necesidades de la función para ver el objeto. Los buffers de <code class="classname">stream</code> no estan pensados para
      ser copiados (no tienen contructor de copia), por lo que definimos <code class="varname">sb</code> como una referencia al buffer
      de <code class="classname">stream</code> de <code class="classname">cout</code>. Necesitamos las llamadas a <code class="function">fail()</code>
      y <code class="function">clear()</code> en caso de que el fichero de entrada tenga una línea en blanco (este la tiene). Cuando
      esta particular versión sobrecargada de <code class="function">get()</code> vee dos carácteres de nueva línea en una fila (una
      evidencia de una línea en blanco), activa el bit de error del <code class="classname">stream</code> de entrada, asi que se debe
      llamar a <code class="function">clear()</code> para resetearlo y que así el <code class="classname">stream</code> pueda continuar siendo
      leído. La segunda llamada a <code class="function">get()</code> extrae y hace eco de cualquier delimitador de nueva línea. (Recuerde,
      la función <code class="function">get()</code> no extrae este delimitador como sí lo hace <code class="function">getline()</code>).
    </p><p>
      Probablemente no necesitará usar una técnica como esta a menudo, pero es bueno saber que existe.<sup>[<a id="idp4200760" href="#ftn.idp4200760" class="footnote">15</a>]</sup>
    </p></div><div class="sect1" title="5.6. Buscar en iostreams"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4201664"></a>5.6. Buscar en iostreams</h2></div></div></div><p>
      Cada tipo de iostream tiene el concepto de donde está el 'siguiente' carácter que proviene de (si es un
      <code class="classname">istream</code>) o que va hacia (si es un <code class="classname">ostream</code>). En algunas
      situaciones, puede querer mover la posición en este <code class="classname">stream</code>. Puede hacer esto usando
      dos modelos: uno usa una localización absoluta en el stream llamada <code class="varname">streampos</code>; el segundo
      trabaja como las funciones <code class="function">fseek()</code> de la librería estándar de C para un fichero y
      se mueve un número dado de bytes desde el principio, final o la posición actual en el fichero.
    </p><p>
      El acercamiento de <code class="classname">streampos</code> requiere que primero llame una función 'tell':(
      <code class="function">tellp()</code> para un <code class="classname">ostream</code> o <code class="function">tellg()</code> para
      un <code class="classname">istream</code>. (La 'p' se refiere a 'put pointer' y la 'g' se refiere a 'get pointer').
      Esta función retorna un <code class="classname">streampos</code> que puede usar después en llamadas a
      <code class="function">seekp()</code> para un <code class="classname">ostream</code> o <code class="function">seekg()</code> para un
      <code class="classname">ostream</code> cuando usted quiere retornar a la posición en el <code class="classname">stream</code>.
    </p><p>
      La segunda aproximación es una búsqueda relativa y usa versiones sobrecargadas de <code class="function">seekp()</code> y
      <code class="function">seekg()</code>. El primer argumento es el número de carácteres a mover: puede ser positivo o
      negativo. El segundo argumento es la dirección desde donde buscar:
    </p><p>
      <code class="code">ios::beg</code>
    </p><p>
      Desde el principio del <code class="classname">stream</code>
    </p><p>
      <code class="code">ios::cur</code>
    </p><p>
      Posición actual del <code class="classname">stream</code>
    </p><p>
      <code class="code">ios::end</code>
    </p><p>
      Desde el principio del <code class="classname">stream</code>
    </p><p>
      Aquí un ejemplo que muestra el movimiento por un fichero, pero recuerde, no esta limitado a buscar en ficheros
      como lo está con <code class="code">stdio</code> de C. Con C++, puede buscar en cualquier tipo de <code class="classname">iostream</code>
      (aunque los objetos <code class="classname">stream</code> estándar, como <code class="classname">cin</code> y <code class="classname">cout</code>,
      lo impiden explícitamente):
    </p><div class="example"><a id="idp4212992"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Seeking.cpp</span>
<span class="hl slc">// Seeking in iostreams.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> STR_NUM <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">,</span> STR_LEN <span class="hl opt">=</span> <span class="hl num">30</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span> origData<span class="hl opt">[</span>STR_NUM<span class="hl opt">][</span>STR_LEN<span class="hl opt">] = {</span>
    <span class="hl str">&quot;Hickory dickory dus. . .&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;Are you tired of C++?&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;Well, if you have,&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;That's just too bad,&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;There's plenty more for us!&quot;</span>
  <span class="hl opt">};</span>
  <span class="hl kwb">char</span> readData<span class="hl opt">[</span>STR_NUM<span class="hl opt">][</span>STR_LEN<span class="hl opt">] = {{</span> <span class="hl num">0</span> <span class="hl opt">}};</span>
  ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;Poem.bin&quot;</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>out <span class="hl opt">|</span> ios<span class="hl opt">::</span>binary<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>out<span class="hl opt">,</span> <span class="hl str">&quot;Poem.bin&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> STR_NUM<span class="hl opt">;</span> i<span class="hl opt">++)</span>
    out<span class="hl opt">.</span><span class="hl kwd">write</span><span class="hl opt">(</span>origData<span class="hl opt">[</span>i<span class="hl opt">],</span> STR_LEN<span class="hl opt">);</span>
  out<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Poem.bin&quot;</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>in <span class="hl opt">|</span> ios<span class="hl opt">::</span>binary<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Poem.bin&quot;</span><span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">],</span> STR_LEN<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">],</span> <span class="hl str">&quot;Hickory dickory dus. . .&quot;</span><span class="hl opt">)</span>
    <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Seek -STR_LEN bytes from the end of file</span>
  in<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(-</span>STR_LEN<span class="hl opt">,</span> ios<span class="hl opt">::</span>end<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">],</span> STR_LEN<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">],</span> <span class="hl str">&quot;There's plenty more for us!&quot;</span><span class="hl opt">)</span>
    <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Absolute seek (like using operator[] with a file)</span>
  in<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">3</span> <span class="hl opt">*</span> STR_LEN<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">],</span> STR_LEN<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">],</span> <span class="hl str">&quot;That's just too bad,&quot;</span><span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Seek backwards from current position</span>
  in<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(-</span>STR_LEN <span class="hl opt">*</span> <span class="hl num">2</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>cur<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">],</span> STR_LEN<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">],</span> <span class="hl str">&quot;Well, if you have,&quot;</span><span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl slc">// Seek from the begining of the file</span>
  in<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">1</span> <span class="hl opt">*</span> STR_LEN<span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">],</span> STR_LEN<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>readData<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">],</span> <span class="hl str">&quot;Are you tired of C++?&quot;</span><span class="hl opt">)</span>
    <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.8. C04/Seeking.cpp</strong></p></div><br class="example-break" /><p>
      Este programa escribe un poema a un fichero usando un <code class="classname">stream</code> de salida binaria. Como
      reabrimos como un <code class="classname">ifstream</code>, usamos <code class="function">seekg()</code> para posicionar el
      'get pointer'. Como puede ver, puede buscar desde el principio o el final del archivo o desde la posición actual
      del archivo. Obviamente, debe proveer un número positivo para mover desde el principio del archivo y un número
      negativo para mover hacia atrás.
    </p><p>
      Ahora que ya conoce el <code class="classname">streambuf</code> y como buscar, ya puede entender un método alternativo
      (aparte de usar un objeto <code class="classname">fstream</code>) para crear un objeto <code class="classname">stream</code> que
      podrá leer y escribir en un archivo. El siguiente código crea un <code class="classname">ifstream</code> con banderas
      que dicen que es un fichero de entrada y de salida. Usted no puede escribir en un <code class="classname">ifstream</code>,
      así que necesita crear un <code class="classname">ostream</code> con el buffer subyacente del <code class="classname">stream</code>:
    </p><pre class="programlisting">
ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;filename&quot;</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>in <span class="hl opt">|</span> ios<span class="hl opt">::</span>out<span class="hl opt">);</span>
ostream <span class="hl kwd">out</span><span class="hl opt">(</span>in<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">());</span>
</pre><p>
      Debe estar preguntándose que ocurre cuando usted lee en uno de estos objetos. Aqui tiene un ejemplo:
    </p><div class="example"><a id="idp4222656"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Iofile.cpp</span>
<span class="hl slc">// Reading &amp; writing one file.</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Iofile.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Iofile.cpp&quot;</span><span class="hl opt">);</span>
  ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;Iofile.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>out<span class="hl opt">,</span> <span class="hl str">&quot;Iofile.out&quot;</span><span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> in<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span> <span class="hl slc">// Copy file</span>
  in<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  out<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  <span class="hl slc">// Open for reading and writing:</span>
  ifstream <span class="hl kwd">in2</span><span class="hl opt">(</span><span class="hl str">&quot;Iofile.out&quot;</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>in <span class="hl opt">|</span> ios<span class="hl opt">::</span>out<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in2<span class="hl opt">,</span> <span class="hl str">&quot;Iofile.out&quot;</span><span class="hl opt">);</span>
  ostream <span class="hl kwd">out2</span><span class="hl opt">(</span>in2<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> in2<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>  <span class="hl slc">// Print whole file</span>
  out2 <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Where does this end up?&quot;</span><span class="hl opt">;</span>
  out2<span class="hl opt">.</span><span class="hl kwd">seekp</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  out2 <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;And what about this?&quot;</span><span class="hl opt">;</span>
  in2<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> in2<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.9. C04/Iofile.cpp</strong></p></div><br class="example-break" /><p>
      Las primeras cinco líneas copian el código fuente de este programa en un fichero llamado iofile.out
      y después cierra los ficheros. Esto le da un texto seguro con el que practicar. Entonces, la técnica
      antes mencionada se usa para crear dos objetos que leen y escriben en el mismo fichero. En
      <code class="code">cout &lt;&lt; in2.rebuf()</code>, puede ver como puntero 'get' es inicializado al principio del fichero.
      El puntero 'put', en cambio, se coloca en el final del fichero para que 'Where does this end up' aparezca
      añadido al fichero. No obstante, si el puntero 'put' es movido al principio con un <code class="function">seekp()</code>,
      todo el texto insertado sobreescribe el existente. Ambas escrituras pueden verse cuando el puntero 'get'
      se mueve otra vez al principio con <code class="function">seekg()</code>, y el fichero se muestra. El fichero es
      automáticamente guardado cuando <code class="varname">out2</code> sale del ámbito y su destructor es invocado.
    </p></div><div class="sect1" title="5.7. Iostreams de string"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4227208"></a>5.7. Iostreams de <code class="classname">string</code></h2></div></div></div><p>
      Un <code class="classname">stream</code> de cadena funciona directamente en memoria en vez de con ficheros o la salida
      estándar. Usa las mismas funciones de lectura y formateo que usó con <code class="classname">cin</code> y
      <code class="classname">cout</code> para manipular bits en memoria. En ordenadores antiguos, la memoria se refería al
      núcleo, con lo que este tipo de funcionalidad se llama a menudo formateo en el núcleo.
    </p><p>
      Los nombres de clases para <code class="classname">streams</code> de cadena son una copia de los <code class="classname">streams</code> de
      ficheros. Si usted quiere crear un <code class="classname">stream</code> de cadena para extraer carácteres de él, puede crear un
      <code class="classname">istringstream</code>. Si quiere poner carácteres en un <code class="classname">stream</code> de cadena, puede crear
      un <code class="classname">ostringstream</code>. Todas las declaraciones para <code class="classname">streams</code> de cadena están en la
      cabecera estándar &lt;sstream&gt;. Como es habitual, hay plantillas de clases dentro de la jerarquia de los
      <code class="classname">iostreams</code>, como se muestra en la siguiente figura:
    </p><div class="sect2" title="5.7.1. Streams de cadena de entrada"><div class="titlepage"><div><div><h3 class="title"><a id="idp4231704"></a>5.7.1. Streams de cadena de entrada</h3></div></div></div><p>
	Para leer de un <code class="classname">string</code> usando
	operaciones de <code class="classname">stream</code>, cree un objeto
	<code class="classname">istringstream</code> inicializado con el
	<code class="classname">string</code>. El siguiente programa muestra
	como usar un objeto <code class="classname">istringstream</code>:
      </p><div class="example"><a id="idp4233280"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Istring.cpp</span>
<span class="hl slc">// Input string streams.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>  <span class="hl slc">// For fabs()</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;limits&gt;</span> <span class="hl slc">// For epsilon()</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  istringstream <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;47 1.414 This is a test&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">double</span> f<span class="hl opt">;</span>
  s <span class="hl opt">&gt;&gt;</span> i <span class="hl opt">&gt;&gt;</span> f<span class="hl opt">;</span> <span class="hl slc">// Whitespace-delimited input</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>i <span class="hl opt">==</span> <span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl kwb">double</span> relerr <span class="hl opt">= (</span><span class="hl kwd">fabs</span><span class="hl opt">(</span>f<span class="hl opt">) -</span> <span class="hl num">1.414</span><span class="hl opt">) /</span> <span class="hl num">1.414</span><span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>relerr <span class="hl opt">&lt;=</span> numeric_limits<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;::</span><span class="hl kwd">epsilon</span><span class="hl opt">());</span>
  string buf2<span class="hl opt">;</span>
  s <span class="hl opt">&gt;&gt;</span> buf2<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>buf2 <span class="hl opt">==</span> <span class="hl str">&quot;This&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span> <span class="hl slc">// &quot; is a test&quot;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.10. C04/Istring.cpp</strong></p></div><br class="example-break" /><p>
	Puede ver que es un acercamiento más flexible y general para
	transformar cadenas de carácteres para valores con tipo que la
	librería de funciones del estándar de C, como
	<code class="function">atof()</code> o <code class="function">atoi()</code>,
	aunque esta última puede ser más eficaz para las conversiones
	individuales.
      </p><p>
	En la expresión <code class="code">s &gt;&gt; i &gt;&gt; f</code>, el
	primer número se extrae en <code class="varname">i</code>, y en el
	segundo en <code class="varname">f</code>. Este no es 'el primer
	conjunto de carácteres delimitado por espacios en blanco' por
	que depende del tipo de datos que está siendo extraído. Por
	ejemplo, si la cadena fuera '1.414 47 This is a test',
	entonces <code class="varname">i</code> tomaría el valor 1 porque la
	rutina de entrada se pararía en el punto decimal. Entonces
	<code class="varname">f</code> tomaría 0.414. Esto puede ser muy útil i
	si quiere partir un número de coma flotante entre la parte
	entera y la decimal. De otra manera parecería un error.  El
	segundo <code class="function">assert()</code> calcula el error
	relativo entre lo que leemos y lo que esperamos; siempre es
	mejor hacer esto que comparar la igualdad de números de coma
	flotante. La constante devuelta por
	<code class="function">epsilon()</code>, definida en &lt;limits&gt;,
	representa la epsilon de la máquina para números de doble
	precisión, el cual es la mejor tolerancia que se puede esperar
	para satisfacer las comparaciones de double.<sup>[<a id="idp4240024" href="#ftn.idp4240024" class="footnote">16</a>]</sup>.
     </p><p>
	Como debe haber supuesto, <code class="varname">buf2</code> no toma el
	resto del <code class="classname">string</code>, simplemente la
	siguiente palabra delimitada por espacios en blanco. En
	general, el mejor usar el extractor en
	<code class="classname">iostreams</code> cuando usted conoce
	exactamente la secuencia de datos en el
	<code class="classname">stream</code> de entrada y los convierte a
	algún otro tipo que un <code class="classname">string</code> de
	carácteres. No obstante, si quiere extraer el resto del
	<code class="classname">string</code> de una sola vez y enviarlo a
	otro <code class="classname">iostream</code>, puede usar
	<code class="function">rdbuf()</code> como se muestra.
      </p><p>
	Para probar el extractor de <code class="classname">Date</code> al
	principio de este capítulo, hemos usado un
	<code class="classname">stream</code> de cadena de entrada con el
	siguiente programa de prueba:
      </p><div class="example"><a id="idp4244088"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:DateIOTest.cpp</span>
<span class="hl slc">//{L} ../C02/Date</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../C02/Date.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">testDate</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  istringstream <span class="hl kwd">os</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  Date d<span class="hl opt">;</span>
  os <span class="hl opt">&gt;&gt;</span> d<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>os<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> d <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">else</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;input error with</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">testDate</span><span class="hl opt">(</span><span class="hl str">&quot;08-10-2003&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">testDate</span><span class="hl opt">(</span><span class="hl str">&quot;8-10-2003&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">testDate</span><span class="hl opt">(</span><span class="hl str">&quot;08 - 10 - 2003&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">testDate</span><span class="hl opt">(</span><span class="hl str">&quot;A-10-2003&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">testDate</span><span class="hl opt">(</span><span class="hl str">&quot;08%10/2003&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.11. C04/DateIOTest.cpp</strong></p></div><br class="example-break" /><p>
	Cada literal de cadena en <code class="function">main()</code> se pasa
	por referencia a <code class="function">testDate()</code>, que a su vez
	lo envuelve en un <code class="classname">istringstream</code> con lo
	que podemos probar el extractor de
	<code class="classname">stream</code> que escribimos para los objetos
	<code class="classname">Date</code>. La función
	<code class="function">testDate()</code> también empieza por probar el
	insertador, <code class="function">operator&lt;&lt;()</code>.
      </p></div><div class="sect2" title="5.7.2. Streams de cadena de salida"><div class="titlepage"><div><div><h3 class="title"><a id="idp4248464"></a>5.7.2. Streams de cadena de salida</h3></div></div></div><p>
	Para crear un stream de cadena de salida, simplemente cree un
	objeto ostringstream, que maneja un buffer de carácteres
	dinamicamente dimensionado para guardar cualquier cosas que
	usted inserte. Para tomar el resultado formateado como un
	objeto de string, llame a la función miembro setr(). Aqui
	tiene un ejemplo:
      </p><div class="example"><a id="idp4249640"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Ostring.cpp {RunByHand}</span>
<span class="hl slc">// Illustrates ostringstream.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;type an int, a float and a string: &quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">float</span> f<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> i <span class="hl opt">&gt;&gt;</span> f<span class="hl opt">;</span>
  cin <span class="hl opt">&gt;&gt;</span> ws<span class="hl opt">;</span> <span class="hl slc">// Throw away white space</span>
  string stuff<span class="hl opt">;</span>
  <span class="hl kwd">getline</span><span class="hl opt">(</span>cin<span class="hl opt">,</span> stuff<span class="hl opt">);</span> <span class="hl slc">// Get rest of the line</span>
  ostringstream os<span class="hl opt">;</span>
  os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;integer = &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;float = &quot;</span> <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;string = &quot;</span> <span class="hl opt">&lt;&lt;</span> stuff <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  string result <span class="hl opt">=</span> os<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> result <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.12. C04/Ostring.cpp</strong></p></div><br class="example-break" /><p>
	Esto es similar al ejemplo Istring.cpp anterior que pedía un
	<code class="type">int</code> y un <code class="type">float</code>. A continueación una
	simple ejecución (la entrada por teclado está escrita en
	negrita).
      </p><pre class="screen">
type an int, a float and a string: FIXME:10 20.5 the end
integer = 10
float = 20.5
string = the end
</pre><p>
	Puede ver que, como otros <code class="classname">stream</code> de
	salida, puede usar las herramientas ordinarias de formateo,
	como el operador &lt;&lt; y <code class="function">endl</code>, para
	enviar bytes hacia el <code class="classname">ostringstream</code>. La
	función <code class="function">str()</code> devuelve un nuevo objeto
	<code class="classname">string</code> cada vez que usted la llama con
	lo que el <code class="classname">stringbuf</code> contenido permanece
	inalterado.
      </p><p>
	En el capítulo previo, presentamos un programa,
	HTMLStripper.cpp, que borraba todas las etiqietas HTML y los
	códigos especiales de un fichero de texto. Como prometíamos,
	aqui está una versión más elegante usando
	<code class="classname">streams</code> de cadena.
      </p><div class="example"><a id="idp4255496"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:HTMLStripper2.cpp {RunByHand}</span>
<span class="hl slc">//{L} ../C03/ReplaceAll</span>
<span class="hl slc">// Filter to remove html tags and markers.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../C03/ReplaceAll.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

string<span class="hl opt">&amp;</span> <span class="hl kwd">stripHTMLTags</span><span class="hl opt">(</span>string<span class="hl opt">&amp;</span> s<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>runtime_error<span class="hl opt">) {</span>
  <span class="hl kwb">size_t</span> leftPos<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">((</span>leftPos <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'&lt;'</span><span class="hl opt">)) !=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
    <span class="hl kwb">size_t</span> rightPos <span class="hl opt">=</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'&gt;'</span><span class="hl opt">,</span> leftPos<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>rightPos <span class="hl opt">==</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
      ostringstream msg<span class="hl opt">;</span>
      msg <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Incomplete HTML tag starting in position &quot;</span>
          <span class="hl opt">&lt;&lt;</span> leftPos<span class="hl opt">;</span>
      <span class="hl kwa">throw</span> <span class="hl kwd">runtime_error</span><span class="hl opt">(</span>msg<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">());</span>
    <span class="hl opt">}</span>
    s<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(</span>leftPos<span class="hl opt">,</span> rightPos <span class="hl opt">-</span> leftPos <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Remove all special HTML characters</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;lt;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&lt;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;gt;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&gt;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;amp;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&amp;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replaceAll</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl str">&quot;&amp;nbsp;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Etc...</span>
  <span class="hl kwa">return</span> s<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">requireArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span>
    <span class="hl str">&quot;usage: HTMLStripper2 InputFile&quot;</span><span class="hl opt">);</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl slc">// Read entire file into string; then strip</span>
  ostringstream ss<span class="hl opt">;</span>
  ss <span class="hl opt">&lt;&lt;</span> in<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    string s <span class="hl opt">=</span> ss<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">stripHTMLTags</span><span class="hl opt">(</span>s<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> EXIT_SUCCESS<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>runtime_error<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.13. C04/HTMLStripper2.cpp</strong></p></div><br class="example-break" /><p>
	En este programa leemos el fichero entero dentro de un <code class="classname">string</code> insertando una llamada <code class="function">rdbuf()</code>
	del <code class="classname">stream</code> de fichero al <code class="classname">ostringstream</code>. Ahora es fácil buscar parejas de delimitadores HTML
	y borrarlas sin tener que preocuparnos de límites de líneas como teniamos con la versión previa en el Capítulo 3.
      </p><p>
	El siguiente ejemplo muestra como usar un stream de cadena
	bidireccional (esto es, lectura/escritura):
      </p><div class="example"><a id="idp4259832"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:StringSeeking.cpp {-bor}{-dmc}</span>
<span class="hl slc">// Reads and writes a string stream.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string text <span class="hl opt">=</span> <span class="hl str">&quot;We will hook no fish&quot;</span><span class="hl opt">;</span>
  stringstream <span class="hl kwd">ss</span><span class="hl opt">(</span>text<span class="hl opt">);</span>
  ss<span class="hl opt">.</span><span class="hl kwd">seekp</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>end<span class="hl opt">);</span>
  ss <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; before its time.&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>ss<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">() ==</span>
    <span class="hl str">&quot;We will hook no fish before its time.&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Change &quot;hook&quot; to &quot;ship&quot;</span>
  ss<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  string word<span class="hl opt">;</span>
  ss <span class="hl opt">&gt;&gt;</span> word<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>word <span class="hl opt">==</span> <span class="hl str">&quot;hook&quot;</span><span class="hl opt">);</span>
  ss<span class="hl opt">.</span><span class="hl kwd">seekp</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  ss <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ship&quot;</span><span class="hl opt">;</span>
  <span class="hl slc">// Change &quot;fish&quot; to &quot;code&quot;</span>
  ss<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  ss <span class="hl opt">&gt;&gt;</span> word<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>word <span class="hl opt">==</span> <span class="hl str">&quot;fish&quot;</span><span class="hl opt">);</span>
  ss<span class="hl opt">.</span><span class="hl kwd">seekp</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>beg<span class="hl opt">);</span>
  ss <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;code&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>ss<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">() ==</span>
    <span class="hl str">&quot;We will ship no code before its time.&quot;</span><span class="hl opt">);</span>
  ss<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">(</span><span class="hl str">&quot;A horse of a different color.&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>ss<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">() ==</span> <span class="hl str">&quot;A horse of a different color.&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.14. C04/StringSeeking.cpp</strong></p></div><br class="example-break" /><p>
	Como siempre para mover el puntero de inserción, usted llama a
	<code class="function">seekp()</code>, y para reposicionar el fichero
	de lectura, usted llama a
	<code class="function">seekg()</code>. Incluso aunque no lo hemos
	mostrado con este ejemplo, los <code class="classname">stream</code>
	de cadeana son un poco más permisivos que los
	<code class="classname">stream</code> de fichero ya que podemos
	cambiar de lectura a escritura y viceversa en cualquier
	momento. No necesita reposicionar el puntero de lectura o de
	escritura o vaciar el <code class="classname">stream</code>. Este
	progrma también ilustra la sobrecarga de
	<code class="function">str()</code> que reemplaza el
	<code class="classname">stringbuf</code> contenido en el
	<code class="classname">stream</code> con una nueva cadena.
      </p></div></div><div class="sect1" title="5.8. Formateo de stream de salida"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4265304"></a>5.8. Formateo de stream de salida</h2></div></div></div><p>
      El objetivo del diseño de los <code class="classname">iostream</code> es
      permitir que usted pueda mover y/o formatear carácteres
      fácilmente.  Ciertamente no podria ser de mucha utilidad si no
      se pudiera hacer la mayoria de los formateos provistos por la
      familia de funciones de <code class="function">printf()</code> en C. Es
      esta sección, usted aprenderá todo sobre las funciones de
      formateo de salida que estan disponibles para
      <code class="classname">iostream</code>, con lo que puede formatear los
      bytes de la manera que usted quiera.
    </p><p>
      Las funciones de formateo en iostream pueden ser algo cunfusas
      al principio porque a menudo existe más de una manera de
      controlar el formateo: a través de funciones miembro y
      manipuladores. Para confundir más las cosas, una función miembro
      genérica pone banderas de estado para controlar el formateo,
      como la justificación a la derecha o izquierda, el uso de letras
      mayúsculas para la notación hexadecimal, para siempre usar un
      punto decimal para valores de coma flotante, y cosas así. En el
      otro lado, funciones miembro separadas activan y leen valores
      para el caracter de relleno, la anchura del campo, y la
      precisión.
    </p><p>
      En un intento de clarificar todo esto, primero examinaremos el
      formateo interno de los datos de un iostream, y las funciones
      miembro que pueden modificar estos datos. (Todo puede ser
      controlado por funciones miembro si se desea). Cubriremos los
      manipuladores aparte.
    </p><div class="sect2" title="5.8.1. Banderas de formateo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4269016"></a>5.8.1. Banderas de formateo</h3></div></div></div><p>
	La clase <code class="classname">ios</code> contiene los miembros de
	datos para guardar toda la información de formateo
	perteneciente a un <code class="classname">stream</code>. Algunos de
	estos datos tiene un rango de valores de datos y son guardados
	en variables: la precisión de la coma flotante, la anchura del
	campo de salida, y el carácter usado para rellenar la salida
	(normalmente un espacio). El resto del formateo es determinado
	por banderas, que generalmente están combinadas para ahorrar
	espacio y se llaman colectivamente banderas de formateo. Puede
	recuperar los valores de las banderas de formateo con la
	función miembro <code class="function">ios::flag()</code>, que no toma
	argumentos y retorna un objeto de tipo
	<code class="classname">fmtflags</code> (usualmente un sinónimo de
	<code class="type">long</code>) que contiene las banderas de
	formateo actuales. El resto de funciones hacen cambios en las
	banderas de formateo y retornan el valor previo de las
	banderas de formateo.
      </p><pre class="programlisting">
fmtflags ios<span class="hl opt">::</span><span class="hl kwd">flags</span><span class="hl opt">(</span>fmtflags newflags<span class="hl opt">);</span>
  fmtflags ios<span class="hl opt">::</span><span class="hl kwd">setf</span><span class="hl opt">(</span>fmtflags ored_flag<span class="hl opt">);</span>
  fmtflags ios<span class="hl opt">::</span><span class="hl kwd">unsetf</span><span class="hl opt">(</span>fmtflags clear_flag<span class="hl opt">);</span>
  fmtflags ios<span class="hl opt">::</span><span class="hl kwd">setf</span><span class="hl opt">(</span>fmtflags bits<span class="hl opt">,</span> fmtflags field<span class="hl opt">);</span>
</pre><p>
	La primera función fuerza que todas las banderas cambien, que a veces es lo que usted quiere. Más a menudo, usted cambia una
	bandera cada vez usando las otras tres funciones.
      </p><p>
	El uso de <code class="function">setf()</code> puede parecer algo confusa. Para conocer qué versión sobrecargada usar, debe conocer el
	tipo de la bandera que está cambiando. Existen dos tipos de banderas: las que simplemente estan activadas o no, y aquellas que
	trabajan en grupo con otras banderas. La banderas que estan encendidas/apagadas son las más simples de entender por que usted
	las enciende con <code class="function">setf(fmtflags)</code> y las apaga con <code class="function">unsetf(fmtflags)</code>. Estas banderas
	se muestran en la siguiente tabla:
      </p><p>
	bandera activa/inactiva
      </p><p>
	Efecto
      </p><p>
	<code class="function">ios::skipws</code>
      </p><p>
	Se salta los espacios en blanco. ( Para la entrada esto es por defecto).
      </p><p>
	<code class="function">ios::showbase</code>
      </p><p>
	Indica la base numérica (que puede ser, por ejemplo, decimal, octal o  hexadecimal) cuando imprimimos el valor entero.
	Los <code class="classname">stream</code> de entrada tambié reconocen el prefijo de base cuando <code class="varname">showbase</code> está
	activo.
      </p><p>
	<code class="varname">ios::showpoint</code>
      </p><p>
	Muestra el punto decimal insertando ceros para valores de coma flotante.
      </p><p>
	<code class="varname">ios::uppercase</code>
      </p><p>
	Muestra A-F mayúsculas para valores hexadecimales y E para científicos.
      </p><p>
	<code class="varname">ios::showpos</code>
      </p><p>
	Muestra el signo de sumar (+) para los valores positivos
      </p><p>
	<code class="varname">ios::unitbuf</code>
      </p><p>
	'Unit buffering.' El <code class="classname">stream</code> es borrado después de cada inseción.
      </p><p>
	Por ejemplo, para mostrar el signo de sumar para <code class="classname">cout</code>, puede usar <code class="function">cout.setf(ios::showpos)</code>.
	Para dejar de mostrar el signo de sumar, escriba <code class="function">cout.unsetf(ios::showpos)</code>.
      </p><p>
	La bandera de <code class="varname">unitbuf</code> controla  el almacenamiento unitario, que significa que cada inserción es lanzada a su
	<code class="classname">stream</code> de salida inmediatamente. Esto es útil para hacer recuento de errores, ya que en caso de fallo del
	programa, sus datos son todavía escritos al fichero de log. El siguiente programa ilustra el almacenamiento unitario.
      </p><div class="example"><a id="idp4282960"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Unitbuf.cpp {RunByHand}</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>  <span class="hl slc">// For abort()</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ofstream <span class="hl kwd">out</span><span class="hl opt">(</span><span class="hl str">&quot;log.txt&quot;</span><span class="hl opt">);</span>
  out<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>unitbuf<span class="hl opt">);</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;one&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  out <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;two&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">abort</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.15. C04/Unitbuf.cpp</strong></p></div><br class="example-break" /><p>
	Es necesario activar el almacenamiento unitario antes de que cualquier inserción sea hecha en el <code class="classname">stream</code>.
	Cuando hemos descomentado la llamada a <code class="function">setf()</code>, un compilador en particular ha escrito solo la letra 'o' en
	el fichero log.txt. Con el almacenamiento unitario, ningun dato se perdió.
      </p><p>
	El <code class="classname">stream</code> de salida estándar <code class="classname">cerr</code> tiene el almacenamiento unitario activado por
	defecto. Hay un coste para el almacenamiento unitario, asi que si un <code class="classname">stream</code> de salida se usa intensivamente,
	no active el almacenamiento unitario a menos que la eficiencia no sea una consideración.
      </p></div><div class="sect2" title="5.8.2. Campos de formateo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4286728"></a>5.8.2. Campos de formateo</h3></div></div></div><p>
	El segundo tipo de banderas de formateo trabajan en grupo. Solo una de estas banderas pueden ser activadas cada vez, como
	los botones de una vieja radio de coche - usted apretaba una y el resto saltaban. Desafortunadamente esto no pasa automáticamente,
	y usted tiene que poner atención a que bandera  está activando para no llamar accidentalmente a la función <code class="function">setf()</code>
	incorrecta. Por ejemplo, hay una bandera para cada una de las bases numéricas: hexadecimal, decimal y octal. A estas banderas
	se refiere en conjunto <code class="code">ios::basefield</code>. Si la bandera <code class="code">ios::dec</code> está activa y usted llama
	<code class="code">setf(ios::hex)</code>, usted activará la bandera de <code class="code">ios::hex</code>, pero no desactivará la bandera de
	<code class="code">ios::dec</code>, resultando en un comportamiento indeterminado. En vez de esto,llame a la segunda forma de la función
	<code class="function">setf()</code> como esta: <code class="code">setf(ios::hex, ios::basefield)</code> . Esta función primero limpia todos los
	bits de <code class="code">ios::basefield</code> y luego activa <code class="code">ios::hex</code>. Así, esta forma de <code class="function">setf()</code> asegura
	que las otras banderas en el grupo 'saltan' cuando usted activa una. El manipulador <code class="code">ios::hex</code> lo hace todo por usted,
	automáticamente, asi que no tiene que preocuparse con los detalles de la implementación interna de esta clase o tener cuidado de
	que esto es una seria de banderas binarias. Más adelante verá que  hay manipuladores para proveer de la funcionalidad equivalente en
	todas las parts donde usted fuera a usar <code class="function">setf()</code>.
      </p><p>
	Aquí están los grupos de banderas y sus efectos:
      </p><p>
	<code class="code">ios::basefield</code>
      </p><p>
	Efecto
      </p><p>
	<code class="code">ios::dec</code>
      </p><p>
	Formatea valores enteros en base 10 (decimal)(Formateo por defecto - ningún prefijo es visible).
      </p><p>
	<code class="code">ios::hex</code>
      </p><p>
	Formatea valores enteros en base 16 (hexadecimal).
      </p><p>
	<code class="code">ios::oct</code>
      </p><p>
	Formatea valores enteros en base 8 (octal).
      </p><p>
	<code class="code">ios::floatfield</code>
      </p><p>
	Efecto
      </p><p>
	<code class="code">ios::scientific</code>
      </p><p>
	Muestra números en coma flotante en formato científico. El campo precisión indica el numero de dígitos después del punto decimal.
      </p><p>
	<code class="code">ios::fixed</code>
      </p><p>
	Muestra números en coma flotante en formato fijado. El campo precisión indica en número de dígitos después del punto decimal.
      </p><p>
	'automatic' (Ninguno de los bits está activado).
      </p><p>
	El campo precisión indica el número total de dígitos significativos.
      </p><p>
	<code class="code">ios::adjustfield</code>
      </p><p>
	Efecto
      </p><p>
	<code class="code">ios::left</code>
      </p><p>
	Valores con alineación izquierda; se llena hasta la derecha con el carácter de relleno.
      </p><p>
	<code class="code">ios::right</code>
      </p><p>
	Valores con alineación derecha; se llena hasta la izquierda con el carácter de relleno. Esta es la alineación por defecto.
      </p><p>
	<code class="code">ios::internal</code>
      </p><p>
	Añade carácteres de relleno despues de algún signo inicial o indicador de base, pero antes del valor. (En otras palabras,
	el signo, si está presente, se justifica a la izquierda mientras el número se justifica a la derecha).
      </p></div><div class="sect2" title="5.8.3. Anchura, relleno y precisión"><div class="titlepage"><div><div><h3 class="title"><a id="idp4302008"></a>5.8.3. Anchura, relleno y precisión</h3></div></div></div><p>
	La variables internas que controlan la anchura del campo de salida, el carácter usado para rellenar el campo de salida,
	y la precisión para escribir números de coma flotante son escritos y leídos por funciones miembro del mismo nombre.
      </p><p>
	Función
      </p><p>
	Efecto
      </p><p>
	<code class="code">int ios::width( )</code>
      </p><p>
	Retorna la anchura actual. Por defecto es 0. Se usa para la inserción y la extracción.
      </p><p>
	<code class="code">int ios::width(int n)</code>
      </p><p>
	Pone la anchura, retorna la anchura previa.
      </p><p>
	<code class="code">int ios::fill( )</code>
      </p><p>
	Retorna el carácter de relleno actual. Por defecto es el espacio.
      </p><p>
	<code class="code">int ios::fill(int n)</code>
      </p><p>
	Poner el carácter de relleno, retorna el carácter de relleno anterior.
      </p><p>
	<code class="code">int ios::precision( )</code>
      </p><p>
	Retorna la precisión actual de la coma flotante. Por defecto es 6.
      </p><p>
	<code class="code">int ios::precision(int n)</code>
      </p><p>
	Pone la precisión de la coma flotante, retorna la precisión anteriot. Vea la tabla <code class="code">ios::floatfield</code>
	para el significado de 'precisión'.
      </p><p>
	El relleno y la precisión son bastante claras, pero la anchura requiera alguna explicación. Cuando la anchura es 0,
	insertar un valor produce el mínimo número de carácteres necesario para representar este valor. Una anchura positiva
	significa que insertar un valor producirá al menos tantos carácteres como la anchura; si el valor tiene menos carácteres
	que la anchura, el carácter de relleno llena el campo. No obstante, el valor nunca será truncado, con lo que si usted
	intenta escribir 123 con una anchura de dos, seguirá obteniendo 123. El campo anchura especifica un minimo número de
	carácteres; no hay forma de especificar un número mínimo.
      </p><p>
	La anchura también es diferente por que vuelve a ser cero por cada insertador o extractor que puede ser influenciado por
	este valor. Realmente no es una variable de estado, sino más bien un argumento implícito para los extractores y insertadores.
	Si quiere una anchura constante, llame a <code class="function">width()</code> despues de cada inserción o extracción.
      </p></div><div class="sect2" title="5.8.4. Un ejemplo exhaustivo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4311064"></a>5.8.4. Un ejemplo exhaustivo</h3></div></div></div><p>
	Para estar seguros de que usted conoce como llamar a todas las funciones discutidas previamente, aquí tiene un ejemplo que las llama a todas:
      </p><div class="example"><a id="idp4311888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Format.cpp</span>
<span class="hl slc">// Formatting Functions.</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl ppc">#define D(A) T &lt;&lt; #A &lt;&lt; endl; A</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ofstream <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl str">&quot;format.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>T<span class="hl opt">);</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span><span class="hl kwb">float</span> f <span class="hl opt">=</span> <span class="hl num">2300114.414159</span><span class="hl opt">;)</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> s <span class="hl opt">=</span> <span class="hl str">&quot;Is there any more?&quot;</span><span class="hl opt">;</span>

  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>unitbuf<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showbase<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>uppercase <span class="hl opt">|</span> ios<span class="hl opt">::</span>showpos<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span> <span class="hl slc">// Default is dec</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>hex<span class="hl opt">,</span> ios<span class="hl opt">::</span>basefield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>oct<span class="hl opt">,</span> ios<span class="hl opt">::</span>basefield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">unsetf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showbase<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>dec<span class="hl opt">,</span> ios<span class="hl opt">::</span>basefield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>left<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">(</span><span class="hl str">'0'</span><span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fill char: &quot;</span> <span class="hl opt">&lt;&lt;</span> T<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);)</span>
  T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>right<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);)</span>
  T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>internal<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);)</span>
  T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span> <span class="hl slc">// Without width(10)</span>

  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">unsetf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showpos<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showpoint<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;prec = &quot;</span> <span class="hl opt">&lt;&lt;</span> T<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>scientific<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">unsetf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>uppercase<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>fixed<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;prec = &quot;</span> <span class="hl opt">&lt;&lt;</span> T<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>scientific<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>fixed<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;)</span>

  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);)</span>
  T <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">40</span><span class="hl opt">);)</span>
  T <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>left<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);)</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span>T<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(</span><span class="hl num">40</span><span class="hl opt">);)</span>
  T <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.16. C04/Format.cpp</strong></p></div><br class="example-break" /><p>
	Este ejemplo usa un truco para crear un fichero de traza para que pueda monitorizar lo que está pasando. La macro D(a) usa el preprocesador
	'convirtiendo a string' para convertir a en una cadena para mostrar. Entonces se reitera a con lo que la sentencia se ejecuta. La macro
	envia toda la información a un fichero llamado T, que es el fichero de traza. La salida es:
      </p><pre class="screen">
int i = 47;
float f = 2300114.414159;
T.setf(ios::unitbuf);
T.setf(ios::showbase);
T.setf(ios::uppercase | ios::showpos);
T &lt;&lt; i &lt;&lt; endl;
+47
T.setf(ios::hex, ios::basefield);
T &lt;&lt; i &lt;&lt; endl;
0X2F
T.setf(ios::oct, ios::basefield);
T &lt;&lt; i &lt;&lt; endl;
057
T.unsetf(ios::showbase);
T.setf(ios::dec, ios::basefield);
T.setf(ios::left, ios::adjustfield);
T.fill('0');
T &lt;&lt; "fill char: " &lt;&lt; T.fill() &lt;&lt; endl;
fill char: 0
T.width(10);
+470000000
T.setf(ios::right, ios::adjustfield);
T.width(10);
0000000+47
T.setf(ios::internal, ios::adjustfield);
T.width(10);
+000000047
T &lt;&lt; i &lt;&lt; endl;
+47
T.unsetf(ios::showpos);
T.setf(ios::showpoint);
T &lt;&lt; "prec = " &lt;&lt; T.precision() &lt;&lt; endl;
prec = 6
T.setf(ios::scientific, ios::floatfield);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.300114E+06
T.unsetf(ios::uppercase);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.300114e+06
T.setf(ios::fixed, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.500000
T.precision(20);
T &lt;&lt; "prec = " &lt;&lt; T.precision() &lt;&lt; endl;
prec = 20
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2300114.50000000000000000000
T.setf(ios::scientific, ios::floatfield);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.30011450000000000000e+06
T.setf(ios::fixed, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.50000000000000000000
T.width(10);
Is there any more?
T.width(40);
0000000000000000000000Is there any more?
T.setf(ios::left, ios::adjustfield);
T.width(40);
Is there any more?0000000000000000000000
</pre><p>
	Estudiar esta salida debería clarificar su entendimiento del formateo de las funciones miembro de iostream .
      </p></div></div><div class="sect1" title="5.9. Manipuladores"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4318832"></a>5.9. Manipuladores</h2></div></div></div><p>
      Como puede ver en el programa previo, llamar a funciones miembro para operaciones de formateo de <code class="classname">stream</code>
      puede ser un poco tedioso. Para hacer las cosas mas fáciles de leer y escribir, existe un conjunto de manipuladores para duplicar
      las acciones previstas por las funciones miembro. Las manipuladores son convenientes por que usted puede insertarlos para que actuen
      dentro de una expresion contenedora; no necesita crear una sentencia de llamada a función separada.
    </p><p>
      Los manipuladores cambian el estado de un <code class="classname">stream</code> en vez de (o además de) procesar los datos. Cuando
      insertamos un <code class="function">endl</code> en una expresión de salida, por ejemplo, no solo inserta un carácter de nueva linea,
      sino que ademas termina el <code class="classname">stream</code> (esto es, saca todos los carácteres pendientes que han sido almacenadas
      en el buffer interno del <code class="classname">stream</code> pero todavia no en la salida). Puede terminar el <code class="classname">stream</code>
      simplemente asi:
    </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> flush<span class="hl opt">;</span>
</pre><p>
      Lo que causa una llamada a la función miembro<code class="function"> flush()</code>, como esta:
    </p><pre class="programlisting">
cout<span class="hl opt">.</span><span class="hl kwd">flush</span><span class="hl opt">();</span>
</pre><p>
      como efecto lateral (nada es insertado dentro de <code class="classname">stream</code>). Adicionalmente los manipuladores
      básicos cambirán la base del número a oct (octal), dec (decimal) o hex (hexadecimal).
    </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> hex <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;0x&quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
</pre><p>
      En este caso, la salida numérica continuará en modo hexadecimal hasta que usted lo cambie insertando o dec o oct en el
      <code class="classname">stream</code> de salida.
    </p><p>
      También existe un manipulador para la extracción que se 'come' los espacios en blanco:
    </p><pre class="programlisting">
cin <span class="hl opt">&gt;&gt;</span> ws<span class="hl opt">;</span>
</pre><p>
      Los manipuladores sin argumentos son provistos en &lt;iostream&gt;. Esto incluye dec, oct,y hex, que hacen las
      mismas acciones que, respectivamente, <code class="code">setf(ios::dec, ios::basefield)</code>,
      <code class="code">setf(ios::oct, ios::basefield)</code>, y <code class="code">setf(ios::hex, ios::basefield)</code>, aunque
      más sucintamente. La cabecera &lt;iostream&gt; también incluye ws, endl, y flush y el conjunto adicional mostrado aquí:
    </p><p>
      Manipulador
    </p><p>
      Efecto
    </p><p>
      <span class="emphasis"><em>showbase noshowbase</em></span>
    </p><p>
      Indica la base numérica (dec, oct, o hex) cuando imprimimos un entero.
    </p><p>
      <span class="emphasis"><em>showpos noshowpos</em></span>
    </p><p>
      Muestra el signo más (+) para valores positivos.
    </p><p>
      <span class="emphasis"><em>uppercase nouppercase</em></span>
    </p><p>
      Muestra mayúsculas A-F para valores hexadecimales, y muestra E para valores científicos.
    </p><p>
      <span class="emphasis"><em>showpoint noshowpoint</em></span>
    </p><p>
      Muestra punto decimal y ceros arrastrados para valores de coma flotante.
    </p><p>
      <span class="emphasis"><em>skipws noskipws</em></span>
    </p><p>
      Escapa los espacios en blanco en la entrada.
    </p><p>
      <span class="emphasis"><em>left right internal</em></span>
    </p><p>
      Alineación izquierda, relleno a la derecha. Alineación derecha, relleno a la izquierda. Rellenar entre el signo o el indicador de base y el valor.
    </p><p>
      <span class="emphasis"><em>scientific fixed</em></span>
    </p><p>
      Indica la preferencia al mostrar la salida para coma flotante (notación científica versus coma flotante decimal).
    </p><div class="sect2" title="5.9.1. Manipuladores con argumentos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4333648"></a>5.9.1. Manipuladores con argumentos</h3></div></div></div><p>
	Existen seis manipuladores estándar, como <code class="function">setw()</code>, que toman argumentos. Están definidos en el fichero de cabecera &lt;iomanip&gt;, y están enumerados en la siguiente tabla:
      </p><p>
	Manipulador
      </p><p>
	Efecto
      </p><p>
	<code class="function">setiosflags(fmtflags n)</code>
      </p><p>
	Equivalente a una llamada a <code class="function">setf(n)</code>. La activación continua hasta el siguiente cambio,
	como <code class="function">ios::setf()</code>.
      </p><p>
	<code class="function">resetiosflags(fmtflags n)</code>
      </p><p>
	Limpia solo las banderas de formato especificadas por n. La activación permanece hasta el siguiente
	cambio, como <code class="function">ios::unsetf()</code>.
      </p><p>
	<code class="function">setbase(base n)</code>
      </p><p>
	Cambia la base a n, donde n es 10, 8 o 16. (Caulquier otra opción resulta en 0). Si n es cero, la salida es base 10,
	pero la entrada usa convenciones de C: 10 es 10, 010 es 8, y 0xf es 15. Puede usar también dec, oct y hex para la salida.
      </p><p>
	<code class="function">setfill(char n)</code>
      </p><p>
	Cambia el carácter de relleno a n, como <code class="function">ios::fill()</code>.
      </p><p>
	<code class="function">setprecision(int n)</code>
      </p><p>
	Cambia la precision a n, como <code class="function">ios::precision()</code>.
      </p><p>
	<code class="function">setw(int n)</code>
      </p><p>
	Cambia la anchura del campo a n, como en <code class="function">ios::width()</code>
      </p><p>
	Si está usando mucho el formateo, usted puede ver como usar los manipuladores en vez de llamar a funciones
	miembro de stream puede limpiar su código. Como ejemplo, aquí tiene un programa de la sección previa reescrito
	para usar los manipuladores. (La macro D() ha sido borrada para hacerlo más fácil de leer).
      </p><div class="example"><a id="idp4343104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Manips.cpp</span>
<span class="hl slc">// Format.cpp using manipulators.</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iomanip&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ofstream <span class="hl kwd">trc</span><span class="hl opt">(</span><span class="hl str">&quot;trace.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">47</span><span class="hl opt">;</span>
  <span class="hl kwb">float</span> f <span class="hl opt">=</span> <span class="hl num">2300114.414159</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> s <span class="hl opt">=</span> <span class="hl str">&quot;Is there any more?&quot;</span><span class="hl opt">;</span>

  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setiosflags</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>unitbuf
           <span class="hl opt">|</span> ios<span class="hl opt">::</span>showbase <span class="hl opt">|</span> ios<span class="hl opt">::</span>uppercase
           <span class="hl opt">|</span> ios<span class="hl opt">::</span>showpos<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> hex <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl
      <span class="hl opt">&lt;&lt;</span> oct <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>left<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">resetiosflags</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showbase<span class="hl opt">)</span>
      <span class="hl opt">&lt;&lt;</span> dec <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setfill</span><span class="hl opt">(</span><span class="hl str">'0'</span><span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;fill char: &quot;</span> <span class="hl opt">&lt;&lt;</span> trc<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">) &lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>right<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">) &lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>internal<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">) &lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Without setw(10)</span>

  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">resetiosflags</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showpos<span class="hl opt">)</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setiosflags</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showpoint<span class="hl opt">)</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;prec = &quot;</span> <span class="hl opt">&lt;&lt;</span> trc<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>scientific<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">resetiosflags</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>uppercase<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>fixed<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setprecision</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;prec = &quot;</span> <span class="hl opt">&lt;&lt;</span> trc<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>scientific<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>fixed<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> f <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>

  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">) &lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">40</span><span class="hl opt">) &lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  trc<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>left<span class="hl opt">,</span> ios<span class="hl opt">::</span>adjustfield<span class="hl opt">);</span>
  trc <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">40</span><span class="hl opt">) &lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.17. C04/Manips.cpp</strong></p></div><br class="example-break" /><p>
	Puede ver que un montón de sentencias múltiples han sido condensadas dentro de una sola inserción encadenada. Nótese
	que la llamada a setiosflags() en que se pasa el OR binario de las banderas. Esto se podría haber hecho también con
	<code class="function">setf()</code> y <code class="function">unsetf()</code> como en el ejemplo previo.
      </p><p>

      </p><div class="example"><a id="idp4348056"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:InputWidth.cpp</span>
<span class="hl slc">// Shows limitations of setw with input.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;iomanip&gt;</span>
<span class="hl ppc">#include &lt;limits&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  istringstream <span class="hl kwd">is</span><span class="hl opt">(</span><span class="hl str">&quot;one 2.34 five&quot;</span><span class="hl opt">);</span>
  string temp<span class="hl opt">;</span>
  is <span class="hl opt">&gt;&gt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &gt;&gt;</span> temp<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>temp <span class="hl opt">==</span> <span class="hl str">&quot;on&quot;</span><span class="hl opt">);</span>
  is <span class="hl opt">&gt;&gt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &gt;&gt;</span> temp<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>temp <span class="hl opt">==</span> <span class="hl str">&quot;e&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">double</span> x<span class="hl opt">;</span>
  is <span class="hl opt">&gt;&gt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &gt;&gt;</span> x<span class="hl opt">;</span>
  <span class="hl kwb">double</span> relerr <span class="hl opt">=</span> <span class="hl kwd">fabs</span><span class="hl opt">(</span>x <span class="hl opt">-</span> <span class="hl num">2.34</span><span class="hl opt">) /</span> x<span class="hl opt">;</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>relerr <span class="hl opt">&lt;=</span> numeric_limits<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;::</span><span class="hl kwd">epsilon</span><span class="hl opt">());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.18. C04/InputWidth.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="5.9.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4349976"></a>5.9.2.  </h3></div></div></div><p>

      </p><pre class="programlisting">
ostream<span class="hl opt">&amp;</span> <span class="hl kwd">endl</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;);</span>
</pre><p>

      </p><pre class="programlisting">
cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;howdy&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
</pre><p>

      </p><pre class="programlisting">
ostream<span class="hl opt">&amp;</span> ostream<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp; (*</span>pf<span class="hl opt">)(</span>ostream<span class="hl opt">&amp;)) {</span>
   <span class="hl kwa">return</span> <span class="hl kwd">pf</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4352544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:nl.cpp</span>
<span class="hl slc">// Creating a manipulator.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

ostream<span class="hl opt">&amp;</span> <span class="hl kwd">nl</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\n</span><span class="hl str">'</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;newlines&quot;</span> <span class="hl opt">&lt;&lt;</span> nl <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;between&quot;</span> <span class="hl opt">&lt;&lt;</span> nl
       <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;each&quot;</span> <span class="hl opt">&lt;&lt;</span> nl <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;word&quot;</span> <span class="hl opt">&lt;&lt;</span> nl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.19. C04/nl.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
cout<span class="hl opt">.</span><span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>nl<span class="hl opt">)</span> è <span class="hl kwd">nl</span><span class="hl opt">(</span>cout<span class="hl opt">)</span>
</pre><p>

      </p><pre class="programlisting">
os <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\n</span><span class="hl str">'</span><span class="hl opt">;</span>
</pre><p>

      </p></div><div class="sect2" title="5.9.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4355040"></a>5.9.3.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4355552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Effector.cpp</span>
<span class="hl slc">// Jerry Schwarz's &quot;effectors.&quot;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;limits&gt;</span>  <span class="hl slc">// For max()</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Put out a prefix of a string:</span>
<span class="hl kwc">class</span> Fixw <span class="hl opt">{</span>
  string str<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Fixw</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">,</span> <span class="hl kwb">int</span> width<span class="hl opt">) :</span> <span class="hl kwd">str</span><span class="hl opt">(</span>s<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> width<span class="hl opt">) {}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Fixw<span class="hl opt">&amp;</span> fw<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> fw<span class="hl opt">.</span>str<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Print a number in binary:</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">unsigned long</span> ulong<span class="hl opt">;</span>

<span class="hl kwc">class</span> Bin <span class="hl opt">{</span>
  ulong n<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Bin</span><span class="hl opt">(</span>ulong nn<span class="hl opt">) {</span> n <span class="hl opt">=</span> nn<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Bin<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
    <span class="hl kwb">const</span> ulong ULMAX <span class="hl opt">=</span> numeric_limits<span class="hl opt">&lt;</span>ulong<span class="hl opt">&gt;::</span><span class="hl kwd">max</span><span class="hl opt">();</span>
    ulong bit <span class="hl opt">= ~(</span>ULMAX <span class="hl opt">&gt;&gt;</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Top bit set</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>bit<span class="hl opt">) {</span>
      os <span class="hl opt">&lt;&lt; (</span>b<span class="hl opt">.</span>n <span class="hl opt">&amp;</span> bit ? <span class="hl str">'1'</span> <span class="hl opt">:</span> <span class="hl str">'0'</span><span class="hl opt">);</span>
      bit <span class="hl opt">&gt;&gt;=</span> <span class="hl num">1</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">return</span> os<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string words <span class="hl opt">=</span> <span class="hl str">&quot;Things that make us happy, make us wise&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> words<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); --</span>i <span class="hl opt">&gt;=</span> <span class="hl num">0</span><span class="hl opt">;) {</span>
    ostringstream s<span class="hl opt">;</span>
    s <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">Fixw</span><span class="hl opt">(</span>words<span class="hl opt">,</span> i<span class="hl opt">);</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">() ==</span> words<span class="hl opt">.</span><span class="hl kwd">substr</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
  <span class="hl opt">}</span>
  ostringstream xs<span class="hl opt">,</span> ys<span class="hl opt">;</span>
  xs <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">Bin</span><span class="hl opt">(</span><span class="hl num">0xCAFEBABE</span>UL<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>xs<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">() ==</span>
    <span class="hl str">&quot;1100&quot;</span><span class="hl str">&quot;1010&quot;</span><span class="hl str">&quot;1111&quot;</span><span class="hl str">&quot;1110&quot;</span><span class="hl str">&quot;1011&quot;</span><span class="hl str">&quot;1010&quot;</span><span class="hl str">&quot;1011&quot;</span><span class="hl str">&quot;1110&quot;</span><span class="hl opt">);</span>
  ys <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">Bin</span><span class="hl opt">(</span><span class="hl num">0x76543210</span>UL<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>ys<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">() ==</span>
    <span class="hl str">&quot;0111&quot;</span><span class="hl str">&quot;0110&quot;</span><span class="hl str">&quot;0101&quot;</span><span class="hl str">&quot;0100&quot;</span><span class="hl str">&quot;0011&quot;</span><span class="hl str">&quot;0010&quot;</span><span class="hl str">&quot;0001&quot;</span><span class="hl str">&quot;0000&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.20. C04/Effector.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="5.10."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4358632"></a>5.10.  </h2></div></div></div><p>

    </p><div class="sect2" title="5.10.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4359144"></a>5.10.1.  </h3></div></div></div><p>

      </p><p>

      </p><div class="example"><a id="idp4359848"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Cppcheck.cpp</span>
<span class="hl slc">// Configures .h &amp; .cpp files to conform to style</span>
<span class="hl slc">// standard. Tests existing files for conformance.</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">startsWith</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> base<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> key<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> base<span class="hl opt">.</span><span class="hl kwd">compare</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> key<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(),</span> key<span class="hl opt">) ==</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">cppCheck</span><span class="hl opt">(</span>string fileName<span class="hl opt">) {</span>
  <span class="hl kwb">enum</span> bufs <span class="hl opt">{</span> BASE<span class="hl opt">,</span> HEADER<span class="hl opt">,</span> IMPLEMENT<span class="hl opt">,</span> HLINE1<span class="hl opt">,</span> GUARD1<span class="hl opt">,</span>
    GUARD2<span class="hl opt">,</span> GUARD3<span class="hl opt">,</span> CPPLINE1<span class="hl opt">,</span> INCLUDE<span class="hl opt">,</span> BUFNUM <span class="hl opt">};</span>
  string part<span class="hl opt">[</span>BUFNUM<span class="hl opt">];</span>
  part<span class="hl opt">[</span>BASE<span class="hl opt">] =</span> fileName<span class="hl opt">;</span>
  <span class="hl slc">// Find any '.' in the string:</span>
  <span class="hl kwb">size_t</span> loc <span class="hl opt">=</span> part<span class="hl opt">[</span>BASE<span class="hl opt">].</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'.'</span><span class="hl opt">);</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>loc <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">)</span>
    part<span class="hl opt">[</span>BASE<span class="hl opt">].</span><span class="hl kwd">erase</span><span class="hl opt">(</span>loc<span class="hl opt">);</span> <span class="hl slc">// Strip extension</span>
  <span class="hl slc">// Force to upper case:</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> part<span class="hl opt">[</span>BASE<span class="hl opt">].</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    part<span class="hl opt">[</span>BASE<span class="hl opt">][</span>i<span class="hl opt">] =</span> <span class="hl kwd">toupper</span><span class="hl opt">(</span>part<span class="hl opt">[</span>BASE<span class="hl opt">][</span>i<span class="hl opt">]);</span>
  <span class="hl slc">// Create file names and internal lines:</span>
  part<span class="hl opt">[</span>HEADER<span class="hl opt">] =</span> part<span class="hl opt">[</span>BASE<span class="hl opt">] +</span> <span class="hl str">&quot;.h&quot;</span><span class="hl opt">;</span>
  part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">] =</span> part<span class="hl opt">[</span>BASE<span class="hl opt">] +</span> <span class="hl str">&quot;.cpp&quot;</span><span class="hl opt">;</span>
  part<span class="hl opt">[</span>HLINE1<span class="hl opt">] =</span> <span class="hl str">&quot;//&quot;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">+</span> part<span class="hl opt">[</span>HEADER<span class="hl opt">];</span>
  part<span class="hl opt">[</span>GUARD1<span class="hl opt">] =</span> <span class="hl str">&quot;#ifndef &quot;</span> <span class="hl opt">+</span> part<span class="hl opt">[</span>BASE<span class="hl opt">] +</span> <span class="hl str">&quot;_H&quot;</span><span class="hl opt">;</span>
  part<span class="hl opt">[</span>GUARD2<span class="hl opt">] =</span> <span class="hl str">&quot;#define &quot;</span> <span class="hl opt">+</span> part<span class="hl opt">[</span>BASE<span class="hl opt">] +</span> <span class="hl str">&quot;_H&quot;</span><span class="hl opt">;</span>
  part<span class="hl opt">[</span>GUARD3<span class="hl opt">] =</span> <span class="hl str">&quot;#endif // &quot;</span> <span class="hl opt">+</span> part<span class="hl opt">[</span>BASE<span class="hl opt">] +</span><span class="hl str">&quot;_H&quot;</span><span class="hl opt">;</span>
  part<span class="hl opt">[</span>CPPLINE1<span class="hl opt">] =</span> <span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;//&quot;</span><span class="hl opt">) +</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">+</span> part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">];</span>
  part<span class="hl opt">[</span>INCLUDE<span class="hl opt">] =</span> <span class="hl str">&quot;#include</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">+</span> part<span class="hl opt">[</span>HEADER<span class="hl opt">] +</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl slc">// First, try to open existing files:</span>
  ifstream <span class="hl kwd">existh</span><span class="hl opt">(</span>part<span class="hl opt">[</span>HEADER<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">()),</span>
           <span class="hl kwd">existcpp</span><span class="hl opt">(</span>part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>existh<span class="hl opt">) {</span> <span class="hl slc">// Doesn't exist; create it</span>
    ofstream <span class="hl kwd">newheader</span><span class="hl opt">(</span>part<span class="hl opt">[</span>HEADER<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>newheader<span class="hl opt">,</span> part<span class="hl opt">[</span>HEADER<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    newheader <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>HLINE1<span class="hl opt">] &lt;&lt;</span> endl
              <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>GUARD1<span class="hl opt">] &lt;&lt;</span> endl
              <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>GUARD2<span class="hl opt">] &lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> endl
              <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>GUARD3<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span> <span class="hl slc">// Already exists; verify it</span>
    stringstream hfile<span class="hl opt">;</span> <span class="hl slc">// Write &amp; read</span>
    ostringstream newheader<span class="hl opt">;</span> <span class="hl slc">// Write</span>
    hfile <span class="hl opt">&lt;&lt;</span> existh<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
    <span class="hl slc">// Check that first three lines conform:</span>
    <span class="hl kwb">bool</span> changed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    string s<span class="hl opt">;</span>
    hfile<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl kwd">getline</span><span class="hl opt">(</span>hfile<span class="hl opt">,</span> s<span class="hl opt">);</span>
    <span class="hl kwb">bool</span> lineUsed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    <span class="hl slc">// The call to good() is for Microsoft (later too):</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> line <span class="hl opt">=</span> HLINE1<span class="hl opt">;</span> hfile<span class="hl opt">.</span><span class="hl kwd">good</span><span class="hl opt">() &amp;&amp;</span> line <span class="hl opt">&lt;=</span> GUARD2<span class="hl opt">;</span>
         <span class="hl opt">++</span>line<span class="hl opt">) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">startsWith</span><span class="hl opt">(</span>s<span class="hl opt">,</span> part<span class="hl opt">[</span>line<span class="hl opt">])) {</span>
        newheader <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        lineUsed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>hfile<span class="hl opt">,</span> s<span class="hl opt">))</span>
          lineUsed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
      <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
        newheader <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>line<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
        changed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        lineUsed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Copy rest of file</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>lineUsed<span class="hl opt">)</span>
      newheader <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    newheader <span class="hl opt">&lt;&lt;</span> hfile<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
    <span class="hl slc">// Check for GUARD3</span>
    string head <span class="hl opt">=</span> hfile<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>head<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>part<span class="hl opt">[</span>GUARD3<span class="hl opt">]) ==</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
      newheader <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>GUARD3<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
      changed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// If there were changes, overwrite file:</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>changed<span class="hl opt">) {</span>
      existh<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
      ofstream <span class="hl kwd">newH</span><span class="hl opt">(</span>part<span class="hl opt">[</span>HEADER<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
      <span class="hl kwd">assure</span><span class="hl opt">(</span>newH<span class="hl opt">,</span> part<span class="hl opt">[</span>HEADER<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
      newH <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;//&#64;//</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>  <span class="hl slc">// Change marker</span>
           <span class="hl opt">&lt;&lt;</span> newheader<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">if</span><span class="hl opt">(!</span>existcpp<span class="hl opt">) {</span> <span class="hl slc">// Create cpp file</span>
    ofstream <span class="hl kwd">newcpp</span><span class="hl opt">(</span>part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>newcpp<span class="hl opt">,</span> part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    newcpp <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>CPPLINE1<span class="hl opt">] &lt;&lt;</span> endl
           <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>INCLUDE<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span> <span class="hl slc">// Already exists; verify it</span>
    stringstream cppfile<span class="hl opt">;</span>
    ostringstream newcpp<span class="hl opt">;</span>
    cppfile <span class="hl opt">&lt;&lt;</span> existcpp<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
    <span class="hl slc">// Check that first two lines conform:</span>
    <span class="hl kwb">bool</span> changed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    string s<span class="hl opt">;</span>
    cppfile<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl kwd">getline</span><span class="hl opt">(</span>cppfile<span class="hl opt">,</span> s<span class="hl opt">);</span>
    <span class="hl kwb">bool</span> lineUsed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> line <span class="hl opt">=</span> CPPLINE1<span class="hl opt">;</span>
        cppfile<span class="hl opt">.</span><span class="hl kwd">good</span><span class="hl opt">() &amp;&amp;</span> line <span class="hl opt">&lt;=</span> INCLUDE<span class="hl opt">; ++</span>line<span class="hl opt">) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">startsWith</span><span class="hl opt">(</span>s<span class="hl opt">,</span> part<span class="hl opt">[</span>line<span class="hl opt">])) {</span>
        newcpp <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        lineUsed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>cppfile<span class="hl opt">,</span> s<span class="hl opt">))</span>
          lineUsed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
      <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span>
        newcpp <span class="hl opt">&lt;&lt;</span> part<span class="hl opt">[</span>line<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
        changed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
        lineUsed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// Copy rest of file</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>lineUsed<span class="hl opt">)</span>
      newcpp <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    newcpp <span class="hl opt">&lt;&lt;</span> cppfile<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
    <span class="hl slc">// If there were changes, overwrite file:</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>changed<span class="hl opt">) {</span>
      existcpp<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
      ofstream <span class="hl kwd">newCPP</span><span class="hl opt">(</span>part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
      <span class="hl kwd">assure</span><span class="hl opt">(</span>newCPP<span class="hl opt">,</span> part<span class="hl opt">[</span>IMPLEMENT<span class="hl opt">].</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
      newCPP <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;//&#64;//</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>  <span class="hl slc">// Change marker</span>
             <span class="hl opt">&lt;&lt;</span> newcpp<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">&gt;</span> <span class="hl num">1</span><span class="hl opt">)</span>
    <span class="hl kwd">cppCheck</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwa">else</span>
    <span class="hl kwd">cppCheck</span><span class="hl opt">(</span><span class="hl str">&quot;cppCheckTest.h&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.21. C04/Cppcheck.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl slc">// CPPCHECKTEST.h</span>
<span class="hl ppc">#ifndef CPPCHECKTEST_H</span>
<span class="hl ppc">#define CPPCHECKTEST_H</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// CPPCHECKTEST_H</span><span class="hl ppc"></span>
</pre><pre class="programlisting">
<span class="hl slc">// PPCHECKTEST.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;CPPCHECKTEST.h&quot;</span><span class="hl ppc"></span>
</pre><p>

      </p><p>

      </p></div><div class="sect2" title="5.10.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4369624"></a>5.10.2.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4370136"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Showerr.cpp {RunByHand}</span>
<span class="hl slc">// Un-comment error generators.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;cstdio&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">const</span> string USAGE <span class="hl opt">=</span>
  <span class="hl str">&quot;usage: showerr filename chapnum</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;where filename is a C++ source file</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;and chapnum is the chapter name it's in.</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;Finds lines commented with //! and removes</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;the comment, appending //(#) where # is unique</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;across all files, so you can determine</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;if your compiler finds the error.</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;showerr /r</span><span class="hl esc">\n</span><span class="hl str">&quot;</span>
  <span class="hl str">&quot;resets the unique counter.&quot;</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> Showerr <span class="hl opt">{</span>
  <span class="hl kwb">const int</span> CHAP<span class="hl opt">;</span>
  <span class="hl kwb">const</span> string MARKER<span class="hl opt">,</span> FNAME<span class="hl opt">;</span>
  <span class="hl slc">// File containing error number counter:</span>
  <span class="hl kwb">const</span> string ERRNUM<span class="hl opt">;</span>
  <span class="hl slc">// File containing error lines:</span>
  <span class="hl kwb">const</span> string ERRFILE<span class="hl opt">;</span>
  stringstream edited<span class="hl opt">;</span> <span class="hl slc">// Edited file</span>
  <span class="hl kwb">int</span> counter<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Showerr</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> f<span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> en<span class="hl opt">,</span>
    <span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> ef<span class="hl opt">,</span> <span class="hl kwb">int</span> c<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">CHAP</span><span class="hl opt">(</span>c<span class="hl opt">),</span> <span class="hl kwd">MARKER</span><span class="hl opt">(</span><span class="hl str">&quot;//!&quot;</span><span class="hl opt">),</span> <span class="hl kwd">FNAME</span><span class="hl opt">(</span>f<span class="hl opt">),</span> <span class="hl kwd">ERRNUM</span><span class="hl opt">(</span>en<span class="hl opt">),</span>
    <span class="hl kwd">ERRFILE</span><span class="hl opt">(</span>ef<span class="hl opt">),</span> <span class="hl kwd">counter</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">replaceErrors</span><span class="hl opt">() {</span>
    ifstream <span class="hl kwd">infile</span><span class="hl opt">(</span>FNAME<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>infile<span class="hl opt">,</span> FNAME<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    ifstream <span class="hl kwd">count</span><span class="hl opt">(</span>ERRNUM<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count<span class="hl opt">)</span> count <span class="hl opt">&gt;&gt;</span> counter<span class="hl opt">;</span>
    <span class="hl kwb">int</span> linecount <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
    string buf<span class="hl opt">;</span>
    ofstream <span class="hl kwd">errlines</span><span class="hl opt">(</span>ERRFILE<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">(),</span> ios<span class="hl opt">::</span>app<span class="hl opt">);</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>errlines<span class="hl opt">,</span> ERRFILE<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>infile<span class="hl opt">,</span> buf<span class="hl opt">)) {</span>
      <span class="hl slc">// Find marker at start of line:</span>
      <span class="hl kwb">size_t</span> pos <span class="hl opt">=</span> buf<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>MARKER<span class="hl opt">);</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>pos <span class="hl opt">!=</span> string<span class="hl opt">::</span>npos<span class="hl opt">) {</span>
        <span class="hl slc">// Erase marker:</span>
        buf<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(</span>pos<span class="hl opt">,</span> MARKER<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() +</span> <span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl slc">// Append counter &amp; error info:</span>
        ostringstream out<span class="hl opt">;</span>
        out <span class="hl opt">&lt;&lt;</span> buf <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; // (&quot;</span> <span class="hl opt">&lt;&lt; ++</span>counter <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;) &quot;</span>
            <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Chapter &quot;</span> <span class="hl opt">&lt;&lt;</span> CHAP
            <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; File: &quot;</span> <span class="hl opt">&lt;&lt;</span> FNAME
            <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; Line &quot;</span> <span class="hl opt">&lt;&lt;</span> linecount <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        edited <span class="hl opt">&lt;&lt;</span> out<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
        errlines <span class="hl opt">&lt;&lt;</span> out<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span> <span class="hl slc">// Append error file</span>
      <span class="hl opt">}</span>
      <span class="hl kwa">else</span>
        edited <span class="hl opt">&lt;&lt;</span> buf <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span> <span class="hl slc">// Just copy</span>
      <span class="hl opt">++</span>linecount<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">saveFiles</span><span class="hl opt">() {</span>
    ofstream <span class="hl kwd">outfile</span><span class="hl opt">(</span>FNAME<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span> <span class="hl slc">// Overwrites</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>outfile<span class="hl opt">,</span> FNAME<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    outfile <span class="hl opt">&lt;&lt;</span> edited<span class="hl opt">.</span><span class="hl kwd">rdbuf</span><span class="hl opt">();</span>
    ofstream <span class="hl kwd">count</span><span class="hl opt">(</span>ERRNUM<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span> <span class="hl slc">// Overwrites</span>
    <span class="hl kwd">assure</span><span class="hl opt">(</span>count<span class="hl opt">,</span> ERRNUM<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
    count <span class="hl opt">&lt;&lt;</span> counter<span class="hl opt">;</span> <span class="hl slc">// Save new counter</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwb">const</span> string <span class="hl kwd">ERRCOUNT</span><span class="hl opt">(</span><span class="hl str">&quot;../errnum.txt&quot;</span><span class="hl opt">),</span>
    <span class="hl kwd">ERRFILE</span><span class="hl opt">(</span><span class="hl str">&quot;../errlines.txt&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">requireMinArgs</span><span class="hl opt">(</span>argc<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> USAGE<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">][</span><span class="hl num">0</span><span class="hl opt">] ==</span> <span class="hl str">'/'</span> <span class="hl opt">||</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">][</span><span class="hl num">0</span><span class="hl opt">] ==</span> <span class="hl str">'-'</span><span class="hl opt">) {</span>
    <span class="hl slc">// Allow for other switches:</span>
    <span class="hl kwa">switch</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">][</span><span class="hl num">1</span><span class="hl opt">]) {</span>
      <span class="hl kwa">case</span> <span class="hl str">'r'</span><span class="hl opt">:</span> <span class="hl kwa">case</span> <span class="hl str">'R'</span><span class="hl opt">:</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;reset counter&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwd">remove</span><span class="hl opt">(</span>ERRCOUNT<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span> <span class="hl slc">// Delete files</span>
        <span class="hl kwd">remove</span><span class="hl opt">(</span>ERRFILE<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
        <span class="hl kwa">return</span> EXIT_SUCCESS<span class="hl opt">;</span>
      <span class="hl kwa">default</span><span class="hl opt">:</span>
        cerr <span class="hl opt">&lt;&lt;</span> USAGE <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">==</span> <span class="hl num">3</span><span class="hl opt">) {</span>
    Showerr <span class="hl kwd">s</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">],</span> ERRCOUNT<span class="hl opt">,</span> ERRFILE<span class="hl opt">,</span> <span class="hl kwd">atoi</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">]));</span>
    s<span class="hl opt">.</span><span class="hl kwd">replaceErrors</span><span class="hl opt">();</span>
    s<span class="hl opt">.</span><span class="hl kwd">saveFiles</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.22. C04/Showerr.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div><div class="sect2" title="5.10.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4375928"></a>5.10.3.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4376440"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:DataLogger.h</span>
<span class="hl slc">// Datalogger record layout.</span>
<span class="hl ppc">#ifndef DATALOG_H</span>
<span class="hl ppc">#define DATALOG_H</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;iosfwd&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>ostream<span class="hl opt">;</span>

<span class="hl kwb">struct</span> Coord <span class="hl opt">{</span>
  <span class="hl kwb">int</span> deg<span class="hl opt">,</span> min<span class="hl opt">,</span> sec<span class="hl opt">;</span>
  <span class="hl kwd">Coord</span><span class="hl opt">(</span><span class="hl kwb">int</span> d <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> m <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> s <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">deg</span><span class="hl opt">(</span>d<span class="hl opt">),</span> <span class="hl kwd">min</span><span class="hl opt">(</span>m<span class="hl opt">),</span> <span class="hl kwd">sec</span><span class="hl opt">(</span>s<span class="hl opt">) {}</span>
  std<span class="hl opt">::</span>string <span class="hl kwd">toString</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Coord<span class="hl opt">&amp;);</span>

<span class="hl kwc">class</span> DataPoint <span class="hl opt">{</span>
  std<span class="hl opt">::</span><span class="hl kwb">time_t</span> timestamp<span class="hl opt">;</span> <span class="hl slc">// Time &amp; day</span>
  Coord latitude<span class="hl opt">,</span> longitude<span class="hl opt">;</span>
  <span class="hl kwb">double</span> depth<span class="hl opt">,</span> temperature<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DataPoint</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwb">time_t</span> ts<span class="hl opt">,</span> <span class="hl kwb">const</span> Coord<span class="hl opt">&amp;</span> lat<span class="hl opt">,</span>
            <span class="hl kwb">const</span> Coord<span class="hl opt">&amp;</span> lon<span class="hl opt">,</span> <span class="hl kwb">double</span> dep<span class="hl opt">,</span> <span class="hl kwb">double</span> temp<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">timestamp</span><span class="hl opt">(</span>ts<span class="hl opt">),</span> <span class="hl kwd">latitude</span><span class="hl opt">(</span>lat<span class="hl opt">),</span> <span class="hl kwd">longitude</span><span class="hl opt">(</span>lon<span class="hl opt">),</span>
      <span class="hl kwd">depth</span><span class="hl opt">(</span>dep<span class="hl opt">),</span> <span class="hl kwd">temperature</span><span class="hl opt">(</span>temp<span class="hl opt">) {}</span>
  <span class="hl kwd">DataPoint</span><span class="hl opt">() :</span> <span class="hl kwd">timestamp</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">depth</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">temperature</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> DataPoint<span class="hl opt">&amp;);</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DATALOG_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 5.23. C04/DataLogger.h</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4379056"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:DataLogger.cpp {O}</span>
<span class="hl slc">// Datapoint implementations.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DataLogger.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iomanip&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Coord<span class="hl opt">&amp;</span> c<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>deg <span class="hl opt">&lt;&lt;</span> <span class="hl str">'*'</span> <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>min <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\'</span><span class="hl str">'</span>
            <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>sec <span class="hl opt">&lt;&lt;</span> <span class="hl str">'&quot;'</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

string Coord<span class="hl opt">::</span><span class="hl kwd">toString</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
  ostringstream os<span class="hl opt">;</span>
  os <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> os<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> DataPoint<span class="hl opt">&amp;</span> d<span class="hl opt">) {</span>
  os<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>fixed<span class="hl opt">,</span> ios<span class="hl opt">::</span>floatfield<span class="hl opt">);</span>
  <span class="hl kwb">char</span> fillc <span class="hl opt">=</span> os<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">(</span><span class="hl str">'0'</span><span class="hl opt">);</span> <span class="hl slc">// Pad on left with '0'</span>
  tm<span class="hl opt">*</span> tdata <span class="hl opt">=</span> <span class="hl kwd">localtime</span><span class="hl opt">(&amp;</span>d<span class="hl opt">.</span>timestamp<span class="hl opt">);</span>
  os <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> tdata<span class="hl opt">-&gt;</span>tm_mon <span class="hl opt">+</span> <span class="hl num">1</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\\</span><span class="hl str">'</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> tdata<span class="hl opt">-&gt;</span>tm_mday <span class="hl opt">&lt;&lt;</span> <span class="hl str">'</span><span class="hl esc">\\</span><span class="hl str">'</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> tdata<span class="hl opt">-&gt;</span>tm_year<span class="hl opt">+</span><span class="hl num">1900</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">' '</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> tdata<span class="hl opt">-&gt;</span>tm_hour <span class="hl opt">&lt;&lt;</span> <span class="hl str">':'</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> tdata<span class="hl opt">-&gt;</span>tm_min <span class="hl opt">&lt;&lt;</span> <span class="hl str">':'</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> tdata<span class="hl opt">-&gt;</span>tm_sec<span class="hl opt">;</span>
  os<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">(</span><span class="hl str">' '</span><span class="hl opt">);</span> <span class="hl slc">// Pad on left with ' '</span>
  streamsize prec <span class="hl opt">=</span> os<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">);</span>
  os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; Lat:&quot;</span>    <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span>latitude<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">()</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, Long:&quot;</span>  <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span>longitude<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">()</span>
     <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, depth:&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span>depth
     <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, temp:&quot;</span>  <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">setw</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">) &lt;&lt;</span> d<span class="hl opt">.</span>temperature<span class="hl opt">;</span>
  os<span class="hl opt">.</span><span class="hl kwd">fill</span><span class="hl opt">(</span>fillc<span class="hl opt">);</span>
  os<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">(</span>prec<span class="hl opt">);</span>
  <span class="hl kwa">return</span> os<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.24. C04/DataLogger.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4382744"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Datagen.cpp</span>
<span class="hl slc">// Test data generator.</span>
<span class="hl slc">//{L} DataLogger</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DataLogger.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">time_t</span> timer<span class="hl opt">;</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(&amp;</span>timer<span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  ofstream <span class="hl kwd">data</span><span class="hl opt">(</span><span class="hl str">&quot;data.txt&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>data<span class="hl opt">,</span> <span class="hl str">&quot;data.txt&quot;</span><span class="hl opt">);</span>
  ofstream <span class="hl kwd">bindata</span><span class="hl opt">(</span><span class="hl str">&quot;data.bin&quot;</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>binary<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>bindata<span class="hl opt">,</span> <span class="hl str">&quot;data.bin&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> i<span class="hl opt">++,</span> timer <span class="hl opt">+=</span> <span class="hl num">55</span><span class="hl opt">) {</span>
    <span class="hl slc">// Zero to 199 meters:</span>
    <span class="hl kwb">double</span> newdepth  <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">200</span><span class="hl opt">;</span>
    <span class="hl kwb">double</span> fraction <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span> <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
    newdepth <span class="hl opt">+=</span> <span class="hl num">1.0</span> <span class="hl opt">/</span> fraction<span class="hl opt">;</span>
    <span class="hl kwb">double</span> newtemp <span class="hl opt">=</span> <span class="hl num">150</span> <span class="hl opt">+</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">200</span><span class="hl opt">;</span> <span class="hl slc">// Kelvin</span>
    fraction <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span> <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">;</span>
    newtemp <span class="hl opt">+=</span> <span class="hl num">1.0</span> <span class="hl opt">/</span> fraction<span class="hl opt">;</span>
    <span class="hl kwb">const</span> DataPoint <span class="hl kwd">d</span><span class="hl opt">(</span>timer<span class="hl opt">,</span> <span class="hl kwd">Coord</span><span class="hl opt">(</span><span class="hl num">45</span><span class="hl opt">,</span><span class="hl num">20</span><span class="hl opt">,</span><span class="hl num">31</span><span class="hl opt">),</span>
                      <span class="hl kwd">Coord</span><span class="hl opt">(</span><span class="hl num">22</span><span class="hl opt">,</span><span class="hl num">34</span><span class="hl opt">,</span><span class="hl num">18</span><span class="hl opt">),</span> newdepth<span class="hl opt">,</span>
                      newtemp<span class="hl opt">);</span>
    data <span class="hl opt">&lt;&lt;</span> d <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    bindata<span class="hl opt">.</span><span class="hl kwd">write</span><span class="hl opt">(</span><span class="hl kwa">reinterpret_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const char</span><span class="hl opt">*&gt;(&amp;</span>d<span class="hl opt">),</span>
                  <span class="hl kwa">sizeof</span><span class="hl opt">(</span>d<span class="hl opt">));</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.25. C04/Datagen.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4386680"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Datascan.cpp</span>
<span class="hl slc">//{L} DataLogger</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DataLogger.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ifstream <span class="hl kwd">bindata</span><span class="hl opt">(</span><span class="hl str">&quot;data.bin&quot;</span><span class="hl opt">,</span> ios<span class="hl opt">::</span>binary<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>bindata<span class="hl opt">,</span> <span class="hl str">&quot;data.bin&quot;</span><span class="hl opt">);</span>
  DataPoint d<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>bindata<span class="hl opt">.</span><span class="hl kwd">read</span><span class="hl opt">(</span><span class="hl kwa">reinterpret_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">*&gt;(&amp;</span>d<span class="hl opt">),</span>
         <span class="hl kwa">sizeof</span> d<span class="hl opt">))</span>
    cout <span class="hl opt">&lt;&lt;</span> d <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.26. C04/Datascan.cpp</strong></p></div><br class="example-break" /></div></div><div class="sect1" title="5.11."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4388304"></a>5.11.  </h2></div></div></div><p>

    </p><div class="sect2" title="5.11.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4388816"></a>5.11.1.  </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="5.11.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4391888"></a>5.11.2.  </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4395472"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Locale.cpp {-g++}{-bor}{-edg} {RunByHand}</span>
<span class="hl slc">// Illustrates effects of locales.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;locale&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  locale def<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> def<span class="hl opt">.</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  locale current <span class="hl opt">=</span> cout<span class="hl opt">.</span><span class="hl kwd">getloc</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> current<span class="hl opt">.</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">float</span> val <span class="hl opt">=</span> <span class="hl num">1234.56</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Change to French/France</span>
  cout<span class="hl opt">.</span><span class="hl kwd">imbue</span><span class="hl opt">(</span><span class="hl kwd">locale</span><span class="hl opt">(</span><span class="hl str">&quot;french&quot;</span><span class="hl opt">));</span>
  current <span class="hl opt">=</span> cout<span class="hl opt">.</span><span class="hl kwd">getloc</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> current<span class="hl opt">.</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>

  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Enter the literal 7890,12: &quot;</span><span class="hl opt">;</span>
  cin<span class="hl opt">.</span><span class="hl kwd">imbue</span><span class="hl opt">(</span>cout<span class="hl opt">.</span><span class="hl kwd">getloc</span><span class="hl opt">());</span>
  cin <span class="hl opt">&gt;&gt;</span> val<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout<span class="hl opt">.</span><span class="hl kwd">imbue</span><span class="hl opt">(</span>def<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.27. C04/Locale.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4398256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Facets.cpp {-bor}{-g++}{-mwcc}{-edg}</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;locale&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Change to French/France</span>
  locale <span class="hl kwd">loc</span><span class="hl opt">(</span><span class="hl str">&quot;french&quot;</span><span class="hl opt">);</span>
  cout<span class="hl opt">.</span><span class="hl kwd">imbue</span><span class="hl opt">(</span>loc<span class="hl opt">);</span>
  string currency <span class="hl opt">=</span>
    use_facet<span class="hl opt">&lt;</span>moneypunct<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt; &gt;(</span>loc<span class="hl opt">).</span><span class="hl kwd">curr_symbol</span><span class="hl opt">();</span>
  <span class="hl kwb">char</span> point <span class="hl opt">=</span>
    use_facet<span class="hl opt">&lt;</span>moneypunct<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt; &gt;(</span>loc<span class="hl opt">).</span><span class="hl kwd">decimal_point</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I made &quot;</span> <span class="hl opt">&lt;&lt;</span> currency <span class="hl opt">&lt;&lt;</span> <span class="hl num">12.34</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; today!&quot;</span>
       <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.28. C04/Facets.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="5.12."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4400344"></a>5.12.  </h2></div></div></div><p>

    </p></div><div class="sect1" title="5.13."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4400920"></a>5.13.  </h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4404504"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Exercise14.cpp</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define d(a) cout &lt;&lt; #a</span> <span class="hl pps">&quot; ==</span><span class="hl esc">\t</span><span class="hl pps">&quot;</span><span class="hl ppc"> &lt;&lt; a &lt;&lt; endl;</span>

<span class="hl kwb">void</span> <span class="hl kwd">tellPointers</span><span class="hl opt">(</span>fstream<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwd">d</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">tellp</span><span class="hl opt">());</span>
  <span class="hl kwd">d</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">tellg</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> <span class="hl kwd">tellPointers</span><span class="hl opt">(</span>stringstream<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwd">d</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">tellp</span><span class="hl opt">());</span>
  <span class="hl kwd">d</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">tellg</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  fstream <span class="hl kwd">in</span><span class="hl opt">(</span><span class="hl str">&quot;Exercise14.cpp&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> <span class="hl str">&quot;Exercise14.cpp&quot;</span><span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwd">tellPointers</span><span class="hl opt">(</span>in<span class="hl opt">);</span>
  in<span class="hl opt">.</span><span class="hl kwd">seekp</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">);</span>
  <span class="hl kwd">tellPointers</span><span class="hl opt">(</span>in<span class="hl opt">);</span>
  stringstream <span class="hl kwd">memStream</span><span class="hl opt">(</span><span class="hl str">&quot;Here is a sentence.&quot;</span><span class="hl opt">);</span>
  memStream<span class="hl opt">.</span><span class="hl kwd">seekg</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwd">tellPointers</span><span class="hl opt">(</span>memStream<span class="hl opt">);</span>
  memStream<span class="hl opt">.</span><span class="hl kwd">seekp</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">tellPointers</span><span class="hl opt">(</span>memStream<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 5.29. C04/Exercise14.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4406248"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C04:Exercise15.txt&amp;#13;</span>
Australia<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">5</span>E56<span class="hl opt">,</span><span class="hl num">7667230284</span><span class="hl opt">,</span>Langler<span class="hl opt">,</span>Tyson<span class="hl opt">,</span><span class="hl num">31.2147</span><span class="hl opt">,</span><span class="hl num">0.00042117361</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">2</span>B97<span class="hl opt">,</span><span class="hl num">7586701</span><span class="hl opt">,</span>Oneill<span class="hl opt">,</span>Zeke<span class="hl opt">,</span><span class="hl num">553.429</span><span class="hl opt">,</span><span class="hl num">0.0074673053156065</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">4</span>D75<span class="hl opt">,</span><span class="hl num">7907252710</span><span class="hl opt">,</span>Nickerson<span class="hl opt">,</span>Kelly<span class="hl opt">,</span><span class="hl num">761.612</span><span class="hl opt">,</span><span class="hl num">0.010276276</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">9</span>F2<span class="hl opt">,</span><span class="hl num">6882945012</span><span class="hl opt">,</span>Hartenbach<span class="hl opt">,</span>Neil<span class="hl opt">,</span><span class="hl num">47.9637</span><span class="hl opt">,</span><span class="hl num">0.0006471644</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
Austria<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">480</span>F<span class="hl opt">,</span><span class="hl num">7187262472</span><span class="hl opt">,</span>Oneill<span class="hl opt">,</span>Dee<span class="hl opt">,</span><span class="hl num">264.012</span><span class="hl opt">,</span><span class="hl num">0.00356226040013</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">1</span>B65<span class="hl opt">,</span><span class="hl num">4754732628</span><span class="hl opt">,</span>Haney<span class="hl opt">,</span>Kim<span class="hl opt">,</span><span class="hl num">7.33843</span><span class="hl opt">,</span><span class="hl num">0.000099015948475</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
DA1<span class="hl opt">,</span><span class="hl num">1954960784</span><span class="hl opt">,</span>Pascente<span class="hl opt">,</span>Lester<span class="hl opt">,</span><span class="hl num">56.5452</span><span class="hl opt">,</span><span class="hl num">0.0007629529</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">3</span>F18<span class="hl opt">,</span><span class="hl num">1839715659</span><span class="hl opt">,</span>Elsea<span class="hl opt">,</span>Chelsy<span class="hl opt">,</span><span class="hl num">801.901</span><span class="hl opt">,</span><span class="hl num">0.010819887645</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
Belgium<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
BDF<span class="hl opt">,</span><span class="hl num">5993489554</span><span class="hl opt">,</span>Oneill<span class="hl opt">,</span>Meredith<span class="hl opt">,</span><span class="hl num">283.404</span><span class="hl opt">,</span><span class="hl num">0.0038239127</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">5</span>AC6<span class="hl opt">,</span><span class="hl num">6612945602</span><span class="hl opt">,</span>Parisienne<span class="hl opt">,</span>Biff<span class="hl opt">,</span><span class="hl num">557.74</span><span class="hl opt">,</span><span class="hl num">0.0075254727</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">6</span>AD<span class="hl opt">,</span><span class="hl num">6477082</span><span class="hl opt">,</span>Pennington<span class="hl opt">,</span>Lizanne<span class="hl opt">,</span><span class="hl num">31.0807</span><span class="hl opt">,</span><span class="hl num">0.0004193544</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">4</span>D0E<span class="hl opt">,</span><span class="hl num">7861652688</span><span class="hl opt">,</span>Sisca<span class="hl opt">,</span>Francis<span class="hl opt">,</span><span class="hl num">704.751</span><span class="hl opt">,</span><span class="hl num">0.00950906238</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
Bahamas<span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">37</span>D8<span class="hl opt">,</span><span class="hl num">6837424208</span><span class="hl opt">,</span>Parisienne<span class="hl opt">,</span>Samson<span class="hl opt">,</span><span class="hl num">396.104</span><span class="hl opt">,</span><span class="hl num">0.0053445</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">5</span>E98<span class="hl opt">,</span><span class="hl num">6384069</span><span class="hl opt">,</span>Willis<span class="hl opt">,</span>Pam<span class="hl opt">,</span><span class="hl num">90.4257</span><span class="hl opt">,</span><span class="hl num">0.00122009564059246</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">1462</span><span class="hl opt">,</span><span class="hl num">1288616408</span><span class="hl opt">,</span>Stover<span class="hl opt">,</span>Hazal<span class="hl opt">,</span><span class="hl num">583.939</span><span class="hl opt">,</span><span class="hl num">0.007878970561</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">5</span>FF3<span class="hl opt">,</span><span class="hl num">8028775718</span><span class="hl opt">,</span>Stromstedt<span class="hl opt">,</span>Bunk<span class="hl opt">,</span><span class="hl num">39.8712</span><span class="hl opt">,</span><span class="hl num">0.000537974</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">1095</span><span class="hl opt">,</span><span class="hl num">3737212</span><span class="hl opt">,</span>Stover<span class="hl opt">,</span>Denny<span class="hl opt">,</span><span class="hl num">3.05387</span><span class="hl opt">,</span><span class="hl num">0.000041205248883</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl num">7428</span><span class="hl opt">,</span><span class="hl num">2019381883</span><span class="hl opt">,</span>Parisienne<span class="hl opt">,</span>Shane<span class="hl opt">,</span><span class="hl num">363.272</span><span class="hl opt">,</span><span class="hl num">0.00490155</span><span class="hl opt">&amp;</span><span class="hl ppc">#13;</span>
<span class="hl slc">///:~&amp;#13;</span>
</pre></div><p class="title"><strong>Listado 5.30. C04/Exercise15.txt</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp4052024" href="#idp4052024" class="para">11</a>] </sup>
	    Explicadas en profundidad en el capítulo 5.
	  </p></div><div class="footnote"><p><sup>[<a id="ftn.idp4113864" href="#idp4113864" class="para">12</a>] </sup>Por esa
	razón usted puede escribir <code class="classname">ios::failbit</code>
	en lugar de <code class="classname">ios_base::failbit</code> para
	ahorrar pulsaciones.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp4134536" href="#idp4134536" class="para">13</a>] </sup>Es común el uso de
      <code class="function">operator void*()</code> en vez de
      <code class="function">operator bool()</code> porque las conversiones
      implícitas de booleano a entero pueden causar sorpresas; pueden
      emplazarle incorrectamente un stream en un contexto donde una
      conversion a integer puede ser aplicada. La función
      <code class="function">operator void*()</code> solo será llamada
      implícitamente en el cuerpo de una expresión
      booleana.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp4143848" href="#idp4143848" class="para">14</a>] </sup>un tipo integral usado para alojar bits aislados.</p></div><div class="footnote"><p><sup>[<a id="ftn.idp4200760" href="#idp4200760" class="para">15</a>] </sup>Un tratado mucho más en profundidad de buffers de stream y streams en general puede ser encontrado en[<span class="citation"> Langer &amp; Kreft's, Standar C++ iostreams and Locales, Addison-Wesley, 1999.</span>]</p></div><div class="footnote"><p><sup>[<a id="ftn.idp4240024" href="#idp4240024" class="para">16</a>] </sup>Para más información sobre la epsilon de la máquina y el
	cómputo de punto flotante en general, vea el artículo de
	Chuck, "The Standard C Library, Part 3", C/C++ Users Journal,
	Marzo 1995, disponible en
	www.freshsources.com/1995006a.htm</p></div></div></div><div class="chapter" title="6: Las plantillas en profundidad"><div class="titlepage"><div><div><h2 class="title"><a id="C05"></a>6: Las plantillas en profundidad</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp4410728">6.1.  </a></span></dt><dt><span class="sect1"><a href="#idp4459360">6.2.  </a></span></dt><dt><span class="sect1"><a href="#idp4497464">6.3.  </a></span></dt><dt><span class="sect1"><a href="#idp4524448">6.4.  </a></span></dt><dt><span class="sect1"><a href="#idp4550120">6.5.  </a></span></dt><dt><span class="sect1"><a href="#idp4575968">6.6.  </a></span></dt><dt><span class="sect1"><a href="#idp4617776">6.7.  </a></span></dt><dt><span class="sect1"><a href="#idp4632064">6.8.  </a></span></dt></dl></div><p>

  </p><p>

  </p><div class="sect1" title="6.1."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4410728"></a>6.1.  </h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  T<span class="hl opt">*</span> data<span class="hl opt">;</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">);</span>
  <span class="hl slc">// Etc.</span>
<span class="hl opt">};</span>
</pre><p>

    </p><pre class="programlisting">
Stack<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> myStack<span class="hl opt">;</span> <span class="hl slc">// A Stack of ints</span>
</pre><p>

    </p><div class="sect2" title="6.1.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4413424"></a>6.1.1.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>  <span class="hl slc">// Fixed capacity is N</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">);</span>
  <span class="hl slc">// Etc.</span>
<span class="hl opt">};</span>
</pre><p>

      </p><pre class="programlisting">
Stack<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">100</span><span class="hl opt">&gt;</span> myFixedStack<span class="hl opt">;</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4415560"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Urand.h {-bor}</span>
<span class="hl slc">// Unique randomizer.</span>
<span class="hl ppc">#ifndef URAND_H</span>
<span class="hl ppc">#define URAND_H</span>
<span class="hl ppc">#include &lt;bitset&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>bitset<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">size_t</span> UpperBound<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Urand <span class="hl opt">{</span>
  bitset<span class="hl opt">&lt;</span>UpperBound<span class="hl opt">&gt;</span> used<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Urand</span><span class="hl opt">() {</span> <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">)); }</span> <span class="hl slc">// Randomize</span>
  <span class="hl kwb">size_t</span> <span class="hl kwc">operator</span><span class="hl opt">()();</span> <span class="hl slc">// The &quot;generator&quot; function</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">size_t</span> UpperBound<span class="hl opt">&gt;</span>
<span class="hl kwc">inline</span> <span class="hl kwb">size_t</span> Urand<span class="hl opt">&lt;</span>UpperBound<span class="hl opt">&gt;::</span><span class="hl kwc">operator</span><span class="hl opt">()() {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>used<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">() ==</span> UpperBound<span class="hl opt">)</span>
    used<span class="hl opt">.</span><span class="hl kwd">reset</span><span class="hl opt">();</span>  <span class="hl slc">// Start over (clear bitset)</span>
  <span class="hl kwb">size_t</span> newval<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>used<span class="hl opt">[</span>newval <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> UpperBound<span class="hl opt">])</span>
    <span class="hl opt">;</span> <span class="hl slc">// Until unique value is found</span>
  used<span class="hl opt">[</span>newval<span class="hl opt">] =</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> newval<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// URAND_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.1. C05/Urand.h</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4418120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:UrandTest.cpp {-bor}</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Urand.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Urand<span class="hl opt">&lt;</span><span class="hl num">10</span><span class="hl opt">&gt;</span> u<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">u</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.2. C05/UrandTest.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.1.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4419536"></a>6.1.2.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>  <span class="hl slc">// Fixed capacity is N</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">);</span>
  <span class="hl slc">// Etc.</span>
<span class="hl opt">};</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T <span class="hl opt">=</span> <span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">size_t</span> N <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">&gt;</span>  <span class="hl slc">// Both defaulted</span>
<span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>  <span class="hl slc">// Fixed capacity is N</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">);</span>
  <span class="hl slc">// Etc.</span>
<span class="hl opt">};</span>

Stack<span class="hl opt">&lt;&gt;</span> myStack<span class="hl opt">;</span>  <span class="hl slc">// Same as Stack&lt;int, 100&gt;</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> Allocator <span class="hl opt">=</span> allocator<span class="hl opt">&lt;</span>T<span class="hl opt">&gt; &gt;</span>
<span class="hl kwc">class</span> vector<span class="hl opt">;</span>
</pre><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4423224"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:FuncDef.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> T <span class="hl kwd">sum</span><span class="hl opt">(</span>T<span class="hl opt">*</span> b<span class="hl opt">,</span> T<span class="hl opt">*</span> e<span class="hl opt">,</span> T init <span class="hl opt">=</span> <span class="hl kwd">T</span><span class="hl opt">()) {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>b <span class="hl opt">!=</span> e<span class="hl opt">)</span>
    init <span class="hl opt">+= *</span>b<span class="hl opt">++;</span>
  <span class="hl kwa">return</span> init<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span> <span class="hl opt">};</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">sum</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]) &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 6</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.3. C05/FuncDef.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.1.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4424944"></a>6.1.3.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4425456"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:TempTemp.cpp</span>
<span class="hl slc">// Illustrates a template template parameter.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Array <span class="hl opt">{</span> <span class="hl slc">// A simple, expandable sequence</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> INIT <span class="hl opt">=</span> <span class="hl num">10</span> <span class="hl opt">};</span>
  T<span class="hl opt">*</span> data<span class="hl opt">;</span>
  <span class="hl kwb">size_t</span> capacity<span class="hl opt">;</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Array</span><span class="hl opt">() {</span>
    count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    data <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">[</span>capacity <span class="hl opt">=</span> INIT<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Array</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> <span class="hl opt">[]</span> data<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">==</span> capacity<span class="hl opt">) {</span>
      <span class="hl slc">// Grow underlying array</span>
      <span class="hl kwb">size_t</span> newCap <span class="hl opt">=</span> <span class="hl num">2</span> <span class="hl opt">*</span> capacity<span class="hl opt">;</span>
      T<span class="hl opt">*</span> newData <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">[</span>newCap<span class="hl opt">];</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> count<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
        newData<span class="hl opt">[</span>i<span class="hl opt">] =</span> data<span class="hl opt">[</span>i<span class="hl opt">];</span>
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span> data<span class="hl opt">;</span>
      data <span class="hl opt">=</span> newData<span class="hl opt">;</span>
      capacity <span class="hl opt">=</span> newCap<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    data<span class="hl opt">[</span>count<span class="hl opt">++] =</span> t<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pop_back</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
      <span class="hl opt">--</span>count<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> data<span class="hl opt">; }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> data <span class="hl opt">+</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Container <span class="hl opt">{</span>
  Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> seq<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span> seq<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>t<span class="hl opt">); }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(); }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Container<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> Array<span class="hl opt">&gt;</span> container<span class="hl opt">;</span>
  container<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  container<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> container<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>p <span class="hl opt">!=</span> container<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt; *</span>p<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.4. C05/TempTemp.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> seq<span class="hl opt">;</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
</pre><p>

      </p><pre class="programlisting">
T <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">);</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4430920"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:TempTemp2.cpp</span>
<span class="hl slc">// A multi-variate template template parameter.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Array <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Array</span><span class="hl opt">() {</span> count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">&lt;</span> N<span class="hl opt">)</span>
      data<span class="hl opt">[</span>count<span class="hl opt">++] =</span> t<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pop_back</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
      <span class="hl opt">--</span>count<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> data<span class="hl opt">; }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> data <span class="hl opt">+</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span><span class="hl kwb">size_t</span> N<span class="hl opt">,</span><span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">,</span><span class="hl kwb">size_t</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Container <span class="hl opt">{</span>
  Seq<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;</span> seq<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span> seq<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>t<span class="hl opt">); }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(); }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const size_t</span> N <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
  Container<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> N<span class="hl opt">,</span> Array<span class="hl opt">&gt;</span> container<span class="hl opt">;</span>
  container<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  container<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> container<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>p <span class="hl opt">!=</span> container<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt; *</span>p<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.5. C05/TempTemp2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4433576"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:TempTemp3.cpp {-bor}{-msc}</span>
<span class="hl slc">// Template template parameters and default arguments.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">&gt;</span>  <span class="hl slc">// A default argument</span>
<span class="hl kwc">class</span> Array <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>
  <span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Array</span><span class="hl opt">() {</span> count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">&lt;</span> N<span class="hl opt">)</span>
      data<span class="hl opt">[</span>count<span class="hl opt">++] =</span> t<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pop_back</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">)</span>
      <span class="hl opt">--</span>count<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> data<span class="hl opt">; }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> data <span class="hl opt">+</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">,</span> <span class="hl kwb">size_t</span> <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Container <span class="hl opt">{</span>
  Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> seq<span class="hl opt">;</span>  <span class="hl slc">// Default used</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span> seq<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>t<span class="hl opt">); }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(); }</span>
  T<span class="hl opt">*</span> <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Container<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> Array<span class="hl opt">&gt;</span> container<span class="hl opt">;</span>
  container<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  container<span class="hl opt">.</span><span class="hl kwd">append</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> container<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>p <span class="hl opt">!=</span> container<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt; *</span>p<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.6. C05/TempTemp3.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">,</span> <span class="hl kwb">size_t</span> <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4437080"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:TempTemp4.cpp {-bor}{-msc}</span>
<span class="hl slc">// Passes standard sequences as template arguments.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;list&gt;</span>
<span class="hl ppc">#include &lt;memory&gt;</span>  <span class="hl slc">// Declares allocator&lt;T&gt;</span>
<span class="hl ppc"></span><span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> U<span class="hl opt">,</span> <span class="hl kwc">class</span> <span class="hl opt">=</span> allocator<span class="hl opt">&lt;</span>U<span class="hl opt">&gt; &gt;</span>
         <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Container <span class="hl opt">{</span>
  Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> seq<span class="hl opt">;</span> <span class="hl slc">// Default of allocator&lt;T&gt; applied implicitly</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span> seq<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>t<span class="hl opt">); }</span>
  typename Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span>iterator <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(); }</span>
  typename Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span>iterator <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> seq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Use a vector</span>
  Container<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> vector<span class="hl opt">&gt;</span> vContainer<span class="hl opt">;</span>
  vContainer<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  vContainer<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;::</span>iterator p <span class="hl opt">=</span> vContainer<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
      p <span class="hl opt">!=</span> vContainer<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(); ++</span>p<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Use a list</span>
  Container<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> list<span class="hl opt">&gt;</span> lContainer<span class="hl opt">;</span>
  lContainer<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
  lContainer<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>list<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;::</span>iterator p2 <span class="hl opt">=</span> lContainer<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
      p2 <span class="hl opt">!=</span> lContainer<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(); ++</span>p2<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>p2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.7. C05/TempTemp4.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.1.4."><div class="titlepage"><div><div><h3 class="title"><a id="idp4439288"></a>6.1.4.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4439800"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:TypenamedID.cpp {-bor}</span>
<span class="hl slc">// Uses 'typename' as a prefix for nested types.</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> X <span class="hl opt">{</span>
  <span class="hl slc">// Without typename, you should get an error:</span>
  typename T<span class="hl opt">::</span>id i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> i<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">class</span> id <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {}</span>
  <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X<span class="hl opt">&lt;</span>Y<span class="hl opt">&gt;</span> xy<span class="hl opt">;</span>
  xy<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.8. C05/TypenamedID.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4442584"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:PrintSeq.cpp {-msc}{-mwcc}</span>
<span class="hl slc">// A print function for Standard C++ sequences.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;list&gt;</span>
<span class="hl ppc">#include &lt;memory&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> U<span class="hl opt">,</span> <span class="hl kwc">class</span> <span class="hl opt">=</span> allocator<span class="hl opt">&lt;</span>U<span class="hl opt">&gt; &gt;</span>
         <span class="hl kwc">class</span> Seq<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">printSeq</span><span class="hl opt">(</span>Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> seq<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>typename Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span>iterator b <span class="hl opt">=</span> seq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
       b <span class="hl opt">!=</span> seq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();)</span>
    cout <span class="hl opt">&lt;&lt; *</span>b<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Process a vector</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwd">printSeq</span><span class="hl opt">(</span>v<span class="hl opt">);</span>
  <span class="hl slc">// Process a list</span>
  list<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> lst<span class="hl opt">;</span>
  lst<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">);</span>
  lst<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">);</span>
  <span class="hl kwd">printSeq</span><span class="hl opt">(</span>lst<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.9. C05/PrintSeq.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp4444688"></a></h4></div></div></div><p>

	</p><pre class="programlisting">
typename Seq<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span>iterator It<span class="hl opt">;</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">typedef</span> typename Seq<span class="hl opt">&lt;</span>It<span class="hl opt">&gt;::</span>iterator It<span class="hl opt">;</span>
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp4446160"></a></h4></div></div></div><p>

	</p><div class="example"><a id="idp4446608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:UsingTypename.cpp</span>
<span class="hl slc">// Using 'typename' in the template argument list.</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> X <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> x<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.10. C05/UsingTypename.cpp</strong></p></div><br class="example-break" /><p>

	</p></div></div><div class="sect2" title="6.1.5."><div class="titlepage"><div><div><h3 class="title"><a id="idp4447952"></a>6.1.5.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4448464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:DotTemplate.cpp</span>
<span class="hl slc">// Illustrate the .template construct.</span>
<span class="hl ppc">#include &lt;bitset&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span>
basic_string<span class="hl opt">&lt;</span>charT<span class="hl opt">&gt;</span> <span class="hl kwd">bitsetToString</span><span class="hl opt">(</span><span class="hl kwb">const</span> bitset<span class="hl opt">&lt;</span>N<span class="hl opt">&gt;&amp;</span> bs<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> bs<span class="hl opt">.</span> <span class="hl kwc">template</span> to_string<span class="hl opt">&lt;</span>charT<span class="hl opt">,</span> char_traits<span class="hl opt">&lt;</span>charT<span class="hl opt">&gt;,</span>
                                allocator<span class="hl opt">&lt;</span>charT<span class="hl opt">&gt; &gt;();</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  bitset<span class="hl opt">&lt;</span><span class="hl num">10</span><span class="hl opt">&gt;</span> bs<span class="hl opt">;</span>
  bs<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  bs<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> bs <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 0000100010</span>
  string s <span class="hl opt">=</span> bitsetToString<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;(</span>bs<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 0000100010</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.11. C05/DotTemplate.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">,</span> <span class="hl kwc">class</span> traits<span class="hl opt">,</span> <span class="hl kwc">class</span> Allocator<span class="hl opt">&gt;</span>
basic_string<span class="hl opt">&lt;</span>charT<span class="hl opt">,</span> traits<span class="hl opt">,</span> Allocator<span class="hl opt">&gt;</span> <span class="hl kwd">to_string</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
</pre><p>

      </p><pre class="programlisting">
wstring s <span class="hl opt">=</span> bitsetToString<span class="hl opt">&lt;</span><span class="hl kwb">wchar_t</span><span class="hl opt">&gt;(</span>bs<span class="hl opt">);</span>
</pre><p>

      </p><p>

      </p></div><div class="sect2" title="6.1.6."><div class="titlepage"><div><div><h3 class="title"><a id="idp4451912"></a>6.1.6.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> <span class="hl kwb">complex</span> <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> X<span class="hl opt">&gt;</span> <span class="hl kwb">complex</span><span class="hl opt">(</span><span class="hl kwb">const complex</span><span class="hl opt">&lt;</span>X<span class="hl opt">&gt;&amp;);</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwb">complex</span><span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> <span class="hl kwd">z</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl kwb">complex</span><span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;</span> <span class="hl kwd">w</span><span class="hl opt">(</span>z<span class="hl opt">);</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename X<span class="hl opt">&gt;</span>
<span class="hl kwb">complex</span><span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span><span class="hl kwb">complex</span><span class="hl opt">(</span><span class="hl kwb">const complex</span><span class="hl opt">&lt;</span>X<span class="hl opt">&gt;&amp;</span> c<span class="hl opt">) {</span><span class="hl com">/* Body here' */</span><span class="hl opt">}</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> data<span class="hl opt">[</span><span class="hl num">5</span><span class="hl opt">] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">5</span> <span class="hl opt">};</span>
vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span>data<span class="hl opt">,</span> data<span class="hl opt">+</span><span class="hl num">5</span><span class="hl opt">);</span>
vector<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;</span> <span class="hl kwd">v2</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> InputIterator<span class="hl opt">&gt;</span>
<span class="hl kwd">vector</span><span class="hl opt">(</span>InputIterator first<span class="hl opt">,</span> InputIterator last<span class="hl opt">,</span>
       <span class="hl kwb">const</span> Allocator<span class="hl opt">&amp; =</span> <span class="hl kwd">Allocator</span><span class="hl opt">());</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4456456"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:MemberClass.cpp</span>
<span class="hl slc">// A member class template.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;typeinfo&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Outer <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> R<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Inner <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> R<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> Outer<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span>Inner<span class="hl opt">&lt;</span>R<span class="hl opt">&gt;::</span><span class="hl kwd">f</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Outer == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>T<span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Inner == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>R<span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Full Inner == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Outer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;::</span>Inner<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt;</span> inner<span class="hl opt">;</span>
  inner<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.12. C05/MemberClass.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><pre class="screen">
Outer == int
Inner == bool
Full Inner == Outer&lt;int&gt;::Inner&lt;bool&gt;
</pre><p>

      </p><p>

      </p></div></div><div class="sect1" title="6.2."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4459360"></a>6.2.  </h2></div></div></div><p>

    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">&lt;</span> b<span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>

    </p><pre class="programlisting">
<span class="hl kwb">int</span> z <span class="hl opt">=</span> min<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>i<span class="hl opt">,</span> j<span class="hl opt">);</span>
</pre><p>

    </p><div class="sect2" title="6.2.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4461056"></a>6.2.1.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> z <span class="hl opt">=</span> <span class="hl kwd">min</span><span class="hl opt">(</span>i<span class="hl opt">,</span> j<span class="hl opt">);</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> z <span class="hl opt">=</span> <span class="hl kwd">min</span><span class="hl opt">(</span>x<span class="hl opt">,</span> j<span class="hl opt">);</span> <span class="hl slc">// x is a double</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> z <span class="hl opt">=</span> min<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span>x<span class="hl opt">,</span> j<span class="hl opt">);</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">,</span> typename U<span class="hl opt">&gt;</span>
<span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> U<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">&lt;</span> b<span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4464408"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:StringConv.h</span>
<span class="hl slc">// Function templates to convert to and from strings.</span>
<span class="hl ppc">#ifndef STRINGCONV_H</span>
<span class="hl ppc">#define STRINGCONV_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> T <span class="hl kwd">fromString</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  std<span class="hl opt">::</span>istringstream <span class="hl kwd">is</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  T t<span class="hl opt">;</span>
  is <span class="hl opt">&gt;&gt;</span> t<span class="hl opt">;</span>
  <span class="hl kwa">return</span> t<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> std<span class="hl opt">::</span>string <span class="hl kwd">toString</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
  std<span class="hl opt">::</span>ostringstream s<span class="hl opt">;</span>
  s <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">;</span>
  <span class="hl kwa">return</span> s<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// STRINGCONV_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.13. C05/StringConv.h</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4466040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:StringConvTest.cpp</span>
<span class="hl ppc">#include &lt;complex&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;StringConv.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1234</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i ==</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">toString</span><span class="hl opt">(</span>i<span class="hl opt">) &lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">float</span> x <span class="hl opt">=</span> <span class="hl num">567.89</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x ==</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">toString</span><span class="hl opt">(</span>x<span class="hl opt">) &lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">complex</span><span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl num">1.0</span><span class="hl opt">,</span> <span class="hl num">2.0</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;c ==</span> <span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">toString</span><span class="hl opt">(</span>c<span class="hl opt">) &lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>

  i <span class="hl opt">=</span> fromString<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span><span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;1234&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;i == &quot;</span> <span class="hl opt">&lt;&lt;</span> i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  x <span class="hl opt">=</span> fromString<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;(</span><span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;567.89&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x == &quot;</span> <span class="hl opt">&lt;&lt;</span> x <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  c <span class="hl opt">=</span> fromString<span class="hl opt">&lt;</span><span class="hl kwb">complex</span><span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt; &gt;(</span><span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;(1.0,2.0)&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;c == &quot;</span> <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.14. C05/StringConvTest.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="screen">
i == "1234"
x == "567.89"
c == "(1,2)"

i == 1234
x == 567.89
c == (1,2)
</pre><p>

      </p><div class="example"><a id="idp4468424"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:ImplicitCast.cpp</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename R<span class="hl opt">,</span> typename P<span class="hl opt">&gt;</span>
R <span class="hl kwd">implicit_cast</span><span class="hl opt">(</span><span class="hl kwb">const</span> P<span class="hl opt">&amp;</span> p<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> p<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwb">float</span> x <span class="hl opt">=</span> implicit_cast<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;(</span>i<span class="hl opt">);</span>
  <span class="hl kwb">int</span> j <span class="hl opt">=</span> implicit_cast<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
  <span class="hl slc">//! char* p = implicit_cast&lt;char*&gt;(i);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.15. C05/ImplicitCast.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4469968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:ArraySize.cpp</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">size_t</span> R<span class="hl opt">,</span> <span class="hl kwb">size_t</span> C<span class="hl opt">,</span> typename T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">init1</span><span class="hl opt">(</span>T a<span class="hl opt">[</span>R<span class="hl opt">][</span>C<span class="hl opt">]) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> R<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> C<span class="hl opt">; ++</span>j<span class="hl opt">)</span>
      a<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">] =</span> <span class="hl kwd">T</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">size_t</span> R<span class="hl opt">,</span> <span class="hl kwb">size_t</span> C<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">init2</span><span class="hl opt">(</span><span class="hl kwd">T</span> <span class="hl opt">(&amp;</span>a<span class="hl opt">)[</span>R<span class="hl opt">][</span>C<span class="hl opt">]) {</span>  <span class="hl slc">// Reference parameter</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> R<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> C<span class="hl opt">; ++</span>j<span class="hl opt">)</span>
      a<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">] =</span> <span class="hl kwd">T</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">][</span><span class="hl num">20</span><span class="hl opt">];</span>
  init1<span class="hl opt">&lt;</span><span class="hl num">10</span><span class="hl opt">,</span><span class="hl num">20</span><span class="hl opt">&gt;(</span>a<span class="hl opt">);</span>  <span class="hl slc">// Must specify</span>
  <span class="hl kwd">init2</span><span class="hl opt">(</span>a<span class="hl opt">);</span>         <span class="hl slc">// Sizes deduced</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.16. C05/ArraySize.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.2.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4471592"></a>6.2.2.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4472104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:MinTest.cpp</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>strcmp<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>cout<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">&lt;</span> b<span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> a<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>a<span class="hl opt">,</span> b<span class="hl opt">) &lt;</span> <span class="hl num">0</span><span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">double</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">double</span> x<span class="hl opt">,</span> <span class="hl kwb">double</span> y<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>x <span class="hl opt">&lt;</span> y<span class="hl opt">)</span> ? x <span class="hl opt">:</span> y<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const char</span> <span class="hl opt">*</span>s2 <span class="hl opt">=</span> <span class="hl str">&quot;say</span> <span class="hl esc">\&quot;</span><span class="hl str">Ni-!</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span><span class="hl opt">, *</span>s1 <span class="hl opt">=</span> <span class="hl str">&quot;knights who&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>      <span class="hl slc">// 1: 1 (template)</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl num">1.0</span><span class="hl opt">,</span> <span class="hl num">2.0</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 2: 1 (double)</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2.0</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>    <span class="hl slc">// 3: 1 (double)</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">min</span><span class="hl opt">(</span>s1<span class="hl opt">,</span> s2<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>    <span class="hl slc">// 4: knights who (const</span>
                                  <span class="hl slc">//                 char*)</span>
  cout <span class="hl opt">&lt;&lt;</span> min<span class="hl opt">&lt;&gt;(</span>s1<span class="hl opt">,</span> s2<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 5: say &quot;Ni-!&quot;</span>
                                  <span class="hl slc">//    (template)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.17. C05/MinTest.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span>
<span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> b<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
</pre><p>

      </p></div><div class="sect2" title="6.2.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4475472"></a>6.2.3.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4475984"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:TemplateFunctionAddress.cpp {-mwcc}</span>
<span class="hl slc">// Taking the address of a function generated</span>
<span class="hl slc">// from a template.</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>T<span class="hl opt">*) {}</span>

<span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">(*</span>pf<span class="hl opt">)(</span><span class="hl kwb">int</span><span class="hl opt">*)) {}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">(*</span>pf<span class="hl opt">)(</span>T<span class="hl opt">*)) {}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">h</span><span class="hl opt">(&amp;</span>f<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;);</span> <span class="hl slc">// Full type specification</span>
  <span class="hl kwd">h</span><span class="hl opt">(&amp;</span>f<span class="hl opt">);</span> <span class="hl slc">// Type deduction</span>
  g<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(&amp;</span>f<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;);</span> <span class="hl slc">// Full type specification</span>
  <span class="hl kwd">g</span><span class="hl opt">(&amp;</span>f<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;);</span> <span class="hl slc">// Type deduction</span>
  g<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(&amp;</span>f<span class="hl opt">);</span> <span class="hl slc">// Partial (but sufficient) specification</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.18. C05/TemplateFunctionAddress.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl slc">// The variable s is a std::string</span>
<span class="hl kwd">transform</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> tolower<span class="hl opt">);</span>
</pre><p>

      </p><div class="example"><a id="idp4478648"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:FailedTransform.cpp {-xo}</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;LOWER&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> tolower<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.19. C05/FailedTransform.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">&gt;</span> charT <span class="hl kwd">toupper</span><span class="hl opt">(</span>charT c<span class="hl opt">,</span>
                                    <span class="hl kwb">const</span> locale<span class="hl opt">&amp;</span> loc<span class="hl opt">);</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">&gt;</span> charT <span class="hl kwd">tolower</span><span class="hl opt">(</span>charT c<span class="hl opt">,</span>
                                    <span class="hl kwb">const</span> locale<span class="hl opt">&amp;</span> loc<span class="hl opt">);</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwd">transform</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()</span>
    <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">(*)(</span><span class="hl kwb">int</span><span class="hl opt">)&gt;(</span>tolower<span class="hl opt">));</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4481952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:StrTolower.cpp {O} {-mwcc}</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

string <span class="hl kwd">strTolower</span><span class="hl opt">(</span>string s<span class="hl opt">) {</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> tolower<span class="hl opt">);</span>
  <span class="hl kwa">return</span> s<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.20. C05/StrTolower.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4483472"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Tolower.cpp {-mwcc}</span>
<span class="hl slc">//{L} StrTolower</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
string <span class="hl kwd">strTolower</span><span class="hl opt">(</span>string<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;LOWER&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">strTolower</span><span class="hl opt">(</span>s<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.21. C05/Tolower.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4484944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:ToLower2.cpp {-mwcc}</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">&gt;</span> charT <span class="hl kwd">strTolower</span><span class="hl opt">(</span>charT c<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">tolower</span><span class="hl opt">(</span>c<span class="hl opt">);</span>  <span class="hl slc">// One-arg version called</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;LOWER&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),&amp;</span>strTolower<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;);</span>
  cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.22. C05/ToLower2.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.2.4."><div class="titlepage"><div><div><h3 class="title"><a id="idp4486792"></a>6.2.4.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4487304"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:ApplySequence.h</span>
<span class="hl slc">// Apply a function to an STL sequence container.</span>

<span class="hl slc">// const, 0 arguments, any type of return value:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Seq<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> R<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">apply</span><span class="hl opt">(</span>Seq<span class="hl opt">&amp;</span> sq<span class="hl opt">,</span> <span class="hl kwd">R</span> <span class="hl opt">(</span>T<span class="hl opt">::*</span>f<span class="hl opt">)()</span> <span class="hl kwb">const</span><span class="hl opt">) {</span>
  typename Seq<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> sq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> sq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    <span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;*</span>f<span class="hl opt">)();</span>
<span class="hl opt">}</span>

<span class="hl slc">// const, 1 argument, any type of return value:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Seq<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> R<span class="hl opt">,</span> <span class="hl kwc">class</span> A<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">apply</span><span class="hl opt">(</span>Seq<span class="hl opt">&amp;</span> sq<span class="hl opt">,</span> <span class="hl kwd">R</span><span class="hl opt">(</span>T<span class="hl opt">::*</span>f<span class="hl opt">)(</span>A<span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">,</span> A a<span class="hl opt">) {</span>
  typename Seq<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> sq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> sq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    <span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;*</span>f<span class="hl opt">)(</span>a<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// const, 2 arguments, any type of return value:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Seq<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> R<span class="hl opt">,</span>
         <span class="hl kwc">class</span> A1<span class="hl opt">,</span> <span class="hl kwc">class</span> A2<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">apply</span><span class="hl opt">(</span>Seq<span class="hl opt">&amp;</span> sq<span class="hl opt">,</span> <span class="hl kwd">R</span><span class="hl opt">(</span>T<span class="hl opt">::*</span>f<span class="hl opt">)(</span>A1<span class="hl opt">,</span> A2<span class="hl opt">)</span> <span class="hl kwb">const</span><span class="hl opt">,</span>
    A1 a1<span class="hl opt">,</span> A2 a2<span class="hl opt">) {</span>
  typename Seq<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> sq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> sq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    <span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;*</span>f<span class="hl opt">)(</span>a1<span class="hl opt">,</span> a2<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// Non-const, 0 arguments, any type of return value:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Seq<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> R<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">apply</span><span class="hl opt">(</span>Seq<span class="hl opt">&amp;</span> sq<span class="hl opt">,</span> <span class="hl kwd">R</span> <span class="hl opt">(</span>T<span class="hl opt">::*</span>f<span class="hl opt">)()) {</span>
  typename Seq<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> sq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> sq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    <span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;*</span>f<span class="hl opt">)();</span>
<span class="hl opt">}</span>

<span class="hl slc">// Non-const, 1 argument, any type of return value:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Seq<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> R<span class="hl opt">,</span> <span class="hl kwc">class</span> A<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">apply</span><span class="hl opt">(</span>Seq<span class="hl opt">&amp;</span> sq<span class="hl opt">,</span> <span class="hl kwd">R</span><span class="hl opt">(</span>T<span class="hl opt">::*</span>f<span class="hl opt">)(</span>A<span class="hl opt">),</span> A a<span class="hl opt">) {</span>
  typename Seq<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> sq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> sq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    <span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;*</span>f<span class="hl opt">)(</span>a<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// Non-const, 2 arguments, any type of return value:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Seq<span class="hl opt">,</span> <span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> R<span class="hl opt">,</span>
         <span class="hl kwc">class</span> A1<span class="hl opt">,</span> <span class="hl kwc">class</span> A2<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">apply</span><span class="hl opt">(</span>Seq<span class="hl opt">&amp;</span> sq<span class="hl opt">,</span> <span class="hl kwd">R</span><span class="hl opt">(</span>T<span class="hl opt">::*</span>f<span class="hl opt">)(</span>A1<span class="hl opt">,</span> A2<span class="hl opt">),</span>
    A1 a1<span class="hl opt">,</span> A2 a2<span class="hl opt">) {</span>
  typename Seq<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> sq<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> sq<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    <span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;*</span>f<span class="hl opt">)(</span>a1<span class="hl opt">,</span> a2<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl slc">// Etc., to handle maximum likely arguments ///:~</span>
</pre></div><p class="title"><strong>Listado 6.23. C05/ApplySequence.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4490496"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Gromit.h</span>
<span class="hl slc">// The techno-dog. Has member functions</span>
<span class="hl slc">// with various numbers of arguments.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwc">class</span> Gromit <span class="hl opt">{</span>
  <span class="hl kwb">int</span> arf<span class="hl opt">;</span>
  <span class="hl kwb">int</span> totalBarks<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Gromit</span><span class="hl opt">(</span><span class="hl kwb">int</span> arf <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">) :</span> <span class="hl kwd">arf</span><span class="hl opt">(</span>arf <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">totalBarks</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">speak</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> arf<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;arf! &quot;</span><span class="hl opt">;</span>
      <span class="hl opt">++</span>totalBarks<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">char</span> <span class="hl kwd">eat</span><span class="hl opt">(</span><span class="hl kwb">float</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;chomp!&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl str">'z'</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;zzz...&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">sit</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Sitting...&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.24. C05/Gromit.h</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4492288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:ApplyGromit.cpp</span>
<span class="hl slc">// Test ApplySequence.h.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;ApplySequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Gromit.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Gromit<span class="hl opt">*&gt;</span> dogs<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    dogs<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Gromit</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl kwd">apply</span><span class="hl opt">(</span>dogs<span class="hl opt">, &amp;</span>Gromit<span class="hl opt">::</span>speak<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">apply</span><span class="hl opt">(</span>dogs<span class="hl opt">, &amp;</span>Gromit<span class="hl opt">::</span>eat<span class="hl opt">,</span> <span class="hl num">2.0</span>f<span class="hl opt">);</span>
  <span class="hl kwd">apply</span><span class="hl opt">(</span>dogs<span class="hl opt">, &amp;</span>Gromit<span class="hl opt">::</span>sleep<span class="hl opt">,</span> <span class="hl str">'z'</span><span class="hl opt">,</span> <span class="hl num">3.0</span><span class="hl opt">);</span>
  <span class="hl kwd">apply</span><span class="hl opt">(</span>dogs<span class="hl opt">, &amp;</span>Gromit<span class="hl opt">::</span>sit<span class="hl opt">);</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>dogs<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.25. C05/ApplyGromit.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div><div class="sect2" title="6.2.5."><div class="titlepage"><div><div><h3 class="title"><a id="idp4494080"></a>6.2.5.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>T<span class="hl opt">);</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>T<span class="hl opt">*);</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">*);</span>
</pre><p>

      </p><div class="example"><a id="idp4495232"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:PartialOrder.cpp</span>
<span class="hl slc">// Reveals ordering of function templates.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>T<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;T&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>T<span class="hl opt">*) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;T*&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">*) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;const T*&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>            <span class="hl slc">// T</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(&amp;</span>i<span class="hl opt">);</span>           <span class="hl slc">// T*</span>
  <span class="hl kwb">const int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">f</span><span class="hl opt">(&amp;</span>j<span class="hl opt">);</span>           <span class="hl slc">// const T*</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.26. C05/PartialOrder.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div></div><div class="sect1" title="6.3."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4497464"></a>6.3.  </h2></div></div></div><p>

    </p><div class="sect2" title="6.3.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4497976"></a>6.3.1.  </h3></div></div></div><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> a<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>a<span class="hl opt">,</span> b<span class="hl opt">) &lt;</span> <span class="hl num">0</span><span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre><p>

      </p><div class="example"><a id="idp4499360"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:MinTest2.cpp</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>strcmp<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>cout<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">&lt;</span> b<span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// An explicit specialization of the min template</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span>
<span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwb">const</span><span class="hl opt">&amp;</span> min<span class="hl opt">&lt;</span><span class="hl kwb">const char</span><span class="hl opt">*&gt;(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwb">const</span><span class="hl opt">&amp;</span> a<span class="hl opt">,</span>
                                    <span class="hl kwb">const char</span><span class="hl opt">*</span> <span class="hl kwb">const</span><span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span>a<span class="hl opt">,</span> b<span class="hl opt">) &lt;</span> <span class="hl num">0</span><span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const char</span> <span class="hl opt">*</span>s2 <span class="hl opt">=</span> <span class="hl str">&quot;say</span> <span class="hl esc">\&quot;</span><span class="hl str">Ni-!</span><span class="hl esc">\&quot;</span><span class="hl str">&quot;</span><span class="hl opt">, *</span>s1 <span class="hl opt">=</span> <span class="hl str">&quot;knights who&quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">min</span><span class="hl opt">(</span>s1<span class="hl opt">,</span> s2<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> min<span class="hl opt">&lt;&gt;(</span>s1<span class="hl opt">,</span> s2<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.27. C05/MinTest2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> Allocator <span class="hl opt">=</span> allocator<span class="hl opt">&lt;</span>T<span class="hl opt">&gt; &gt;</span>
<span class="hl kwc">class</span> vector <span class="hl opt">{...};</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">class</span> vector<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">,</span> allocator<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt; &gt; {...};</span>
</pre><p>

      </p><p>

      </p></div><div class="sect2" title="6.3.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4503144"></a>6.3.2.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Allocator<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> vector<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">,</span> Allocator<span class="hl opt">&gt;;</span>
</pre><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4504672"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:PartialOrder2.cpp</span>
<span class="hl slc">// Reveals partial ordering of class templates.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Primary Template</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> U<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;T == int</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;U == double</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C<span class="hl opt">&lt;</span>T<span class="hl opt">*,</span> U<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;T* used</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> U<span class="hl opt">*&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;U* used</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C<span class="hl opt">&lt;</span>T<span class="hl opt">*,</span> U<span class="hl opt">*&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;T* and U* used</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> C<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> T<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;T == U</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span>    <span class="hl slc">// 1: Primary template</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span>    <span class="hl slc">// 2: T == int</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// 3: U == double</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span>  <span class="hl slc">// 4: T == U</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">*,</span> <span class="hl kwb">float</span><span class="hl opt">&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// 5: T* used [T is float]</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">,</span> <span class="hl kwb">float</span><span class="hl opt">*&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// 6: U* used [U is float]</span>
  C<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">*,</span> <span class="hl kwb">int</span><span class="hl opt">*&gt;().</span><span class="hl kwd">f</span><span class="hl opt">();</span>  <span class="hl slc">// 7: T* and U* used [float,int]</span>
  <span class="hl slc">// The following are ambiguous:</span>
<span class="hl slc">//   8: C&lt;int, int&gt;().f();</span>
<span class="hl slc">//   9: C&lt;double, double&gt;().f();</span>
<span class="hl slc">//  10: C&lt;float*, float*&gt;().f();</span>
<span class="hl slc">//  11: C&lt;int, int*&gt;().f();</span>
<span class="hl slc">//  12: C&lt;int*, int*&gt;().f();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.28. C05/PartialOrder2.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.3.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4507808"></a>6.3.3.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4508320"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Sortable.h</span>
<span class="hl slc">// Template specialization.</span>
<span class="hl ppc">#ifndef SORTABLE_H</span>
<span class="hl ppc">#define SORTABLE_H</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Sortable <span class="hl opt">:</span> <span class="hl kwc">public</span> std<span class="hl opt">::</span>vector<span class="hl opt">&lt;</span>T<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">sort</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> Sortable<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span><span class="hl kwd">sort</span><span class="hl opt">() {</span> <span class="hl slc">// A simple sort</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">size</span><span class="hl opt">();</span> i <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">; --</span>i<span class="hl opt">)</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> i<span class="hl opt">; ++</span>j<span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">) &gt;</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">)) {</span>
        T t <span class="hl opt">=</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">) =</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">);</span>
        <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">) =</span> t<span class="hl opt">;</span>
      <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl slc">// Partial specialization for pointers:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Sortable<span class="hl opt">&lt;</span>T<span class="hl opt">*&gt; :</span> <span class="hl kwc">public</span> std<span class="hl opt">::</span>vector<span class="hl opt">&lt;</span>T<span class="hl opt">*&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">sort</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> Sortable<span class="hl opt">&lt;</span>T<span class="hl opt">*&gt;::</span><span class="hl kwd">sort</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">size</span><span class="hl opt">();</span> i <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">; --</span>i<span class="hl opt">)</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> i<span class="hl opt">; ++</span>j<span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">) &gt; *</span><span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">)) {</span>
        T<span class="hl opt">*</span> t <span class="hl opt">=</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">) =</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">);</span>
        <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">) =</span> t<span class="hl opt">;</span>
      <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl slc">// Full specialization for char*</span>
<span class="hl slc">// (Made inline here for convenience -- normally you would</span>
<span class="hl slc">// place the function body in a separate file and only</span>
<span class="hl slc">// leave the declaration here).</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">inline</span> <span class="hl kwb">void</span> Sortable<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">*&gt;::</span><span class="hl kwd">sort</span><span class="hl opt">() {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">size</span><span class="hl opt">();</span> i <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">; --</span>i<span class="hl opt">)</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> j <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> i<span class="hl opt">; ++</span>j<span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">strcmp</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">)) &gt;</span> <span class="hl num">0</span><span class="hl opt">) {</span>
        <span class="hl kwb">char</span><span class="hl opt">*</span> t <span class="hl opt">=</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">) =</span> <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">);</span>
        <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">at</span><span class="hl opt">(</span>j<span class="hl opt">) =</span> t<span class="hl opt">;</span>
      <span class="hl opt">}</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// SORTABLE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.29. C05/Sortable.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4512040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Sortable.cpp</span>
<span class="hl slc">//{-bor} (Because of bitset in Urand.h)</span>
<span class="hl slc">// Testing template specialization.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Sortable.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Urand.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl ppc">#define asz(a) (sizeof a / sizeof a[0])</span>

<span class="hl kwb">char</span><span class="hl opt">*</span> words<span class="hl opt">[] = {</span> <span class="hl str">&quot;is&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;running&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;big&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;dog&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">, };</span>
<span class="hl kwb">char</span><span class="hl opt">*</span> words2<span class="hl opt">[] = {</span> <span class="hl str">&quot;this&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;that&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;theother&quot;</span><span class="hl opt">, };</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Sortable<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> is<span class="hl opt">;</span>
  Urand<span class="hl opt">&lt;</span><span class="hl num">47</span><span class="hl opt">&gt;</span> rnd<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">15</span><span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    is<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwd">rnd</span><span class="hl opt">());</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> is<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> is<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  is<span class="hl opt">.</span><span class="hl kwd">sort</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> is<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> is<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>

  <span class="hl slc">// Uses the template partial specialization:</span>
  Sortable<span class="hl opt">&lt;</span>string<span class="hl opt">*&gt;</span> ss<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwd">asz</span><span class="hl opt">(</span>words<span class="hl opt">); ++</span>i<span class="hl opt">)</span>
    ss<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">string</span><span class="hl opt">(</span>words<span class="hl opt">[</span>i<span class="hl opt">]));</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> ss<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>ss<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  ss<span class="hl opt">.</span><span class="hl kwd">sort</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> ss<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>ss<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
    <span class="hl kwa">delete</span> ss<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>

  <span class="hl slc">// Uses the full char* specialization:</span>
  Sortable<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">*&gt;</span> scp<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwd">asz</span><span class="hl opt">(</span>words2<span class="hl opt">); ++</span>i<span class="hl opt">)</span>
    scp<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>words2<span class="hl opt">[</span>i<span class="hl opt">]);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> scp<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> scp<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  scp<span class="hl opt">.</span><span class="hl kwd">sort</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> scp<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> scp<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.30. C05/Sortable.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.3.4."><div class="titlepage"><div><div><h3 class="title"><a id="idp4515048"></a>6.3.4.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4515560"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:DelayedInstantiation.cpp</span>
<span class="hl slc">// Member functions of class templates are not</span>
<span class="hl slc">// instantiated until they're needed.</span>

<span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Y <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Z <span class="hl opt">{</span>
  T t<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">a</span><span class="hl opt">() {</span> t<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">b</span><span class="hl opt">() {</span> t<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Z<span class="hl opt">&lt;</span>X<span class="hl opt">&gt;</span> zx<span class="hl opt">;</span>
  zx<span class="hl opt">.</span><span class="hl kwd">a</span><span class="hl opt">();</span> <span class="hl slc">// Doesn't create Z&lt;X&gt;::b()</span>
  Z<span class="hl opt">&lt;</span>Y<span class="hl opt">&gt;</span> zy<span class="hl opt">;</span>
  zy<span class="hl opt">.</span><span class="hl kwd">b</span><span class="hl opt">();</span> <span class="hl slc">// Doesn't create Z&lt;Y&gt;::a()</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.31. C05/DelayedInstantiation.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4517232"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Nobloat.h</span>
<span class="hl slc">// Shares code for storing pointers in a Stack.</span>
<span class="hl ppc">#ifndef NOBLOAT_H</span>
<span class="hl ppc">#define NOBLOAT_H</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>

<span class="hl slc">// The primary template</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack <span class="hl opt">{</span>
  T<span class="hl opt">*</span> data<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> capacity<span class="hl opt">;</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> INIT <span class="hl opt">=</span> <span class="hl num">5</span> <span class="hl opt">};</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() {</span>
    count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    capacity <span class="hl opt">=</span> INIT<span class="hl opt">;</span>
    data <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">[</span>INIT<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">==</span> capacity<span class="hl opt">) {</span>
      <span class="hl slc">// Grow array store</span>
      std<span class="hl opt">::</span><span class="hl kwb">size_t</span> newCapacity <span class="hl opt">=</span> <span class="hl num">2</span> <span class="hl opt">*</span> capacity<span class="hl opt">;</span>
      T<span class="hl opt">*</span> newData <span class="hl opt">=</span> <span class="hl kwa">new</span> T<span class="hl opt">[</span>newCapacity<span class="hl opt">];</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> count<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
        newData<span class="hl opt">[</span>i<span class="hl opt">] =</span> data<span class="hl opt">[</span>i<span class="hl opt">];</span>
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span> data<span class="hl opt">;</span>
      data <span class="hl opt">=</span> newData<span class="hl opt">;</span>
      capacity <span class="hl opt">=</span> newCapacity<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">&lt;</span> capacity<span class="hl opt">);</span>
    data<span class="hl opt">[</span>count<span class="hl opt">++] =</span> t<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl opt">--</span>count<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  T <span class="hl kwd">top</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> data<span class="hl opt">[</span>count<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">];</span>
  <span class="hl opt">}</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> <span class="hl kwd">size</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Full specialization for void*</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">class</span> Stack<span class="hl opt">&lt;</span><span class="hl kwb">void</span> <span class="hl opt">*&gt; {</span>
  <span class="hl kwb">void</span><span class="hl opt">**</span> data<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> count<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> capacity<span class="hl opt">;</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> INIT <span class="hl opt">=</span> <span class="hl num">5</span> <span class="hl opt">};</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Stack</span><span class="hl opt">() {</span>
    count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    capacity <span class="hl opt">=</span> INIT<span class="hl opt">;</span>
    data <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">void</span><span class="hl opt">*[</span>INIT<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>count <span class="hl opt">==</span> capacity<span class="hl opt">) {</span>
      std<span class="hl opt">::</span><span class="hl kwb">size_t</span> newCapacity <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">*</span>capacity<span class="hl opt">;</span>
      <span class="hl kwb">void</span><span class="hl opt">**</span> newData <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwb">void</span><span class="hl opt">*[</span>newCapacity<span class="hl opt">];</span>
      std<span class="hl opt">::</span><span class="hl kwd">memcpy</span><span class="hl opt">(</span>newData<span class="hl opt">,</span> data<span class="hl opt">,</span> count<span class="hl opt">*</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*));</span>
      <span class="hl kwa">delete</span> <span class="hl opt">[]</span> data<span class="hl opt">;</span>
      data <span class="hl opt">=</span> newData<span class="hl opt">;</span>
      capacity <span class="hl opt">=</span> newCapacity<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">&lt;</span> capacity<span class="hl opt">);</span>
    data<span class="hl opt">[</span>count<span class="hl opt">++] =</span> t<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl opt">--</span>count<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">top</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> data<span class="hl opt">[</span>count<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">];</span>
  <span class="hl opt">}</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> <span class="hl kwd">size</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Partial specialization for other pointer types</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Stack<span class="hl opt">&lt;</span>T<span class="hl opt">*&gt; :</span> <span class="hl kwc">private</span> Stack<span class="hl opt">&lt;</span><span class="hl kwb">void</span> <span class="hl opt">*&gt; {</span>
  <span class="hl kwc">typedef</span> Stack<span class="hl opt">&lt;</span><span class="hl kwb">void</span> <span class="hl opt">*&gt;</span> Base<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">push</span><span class="hl opt">(</span>T<span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">&amp;</span> t<span class="hl opt">) {</span> Base<span class="hl opt">::</span><span class="hl kwd">push</span><span class="hl opt">(</span>t<span class="hl opt">); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pop</span><span class="hl opt">() {</span>Base<span class="hl opt">::</span><span class="hl kwd">pop</span><span class="hl opt">();}</span>
  T<span class="hl opt">*</span> <span class="hl kwd">top</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return static_cast</span><span class="hl opt">&lt;</span>T<span class="hl opt">*&gt;(</span>Base<span class="hl opt">::</span><span class="hl kwd">top</span><span class="hl opt">()); }</span>
  std<span class="hl opt">::</span><span class="hl kwb">size_t</span> <span class="hl kwd">size</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> Base<span class="hl opt">::</span><span class="hl kwd">size</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// NOBLOAT_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.32. C05/Nobloat.h</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4522528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:NobloatTest.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Nobloat.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> StackType<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">emptyTheStack</span><span class="hl opt">(</span>StackType<span class="hl opt">&amp;</span> stk<span class="hl opt">) {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>stk<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &gt;</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> stk<span class="hl opt">.</span><span class="hl kwd">top</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    stk<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl slc">// An overload for emptyTheStack (not a specialization!)</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">emptyTheStack</span><span class="hl opt">(</span>Stack<span class="hl opt">&lt;</span>T<span class="hl opt">*&gt;&amp;</span> stk<span class="hl opt">) {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>stk<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &gt;</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt; *</span>stk<span class="hl opt">.</span><span class="hl kwd">top</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    stk<span class="hl opt">.</span><span class="hl kwd">pop</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Stack<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> s1<span class="hl opt">;</span>
  s1<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  s1<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwd">emptyTheStack</span><span class="hl opt">(</span>s1<span class="hl opt">);</span>
  Stack<span class="hl opt">&lt;</span><span class="hl kwb">int</span> <span class="hl opt">*&gt;</span> s2<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">4</span><span class="hl opt">;</span>
  s2<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(&amp;</span>i<span class="hl opt">);</span>
  s2<span class="hl opt">.</span><span class="hl kwd">push</span><span class="hl opt">(&amp;</span>j<span class="hl opt">);</span>
  <span class="hl kwd">emptyTheStack</span><span class="hl opt">(</span>s2<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.33. C05/NobloatTest.cpp</strong></p></div><br class="example-break" /><p>

      </p></div></div><div class="sect1" title="6.4."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4524448"></a>6.4.  </h2></div></div></div><p>

    </p><div class="sect2" title="6.4.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4524960"></a>6.4.1.  </h3></div></div></div><p>

      </p><p>

      </p><pre class="programlisting">
MyClass<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">();</span>
x<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
p<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">();</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl slc">// ...</span>
  std<span class="hl opt">::</span>string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;hello&quot;</span><span class="hl opt">);</span>
  std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
std<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span><span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>cout<span class="hl opt">,</span>s<span class="hl opt">),</span>std<span class="hl opt">::</span>endl<span class="hl opt">);</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>cout<span class="hl opt">,</span> s<span class="hl opt">);</span>
</pre><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl opt">(</span>f<span class="hl opt">)(</span>x<span class="hl opt">,</span> y<span class="hl opt">);</span> <span class="hl slc">// ADL suppressed</span>
</pre><p>

      </p><div class="example"><a id="idp4529704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Lookup.cpp</span>
<span class="hl slc">// Only produces correct behavior with EDG,</span>
<span class="hl slc">// and Metrowerks using a special option.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>cout<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">) {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;f(double)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> X <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;f(int)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;().</span><span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.34. C05/Lookup.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
<span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">)</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4532096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Lookup2.cpp {-bor}{-g++}{-dmc}</span>
<span class="hl slc">// Microsoft: use option -Za (ANSI mode)</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;typeinfo&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>cout<span class="hl opt">;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;global g()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Y <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Y&lt;&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>T<span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">&quot;&gt;::g()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Y&lt;&quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>T<span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">&quot;&gt;::h()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">int</span> E<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">double</span> E<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">swap</span><span class="hl opt">(</span>T<span class="hl opt">&amp;</span> t1<span class="hl opt">,</span> T<span class="hl opt">&amp;</span> t2<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;global swap&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  T temp <span class="hl opt">=</span> t1<span class="hl opt">;</span>
  t1 <span class="hl opt">=</span> t2<span class="hl opt">;</span>
  t2 <span class="hl opt">=</span> temp<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> X <span class="hl opt">:</span> <span class="hl kwc">public</span> Y<span class="hl opt">&lt;</span>T<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  E <span class="hl kwd">f</span><span class="hl opt">() {</span>
    <span class="hl kwd">g</span><span class="hl opt">();</span>
    <span class="hl kwa">this</span><span class="hl opt">-&gt;</span><span class="hl kwd">h</span><span class="hl opt">();</span>
    T t1 <span class="hl opt">=</span> <span class="hl kwd">T</span><span class="hl opt">(),</span> t2 <span class="hl opt">=</span> <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> t1 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">swap</span><span class="hl opt">(</span>t1<span class="hl opt">,</span> t2<span class="hl opt">);</span>
    std<span class="hl opt">::</span><span class="hl kwd">swap</span><span class="hl opt">(</span>t1<span class="hl opt">,</span> t2<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwc">typeid</span><span class="hl opt">(</span>E<span class="hl opt">).</span><span class="hl kwd">name</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">E</span><span class="hl opt">(</span>t2<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  X<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> x<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> x<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.35. C05/Lookup2.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="screen">
global g()
Y&lt;int&gt;::h()
0
global swap
double
1
</pre><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="6.4.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4536544"></a>6.4.2.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4537056"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:FriendScope.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Friendly <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Friendly</span><span class="hl opt">(</span><span class="hl kwb">int</span> theInt<span class="hl opt">) {</span> i <span class="hl opt">=</span> theInt<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&amp;);</span> <span class="hl slc">// Needs global def.</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> <span class="hl kwd">f</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwd">Friendly</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">));</span>  <span class="hl slc">// Uses ADL</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&amp;</span> fo<span class="hl opt">) {</span>  <span class="hl slc">// Definition of friend</span>
  cout <span class="hl opt">&lt;&lt;</span> fo<span class="hl opt">.</span>i <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">h</span><span class="hl opt">();</span> <span class="hl slc">// Prints 1</span>
  <span class="hl kwd">Friendly</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">g</span><span class="hl opt">();</span> <span class="hl slc">// Prints 2</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.36. C05/FriendScope.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4538704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:FriendScope2.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Necessary forward declarations:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Friendly<span class="hl opt">;</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;);</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Friendly <span class="hl opt">{</span>
  T t<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Friendly</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> theT<span class="hl opt">) :</span> <span class="hl kwd">t</span><span class="hl opt">(</span>theT<span class="hl opt">) {}</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">void</span> f<span class="hl opt">&lt;&gt;(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;);</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> <span class="hl kwd">f</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>Friendly<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span><span class="hl num">1</span><span class="hl opt">));</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> fo<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> fo<span class="hl opt">.</span>t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">h</span><span class="hl opt">();</span>
  Friendly<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.37. C05/FriendScope2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4540872"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:FriendScope3.cpp {-bor}</span>
<span class="hl slc">// Microsoft: use the -Za (ANSI-compliant) option</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Friendly <span class="hl opt">{</span>
  T t<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Friendly</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> theT<span class="hl opt">) :</span> <span class="hl kwd">t</span><span class="hl opt">(</span>theT<span class="hl opt">) {}</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> fo<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> fo<span class="hl opt">.</span>t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> <span class="hl kwd">f</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">(</span>Friendly<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span><span class="hl num">1</span><span class="hl opt">));</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">h</span><span class="hl opt">();</span>
  Friendly<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.38. C05/FriendScope3.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Box <span class="hl opt">{</span>
  T t<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Box</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> theT<span class="hl opt">) :</span> <span class="hl kwd">t</span><span class="hl opt">(</span>theT<span class="hl opt">) {}</span>
<span class="hl opt">};</span>
</pre><p>

      </p><div class="example"><a id="idp4543288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Box1.cpp</span>
<span class="hl slc">// Defines template operators.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Forward declarations</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Box<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;);</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;);</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Box <span class="hl opt">{</span>
  T t<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Box</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> theT<span class="hl opt">) :</span> <span class="hl kwd">t</span><span class="hl opt">(</span>theT<span class="hl opt">) {}</span>
  <span class="hl kwc">friend</span> Box <span class="hl kwc">operator</span><span class="hl opt">+&lt;&gt;(</span><span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;);</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt; &lt;&gt;(</span>ostream<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;);</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> b1<span class="hl opt">,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> b2<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;(</span>b1<span class="hl opt">.</span>t <span class="hl opt">+</span> b2<span class="hl opt">.</span>t<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span>
ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">'['</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>t <span class="hl opt">&lt;&lt;</span> <span class="hl str">']'</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Box<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">b1</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">b2</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> b1 <span class="hl opt">+</span> b2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// [3]</span>
<span class="hl slc">//  cout &lt;&lt; b1 + 2 &lt;&lt; endl; // No implicit conversions!</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.39. C05/Box1.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4545528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Box2.cpp</span>
<span class="hl slc">// Defines non-template operators.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Box <span class="hl opt">{</span>
  T t<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Box</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> theT<span class="hl opt">) :</span> <span class="hl kwd">t</span><span class="hl opt">(</span>theT<span class="hl opt">) {}</span>
  <span class="hl kwc">friend</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> b1<span class="hl opt">,</span>
                          <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> b2<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;(</span>b1<span class="hl opt">.</span>t <span class="hl opt">+</span> b2<span class="hl opt">.</span>t<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Box<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;</span> b<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">'['</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>t <span class="hl opt">&lt;&lt;</span> <span class="hl str">']'</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Box<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">b1</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">b2</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> b1 <span class="hl opt">+</span> b2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// [3]</span>
  cout <span class="hl opt">&lt;&lt;</span> b1 <span class="hl opt">+</span> <span class="hl num">2</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// [3]</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.40. C05/Box2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl slc">// Inside Friendly:</span>
<span class="hl kwc">friend</span> <span class="hl kwb">void</span> f<span class="hl opt">&lt;&gt;(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;&amp;);</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl slc">// Inside Friendly:</span>
<span class="hl kwc">friend</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">);</span> <span class="hl slc">// g(int) befriends all Friendlys</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Friendly <span class="hl opt">{</span>
  <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> U<span class="hl opt">&gt;</span> <span class="hl kwc">friend</span> <span class="hl kwb">void</span> f<span class="hl opt">&lt;&gt;(</span><span class="hl kwb">const</span> Friendly<span class="hl opt">&lt;</span>U<span class="hl opt">&gt;&amp;);</span>
</pre><p>

      </p></div></div><div class="sect1" title="6.5."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4550120"></a>6.5.  </h2></div></div></div><p>

    </p><div class="sect2" title="6.5.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4550632"></a>6.5.1.  </h3></div></div></div><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> numeric_limits <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static const bool</span> is_specialized <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">min</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">max</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static const int</span> digits <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static const int</span> digits10 <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> is_signed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> is_integer <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> is_exact <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const int</span> radix <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">epsilon</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">round_error</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static const int</span> min_exponent <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static const int</span> min_exponent10 <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static const int</span> max_exponent <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static const int</span> max_exponent10 <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> has_infinity <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> has_quiet_NaN <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> has_signaling_NaN <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const</span> float_denorm_style has_denorm <span class="hl opt">=</span>
                                  denorm_absent<span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> has_denorm_loss <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">infinity</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">quiet_NaN</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">signaling_NaN</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static</span> T <span class="hl kwd">denorm_min</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">();</span>
  <span class="hl kwb">static const bool</span> is_iec559 <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> is_bounded <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> is_modulo <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> traps <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const bool</span> tinyness_before <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
  <span class="hl kwb">static const</span> float_round_style round_style <span class="hl opt">=</span>
                                 round_toward_zero<span class="hl opt">;</span>
<span class="hl opt">};</span>
</pre><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> charT<span class="hl opt">,</span>
  <span class="hl kwc">class</span> traits <span class="hl opt">=</span> char_traits<span class="hl opt">&lt;</span>charT<span class="hl opt">&gt;,</span>
  <span class="hl kwc">class</span> allocator <span class="hl opt">=</span> allocator<span class="hl opt">&lt;</span>charT<span class="hl opt">&gt; &gt;</span>
  <span class="hl kwc">class</span> basic_string<span class="hl opt">;</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwb">struct</span> char_traits<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt; {</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">char</span> char_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">int</span> int_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> streamoff off_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> streampos pos_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">mbstate_t</span> state_type<span class="hl opt">;</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">assign</span><span class="hl opt">(</span>char_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">eq</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">lt</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">compare</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s1<span class="hl opt">,</span>
                     <span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">static size_t</span> <span class="hl kwd">length</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s<span class="hl opt">);</span>
  <span class="hl kwb">static const</span> char_type<span class="hl opt">*</span> <span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s<span class="hl opt">,</span>
                               <span class="hl kwb">size_t</span> n<span class="hl opt">,</span>
                               <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type<span class="hl opt">*</span> <span class="hl kwd">move</span><span class="hl opt">(</span>char_type<span class="hl opt">*</span> s1<span class="hl opt">,</span>
                         <span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type<span class="hl opt">*</span> <span class="hl kwd">copy</span><span class="hl opt">(</span>char_type<span class="hl opt">*</span> s1<span class="hl opt">,</span>
                         <span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type<span class="hl opt">*</span> <span class="hl kwd">assign</span><span class="hl opt">(</span>char_type<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">,</span>
                           char_type a<span class="hl opt">);</span>
  <span class="hl kwb">static</span> int_type <span class="hl kwd">not_eof</span><span class="hl opt">(</span><span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type <span class="hl kwd">to_char_type</span><span class="hl opt">(</span><span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
  <span class="hl kwb">static</span> int_type <span class="hl kwd">to_int_type</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">eq_int_type</span><span class="hl opt">(</span><span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span>
                          <span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static</span> int_type <span class="hl kwd">eof</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
</pre><p>

      </p><pre class="programlisting">
std<span class="hl opt">::</span>string s<span class="hl opt">;</span>
</pre><p>

      </p><pre class="programlisting">
std<span class="hl opt">::</span>basic_string<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">,</span> std<span class="hl opt">::</span>char_traits<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;,</span>
   std<span class="hl opt">::</span>allocator<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt; &gt;</span> s<span class="hl opt">;</span>
</pre><p>

      </p><div class="example"><a id="idp4558344"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:BearCorner.h</span>
<span class="hl ppc">#ifndef BEARCORNER_H</span>
<span class="hl ppc">#define BEARCORNER_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>ostream<span class="hl opt">;</span>

<span class="hl slc">// Item classes (traits of guests):</span>
<span class="hl kwc">class</span> Milk <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Milk<span class="hl opt">&amp;) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Milk&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> CondensedMilk <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> CondensedMilk <span class="hl opt">&amp;) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Condensed Milk&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Honey <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Honey<span class="hl opt">&amp;) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Honey&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Cookies <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Cookies<span class="hl opt">&amp;) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Cookies&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Guest classes:</span>
<span class="hl kwc">class</span> Bear <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Bear<span class="hl opt">&amp;) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Theodore&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Boy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Boy<span class="hl opt">&amp;) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Patrick&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Primary traits template (empty-could hold common types)</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Guest<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> GuestTraits<span class="hl opt">;</span>

<span class="hl slc">// Traits specializations for Guest types</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">class</span> GuestTraits<span class="hl opt">&lt;</span>Bear<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">typedef</span> CondensedMilk beverage_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> Honey snack_type<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">class</span> GuestTraits<span class="hl opt">&lt;</span>Boy<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">typedef</span> Milk beverage_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> Cookies snack_type<span class="hl opt">;</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// BEARCORNER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.41. C05/BearCorner.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="6.5.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4562608"></a>6.5.2.  </h3></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwb">struct</span> char_traits<span class="hl opt">&lt;</span><span class="hl kwb">wchar_t</span><span class="hl opt">&gt; {</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">wchar_t</span> char_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">wint_t</span> int_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> streamoff off_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> wstreampos pos_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> <span class="hl kwb">mbstate_t</span> state_type<span class="hl opt">;</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">assign</span><span class="hl opt">(</span>char_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">eq</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">lt</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span> <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">compare</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s1<span class="hl opt">,</span>
                     <span class="hl kwb">const</span> char_type<span class="hl opt">*</span>  s2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">static size_t</span> <span class="hl kwd">length</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s<span class="hl opt">);</span>
  <span class="hl kwb">static const</span> char_type<span class="hl opt">*</span> <span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s<span class="hl opt">,</span>
                               <span class="hl kwb">size_t</span> n<span class="hl opt">,</span>
                               <span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> a<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type<span class="hl opt">*</span> <span class="hl kwd">move</span><span class="hl opt">(</span>char_type<span class="hl opt">*</span> s1<span class="hl opt">,</span>
                         <span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type<span class="hl opt">*</span> <span class="hl kwd">copy</span><span class="hl opt">(</span>char_type<span class="hl opt">*</span> s1<span class="hl opt">,</span>
                         <span class="hl kwb">const</span> char_type<span class="hl opt">*</span> s2<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type<span class="hl opt">*</span> <span class="hl kwd">assign</span><span class="hl opt">(</span>char_type<span class="hl opt">*</span> s<span class="hl opt">,</span> <span class="hl kwb">size_t</span> n<span class="hl opt">,</span>
                           char_type a<span class="hl opt">);</span>
  <span class="hl kwb">static</span> int_type <span class="hl kwd">not_eof</span><span class="hl opt">(</span><span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
  <span class="hl kwb">static</span> char_type <span class="hl kwd">to_char_type</span><span class="hl opt">(</span><span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
  <span class="hl kwb">static</span> int_type <span class="hl kwd">to_int_type</span><span class="hl opt">(</span><span class="hl kwb">const</span> char_type<span class="hl opt">&amp;</span> c<span class="hl opt">);</span>
  <span class="hl kwb">static bool</span> <span class="hl kwd">eq_int_type</span><span class="hl opt">(</span><span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c1<span class="hl opt">,</span>
                          <span class="hl kwb">const</span> int_type<span class="hl opt">&amp;</span> c2<span class="hl opt">);</span>
  <span class="hl kwb">static</span> int_type <span class="hl kwd">eof</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4565544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:BearCorner2.cpp</span>
<span class="hl slc">// Illustrates policy classes.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;BearCorner.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Policy classes (require a static doAction() function):</span>
<span class="hl kwc">class</span> Feed <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static const char</span><span class="hl opt">*</span> <span class="hl kwd">doAction</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Feeding&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Stuff <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static const char</span><span class="hl opt">*</span> <span class="hl kwd">doAction</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Stuffing&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// The Guest template (uses a policy and a traits class)</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Guest<span class="hl opt">,</span> <span class="hl kwc">class</span> Action<span class="hl opt">,</span>
         <span class="hl kwc">class</span> traits <span class="hl opt">=</span> GuestTraits<span class="hl opt">&lt;</span>Guest<span class="hl opt">&gt; &gt;</span>
<span class="hl kwc">class</span> BearCorner <span class="hl opt">{</span>
  Guest theGuest<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> typename traits<span class="hl opt">::</span>beverage_type beverage_type<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> typename traits<span class="hl opt">::</span>snack_type snack_type<span class="hl opt">;</span>
  beverage_type bev<span class="hl opt">;</span>
  snack_type snack<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">BearCorner</span><span class="hl opt">(</span><span class="hl kwb">const</span> Guest<span class="hl opt">&amp;</span> g<span class="hl opt">) :</span> <span class="hl kwd">theGuest</span><span class="hl opt">(</span>g<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">entertain</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> Action<span class="hl opt">::</span><span class="hl kwd">doAction</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">&quot; &quot;</span> <span class="hl opt">&lt;&lt;</span> theGuest
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; with &quot;</span> <span class="hl opt">&lt;&lt;</span> bev
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; and &quot;</span> <span class="hl opt">&lt;&lt;</span> snack <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Boy cr<span class="hl opt">;</span>
  BearCorner<span class="hl opt">&lt;</span>Boy<span class="hl opt">,</span> Feed<span class="hl opt">&gt;</span> <span class="hl kwd">pc1</span><span class="hl opt">(</span>cr<span class="hl opt">);</span>
  pc1<span class="hl opt">.</span><span class="hl kwd">entertain</span><span class="hl opt">();</span>
  Bear pb<span class="hl opt">;</span>
  BearCorner<span class="hl opt">&lt;</span>Bear<span class="hl opt">,</span> Stuff<span class="hl opt">&gt;</span> <span class="hl kwd">pc2</span><span class="hl opt">(</span>pb<span class="hl opt">);</span>
  pc2<span class="hl opt">.</span><span class="hl kwd">entertain</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.42. C05/BearCorner2.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.5.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4568600"></a>6.5.3.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4569112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:CountedClass.cpp</span>
<span class="hl slc">// Object counting via static members.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> CountedClass <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">CountedClass</span><span class="hl opt">() { ++</span>count<span class="hl opt">; }</span>
  <span class="hl kwd">CountedClass</span><span class="hl opt">(</span><span class="hl kwb">const</span> CountedClass<span class="hl opt">&amp;) { ++</span>count<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">CountedClass</span><span class="hl opt">() { --</span>count<span class="hl opt">; }</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">getCount</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> CountedClass<span class="hl opt">::</span>count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CountedClass a<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 1</span>
  CountedClass b<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 2</span>
  <span class="hl opt">{</span> <span class="hl slc">// An arbitrary scope:</span>
    CountedClass <span class="hl kwd">c</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 3</span>
    a <span class="hl opt">=</span> c<span class="hl opt">;</span>
    cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 3</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 2</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.43. C05/CountedClass.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4571624"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:CountedClass2.cpp</span>
<span class="hl slc">// Erroneous attempt to count objects.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Counted <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Counted</span><span class="hl opt">() { ++</span>count<span class="hl opt">; }</span>
  <span class="hl kwd">Counted</span><span class="hl opt">(</span><span class="hl kwb">const</span> Counted<span class="hl opt">&amp;) { ++</span>count<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Counted</span><span class="hl opt">() { --</span>count<span class="hl opt">; }</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">getCount</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> Counted<span class="hl opt">::</span>count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> CountedClass <span class="hl opt">:</span> <span class="hl kwc">public</span> Counted <span class="hl opt">{};</span>
<span class="hl kwc">class</span> CountedClass2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Counted <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CountedClass a<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>    <span class="hl slc">// 1</span>
  CountedClass b<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>    <span class="hl slc">// 2</span>
  CountedClass2 c<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass2<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 3 (Error)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.44. C05/CountedClass2.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4573896"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:CountedClass3.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Counted <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Counted</span><span class="hl opt">() { ++</span>count<span class="hl opt">; }</span>
  <span class="hl kwd">Counted</span><span class="hl opt">(</span><span class="hl kwb">const</span> Counted<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;&amp;) { ++</span>count<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Counted</span><span class="hl opt">() { --</span>count<span class="hl opt">; }</span>
  <span class="hl kwb">static int</span> <span class="hl kwd">getCount</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">int</span> Counted<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;::</span>count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>

<span class="hl slc">// Curious class definitions</span>
<span class="hl kwc">class</span> CountedClass <span class="hl opt">:</span> <span class="hl kwc">public</span> Counted<span class="hl opt">&lt;</span>CountedClass<span class="hl opt">&gt; {};</span>
<span class="hl kwc">class</span> CountedClass2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Counted<span class="hl opt">&lt;</span>CountedClass2<span class="hl opt">&gt; {};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CountedClass a<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>    <span class="hl slc">// 1</span>
  CountedClass b<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>    <span class="hl slc">// 2</span>
  CountedClass2 c<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> CountedClass2<span class="hl opt">::</span><span class="hl kwd">getCount</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 1 (!)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.45. C05/CountedClass3.cpp</strong></p></div><br class="example-break" /><p>

      </p></div></div><div class="sect1" title="6.6."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4575968"></a>6.6.  </h2></div></div></div><p>

    </p><div class="example"><a id="idp4576480"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Factorial.cpp</span>
<span class="hl slc">// Compile-time computation using templates.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Factorial <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> Factorial<span class="hl opt">&lt;</span>n<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">&gt;::</span>val <span class="hl opt">*</span> n <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwb">struct</span> Factorial<span class="hl opt">&lt;</span><span class="hl num">0</span><span class="hl opt">&gt; {</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> <span class="hl num">1</span> <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> Factorial<span class="hl opt">&lt;</span><span class="hl num">12</span><span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 479001600</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.46. C05/Factorial.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><pre class="programlisting">
<span class="hl kwb">double</span> nums<span class="hl opt">[</span>Factorial<span class="hl opt">&lt;</span><span class="hl num">5</span><span class="hl opt">&gt;::</span>val<span class="hl opt">];</span>
<span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span> nums <span class="hl opt">==</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">)*</span><span class="hl num">120</span><span class="hl opt">);</span>
</pre><div class="sect2" title="6.6.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4578640"></a>6.6.1.  </h3></div></div></div><p>

      </p><div class="example"><a id="idp4579152"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Fibonacci.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Fib <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> Fib<span class="hl opt">&lt;</span>n<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">&gt;::</span>val <span class="hl opt">+</span> Fib<span class="hl opt">&lt;</span>n<span class="hl opt">-</span><span class="hl num">2</span><span class="hl opt">&gt;::</span>val <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwb">struct</span> Fib<span class="hl opt">&lt;</span><span class="hl num">1</span><span class="hl opt">&gt; {</span> <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> <span class="hl num">1</span> <span class="hl opt">}; };</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwb">struct</span> Fib<span class="hl opt">&lt;</span><span class="hl num">0</span><span class="hl opt">&gt; {</span> <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> <span class="hl num">0</span> <span class="hl opt">}; };</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> Fib<span class="hl opt">&lt;</span><span class="hl num">5</span><span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 6</span>
  cout <span class="hl opt">&lt;&lt;</span> Fib<span class="hl opt">&lt;</span><span class="hl num">20</span><span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 6765</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.47. C05/Fibonacci.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> val <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl kwa">while</span><span class="hl opt">(</span>p<span class="hl opt">--)</span>
   val <span class="hl opt">*=</span> n<span class="hl opt">; --&gt;</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> <span class="hl kwd">power</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">,</span> <span class="hl kwb">int</span> p<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>p <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> ? <span class="hl num">1</span> <span class="hl opt">:</span> n<span class="hl opt">*</span><span class="hl kwd">power</span><span class="hl opt">(</span>n<span class="hl opt">,</span> p <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre><p>

      </p><div class="example"><a id="idp4582216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Power.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> N<span class="hl opt">,</span> <span class="hl kwb">int</span> P<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Power <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> N <span class="hl opt">*</span> Power<span class="hl opt">&lt;</span>N<span class="hl opt">,</span> P<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">&gt;::</span>val <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> N<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Power<span class="hl opt">&lt;</span>N<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">&gt; {</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> <span class="hl num">1</span> <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> Power<span class="hl opt">&lt;</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 32</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.48. C05/Power.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4583904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Accumulate.cpp</span>
<span class="hl slc">// Passes a &quot;function&quot; as a parameter at compile time.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Accumulates the results of F(0)..F(n)</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">,</span> <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> F<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Accumulate <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> Accumulate<span class="hl opt">&lt;</span>n<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">,</span> F<span class="hl opt">&gt;::</span>val <span class="hl opt">+</span> F<span class="hl opt">&lt;</span>n<span class="hl opt">&gt;::</span>val <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl slc">// The stopping criterion (returns the value F(0))</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> F<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Accumulate<span class="hl opt">&lt;</span><span class="hl num">0</span><span class="hl opt">,</span> F<span class="hl opt">&gt; {</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> F<span class="hl opt">&lt;</span><span class="hl num">0</span><span class="hl opt">&gt;::</span>val <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl slc">// Various &quot;functions&quot;:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Identity <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> n <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Square <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> n<span class="hl opt">*</span>n <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Cube <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> n<span class="hl opt">*</span>n<span class="hl opt">*</span>n <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> Accumulate<span class="hl opt">&lt;</span><span class="hl num">4</span><span class="hl opt">,</span> Identity<span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 10</span>
  cout <span class="hl opt">&lt;&lt;</span> Accumulate<span class="hl opt">&lt;</span><span class="hl num">4</span><span class="hl opt">,</span> Square<span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>   <span class="hl slc">// 30</span>
  cout <span class="hl opt">&lt;&lt;</span> Accumulate<span class="hl opt">&lt;</span><span class="hl num">4</span><span class="hl opt">,</span> Cube<span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>     <span class="hl slc">// 100</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.49. C05/Accumulate.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp4585856"></a></h4></div></div></div><p>

      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">mult</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">[</span>ROWS<span class="hl opt">][</span>COLS<span class="hl opt">],</span> <span class="hl kwb">int</span> x<span class="hl opt">[</span>COLS<span class="hl opt">],</span> <span class="hl kwb">int</span> y<span class="hl opt">[</span>COLS<span class="hl opt">]) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> ROWS<span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
      y<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> COLS<span class="hl opt">; ++</span>j<span class="hl opt">)</span>
        y<span class="hl opt">[</span>i<span class="hl opt">] +=</span> a<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">]*</span>x<span class="hl opt">[</span>j<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwb">void</span> <span class="hl kwd">mult</span><span class="hl opt">(</span><span class="hl kwb">int</span> a<span class="hl opt">[</span>ROWS<span class="hl opt">][</span>COLS<span class="hl opt">],</span> <span class="hl kwb">int</span> x<span class="hl opt">[</span>COLS<span class="hl opt">],</span> <span class="hl kwb">int</span> y<span class="hl opt">[</span>COLS<span class="hl opt">]) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> ROWS<span class="hl opt">; ++</span>i<span class="hl opt">) {</span>
      y<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> j <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> j <span class="hl opt">&lt;</span> COLS<span class="hl opt">;</span> j <span class="hl opt">+=</span> <span class="hl num">2</span><span class="hl opt">)</span>
        y<span class="hl opt">[</span>i<span class="hl opt">] +=</span> a<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">]*</span>x<span class="hl opt">[</span>j<span class="hl opt">] +</span> a<span class="hl opt">[</span>i<span class="hl opt">][</span>j<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">]*</span>x<span class="hl opt">[</span>j<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4588520"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Unroll.cpp</span>
<span class="hl slc">// Unrolls an implicit loop via inlining.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n<span class="hl opt">&gt;</span> <span class="hl kwc">inline</span> <span class="hl kwb">int</span> <span class="hl kwd">power</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> power<span class="hl opt">&lt;</span>n<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">&gt;(</span>m<span class="hl opt">) *</span> m<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">inline</span> <span class="hl kwb">int</span> power<span class="hl opt">&lt;</span><span class="hl num">1</span><span class="hl opt">&gt;(</span><span class="hl kwb">int</span> m<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> m<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">inline</span> <span class="hl kwb">int</span> power<span class="hl opt">&lt;</span><span class="hl num">0</span><span class="hl opt">&gt;(</span><span class="hl kwb">int</span> m<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl num">1</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> m <span class="hl opt">=</span> <span class="hl num">4</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> power<span class="hl opt">&lt;</span><span class="hl num">3</span><span class="hl opt">&gt;(</span>m<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.50. C05/Unroll.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp4590024"></a></h4></div></div></div><p>

      </p><div class="example"><a id="idp4590472"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Max.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">int</span> n1<span class="hl opt">,</span> <span class="hl kwb">int</span> n2<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Max <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> val <span class="hl opt">=</span> n1 <span class="hl opt">&gt;</span> n2 ? n1 <span class="hl opt">:</span> n2 <span class="hl opt">};</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> Max<span class="hl opt">&lt;</span><span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">&gt;::</span>val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 20</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.51. C05/Max.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4591896"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Conditionals.cpp</span>
<span class="hl slc">// Uses compile-time conditions to choose code.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">bool</span> cond<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Select <span class="hl opt">{};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">class</span> Select<span class="hl opt">&lt;</span><span class="hl kwa">true</span><span class="hl opt">&gt; {</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">statement1</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;This is statement1 executing</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> <span class="hl kwd">statement1</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwc">class</span> Select<span class="hl opt">&lt;</span><span class="hl kwa">false</span><span class="hl opt">&gt; {</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">statement2</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;This is statement2 executing</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> <span class="hl kwd">statement2</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">bool</span> cond<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">execute</span><span class="hl opt">() {</span>
  Select<span class="hl opt">&lt;</span>cond<span class="hl opt">&gt;::</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  execute<span class="hl opt">&lt;</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) ==</span> <span class="hl num">4</span><span class="hl opt">&gt;();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.52. C05/Conditionals.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
<span class="hl kwa">if</span><span class="hl opt">(</span>cond<span class="hl opt">)</span>
  <span class="hl kwd">statement1</span><span class="hl opt">();</span>
<span class="hl kwa">else</span>
  <span class="hl kwd">statement2</span><span class="hl opt">();</span>
</pre><p>

      </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp4594432"></a></h4></div></div></div><p>

      </p><div class="example"><a id="idp4594880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:StaticAssert1.cpp {-xo}</span>
<span class="hl slc">// A simple, compile-time assertion facility</span>

<span class="hl ppc">#define STATIC_ASSERT(x) \</span>
<span class="hl ppc">  do { typedef int a[(x) ? 1 : -1]; } while(0)</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">STATIC_ASSERT</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">) &lt;=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">long</span><span class="hl opt">));</span> <span class="hl slc">// Passes</span>
  <span class="hl kwd">STATIC_ASSERT</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">) &lt;=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">));</span> <span class="hl slc">// Fails</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.53. C05/StaticAssert1.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4596504"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:StaticAssert2.cpp {-g++}</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A template and a specialization</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> StaticCheck <span class="hl opt">{</span>
  <span class="hl kwd">StaticCheck</span><span class="hl opt">(...);</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;&gt;</span> <span class="hl kwb">struct</span> StaticCheck<span class="hl opt">&lt;</span><span class="hl kwa">false</span><span class="hl opt">&gt; {};</span>

<span class="hl slc">// The macro (generates a local class)</span>
<span class="hl ppc">#define STATIC_CHECK(expr, msg) {             \</span>
<span class="hl ppc">  class Error_##msg {};                       \</span>
<span class="hl ppc">  sizeof((StaticCheck&lt;expr&gt;(Error_##msg()))); \</span>
<span class="hl ppc">}</span>

<span class="hl slc">// Detects narrowing conversions</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> To<span class="hl opt">,</span> <span class="hl kwc">class</span> From<span class="hl opt">&gt;</span> To <span class="hl kwd">safe_cast</span><span class="hl opt">(</span>From from<span class="hl opt">) {</span>
  <span class="hl kwd">STATIC_CHECK</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span>From<span class="hl opt">) &lt;=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>To<span class="hl opt">),</span>
               NarrowingConversion<span class="hl opt">);</span>
  <span class="hl kwa">return reinterpret_cast</span><span class="hl opt">&lt;</span>To<span class="hl opt">&gt;(</span>from<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">void</span><span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> i <span class="hl opt">=</span> safe_cast<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>p<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;int cast okay&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">//! char c = safe_cast&lt;char&gt;(p);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.54. C05/StaticAssert2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwb">int</span> i <span class="hl opt">=</span> safe_cast<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>p<span class="hl opt">);</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl opt">{</span>                                                   \
   <span class="hl kwc">class</span> Error_NarrowingConversion <span class="hl opt">{};</span>              \
   <span class="hl kwa">sizeof</span><span class="hl opt">(</span>StaticCheck<span class="hl opt">&lt;</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*) &lt;=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">int</span><span class="hl opt">)&gt;</span> \
           <span class="hl opt">(</span><span class="hl kwd">Error_NarrowingConversion</span><span class="hl opt">()));</span>          \
<span class="hl opt">}</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
<span class="hl kwb">char</span> c <span class="hl opt">=</span> safe_cast<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;(</span>p<span class="hl opt">);</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl opt">{</span>                                                    \
   <span class="hl kwc">class</span> Error_NarrowingConversion <span class="hl opt">{};</span>               \
   <span class="hl kwa">sizeof</span><span class="hl opt">(</span>StaticCheck<span class="hl opt">&lt;</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*) &lt;=</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">)&gt;</span> \
           <span class="hl opt">(</span><span class="hl kwd">Error_NarrowingConversion</span><span class="hl opt">()));</span>           \
<span class="hl opt">}</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl kwa">sizeof</span><span class="hl opt">(</span>StaticCheck<span class="hl opt">&lt;</span><span class="hl kwa">false</span><span class="hl opt">&gt;(</span><span class="hl kwd">Error_NarrowingConversion</span><span class="hl opt">()));</span>
</pre><pre class="screen">
Cannot cast from 'Error_NarrowingConversion' to 'StaticCheck&lt;0&gt;' in function
char safe_cast&lt;char,void *&gt;(void *)
</pre><p>

      </p></div></div><div class="sect2" title="6.6.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4603000"></a>6.6.2.  </h3></div></div></div><p>

      </p><p>

      </p><pre class="programlisting">
D <span class="hl opt">=</span> A <span class="hl opt">+</span> B <span class="hl opt">+</span> C<span class="hl opt">;</span>
</pre><p>

      </p><p>

      </p><div class="example"><a id="idp4604448"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:MyVector.cpp</span>
<span class="hl slc">// Optimizes away temporaries via templates.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A proxy class for sums of vectors</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">,</span> <span class="hl kwb">size_t</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> MyVectorSum<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> MyVector <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      data<span class="hl opt">[</span>i<span class="hl opt">] =</span> right<span class="hl opt">.</span>data<span class="hl opt">[</span>i<span class="hl opt">];</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> data<span class="hl opt">[</span>i<span class="hl opt">]; }</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> i<span class="hl opt">) {</span> <span class="hl kwa">return</span> data<span class="hl opt">[</span>i<span class="hl opt">]; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Proxy class hold references; uses lazy addition</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> MyVectorSum <span class="hl opt">{</span>
  <span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> left<span class="hl opt">;</span>
  <span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MyVectorSum</span><span class="hl opt">(</span><span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> lhs<span class="hl opt">,</span>
              <span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> rhs<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">left</span><span class="hl opt">(</span>lhs<span class="hl opt">),</span> <span class="hl kwd">right</span><span class="hl opt">(</span>rhs<span class="hl opt">) {}</span>
  T <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> left<span class="hl opt">[</span>i<span class="hl opt">] +</span> right<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Operator to support v3 = v1 + v2</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span>
MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;::</span><span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    data<span class="hl opt">[</span>i<span class="hl opt">] =</span> right<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl slc">// operator+ just stores references</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwc">inline</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;</span>
<span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> left<span class="hl opt">,</span>
          <span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;(</span>left<span class="hl opt">,</span> right<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// Convenience functions for the test program below</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">init</span><span class="hl opt">(</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> v<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    v<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> v<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v1<span class="hl opt">;</span>
  <span class="hl kwd">init</span><span class="hl opt">(</span>v1<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">);</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v2<span class="hl opt">;</span>
  <span class="hl kwd">init</span><span class="hl opt">(</span>v2<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">);</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v3<span class="hl opt">;</span>
  v3 <span class="hl opt">=</span> v1 <span class="hl opt">+</span> v2<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">);</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v4<span class="hl opt">;</span>
  <span class="hl slc">// Not yet supported:</span>
<span class="hl slc">//!  v4 = v1 + v2 + v3;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.55. C05/MyVector.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="programlisting">
v1 <span class="hl opt">=</span> v2 <span class="hl opt">+</span> v3<span class="hl opt">;</span> <span class="hl slc">// Add two vectors</span>
</pre><p>

      </p><pre class="programlisting">
v3<span class="hl opt">.</span><span class="hl kwc">operator</span><span class="hl opt">=&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span><span class="hl num">5</span><span class="hl opt">&gt;(</span>MyVectorSum<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span><span class="hl num">5</span><span class="hl opt">&gt;(</span>v2<span class="hl opt">,</span> v3<span class="hl opt">));</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
v4 <span class="hl opt">=</span> v1 <span class="hl opt">+</span> v2 <span class="hl opt">+</span> v3<span class="hl opt">;</span>
</pre><p>

      </p><pre class="programlisting">
<span class="hl opt">(</span>v1 <span class="hl opt">+</span> v2<span class="hl opt">) +</span> v3<span class="hl opt">;</span>
</pre><p>

      </p><div class="example"><a id="idp4610104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:MyVector2.cpp</span>
<span class="hl slc">// Handles sums of any length with expression templates.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// A proxy class for sums of vectors</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span><span class="hl opt">,</span> <span class="hl kwb">size_t</span><span class="hl opt">,</span> <span class="hl kwc">class</span><span class="hl opt">,</span> <span class="hl kwc">class</span><span class="hl opt">&gt;</span> <span class="hl kwc">class</span> MyVectorSum<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> MyVector <span class="hl opt">{</span>
  T data<span class="hl opt">[</span>N<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      data<span class="hl opt">[</span>i<span class="hl opt">] =</span> right<span class="hl opt">.</span>data<span class="hl opt">[</span>i<span class="hl opt">];</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Left<span class="hl opt">,</span> <span class="hl kwc">class</span> Right<span class="hl opt">&gt;</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>Left<span class="hl opt">,</span>Right<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">);</span>
  <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> data<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl opt">}</span>
  T<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> i<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> data<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Allows mixing MyVector and MyVectorSum</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">,</span> <span class="hl kwc">class</span> Left<span class="hl opt">,</span> <span class="hl kwc">class</span> Right<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> MyVectorSum <span class="hl opt">{</span>
  <span class="hl kwb">const</span> Left<span class="hl opt">&amp;</span> left<span class="hl opt">;</span>
  <span class="hl kwb">const</span> Right<span class="hl opt">&amp;</span> right<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MyVectorSum</span><span class="hl opt">(</span><span class="hl kwb">const</span> Left<span class="hl opt">&amp;</span> lhs<span class="hl opt">,</span> <span class="hl kwb">const</span> Right<span class="hl opt">&amp;</span> rhs<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">left</span><span class="hl opt">(</span>lhs<span class="hl opt">),</span> <span class="hl kwd">right</span><span class="hl opt">(</span>rhs<span class="hl opt">) {}</span>
  T <span class="hl kwc">operator</span><span class="hl opt">[](</span><span class="hl kwb">size_t</span> i<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> left<span class="hl opt">[</span>i<span class="hl opt">] +</span> right<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Left<span class="hl opt">,</span> <span class="hl kwc">class</span> Right<span class="hl opt">&gt;</span>
MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span>
MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;::</span>
<span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>Left<span class="hl opt">,</span>Right<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    data<span class="hl opt">[</span>i<span class="hl opt">] =</span> right<span class="hl opt">[</span>i<span class="hl opt">];</span>
  <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl slc">// operator+ just stores references</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span>
<span class="hl kwc">inline</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;,</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt; &gt;</span>
<span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> left<span class="hl opt">,</span>
          <span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;,</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt; &gt;</span>
      <span class="hl opt">(</span>left<span class="hl opt">,</span>right<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">,</span> <span class="hl kwc">class</span> Left<span class="hl opt">,</span> <span class="hl kwc">class</span> Right<span class="hl opt">&gt;</span>
<span class="hl kwc">inline</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span> N<span class="hl opt">,</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>Left<span class="hl opt">,</span>Right<span class="hl opt">&gt;,</span>
            MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt; &gt;</span>
<span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>Left<span class="hl opt">,</span>Right<span class="hl opt">&gt;&amp;</span> left<span class="hl opt">,</span>
          <span class="hl kwb">const</span> MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> right<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>MyVectorSum<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">,</span>Left<span class="hl opt">,</span>Right<span class="hl opt">&gt;,</span>
                         MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt; &gt;</span>
    <span class="hl opt">(</span>left<span class="hl opt">,</span> right<span class="hl opt">);</span>
<span class="hl opt">}</span>
<span class="hl slc">// Convenience functions for the test program below</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">init</span><span class="hl opt">(</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> v<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    v<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">,</span> <span class="hl kwb">size_t</span> N<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>MyVector<span class="hl opt">&lt;</span>T<span class="hl opt">,</span>N<span class="hl opt">&gt;&amp;</span> v<span class="hl opt">) {</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> N<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> v<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v1<span class="hl opt">;</span>
  <span class="hl kwd">init</span><span class="hl opt">(</span>v1<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">);</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v2<span class="hl opt">;</span>
  <span class="hl kwd">init</span><span class="hl opt">(</span>v2<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">);</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v3<span class="hl opt">;</span>
  v3 <span class="hl opt">=</span> v1 <span class="hl opt">+</span> v2<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">);</span>
  <span class="hl slc">// Now supported:</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v4<span class="hl opt">;</span>
  v4 <span class="hl opt">=</span> v1 <span class="hl opt">+</span> v2 <span class="hl opt">+</span> v3<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v4<span class="hl opt">);</span>
  MyVector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">&gt;</span> v5<span class="hl opt">;</span>
  v5 <span class="hl opt">=</span> v1 <span class="hl opt">+</span> v2 <span class="hl opt">+</span> v3 <span class="hl opt">+</span> v4<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v5<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.56. C05/MyVector2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><pre class="programlisting">
v4 <span class="hl opt">=</span> v1 <span class="hl opt">+</span> v2 <span class="hl opt">+</span> v3<span class="hl opt">;</span>
</pre><p>

      </p><p>

      </p><pre class="programlisting">
v4<span class="hl opt">.</span><span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwd">MVS</span><span class="hl opt">(</span><span class="hl kwd">MVS</span><span class="hl opt">(</span>v1<span class="hl opt">,</span> v2<span class="hl opt">),</span> v3<span class="hl opt">));</span>
</pre><p>

      </p><p>

      </p></div></div><div class="sect1" title="6.7."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4617776"></a>6.7.  </h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="sect2" title="6.7.1."><div class="titlepage"><div><div><h3 class="title"><a id="idp4619248"></a>6.7.1.  </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="6.7.2."><div class="titlepage"><div><div><h3 class="title"><a id="idp4620208"></a>6.7.2.  </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4621680"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:OurMin.h</span>
<span class="hl ppc">#ifndef OURMIN_H</span>
<span class="hl ppc">#define OURMIN_H</span>
<span class="hl slc">// The declaration of min()</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;);</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OURMIN_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.57. C05/OurMin.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4623088"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:MinInstances.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;OurMin.cpp&quot;</span><span class="hl ppc"></span>

<span class="hl slc">// Explicit Instantiations for int and double</span>
<span class="hl kwc">template</span> <span class="hl kwb">const int</span><span class="hl opt">&amp;</span> min<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span><span class="hl kwb">const int</span><span class="hl opt">&amp;,</span> <span class="hl kwb">const int</span><span class="hl opt">&amp;);</span>
<span class="hl kwc">template</span> <span class="hl kwb">const double</span><span class="hl opt">&amp;</span> min<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span><span class="hl kwb">const double</span><span class="hl opt">&amp;,</span>
                                   <span class="hl kwb">const double</span><span class="hl opt">&amp;);</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.58. C05/MinInstances.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4624728"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:OurMin.cpp {O}</span>
<span class="hl ppc">#ifndef OURMIN_CPP</span>
<span class="hl ppc">#define OURMIN_CPP</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;OurMin.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">&lt;</span> b<span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OURMIN_CPP ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.59. C05/OurMin.cpp</strong></p></div><br class="example-break" /><p>

      </p><pre class="screen">
1
3.1
</pre><p>

      </p><p>

      </p></div><div class="sect2" title="6.7.3."><div class="titlepage"><div><div><h3 class="title"><a id="idp4627024"></a>6.7.3.  </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4628112"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:OurMin2.h</span>
<span class="hl slc">// Declares min as an exported template</span>
<span class="hl slc">// (Only works with EDG-based compilers)</span>
<span class="hl ppc">#ifndef OURMIN2_H</span>
<span class="hl ppc">#define OURMIN2_H</span>
export <span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;,</span>
                                         <span class="hl kwb">const</span> T<span class="hl opt">&amp;);</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OURMIN2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 6.60. C05/OurMin2.h</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4629456"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">// C05:OurMin2.cpp</span>
<span class="hl slc">// The definition of the exported min template</span>
<span class="hl slc">// (Only works with EDG-based compilers)</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;OurMin2.h&quot;</span><span class="hl ppc"></span>
export
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">min</span><span class="hl opt">(</span><span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> a<span class="hl opt">,</span> <span class="hl kwb">const</span> T<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">&lt;</span> b<span class="hl opt">)</span> ? a <span class="hl opt">:</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.61. C05/OurMin2.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="6.7.4."><div class="titlepage"><div><div><h3 class="title"><a id="idp4630848"></a>6.7.4.  </h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="6.8."><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4632064"></a>6.8.  </h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4633344"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Exercise4.cpp {-xo}</span>
<span class="hl kwc">class</span> Noncomparable <span class="hl opt">{};</span>

<span class="hl kwb">struct</span> HardLogic <span class="hl opt">{</span>
  Noncomparable nc1<span class="hl opt">,</span> nc2<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">compare</span><span class="hl opt">() {</span>
    <span class="hl kwa">return</span> nc1 <span class="hl opt">==</span> nc2<span class="hl opt">;</span> <span class="hl slc">// Compiler error</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> SoftLogic <span class="hl opt">{</span>
  Noncomparable nc1<span class="hl opt">,</span> nc2<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">noOp</span><span class="hl opt">() {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">compare</span><span class="hl opt">() {</span>
    nc1 <span class="hl opt">==</span> nc2<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  SoftLogic<span class="hl opt">&lt;</span>Noncomparable<span class="hl opt">&gt;</span> l<span class="hl opt">;</span>
  l<span class="hl opt">.</span><span class="hl kwd">noOp</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.62. C05/Exercise4.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4635120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Exercise7.cpp {-xo}</span>
<span class="hl kwc">class</span> Buddy <span class="hl opt">{};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> My <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">(</span>My<span class="hl opt">&lt;</span>Buddy<span class="hl opt">&gt;&amp;</span> s<span class="hl opt">) {</span>
    s<span class="hl opt">.</span>i <span class="hl opt">=</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  My<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> h<span class="hl opt">;</span>
  My<span class="hl opt">&lt;</span>Buddy<span class="hl opt">&gt;</span> me<span class="hl opt">,</span> bud<span class="hl opt">;</span>
  h<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>bud<span class="hl opt">);</span>
  me<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">(</span>bud<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.63. C05/Exercise7.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4636496"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C05:Exercise8.cpp {-xo}</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">double</span> <span class="hl kwd">pythag</span><span class="hl opt">(</span>T a<span class="hl opt">,</span> T b<span class="hl opt">,</span> T c<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl opt">(-</span>b <span class="hl opt">+</span> <span class="hl kwd">sqrt</span><span class="hl opt">(</span><span class="hl kwb">double</span><span class="hl opt">(</span>b<span class="hl opt">*</span>b <span class="hl opt">-</span> <span class="hl num">4</span><span class="hl opt">*</span>a<span class="hl opt">*</span>c<span class="hl opt">))) /</span> <span class="hl num">2</span><span class="hl opt">*</span>a<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">pythag</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span>
  <span class="hl kwd">pythag</span><span class="hl opt">(</span><span class="hl num">1.0</span><span class="hl opt">,</span> <span class="hl num">2.0</span><span class="hl opt">,</span> <span class="hl num">3.0</span><span class="hl opt">);</span>
  <span class="hl kwd">pythag</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2.0</span><span class="hl opt">,</span> <span class="hl num">3.0</span><span class="hl opt">);</span>
  pythag<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2.0</span><span class="hl opt">,</span> <span class="hl num">3.0</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 6.64. C05/Exercise8.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p></div></div><div class="chapter" title="7: Algoritmos genéricos"><div class="titlepage"><div><div><h2 class="title"><a id="C06"></a>7: Algoritmos genéricos</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp4641792">7.1. Un primer vistazo</a></span></dt><dt><span class="sect1"><a href="#idp4706488">7.2. Objetos-función</a></span></dt><dt><span class="sect1"><a href="#idp4765784">7.3. Un catálogo de algoritmos STL</a></span></dt><dt><span class="sect1"><a href="#idp4879440">7.4. Creando sus propios algoritmos tipo STL</a></span></dt><dt><span class="sect1"><a href="#idp4883000">7.5. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp4883960">7.6. Ejercicios</a></span></dt></dl></div><p>
    Los algoritmos son la base de la computación. Ser capaz de escribir un algoritmo que
    funcione con cualquier tipo de se secuencia hace que sus programas sean simples y
    seguros. La habilidad para adaptar algoritmos en tiempo de ejecución a revolucionado
    el desarrollo de software.
  </p><p>
    El subconjunto de la Librería Estándar de C++ conocido como Standard Template Library
    (STL)<sup>[<a id="idp4640008" href="#ftn.idp4640008" class="footnote">17</a>]</sup> fue
    diseñado entorno a algoritmos genéricos —código que procesa secuencias de
    cualquier tipo de valores de un modo seguro. El objetivo era usar algoritmos
    predefinidos para casi cualquier tarea, en lugar de codificar a mano cada vez que se
    necesitara procesar una colección de datos. Sin embargo, ese potencial requiere cierto
    aprendizaje. Para cuando llegue al final de este capítulo, debería ser capaz de
    decidir por sí mismo si los algoritmos le resultan útiles o demasiado confusos de
    recordar. Si es como la mayoría de la gente, se resistirá al principio pero entonces
    tenderá a usarlos más y más con el tiempo.
  </p><div class="sect1" title="7.1. Un primer vistazo"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4641792"></a>7.1. Un primer vistazo</h2></div></div></div><p>
      Entre otras cosas, los algoritmos genéricos de la librería estándar proporcionan un
      vocabulario con el que desribir soluciones. Una vez que los algoritmos le sean
      familiares, tendrá un nuevo conjunto de palabras con el que discutir que está
      haciendo, y esas palabras son de un nivel mayor que las que tenía antes. No
      necesitará decir «Este bucle recorre y asigna de aquí a ahí... oh, ya veo, ¡está
      copiando!» En su lugar dirá simplemente <code class="function">copy()</code>. Esto es lo que
      hemos estado haciendo desde el principio de la programación de computadores
      —creando abstracciones de alto nivel para expresar lo que está haciendo y
      perder menos tiempo diciendo cómo hacerlo. El «cómo» se ha resuelto una vez y para
      todo y está oculto en el código del algoritmo, listo para ser reutilizado cuando se
      necesite.
    </p><p>
      Vea aquí un ejemplo de cómo utilizar el algoritmo <code class="function">copy</code>:
    </p><div class="example"><a id="idp4644712"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyInts.cpp</span>
<span class="hl slc">// Copies ints without an explicit loop.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>  <span class="hl slc">// For size_t</span>
<span class="hl ppc"></span><span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SIZE<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>a<span class="hl opt">[</span>i<span class="hl opt">] ==</span> b<span class="hl opt">[</span>i<span class="hl opt">]);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.1. C06/CopyInts.cpp</strong></p></div><br class="example-break" /><p>
      Los dos primeros parámetros de <code class="function">copy</code> representan el rango de la
      secuencia de entrada —en este caso del array <code class="varname">a</code>. Los rangos
      se especifican con un par de punteros. El primero apunta al primer elemento de la
      secuencia, y el segungo apunta una posición después del final del array (justo
      después del último elemento). Esto puede parecer extraño al principio, pero es una
      antigua expresión idiomática de C que resulta bastante práctica. Por ejemplo, la
      diferencia entre esos dos punteros devuelve el número de elementos de la
      secuencia. Más importante, en la implementación de <code class="function">copy()</code>, el
      segundo puntero puede actual como un centinela para para la iteración a través de la
      secuencia. El tercer argumento hace referencia al comienzo de la secuencia de
      salida, que es el array <code class="varname">b</code> en el ejemplo. Se asume que el array
      <code class="varname">b</code> tiene suficiente espacio para recibir los elementos copiados.
    </p><p>
      El algotirmo <code class="function">copy()</code> no parece muy excitante if solo puediera
      procesar enteros. Puede copiar cualquier tipo de secuencia. El siguiente ejemplo
      copia objetos <code class="classname">string</code>.
    </p><div class="example"><a id="idp4650216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyStrings.cpp</span>
<span class="hl slc">// Copies strings.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string a<span class="hl opt">[] = {</span><span class="hl str">&quot;read&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;my&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;lips&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  string b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">equal</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.2. C06/CopyStrings.cpp</strong></p></div><br class="example-break" /><p>
      Este ejmeplo presenta otro algoritmo, <code class="function">equal()</code>, que devuelve
      cierto solo si cada elemento de la primera secuencia es igual (usando su
      <code class="function">operator==()</code>) a su elemento correspondiente en la segunda
      secuencia. Este ejemplo recorre cada secuencia 2 veces, una para copiar, y otra para
      comparar, sin ningún bucle explícito.
    </p><p>
      Los algoritmos genéricos consiguen esta flexibilidad porque son funciones
      parametrizadas (plantillas). Si piensa en la implementación de
      <code class="function">copy()</code> verá que es algo como lo siguiente, que es «casi»
      correcto:
    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename T<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">copy</span><span class="hl opt">(</span>T<span class="hl opt">*</span> begin<span class="hl opt">,</span> T<span class="hl opt">*</span> end<span class="hl opt">,</span> T<span class="hl opt">*</span> dest<span class="hl opt">) {</span>
  <span class="hl kwa">while</span> <span class="hl opt">(</span>begin <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    <span class="hl opt">*</span>dest<span class="hl opt">++ = *</span>begin<span class="hl opt">++;</span>
<span class="hl opt">}</span>
</pre><p>
      Decimos «casi» porque <code class="function">copy()</code> puede procesar secuencias
      delimitadas por cualquier cosa que actúe como un puntero, tal como un iterador. De
      ese modo, <code class="function">copy()</code> se puede utilizar para duplicar un
      <code class="classname">vector</code>, como en el siguiente ejemplo.
    </p><div class="example"><a id="idp4656152"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyVector.cpp</span>
<span class="hl slc">// Copies the contents of a vector.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v2</span><span class="hl opt">(</span>SIZE<span class="hl opt">);</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">equal</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.3. C06/CopyVector.cpp</strong></p></div><br class="example-break" /><p>
      El primer vector, <code class="varname">v1</code>, es inicializado a partir de una secuencia
      de enteros en el array <code class="varname">a</code>. La definición del vector
      <code class="varname">v2</code> usa un contructor diferente de <code class="classname">vector</code>
      que reserva sitio para <code class="constant">SIZE</code> elementos, inicializados a cero (el
      valor por defecto para enteros).
    </p><p>
      Igual que con el ejemplo anterior con el array, es importante que
      <code class="varname">v2</code> tenga suficiente espacio para recibir una copia de los
      contenidos de <code class="varname">v1</code>. Por conveniencia, una función de librería
      especial, <code class="function">back_inserter()</code>, retorna un tipo especial de iterador
      que inserta elementos en lugar de sobre-escribirlos, de modo que la memoria del
      contenedor se expande conforme se necesita. El siguiente ejemplo usa
      <code class="function">back_inserter()</code>, y por eso no hay que establecer el tamaño del
      vector de salida, <code class="varname">v2</code>, antes de tiempo.
    </p><div class="example"><a id="idp4661096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:InsertVector.cpp</span>
<span class="hl slc">// Appends the contents of a vector to another.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v2<span class="hl opt">;</span>  <span class="hl slc">// v2 is empty here</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>v2<span class="hl opt">));</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">equal</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.4. C06/InsertVector.cpp</strong></p></div><br class="example-break" /><p>
      La función <code class="function">back_inserter()</code> está definida en el fichero de
      cabecera <code class="filename">&lt;iterator&gt;</code>. Explicaremos los iteradores de
      inserción en profundidad en el próximo capítulo.
    </p><p>
      Dado que los iteradores son idénticos a punteros en todos los sentidos importantes,
      puede escribir los algoritmos de la librería estándar de modo que los argumentos
      puedan ser tanto punteros como iteradores. Por esta razón, la implementación de
      <code class="function">copy()</code> se parece más al siguiente código:
    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename Iterator<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">copy</span><span class="hl opt">(</span>Iterator begin<span class="hl opt">,</span> Iterator end<span class="hl opt">,</span> Iterator dest<span class="hl opt">) {</span>
  <span class="hl kwa">while</span> <span class="hl opt">(</span>begin <span class="hl opt">!=</span> end<span class="hl opt">)</span>
    <span class="hl opt">*</span>begin<span class="hl opt">++ = *</span>dest<span class="hl opt">++;</span>
<span class="hl opt">}</span>
</pre><p>
      Para cualquier tipo de argumento que use en la llamada, <code class="function">copy()</code>
      asume que implementa adecuadamente la indirección y los operadores de incremento. Si
      no lo hace, obtendrás un error de compilación.
    </p><div class="sect2" title="7.1.1. Predicados"><div class="titlepage"><div><div><h3 class="title"><a id="idp4666408"></a>7.1.1. Predicados</h3></div></div></div><p>
	A veces, podría querer copiar solo un subconjunto bien definido de una secuencia a
	otra; solo aquellos elementos que satisfagan una condición particular. Para
	conseguir esta flexibilidad, muchos algoritmos tienen una forma alternativa de
	llamada que permite proporcionar un predicado, que es simplemente una función que
	retorna un valor booleano basado en algún criterio. Suponga por ejemplo, que solo
	quiere extraer de una secuencia de enteros, aquellos que son menores o iguales de
	15. Una versión de <code class="function">copy()</code> llamada
	<code class="function">remove_copy_if()</code> puede hacer el trabajo, tal que así:
      </p><div class="example"><a id="idp4668280"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyInts2.cpp</span>
<span class="hl slc">// Ignores ints that satisfy a predicate.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// You supply this predicate</span>
<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> endb <span class="hl opt">=</span> <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a<span class="hl opt">+</span>SIZE<span class="hl opt">,</span> b<span class="hl opt">,</span> gt15<span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> beginb <span class="hl opt">=</span> b<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>beginb <span class="hl opt">!=</span> endb<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>beginb<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// Prints 10 only</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.5. C06/CopyInts2.cpp</strong></p></div><br class="example-break" /><p>
	La función <code class="function">remove_copy_if()</code> acepta los rangos definidos por
	punteros habituales, seguidos de un predicado de su elección. El predicado debe
	ser un puntero a función[FIXME] que toma un argumento simple del mismo tipo que
	los elementos de la secuencia, y que debe retornar un booleano. Aquí, la función
	<code class="function">gt15</code> returna verdadero si su argumento es mayor que 15. El
	algoritmo <code class="function">remove_copy_if()</code> aplica <code class="function">gt15()</code>
	a cada elemento en la secuencia de entrada e ignora aquellos elementos para los
	cuales el predicado devuelve verdad cuando escribe la secuencia de salida.
      </p><p>
	El siguiente programa ilustra otra variación más del algoritmo de copia.
      </p><div class="example"><a id="idp4672288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyStrings2.cpp</span>
<span class="hl slc">// Replaces strings that satisfy a predicate.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// The predicate</span>
<span class="hl kwb">bool</span> <span class="hl kwd">contains_e</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'e'</span><span class="hl opt">) !=</span> string<span class="hl opt">::</span>npos<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string a<span class="hl opt">[] = {</span><span class="hl str">&quot;read&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;my&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;lips&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  string b<span class="hl opt">[</span>SIZE<span class="hl opt">];</span>
  string<span class="hl opt">*</span> endb <span class="hl opt">=</span> <span class="hl kwd">replace_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> b<span class="hl opt">,</span>
    contains_e<span class="hl opt">,</span> <span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;kiss&quot;</span><span class="hl opt">));</span>
  string<span class="hl opt">*</span> beginb <span class="hl opt">=</span> b<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>beginb <span class="hl opt">!=</span> endb<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>beginb<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.6. C06/CopyStrings2.cpp</strong></p></div><br class="example-break" /><p>
	En lugar de simplemente ignorar elementos que no satisfagan el predicado,
	<code class="function">replace_copy_if()</code> substituye un valor fijo para esos
	elementos cuando escribe la secuencia de salida. La salida es:
      </p><pre class="screen">
kiss
my
lips
</pre><p>
	como la ocurrencia original de «read», la única cadena de entrada que
	contiene la letra «e», es reemplazada por la palabra
	«kiss», como se especificó en el último argumento en la llamada a
	<code class="function">replace_copy_if()</code>.
      </p><p>
	El algoritmo <code class="function">replace_if()</code> cambia la secuencia original in
	situ, en lugar de escribir en una secuencia de salida separada, tal como muestra
	el siguiente programa:
      </p><div class="example"><a id="idp4677824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:ReplaceStrings.cpp</span>
<span class="hl slc">// Replaces strings in-place.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">contains_e</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> s<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span><span class="hl str">'e'</span><span class="hl opt">) !=</span> string<span class="hl opt">::</span>npos<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string a<span class="hl opt">[] = {</span><span class="hl str">&quot;read&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;my&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;lips&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">replace_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> contains_e<span class="hl opt">,</span> <span class="hl kwd">string</span><span class="hl opt">(</span><span class="hl str">&quot;kiss&quot;</span><span class="hl opt">));</span>
  string<span class="hl opt">*</span> p <span class="hl opt">=</span> a<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>p <span class="hl opt">!=</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt; *</span>p<span class="hl opt">++ &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.7. C06/ReplaceStrings.cpp</strong></p></div><br class="example-break" /></div><div class="sect2" title="7.1.2. Iteradores de flujo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4680064"></a>7.1.2. Iteradores de flujo</h3></div></div></div><p>
	Como cualquier otra buena librería, la Librería Estándar de C++ intenta
	proporcionar modos convenientes de automatizar tareas comunes. Mencionamos al
	principio de este capítulo puede usar algoritmos genéricos en lugar de
	bucles. Hasta el momento, sin embargo, nuestros ejemplos siguen usando un bucle
	explícito para imprimir su salida. Dado que imprimir la salida es una de las
	tareas más comunes, es de esperar que haya una forma de automatizar eso también.
      </p><p>
	Ahí es donde los iteradores de flujo entran en juego. Un iterador de flujo usa un
	flujo como secuencia de entrada o salida. Para eliminar el bucle de salida en el
	programa <code class="filename">CopyInts2.cpp</code>, puede hacer algo como lo siguiente:
      </p><div class="example"><a id="idp4682176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyInts3.cpp</span>
<span class="hl slc">// Uses an output stream iterator.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span> gt15<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.8. C06/CopyInts3.cpp</strong></p></div><br class="example-break" /><p>
	En este ejemplo, reemplazaremos la secuencia de salida <code class="varname">b</code> en el
	tercer argumento de <code class="function">remove_copy_if()</code> con un iterador de flujo
	de salida, que es una instancia de la clase
	<code class="classname">ostream_iterator</code> declarada en el fichero
	<code class="filename">&lt;iterator&gt;</code>. Los iteradores de flujo de salida sobrecargan
	sus operadores de copia-asignación para escribir a sus flujos. Esta instancia en
	particular de <code class="classname">ostream_iterator</code> está vinculada al flujo de
	salida <code class="varname">cout</code>. Cada vez que <code class="function">remove_copy_if()</code>
	asigna un entero de la secuencia <code class="varname">a</code> a <code class="varname">cout</code> a
	través de este iterador, el iterador escribe el entero a <code class="varname">cout</code> y
	automáticamente escribe también una instancia de la cada de separador indicada en
	su segundo argumento, que en este caso contiene el carácter de nueva linea.
      </p><p>
	Es igual de fácil escribir en un fichero proporcionando un flujo de salida
	asociado a un fichero en lugar de <code class="varname">cout</code>.
      </p><div class="example"><a id="idp4687608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyIntsToFile.cpp</span>
<span class="hl slc">// Uses an output file stream iterator.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  ofstream <span class="hl kwd">outf</span><span class="hl opt">(</span><span class="hl str">&quot;ints.out&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>outf<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span> gt15<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.9. C06/CopyIntsToFile.cpp</strong></p></div><br class="example-break" /><p>
	Un iterador de flujo de entrada permite a un algoritmo leer su secuencia de
	entrada desde un flujo de entrada. Esto se consigue haciendo que tanto el
	constructor como <code class="function">operator++()</code> lean el siguiente elemento del
	flujo subyacente y sobrecargando <code class="function">operator*()</code> para conseguir
	el valor leído previamente. Dado que los algoritmos requieren dos punteros para
	delimitar la secuencia de entrada, puede construir un
	<code class="classname">istream_iterator</code> de dos formas, como puede ver en el
	siguiente programa.
      </p><div class="example"><a id="idp4690544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyIntsFromFile.cpp</span>
<span class="hl slc">// Uses an input stream iterator.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">gt15</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl num">15</span> <span class="hl opt">&lt;</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ofstream <span class="hl kwd">ints</span><span class="hl opt">(</span><span class="hl str">&quot;someInts.dat&quot;</span><span class="hl opt">);</span>
  ints <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;1 3 47 5 84 9&quot;</span><span class="hl opt">;</span>
  ints<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  ifstream <span class="hl kwd">inf</span><span class="hl opt">(</span><span class="hl str">&quot;someInts.dat&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>inf<span class="hl opt">,</span> <span class="hl str">&quot;someInts.dat&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>istream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>inf<span class="hl opt">),</span>
                 istream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span> gt15<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.10. C06/CopyIntsFromFile.cpp</strong></p></div><br class="example-break" /><p>
	El primer argumento de <code class="function">replace_copy_if()</code> en este programa
	asocia un objeto <code class="classname">istream_iterator</code> al fichero de entrada que
	contiene enteros. El segundo argumento usa el constructor por defecto de la clase
	<code class="classname">istream_iterator</code>. Esta llamada construye un valor especial
	de <code class="function">istream_iterator</code> que indica el fin de fichero, de modo que
	cuando el primer iterador encuentra el final del fichero físico, se compara con el
	valor de <code class="code">istream_iterator&lt;int&gt;()</code>, permitiendo al algoritmo terminar
	correctamente. Fíjese que este ejemplo evita usar un array explícito.
      </p></div><div class="sect2" title="7.1.3. Complejidad algorítmica"><div class="titlepage"><div><div><h3 class="title"><a id="idp4694688"></a>7.1.3. Complejidad algorítmica</h3></div></div></div><p>
	Usar una librería es una cuestión de confianza. Debe confiar en que los
	desarrolladores no solo proporcionan la funcionalidad correcta, sino también
	esperar que las funciones se ejecutan tan eficientemente como sea posible. Es
	mejor escribir sus propios bucles que usar algoritmos que degradan el rendimiento.
      </p><p>
	Para garantizar la calidad de las implementaciones de la librería, la estándar de
	C++ no solo especifica lo que debería hacer un algoritmo, también cómo de rápido
	debería hacerlo y a veces cuánto espacio debería usar. Cualquier algoritmo que no
	cumpla con los requisitos de rendimiento no es conforma al estándar. La medida de
	la eficiencia operacional de un algoritmo se llama complejidad.
      </p><p>
	Cuando es posible, el estándar especifica el número exacto de operaciones que un
	algoritmo debería usar. El algoritmo <code class="function">count_if()</code>, por ejemplo,
	retorna el número de elementos de una secuencia que cumplan el predicado
	especificado. La siguiente llamada a <code class="function">count_if()</code>, si se aplica
	a una secuencia de enteros similar a los ejemplos anteriores de este capítulo,
	devuelve el número de elementos mayores que 15:
      </p><pre class="programlisting">
<span class="hl kwb">size_t</span> n <span class="hl opt">=</span> <span class="hl kwd">count_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> gt15<span class="hl opt">);</span>
</pre><p>
	Dado que <code class="function">count_if()</code> debe comprobar cada elemento exactamente
	una vez, se especificó hacer un número de comprobaciones que sea exactamente igual
	que el número de elementos en la secuencia. El algoritmo
	<code class="function">copy()</code> tiene la misma especificación.
      </p><p>
	Otros algoritmos pueden estar especificados para realizar cierto número máximo de
	operaciones. El algoritmo <code class="function">find()</code> busca a través de una
	secuencia hasta encontrar un elemento igual a su tercer argumento.
      </p><pre class="programlisting">
<span class="hl kwb">int</span><span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwd">find</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">);</span>
</pre><p>
	Para tan pronto como encuentre el elemento y devuelve un puntero a la primera
	ocurrencia. Si no encuentra ninguno, retorna un puntero a una posición pasado el
	final de la secuencia (<code class="code">a+SIZE</code> en este ejemplo). De modo que
	<code class="function">find()</code> realiza como máximo tantas comparaciones como
	elementos tenga la secuencia.
      </p><p>
	A veces el número de operaciones que realiza un algoritmo no se puede medir con
	tanta precisión. En esos casos, el estándar especifica la complejidad asintótica
	del algoritmo, que es una medida de cómo se comportará el algoritmo con secuencias
	largas comparadas con formulas bien conocidas. Un buen ejemplo es el algoritmo
	<code class="function">sort()</code>, del que el estándar dice que requiere
	«aproximadamente n log n comparaciones de media» (n es el número de
	elementos de la secuencia). [FIXME]. Esta medida de complejidad da una idea del
	coste de un algoritmo y al menos le da una base fiable para comparar
	algoritmos. Como verá en el siguiente capítulo, el método
	<code class="function">find()</code> para el contendor <code class="classname">set</code> tiene
	complejidad logarítmica, que implica que el coste de una búsqueda de un elemento
	en un <code class="classname">set</code> será, para conjuntos grandes, proporcional al
	logaritmo del número de elementos. Eso es mucho menor que el número de elementos
	para un n grande, de modo que siempre es mejor buscar en un
	<code class="classname">set</code> utilizando el método en lugar del algoritmo genérico.
      </p></div></div><div class="sect1" title="7.2. Objetos-función"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4706488"></a>7.2. Objetos-función</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4707616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:GreaterThanN.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> gt_n <span class="hl opt">{</span>
  <span class="hl kwb">int</span> value<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">gt_n</span><span class="hl opt">(</span><span class="hl kwb">int</span> val<span class="hl opt">) :</span> <span class="hl kwd">value</span><span class="hl opt">(</span>val<span class="hl opt">) {}</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span> <span class="hl kwa">return</span> n <span class="hl opt">&gt;</span> value<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  gt_n <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// Prints 0 (for false)</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// Prints 1 (for true)</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.11. C06/GreaterThanN.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="sect2" title="7.2.1. Clasificación de objetos-función"><div class="titlepage"><div><div><h3 class="title"><a id="idp4709656"></a>7.2.1. Clasificación de objetos-función</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="7.2.2. Creación automática de objetos-función"><div class="titlepage"><div><div><h3 class="title"><a id="idp4712424"></a>7.2.2. Creación automática de objetos-función</h3></div></div></div><p>

      </p><p>

      </p><div class="example"><a id="idp4713216"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CopyInts4.cpp</span>
<span class="hl slc">// Uses a standard function object and adaptor.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span>
                 ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span>
                 <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> <span class="hl num">15</span><span class="hl opt">));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.12. C06/CopyInts4.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4716488"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CountNotEqual.cpp</span>
<span class="hl slc">// Count elements not equal to 20.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">,</span> <span class="hl num">30</span> <span class="hl opt">};</span>
  <span class="hl kwb">const size_t</span> SIZE <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">count_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SIZE<span class="hl opt">,</span>
                   <span class="hl kwd">not1</span><span class="hl opt">(</span><span class="hl kwd">bind1st</span><span class="hl opt">(</span>equal_to<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> <span class="hl num">20</span><span class="hl opt">)));</span><span class="hl slc">// 2</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.13. C06/CountNotEqual.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="7.2.3. Objetos-función adaptables"><div class="titlepage"><div><div><h3 class="title"><a id="idp4719680"></a>7.2.3. Objetos-función adaptables</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="7.2.4. Más ejemplos de objetos-función"><div class="titlepage"><div><div><h3 class="title"><a id="idp4722432"></a>7.2.4. Más ejemplos de objetos-función</h3></div></div></div><p>

      </p><div class="example"><a id="idp4723016"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Generators.h</span>
<span class="hl slc">// Different ways to fill sequences.</span>
<span class="hl ppc">#ifndef GENERATORS_H</span>
<span class="hl ppc">#define GENERATORS_H</span>
<span class="hl ppc">#include &lt;cstring&gt;</span>
<span class="hl ppc">#include &lt;set&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>

<span class="hl slc">// A generator that can skip over numbers:</span>
<span class="hl kwc">class</span> SkipGen <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwb">int</span> skp<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">SkipGen</span><span class="hl opt">(</span><span class="hl kwb">int</span> start <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwb">int</span> skip <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">i</span><span class="hl opt">(</span>start<span class="hl opt">),</span> <span class="hl kwd">skp</span><span class="hl opt">(</span>skip<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwb">int</span> r <span class="hl opt">=</span> i<span class="hl opt">;</span>
    i <span class="hl opt">+=</span> skp<span class="hl opt">;</span>
    <span class="hl kwa">return</span> r<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Generate unique random numbers from 0 to mod:</span>
<span class="hl kwc">class</span> URandGen <span class="hl opt">{</span>
  std<span class="hl opt">::</span>set<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> used<span class="hl opt">;</span>
  <span class="hl kwb">int</span> limit<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">URandGen</span><span class="hl opt">(</span><span class="hl kwb">int</span> lim<span class="hl opt">) :</span> <span class="hl kwd">limit</span><span class="hl opt">(</span>lim<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
      <span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl kwb">int</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">rand</span><span class="hl opt">()) %</span> limit<span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>used<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>i<span class="hl opt">) ==</span> used<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
        used<span class="hl opt">.</span><span class="hl kwd">insert</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
        <span class="hl kwa">return</span> i<span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Produces random characters:</span>
<span class="hl kwc">class</span> CharGen <span class="hl opt">{</span>
  <span class="hl kwb">static const char</span><span class="hl opt">*</span> source<span class="hl opt">;</span>
  <span class="hl kwb">static const int</span> len<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">char</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwa">return</span> source<span class="hl opt">[</span>std<span class="hl opt">::</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> len<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// GENERATORS_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.14. C06/Generators.h</strong></p></div><br class="example-break" /><div class="example"><a id="idp4724944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Generators.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">const char</span><span class="hl opt">*</span> CharGen<span class="hl opt">::</span>source <span class="hl opt">=</span> <span class="hl str">&quot;ABCDEFGHIJK&quot;</span>
  <span class="hl str">&quot;LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span><span class="hl opt">;</span>
<span class="hl kwb">const int</span> CharGen<span class="hl opt">::</span>len <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">strlen</span><span class="hl opt">(</span>source<span class="hl opt">);</span>
<span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.15. C06/Generators.cpp</strong></p></div><br class="example-break" /><p>

      </p><div class="example"><a id="idp4726176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:FunctionObjects.cpp {-bor}</span>
<span class="hl slc">// Illustrates selected predefined function object</span>
<span class="hl slc">// templates from the Standard C++ library.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename Contain<span class="hl opt">,</span> typename UnaryFunc<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">testUnary</span><span class="hl opt">(</span>Contain<span class="hl opt">&amp;</span> source<span class="hl opt">,</span> Contain<span class="hl opt">&amp;</span> dest<span class="hl opt">,</span>
  UnaryFunc f<span class="hl opt">) {</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>source<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> source<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> dest<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> f<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename Contain1<span class="hl opt">,</span> typename Contain2<span class="hl opt">,</span>
  typename BinaryFunc<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">testBinary</span><span class="hl opt">(</span>Contain1<span class="hl opt">&amp;</span> src1<span class="hl opt">,</span> Contain1<span class="hl opt">&amp;</span> src2<span class="hl opt">,</span>
  Contain2<span class="hl opt">&amp;</span> dest<span class="hl opt">,</span> BinaryFunc f<span class="hl opt">) {</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>src1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> src1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    src2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> dest<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> f<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl slc">// Executes the expression, then stringizes the</span>
<span class="hl slc">// expression into the print statement:</span>
<span class="hl ppc">#define T(EXPR) EXPR; print(r.begin(), r.end(), \</span>
<span class="hl ppc"></span>  <span class="hl pps">&quot;After &quot;</span><span class="hl ppc"> #EXPR);</span>
<span class="hl slc">// For Boolean tests:</span>
<span class="hl ppc">#define B(EXPR) EXPR; print(br.begin(), br.end(), \</span>
<span class="hl ppc"></span>  <span class="hl pps">&quot;After &quot;</span><span class="hl ppc"> #EXPR);</span>

<span class="hl slc">// Boolean random generator:</span>
<span class="hl kwb">struct</span> BRand <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span> <span class="hl kwa">return</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">2</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">;</span>
  <span class="hl kwb">const int</span> MAX <span class="hl opt">=</span> <span class="hl num">50</span><span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">x</span><span class="hl opt">(</span>SZ<span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span>SZ<span class="hl opt">),</span> <span class="hl kwd">r</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  <span class="hl slc">// An integer random number generator:</span>
  URandGen <span class="hl kwd">urg</span><span class="hl opt">(</span>MAX<span class="hl opt">);</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>  <span class="hl slc">// Randomize</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span>x<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> SZ<span class="hl opt">,</span> urg<span class="hl opt">);</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span>y<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> SZ<span class="hl opt">,</span> urg<span class="hl opt">);</span>
  <span class="hl slc">// Add one to each to guarantee nonzero divide:</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>y<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> y<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> y<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>
    <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>plus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> <span class="hl num">1</span><span class="hl opt">));</span>
  <span class="hl slc">// Guarantee one pair of elements is ==:</span>
  x<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> y<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>x<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> x<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;x&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>y<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> y<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;y&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Operate on each element pair of x &amp; y,</span>
  <span class="hl slc">// putting the result into r:</span>
  <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">,</span> plus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">,</span> minus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">,</span> multiplies<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">,</span> divides<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">,</span> modulus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">T</span><span class="hl opt">(</span><span class="hl kwd">testUnary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> r<span class="hl opt">,</span> negate<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt;</span> <span class="hl kwd">br</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span> <span class="hl slc">// For Boolean results</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> equal_to<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> not_equal_to<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> greater<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> less<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> greater_equal<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> less_equal<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> br<span class="hl opt">,</span> <span class="hl kwd">not2</span><span class="hl opt">(</span>greater_equal<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;())));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>x<span class="hl opt">,</span>y<span class="hl opt">,</span>br<span class="hl opt">,</span><span class="hl kwd">not2</span><span class="hl opt">(</span>less_equal<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;())));</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt;</span> <span class="hl kwd">b1</span><span class="hl opt">(</span>SZ<span class="hl opt">),</span> <span class="hl kwd">b2</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span>b1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> SZ<span class="hl opt">,</span> <span class="hl kwd">BRand</span><span class="hl opt">());</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span>b2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> SZ<span class="hl opt">,</span> <span class="hl kwd">BRand</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> b1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;b1&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> b2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;b2&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>b1<span class="hl opt">,</span> b2<span class="hl opt">,</span> br<span class="hl opt">,</span> logical_and<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testBinary</span><span class="hl opt">(</span>b1<span class="hl opt">,</span> b2<span class="hl opt">,</span> br<span class="hl opt">,</span> logical_or<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testUnary</span><span class="hl opt">(</span>b1<span class="hl opt">,</span> br<span class="hl opt">,</span> logical_not<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;()));</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwd">testUnary</span><span class="hl opt">(</span>b1<span class="hl opt">,</span> br<span class="hl opt">,</span> <span class="hl kwd">not1</span><span class="hl opt">(</span>logical_not<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;())));</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.16. C06/FunctionObjects.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4734824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:FBinder.cpp</span>
<span class="hl slc">// Binders aren't limited to producing predicates.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">out</span><span class="hl opt">(</span>cout<span class="hl opt">,</span><span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v</span><span class="hl opt">(</span><span class="hl num">15</span><span class="hl opt">);</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>  <span class="hl slc">// Randomize</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">URandGen</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">));</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> out<span class="hl opt">);</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>
            <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>multiplies<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> <span class="hl num">10</span><span class="hl opt">));</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> out<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.17. C06/FBinder.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4737352"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:BinderValue.cpp</span>
<span class="hl slc">// The bound argument can vary.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">boundedRand</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span><span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span>SZ<span class="hl opt">],</span> b<span class="hl opt">[</span>SZ<span class="hl opt">] = {</span><span class="hl num">0</span><span class="hl opt">};</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> boundedRand<span class="hl opt">);</span>
  <span class="hl kwb">int</span> val <span class="hl opt">=</span> <span class="hl kwd">boundedRand</span><span class="hl opt">();</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> end <span class="hl opt">=</span> <span class="hl kwd">remove_copy_if</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> b<span class="hl opt">,</span>
                            <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> val<span class="hl opt">));</span>
  <span class="hl slc">// Sort for easier viewing:</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">);</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>b<span class="hl opt">,</span> end<span class="hl opt">);</span>
  ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">out</span><span class="hl opt">(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Original Sequence:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> out<span class="hl opt">);</span> cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Values &lt;= &quot;</span> <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>b<span class="hl opt">,</span> end<span class="hl opt">,</span> out<span class="hl opt">);</span> cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.18. C06/BinderValue.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div><div class="sect2" title="7.2.5. Adaptadores de puntero a función"><div class="titlepage"><div><div><h3 class="title"><a id="idp4739856"></a>7.2.5. Adaptadores de puntero a función</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4740824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:PtrFun1.cpp</span>
<span class="hl slc">// Using ptr_fun() with a unary function.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> d<span class="hl opt">[] = {</span> <span class="hl num">123</span><span class="hl opt">,</span> <span class="hl num">94</span><span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">314</span><span class="hl opt">,</span> <span class="hl num">315</span> <span class="hl opt">};</span>
<span class="hl kwb">const int</span> DSZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> d <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>d<span class="hl opt">;</span>

<span class="hl kwb">bool</span> <span class="hl kwd">isEven</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> <span class="hl kwa">return</span> x <span class="hl opt">%</span> <span class="hl num">2</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt;</span> vb<span class="hl opt">;</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>d<span class="hl opt">,</span> d <span class="hl opt">+</span> DSZ<span class="hl opt">,</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vb<span class="hl opt">),</span>
    <span class="hl kwd">not1</span><span class="hl opt">(</span><span class="hl kwd">ptr_fun</span><span class="hl opt">(</span>isEven<span class="hl opt">)));</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>vb<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vb<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">bool</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Output: 1 0 0 0 1</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.19. C06/PtrFun1.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4743528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:PtrFun2.cpp {-edg}</span>
<span class="hl slc">// Using ptr_fun() for a binary function.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cmath&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">double</span> d<span class="hl opt">[] = {</span> <span class="hl num">01.23</span><span class="hl opt">,</span> <span class="hl num">91.370</span><span class="hl opt">,</span> <span class="hl num">56.661</span><span class="hl opt">,</span>
  <span class="hl num">023.230</span><span class="hl opt">,</span> <span class="hl num">19.959</span><span class="hl opt">,</span> <span class="hl num">1.0</span><span class="hl opt">,</span> <span class="hl num">3.14159</span> <span class="hl opt">};</span>
<span class="hl kwb">const int</span> DSZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> d <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>d<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;</span> vd<span class="hl opt">;</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>d<span class="hl opt">,</span> d <span class="hl opt">+</span> DSZ<span class="hl opt">,</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vd<span class="hl opt">),</span>
    <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>ptr_fun<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">,</span> <span class="hl kwb">double</span><span class="hl opt">&gt;(</span>pow<span class="hl opt">),</span> <span class="hl num">2.0</span><span class="hl opt">));</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>vd<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vd<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.20. C06/PtrFun2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4746040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:MemFun1.cpp</span>
<span class="hl slc">// Applying pointers to member functions.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Shape</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Circle <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::Draw()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Circle</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::~Circle()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Square <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::Draw()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Square</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::~Square()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Shape<span class="hl opt">*&gt;</span> vs<span class="hl opt">;</span>
  vs<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> Circle<span class="hl opt">);</span>
  vs<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> Square<span class="hl opt">);</span>
  <span class="hl kwd">for_each</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">mem_fun</span><span class="hl opt">(&amp;</span>Shape<span class="hl opt">::</span>draw<span class="hl opt">));</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>vs<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.21. C06/MemFun1.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp4748968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:MemFun2.cpp</span>
<span class="hl slc">// Calling member functions through an object reference.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Angle <span class="hl opt">{</span>
  <span class="hl kwb">int</span> degrees<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Angle</span><span class="hl opt">(</span><span class="hl kwb">int</span> deg<span class="hl opt">) :</span> <span class="hl kwd">degrees</span><span class="hl opt">(</span>deg<span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">mul</span><span class="hl opt">(</span><span class="hl kwb">int</span> times<span class="hl opt">) {</span> <span class="hl kwa">return</span> degrees <span class="hl opt">*=</span> times<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Angle<span class="hl opt">&gt;</span> va<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">50</span><span class="hl opt">;</span> i <span class="hl opt">+=</span> <span class="hl num">10</span><span class="hl opt">)</span>
    va<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwd">Angle</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl kwb">int</span> x<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">5</span> <span class="hl opt">};</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>va<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> va<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> x<span class="hl opt">,</span>
    ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">),</span>
    <span class="hl kwd">mem_fun_ref</span><span class="hl opt">(&amp;</span>Angle<span class="hl opt">::</span>mul<span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Output: 0 20 60 120 200</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.22. C06/MemFun2.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4750920"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:FindBlanks.cpp</span>
<span class="hl slc">// Demonstrates mem_fun_ref() with string::empty().</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">typedef</span> vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span>iterator LSI<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> fname <span class="hl opt">=</span> <span class="hl str">&quot;FindBlanks.cpp&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">&gt;</span> <span class="hl num">1</span><span class="hl opt">)</span> fname <span class="hl opt">=</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>fname<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> fname<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> vs<span class="hl opt">;</span>
  string s<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> s<span class="hl opt">))</span>
    vs<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>s<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> cpy <span class="hl opt">=</span> vs<span class="hl opt">;</span> <span class="hl slc">// For testing</span>
  LSI lsi <span class="hl opt">=</span> <span class="hl kwd">find_if</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
     <span class="hl kwd">mem_fun_ref</span><span class="hl opt">(&amp;</span>string<span class="hl opt">::</span>empty<span class="hl opt">));</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>lsi <span class="hl opt">!=</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
    <span class="hl opt">*</span>lsi <span class="hl opt">=</span> <span class="hl str">&quot;A BLANK LINE&quot;</span><span class="hl opt">;</span>
    lsi <span class="hl opt">=</span> <span class="hl kwd">find_if</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
      <span class="hl kwd">mem_fun_ref</span><span class="hl opt">(&amp;</span>string<span class="hl opt">::</span>empty<span class="hl opt">));</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> cpy<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++)</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>cpy<span class="hl opt">[</span>i<span class="hl opt">].</span><span class="hl kwd">size</span><span class="hl opt">() ==</span> <span class="hl num">0</span><span class="hl opt">)</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>vs<span class="hl opt">[</span>i<span class="hl opt">] ==</span> <span class="hl str">&quot;A BLANK LINE&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">else</span>
      <span class="hl kwa">assert</span><span class="hl opt">(</span>vs<span class="hl opt">[</span>i<span class="hl opt">] !=</span> <span class="hl str">&quot;A BLANK LINE&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.23. C06/FindBlanks.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="7.2.6. Escribir sus propios adaptadores de objeto-función"><div class="titlepage"><div><div><h3 class="title"><a id="idp4754176"></a>7.2.6. Escribir sus propios adaptadores de objeto-función</h3></div></div></div><p>

      </p><div class="example"><a id="idp4754800"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:NumStringGen.h</span>
<span class="hl slc">// A random number generator that produces</span>
<span class="hl slc">// strings representing floating-point numbers.</span>
<span class="hl ppc">#ifndef NUMSTRINGGEN_H</span>
<span class="hl ppc">#define NUMSTRINGGEN_H</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>

<span class="hl kwc">class</span> NumStringGen <span class="hl opt">{</span>
  <span class="hl kwb">const int</span> sz<span class="hl opt">;</span> <span class="hl slc">// Number of digits to make</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">NumStringGen</span><span class="hl opt">(</span><span class="hl kwb">int</span> ssz <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">) :</span> <span class="hl kwd">sz</span><span class="hl opt">(</span>ssz<span class="hl opt">) {}</span>
  std<span class="hl opt">::</span>string <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    std<span class="hl opt">::</span>string <span class="hl kwd">digits</span><span class="hl opt">(</span><span class="hl str">&quot;0123456789&quot;</span><span class="hl opt">);</span>
    <span class="hl kwb">const int</span> ndigits <span class="hl opt">=</span> digits<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span>
    std<span class="hl opt">::</span>string <span class="hl kwd">r</span><span class="hl opt">(</span>sz<span class="hl opt">,</span> <span class="hl str">' '</span><span class="hl opt">);</span>
    <span class="hl slc">// Don't want a zero as the first digit</span>
    r<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> digits<span class="hl opt">[</span>std<span class="hl opt">::</span><span class="hl kwd">rand</span><span class="hl opt">() % (</span>ndigits <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">)] +</span> <span class="hl num">1</span><span class="hl opt">;</span>
    <span class="hl slc">// Now assign the rest</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> sz<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>sz <span class="hl opt">&gt;=</span> <span class="hl num">3</span> <span class="hl opt">&amp;&amp;</span> i <span class="hl opt">==</span> sz<span class="hl opt">/</span><span class="hl num">2</span><span class="hl opt">)</span>
        r<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl str">'.'</span><span class="hl opt">;</span> <span class="hl slc">// Insert a decimal point</span>
      <span class="hl kwa">else</span>
        r<span class="hl opt">[</span>i<span class="hl opt">] =</span> digits<span class="hl opt">[</span>std<span class="hl opt">::</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> ndigits<span class="hl opt">];</span>
    <span class="hl kwa">return</span> r<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// NUMSTRINGGEN_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.24. C06/NumStringGen.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4757528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:MemFun3.cpp</span>
<span class="hl slc">// Using mem_fun().</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NumStringGen.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> <span class="hl kwd">vs</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  <span class="hl slc">// Fill it with random number strings:</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Randomize</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">NumStringGen</span><span class="hl opt">());</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    ostream_iterator<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">const char</span><span class="hl opt">*</span> vcp<span class="hl opt">[</span>SZ<span class="hl opt">];</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> vcp<span class="hl opt">,</span>
    <span class="hl kwd">mem_fun_ref</span><span class="hl opt">(&amp;</span>string<span class="hl opt">::</span>c_str<span class="hl opt">));</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;</span> vd<span class="hl opt">;</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>vcp<span class="hl opt">,</span> vcp <span class="hl opt">+</span> SZ<span class="hl opt">,</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vd<span class="hl opt">),</span>
    std<span class="hl opt">::</span>atof<span class="hl opt">);</span>
  cout<span class="hl opt">.</span><span class="hl kwd">precision</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">);</span>
  cout<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>showpoint<span class="hl opt">);</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>vd<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vd<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.25. C06/MemFun3.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4760528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:ComposeTry.cpp</span>
<span class="hl slc">// A first attempt at implementing function composition.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename R<span class="hl opt">,</span> typename E<span class="hl opt">,</span> typename F1<span class="hl opt">,</span> typename F2<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> unary_composer <span class="hl opt">{</span>
  F1 f1<span class="hl opt">;</span>
  F2 f2<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">unary_composer</span><span class="hl opt">(</span>F1 fone<span class="hl opt">,</span> F2 ftwo<span class="hl opt">) :</span> <span class="hl kwd">f1</span><span class="hl opt">(</span>fone<span class="hl opt">),</span> <span class="hl kwd">f2</span><span class="hl opt">(</span>ftwo<span class="hl opt">) {}</span>
  R <span class="hl kwc">operator</span><span class="hl opt">()(</span>E x<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl kwd">f1</span><span class="hl opt">(</span><span class="hl kwd">f2</span><span class="hl opt">(</span>x<span class="hl opt">)); }</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename R<span class="hl opt">,</span> typename E<span class="hl opt">,</span> typename F1<span class="hl opt">,</span> typename F2<span class="hl opt">&gt;</span>
unary_composer<span class="hl opt">&lt;</span>R<span class="hl opt">,</span> E<span class="hl opt">,</span> F1<span class="hl opt">,</span> F2<span class="hl opt">&gt;</span> <span class="hl kwd">compose</span><span class="hl opt">(</span>F1 f1<span class="hl opt">,</span> F2 f2<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> unary_composer<span class="hl opt">&lt;</span>R<span class="hl opt">,</span> E<span class="hl opt">,</span> F1<span class="hl opt">,</span> F2<span class="hl opt">&gt;(</span>f1<span class="hl opt">,</span> f2<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">double</span> x <span class="hl opt">=</span> compose<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">,</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;&gt;(</span>
    atof<span class="hl opt">,</span> <span class="hl kwd">mem_fun_ref</span><span class="hl opt">(&amp;</span>string<span class="hl opt">::</span>c_str<span class="hl opt">))(</span><span class="hl str">&quot;12.34&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>x <span class="hl opt">==</span> <span class="hl num">12.34</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.26. C06/ComposeTry.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp4762784"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:ComposeFinal.cpp {-edg}</span>
<span class="hl slc">// An adaptable composer.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NumStringGen.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename F1<span class="hl opt">,</span> typename F2<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> unary_composer
<span class="hl opt">:</span> <span class="hl kwc">public</span> unary_function<span class="hl opt">&lt;</span>typename F2<span class="hl opt">::</span>argument_type<span class="hl opt">,</span>
                        typename F1<span class="hl opt">::</span>result_type<span class="hl opt">&gt; {</span>
  F1 f1<span class="hl opt">;</span>
  F2 f2<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">unary_composer</span><span class="hl opt">(</span>F1 f1<span class="hl opt">,</span> F2 f2<span class="hl opt">) :</span> <span class="hl kwd">f1</span><span class="hl opt">(</span>f1<span class="hl opt">),</span> <span class="hl kwd">f2</span><span class="hl opt">(</span>f2<span class="hl opt">) {}</span>
  typename F1<span class="hl opt">::</span>result_type
  <span class="hl kwc">operator</span><span class="hl opt">()(</span>typename F2<span class="hl opt">::</span>argument_type x<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">f1</span><span class="hl opt">(</span><span class="hl kwd">f2</span><span class="hl opt">(</span>x<span class="hl opt">));</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename F1<span class="hl opt">,</span> typename F2<span class="hl opt">&gt;</span>
unary_composer<span class="hl opt">&lt;</span>F1<span class="hl opt">,</span> F2<span class="hl opt">&gt;</span> <span class="hl kwd">compose</span><span class="hl opt">(</span>F1 f1<span class="hl opt">,</span> F2 f2<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> unary_composer<span class="hl opt">&lt;</span>F1<span class="hl opt">,</span> F2<span class="hl opt">&gt;(</span>f1<span class="hl opt">,</span> f2<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">9</span><span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> <span class="hl kwd">vs</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  <span class="hl slc">// Fill it with random number strings:</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">NumStringGen</span><span class="hl opt">());</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    ostream_iterator<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;</span> vd<span class="hl opt">;</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>vs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vd<span class="hl opt">),</span>
    <span class="hl kwd">compose</span><span class="hl opt">(</span><span class="hl kwd">ptr_fun</span><span class="hl opt">(</span>atof<span class="hl opt">),</span> <span class="hl kwd">mem_fun_ref</span><span class="hl opt">(&amp;</span>string<span class="hl opt">::</span>c_str<span class="hl opt">)));</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>vd<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vd<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    ostream_iterator<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.27. C06/ComposeFinal.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p></div></div><div class="sect1" title="7.3. Un catálogo de algoritmos STL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4765784"></a>7.3. Un catálogo de algoritmos STL</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="sect2" title="7.3.1. Herramientas de soporte para la creación de ejemplos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4768864"></a>7.3.1. Herramientas de soporte para la creación de ejemplos</h3></div></div></div><p>

      </p><p>

      </p><div class="example"><a id="idp4769680"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:PrintSequence.h</span>
<span class="hl slc">// Prints the contents of any sequence.</span>
<span class="hl ppc">#ifndef PRINTSEQUENCE_H</span>
<span class="hl ppc">#define PRINTSEQUENCE_H</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename Iter<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>Iter first<span class="hl opt">,</span> Iter last<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> nm <span class="hl opt">=</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">,</span>
           <span class="hl kwb">const char</span><span class="hl opt">*</span> sep <span class="hl opt">=</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
           std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os <span class="hl opt">=</span> std<span class="hl opt">::</span>cout<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>nm <span class="hl opt">!=</span> <span class="hl num">0</span> <span class="hl opt">&amp;&amp; *</span>nm <span class="hl opt">!=</span> <span class="hl str">'\0'</span><span class="hl opt">)</span>
    os <span class="hl opt">&lt;&lt;</span> nm <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> sep<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> typename 
    std<span class="hl opt">::</span>iterator_traits<span class="hl opt">&lt;</span>Iter<span class="hl opt">&gt;::</span>value_type T<span class="hl opt">;</span>
  std<span class="hl opt">::</span><span class="hl kwd">copy</span><span class="hl opt">(</span>first<span class="hl opt">,</span> last<span class="hl opt">,</span> 
            std<span class="hl opt">::</span>ostream_iterator<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;(</span>std<span class="hl opt">::</span>cout<span class="hl opt">,</span> sep<span class="hl opt">));</span>
  os <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// PRINTSEQUENCE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.28. C06/PrintSequence.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Reordenación estable vs. inestable"><div class="titlepage"><div><div><h4 class="title"><a id="idp4772040"></a>Reordenación estable vs. inestable</h4></div></div></div><p>

        </p><p>

        </p><div class="example"><a id="idp4772824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:NString.h</span>
<span class="hl slc">// A &quot;numbered string&quot; that keeps track of the</span>
<span class="hl slc">// number of occurrences of the word it contains.</span>
<span class="hl ppc">#ifndef NSTRING_H</span>
<span class="hl ppc">#define NSTRING_H</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;utility&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>

<span class="hl kwc">typedef</span> std<span class="hl opt">::</span>pair<span class="hl opt">&lt;</span>std<span class="hl opt">::</span>string<span class="hl opt">,</span> <span class="hl kwb">int</span><span class="hl opt">&gt;</span> psi<span class="hl opt">;</span>

<span class="hl slc">// Only compare on the first element</span>
<span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> psi<span class="hl opt">&amp;</span> l<span class="hl opt">,</span> <span class="hl kwb">const</span> psi<span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> l<span class="hl opt">.</span>first <span class="hl opt">==</span> r<span class="hl opt">.</span>first<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> NString <span class="hl opt">{</span>
  std<span class="hl opt">::</span>string s<span class="hl opt">;</span>
  <span class="hl kwb">int</span> thisOccurrence<span class="hl opt">;</span>
  <span class="hl slc">// Keep track of the number of occurrences:</span>
  <span class="hl kwc">typedef</span> std<span class="hl opt">::</span>vector<span class="hl opt">&lt;</span>psi<span class="hl opt">&gt;</span> vp<span class="hl opt">;</span>
  <span class="hl kwc">typedef</span> vp<span class="hl opt">::</span>iterator vpit<span class="hl opt">;</span>
  <span class="hl kwb">static</span> vp words<span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addString</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> x<span class="hl opt">) {</span>
    psi <span class="hl kwd">p</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
    vpit it <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">find</span><span class="hl opt">(</span>words<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> words<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> p<span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> words<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
      thisOccurrence <span class="hl opt">= ++</span>it<span class="hl opt">-&gt;</span>second<span class="hl opt">;</span>
    <span class="hl kwa">else</span> <span class="hl opt">{</span>
      thisOccurrence <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
      words<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>p<span class="hl opt">);</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">NString</span><span class="hl opt">() :</span> <span class="hl kwd">thisOccurrence</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwd">NString</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> x<span class="hl opt">) :</span> <span class="hl kwd">s</span><span class="hl opt">(</span>x<span class="hl opt">) {</span> <span class="hl kwd">addString</span><span class="hl opt">(</span>x<span class="hl opt">); }</span>
  <span class="hl kwd">NString</span><span class="hl opt">(</span><span class="hl kwb">const char</span><span class="hl opt">*</span> x<span class="hl opt">) :</span> <span class="hl kwd">s</span><span class="hl opt">(</span>x<span class="hl opt">) {</span> <span class="hl kwd">addString</span><span class="hl opt">(</span>x<span class="hl opt">); }</span>
  <span class="hl slc">// Implicit operator= and copy-constructor are OK here.</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>
    std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> ns<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> ns<span class="hl opt">.</span>s <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; [&quot;</span> <span class="hl opt">&lt;&lt;</span> ns<span class="hl opt">.</span>thisOccurrence <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;]&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Need this for sorting. Notice it only</span>
  <span class="hl slc">// compares strings, not occurrences:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;(</span><span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> l<span class="hl opt">,</span> <span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> l<span class="hl opt">.</span>s <span class="hl opt">&lt;</span> r<span class="hl opt">.</span>s<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> l<span class="hl opt">,</span> <span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> l<span class="hl opt">.</span>s <span class="hl opt">==</span> r<span class="hl opt">.</span>s<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// For sorting with greater&lt;NString&gt;:</span>
  <span class="hl kwc">friend</span> <span class="hl kwb">bool</span>
  <span class="hl kwc">operator</span><span class="hl opt">&gt;(</span><span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> l<span class="hl opt">,</span> <span class="hl kwb">const</span> NString<span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> l<span class="hl opt">.</span>s <span class="hl opt">&gt;</span> r<span class="hl opt">.</span>s<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// To get at the string directly:</span>
  <span class="hl kwc">operator</span> <span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> s<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Because NString::vp is a template and we are using the</span>
<span class="hl slc">// inclusion model, it must be defined in this header file:</span>
NString<span class="hl opt">::</span>vp NString<span class="hl opt">::</span>words<span class="hl opt">;</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// NSTRING_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.29. C06/NString.h</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.2. Relleno y generación"><div class="titlepage"><div><div><h3 class="title"><a id="idp4776136"></a>7.3.2. Relleno y generación</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4777464"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4777976"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:FillGenerateTest.cpp</span>
<span class="hl slc">// Demonstrates &quot;fill&quot; and &quot;generate.&quot;</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">);</span>
  <span class="hl kwd">fill</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;howdy&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v1&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;</span> v2<span class="hl opt">;</span>
  <span class="hl kwd">fill_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>v2<span class="hl opt">),</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl str">&quot;bye&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v2&quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v3</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v3<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v3<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">SkipGen</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">,</span><span class="hl num">5</span><span class="hl opt">));</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v3<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v3&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v4<span class="hl opt">;</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>v4<span class="hl opt">),</span><span class="hl num">15</span><span class="hl opt">,</span> <span class="hl kwd">URandGen</span><span class="hl opt">(</span><span class="hl num">30</span><span class="hl opt">));</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v4<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v4<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v4&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.30. C06/FillGenerateTest.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.3. Conteo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4780984"></a>7.3.3. Conteo</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4782264"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4782776"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Counting.cpp</span>
<span class="hl slc">// The counting algorithms.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;set&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;</span> v<span class="hl opt">;</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>v<span class="hl opt">),</span> <span class="hl num">50</span><span class="hl opt">,</span> <span class="hl kwd">CharGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Create a set of the characters in v:</span>
  set<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;</span> <span class="hl kwd">cs</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwc">typedef</span> set<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;::</span>iterator sci<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>sci it <span class="hl opt">=</span> cs<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span> it <span class="hl opt">!=</span> cs<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span> it<span class="hl opt">++) {</span>
    <span class="hl kwb">int</span> n <span class="hl opt">=</span> <span class="hl kwd">count</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(), *</span>it<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> n <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> lc <span class="hl opt">=</span> <span class="hl kwd">count_if</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;(),</span> <span class="hl str">'a'</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">Lowercase letters: &quot;</span> <span class="hl opt">&lt;&lt;</span> lc <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;sorted&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.31. C06/Counting.cpp</strong></p></div><br class="example-break" /><p>

        </p></div></div><div class="sect2" title="7.3.4. Manipulación de secuencias"><div class="titlepage"><div><div><h3 class="title"><a id="idp4785256"></a>7.3.4. Manipulación de secuencias</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4789480"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4789992"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Manipulations.cpp</span>
<span class="hl slc">// Shows basic manipulations.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl slc">// NString</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NString.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v1</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl slc">// Simple counting:</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">SkipGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v1&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v2</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">());</span>
  <span class="hl kwd">copy_backward</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;copy_backward&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">reverse_copy</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;reverse_copy&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">reverse</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;reverse&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> half <span class="hl opt">=</span> v1<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() /</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl slc">// Ranges must be exactly the same size:</span>
  <span class="hl kwd">swap_ranges</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">() +</span> half<span class="hl opt">,</span>
    v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">() +</span> half<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;swap_ranges&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Start with a fresh sequence:</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">SkipGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v1&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> third <span class="hl opt">=</span> v1<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() /</span> <span class="hl num">3</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwd">rotate</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">() +</span> third<span class="hl opt">,</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span>v1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;rotate&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Second rotate example:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">char</span> c<span class="hl opt">[] =</span> <span class="hl str">&quot;aabbccddeeffgghhiijj&quot;</span><span class="hl opt">;</span>
  <span class="hl kwb">const char</span> CSZ <span class="hl opt">=</span> <span class="hl kwd">strlen</span><span class="hl opt">(</span>c<span class="hl opt">);</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwd">rotate</span><span class="hl opt">(</span>c<span class="hl opt">,</span> c <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">,</span> c <span class="hl opt">+</span> CSZ<span class="hl opt">);</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span>c<span class="hl opt">,</span> c <span class="hl opt">+</span> CSZ<span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;All n! permutations of abcd:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">int</span> nf <span class="hl opt">=</span> <span class="hl num">4</span> <span class="hl opt">*</span> <span class="hl num">3</span> <span class="hl opt">*</span> <span class="hl num">2</span> <span class="hl opt">*</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span> p<span class="hl opt">[] =</span> <span class="hl str">&quot;abcd&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> nf<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwd">next_permutation</span><span class="hl opt">(</span>p<span class="hl opt">,</span> p <span class="hl opt">+</span> <span class="hl num">4</span><span class="hl opt">);</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span>p<span class="hl opt">,</span> p <span class="hl opt">+</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Using prev_permutation:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> nf<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwd">prev_permutation</span><span class="hl opt">(</span>p<span class="hl opt">,</span> p <span class="hl opt">+</span> <span class="hl num">4</span><span class="hl opt">);</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span>p<span class="hl opt">,</span> p <span class="hl opt">+</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;random_shuffling a word:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  string <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl str">&quot;hello&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
    <span class="hl kwd">random_shuffle</span><span class="hl opt">(</span>s<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
    cout <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  NString sa<span class="hl opt">[] = {</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;c&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;d&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span>
    <span class="hl str">&quot;c&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;d&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;c&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;d&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;c&quot;</span><span class="hl opt">};</span>
  <span class="hl kwb">const int</span> SASZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> sa <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>sa<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;</span> <span class="hl kwd">ns</span><span class="hl opt">(</span>sa<span class="hl opt">,</span> sa <span class="hl opt">+</span> SASZ<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>ns<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> ns<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;ns&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span>
    <span class="hl kwd">partition</span><span class="hl opt">(</span>ns<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> ns<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
      <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;(),</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Partition point: &quot;</span> <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>ns<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> ns<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Reload vector:</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>sa<span class="hl opt">,</span> sa <span class="hl opt">+</span> SASZ<span class="hl opt">,</span> ns<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  it <span class="hl opt">=</span> <span class="hl kwd">stable_partition</span><span class="hl opt">(</span>ns<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> ns<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;(),</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Stable partition&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Partition point: &quot;</span> <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>ns<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> ns<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.32. C06/Manipulations.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.5. Búsqueda y reemplazo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4795128"></a>7.3.5. Búsqueda y reemplazo</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4799528"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4800040"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:SearchReplace.cpp</span>
<span class="hl slc">// The STL search and replace algorithms.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">struct</span> PlusOne <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">int</span> j<span class="hl opt">) {</span> <span class="hl kwa">return</span> j <span class="hl opt">==</span> i <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> MulMoreThan <span class="hl opt">{</span>
  <span class="hl kwb">int</span> value<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MulMoreThan</span><span class="hl opt">(</span><span class="hl kwb">int</span> val<span class="hl opt">) :</span> <span class="hl kwd">value</span><span class="hl opt">(</span>val<span class="hl opt">) {}</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">int</span> v<span class="hl opt">,</span> <span class="hl kwb">int</span> m<span class="hl opt">) {</span> <span class="hl kwa">return</span> v <span class="hl opt">*</span> m <span class="hl opt">&gt;</span> value<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span>
    <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">11</span> <span class="hl opt">};</span>
  <span class="hl kwb">const int</span> ASZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>a<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> <span class="hl kwd">v</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span> <span class="hl kwd">find</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl num">4</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;find: &quot;</span> <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  it <span class="hl opt">=</span> <span class="hl kwd">find_if</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> <span class="hl num">8</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;find_if: &quot;</span> <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  it <span class="hl opt">=</span> <span class="hl kwd">adjacent_find</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;adjacent_find: &quot;</span> <span class="hl opt">&lt;&lt; *</span>it
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span> <span class="hl opt">&lt;&lt; *(</span>it <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
    it <span class="hl opt">=</span> <span class="hl kwd">adjacent_find</span><span class="hl opt">(</span>it <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">,</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
  it <span class="hl opt">=</span> <span class="hl kwd">adjacent_find</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">PlusOne</span><span class="hl opt">());</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;adjacent_find PlusOne: &quot;</span> <span class="hl opt">&lt;&lt; *</span>it
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, &quot;</span> <span class="hl opt">&lt;&lt; *(</span>it <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
    it <span class="hl opt">=</span> <span class="hl kwd">adjacent_find</span><span class="hl opt">(</span>it <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">,</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">PlusOne</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[] = {</span> <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">11</span> <span class="hl opt">};</span>
  <span class="hl kwb">const int</span> BSZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> b <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>b<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> b <span class="hl opt">+</span> BSZ<span class="hl opt">,</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">find_first_of</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> b<span class="hl opt">,</span> b <span class="hl opt">+</span> BSZ<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> it <span class="hl opt">+</span> BSZ<span class="hl opt">,</span> <span class="hl str">&quot;find_first_of&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">find_first_of</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    b<span class="hl opt">,</span> b <span class="hl opt">+</span> BSZ<span class="hl opt">,</span> <span class="hl kwd">PlusOne</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span>it <span class="hl opt">+</span> BSZ<span class="hl opt">,</span><span class="hl str">&quot;find_first_of PlusOne&quot;</span><span class="hl opt">,</span><span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">search</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> b<span class="hl opt">,</span> b <span class="hl opt">+</span> BSZ<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> it <span class="hl opt">+</span> BSZ<span class="hl opt">,</span> <span class="hl str">&quot;search&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> c<span class="hl opt">[] = {</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">6</span><span class="hl opt">,</span> <span class="hl num">7</span> <span class="hl opt">};</span>
  <span class="hl kwb">const int</span> CSZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> c <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>c<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>c<span class="hl opt">,</span> c <span class="hl opt">+</span> CSZ<span class="hl opt">,</span> <span class="hl str">&quot;c&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">search</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> c<span class="hl opt">,</span> c <span class="hl opt">+</span> CSZ<span class="hl opt">,</span> <span class="hl kwd">PlusOne</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> it <span class="hl opt">+</span> CSZ<span class="hl opt">,</span><span class="hl str">&quot;search PlusOne&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> d<span class="hl opt">[] = {</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">11</span> <span class="hl opt">};</span>
  <span class="hl kwb">const int</span> DSZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> d <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> <span class="hl opt">*</span>d<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>d<span class="hl opt">,</span> d <span class="hl opt">+</span> DSZ<span class="hl opt">,</span> <span class="hl str">&quot;d&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">find_end</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> d<span class="hl opt">,</span> d <span class="hl opt">+</span> DSZ<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span><span class="hl str">&quot;find_end&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> e<span class="hl opt">[] = {</span> <span class="hl num">9</span><span class="hl opt">,</span> <span class="hl num">9</span> <span class="hl opt">};</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>e<span class="hl opt">,</span> e <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl str">&quot;e&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">find_end</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> e<span class="hl opt">,</span> e <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl kwd">PlusOne</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span><span class="hl str">&quot;find_end PlusOne&quot;</span><span class="hl opt">,</span><span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">search_n</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> it <span class="hl opt">+</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl str">&quot;search_n 3, 7&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">search_n</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    <span class="hl num">6</span><span class="hl opt">,</span> <span class="hl num">15</span><span class="hl opt">,</span> <span class="hl kwd">MulMoreThan</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">));</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> it <span class="hl opt">+</span> <span class="hl num">6</span><span class="hl opt">,</span>
    <span class="hl str">&quot;search_n 6, 15, MulMoreThan(100)&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;min_element: &quot;</span>
       <span class="hl opt">&lt;&lt; *</span><span class="hl kwd">min_element</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;max_element: &quot;</span>
       <span class="hl opt">&lt;&lt; *</span><span class="hl kwd">max_element</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) &lt;&lt;</span> endl<span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> v2<span class="hl opt">;</span>
  <span class="hl kwd">replace_copy</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>v2<span class="hl opt">),</span> <span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;replace_copy 8 -&gt; 47&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">replace_if</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    <span class="hl kwd">bind2nd</span><span class="hl opt">(</span>greater_equal<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> <span class="hl num">7</span><span class="hl opt">), -</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;replace_if &gt;= 7 -&gt; -1&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.33. C06/SearchReplace.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.6. Comparación de rangos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4810144"></a>7.3.6. Comparación de rangos</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4812440"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4812952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Comparison.cpp</span>
<span class="hl slc">// The STL range comparison algorithms.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Strings provide a convenient way to create</span>
  <span class="hl slc">// ranges of characters, but you should</span>
  <span class="hl slc">// normally look for native string operations:</span>
  string <span class="hl kwd">s1</span><span class="hl opt">(</span><span class="hl str">&quot;This is a test&quot;</span><span class="hl opt">);</span>
  string <span class="hl kwd">s2</span><span class="hl opt">(</span><span class="hl str">&quot;This is a Test&quot;</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;s1: &quot;</span> <span class="hl opt">&lt;&lt;</span> s1 <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;s2: &quot;</span> <span class="hl opt">&lt;&lt;</span> s2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;compare s1 &amp; s1: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">equal</span><span class="hl opt">(</span>s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;compare s1 &amp; s2: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">equal</span><span class="hl opt">(</span>s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">()) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;lexicographical_compare s1 &amp; s1: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">lexicographical_compare</span><span class="hl opt">(</span>s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
          s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) &lt;&lt;</span>  endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;lexicographical_compare s1 &amp; s2: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">lexicographical_compare</span><span class="hl opt">(</span>s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
          s2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;lexicographical_compare s2 &amp; s1: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">lexicographical_compare</span><span class="hl opt">(</span>s2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
          s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;lexicographical_compare shortened &quot;</span>
          <span class="hl str">&quot;s1 &amp; full-length s2: &quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  string <span class="hl kwd">s3</span><span class="hl opt">(</span>s1<span class="hl opt">);</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>s3<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">() !=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    <span class="hl kwb">bool</span> result <span class="hl opt">=</span> <span class="hl kwd">lexicographical_compare</span><span class="hl opt">(</span>
      s3<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s3<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>s2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
    cout <span class="hl opt">&lt;&lt;</span> s3 <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> s2 <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, result = &quot;</span>
         <span class="hl opt">&lt;&lt;</span> result <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>result <span class="hl opt">==</span> <span class="hl kwa">true</span><span class="hl opt">)</span> <span class="hl kwa">break</span><span class="hl opt">;</span>
    s3 <span class="hl opt">=</span> s3<span class="hl opt">.</span><span class="hl kwd">substr</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> s3<span class="hl opt">.</span><span class="hl kwd">length</span><span class="hl opt">() -</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  pair<span class="hl opt">&lt;</span>string<span class="hl opt">::</span>iterator<span class="hl opt">,</span> string<span class="hl opt">::</span>iterator<span class="hl opt">&gt;</span> p <span class="hl opt">=</span>
    <span class="hl kwd">mismatch</span><span class="hl opt">(</span>s1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> s2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>p<span class="hl opt">.</span>first<span class="hl opt">,</span> s1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;p.first&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>p<span class="hl opt">.</span>second<span class="hl opt">,</span> s2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;p.second&quot;</span><span class="hl opt">,</span><span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.34. C06/Comparison.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.7. Eliminación de elementos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4816608"></a>7.3.7. Eliminación de elementos</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4820056"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4820568"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Removing.cpp</span>
<span class="hl slc">// The removing algorithms.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">struct</span> IsUpper <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">char</span> c<span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl kwd">isupper</span><span class="hl opt">(</span>c<span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  string v<span class="hl opt">;</span>
  v<span class="hl opt">.</span><span class="hl kwd">resize</span><span class="hl opt">(</span><span class="hl num">25</span><span class="hl opt">);</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">CharGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v original&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Create a set of the characters in v:</span>
  string <span class="hl kwd">us</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>us<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> us<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  string<span class="hl opt">::</span>iterator it <span class="hl opt">=</span> us<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit <span class="hl opt">=</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>
    uend <span class="hl opt">=</span> <span class="hl kwd">unique</span><span class="hl opt">(</span>us<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> us<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl slc">// Step through and remove everything:</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> uend<span class="hl opt">) {</span>
    cit <span class="hl opt">=</span> <span class="hl kwd">remove</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">, *</span>it<span class="hl opt">);</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;Complete v&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">,</span> <span class="hl str">&quot;Pseudo v &quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Removed element:</span><span class="hl esc">\t</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt; *</span>it
         <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">Psuedo Last Element:</span><span class="hl esc">\t</span><span class="hl str">&quot;</span>
         <span class="hl opt">&lt;&lt; *</span>cit <span class="hl opt">&lt;&lt;</span> endl <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">++</span>it<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">CharGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;v&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  cit <span class="hl opt">=</span> <span class="hl kwd">remove_if</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">IsUpper</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">,</span> <span class="hl str">&quot;v after remove_if IsUpper&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Copying versions are not shown for remove()</span>
  <span class="hl slc">// and remove_if().</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">,</span> <span class="hl str">&quot;sorted&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  string v2<span class="hl opt">;</span>
  v2<span class="hl opt">.</span><span class="hl kwd">resize</span><span class="hl opt">(</span>cit <span class="hl opt">-</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  <span class="hl kwd">unique_copy</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">,</span> v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;unique_copy&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Same behavior:</span>
  cit <span class="hl opt">=</span> <span class="hl kwd">unique</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">,</span> equal_to<span class="hl opt">&lt;</span><span class="hl kwb">char</span><span class="hl opt">&gt;());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cit<span class="hl opt">,</span> <span class="hl str">&quot;unique equal_to&lt;char&gt;&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.35. C06/Removing.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.8. Ordenación y operación sobre rangos ordenados"><div class="titlepage"><div><div><h3 class="title"><a id="idp4823808"></a>7.3.8. Ordenación y operación sobre rangos ordenados</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ordenación"><div class="titlepage"><div><div><h4 class="title"><a id="idp4824808"></a>Ordenación</h4></div></div></div><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p></div><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4829608"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4830120"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:SortedSearchTest.cpp</span>
<span class="hl slc">// Test searching in sorted ranges.</span>
<span class="hl slc">// NString</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;NString.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../require.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwc">typedef</span> vector<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;::</span>iterator sit<span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> fname <span class="hl opt">=</span> <span class="hl str">&quot;Test.txt&quot;</span><span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">&gt;</span> <span class="hl num">1</span><span class="hl opt">)</span> fname <span class="hl opt">=</span> argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
  ifstream <span class="hl kwd">in</span><span class="hl opt">(</span>fname<span class="hl opt">);</span>
  <span class="hl kwd">assure</span><span class="hl opt">(</span>in<span class="hl opt">,</span> fname<span class="hl opt">);</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>
  cout<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>boolalpha<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;</span> original<span class="hl opt">;</span>
  <span class="hl kwd">copy</span><span class="hl opt">(</span>istream_iterator<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;(</span>in<span class="hl opt">),</span>
    istream_iterator<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;(),</span> <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>original<span class="hl opt">));</span>
  <span class="hl kwd">require</span><span class="hl opt">(</span>original<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() &gt;=</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl str">&quot;Must have four elements&quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>NString<span class="hl opt">&gt;</span> <span class="hl kwd">v</span><span class="hl opt">(</span>original<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> original<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()),</span>
    <span class="hl kwd">w</span><span class="hl opt">(</span>original<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() /</span> <span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;sort&quot;</span><span class="hl opt">);</span>
  v <span class="hl opt">=</span> original<span class="hl opt">;</span>
  <span class="hl kwd">stable_sort</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;stable_sort&quot;</span><span class="hl opt">);</span>
  v <span class="hl opt">=</span> original<span class="hl opt">;</span>
  sit it <span class="hl opt">=</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> it2<span class="hl opt">;</span>
  <span class="hl slc">// Move iterator to middle</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() /</span> <span class="hl num">2</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl opt">++</span>it<span class="hl opt">;</span>
  <span class="hl kwd">partial_sort</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> it<span class="hl opt">,</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;middle = &quot;</span> <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;partial_sort&quot;</span><span class="hl opt">);</span>
  v <span class="hl opt">=</span> original<span class="hl opt">;</span>
  <span class="hl slc">// Move iterator to a quarter position</span>
  it <span class="hl opt">=</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> v<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() /</span> <span class="hl num">4</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    <span class="hl opt">++</span>it<span class="hl opt">;</span>
  <span class="hl slc">// Less elements to copy from than to the destination</span>
  <span class="hl kwd">partial_sort_copy</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> it<span class="hl opt">,</span> w<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> w<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>w<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> w<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;partial_sort_copy&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Not enough room in destination</span>
  <span class="hl kwd">partial_sort_copy</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> w<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>w<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>w<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> w<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;w partial_sort_copy&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// v remains the same through all this process</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>v <span class="hl opt">==</span> original<span class="hl opt">);</span>
  <span class="hl kwd">nth_element</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> it<span class="hl opt">,</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;The nth_element = &quot;</span> <span class="hl opt">&lt;&lt; *</span>it <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;nth_element&quot;</span><span class="hl opt">);</span>
  string f <span class="hl opt">=</span> original<span class="hl opt">[</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> original<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">()];</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;binary search: &quot;</span>
       <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">binary_search</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> f<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">());</span>
  it <span class="hl opt">=</span> <span class="hl kwd">lower_bound</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> f<span class="hl opt">);</span>
  it2 <span class="hl opt">=</span> <span class="hl kwd">upper_bound</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> f<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>it<span class="hl opt">,</span> it2<span class="hl opt">,</span> <span class="hl str">&quot;found range&quot;</span><span class="hl opt">);</span>
  pair<span class="hl opt">&lt;</span>sit<span class="hl opt">,</span> sit<span class="hl opt">&gt;</span> ip <span class="hl opt">=</span> <span class="hl kwd">equal_range</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> f<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>ip<span class="hl opt">.</span>first<span class="hl opt">,</span> ip<span class="hl opt">.</span>second<span class="hl opt">,</span> <span class="hl str">&quot;equal_range&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.36. C06/SortedSearchTest.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p></div><div class="sect3" title="Mezcla de rangos ordenados"><div class="titlepage"><div><div><h4 class="title"><a id="idp4833904"></a>Mezcla de rangos ordenados</h4></div></div></div><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p></div><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4835248"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4835760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:MergeTest.cpp</span>
<span class="hl slc">// Test merging in sorted ranges.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">15</span><span class="hl opt">;</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[</span>SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">] = {</span><span class="hl num">0</span><span class="hl opt">};</span>
  <span class="hl slc">// Both ranges go in the same array:</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> <span class="hl kwd">SkipGen</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">));</span>
  a<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">] =</span> <span class="hl num">4</span><span class="hl opt">;</span>
  a<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">] =</span> <span class="hl num">4</span><span class="hl opt">;</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl kwd">SkipGen</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">));</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> <span class="hl str">&quot;range1&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl str">&quot;range2&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[</span>SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">] = {</span><span class="hl num">0</span><span class="hl opt">};</span> <span class="hl slc">// Initialize all to zero</span>
  <span class="hl kwd">merge</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> b <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl str">&quot;merge&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Reset b</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    b<span class="hl opt">[</span>i<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwd">inplace_merge</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl str">&quot;inplace_merge&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> end <span class="hl opt">=</span> <span class="hl kwd">set_union</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">,</span> a <span class="hl opt">+</span> SZ<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;set_union&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.37. C06/MergeTest.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p></div><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4841120"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4841632"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:SetOperations.cpp</span>
<span class="hl slc">// Set operations on sorted ranges.</span>
<span class="hl slc">//{L} Generators</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Generators.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">30</span><span class="hl opt">;</span>
  <span class="hl kwb">char</span> v<span class="hl opt">[</span>SZ <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">],</span> v2<span class="hl opt">[</span>SZ <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">];</span>
  CharGen g<span class="hl opt">;</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span> g<span class="hl opt">);</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">,</span> g<span class="hl opt">);</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">);</span>
  <span class="hl kwd">sort</span><span class="hl opt">(</span>v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span> <span class="hl str">&quot;v&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">,</span> <span class="hl str">&quot;v2&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">bool</span> b <span class="hl opt">=</span> <span class="hl kwd">includes</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">/</span><span class="hl num">2</span><span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">);</span>
  cout<span class="hl opt">.</span><span class="hl kwd">setf</span><span class="hl opt">(</span>ios<span class="hl opt">::</span>boolalpha<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;includes: &quot;</span> <span class="hl opt">&lt;&lt;</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">char</span> v3<span class="hl opt">[</span>SZ<span class="hl opt">*</span><span class="hl num">2</span> <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">], *</span>end<span class="hl opt">;</span>
  end <span class="hl opt">=</span> <span class="hl kwd">set_union</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v3<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;set_union&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  end <span class="hl opt">=</span> <span class="hl kwd">set_intersection</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v3<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;set_intersection&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  end <span class="hl opt">=</span> <span class="hl kwd">set_difference</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v3<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;set_difference&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
  end <span class="hl opt">=</span> <span class="hl kwd">set_symmetric_difference</span><span class="hl opt">(</span>v<span class="hl opt">,</span> v <span class="hl opt">+</span> SZ<span class="hl opt">,</span>
    v2<span class="hl opt">,</span> v2 <span class="hl opt">+</span> SZ<span class="hl opt">,</span> v3<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>v3<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;set_symmetric_difference&quot;</span><span class="hl opt">,</span><span class="hl str">&quot;&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.38. C06/SetOperations.cpp</strong></p></div><br class="example-break" /><p>

        </p></div></div><div class="sect2" title="7.3.9. Operaciones sobre el montículo"><div class="titlepage"><div><div><h3 class="title"><a id="idp4843968"></a>7.3.9. Operaciones sobre el montículo</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="7.3.10. Aplicando una operación a cada elemento de un rango"><div class="titlepage"><div><div><h3 class="title"><a id="idp4846344"></a>7.3.10. Aplicando una operación a cada elemento de un rango</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplos"><div class="titlepage"><div><div><h4 class="title"><a id="idp4847928"></a>Ejemplos</h4></div></div></div><p>

        </p><p>

        </p><p>

        </p><p>

        </p><div class="example"><a id="idp4849016"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Counted.h</span>
<span class="hl slc">// An object that keeps track of itself.</span>
<span class="hl ppc">#ifndef COUNTED_H</span>
<span class="hl ppc">#define COUNTED_H</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>

<span class="hl kwc">class</span> Counted <span class="hl opt">{</span>
  <span class="hl kwb">static int</span> count<span class="hl opt">;</span>
  <span class="hl kwb">char</span><span class="hl opt">*</span> ident<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Counted</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> id<span class="hl opt">) :</span> <span class="hl kwd">ident</span><span class="hl opt">(</span>id<span class="hl opt">) { ++</span>count<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Counted</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> ident <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; count = &quot;</span>
              <span class="hl opt">&lt;&lt; --</span>count <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> CountedVector <span class="hl opt">:</span> <span class="hl kwc">public</span> std<span class="hl opt">::</span>vector<span class="hl opt">&lt;</span>Counted<span class="hl opt">*&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">CountedVector</span><span class="hl opt">(</span><span class="hl kwb">char</span><span class="hl opt">*</span> id<span class="hl opt">) {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      <span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Counted</span><span class="hl opt">(</span>id<span class="hl opt">));</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// COUNTED_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.39. C06/Counted.h</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><div class="example"><a id="idp4850968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:ForEach.cpp {-mwcc}</span>
<span class="hl slc">// Use of STL for_each() algorithm.</span>
<span class="hl slc">//{L} Counted</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Counted.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Function object:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> DeleteT <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span>T<span class="hl opt">*</span> x<span class="hl opt">) {</span> <span class="hl kwa">delete</span> x<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Template function:</span>
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">void</span> <span class="hl kwd">wipe</span><span class="hl opt">(</span>T<span class="hl opt">*</span> x<span class="hl opt">) {</span> <span class="hl kwa">delete</span> x<span class="hl opt">; }</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CountedVector <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl str">&quot;two&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">for_each</span><span class="hl opt">(</span>B<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> B<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> DeleteT<span class="hl opt">&lt;</span>Counted<span class="hl opt">&gt;());</span>
  CountedVector <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl str">&quot;three&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">for_each</span><span class="hl opt">(</span>C<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> C<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> wipe<span class="hl opt">&lt;</span>Counted<span class="hl opt">&gt;);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.40. C06/ForEach.cpp</strong></p></div><br class="example-break" /><p>

        </p><div class="example"><a id="idp4853024"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Transform.cpp {-mwcc}</span>
<span class="hl slc">// Use of STL transform() algorithm.</span>
<span class="hl slc">//{L} Counted</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Counted.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> T<span class="hl opt">*</span> <span class="hl kwd">deleteP</span><span class="hl opt">(</span>T<span class="hl opt">*</span> x<span class="hl opt">) {</span> <span class="hl kwa">delete</span> x<span class="hl opt">;</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">; }</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwb">struct</span> Deleter <span class="hl opt">{</span>
  T<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span>T<span class="hl opt">*</span> x<span class="hl opt">) {</span> <span class="hl kwa">delete</span> x<span class="hl opt">;</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CountedVector <span class="hl kwd">cv</span><span class="hl opt">(</span><span class="hl str">&quot;one&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>cv<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cv<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> cv<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>
    deleteP<span class="hl opt">&lt;</span>Counted<span class="hl opt">&gt;);</span>
  CountedVector <span class="hl kwd">cv2</span><span class="hl opt">(</span><span class="hl str">&quot;two&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>cv2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> cv2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> cv2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>
    Deleter<span class="hl opt">&lt;</span>Counted<span class="hl opt">&gt;());</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.41. C06/Transform.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><p>

        </p><div class="example"><a id="idp4856200"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:Inventory.h</span>
<span class="hl ppc">#ifndef INVENTORY_H</span>
<span class="hl ppc">#define INVENTORY_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>rand<span class="hl opt">;</span>

<span class="hl kwc">class</span> Inventory <span class="hl opt">{</span>
  <span class="hl kwb">char</span> item<span class="hl opt">;</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>
  <span class="hl kwb">int</span> value<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Inventory</span><span class="hl opt">(</span><span class="hl kwb">char</span> it<span class="hl opt">,</span> <span class="hl kwb">int</span> quant<span class="hl opt">,</span> <span class="hl kwb">int</span> val<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">item</span><span class="hl opt">(</span>it<span class="hl opt">),</span> <span class="hl kwd">quantity</span><span class="hl opt">(</span>quant<span class="hl opt">),</span> <span class="hl kwd">value</span><span class="hl opt">(</span>val<span class="hl opt">) {}</span>
  <span class="hl slc">// Synthesized operator= &amp; copy-constructor OK</span>
  <span class="hl kwb">char</span> <span class="hl kwd">getItem</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> item<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getQuantity</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> quantity<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setQuantity</span><span class="hl opt">(</span><span class="hl kwb">int</span> q<span class="hl opt">) {</span> quantity <span class="hl opt">=</span> q<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getValue</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> value<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl kwb">int</span> val<span class="hl opt">) {</span> value <span class="hl opt">=</span> val<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>
    std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Inventory<span class="hl opt">&amp;</span> inv<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> inv<span class="hl opt">.</span>item <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;quantity &quot;</span> <span class="hl opt">&lt;&lt;</span> inv<span class="hl opt">.</span>quantity
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, value &quot;</span> <span class="hl opt">&lt;&lt;</span> inv<span class="hl opt">.</span>value<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// A generator:</span>
<span class="hl kwb">struct</span> InvenGen <span class="hl opt">{</span>
  Inventory <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwb">static char</span> c <span class="hl opt">=</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
    <span class="hl kwb">int</span> q <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">100</span><span class="hl opt">;</span>
    <span class="hl kwb">int</span> v <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">500</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Inventory</span><span class="hl opt">(</span>c<span class="hl opt">++,</span> q<span class="hl opt">,</span> v<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// INVENTORY_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.42. C06/Inventory.h</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><div class="example"><a id="idp4859352"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:CalcInventory.cpp</span>
<span class="hl slc">// More use of for_each().</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Inventory.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// To calculate inventory totals:</span>
<span class="hl kwc">class</span> InvAccum <span class="hl opt">{</span>
  <span class="hl kwb">int</span> quantity<span class="hl opt">;</span>
  <span class="hl kwb">int</span> value<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">InvAccum</span><span class="hl opt">() :</span> <span class="hl kwd">quantity</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">value</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">const</span> Inventory<span class="hl opt">&amp;</span> inv<span class="hl opt">) {</span>
    quantity <span class="hl opt">+=</span> inv<span class="hl opt">.</span><span class="hl kwd">getQuantity</span><span class="hl opt">();</span>
    value <span class="hl opt">+=</span> inv<span class="hl opt">.</span><span class="hl kwd">getQuantity</span><span class="hl opt">() *</span> inv<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> InvAccum<span class="hl opt">&amp;</span> ia<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;total quantity: &quot;</span> <span class="hl opt">&lt;&lt;</span> ia<span class="hl opt">.</span>quantity
              <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;, total value: &quot;</span> <span class="hl opt">&lt;&lt;</span> ia<span class="hl opt">.</span>value<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Inventory<span class="hl opt">&gt;</span> vi<span class="hl opt">;</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>  <span class="hl slc">// Randomize</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vi<span class="hl opt">),</span> <span class="hl num">15</span><span class="hl opt">,</span> <span class="hl kwd">InvenGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;vi&quot;</span><span class="hl opt">);</span>
  InvAccum ia <span class="hl opt">=</span> <span class="hl kwd">for_each</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">InvAccum</span><span class="hl opt">());</span>
  cout <span class="hl opt">&lt;&lt;</span> ia <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.43. C06/CalcInventory.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><div class="example"><a id="idp4862488"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:TransformNames.cpp</span>
<span class="hl slc">// More use of transform().</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;cctype&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Inventory.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">struct</span> NewImproved <span class="hl opt">{</span>
  Inventory <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">const</span> Inventory<span class="hl opt">&amp;</span> inv<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Inventory</span><span class="hl opt">(</span><span class="hl kwd">toupper</span><span class="hl opt">(</span>inv<span class="hl opt">.</span><span class="hl kwd">getItem</span><span class="hl opt">()),</span>
      inv<span class="hl opt">.</span><span class="hl kwd">getQuantity</span><span class="hl opt">(),</span> inv<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Inventory<span class="hl opt">&gt;</span> vi<span class="hl opt">;</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>  <span class="hl slc">// Randomize</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vi<span class="hl opt">),</span> <span class="hl num">15</span><span class="hl opt">,</span> <span class="hl kwd">InvenGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;vi&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span><span class="hl kwd">NewImproved</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;vi&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.44. C06/TransformNames.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p><div class="example"><a id="idp4865328"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:SpecialList.cpp</span>
<span class="hl slc">// Using the second version of transform().</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Inventory.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">struct</span> Discounter <span class="hl opt">{</span>
  Inventory <span class="hl kwc">operator</span><span class="hl opt">()(</span><span class="hl kwb">const</span> Inventory<span class="hl opt">&amp;</span> inv<span class="hl opt">,</span>
    <span class="hl kwb">float</span> discount<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">Inventory</span><span class="hl opt">(</span>inv<span class="hl opt">.</span><span class="hl kwd">getItem</span><span class="hl opt">(),</span> inv<span class="hl opt">.</span><span class="hl kwd">getQuantity</span><span class="hl opt">(),</span>
      <span class="hl kwb">int</span><span class="hl opt">(</span>inv<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() * (</span><span class="hl num">1</span> <span class="hl opt">-</span> discount<span class="hl opt">)));</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">struct</span> DiscGen <span class="hl opt">{</span>
  <span class="hl kwb">float</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwb">float</span> r <span class="hl opt">=</span> <span class="hl kwb">float</span><span class="hl opt">(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">10</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> r <span class="hl opt">/</span> <span class="hl num">100.0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Inventory<span class="hl opt">&gt;</span> vi<span class="hl opt">;</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>  <span class="hl slc">// Randomize</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>vi<span class="hl opt">),</span> <span class="hl num">15</span><span class="hl opt">,</span> <span class="hl kwd">InvenGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;vi&quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> disc<span class="hl opt">;</span>
  <span class="hl kwd">generate_n</span><span class="hl opt">(</span><span class="hl kwd">back_inserter</span><span class="hl opt">(</span>disc<span class="hl opt">),</span> <span class="hl num">15</span><span class="hl opt">,</span> <span class="hl kwd">DiscGen</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>disc<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> disc<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl str">&quot;Discounts:&quot;</span><span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>Inventory<span class="hl opt">&gt;</span> discounted<span class="hl opt">;</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>vi<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>vi<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> disc<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span>
    <span class="hl kwd">back_inserter</span><span class="hl opt">(</span>discounted<span class="hl opt">),</span> <span class="hl kwd">Discounter</span><span class="hl opt">());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>discounted<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> discounted<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span><span class="hl str">&quot;discounted&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.45. C06/SpecialList.cpp</strong></p></div><br class="example-break" /><p>

        </p></div></div><div class="sect2" title="7.3.11. Algoritmos numéricos"><div class="titlepage"><div><div><h3 class="title"><a id="idp4867992"></a>7.3.11. Algoritmos numéricos</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="sect3" title="Ejemplo"><div class="titlepage"><div><div><h4 class="title"><a id="idp4872008"></a>Ejemplo</h4></div></div></div><p>

        </p><div class="example"><a id="idp4872520"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:NumericTest.cpp</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;functional&gt;</span>
<span class="hl ppc">#include &lt;numeric&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">int</span> a<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">,</span> <span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">13</span> <span class="hl opt">};</span>
  <span class="hl kwb">const int</span> ASZ <span class="hl opt">=</span> <span class="hl kwa">sizeof</span> a <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> a<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> <span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl kwb">int</span> r <span class="hl opt">=</span> <span class="hl kwd">accumulate</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;accumulate 1: &quot;</span> <span class="hl opt">&lt;&lt;</span> r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Should produce the same result:</span>
  r <span class="hl opt">=</span> <span class="hl kwd">accumulate</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> plus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;accumulate 2: &quot;</span> <span class="hl opt">&lt;&lt;</span> r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">int</span> b<span class="hl opt">[] = {</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span> <span class="hl opt">};</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> b <span class="hl opt">+</span> <span class="hl kwa">sizeof</span> b <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> b<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">],</span> <span class="hl str">&quot;b&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  r <span class="hl opt">=</span> <span class="hl kwd">inner_product</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> b<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inner_product 1: &quot;</span> <span class="hl opt">&lt;&lt;</span> r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Should produce the same result:</span>
  r <span class="hl opt">=</span> <span class="hl kwd">inner_product</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> b<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span>
    plus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(),</span> multiplies<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;());</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inner_product 2: &quot;</span> <span class="hl opt">&lt;&lt;</span> r <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> it <span class="hl opt">=</span> <span class="hl kwd">partial_sum</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> it<span class="hl opt">,</span> <span class="hl str">&quot;partial_sum 1&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Should produce the same result:</span>
  it <span class="hl opt">=</span> <span class="hl kwd">partial_sum</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> b<span class="hl opt">,</span> plus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> it<span class="hl opt">,</span> <span class="hl str">&quot;partial_sum 2&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  it <span class="hl opt">=</span> <span class="hl kwd">adjacent_difference</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> b<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> it<span class="hl opt">,</span> <span class="hl str">&quot;adjacent_difference 1&quot;</span><span class="hl opt">,</span><span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Should produce the same result:</span>
  it <span class="hl opt">=</span> <span class="hl kwd">adjacent_difference</span><span class="hl opt">(</span>a<span class="hl opt">,</span> a <span class="hl opt">+</span> ASZ<span class="hl opt">,</span> b<span class="hl opt">,</span> minus<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;());</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>b<span class="hl opt">,</span> it<span class="hl opt">,</span> <span class="hl str">&quot;adjacent_difference 2&quot;</span><span class="hl opt">,</span><span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 7.46. C06/NumericTest.cpp</strong></p></div><br class="example-break" /><p>

        </p><p>

        </p></div></div><div class="sect2" title="7.3.12. Utilidades generales"><div class="titlepage"><div><div><h3 class="title"><a id="idp4875920"></a>7.3.12. Utilidades generales</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="7.4. Creando sus propios algoritmos tipo STL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4879440"></a>7.4. Creando sus propios algoritmos tipo STL</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><pre class="programlisting">
<span class="hl slc">// Assumes pred is the incoming condition</span>
<span class="hl kwd">replace_copy_if</span><span class="hl opt">(</span>begin<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl kwd">not1</span><span class="hl opt">(</span>pred<span class="hl opt">));</span>
</pre><p>

    </p><div class="example"><a id="idp4881000"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C06:copy_if.h</span>
<span class="hl slc">// Create your own STL-style algorithm.</span>
<span class="hl ppc">#ifndef COPY_IF_H</span>
<span class="hl ppc">#define COPY_IF_H</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename ForwardIter<span class="hl opt">,</span>
  typename OutputIter<span class="hl opt">,</span> typename UnaryPred<span class="hl opt">&gt;</span>
OutputIter <span class="hl kwd">copy_if</span><span class="hl opt">(</span>ForwardIter begin<span class="hl opt">,</span> ForwardIter end<span class="hl opt">,</span>
  OutputIter dest<span class="hl opt">,</span> UnaryPred f<span class="hl opt">) {</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>begin <span class="hl opt">!=</span> end<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">f</span><span class="hl opt">(*</span>begin<span class="hl opt">))</span>
      <span class="hl opt">*</span>dest<span class="hl opt">++ = *</span>begin<span class="hl opt">;</span>
    <span class="hl opt">++</span>begin<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">return</span> dest<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// COPY_IF_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 7.47. C06/copy_if.h</strong></p></div><br class="example-break" /><p>

    </p></div><div class="sect1" title="7.5. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4883000"></a>7.5. Resumen</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="7.6. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4883960"></a>7.6. Ejercicios</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp4640008" href="#idp4640008" class="para">17</a>] </sup>N. de T.: Librería Estándar de Plantillas.</p></div></div></div></div><div class="part" title="Parte III. Temas especiales"><div class="titlepage"><div><div><h1 class="title"><a id="idp4898296"></a>Parte III. Temas especiales</h1></div></div></div><div class="partintro" title="Temas especiales"><div></div><div class="highlights"><p>
	  La marca de un profesional aparece en su atención a los
	  detalles más finos del oficio. En esta sección del libro veremos características
	  avanzadas de C++ junto con técnicas de desarrollo usadas por
	  profesionales brillantes de C++.
	</p></div><p>
	A veces necesita salir de los convencionalismos que suenan a
	diseño orientado a objetos, inspeccionando el tipo de un objeto
	en tiempo de ejecución. La mayoría de las veces debería dejar
	que las funciones virtuales hagan ese trabajo por usted, pero
	cuando escriba herramientas software para propósitos especiales,
	tales como depuradores, visualizadores de bases de datos, o
	navegadores de clases, necesitará determinar la información de
	tipado en tiempo de ejecución. Ahí es cuando el mecanismo de identificación
	de tipo en tiempo de ejecución (RTTI) resulta útil. RTTI es el
	tema del Capítulo 8.
      </p><p>
	La herencia múltiple ha sido maltratado a lo largo de los años,
	y algunos lenguajes incluso no la permiten. No obstante, cuando
	se usa adecuadamente, puede ser una herramienta potente para
	conseguir código eficiente y elegante. Un buen número de
	prácticas estándar que involucran herencia múltiple han
	evolucionado con el tiempo; las veremos en el Capítulo 9.
      </p><p>
	Quizás la innovación más notable en el desarrollo de software
	desde las técnicas de orientación a objetos es el uso de los
	patrones de diseño. Un patrón de diseño describe soluciones para
	muchos problemas comunes del diseño de software, y se puede
	aplicar a muchas situaciones e implementación en cualquier
	lenguaje. En el Capítulo 10 describiremos una selección de
	patrones de diseño y los implementaremos en C++.
      </p><p>
	El Capítulo 11 explica los beneficios y desafíos de la
	programación multihilo. La versión actual de C++ Estándar no
	especifica soporte para hilos, aunque la mayoría de los sistema
	operativos los ofrecen. Usaremos un librería portable y
	disponible libremente para ilustrar cómo los programadores
	pueden sacar provecho de los hilos para construir aplicaciones
	más usables y receptivas.
      </p><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="chapter"><a href="#C09">8. Herencia múltiple</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp4905016">8.1. Perspectiva</a></span></dt><dt><span class="sect1"><a href="#idp4931136">8.2. Herencia de interfaces</a></span></dt><dt><span class="sect1"><a href="#idp4945776">8.3. Herencia de implementación</a></span></dt><dt><span class="sect1"><a href="#idp4963152">8.4. Subobjetos duplicados</a></span></dt><dt><span class="sect1"><a href="#idp4969320">8.5. Clases base virtuales</a></span></dt><dt><span class="sect1"><a href="#idp4985016">8.6. Cuestión sobre búsqueda de nombres</a></span></dt><dt><span class="sect1"><a href="#idp4992112">8.7. Evitar la MI</a></span></dt><dt><span class="sect1"><a href="#idp4993456">8.8. Extender una interface</a></span></dt><dt><span class="sect1"><a href="#idp5003216">8.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5004176">8.10. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C10">9. Patrones de Diseño</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5011344">9.1. El Concepto de Patrón </a></span></dt><dt><span class="sect1"><a href="#idp5022176">9.2. Clasificación de los patrones</a></span></dt><dt><span class="sect1"><a href="#idp5031576">9.3.  Simplificación de modismos</a></span></dt><dt><span class="sect1"><a href="#idp5041816">9.4. Singleton</a></span></dt><dt><span class="sect1"><a href="#idp5088232">9.5. Comando: elegir la operación </a></span></dt><dt><span class="sect1"><a href="#idp5115784">9.6. Desacoplamiento de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5134736">9.7. Adaptador</a></span></dt><dt><span class="sect1"><a href="#idp5145976">9.8. Template Method</a></span></dt><dt><span class="sect1"><a href="#idp5150296">9.9. Estrategia: elegir el algoritno en tiempo de ejecución</a></span></dt><dt><span class="sect1"><a href="#idp5156064">9.10. Cadena de Responsabilidad: intentar una secuencia de estrategias</a></span></dt><dt><span class="sect1"><a href="#idp5166728">9.11. Factorías: encapsular la creación de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5206568">9.12. Builder: creación de objetos complejos</a></span></dt><dt><span class="sect1"><a href="#idp5224808">9.13. Observador</a></span></dt><dt><span class="sect1"><a href="#idp5242824">9.14. Despachado múltiple</a></span></dt><dt><span class="sect1"><a href="#idp5256456">9.15. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5257224">9.16. Ejercicios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#C11">10. Concurrencia</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idp5268520">10.1. Motivación</a></span></dt><dt><span class="sect1"><a href="#idp5277184">10.2. Concurrencia en C++</a></span></dt><dt><span class="sect1"><a href="#idp5301632">10.3. Utilización de los hilos</a></span></dt><dt><span class="sect1"><a href="#idp5367656">10.4. Comparición de recursos limitados</a></span></dt><dt><span class="sect1"><a href="#idp5445456">10.5. Finalización de tareas</a></span></dt><dt><span class="sect1"><a href="#idp5503488">10.6. Cooperación entre hilos</a></span></dt><dt><span class="sect1"><a href="#idp5544856">10.7. Bloqueo letal</a></span></dt><dt><span class="sect1"><a href="#idp5556744">10.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5561544">10.9. Ejercicios</a></span></dt></dl></dd></dl></div></div><div class="chapter" title="8: Herencia múltiple"><div class="titlepage"><div><div><h2 class="title"><a id="C09"></a>8: Herencia múltiple</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp4905016">8.1. Perspectiva</a></span></dt><dt><span class="sect1"><a href="#idp4931136">8.2. Herencia de interfaces</a></span></dt><dt><span class="sect1"><a href="#idp4945776">8.3. Herencia de implementación</a></span></dt><dt><span class="sect1"><a href="#idp4963152">8.4. Subobjetos duplicados</a></span></dt><dt><span class="sect1"><a href="#idp4969320">8.5. Clases base virtuales</a></span></dt><dt><span class="sect1"><a href="#idp4985016">8.6. Cuestión sobre búsqueda de nombres</a></span></dt><dt><span class="sect1"><a href="#idp4992112">8.7. Evitar la MI</a></span></dt><dt><span class="sect1"><a href="#idp4993456">8.8. Extender una interface</a></span></dt><dt><span class="sect1"><a href="#idp5003216">8.9. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5004176">8.10. Ejercicios</a></span></dt></dl></div><p>
      El concepto básico de la herencia múltiple (HM) suena bastante
      simple: puede crear un nuevo tipo heredando de más una una clase
      base. La sintaxis es exactamente la que espera, y en la medida en
      que los diagramas de herencia sean simples, la HM puede ser simple
      también.
  </p><p>
    Sin embargo, la HM puede presentar un buen número de situaciones
    ambiguas y extrañas, que se cubren en este capítulo. Pero primero,
    es útil tener algo de perspectiva sobre el asunto.
  </p><div class="sect1" title="8.1. Perspectiva"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4905016"></a>8.1. Perspectiva</h2></div></div></div><p>
      Antes de C++, el lenguaje orientado a objetos más popular era
      Smaltalk. Smaltalk fue creado desde cero como un lenguaje
      orientado a objetos. A menudo se dice que es puro, mientras que a
      C++ se le llama lenguaje híbrido porque soporta múltiples
      paradigmas de programación, no sólo el paradigma orientado a
      objeto. Uno de las decisiones de diseño de Smalltalk fue que
      todas las clases tendrían solo herencia simple, empezando en una
      clase base (llamada <code class="classname">Object</code> - ese es el
      modelo para la <span class="emphasis"><em>jerarquía basada en objetos</em></span>)
      <sup>[<a id="idp4906672" href="#ftn.idp4906672" class="footnote">18</a>]</sup>
      En Smalltalk no puede crear una nueva clase sin derivar de un
      clase existente, que es la razón por la que lleva cierto tiempo
      ser productivo con Smalltalk: debe aprender la librería de
      clases antes de empezar a hacer clases nuevas. La jerarquía de
      clases de Smalltalk es por tanto un único árbol monolítico.
    </p><p>
      Las clases de Smalltalk normalmente tienen ciertas cosas en
      común, y siempre tienen algunas cosas en común (las
      características y el comportamiento de
      <code class="classname">Object</code>), de modo que no suelen aparecer
      situaciones en las que se necesite heredad de más de una clase
      base. Sin embargo, con C++ puede crear tantos árboles de
      herencia distintos como quiera. Por completitud lógica el
      lenguaje debe ser capaz de combinar más de una clase a la vez -
      por eso la necesidad de herencia múltiple.
    </p><p>
      No fue obvio, sin embargo, que los programadores requiriesen
      herencia múltiple, y había (y sigue habiendo) mucha discrepancia
      sobre si es algo esencial en C++. La HM fue añadida en cfront
      release 2.0 de AT&amp;T en 1989 y fue el primer cambio
      significativo en el lenguaje desde la versión 1.0.
      <sup>[<a id="idp4910080" href="#ftn.idp4910080" class="footnote">19</a>]</sup>
      Desde entonces, se han añadido muchas características al
      Estándar C++ (las plantillas son dignas de mención) que
      cambian la manera de pensar al programar y le dan a la HM un
      papel mucho menos importante. Puede pensar en la HM como una
      prestación menor del lenguaje que raramente está involucrada
      en las decisiones de diseño diarias.
    </p><p>
      Uno de los argumentos más convincentes para la HM involucra a
      los contenedores. Suponga que quiere crear un contenedor que
      todo el mundo pueda usar fácilmente. Una propuesta es usar
      <code class="type">void*</code> como tipo para el contenido. La propuesta de
      Smalltalk, sin embargo, es hacer un contenedor que aloja
      <code class="classname">Object</code>, dado que
      <code class="classname">Object</code> es el tipo base de la jerarquía de
      Smalltalk. Como todo en Smalltalk está derivado de
      <code class="classname">Object</code>, un contenedor que aloja
      <code class="classname">Object</code>s puede contener cualquier cosa.
    </p><p>
      Ahora considere la situación en C++. Suponga que el fabricante A
      crea una jerarquía basada-en-objetos que incluye un conjunto de
      contenedores incluye uno que desea usar llamado
      <code class="classname">Holder</code>. Después, se da cuenta de que la
      jerarquía de clases del fabricante B contiene alguna clase que
      también es importante para usted, una clase
      <code class="classname">BitImage</code>, por ejemplo, que contiene
      imágenes. La única forma de hacer que un
      <code class="classname">Holder</code> de <code class="classname">BitImage</code>
      es derivar de una nueva clase que derive también de
      <code class="classname">Object</code>, y así poder almacenarlos en el
      <code class="classname">Holder</code>, y
      <code class="classname">BitImage</code>:
    </p><div class="figure"><a id="idp4915992"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V2_13.png" align="middle" /></div></div><p class="title"><strong>Figura 8.1. </strong></p></div><br class="figure-break" /><p>
      Éste fue un motivo importante para la HM, y muchas librerías de
      clases están hechas con este model. Sin embargo, tal como se vio
      en el <a class="link" href="#C05" title="6: Las plantillas en profundidad">Capítulo 5</a>, la aportación de
      las plantillas ha cambiado la forma de crear contenedores, y por
      eso esta situación ya no es un asunto crucial en favor de la HM.
    </p><p>
      El otro motivo por el que se necesita la HM está relacionado con
      el diseño. Puede usar la HM intencionadamente para hacer un
      diseño más flexible y útil (o al menos aparentarlo). Un ejemplo
      de esto es el diseño de la librería original <code class="filename">iostream</code> (que persiste hoy día, como
      vio en el <a class="link" href="#C04" title="5: Iostreams">Capítulo 4</a>.
    </p><div class="figure"><a id="idp4927064"></a><div class="figure-contents"><div class="mediaobject" align="center"><img src="./images/V2_13.png" align="middle" /></div></div><p class="title"><strong>Figura 8.2. </strong></p></div><br class="figure-break" /><p>
      Tanto <code class="classname">iostream</code> como
      <code class="classname">ostream</code> son clases útiles por si mismas,
      pero se pueden derivar simultáneamente por una clase que combina
      sus características y comportamientos. La clase
      <code class="classname">ios</code> proporciona una combinación de las
      dos clases, y por eso en este caso la HM es un mecanismo de
      FIXME:code-factoring.
    </p><p>
      Sin importar lo que le motive a usar HM, debe saber que es más
      difícil de usar de lo que podría parecer.
    </p></div><div class="sect1" title="8.2. Herencia de interfaces"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4931136"></a>8.2. Herencia de interfaces</h2></div></div></div><p>
      Un uso no controvertido de la herencia múltiple es la herencia
      de interfaz. En C++, toda herencia lo es de implementación, dado
      que todo en una clase base, interface e implentación, pasa a
      formar parte de la clase derivada. No es posible heredar solo
      una parte de una clase (es decir, la interface únicamente). Tal
      como se explica en el [FIXME:enlace en la versión web] Capítulo
      14 del volumen 1, es posible hacer herencia privada y protegida
      para restringir el acceso a los miembros heredados desde las
      clases base cuando se usa por clientes de instancias de una
      clase derivada, pero esto no afecta a la propia clase derivada;
      esa clase sigue conteniendo todos los datos de la clase base y
      puede acceder a todos los miembros no-privados de la clase base.

    </p><p>
      La herencia de interfaces. por otra parte, sólo añade
      declaraciones de miembros a la interfaz de la clase derivada,
      algo que no está soportado directamente en C++. La técnica
      habitual para simular la herencia de interfaz en C++ es derivar
      de una clase interfaz, que es una clase que sólo contiene
      declaraciones (ni datos ni cuerpos de funciones). Estas
      declaraciones serán funciones virtuales puras, excepto el
      destructor. Aquí hay un ejemplo:
    </p><div class="example"><a id="idp4934336"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Interfaces.cpp</span>
<span class="hl slc">// Multiple interface inheritance.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Printable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Printable</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;)</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Intable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Intable</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">int</span> <span class="hl kwd">toInt</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Stringable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Stringable</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> string <span class="hl kwd">toString</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Able <span class="hl opt">:</span> <span class="hl kwc">public</span> Printable<span class="hl opt">,</span> <span class="hl kwc">public</span> Intable<span class="hl opt">,</span>
             <span class="hl kwc">public</span> Stringable <span class="hl opt">{</span>
  <span class="hl kwb">int</span> myData<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Able</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> myData <span class="hl opt">=</span> x<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> os <span class="hl opt">&lt;&lt;</span> myData<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">toInt</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> myData<span class="hl opt">; }</span>
  string <span class="hl kwd">toString</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    ostringstream os<span class="hl opt">;</span>
    os <span class="hl opt">&lt;&lt;</span> myData<span class="hl opt">;</span>
    <span class="hl kwa">return</span> os<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">testPrintable</span><span class="hl opt">(</span><span class="hl kwb">const</span> Printable<span class="hl opt">&amp;</span> p<span class="hl opt">) {</span>
  p<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span>cout<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">testIntable</span><span class="hl opt">(</span><span class="hl kwb">const</span> Intable<span class="hl opt">&amp;</span> n<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> n<span class="hl opt">.</span><span class="hl kwd">toInt</span><span class="hl opt">() +</span> <span class="hl num">1</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">testStringable</span><span class="hl opt">(</span><span class="hl kwb">const</span> Stringable<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">() +</span> <span class="hl str">&quot;th&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Able <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl num">7</span><span class="hl opt">);</span>
  <span class="hl kwd">testPrintable</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
  <span class="hl kwd">testIntable</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
  <span class="hl kwd">testStringable</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.1. C09/Interfaces.cpp</strong></p></div><br class="example-break" /><p>

      La clase <code class="classname">Able</code> «implementa»
      las interfaces <code class="classname">Printable</code>,
      <code class="classname">Intable</code>
      y <code class="classname">Stringable</code> dado que proporciona
      implementaciones para las funciones que éstas declaran. Dado
      que <code class="classname">Able</code> deriva de las tres clases, los
      objetos <code class="classname">Able</code> tienen múltiples
      relaciones «es-un». Por ejemplo, el
      objeto <code class="varname">a</code> puede actuar como un
      objeto <code class="classname">Printable</code> dado que su
      clase, <code class="classname">Able</code>, deriva públicamente
      de <code class="classname">Printable</code> y proporciona una
      implementación para <code class="methodname">print()</code>. Las
      funciones de prueba no necesitan saber el tipo más derivado de
      su parámetro; sólo necesitan un objeto que sea substituible por
      el tipo de su parámetro.
    </p><p>
      Como es habitual, una plantilla es una solución más compacta:
    </p><div class="example"><a id="idp4940944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Interfaces2.cpp</span>
<span class="hl slc">// Implicit interface inheritance via templates.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Able <span class="hl opt">{</span>
  <span class="hl kwb">int</span> myData<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Able</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> myData <span class="hl opt">=</span> x<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> os <span class="hl opt">&lt;&lt;</span> myData<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">toInt</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> myData<span class="hl opt">; }</span>
  string <span class="hl kwd">toString</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    ostringstream os<span class="hl opt">;</span>
    os <span class="hl opt">&lt;&lt;</span> myData<span class="hl opt">;</span>
    <span class="hl kwa">return</span> os<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Printable<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">testPrintable</span><span class="hl opt">(</span><span class="hl kwb">const</span> Printable<span class="hl opt">&amp;</span> p<span class="hl opt">) {</span>
  p<span class="hl opt">.</span><span class="hl kwd">print</span><span class="hl opt">(</span>cout<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Intable<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">testIntable</span><span class="hl opt">(</span><span class="hl kwb">const</span> Intable<span class="hl opt">&amp;</span> n<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> n<span class="hl opt">.</span><span class="hl kwd">toInt</span><span class="hl opt">() +</span> <span class="hl num">1</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Stringable<span class="hl opt">&gt;</span>
<span class="hl kwb">void</span> <span class="hl kwd">testStringable</span><span class="hl opt">(</span><span class="hl kwb">const</span> Stringable<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">toString</span><span class="hl opt">() +</span> <span class="hl str">&quot;th&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Able <span class="hl kwd">a</span><span class="hl opt">(</span><span class="hl num">7</span><span class="hl opt">);</span>
  <span class="hl kwd">testPrintable</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
  <span class="hl kwd">testIntable</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
  <span class="hl kwd">testStringable</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.2. C09/Interfaces2.cpp</strong></p></div><br class="example-break" /><p>
      Los
      nombres <code class="classname">Printable</code>, <code class="classname">Intable</code>
      y <code class="classname">Stringable</code> ahora no son mas que
      parámetros de la plantilla que asume la existencia de las
      operaciones indicadas en sus respectivos argumentos. En otras
      palabras, las funciones de prueba pueden aceptar argumentos de
      cualquier tipo que proporciona una definición de método con la
      signatura y tipo de retorno correctos. Hay gente que encuentra
      más cómoda la primera versión porque los nombres de tipo
      garantizan que las interfaces esperadas están
      implementadas. Otros están contentos con el hecho de que si las
      operaciones requeridas por las funciones de prueba no se
      satisfacen por los argumentos de la plantilla, el error puede
      ser capturado en la compilación. Esta segunda es una forma de
      comprobación de tipos técnicamente más débil que el primer
      enfoque (herencia), pero el efecto para el programador (y el
      programa) es el mismo. Se trata de una forma de comprobación
      débil de tipo que es aceptable para muchos de los programadores
      C++ de hoy en día.
    </p></div><div class="sect1" title="8.3. Herencia de implementación"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4945776"></a>8.3. Herencia de implementación</h2></div></div></div><p>

    </p><p>

    </p><div class="example"><a id="idp4946544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Database.h</span>
<span class="hl slc">// A prototypical resource class.</span>
<span class="hl ppc">#ifndef DATABASE_H</span>
<span class="hl ppc">#define DATABASE_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>

<span class="hl kwb">struct</span> DatabaseError <span class="hl opt">:</span> std<span class="hl opt">::</span>runtime_error <span class="hl opt">{</span>
  <span class="hl kwd">DatabaseError</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> msg<span class="hl opt">)</span>
    <span class="hl opt">:</span> std<span class="hl opt">::</span><span class="hl kwd">runtime_error</span><span class="hl opt">(</span>msg<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Database <span class="hl opt">{</span>
  std<span class="hl opt">::</span>string dbid<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Database</span><span class="hl opt">(</span><span class="hl kwb">const</span> std<span class="hl opt">::</span>string<span class="hl opt">&amp;</span> dbStr<span class="hl opt">) :</span> <span class="hl kwd">dbid</span><span class="hl opt">(</span>dbStr<span class="hl opt">) {}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Database</span><span class="hl opt">() {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">open</span><span class="hl opt">()</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>DatabaseError<span class="hl opt">) {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Connected to &quot;</span> <span class="hl opt">&lt;&lt;</span> dbid <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">close</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> dbid <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; closed&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Other database functions...</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DATABASE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 8.3. C09/Database.h</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4948976"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:UseDatabase.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Database.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Database <span class="hl kwd">db</span><span class="hl opt">(</span><span class="hl str">&quot;MyDatabase&quot;</span><span class="hl opt">);</span>
  db<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">();</span>
  <span class="hl slc">// Use other db functions...</span>
  db<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl com">/* Output:</span>
<span class="hl com">connected to MyDatabase</span>
<span class="hl com">MyDatabase closed</span>
<span class="hl com">*/</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.4. C09/UseDatabase.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4950224"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Countable.h</span>
<span class="hl slc">// A &quot;mixin&quot; class.</span>
<span class="hl ppc">#ifndef COUNTABLE_H</span>
<span class="hl ppc">#define COUNTABLE_H</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>

<span class="hl kwc">class</span> Countable <span class="hl opt">{</span>
  <span class="hl kwb">long</span> count<span class="hl opt">;</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwd">Countable</span><span class="hl opt">() {</span> count <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Countable</span><span class="hl opt">() {</span> <span class="hl kwa">assert</span><span class="hl opt">(</span>count <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">); }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">long</span> <span class="hl kwd">attach</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl opt">++</span>count<span class="hl opt">; }</span>
  <span class="hl kwb">long</span> <span class="hl kwd">detach</span><span class="hl opt">() {</span>
    <span class="hl kwa">return</span> <span class="hl opt">(--</span>count <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">)</span> ? count <span class="hl opt">: (</span><span class="hl kwa">delete this</span><span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">long</span> <span class="hl kwd">refCount</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> count<span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// COUNTABLE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 8.5. C09/Countable.h</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><div class="example"><a id="idp4952256"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:DBConnection.h</span>
<span class="hl slc">// Uses a &quot;mixin&quot; class.</span>
<span class="hl ppc">#ifndef DBCONNECTION_H</span>
<span class="hl ppc">#define DBCONNECTION_H</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Countable.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Database.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>

<span class="hl kwc">class</span> DBConnection <span class="hl opt">:</span> <span class="hl kwc">public</span> Database<span class="hl opt">,</span> <span class="hl kwc">public</span> Countable <span class="hl opt">{</span>
  <span class="hl kwd">DBConnection</span><span class="hl opt">(</span><span class="hl kwb">const</span> DBConnection<span class="hl opt">&amp;);</span> <span class="hl slc">// Disallow copy</span>
  DBConnection<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> DBConnection<span class="hl opt">&amp;);</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwd">DBConnection</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> dbStr<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>DatabaseError<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">Database</span><span class="hl opt">(</span>dbStr<span class="hl opt">) {</span> <span class="hl kwd">open</span><span class="hl opt">(); }</span>
  <span class="hl opt">~</span><span class="hl kwd">DBConnection</span><span class="hl opt">() {</span> <span class="hl kwd">close</span><span class="hl opt">(); }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> DBConnection<span class="hl opt">*</span>
  <span class="hl kwd">create</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> dbStr<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>DatabaseError<span class="hl opt">) {</span>
    DBConnection<span class="hl opt">*</span> con <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">DBConnection</span><span class="hl opt">(</span>dbStr<span class="hl opt">);</span>
    con<span class="hl opt">-&gt;</span><span class="hl kwd">attach</span><span class="hl opt">();</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>con<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> con<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Other added functionality as desired...</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DBCONNECTION_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 8.6. C09/DBConnection.h</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4955096"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:UseDatabase2.cpp</span>
<span class="hl slc">// Tests the Countable &quot;mixin&quot; class.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DBConnection.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> DBClient <span class="hl opt">{</span>
  DBConnection<span class="hl opt">*</span> db<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DBClient</span><span class="hl opt">(</span>DBConnection<span class="hl opt">*</span> dbCon<span class="hl opt">) {</span>
    db <span class="hl opt">=</span> dbCon<span class="hl opt">;</span>
    db<span class="hl opt">-&gt;</span><span class="hl kwd">attach</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">DBClient</span><span class="hl opt">() {</span> db<span class="hl opt">-&gt;</span><span class="hl kwd">detach</span><span class="hl opt">(); }</span>
  <span class="hl slc">// Other database requests using db...</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  DBConnection<span class="hl opt">*</span> db <span class="hl opt">=</span> DBConnection<span class="hl opt">::</span><span class="hl kwd">create</span><span class="hl opt">(</span><span class="hl str">&quot;MyDatabase&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
  DBClient <span class="hl kwd">c1</span><span class="hl opt">(</span>db<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
  DBClient <span class="hl kwd">c2</span><span class="hl opt">(</span>db<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">3</span><span class="hl opt">);</span>
  <span class="hl slc">// Use database, then release attach from original create</span>
  db<span class="hl opt">-&gt;</span><span class="hl kwd">detach</span><span class="hl opt">();</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.7. C09/UseDatabase2.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><div class="example"><a id="idp4957592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:DBConnection2.h</span>
<span class="hl slc">// A parameterized mixin.</span>
<span class="hl ppc">#ifndef DBCONNECTION2_H</span>
<span class="hl ppc">#define DBCONNECTION2_H</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Database.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span>string<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Counter<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> DBConnection <span class="hl opt">:</span> <span class="hl kwc">public</span> Database<span class="hl opt">,</span> <span class="hl kwc">public</span> Counter <span class="hl opt">{</span>
  <span class="hl kwd">DBConnection</span><span class="hl opt">(</span><span class="hl kwb">const</span> DBConnection<span class="hl opt">&amp;);</span> <span class="hl slc">// Disallow copy</span>
  DBConnection<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> DBConnection<span class="hl opt">&amp;);</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwd">DBConnection</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> dbStr<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>DatabaseError<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">Database</span><span class="hl opt">(</span>dbStr<span class="hl opt">) {</span> <span class="hl kwd">open</span><span class="hl opt">(); }</span>
  <span class="hl opt">~</span><span class="hl kwd">DBConnection</span><span class="hl opt">() {</span> <span class="hl kwd">close</span><span class="hl opt">(); }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> DBConnection<span class="hl opt">*</span> <span class="hl kwd">create</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> dbStr<span class="hl opt">)</span>
  <span class="hl kwa">throw</span><span class="hl opt">(</span>DatabaseError<span class="hl opt">) {</span>
    DBConnection<span class="hl opt">*</span> con <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">DBConnection</span><span class="hl opt">(</span>dbStr<span class="hl opt">);</span>
    con<span class="hl opt">-&gt;</span><span class="hl kwd">attach</span><span class="hl opt">();</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>con<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> con<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Other added functionality as desired...</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DBCONNECTION2_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 8.8. C09/DBConnection2.h</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4959992"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:UseDatabase3.cpp</span>
<span class="hl slc">// Tests a parameterized &quot;mixin&quot; class.</span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Countable.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DBConnection2.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> DBClient <span class="hl opt">{</span>
  DBConnection<span class="hl opt">&lt;</span>Countable<span class="hl opt">&gt;*</span> db<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DBClient</span><span class="hl opt">(</span>DBConnection<span class="hl opt">&lt;</span>Countable<span class="hl opt">&gt;*</span> dbCon<span class="hl opt">) {</span>
    db <span class="hl opt">=</span> dbCon<span class="hl opt">;</span>
    db<span class="hl opt">-&gt;</span><span class="hl kwd">attach</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">DBClient</span><span class="hl opt">() {</span> db<span class="hl opt">-&gt;</span><span class="hl kwd">detach</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  DBConnection<span class="hl opt">&lt;</span>Countable<span class="hl opt">&gt;*</span> db <span class="hl opt">=</span>
    DBConnection<span class="hl opt">&lt;</span>Countable<span class="hl opt">&gt;::</span><span class="hl kwd">create</span><span class="hl opt">(</span><span class="hl str">&quot;MyDatabase&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
  DBClient <span class="hl kwd">c1</span><span class="hl opt">(</span>db<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
  DBClient <span class="hl kwd">c2</span><span class="hl opt">(</span>db<span class="hl opt">);</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">3</span><span class="hl opt">);</span>
  db<span class="hl opt">-&gt;</span><span class="hl kwd">detach</span><span class="hl opt">();</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>db<span class="hl opt">-&gt;</span><span class="hl kwd">refCount</span><span class="hl opt">() ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.9. C09/UseDatabase3.cpp</strong></p></div><br class="example-break" /><p>

    </p><pre class="programlisting">
<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> Mixin1<span class="hl opt">,</span> <span class="hl kwc">class</span> Mixin2<span class="hl opt">,</span> ?? <span class="hl opt">,</span> <span class="hl kwc">class</span> MixinK<span class="hl opt">&gt;</span>
<span class="hl kwc">class</span> Subject <span class="hl opt">:</span> <span class="hl kwc">public</span> Mixin1<span class="hl opt">,</span>
                <span class="hl kwc">public</span> Mixin2<span class="hl opt">,</span>
                ??
                <span class="hl kwc">public</span> MixinK <span class="hl opt">{</span>??<span class="hl opt">};</span>
</pre></div><div class="sect1" title="8.4. Subobjetos duplicados"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4963152"></a>8.4. Subobjetos duplicados</h2></div></div></div><p>

    </p><div class="example"><a id="idp4963664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Offset.cpp</span>
<span class="hl slc">// Illustrates layout of subobjects with MI.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> A <span class="hl opt">{</span> <span class="hl kwb">int</span> x<span class="hl opt">; };</span>
<span class="hl kwc">class</span> B <span class="hl opt">{</span> <span class="hl kwb">int</span> y<span class="hl opt">; };</span>
<span class="hl kwc">class</span> C <span class="hl opt">:</span> <span class="hl kwc">public</span> A<span class="hl opt">,</span> <span class="hl kwc">public</span> B <span class="hl opt">{</span> <span class="hl kwb">int</span> z<span class="hl opt">; };</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(A) == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>A<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(B) == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>B<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;sizeof(C) == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span><span class="hl opt">(</span>C<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  C c<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&amp;c == &quot;</span> <span class="hl opt">&lt;&lt; &amp;</span>c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  A<span class="hl opt">*</span> ap <span class="hl opt">= &amp;</span>c<span class="hl opt">;</span>
  B<span class="hl opt">*</span> bp <span class="hl opt">= &amp;</span>c<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ap == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">void</span><span class="hl opt">*&gt;(</span>ap<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;bp == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">void</span><span class="hl opt">*&gt;(</span>bp<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  C<span class="hl opt">*</span> cp <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span>C<span class="hl opt">*&gt;(</span>bp<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;cp == &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">void</span><span class="hl opt">*&gt;(</span>cp<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;bp == cp? &quot;</span> <span class="hl opt">&lt;&lt;</span> boolalpha <span class="hl opt">&lt;&lt; (</span>bp <span class="hl opt">==</span> cp<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cp <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  bp <span class="hl opt">=</span> cp<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> bp <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>
<span class="hl com">/* Output:</span>
<span class="hl com">sizeof(A) == 4</span>
<span class="hl com">sizeof(B) == 4</span>
<span class="hl com">sizeof(C) == 12</span>
<span class="hl com">&amp;c == 1245052</span>
<span class="hl com">ap == 1245052</span>
<span class="hl com">bp == 1245056</span>
<span class="hl com">cp == 1245052</span>
<span class="hl com">bp == cp? true</span>
<span class="hl com">0</span>
<span class="hl com">*/</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.10. C09/Offset.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4966664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Duplicate.cpp</span>
<span class="hl slc">// Shows duplicate subobjects.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Top</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span> x <span class="hl opt">=</span> n<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">public</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> y <span class="hl opt">=</span> n<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">public</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> z<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> z <span class="hl opt">=</span> n<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{</span>
  <span class="hl kwb">int</span> w<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Bottom</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">int</span> j<span class="hl opt">,</span> <span class="hl kwb">int</span> k<span class="hl opt">,</span> <span class="hl kwb">int</span> m<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">Left</span><span class="hl opt">(</span>i<span class="hl opt">,</span> k<span class="hl opt">),</span> <span class="hl kwd">Right</span><span class="hl opt">(</span>j<span class="hl opt">,</span> k<span class="hl opt">) {</span> w <span class="hl opt">=</span> m<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span> <span class="hl slc">// 20</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.11. C09/Duplicate.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="8.5. Clases base virtuales"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4969320"></a>8.5. Clases base virtuales</h2></div></div></div><p>

    </p><div class="example"><a id="idp4969832"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:VirtualBase.cpp</span>
<span class="hl slc">// Shows a shared subobject via a virtual base.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Top</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span> x <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Top</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Top<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">.</span>x<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> y <span class="hl opt">=</span> n<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> z<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> z <span class="hl opt">=</span> n<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{</span>
  <span class="hl kwb">int</span> w<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Bottom</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">int</span> j<span class="hl opt">,</span> <span class="hl kwb">int</span> k<span class="hl opt">,</span> <span class="hl kwb">int</span> m<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>i<span class="hl opt">),</span> <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> j<span class="hl opt">),</span> <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> k<span class="hl opt">) {</span> w <span class="hl opt">=</span> m<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Bottom<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>x <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>y <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>z
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>w<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">sizeof</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">void</span><span class="hl opt">*&gt;(&amp;</span>b<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  Top<span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span>Top<span class="hl opt">*&gt;(&amp;</span>b<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt; *</span>p <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">void</span><span class="hl opt">*&gt;(</span>p<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">dynamic_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">void</span><span class="hl opt">*&gt;(</span>p<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.12. C09/VirtualBase.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><pre class="screen">
36
1,2,3,4
1245032
1
1245060
1245032
</pre><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4974592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:VirtualBase2.cpp</span>
<span class="hl slc">// How NOT to implement operator&lt;&lt;.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Top</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span> x <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Top</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Top<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">.</span>x<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> y <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Left<span class="hl opt">&amp;</span> l<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Top<span class="hl opt">&amp;&gt;(</span>l<span class="hl opt">) &lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> l<span class="hl opt">.</span>y<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> z<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> z <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Right<span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Top<span class="hl opt">&amp;&gt;(</span>r<span class="hl opt">) &lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> r<span class="hl opt">.</span>z<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{</span>
  <span class="hl kwb">int</span> w<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Bottom</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">int</span> j<span class="hl opt">,</span> <span class="hl kwb">int</span> k<span class="hl opt">,</span> <span class="hl kwb">int</span> m<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>i<span class="hl opt">),</span> <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> j<span class="hl opt">),</span> <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> k<span class="hl opt">) {</span> w <span class="hl opt">=</span> m<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Bottom<span class="hl opt">&amp;</span> b<span class="hl opt">){</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Left<span class="hl opt">&amp;&gt;(</span>b<span class="hl opt">)</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Right<span class="hl opt">&amp;&gt;(</span>b<span class="hl opt">)</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>w<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 1,2,1,3,4</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.13. C09/VirtualBase2.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4976880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:VirtualBase3.cpp</span>
<span class="hl slc">// A correct stream inserter.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Top</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span> x <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Top</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Top<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">.</span>x<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> y<span class="hl opt">;</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">specialPrint</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl slc">// Only print Left's part</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span><span class="hl opt">&lt;&lt;</span> y<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> y <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Left<span class="hl opt">&amp;</span> l<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Top<span class="hl opt">&amp;&gt;(</span>l<span class="hl opt">) &lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> l<span class="hl opt">.</span>y<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
  <span class="hl kwb">int</span> z<span class="hl opt">;</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">specialPrint</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl slc">// Only print Right's part</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span><span class="hl opt">&lt;&lt;</span> z<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> n<span class="hl opt">) :</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>m<span class="hl opt">) {</span> z <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Right<span class="hl opt">&amp;</span> r<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Top<span class="hl opt">&amp;&gt;(</span>r<span class="hl opt">) &lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> r<span class="hl opt">.</span>z<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{</span>
  <span class="hl kwb">int</span> w<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Bottom</span><span class="hl opt">(</span><span class="hl kwb">int</span> i<span class="hl opt">,</span> <span class="hl kwb">int</span> j<span class="hl opt">,</span> <span class="hl kwb">int</span> k<span class="hl opt">,</span> <span class="hl kwb">int</span> m<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">Top</span><span class="hl opt">(</span>i<span class="hl opt">),</span> <span class="hl kwd">Left</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> j<span class="hl opt">),</span> <span class="hl kwd">Right</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> k<span class="hl opt">) {</span> w <span class="hl opt">=</span> m<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Bottom<span class="hl opt">&amp;</span> b<span class="hl opt">){</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl kwa">static_cast</span><span class="hl opt">&lt;</span><span class="hl kwb">const</span> Top<span class="hl opt">&amp;&gt;(</span>b<span class="hl opt">);</span>
    b<span class="hl opt">.</span>Left<span class="hl opt">::</span><span class="hl kwd">specialPrint</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
    b<span class="hl opt">.</span>Right<span class="hl opt">::</span><span class="hl kwd">specialPrint</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">','</span> <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>w<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> b <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>  <span class="hl slc">// 1,2,3,4</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.14. C09/VirtualBase3.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4981288"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:VirtInit.cpp</span>
<span class="hl slc">// Illustrates initialization order with virtual bases.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> M <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">M</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;M &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> A <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in A&quot;</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;A &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">A</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> B <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in B&quot;</span><span class="hl opt">)  {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;B &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">B</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> C <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in C&quot;</span><span class="hl opt">)  {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;C &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">C</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> D <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in D&quot;</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;D &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">D</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> E <span class="hl opt">:</span> <span class="hl kwc">public</span> A<span class="hl opt">,</span> <span class="hl kwc">virtual public</span> B<span class="hl opt">,</span> <span class="hl kwc">virtual public</span> C <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">E</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl str">&quot;from E&quot;</span><span class="hl opt">),</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl str">&quot;from E&quot;</span><span class="hl opt">),</span>
  <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl str">&quot;from E&quot;</span><span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in E&quot;</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;E &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> F <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> B<span class="hl opt">,</span> <span class="hl kwc">virtual public</span> C<span class="hl opt">,</span> <span class="hl kwc">public</span> D <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">F</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl str">&quot;from F&quot;</span><span class="hl opt">),</span> <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl str">&quot;from F&quot;</span><span class="hl opt">),</span>
  <span class="hl kwd">D</span><span class="hl opt">(</span><span class="hl str">&quot;from F&quot;</span><span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in F&quot;</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;F &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> G <span class="hl opt">:</span> <span class="hl kwc">public</span> E<span class="hl opt">,</span> <span class="hl kwc">public</span> F <span class="hl opt">{</span>
  M m<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">G</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl str">&quot;from G&quot;</span><span class="hl opt">),</span> <span class="hl kwd">C</span><span class="hl opt">(</span><span class="hl str">&quot;from G&quot;</span><span class="hl opt">),</span>
  <span class="hl kwd">E</span><span class="hl opt">(</span><span class="hl str">&quot;from G&quot;</span><span class="hl opt">),</span>  <span class="hl kwd">F</span><span class="hl opt">(</span><span class="hl str">&quot;from G&quot;</span><span class="hl opt">),</span> <span class="hl kwd">m</span><span class="hl opt">(</span><span class="hl str">&quot;in G&quot;</span><span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;G &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  G <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl str">&quot;from main&quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.15. C09/VirtInit.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><pre class="screen">
M in B
B from G
M in C
C from G
M in A
A from E
M in E
E from G
M in D
D from F
M in F
F from G
M in G
G from main
</pre><p>

    </p></div><div class="sect1" title="8.6. Cuestión sobre búsqueda de nombres"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4985016"></a>8.6. Cuestión sobre búsqueda de nombres</h2></div></div></div><p>

    </p><div class="example"><a id="idp4985608"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:AmbiguousName.cpp {-xo}</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Top</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom b<span class="hl opt">;</span>
  b<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Error here</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.16. C09/AmbiguousName.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4986944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:BreakTie.cpp</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Top</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwa">using</span> Left<span class="hl opt">::</span>f<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom b<span class="hl opt">;</span>
  b<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Calls Left::f()</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.17. C09/BreakTie.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><div class="example"><a id="idp4988496"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Dominance.cpp</span>

<span class="hl kwc">class</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Top</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Left <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Right <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> Top <span class="hl opt">{};</span>

<span class="hl kwc">class</span> Bottom <span class="hl opt">:</span> <span class="hl kwc">public</span> Left<span class="hl opt">,</span> <span class="hl kwc">public</span> Right <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Bottom b<span class="hl opt">;</span>
  b<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Calls Left::f()</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.18. C09/Dominance.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><div class="example"><a id="idp4990024"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Dominance2.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> A <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">A</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;A::f</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> B <span class="hl opt">:</span> <span class="hl kwc">virtual public</span> A <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;B::f</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> C <span class="hl opt">:</span> <span class="hl kwc">public</span> B <span class="hl opt">{};</span>
<span class="hl kwc">class</span> D <span class="hl opt">:</span> <span class="hl kwc">public</span> C<span class="hl opt">,</span> <span class="hl kwc">virtual public</span> A <span class="hl opt">{};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  B<span class="hl opt">*</span> p <span class="hl opt">=</span> <span class="hl kwa">new</span> D<span class="hl opt">;</span>
  p<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">();</span> <span class="hl slc">// Calls B::f()</span>
  <span class="hl kwa">delete</span> p<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.19. C09/Dominance2.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p></div><div class="sect1" title="8.7. Evitar la MI"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4992112"></a>8.7. Evitar la MI</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="8.8. Extender una interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp4993456"></a>8.8. Extender una interface</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4994352"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Vendor.h</span>
<span class="hl slc">// Vendor-supplied class header</span>
<span class="hl slc">// You only get this &amp; the compiled Vendor.obj.</span>
<span class="hl ppc">#ifndef VENDOR_H</span>
<span class="hl ppc">#define VENDOR_H</span>

<span class="hl kwc">class</span> Vendor <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">v</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span> <span class="hl slc">// Might want this to be virtual...</span>
  <span class="hl opt">~</span><span class="hl kwd">Vendor</span><span class="hl opt">();</span> <span class="hl slc">// Oops! Not virtual!</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Vendor1 <span class="hl opt">:</span> <span class="hl kwc">public</span> Vendor <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">v</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span><span class="hl opt">;</span>
  <span class="hl opt">~</span><span class="hl kwd">Vendor1</span><span class="hl opt">();</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl kwb">const</span> Vendor<span class="hl opt">&amp;);</span>
<span class="hl kwb">void</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwb">const</span> Vendor<span class="hl opt">&amp;);</span>
<span class="hl slc">// Etc.</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// VENDOR_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 8.20. C09/Vendor.h</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp4996336"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Vendor.cpp {O}</span>
<span class="hl slc">// Assume this is compiled and unavailable to you.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Vendor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">void</span> Vendor<span class="hl opt">::</span><span class="hl kwd">v</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vendor::v()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">void</span> Vendor<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vendor::f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

Vendor<span class="hl opt">::~</span><span class="hl kwd">Vendor</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Vendor()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">void</span> Vendor1<span class="hl opt">::</span><span class="hl kwd">v</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vendor1::v()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">void</span> Vendor1<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Vendor1::f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

Vendor1<span class="hl opt">::~</span><span class="hl kwd">Vendor1</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Vendor1()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>

<span class="hl kwb">void</span> <span class="hl kwd">A</span><span class="hl opt">(</span><span class="hl kwb">const</span> Vendor<span class="hl opt">&amp;</span> v<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  v<span class="hl opt">.</span><span class="hl kwd">v</span><span class="hl opt">();</span>
  v<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">B</span><span class="hl opt">(</span><span class="hl kwb">const</span> Vendor<span class="hl opt">&amp;</span> v<span class="hl opt">) {</span>
  <span class="hl slc">// ...</span>
  v<span class="hl opt">.</span><span class="hl kwd">v</span><span class="hl opt">();</span>
  v<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl slc">// ...</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.21. C09/Vendor.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp4998968"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C09:Paste.cpp</span>
<span class="hl slc">//{L} Vendor</span>
<span class="hl slc">// Fixing a mess with MI.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Vendor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> MyBase <span class="hl opt">{</span> <span class="hl slc">// Repair Vendor interface</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">v</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl slc">// New interface function:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">MyBase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~MyBase()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Paste1 <span class="hl opt">:</span> <span class="hl kwc">public</span> MyBase<span class="hl opt">,</span> <span class="hl kwc">public</span> Vendor1 <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">v</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Paste1::v()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    Vendor1<span class="hl opt">::</span><span class="hl kwd">v</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Paste1::f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    Vendor1<span class="hl opt">::</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Paste1::g()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Paste1</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Paste1()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Paste1<span class="hl opt">&amp;</span> p1p <span class="hl opt">= *</span><span class="hl kwa">new</span> Paste1<span class="hl opt">;</span>
  MyBase<span class="hl opt">&amp;</span> mp <span class="hl opt">=</span> p1p<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;calling f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  mp<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>  <span class="hl slc">// Right behavior</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;calling g()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  mp<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">();</span> <span class="hl slc">// New behavior</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;calling A(p1p)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">A</span><span class="hl opt">(</span>p1p<span class="hl opt">);</span> <span class="hl slc">// Same old behavior</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;calling B(p1p)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">B</span><span class="hl opt">(</span>p1p<span class="hl opt">);</span>  <span class="hl slc">// Same old behavior</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;delete mp&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl slc">// Deleting a reference to a heap object:</span>
  <span class="hl kwa">delete</span> <span class="hl opt">&amp;</span>mp<span class="hl opt">;</span> <span class="hl slc">// Right behavior</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 8.22. C09/Paste.cpp</strong></p></div><br class="example-break" /><p>

    </p><pre class="programlisting">
MyBase<span class="hl opt">*</span> mp <span class="hl opt">=</span> p1p<span class="hl opt">;</span> <span class="hl slc">// Upcast</span>
</pre><p>

    </p><pre class="screen">
calling f()
Paste1::f()
Vendor1::f()
calling g()
Paste1::g()
calling A(p1p)
Paste1::v()
Vendor1::v()
Vendor::f()
calling B(p1p)
Paste1::v()
Vendor1::v()
Vendor::f()
delete mp
~Paste1()
~Vendor1()
~Vendor()
~MyBase()
</pre><p>

    </p><p>

    </p></div><div class="sect1" title="8.9. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5003216"></a>8.9. Resumen</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="8.10. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5004176"></a>8.10. Ejercicios</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idp4906672" href="#idp4906672" class="para">18</a>] </sup>
	  
	  Esto también ocurre en Java, y en otros lenguajes orientados
	  a objetos.
	</p></div><div class="footnote"><p><sup>[<a id="ftn.idp4910080" href="#idp4910080" class="para">19</a>] </sup>
	  
	  Son números de versión internos de AT&amp;T.
	</p></div></div></div><div class="chapter" title="9: Patrones de Diseño"><div class="titlepage"><div><div><h2 class="title"><a id="C10"></a>9: Patrones de Diseño</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp5011344">9.1. El Concepto de Patrón </a></span></dt><dt><span class="sect1"><a href="#idp5022176">9.2. Clasificación de los patrones</a></span></dt><dt><span class="sect1"><a href="#idp5031576">9.3.  Simplificación de modismos</a></span></dt><dt><span class="sect1"><a href="#idp5041816">9.4. Singleton</a></span></dt><dt><span class="sect1"><a href="#idp5088232">9.5. Comando: elegir la operación </a></span></dt><dt><span class="sect1"><a href="#idp5115784">9.6. Desacoplamiento de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5134736">9.7. Adaptador</a></span></dt><dt><span class="sect1"><a href="#idp5145976">9.8. Template Method</a></span></dt><dt><span class="sect1"><a href="#idp5150296">9.9. Estrategia: elegir el algoritno en tiempo de ejecución</a></span></dt><dt><span class="sect1"><a href="#idp5156064">9.10. Cadena de Responsabilidad: intentar una secuencia de estrategias</a></span></dt><dt><span class="sect1"><a href="#idp5166728">9.11. Factorías: encapsular la creación de objetos</a></span></dt><dt><span class="sect1"><a href="#idp5206568">9.12. Builder: creación de objetos complejos</a></span></dt><dt><span class="sect1"><a href="#idp5224808">9.13. Observador</a></span></dt><dt><span class="sect1"><a href="#idp5242824">9.14. Despachado múltiple</a></span></dt><dt><span class="sect1"><a href="#idp5256456">9.15. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5257224">9.16. Ejercicios</a></span></dt></dl></div><p>
	"...describa un problema que sucede una y otra vez en nuestro
entorno, y luego describa el núcleo de la solución a ese problema, de
tal forma que pueda utilizar esa solución un millón de veces más, sin
siquiera hacerlo dos veces de la misma manera." - Christopher
Alexander
  </p><p>
	Este capítulo presenta el importante y aún no tradicional enfoque
de los patrones para el diseño de programas.
  </p><p>
	El avance reciente más importante en el diseño orientado a objetos
es probablemente el movimiento de los patrones de diseño, inicialmente
narrado en "Design Patterns", por Gamma, Helm, Johnson y Vlissides
(Addison Wesley, 1995), que suele llamarse el libro de la "Banda de
los Cuatro" (en inglés, GoF: Gang of Four). El GoF muestra 23
soluciones para clases de problemas muy particulares. En este capítulo
se discuten los conceptos básicos de los patrones de diseño y se
ofrecen ejemplos de código que ilustran los patrones escogidos. Esto
debería abrirle el apetito para leer más acerca de los patrones de
diseño, una fuente de lo que se ha convertido en vocabulario esencial,
casi obligatorio, para la programación orientada a objetos.

  </p><div class="sect1" title="9.1. El Concepto de Patrón"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5011344"></a>9.1. El Concepto de Patrón </h2></div></div></div><p>
	  En principio, puede pensar en un patrón como una manera
especialmente inteligente e intuitiva de resolver una clase de
problema en particular. Parece que un equipo de personas han estudiado
todos los ángulos de un problema y han dado con la solución más
general y flexible para ese tipo de problema. Este problema podría ser
uno que usted ha visto y resuelto antes, pero su solución
probablemente no tenía la clase de completitud que verá plasmada en un
patrón.  Es más, el patrón existe independientemente de cualquier
implementación particular y puede implementarse de numerosas maneras.
    </p><p>
Aunque se llaman "patrones de diseño", en realidad no están ligados al
ámbito del diseño. Un patrón parece apartarse de la manera tradicional
de pensar sobre el análisis, diseño e implementación. En cambio, un
patrón abarca una idea completa dentro de un programa, y por lo tanto
puede también abarcar las fases de análisis y diseño de alto
nivel. Sin embargo, dado que un patrón a menudo tiene una
implementación directa en código, podría no mostrarse hasta el diseño
de bajo nivel o la implementación (y usted no se daría cuenta de que
necesita ese patrón hasta que llegase a esas fases).
    </p><p>
	  El concepto básico de un patrón puede verse también como el
concepto básico del diseño de programas en general: añadir capas de
abstracción. Cuando se abstrae algo, se están aislando detalles
concretos, y una de las razones de mayor peso para hacerlo es separar
las cosas que cambian de las cosas que no.  Otra forma de verlo es que
una vez que encuentra una parte de su programa que es susceptible de
cambiar, querrá prevenir que esos cambios propagen efectos colaterales
por su código. Si lo consigue, su código no sólo será más fácil de
leer y comprender, también será más fácil de mantener, lo que a la
larga, siempre redunda en menores costes.
    </p><p>
	  La parte más difícil de desarrollar un diseño elegante y
mantenible a menudo es descubrir lo que llamamos el "vector de
cambio". (Aquí "vector" se refiere al mayor gradiente tal y como se
entiende en ciencias, no como la clase contenedora.) Esto implica
encontrar la cosa más importante que cambia en su sistema o, dicho de
otra forma, descubrir dónde están sus mayores costes.  Una vez que
descubra el vector de cambios, tendrá el punto focal alrededor del
cual estructurar su diseño.
    </p><p>
	  Por lo tanto, el objetivo de los patrones de diseño es
encapsular el cambio. Si lo enfoca de esta forma, ya habrá visto
algunos patrones de diseño en este libro. Por ejemplo, la herencia
podría verse como un patrón de diseño (aunque uno implementado por el
compilador). Expresa diferencias de comportamiento (eso es lo que
cambia) en objetos que tienen todos la misma interfaz (esto es lo que
no cambia). La composición también podría considerarse un patrón, ya
que puede cambiar dinámica o estáticamente los objetos que implementan
su clase, y por lo tanto, la forma en la que funciona la
clase. Normalmente, sin embargo, las características que los lenguajes
de programación soportan directamente no se han clasificado como
patrones de diseño.
    </p><p>
	  También ha visto ya otro patrón que aparece en el GoF: el
«iterador». Esta es la herramienta fundamental usada en
el diseño del STL, descrito en capítulos anteriores. El iterador
esconde la implementación concreta del contenedor a medida que se
avanza y se seleccionan los elementos uno a uno. Los iteradores le
ayudan a escribir código genérico que realiza una operación en todos
los elementos de un rango sin tener en cuenta el contenedor que
contiene el rango. Por lo tanto, cualquier contenedor que pueda
producir iteradores puede utilizar su código genérico.
    </p><div class="sect2" title="9.1.1. La composición es preferible a la herencia"><div class="titlepage"><div><div><h3 class="title"><a id="idp5018976"></a>9.1.1. La composición es preferible a la herencia</h3></div></div></div><p>
		La contribución más importante del GoF puede que no sea un
patrón, si no una máxima que introducen en el Capítulo
1: «Prefiera siempre la composición de objetos antes que la
herencia de clases». Entender la herecia y el polimorfismo es
un reto tal, que podría empezar a otorgarle una importancia excesiva a
estas técnicas. Se ven muchos diseños excesivamente complicados (el
nuestro incluído) como resultado de ser demasiado indulgentes con la
herencia - por ejemplo, muchos diseños de herencia múltiple se
desarrollan por insistir en usar la herencia en todas partes.
      </p><p>
		Una de las directrices en la «Programación
Extrema» es "haga la cosa más simple que pueda funcionar". Un
diseño que parece requerir de herencia puede a menudo simplificarse
drásticamente usando una composición en su lugar, y descubrirá también
que el resultado es más flexible, como comprenderá al estudiar algunos
de los patrones de diseño de este capítulo. Por lo tanto, al
considerar un diseño, pregúntese: ¿Podría ser más simple si usara
Composición? ¿De verdad necesito Herencia aquí, y qué me aporta?
      </p></div></div><div class="sect1" title="9.2. Clasificación de los patrones"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5022176"></a>9.2. Clasificación de los patrones</h2></div></div></div><p>
	  El GoF describe 23 patrones, clasificados según tres propósitos
FIXME: (all of which revolve around the particular aspect that can
vary):
	</p><p>
	  1. Creacional: Cómo se puede crear un objeto. Habitualmente esto
incluye aislar los detalles de la creación del objeto, de forma que su
código no dependa de los tipos de objeto que hay y por lo tantok, no
tenga que cambiarlo cuando añada un nuevo tipo de objeto. Este
capítulo presenta los patrones Singleton, Fábricas (Factories), y
Constructor (Builder).
    </p><p>
	  2. Estructural: Esto afecta a la manera en que los objetos se
conectan con otros objetos para asegurar que los cambios del sistema
no requieren cambiar esas conexiones. Los patrones estructurales
suelen imponerlos las restricciones del proyecto. En este capítulo
verá el Proxy y el Adaptador (Adapter).
    </p><p>
	  3. Comportacional: Objetos que manejan tipos particulares de
acciones dentro de un programa. Éstos encapsulan procesos que quiere
que se ejecuten, como interpretar un lenguaje, completar una petición,
moverse a través de una secuencia (como en un iterador) o implementar
un algoritmo. Este capítulo contiene ejemplos de <code class="keyword">Comando</code>
(Command), Método Plantilla (Template Method), Estado (State),
Estrategia (Strategy), Cadena de Responsabilidad (Chain of
Responsibility), Observador (Observer), FIXME: Despachador Múltiple
(Multiple Dispatching) y Visitador (Visitor).
    </p><p>
	El GoF incluye una sección sobre cada uno de los 23 patrones,
junto con uno o más ejemplos de cada uno, típicamente en C++ aunque a
veces en SmallTalk. Este libro no repite los detalles de los patrones
mostrados en GoF, ya que aquél FIXME: "stands on its own" y debería
estudiarse aparte. La descripción y los ejemplos que se dan aquí
intentan darle una visión de los patrones, de forma que pueda hacerse
una idea de lo que tratan y de porqué son importantes.
    </p><div class="sect2" title="9.2.1. Características, modismos patrones"><div class="titlepage"><div><div><h3 class="title"><a id="idp5027360"></a>9.2.1. Características, modismos patrones </h3></div></div></div><p>
	El trabajo va más allá de lo que se muestra en el libro del
GoF. Desde su publicación, hay más patrones y un proceso más refinado
para definir patrones de diseño.[135] Esto es importante porque no es
fácil identificar nuevos patrones ni describirlos adecuadamente. Hay
mucha confusión en la literatura popular acerca de qué es un patrón de
diseño, por ejemplo. Los patrones no son triviales, ni están
representados por características implementadas en un lenguaje de
programación. Los constructores y destructores, por ejemplo, podrían
llamarse el patrón de inicialización garantizada y el de limpieza. Hay
constructores importantes y esenciales, pero son características del
lenguaje rutinarias, y no son lo suficientemente ricas como para ser
consideradas patrones.
      </p><p>
	Otro FIXME: (no-ejemplo? anti-ejemplo?) viene de varias formas de
agregación. La agregación es un principio completamente fundamental en
la programación orientada a objetos: se hacen objetos a partir de
otros objetos. Aunque a veces, esta idea se clasifica erróneamente
como un patrón. Esto no es bueno, porque contamina la idea del patrón
de diseño, y sugiere que cualquier cosa que le sorprenda la primera
vez que la ve debería convertirse en un patrón de diseño.
      </p><p>
	El lenguaje Java da otro ejemplo equivocado: Los diseñadores de la
especificación de JavaBeans decidieron referirse a la notación get/set
como un patrón de diseño (por ejemplo, getInfo() devuelve una
propiedad Info y setInfo() la modifica). Esto es únicamente una
convención de nombrado, y de ninguna manera constituye un patrón de
diseño.
      </p></div></div><div class="sect1" title="9.3. Simplificación de modismos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5031576"></a>9.3.  Simplificación de modismos</h2></div></div></div><p>
	Antes de adentrarnos en técnicas más complejas, es útil echar un
vistazo a algunos métodos básicos de mantener el código simple y
sencillo.
    </p><div class="sect2" title="9.3.1. Mensajero"><div class="titlepage"><div><div><h3 class="title"><a id="idp5032464"></a>9.3.1.  Mensajero</h3></div></div></div><p>
	El más trivial es el Mensajero (Messenger), [136] que empaqueta
información en un objeto que se envia, en lugar de ir enviando todas
las piezas independientemente.  Nótese que sin el Mensajero, el código
para la función translate() sería mucho más confuso:
      </p><div class="example"><a id="idp5033528"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:MessengerDemo.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Point <span class="hl opt">{</span> <span class="hl slc">// A messenger</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> x<span class="hl opt">,</span> y<span class="hl opt">,</span> z<span class="hl opt">;</span> <span class="hl slc">// Since it's just a carrier</span>
  <span class="hl kwd">Point</span><span class="hl opt">(</span><span class="hl kwb">int</span> xi<span class="hl opt">,</span> <span class="hl kwb">int</span> yi<span class="hl opt">,</span> <span class="hl kwb">int</span> zi<span class="hl opt">) :</span> <span class="hl kwd">x</span><span class="hl opt">(</span>xi<span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span>yi<span class="hl opt">),</span> <span class="hl kwd">z</span><span class="hl opt">(</span>zi<span class="hl opt">) {}</span>
  <span class="hl kwd">Point</span><span class="hl opt">(</span><span class="hl kwb">const</span> Point<span class="hl opt">&amp;</span> p<span class="hl opt">) :</span>  <span class="hl kwd">x</span><span class="hl opt">(</span>p<span class="hl opt">.</span>x<span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span>p<span class="hl opt">.</span>y<span class="hl opt">),</span> <span class="hl kwd">z</span><span class="hl opt">(</span>p<span class="hl opt">.</span>z<span class="hl opt">) {}</span>
  Point<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Point<span class="hl opt">&amp;</span> rhs<span class="hl opt">) {</span>
    x <span class="hl opt">=</span> rhs<span class="hl opt">.</span>x<span class="hl opt">;</span>
    y <span class="hl opt">=</span> rhs<span class="hl opt">.</span>y<span class="hl opt">;</span>
    z <span class="hl opt">=</span> rhs<span class="hl opt">.</span>z<span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Point<span class="hl opt">&amp;</span> p<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;x=&quot;</span> <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">.</span>x <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; y=&quot;</span> <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">.</span>y
              <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; z=&quot;</span> <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">.</span>z<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Vector <span class="hl opt">{</span> <span class="hl slc">// Mathematical vector</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">int</span> magnitude<span class="hl opt">,</span> direction<span class="hl opt">;</span>
  <span class="hl kwd">Vector</span><span class="hl opt">(</span><span class="hl kwb">int</span> m<span class="hl opt">,</span> <span class="hl kwb">int</span> d<span class="hl opt">) :</span> <span class="hl kwd">magnitude</span><span class="hl opt">(</span>m<span class="hl opt">),</span> <span class="hl kwd">direction</span><span class="hl opt">(</span>d<span class="hl opt">) {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Space <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> Point <span class="hl kwd">translate</span><span class="hl opt">(</span>Point p<span class="hl opt">,</span> Vector v<span class="hl opt">) {</span>
    <span class="hl slc">// Copy-constructor prevents modifying the original.</span>
    <span class="hl slc">// A dummy calculation:</span>
    p<span class="hl opt">.</span>x <span class="hl opt">+=</span> v<span class="hl opt">.</span>magnitude <span class="hl opt">+</span> v<span class="hl opt">.</span>direction<span class="hl opt">;</span>
    p<span class="hl opt">.</span>y <span class="hl opt">+=</span> v<span class="hl opt">.</span>magnitude <span class="hl opt">+</span> v<span class="hl opt">.</span>direction<span class="hl opt">;</span>
    p<span class="hl opt">.</span>z <span class="hl opt">+=</span> v<span class="hl opt">.</span>magnitude <span class="hl opt">+</span> v<span class="hl opt">.</span>direction<span class="hl opt">;</span>
    <span class="hl kwa">return</span> p<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Point <span class="hl kwd">p1</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span>
  Point p2 <span class="hl opt">=</span> Space<span class="hl opt">::</span><span class="hl kwd">translate</span><span class="hl opt">(</span>p1<span class="hl opt">,</span> <span class="hl kwd">Vector</span><span class="hl opt">(</span><span class="hl num">11</span><span class="hl opt">,</span> <span class="hl num">47</span><span class="hl opt">));</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;p1: &quot;</span> <span class="hl opt">&lt;&lt;</span> p1 <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; p2: &quot;</span> <span class="hl opt">&lt;&lt;</span> p2 <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.1. C10/MessengerDemo.cpp</strong></p></div><br class="example-break" /><p>
	El código ha sido simplificado para evitar distracciones.
      </p><p>
	Como el objetivo del Mensajero es simplemente llevar datos, dichos
datos se hacen públicos para facilitar el acceso. Sin embargo, podría
tener razones para hacer estos campos privados.
      </p></div><div class="sect2" title="9.3.2. Parámetro de Recolección"><div class="titlepage"><div><div><h3 class="title"><a id="idp5037520"></a>9.3.2. Parámetro de Recolección</h3></div></div></div><p>
	El hermano mayor del Mensajero es el parámetro de recolección,
cuyo trabajo es capturar información sobre la función a la que es
pasado. Generalmente se usa cuando el parámetro de recolección se pasa
a múltiples funciones; es como una abeja recogiendo polen.
      </p><p>
	Un contenedor (container) es un parámetro de recolección
especialmente útil, ya que está configurado para añadir objetos
dinámicamente:
      </p><div class="example"><a id="idp5039160"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:CollectingParameterDemo.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> CollectingParameter <span class="hl opt">:</span> <span class="hl kwc">public</span> vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt; {};</span>

<span class="hl kwc">class</span> Filler <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span>CollectingParameter<span class="hl opt">&amp;</span> cp<span class="hl opt">) {</span>
    cp<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl str">&quot;accumulating&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">(</span>CollectingParameter<span class="hl opt">&amp;</span> cp<span class="hl opt">) {</span>
    cp<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl str">&quot;items&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">(</span>CollectingParameter<span class="hl opt">&amp;</span> cp<span class="hl opt">) {</span>
    cp<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl str">&quot;as we go&quot;</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Filler filler<span class="hl opt">;</span>
  CollectingParameter cp<span class="hl opt">;</span>
  filler<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(</span>cp<span class="hl opt">);</span>
  filler<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">(</span>cp<span class="hl opt">);</span>
  filler<span class="hl opt">.</span><span class="hl kwd">h</span><span class="hl opt">(</span>cp<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>string<span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span> cp<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> cp<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
    cout <span class="hl opt">&lt;&lt; *</span>it<span class="hl opt">++ &lt;&lt;</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.2. C10/CollectingParameterDemo.cpp</strong></p></div><br class="example-break" /><p>
	El parámetro de recolección debe tener alguna forma de establecer
o insertar valores. Nótese que por esta definición, un Mensajero
podría usarse como parámetro de recolección. La clave reside en que el
parámetro de recolección se pasa y es modificado por la función que lo
recibe.
      </p></div></div><div class="sect1" title="9.4. Singleton"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5041816"></a>9.4. Singleton</h2></div></div></div><p>
	Posiblemente, el patrón de diseño más simple del GoF es
el <code class="keyword">Singleton</code>, que es una forma de asegurar una única
instancia de una clase. El siguiente programa muestra cómo implementar
un <code class="keyword">Singleton</code> en C++:
    </p><div class="example"><a id="idp5043568"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:SingletonPattern.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Singleton <span class="hl opt">{</span>
  <span class="hl kwb">static</span> Singleton s<span class="hl opt">;</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwd">Singleton</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>x<span class="hl opt">) { }</span>
  Singleton<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span>Singleton<span class="hl opt">&amp;);</span>  <span class="hl slc">// Disallowed</span>
  <span class="hl kwd">Singleton</span><span class="hl opt">(</span><span class="hl kwb">const</span> Singleton<span class="hl opt">&amp;);</span>       <span class="hl slc">// Disallowed</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> Singleton<span class="hl opt">&amp;</span> <span class="hl kwd">instance</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> s<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getValue</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> i <span class="hl opt">=</span> x<span class="hl opt">; }</span>
<span class="hl opt">};</span>

Singleton Singleton<span class="hl opt">::</span><span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Singleton<span class="hl opt">&amp;</span> s <span class="hl opt">=</span> Singleton<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  Singleton<span class="hl opt">&amp;</span> s2 <span class="hl opt">=</span> Singleton<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">();</span>
  s2<span class="hl opt">.</span><span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.3. C10/SingletonPattern.cpp</strong></p></div><br class="example-break" /><p>
	La clave para crear un Singleton es evitar que el programador
cliente tenga control sobre el ciclo de vida del objeto. Para
lograrlo, declare todos los constructores privados, y evite que el
compilador genere implícitamente cualquier constructor. Fíjese que el
FIXME: constructor de copia? y el operador de asignación (que
intencionadamente carecen de implementación alguna, ya que nunca van a
ser llamados) están declarados como privados, para evitar que se haga
cualquier tipo de copia.
    </p><p>
	También debe decidir cómo va a crear el objeto. Aquí, se crea de
forma estática, pero también puede esperar a que el programador
cliente pida uno y crearlo bajo demanda. Esto se llama "inicialización
vaga", y sólo tiene sentido si resulta caro crear el objeto y no
siempre se necesita.
    </p><p>
	Si devuelve un puntero en lugar de una referencia, el usuario
podría borrar el puntero sin darse cuenta, por lo que la
implementación citada anteriormente es más segura (el destructor
también podría declararse privado o protegido para solventar el
problema). En cualquier caso, el objeto debería almacenarse de forma
privada.
    </p><p>
	  Usted da acceso a través de FIXME (funciones de miembros)
	  públicas. Aquí,
<code class="keyword">instance()</code> genera una referencia al objeto <code class="keyword">Singleton</code>. El resto
de la interfaz (<code class="keyword">getValue()</code> y <code class="keyword">setValue()</code>) es la interfaz regular
de la clase.
    </p><p>
	  Fíjese en que no está restringido a crear un único objeto. Esta
técnica también soporta la creacion de un <code class="keyword">pool</code> limitado de
objetos. En este caso, sin embargo, puede enfrentarse al problema de
compartir objetos del <code class="keyword">pool</code>.  Si esto supone un problema,
puede crear una solución que incluya un <code class="keyword">check-out</code> y
un <code class="keyword">check-in</code> de los objetos compartidos.
    </p><div class="sect2" title="9.4.1. Variantes del Singleton"><div class="titlepage"><div><div><h3 class="title"><a id="idp5053088"></a>9.4.1. Variantes del Singleton </h3></div></div></div><p>
		Cualquier miembro <code class="keyword">static</code> dentro de una clase es una
		forma de Singleton se hará uno y sólo uno. En cierto modo, el
		lenguaje da soporte directo a esta idea; se usa de forma
		regular. Sin embargo, los objetos estáticos tienen un problema
		(ya miembros o no): el orden de inicialización, tal y como se
		describe en el volumen 1 de este libro. Si un
		objeto <code class="keyword">static</code> depende de otro, es importante que los
		objetos se inicializen en el orden correcto.
      </p><p>
		En el volumen 1, se mostró cómo controlar el orden de
inicialización definiendo un objeto estático dentro de una
función. Esto retrasa la inicialización del objeto hasta la primera
vez que se llama a la función. Si la función devuelve una referencia
al objeto estático, hace las veces de <code class="keyword">Singleton</code> a la vez que
elimina gran parte de la preocupación de la inicialización
estática. Por ejemplo, suponga que quiere crear un fichero
de <code class="keyword">log</code> en la primera llamada a una función que devuelve una
referencia a dicho fichero. Basta con este fichero de cabecera:
      </p><div class="example"><a id="idp5057464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:LogFile.h</span>
<span class="hl ppc">#ifndef LOGFILE_H</span>
<span class="hl ppc">#define LOGFILE_H</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
std<span class="hl opt">::</span>ofstream<span class="hl opt">&amp;</span> <span class="hl kwd">logfile</span><span class="hl opt">();</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// LOGFILE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.4. C10/LogFile.h</strong></p></div><br class="example-break" /><p>
		La implementación no debe FIXME: hacerse en la misma línea,
porque eso significaría que la función entera, incluída la definición
del objeto estático que contiene, podría ser duplicada en cualquier
unidad de traducción donde se incluya, lo que viola la regla de única
definición de C++. [137] Con toda seguridad, esto frustraría cualquier
intento de controlar el orden de inicialización (pero potencialmente
de una forma sutil y difícil de detectar). De forma que la
implementación debe separarse:
      </p><div class="example"><a id="idp5059280"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:LogFile.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LogFile.h&quot;</span><span class="hl ppc"></span>
std<span class="hl opt">::</span>ofstream<span class="hl opt">&amp;</span> <span class="hl kwd">logfile</span><span class="hl opt">() {</span>
  <span class="hl kwb">static</span> std<span class="hl opt">::</span>ofstream <span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">&quot;Logfile.log&quot;</span><span class="hl opt">);</span>
  <span class="hl kwa">return</span> log<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.5. C10/LogFile.cpp</strong></p></div><br class="example-break" /><p>
		Ahora el objeto <code class="keyword">log</code> no se inicializará hasta la
primera vez que se llame a <code class="keyword">logfile()</code>. Así que, si crea una
función:
      </p><div class="example"><a id="idp5061832"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:UseLog1.h</span>
<span class="hl ppc">#ifndef USELOG1_H</span>
<span class="hl ppc">#define USELOG1_H</span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// USELOG1_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.6. C10/UseLog1.h</strong></p></div><br class="example-break" /><p>
		que use <code class="keyword">logfile()</code> en su implementación:
      </p><div class="example"><a id="idp5063464"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:UseLog1.cpp {O}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;UseLog1.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LogFile.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
  <span class="hl kwd">logfile</span><span class="hl opt">() &lt;&lt;</span> __FILE__ <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.7. C10/UseLog1.cpp</strong></p></div><br class="example-break" /><p>
		y utiliza <code class="keyword">logfile()</code> otra vez en otro fichero:
      </p><div class="example"><a id="idp5065160"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:UseLog2.cpp</span>
<span class="hl slc">//{L} LogFile UseLog1</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;UseLog1.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LogFile.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span>
  <span class="hl kwd">logfile</span><span class="hl opt">() &lt;&lt;</span> __FILE__ <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">f</span><span class="hl opt">();</span>
  <span class="hl kwd">g</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.8. C10/UseLog2.cpp</strong></p></div><br class="example-break" /><p>
	el objecto <code class="varname">log</code> no se crea hasta la primera
	llamada a <code class="function">f()</code>.
      </p><p>
	Puede combinar fácilmente la creación de objetos estáticos
	dentro de una función miembro con la clase
	<code class="keyword">Singleton</code>. SingletonPattern.cpp puede modificarse para
	usar esta aproximación:[138]
      </p><div class="example"><a id="idp5068048"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:SingletonPattern2.cpp</span>
<span class="hl slc">// Meyers' Singleton.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Singleton <span class="hl opt">{</span>
  <span class="hl kwb">int</span> i<span class="hl opt">;</span>
  <span class="hl kwd">Singleton</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) :</span> <span class="hl kwd">i</span><span class="hl opt">(</span>x<span class="hl opt">) { }</span>
  <span class="hl kwb">void</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span>Singleton<span class="hl opt">&amp;);</span>
  <span class="hl kwd">Singleton</span><span class="hl opt">(</span><span class="hl kwb">const</span> Singleton<span class="hl opt">&amp;);</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> Singleton<span class="hl opt">&amp;</span> <span class="hl kwd">instance</span><span class="hl opt">() {</span>
    <span class="hl kwb">static</span> Singleton <span class="hl kwd">s</span><span class="hl opt">(</span><span class="hl num">47</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> s<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getValue</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> i<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl kwb">int</span> x<span class="hl opt">) {</span> i <span class="hl opt">=</span> x<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Singleton<span class="hl opt">&amp;</span> s <span class="hl opt">=</span> Singleton<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  Singleton<span class="hl opt">&amp;</span> s2 <span class="hl opt">=</span> Singleton<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">();</span>
  s2<span class="hl opt">.</span><span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl num">9</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> s<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.9. C10/SingletonPattern2.cpp</strong></p></div><br class="example-break" /><p>
		Se da un caso especialmente interesante cuando
dos <code class="keyword">Singletons</code> dependen mutuamente el uno del otro, de esta
forma:
      </p><div class="example"><a id="idp5070760"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:FunctionStaticSingleton.cpp</span>

<span class="hl kwc">class</span> Singleton1 <span class="hl opt">{</span>
  <span class="hl kwd">Singleton1</span><span class="hl opt">() {}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> Singleton1<span class="hl opt">&amp;</span> <span class="hl kwd">ref</span><span class="hl opt">() {</span>
    <span class="hl kwb">static</span> Singleton1 single<span class="hl opt">;</span>
    <span class="hl kwa">return</span> single<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Singleton2 <span class="hl opt">{</span>
  Singleton1<span class="hl opt">&amp;</span> s1<span class="hl opt">;</span>
  <span class="hl kwd">Singleton2</span><span class="hl opt">(</span>Singleton1<span class="hl opt">&amp;</span> s<span class="hl opt">) :</span> <span class="hl kwd">s1</span><span class="hl opt">(</span>s<span class="hl opt">) {}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> Singleton2<span class="hl opt">&amp;</span> <span class="hl kwd">ref</span><span class="hl opt">() {</span>
    <span class="hl kwb">static</span> Singleton2 <span class="hl kwd">single</span><span class="hl opt">(</span>Singleton1<span class="hl opt">::</span><span class="hl kwd">ref</span><span class="hl opt">());</span>
    <span class="hl kwa">return</span> single<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Singleton1<span class="hl opt">&amp;</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> s1<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Singleton1<span class="hl opt">&amp;</span> s1 <span class="hl opt">=</span> Singleton2<span class="hl opt">::</span><span class="hl kwd">ref</span><span class="hl opt">().</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.10. C10/FunctionStaticSingleton.cpp</strong></p></div><br class="example-break" /><p>
		Cuando se llama a <code class="keyword">Singleton2::ref()</code>, hace que se cree
su único objeto <code class="keyword">Singleton2</code>. En el proceso de esta creación,
se llama a <code class="keyword">Singleton1::ref()</code>, y esto hace que se cree su
objeto único
<code class="keyword">Singleton1</code>. Como esta técnica no se basa en el orden de linkado
ni el de carga, el programador tiene mucho mayor control sobre la inicialización,
lo que redunda en menos problemas.
      </p><p>
		Otra variación del <code class="keyword">Singleton</code> separa la unicidad de un
objeto de su implementación. Esto se logra usando el "Patrón Plantilla
Curiosamente Recursivo" mencionado en el Capítulo 5:
      </p><div class="example"><a id="idp5075720"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:CuriousSingleton.cpp</span>
<span class="hl slc">// Separates a class from its Singleton-ness (almost).</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> Singleton <span class="hl opt">{</span>
  <span class="hl kwd">Singleton</span><span class="hl opt">(</span><span class="hl kwb">const</span> Singleton<span class="hl opt">&amp;);</span>
  Singleton<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span><span class="hl kwb">const</span> Singleton<span class="hl opt">&amp;);</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwd">Singleton</span><span class="hl opt">() {}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Singleton</span><span class="hl opt">() {}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static</span> T<span class="hl opt">&amp;</span> <span class="hl kwd">instance</span><span class="hl opt">() {</span>
    <span class="hl kwb">static</span> T theInstance<span class="hl opt">;</span>
    <span class="hl kwa">return</span> theInstance<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// A sample class to be made into a Singleton</span>
<span class="hl kwc">class</span> MyClass <span class="hl opt">:</span> <span class="hl kwc">public</span> Singleton<span class="hl opt">&lt;</span>MyClass<span class="hl opt">&gt; {</span>
  <span class="hl kwb">int</span> x<span class="hl opt">;</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwc">friend class</span> Singleton<span class="hl opt">&lt;</span>MyClass<span class="hl opt">&gt;;</span>
  <span class="hl kwd">MyClass</span><span class="hl opt">() {</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl kwb">int</span> n<span class="hl opt">) {</span> x <span class="hl opt">=</span> n<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getValue</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> x<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  MyClass<span class="hl opt">&amp;</span> m <span class="hl opt">=</span> MyClass<span class="hl opt">::</span><span class="hl kwd">instance</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> m<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  m<span class="hl opt">.</span><span class="hl kwd">setValue</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> m<span class="hl opt">.</span><span class="hl kwd">getValue</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.11. C10/CuriousSingleton.cpp</strong></p></div><br class="example-break" /><p>
		<code class="keyword">MyClass</code> se convierte en <code class="keyword">Singleton</code>:
      </p><p>
		1. Haciendo que su constructor sea <code class="keyword">private</code> o <code class="keyword">protected</code>.
      </p><p>
		2. Haciéndose amigo de <code class="keyword">Singleton&lt;MyClass&gt;</code>.
      </p><p>
		3. Derivando <code class="keyword">MyClass</code> desde <code class="keyword">Singleton&lt;MyClass&gt;</code>.
      </p><p>
		La auto-referencia del paso 3 podría sonar inversímil, pero
tal como se explicó en el Capítulo 5, funciona porque sólo hay una
dependencia estática sobre el argumento plantilla de la
plantilla <code class="keyword">Singleton</code>. En otras palabras, el código de la
clase <code class="keyword">Singleton&lt;MyClass&gt;</code> puede ser instanciado por el
compilador porque no depende del tamaño de <code class="keyword">MyClass</code>. Es
después, cuando se a <code class="keyword">Singleton&lt;MyClass&gt;::instance()</code>,
cuando se necesita el tamaño de
<code class="keyword">MyClass</code>, y para entonces <code class="keyword">MyClass</code> ya se ha compilado y su tamaño
se conoce.[139]
      </p><p>
	Es interesante lo intrincado que un patrón tan simple como el
	<code class="keyword">Singleton</code> puede llegar a ser, y ni siquiera se han
	tratado todavía asuntos de seguridad de hilos. Por último, el
	patrón <code class="keyword">Singleton</code> debería usarse lo justo y necesario. Los
	verdaderos objetos <code class="keyword">Singleton</code> rara vez aparecen, y la
	última cosa para la que debe usarse un
	<code class="keyword">Singleton</code> es para remplazar a una variable
	global. [140]
      </p></div></div><div class="sect1" title="9.5. Comando: elegir la operación"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5088232"></a>9.5. Comando: elegir la operación </h2></div></div></div><p>
	  El patrón <code class="keyword">Comando</code> es estructuralmente muy sencillo,
pero puede tener un impacto importante en el desacoplamiento (y, por
ende, en la limpieza) de su código.
    </p><p>
	  En "Advanced C++: Programming Styles And Idioms (Addison Wesley,
1992)", Jim Coplien acuña el término <code class="keyword">functor</code>, que es un
objeto cuyo único propósito es encapsular una función (dado
que <code class="keyword">functor</code> tiene su significado en matemáticas, usaremos el
término "objeto función", que es más explícito). El quid está en
desacoplar la elección de la función que hay que llamar del sitio
donde se llama a dicha función.
    </p><p>
	  Este término se menciona en el GoF, pero no se usa. Sin embargo,
el concepto de "objeto función" se repite en numerosos patrones del
libro.
    </p><p>
	  Un <code class="keyword">Comando</code> es un objeto función en su estado más puro:
una función que tiene un objeto. Al envolver una función en un objeto,
puede pasarla a otras funciones u objetos como parámetro, para
decirles que realicen esta operación concreta mientras llevan a cabo
su petición. Se podría decir que un <code class="keyword">Comando</code> es un Mensajero
que lleva un comportamiento.
    </p><div class="example"><a id="idp5093704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:CommandPattern.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Command <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">execute</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Hello <span class="hl opt">:</span> <span class="hl kwc">public</span> Command <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">execute</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Hello &quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> World <span class="hl opt">:</span> <span class="hl kwc">public</span> Command <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">execute</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;World! &quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> IAm <span class="hl opt">:</span> <span class="hl kwc">public</span> Command <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">execute</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I'm the command pattern!&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// An object that holds commands:</span>
<span class="hl kwc">class</span> Macro <span class="hl opt">{</span>
  vector<span class="hl opt">&lt;</span>Command<span class="hl opt">*&gt;</span> commands<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">add</span><span class="hl opt">(</span>Command<span class="hl opt">*</span> c<span class="hl opt">) {</span> commands<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>c<span class="hl opt">); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    vector<span class="hl opt">&lt;</span>Command<span class="hl opt">*&gt;::</span>iterator it <span class="hl opt">=</span> commands<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> commands<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
      <span class="hl opt">(*</span>it<span class="hl opt">++)-&gt;</span><span class="hl kwd">execute</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Macro macro<span class="hl opt">;</span>
  macro<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> Hello<span class="hl opt">);</span>
  macro<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> World<span class="hl opt">);</span>
  macro<span class="hl opt">.</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> IAm<span class="hl opt">);</span>
  macro<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.12. C10/CommandPattern.cpp</strong></p></div><br class="example-break" /><p>
	  El punto principal del <code class="keyword">Comando</code> es permitirle dar una
acción deseada a una función u objeto. En el ejemplo anterior, esto
provee una manera de encolar un conjunto de acciones que se deben
ejecutar colectivamente. Aquí, puede crear dinámicamente nuevos
comportamientos, algo que puede hacer normalmente escribiendo nuevo
código, pero en el ejemplo anterior podría hacerse interpretando
un <code class="keyword">script</code> (vea el patrón Intérprete si lo que necesita hacer
se vuelve demasiado complicado).
    </p><p>
	  Según el GoF, los <code class="keyword">Comandos</code> son un sustituto orientado a
	  objetos de las <code class="keyword">retrollamadas</code>
	  (<code class="keyword">callbacks</code>). [141] Sin embargo, pensamos que la palabra
	  "retro" es una parte esencial del concepto de retrollamada -una
	  retrollamada retorna al creador de la misma. Por otro lado, un
	  objeto <code class="keyword">Comando</code>, simplemente se crea y se entrega a
	  alguna función u objeto, y no se permanece conectado de por vida
	  al objecto <code class="keyword">Comando</code>.
    </p><p>
Un ejemplo habitual del patrón <code class="keyword">Comando</code> es la implementación
de la funcionalidad de "deshacer" en una aplicación. Cada vez que el
usuario realiza una operación, se coloca el correspondiente objeto
Comando de deshacer en una cola. Cada objeto Comando que se ejecuta
guarda el estado del programa en el paso anterior.
    </p><div class="sect2" title="9.5.1. Desacoplar la gestión de eventos con Comando"><div class="titlepage"><div><div><h3 class="title"><a id="idp5101792"></a>9.5.1. Desacoplar la gestión de eventos con Comando</h3></div></div></div><p>
Como se verá en el siguiente capítulo, una de las razones para emplear
técnicas de concurrencia es facilitar la gestión de la programación
dirigida por eventos, donde los eventos pueden aparecer en el programa
de forma impredecible. Por ejemplo, un usuario que pulsa un botón de
"Salir" mientras se está realizando una operación espera que el
programa responda rápidamente.
      </p><p>
Un motivo para usar concurrencia es que previene el aclopamiento entre
los bloques del código. Es decir, si está ejecutando un hilo aparte
para vigilar el botónde salida, las operaciones normales de su
programa no necesitan saber nada sobre el botón ni sobe ninguna de las
demás operaciones que se están vigilando.
      </p><p>
Sin embargo, una vez que comprenda que el quiz está en el
acoplamiento, puede evitarlo usando el patrón Comando. Cada operación
normal debe llamar periódicamente a una función para que compruebe el
estado de los eventos, pero con el patrón Comando, estas operaciones
normales no tienen porqué saber nada sobre lo que están comprobando, y
por lo tanto, están desacopladas del código de manejo de eventos:
      </p><div class="example"><a id="idp5104792"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:MulticastCommand.cpp {RunByHand}</span>
<span class="hl slc">// Decoupling event management with the Command pattern.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Framework for running tasks:</span>
<span class="hl kwc">class</span> Task <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">operation</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> TaskRunner <span class="hl opt">{</span>
  <span class="hl kwb">static</span> vector<span class="hl opt">&lt;</span>Task<span class="hl opt">*&gt;</span> tasks<span class="hl opt">;</span>
  <span class="hl kwd">TaskRunner</span><span class="hl opt">() {}</span> <span class="hl slc">// Make it a Singleton</span>
  TaskRunner<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">=(</span>TaskRunner<span class="hl opt">&amp;);</span> <span class="hl slc">// Disallowed</span>
  <span class="hl kwd">TaskRunner</span><span class="hl opt">(</span><span class="hl kwb">const</span> TaskRunner<span class="hl opt">&amp;);</span> <span class="hl slc">// Disallowed</span>
  <span class="hl kwb">static</span> TaskRunner tr<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">add</span><span class="hl opt">(</span>Task<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span> tasks<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(&amp;</span>t<span class="hl opt">); }</span>
  <span class="hl kwb">static void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    vector<span class="hl opt">&lt;</span>Task<span class="hl opt">*&gt;::</span>iterator it <span class="hl opt">=</span> tasks<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> tasks<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
      <span class="hl opt">(*</span>it<span class="hl opt">++)-&gt;</span><span class="hl kwd">operation</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

TaskRunner TaskRunner<span class="hl opt">::</span>tr<span class="hl opt">;</span>
vector<span class="hl opt">&lt;</span>Task<span class="hl opt">*&gt;</span> TaskRunner<span class="hl opt">::</span>tasks<span class="hl opt">;</span>

<span class="hl kwc">class</span> EventSimulator <span class="hl opt">{</span>
  <span class="hl kwb">clock_t</span> creation<span class="hl opt">;</span>
  <span class="hl kwb">clock_t</span> delay<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">EventSimulator</span><span class="hl opt">() :</span> <span class="hl kwd">creation</span><span class="hl opt">(</span><span class="hl kwd">clock</span><span class="hl opt">()) {</span>
    delay <span class="hl opt">=</span> CLOCKS_PER_SEC<span class="hl opt">/</span><span class="hl num">4</span> <span class="hl opt">* (</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">20</span> <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;delay = &quot;</span> <span class="hl opt">&lt;&lt;</span> delay <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">fired</span><span class="hl opt">() {</span>
    <span class="hl kwa">return</span> <span class="hl kwd">clock</span><span class="hl opt">() &gt;</span> creation <span class="hl opt">+</span> delay<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Something that can produce asynchronous events:</span>
<span class="hl kwc">class</span> Button <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> pressed<span class="hl opt">;</span>
  string id<span class="hl opt">;</span>
  EventSimulator e<span class="hl opt">;</span> <span class="hl slc">// For demonstration</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Button</span><span class="hl opt">(</span>string name<span class="hl opt">) :</span> <span class="hl kwd">pressed</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>name<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">press</span><span class="hl opt">() {</span> pressed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">isPressed</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>e<span class="hl opt">.</span><span class="hl kwd">fired</span><span class="hl opt">())</span> <span class="hl kwd">press</span><span class="hl opt">();</span> <span class="hl slc">// Simulate the event</span>
    <span class="hl kwa">return</span> pressed<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Button<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> b<span class="hl opt">.</span>id<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// The Command object</span>
<span class="hl kwc">class</span> CheckButton <span class="hl opt">:</span> <span class="hl kwc">public</span> Task <span class="hl opt">{</span>
  Button<span class="hl opt">&amp;</span> button<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> handled<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">CheckButton</span><span class="hl opt">(</span>Button <span class="hl opt">&amp;</span> b<span class="hl opt">) :</span> <span class="hl kwd">button</span><span class="hl opt">(</span>b<span class="hl opt">),</span> <span class="hl kwd">handled</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">operation</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>button<span class="hl opt">.</span><span class="hl kwd">isPressed</span><span class="hl opt">() &amp;&amp; !</span>handled<span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> button <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; pressed&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      handled <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// The procedures that perform the main processing. These</span>
<span class="hl slc">// need to be occasionally &quot;interrupted&quot; in order to</span>
<span class="hl slc">// check the state of the buttons or other events:</span>
<span class="hl kwb">void</span> <span class="hl kwd">procedure1</span><span class="hl opt">() {</span>
  <span class="hl slc">// Perform procedure1 operations here.</span>
  <span class="hl slc">// ...</span>
  TaskRunner<span class="hl opt">::</span><span class="hl kwd">run</span><span class="hl opt">();</span> <span class="hl slc">// Check all events</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">procedure2</span><span class="hl opt">() {</span>
  <span class="hl slc">// Perform procedure2 operations here.</span>
  <span class="hl slc">// ...</span>
  TaskRunner<span class="hl opt">::</span><span class="hl kwd">run</span><span class="hl opt">();</span> <span class="hl slc">// Check all events</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">procedure3</span><span class="hl opt">() {</span>
  <span class="hl slc">// Perform procedure3 operations here.</span>
  <span class="hl slc">// ...</span>
  TaskRunner<span class="hl opt">::</span><span class="hl kwd">run</span><span class="hl opt">();</span> <span class="hl slc">// Check all events</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Randomize</span>
  Button <span class="hl kwd">b1</span><span class="hl opt">(</span><span class="hl str">&quot;Button 1&quot;</span><span class="hl opt">),</span> <span class="hl kwd">b2</span><span class="hl opt">(</span><span class="hl str">&quot;Button 2&quot;</span><span class="hl opt">),</span> <span class="hl kwd">b3</span><span class="hl opt">(</span><span class="hl str">&quot;Button 3&quot;</span><span class="hl opt">);</span>
  CheckButton <span class="hl kwd">cb1</span><span class="hl opt">(</span>b1<span class="hl opt">),</span> <span class="hl kwd">cb2</span><span class="hl opt">(</span>b2<span class="hl opt">),</span> <span class="hl kwd">cb3</span><span class="hl opt">(</span>b3<span class="hl opt">);</span>
  TaskRunner<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span>cb1<span class="hl opt">);</span>
  TaskRunner<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span>cb2<span class="hl opt">);</span>
  TaskRunner<span class="hl opt">::</span><span class="hl kwd">add</span><span class="hl opt">(</span>cb3<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Control-C to exit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
    <span class="hl kwd">procedure1</span><span class="hl opt">();</span>
    <span class="hl kwd">procedure2</span><span class="hl opt">();</span>
    <span class="hl kwd">procedure3</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.13. C10/MulticastCommand.cpp</strong></p></div><br class="example-break" /><p>
		Aquí, el objeto Comando está representado por <code class="keyword">Tarea</code>s
		ejecutadas por el
		Singleton <code class="keyword">TaskRunner</code>. <code class="keyword">EventSimulator</code> crea un
		retraso aleatorio, de modo que si se llama periódicamente a la
		función fired() el resultado cambiará de <code class="keyword">false</code>
		a <code class="keyword">true</code> en algún momento aleatorio. Los
		objetos <code class="keyword">EventSimulator</code> se utilizan dentro de los
		Botones para simular que ocurre un evento de usuario en un
		momento impredecible. <code class="keyword">CheckButton</code> es la
		implementación de la Tarea que es comprobada periódicamente
		por todo el código "normal" del progama. Puede ver cómo ocurre
		al final de procedure1(), procedure2() y procedure3().
      </p><p>
Aunque esto requiere un poco más de razonamiento para establecerlo, verá en el
Capítulo 11 que utilizar hilos requiere mucho pensamiento y cuidado para prevenir
las muchas dificultades inhenerentes a la programación concurrente, por lo que
la solución más simple puede ser preferible. También puede crear un esquema de hilos
muy simple moviendo las llamadas a TaskRunner::run() a un objeto temporizador multi-hilo.
Al hacer esto, se elimina todo el acoplamiento entre las operaciones "normales"
(los "procedures" en el ejemplo anterior) y el código de eventos.
      </p></div></div><div class="sect1" title="9.6. Desacoplamiento de objetos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5115784"></a>9.6. Desacoplamiento de objetos</h2></div></div></div><p>
Tanto el Proxy como el Estado proporcionen una clase sucedánea. El
código habla a esta clase sucedánea, y la verdadera clase que hace el
trabajo está escondida detrás de la sucedánea. Cuando usted llama a
una función en la clase sucedánea, simplemente da un rodeo y llama a
la función en la clase implementadora. Estos dos patrones son tan
familiares que, estructuralmente, Proxy es un caso especial de Estado.
Uno está tentado de juntar ambos en un patrón llamado Sucedánea, pero
la intención de los dos patrones es distinta. Puede ser fácil caer en
la trampa de pensar que si la estructura es la misma, los patrones son
el mismo. Debe mirar siempre la intención del patrón para tener claro
lo que hace.
    </p><p>
La idea básica es simple: cree una clase base, la sucedánea se deriva
junto con la clase o clases que aportan la siguiente implementación:
    </p><p>
Cuando se crea una clase sucedánea, se le da una implementación a la
que envía las llamadas a función.
    </p><p>
Estructuralmente, la diferencia entre Proxy y Estado es simple: un
Proxy sólo tiene una implementación, mientras que Estado tiene más de
una. La aplicación de los patrones se considera (en el GoF) distinta:
Proxy controla el acceso a su implementación, mientras que Estado
cambia la implementación dinámicamente. Sin embargo, si se amplía la
noción de "controlar el acceso a la implementación", entonces los dos
parecen ser parte de un todo.
    </p><div class="sect2" title="9.6.1. Proxy: FIXME: hablando en nombre de otro objeto"><div class="titlepage"><div><div><h3 class="title"><a id="idp5119752"></a>9.6.1. Proxy: FIXME: hablando en nombre de otro objeto</h3></div></div></div><p>
Si se implementa un Proxy usando el diagrama anterior, tiene esta
pinta:
      </p><div class="example"><a id="idp5120408"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:ProxyDemo.cpp</span>
<span class="hl slc">// Simple demonstration of the Proxy pattern.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> ProxyBase <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">ProxyBase</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Implementation <span class="hl opt">:</span> <span class="hl kwc">public</span> ProxyBase <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Implementation.f()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Implementation.g()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Implementation.h()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Proxy <span class="hl opt">:</span> <span class="hl kwc">public</span> ProxyBase <span class="hl opt">{</span>
  ProxyBase<span class="hl opt">*</span> implementation<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Proxy</span><span class="hl opt">() {</span> implementation <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Implementation</span><span class="hl opt">(); }</span>
  <span class="hl opt">~</span><span class="hl kwd">Proxy</span><span class="hl opt">() {</span> <span class="hl kwa">delete</span> implementation<span class="hl opt">; }</span>
  <span class="hl slc">// Forward calls to the implementation:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span> implementation<span class="hl opt">-&gt;</span><span class="hl kwd">f</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">() {</span> implementation<span class="hl opt">-&gt;</span><span class="hl kwd">g</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">h</span><span class="hl opt">() {</span> implementation<span class="hl opt">-&gt;</span><span class="hl kwd">h</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">()  {</span>
  Proxy p<span class="hl opt">;</span>
  p<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
  p<span class="hl opt">.</span><span class="hl kwd">g</span><span class="hl opt">();</span>
  p<span class="hl opt">.</span><span class="hl kwd">h</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.14. C10/ProxyDemo.cpp</strong></p></div><br class="example-break" /><p>
En algunos casos, Implementation no necesita la misma interfaz que
Proxy, siempre y cuando Proxy esté de alguna forma hablando en nombre
de la clase Implementación y referenciando llamadas a función hacia
ella, entonces la idea básica se satisface (note que esta afirmación
está reñida con la definición de Proxy del GoF). Sin embargo, con una
interfaz común es posible realizar un reemplazo FIXME: drop-in del
proxy en el código del cliente -el código del cliente está escrito
para hablar al objeto original, y no necesita ser cambiado para
aceptar el proxy (éste es probablemente el quiz principal de
Proxy). Además, se fuerza a que Implementation complete, a través de
la interfaz común, todas las funciones que Proxy necesita llamar.
      </p><p>
La diferencia entre Proxy y Estado está en los problemas que pueden
resolver.  Los usos más comunes para Proxy que describe el GoF son:
      </p><p>
1. Proxy remoto. Representan a objetos en un espacio de direcciones
distinto. Lo implementan algunas tecnologías de objetos remotos.
      </p><p>
2. Proxy virtual. Proporciona inicialización FIXME: vaga para crear
objetos costosos bajo demanda.
      </p><p>
3. Proxy de protección. Se usa cuando no se desea que el programador
cliente tenga acceso completo al objecto representado.
      </p><p>
4. Referencia inteligente. Para añadir acciones adicionales cuando se
acceda al objeto representado. El conteo de referencias es un buen
ejemplo: mantiene un registro del número de referencias que se
mantienen para un objeto en particular, para implementar el FIXME:
copy-on-write idiom y para prevenir el FIXME: object aliasing.
      </p></div><div class="sect2" title="9.6.2. Estado: cambiar el comportamiento del objeto"><div class="titlepage"><div><div><h3 class="title"><a id="idp5126792"></a>9.6.2. Estado: cambiar el comportamiento del objeto</h3></div></div></div><p>
El patrón Estado produce un objeto que parece que cambia su clase, y
le será útil cuando descubra que tiene código condicional en todas o
casi todas sus funciones.  Al igual que Proxy, un Estado se crea
teniendo un objeto front-end que usa un objeto back-end de
implementación para completar sus tareas. Sin embargo, el patrón
Estado alterna entre una implementación y otra durante la vida del
objeto front-end, para mostrar un comportamiento distinto ante las
mismas llamadas a función. Es una forma de mejorar la implementación
de su código cuando realiza un montón de pruebas en cada una de sus
funciones antes de decidir qué hacer con esa función. Por ejemplo, el
cuento del príncipe convertido en rana contiene un objeto (la
criatura) que se comporta de modo distinto dependiendo del estado en
el que se encuentre. Podría implementar esto comprobando
un <code class="keyword">bool</code>:
      </p><div class="example"><a id="idp5129568"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:KissingPrincess.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Creature <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> isFrog<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Creature</span><span class="hl opt">() :</span> <span class="hl kwd">isFrog</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>isFrog<span class="hl opt">)</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Ribbet!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">else</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Darling!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">kiss</span><span class="hl opt">() {</span> isFrog <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Creature creature<span class="hl opt">;</span>
  creature<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
  creature<span class="hl opt">.</span><span class="hl kwd">kiss</span><span class="hl opt">();</span>
  creature<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.15. C10/KissingPrincess.cpp</strong></p></div><br class="example-break" /><p>
Sin embargo, la función greet(), y cualquier otra función que tenga
que comprobar isFrog antes de realizar sus operaciones, acaban con
código poco elegante, especialmente cuando haya que añadir estados
adicionales al sistema. Delegando las operaciones a un objeto Estado
que puede cambiarse, el código se simplifica.
      </p><div class="example"><a id="idp5131720"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:KissingPrincess2.cpp</span>
<span class="hl slc">// The State pattern.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Creature <span class="hl opt">{</span>
  <span class="hl kwc">class</span> State <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwc">virtual</span> string <span class="hl kwd">response</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">};</span>
  <span class="hl kwc">class</span> Frog <span class="hl opt">:</span> <span class="hl kwc">public</span> State <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    string <span class="hl kwd">response</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Ribbet!&quot;</span><span class="hl opt">; }</span>
  <span class="hl opt">};</span>
  <span class="hl kwc">class</span> Prince <span class="hl opt">:</span> <span class="hl kwc">public</span> State <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    string <span class="hl kwd">response</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl str">&quot;Darling!&quot;</span><span class="hl opt">; }</span>
  <span class="hl opt">};</span>
  State<span class="hl opt">*</span> state<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Creature</span><span class="hl opt">() :</span> <span class="hl kwd">state</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Frog</span><span class="hl opt">()) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> state<span class="hl opt">-&gt;</span><span class="hl kwd">response</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">kiss</span><span class="hl opt">() {</span>
    <span class="hl kwa">delete</span> state<span class="hl opt">;</span>
    state <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Prince</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Creature creature<span class="hl opt">;</span>
  creature<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
  creature<span class="hl opt">.</span><span class="hl kwd">kiss</span><span class="hl opt">();</span>
  creature<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.16. C10/KissingPrincess2.cpp</strong></p></div><br class="example-break" /><p>
No es necesario hacer las clases FIXME: implementadoras anidadas ni
privadas, pero si lo hace, el código será más limpio.
      </p><p>
Note que los cambios en las clases Estado se propagan automáticamente
por todo su código, en lugar de requerir una edición de las clases
para efectuar los cambios.
      </p></div></div><div class="sect1" title="9.7. Adaptador"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5134736"></a>9.7. Adaptador</h2></div></div></div><p>
Un Adaptador coge un tipo y genera una interfaz para algún otro
tipo. Es útil cuando se tiene una librería o trozo de código que tiene
una interfaz particular, y otra librería o trozo de código que usa las
mismas ideas básicas que la primera librería, pero se expresa de forma
diferente. Si se adaptan las formas de expresión entre sí, se puede
crear una solución rápidamente.
    </p><p>
Suponga que tiene una clase productora que genera los números de
Fibonacci:
    </p><div class="example"><a id="idp5136336"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:FibonacciGenerator.h</span>
<span class="hl ppc">#ifndef FIBONACCIGENERATOR_H</span>
<span class="hl ppc">#define FIBONACCIGENERATOR_H</span>

<span class="hl kwc">class</span> FibonacciGenerator <span class="hl opt">{</span>
  <span class="hl kwb">int</span> n<span class="hl opt">;</span>
  <span class="hl kwb">int</span> val<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">FibonacciGenerator</span><span class="hl opt">() :</span> <span class="hl kwd">n</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {</span> val<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> val<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwb">int</span> result <span class="hl opt">=</span> n <span class="hl opt">&gt;</span> <span class="hl num">2</span> ? val<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] +</span> val<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] :</span> n <span class="hl opt">&gt;</span> <span class="hl num">0</span> ? <span class="hl num">1</span> <span class="hl opt">:</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl opt">++</span>n<span class="hl opt">;</span>
    val<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> val<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
    val<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> result<span class="hl opt">;</span>
    <span class="hl kwa">return</span> result<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">count</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> n<span class="hl opt">; }</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// FIBONACCIGENERATOR_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.17. C10/FibonacciGenerator.h</strong></p></div><br class="example-break" /><p>
Como es un productor, se usa llamando al operador(), de esta forma:
    </p><div class="example"><a id="idp5137944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:FibonacciGeneratorTest.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;FibonacciGenerator.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  FibonacciGenerator f<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span><span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">20</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
    cout <span class="hl opt">&lt;&lt;</span> f<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">() &lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">f</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.18. C10/FibonacciGeneratorTest.cpp</strong></p></div><br class="example-break" /><p>
A lo mejor le gustaría coger este generador y realizar operaciones de
algoritmos numéricos STL con él. Desafortunadamente, los algoritmos
STL sólo trabajan con iteradores, así que tiene dos interfaces que no
casan. La solución es crear un adaptador que coja el
FibonacciGenerator y produzca un iterador para los algoritmos STL a
usar. Dado que los algoritmos numéricos sólo necesitan un iterador de
entrada, el Adaptador es bastante directo (para algo que produce un
iterador STL, es decir):
    </p><div class="example"><a id="idp5140104"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:FibonacciAdapter.cpp</span>
<span class="hl slc">// Adapting an interface to something you already have.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;numeric&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;FibonacciGenerator.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../C06/PrintSequence.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> FibonacciAdapter <span class="hl opt">{</span> <span class="hl slc">// Produce an iterator</span>
  FibonacciGenerator f<span class="hl opt">;</span>
  <span class="hl kwb">int</span> length<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">FibonacciAdapter</span><span class="hl opt">(</span><span class="hl kwb">int</span> size<span class="hl opt">) :</span> <span class="hl kwd">length</span><span class="hl opt">(</span>size<span class="hl opt">) {}</span>
  <span class="hl kwc">class</span> iterator<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> iterator<span class="hl opt">;</span>
  <span class="hl kwc">class</span> iterator <span class="hl opt">:</span> <span class="hl kwc">public</span> std<span class="hl opt">::</span>iterator<span class="hl opt">&lt;</span>
    std<span class="hl opt">::</span>input_iterator_tag<span class="hl opt">,</span> FibonacciAdapter<span class="hl opt">,</span> <span class="hl kwb">ptrdiff_t</span><span class="hl opt">&gt; {</span>
    FibonacciAdapter<span class="hl opt">&amp;</span> ap<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwc">typedef</span> <span class="hl kwb">int</span> value_type<span class="hl opt">;</span>
    <span class="hl kwd">iterator</span><span class="hl opt">(</span>FibonacciAdapter<span class="hl opt">&amp;</span> a<span class="hl opt">) :</span> <span class="hl kwd">ap</span><span class="hl opt">(</span>a<span class="hl opt">) {}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">==(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> ap<span class="hl opt">.</span>f<span class="hl opt">.</span><span class="hl kwd">count</span><span class="hl opt">() ==</span> ap<span class="hl opt">.</span>length<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">bool</span> <span class="hl kwc">operator</span><span class="hl opt">!=(</span><span class="hl kwb">const</span> iterator<span class="hl opt">&amp;</span> x<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
      <span class="hl kwa">return</span> <span class="hl opt">!(*</span><span class="hl kwa">this</span> <span class="hl opt">==</span> x<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">int</span> <span class="hl kwc">operator</span><span class="hl opt">*()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> ap<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">(); }</span>
    iterator<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">++() {</span> <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">; }</span>
    iterator <span class="hl kwc">operator</span><span class="hl opt">++(</span><span class="hl kwb">int</span><span class="hl opt">) {</span> <span class="hl kwa">return</span> <span class="hl opt">*</span><span class="hl kwa">this</span><span class="hl opt">; }</span>
  <span class="hl opt">};</span>
  iterator <span class="hl kwd">begin</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
  iterator <span class="hl kwd">end</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> <span class="hl kwd">iterator</span><span class="hl opt">(*</span><span class="hl kwa">this</span><span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">;</span>
  FibonacciAdapter <span class="hl kwd">a1</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;accumulate: &quot;</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">accumulate</span><span class="hl opt">(</span>a1<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> a1<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl num">0</span><span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  FibonacciAdapter <span class="hl kwd">a2</span><span class="hl opt">(</span>SZ<span class="hl opt">),</span> <span class="hl kwd">a3</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;inner product: &quot;</span>
    <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">inner_product</span><span class="hl opt">(</span>a2<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> a2<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> a3<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> <span class="hl num">0</span><span class="hl opt">)</span>
    <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  FibonacciAdapter <span class="hl kwd">a4</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  <span class="hl kwb">int</span> r1<span class="hl opt">[</span>SZ<span class="hl opt">] = {</span><span class="hl num">0</span><span class="hl opt">};</span>
  <span class="hl kwb">int</span><span class="hl opt">*</span> end <span class="hl opt">=</span> <span class="hl kwd">partial_sum</span><span class="hl opt">(</span>a4<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> a4<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> r1<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>r1<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;partial_sum&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
  FibonacciAdapter <span class="hl kwd">a5</span><span class="hl opt">(</span>SZ<span class="hl opt">);</span>
  <span class="hl kwb">int</span> r2<span class="hl opt">[</span>SZ<span class="hl opt">] = {</span><span class="hl num">0</span><span class="hl opt">};</span>
  end <span class="hl opt">=</span> <span class="hl kwd">adjacent_difference</span><span class="hl opt">(</span>a5<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> a5<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> r2<span class="hl opt">);</span>
  <span class="hl kwd">print</span><span class="hl opt">(</span>r2<span class="hl opt">,</span> end<span class="hl opt">,</span> <span class="hl str">&quot;adjacent_difference&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot; &quot;</span><span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.19. C10/FibonacciAdapter.cpp</strong></p></div><br class="example-break" /><p>
Se inicializa un FibonacciAdapter diciéndole cuán largo puede ser la
secuencia de Fibonacci. Cuando se crea un iterador, simplemente
captura una referencia al FibonacciAdapter que lo contiene para que
pueda acceder al FibonacciGenerator y la longitud. Observe que la
comparación de equivalencia ignora el valor de la derecha, porque el
único asunto importante es si el generador ha alcanzado su
longitud. Además, el operator++() no modifica el iterador; la única
operación que cambia el estado del FibonacciAdapter es llamar a la
función operator() del generador en el FibonacciGenerator. Puede
aceptarse esta versión extremadamente simple del iterador porque las
restricciones de un Input Iterator son muy estrictas; concretamente,
sólo se puede leer cada valor de la secuencia una vez.
    </p><p>
En main(), puede verse que los cuatro tipos distintos de algoritmos
numéricos se testan satisfactoriamente con el FibonacciAdapter.
    </p></div><div class="sect1" title="9.8. Template Method"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5145976"></a>9.8. Template Method</h2></div></div></div><p>
El marco de trabajo de una aplicación nos permite heredar de una clase
o conjunto de ellas y crear una nueva aplicación, reutilizando la
mayoría del código de las clases existentes y sobreescribiendo una o
más funciones para adaptar la aplicación a nuestras necesidades.
    </p><p>
Una característica importante de Template Method es que está definido
en la clase base (a veces como una función privada) y no puede
cambiarse -el Template Method es lo que permanece invariable. Llama a
otras funciones de clase base (las que se sobreescriben) para hacer su
trabajo, pero el programador cliente no es necesariamente capaz de
llamarlo directamente, como puede verse aquí:
    </p><div class="example"><a id="idp5147888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:TemplateMethod.cpp</span>
<span class="hl slc">// Simple demonstration of Template Method.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> ApplicationFramework <span class="hl opt">{</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">customize1</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">customize2</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">templateMethod</span><span class="hl opt">() {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      <span class="hl kwd">customize1</span><span class="hl opt">();</span>
      <span class="hl kwd">customize2</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Create a new &quot;application&quot;:</span>
<span class="hl kwc">class</span> MyApp <span class="hl opt">:</span> <span class="hl kwc">public</span> ApplicationFramework <span class="hl opt">{</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">customize1</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Hello &quot;</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">customize2</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;World!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  MyApp app<span class="hl opt">;</span>
  app<span class="hl opt">.</span><span class="hl kwd">templateMethod</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.20. C10/TemplateMethod.cpp</strong></p></div><br class="example-break" /><p>
El motor que ejecuta la aplicación es el Template Method. En una
aplicación gráfica, este motor sería el bucle principal de eventos. El
programador cliente simplemente proporciona las definiciones para
customize1() y customize2(), y la aplicación está lista para
ejecutarse.
    </p></div><div class="sect1" title="9.9. Estrategia: elegir el algoritno en tiempo de ejecución"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5150296"></a>9.9. Estrategia: elegir el algoritno en tiempo de ejecución</h2></div></div></div><p>
Observe que el Template Method es el código que no cambia, y las
funciones que sobreescribe son el código cambiante. Sin embargo, este
cambio está fijado en tiempo de compilación, a través de la
herencia. Siguiendo la máxima de preferir composición a herencia, se
puede usar una composición para aproximar el problema de separar
código que cambia de código que permanece, y generar el patrón
Estrategia. Esta aproximación tiene un beneficio único: en tiempo de
ejecución se puede insertar el código que cambia. Estrategia también
añade un Contexto que puede ser una clase sucedánea que controla la
selección y uso del objeto estrategia -¡igual que Estado!.
    </p><p>
Estrategia significa exactamente eso: se puede resolver un problema de
muchas maneras. Imagine que ha olvidado el nombre de alguien. Estas
son las diferentes maneras para lidiar con esa situación:
    </p><div class="example"><a id="idp5152992"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Strategy.cpp</span>
<span class="hl slc">// The Strategy design pattern.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> NameStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> SayHi <span class="hl opt">:</span> <span class="hl kwc">public</span> NameStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Hi! How's it going?&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Ignore <span class="hl opt">:</span> <span class="hl kwc">public</span> NameStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;(Pretend I don't see you)&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Admission <span class="hl opt">:</span> <span class="hl kwc">public</span> NameStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;I'm sorry. I forgot your name.&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// The &quot;Context&quot; controls the strategy:</span>
<span class="hl kwc">class</span> Context <span class="hl opt">{</span>
  NameStrategy<span class="hl opt">&amp;</span> strategy<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Context</span><span class="hl opt">(</span>NameStrategy<span class="hl opt">&amp;</span> strat<span class="hl opt">) :</span> <span class="hl kwd">strategy</span><span class="hl opt">(</span>strat<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">greet</span><span class="hl opt">() {</span> strategy<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">(); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  SayHi sayhi<span class="hl opt">;</span>
  Ignore ignore<span class="hl opt">;</span>
  Admission admission<span class="hl opt">;</span>
  Context <span class="hl kwd">c1</span><span class="hl opt">(</span>sayhi<span class="hl opt">),</span> <span class="hl kwd">c2</span><span class="hl opt">(</span>ignore<span class="hl opt">),</span> <span class="hl kwd">c3</span><span class="hl opt">(</span>admission<span class="hl opt">);</span>
  c1<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
  c2<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
  c3<span class="hl opt">.</span><span class="hl kwd">greet</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.21. C10/Strategy.cpp</strong></p></div><br class="example-break" /><p>
Normalmente, Context::greet() sería más complejo; es el análogo de
Template Method porque contiene el código que no cambia. Pero puede
ver en main() que la elección de la estrategia puede realizarse en
tiempo de ejecución. Llendo un paso más allá, se puede combinar esto
con el patrón Estado y cambiar la Estrategia durante el tiempo de vida
del objeto Contexto.
    </p></div><div class="sect1" title="9.10. Cadena de Responsabilidad: intentar una secuencia de estrategias"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5156064"></a>9.10. Cadena de Responsabilidad: intentar una secuencia de estrategias</h2></div></div></div><p>
Debe pensarse en Cadena de Responsabilidad como en una generalización
dinámica de la recursión, usando objetos Estrategia. Se hace una
llamada y cada Estrategia de la secuencia intenta satisfacer la
llamada. El proceso termina cuando una de las Estrategias tiene éxito
o la cadena termina. En la recursión, una función se llama a sí misma
una y otra vez hasta que se alcanza una condición de finalización; con
Cadena de Responsabilidad, una función se llama a sí misma, la cual
(moviendo la cadena de Estrategias) llama a una implementación
diferente de la función, etc, hasta que se alcanza la condición de
finalización. Dicha condición puede ser que se ha llegado al final de
la cadena (lo que devuelve un objeto por defecto; puede que no sea
capaz de proporcionar un resultado por defecto, así que debe ser capaz
de determinar el éxito o fracaso de la cadena) o que una de las
Estrategias ha tenido éxito.
    </p><p>
En lugar de llamar a una única función para satisfacer una petición,
hay múltiples funciones en la cadetna que tienen la oportunidad de
hacerlo, de manera que tiene el aspecto de un sistema experto. Dado
que la cadena es en la práctica una lista, puede crearse
dinámicamente, así que podría verse como una sentencia <code class="keyword">switch</code>
más general y construida dinámicamente.
    </p><p>
En el GoF, hay bastante discusión sobre cómo crear la cadena de
responsabilidad como una lista enlazada. Sin embargo, cuando se
estudia el patrón, no debería importar cómo se crea la cadena; eso es
un detalle de implementación. Como el GoF se escribió antes de que los
contenedores STL estuvieran disponibles en la mayoría de los
compiladores de C++, las razones más probables son (1) que no había
listas incluídas y por lo tanto tenían que crear una y (2) que las
estructuras de datos suelen verse como una habilidad fundamental en
las Escuelas (o Facultades), y a los autores del GoF no se les ocurrió
la idea de que las estructuras de datos fueran herramientas estándar
disponibles junto con el lenguaje de programación.. Los detalles del
contenedor usado para implementar la Cadena de Responsabilidad como
una cadena (una lista enlazada en el GoF) no añaden nada a la
solución, y puede implementarse usando un contenedor STL, como se
muestra abajo.
    </p><p>
Aquí puede ver una Cadena de Responsabilidad que encuentra
automáticamente una solución usando un mecanismo para recorrer
automática y recursivamente cada Estrategia de la cadena:
    </p><div class="example"><a id="idp5162752"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:ChainOfReponsibility.cpp</span>
<span class="hl slc">// The approach of the five-year-old.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">enum</span> Answer <span class="hl opt">{</span> NO<span class="hl opt">,</span> YES <span class="hl opt">};</span>

<span class="hl kwc">class</span> GimmeStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> Answer <span class="hl kwd">canIHave</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">GimmeStrategy</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> AskMom <span class="hl opt">:</span> <span class="hl kwc">public</span> GimmeStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Answer <span class="hl kwd">canIHave</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Mooom? Can I have this?&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> NO<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> AskDad <span class="hl opt">:</span> <span class="hl kwc">public</span> GimmeStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Answer <span class="hl kwd">canIHave</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Dad, I really need this!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> NO<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> AskGrandpa <span class="hl opt">:</span> <span class="hl kwc">public</span> GimmeStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Answer <span class="hl kwd">canIHave</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Grandpa, is it my birthday yet?&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> NO<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> AskGrandma <span class="hl opt">:</span> <span class="hl kwc">public</span> GimmeStrategy <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Answer <span class="hl kwd">canIHave</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Grandma, I really love you!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> YES<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Gimme <span class="hl opt">:</span> <span class="hl kwc">public</span> GimmeStrategy <span class="hl opt">{</span>
  vector<span class="hl opt">&lt;</span>GimmeStrategy<span class="hl opt">*&gt;</span> chain<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Gimme</span><span class="hl opt">() {</span>
    chain<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">AskMom</span><span class="hl opt">());</span>
    chain<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">AskDad</span><span class="hl opt">());</span>
    chain<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">AskGrandpa</span><span class="hl opt">());</span>
    chain<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">AskGrandma</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
  Answer <span class="hl kwd">canIHave</span><span class="hl opt">() {</span>
    vector<span class="hl opt">&lt;</span>GimmeStrategy<span class="hl opt">*&gt;::</span>iterator it <span class="hl opt">=</span> chain<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> chain<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
      <span class="hl kwa">if</span><span class="hl opt">((*</span>it<span class="hl opt">++)-&gt;</span><span class="hl kwd">canIHave</span><span class="hl opt">() ==</span> YES<span class="hl opt">)</span>
        <span class="hl kwa">return</span> YES<span class="hl opt">;</span>
    <span class="hl slc">// Reached end without success...</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Whiiiiinnne!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> NO<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">Gimme</span><span class="hl opt">() {</span> <span class="hl kwd">purge</span><span class="hl opt">(</span>chain<span class="hl opt">); }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Gimme chain<span class="hl opt">;</span>
  chain<span class="hl opt">.</span><span class="hl kwd">canIHave</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.22. C10/ChainOfReponsibility.cpp</strong></p></div><br class="example-break" /><p>
Observe que la clase de Contexto Gimme y todas las clases Estrategia
derivan de la misma clase base, GimmeStrategy.
    </p><p>
Si estudia la sección sobre Cadena de Responsabilidad del GoF, verá
que la estructura difiere significativamente de la que se muestra más
arriba, porque ellos se centran en crear su propia lista enlazada. Sin
embargo, si mantiene en mente que la esencia de Cadena de
Responsabilidad es probar muchas soluciones hasta que encuentre la que
funciona, se dará cuenta de que la implementación del mecanismo de
secuenciación no es parte esencial del patrón.
    </p></div><div class="sect1" title="9.11. Factorías: encapsular la creación de objetos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5166728"></a>9.11. Factorías: encapsular la creación de objetos</h2></div></div></div><p>
Cuando se descubre que se necesitan añadir nuevos tipos a un sistema,
el primer paso más sensato es usar polimorfismo para crear una
interfaz común para esos nuevos tipos. Así, se separa el resto del
código en el sistema del conocimiento de los tipos específicos que se
están añadiendo. Los tipos nuevos pueden añadirse sin "molestar" al
código existente, o eso parece. A primera vista, podría parecer que
hace falta cambiar el código únicamente en los lugares donde se hereda
un tipo nuevo, pero esto no es del todo cierto. Todavía hay que crear
un objeto de este nuevo tipo, y en el momento de la creación hay que
especificar qué constructor usar. Por lo tanto, si el codigo que crea
objetos está distribuido por toda la aplicación, se obtiene el mismo
problema que cuando se añaden tipos -hay que localizar todos los
puntos del código donde el tipo tiene importancia. Lo que imoporta es
la creación del tipo, más que el uso del mismo (de eso se encarga el
polimorfismo), pero el efecto es el mismo: añadir un nuevo tipo puede
causar problemas.
    </p><p>
La solución es forzar a que la creación de objetos se lleve a cabo a
través de una factoría común, en lugar de permitir que el código
creacional se disperse por el sistema. Si todo el código del programa
debe ir a esta factoría cada vez que necesita crear uno de esos
objetos, todo lo que hay que hacer para añadir un objeto es modificar
la factoría. Este diseño es una variación del patrón conocido
comúnmente como Factory Method. Dado que todo programa orientado a
objetos crea objetos, y como es probable que haya que extender el
programa añadiendo nuevos tipos, las factorías pueden ser el más útil
de todos los patrones de diseño.
    </p><p>
Como ejemplo, considere el ampliamente usado ejemplo de figura
(Shape). Una aproximación para implementar una factoría es definir una
función miembro estática en la clase base:
    </p><div class="example"><a id="idp5171424"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:ShapeFactory1.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Shape</span><span class="hl opt">() {}</span>
  <span class="hl kwc">class</span> BadShapeCreation <span class="hl opt">:</span> <span class="hl kwc">public</span> logic_error <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">BadShapeCreation</span><span class="hl opt">(</span>string type<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">logic_error</span><span class="hl opt">(</span><span class="hl str">&quot;Cannot create type &quot;</span> <span class="hl opt">+</span> type<span class="hl opt">) {}</span>
  <span class="hl opt">};</span>
  <span class="hl kwb">static</span> Shape<span class="hl opt">*</span> <span class="hl kwd">factory</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> type<span class="hl opt">)</span>
    <span class="hl kwa">throw</span><span class="hl opt">(</span>BadShapeCreation<span class="hl opt">);</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Circle <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
  <span class="hl kwd">Circle</span><span class="hl opt">() {}</span> <span class="hl slc">// Private constructor</span>
  <span class="hl kwc">friend class</span> Shape<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::draw&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::erase&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Circle</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::~Circle&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Square <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
  <span class="hl kwd">Square</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend class</span> Shape<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::draw&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::erase&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Square</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::~Square&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

Shape<span class="hl opt">*</span> Shape<span class="hl opt">::</span><span class="hl kwd">factory</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> type<span class="hl opt">)</span>
  <span class="hl kwa">throw</span><span class="hl opt">(</span>Shape<span class="hl opt">::</span>BadShapeCreation<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>type <span class="hl opt">==</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">)</span> <span class="hl kwa">return new</span> Circle<span class="hl opt">;</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>type <span class="hl opt">==</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">)</span> <span class="hl kwa">return new</span> Square<span class="hl opt">;</span>
  <span class="hl kwa">throw</span> <span class="hl kwd">BadShapeCreation</span><span class="hl opt">(</span>type<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">char</span><span class="hl opt">*</span> sl<span class="hl opt">[] = {</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span> <span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Shape<span class="hl opt">*&gt;</span> shapes<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwa">sizeof</span> sl <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> sl<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span> i<span class="hl opt">++)</span>
      shapes<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>Shape<span class="hl opt">::</span><span class="hl kwd">factory</span><span class="hl opt">(</span>sl<span class="hl opt">[</span>i<span class="hl opt">]));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Shape<span class="hl opt">::</span>BadShapeCreation e<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">purge</span><span class="hl opt">(</span>shapes<span class="hl opt">);</span>
    <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> shapes<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++) {</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">draw</span><span class="hl opt">();</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">erase</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>shapes<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.23. C10/ShapeFactory1.cpp</strong></p></div><br class="example-break" /><p>
La función factory() toma un argumento que le permite determinar qué
tipo de figura crear. Aquí, el argumento es una cadena, pero podría
ser cualquier conjunto de datos. El método factory() es el único
código del sistema que hay que cambiar cuando se añade un nuevo tipo
de figura. (Los datos de inicialización para los objetos vendrán
supuestamente de algún sitio fuera del sistema y no serán un FIXME:
hard-coded array como en el ejemplo.)
    </p><p>
Para asegurar que la creación sólo puede realizarse en factory(), los
constructores de cada tipo específico de figura se hacen privados, y
Shape se declara como <code class="keyword">friend</code> de forma que factory() tiene
acceso a los mismos. (También se podría declarar sólamente
Shape::factory() como
<code class="keyword">friend</code>, pero parece razonablemente inocuo declarar la clase base
entera.) Hay otra implicación importante de este diseño -la clase base, Shape,
debe conocer ahora los detalles de todas las clases derivadas -una propiedad
que el diseño orientado a objetos intenta evitar. Para <code class="keyword">frameworks</code> o
cualquier librería de clases que deban poder extenderse, esto hace que se
convierta rápidamente en algo difícil de manejar, ya que la clase base debe
actualizarse en cuanto se añada un tipo nuevo a la jerarquía. Las factorías
polimórficas, descritas en la siguiente subsección, se pueden usar para
evitar esta dependencia circular tan poco deseada.
    </p><div class="sect2" title="9.11.1. Factorías polimórficas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5179064"></a>9.11.1. Factorías polimórficas</h3></div></div></div><p>
La función estática factory() en el ejemplo anterior fuerza que las
operaciones de creación se centren en un punto, de forma que sea el
único sitio en el que haya que cambiar código. Esto es, sin duda, una
solución razonable, ya que encapsula amablemente el proceso de crear
objetos. Sin embargo, el GoF enfatiza que la razón de ser del patrón
Factory Method es que diferentes tipos de factorías se puedan derivar
de la factoría básica. Factory Method es, de hecho, un tipo especial
de factoría polimórfica. Esto es ShapeFactory1.cpp modificado para que
los Factory Methods estén en una clase aparte como funciones
virtuales.
      </p><div class="example"><a id="idp5180952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:ShapeFactory2.cpp</span>
<span class="hl slc">// Polymorphic Factory Methods.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;map&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Shape <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Shape</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> ShapeFactory <span class="hl opt">{</span>
  <span class="hl kwc">virtual</span> Shape<span class="hl opt">*</span> <span class="hl kwd">create</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">static</span> map<span class="hl opt">&lt;</span>string<span class="hl opt">,</span> ShapeFactory<span class="hl opt">*&gt;</span> factories<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">ShapeFactory</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend class</span> ShapeFactoryInitializer<span class="hl opt">;</span>
  <span class="hl kwc">class</span> BadShapeCreation <span class="hl opt">:</span> <span class="hl kwc">public</span> logic_error <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">BadShapeCreation</span><span class="hl opt">(</span>string type<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">logic_error</span><span class="hl opt">(</span><span class="hl str">&quot;Cannot create type &quot;</span> <span class="hl opt">+</span> type<span class="hl opt">) {}</span>
  <span class="hl opt">};</span>
  <span class="hl kwb">static</span> Shape<span class="hl opt">*</span>
  <span class="hl kwd">createShape</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> id<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>BadShapeCreation<span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>factories<span class="hl opt">.</span><span class="hl kwd">find</span><span class="hl opt">(</span>id<span class="hl opt">) !=</span> factories<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
      <span class="hl kwa">return</span> factories<span class="hl opt">[</span>id<span class="hl opt">]-&gt;</span><span class="hl kwd">create</span><span class="hl opt">();</span>
    <span class="hl kwa">else</span>
      <span class="hl kwa">throw</span> <span class="hl kwd">BadShapeCreation</span><span class="hl opt">(</span>id<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Define the static object:</span>
map<span class="hl opt">&lt;</span>string<span class="hl opt">,</span> ShapeFactory<span class="hl opt">*&gt;</span> ShapeFactory<span class="hl opt">::</span>factories<span class="hl opt">;</span>

<span class="hl kwc">class</span> Circle <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
  <span class="hl kwd">Circle</span><span class="hl opt">() {}</span> <span class="hl slc">// Private constructor</span>
  <span class="hl kwc">friend class</span> ShapeFactoryInitializer<span class="hl opt">;</span>
  <span class="hl kwc">class</span> Factory<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Factory<span class="hl opt">;</span>
  <span class="hl kwc">class</span> Factory <span class="hl opt">:</span> <span class="hl kwc">public</span> ShapeFactory <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    Shape<span class="hl opt">*</span> <span class="hl kwd">create</span><span class="hl opt">() {</span> <span class="hl kwa">return new</span> Circle<span class="hl opt">; }</span>
    <span class="hl kwc">friend class</span> ShapeFactoryInitializer<span class="hl opt">;</span>
  <span class="hl opt">};</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::draw&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::erase&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Circle</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::~Circle&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Square <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
  <span class="hl kwd">Square</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend class</span> ShapeFactoryInitializer<span class="hl opt">;</span>
  <span class="hl kwc">class</span> Factory<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Factory<span class="hl opt">;</span>
  <span class="hl kwc">class</span> Factory <span class="hl opt">:</span> <span class="hl kwc">public</span> ShapeFactory <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    Shape<span class="hl opt">*</span> <span class="hl kwd">create</span><span class="hl opt">() {</span> <span class="hl kwa">return new</span> Square<span class="hl opt">; }</span>
    <span class="hl kwc">friend class</span> ShapeFactoryInitializer<span class="hl opt">;</span>
  <span class="hl opt">};</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::draw&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::erase&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">Square</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::~Square&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// Singleton to initialize the ShapeFactory:</span>
<span class="hl kwc">class</span> ShapeFactoryInitializer <span class="hl opt">{</span>
  <span class="hl kwb">static</span> ShapeFactoryInitializer si<span class="hl opt">;</span>
  <span class="hl kwd">ShapeFactoryInitializer</span><span class="hl opt">() {</span>
    ShapeFactory<span class="hl opt">::</span>factories<span class="hl opt">[</span><span class="hl str">&quot;Circle&quot;</span><span class="hl opt">]=</span> <span class="hl kwa">new</span> Circle<span class="hl opt">::</span>Factory<span class="hl opt">;</span>
    ShapeFactory<span class="hl opt">::</span>factories<span class="hl opt">[</span><span class="hl str">&quot;Square&quot;</span><span class="hl opt">]=</span> <span class="hl kwa">new</span> Square<span class="hl opt">::</span>Factory<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">ShapeFactoryInitializer</span><span class="hl opt">() {</span>
    map<span class="hl opt">&lt;</span>string<span class="hl opt">,</span> ShapeFactory<span class="hl opt">*&gt;::</span>iterator it <span class="hl opt">=</span>
      ShapeFactory<span class="hl opt">::</span>factories<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> ShapeFactory<span class="hl opt">::</span>factories<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">())</span>
      <span class="hl kwa">delete</span> it<span class="hl opt">++-&gt;</span>second<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Static member definition:</span>
ShapeFactoryInitializer ShapeFactoryInitializer<span class="hl opt">::</span>si<span class="hl opt">;</span>

<span class="hl kwb">char</span><span class="hl opt">*</span> sl<span class="hl opt">[] = {</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span> <span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Shape<span class="hl opt">*&gt;</span> shapes<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwa">sizeof</span> sl <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> sl<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span> i<span class="hl opt">++)</span>
      shapes<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>ShapeFactory<span class="hl opt">::</span><span class="hl kwd">createShape</span><span class="hl opt">(</span>sl<span class="hl opt">[</span>i<span class="hl opt">]));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>ShapeFactory<span class="hl opt">::</span>BadShapeCreation e<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> shapes<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++) {</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">draw</span><span class="hl opt">();</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">erase</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>shapes<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.24. C10/ShapeFactory2.cpp</strong></p></div><br class="example-break" /><p>
Ahora, Factory Method aparece en su propia clase, ShapeFactory,
como <code class="keyword"> virtual create()</code>. Es una función miembro privada, lo
que significa que no puede ser llamada directametne, pero puede ser
sobreescrita. Las subclases de Shape deben crear cada una su propias
subclases de ShapeFactory y sobreescribir el método create para crear
un objeto de su propio tipe. Estas factorías son privadas, de forma
que sólo pueden ser accedidas desde el Factory Method principal. De
esta forma, todo el código cliente debe pasar a través del Factory
Method para crear objetos.
      </p><p>
La verdadera creación de figuras se realiza llamando a
ShapeFactory::createShape( ), que es una función estática que usa el
mapa en ShapeFactory para encontrar la objeto factoría apropiado
basándose en el identificador que se le pasa. La factoría crea el
objeto figura directamente, pero podría imaginarse un problema más
complejo en el que el objeto factoría apropiado se devuelve y luego lo
usa quien lo ha llamado para crear un objeto de una manera más
sofisticada. Sin embargo, parece que la mayoría del tiempo no hacen
falta las complejidades del Factory Method polimórfico, y bastará con
una única función estática en la clase base (como se muestra en
ShapeFactory1.cpp).
      </p><p>
		Observe que el ShapeFactory debe ser inicializado cargando su
mapa con objetos factory, lo que tiene lugar en el Singleton
ShapeFactoryInitializer. Así que para añadir un nuevo tipo a este
diseño debe definir el tipo, crear una factoría, y modificar
ShapeFactoryInitializer para que se inserte una instancia de su
factoría en el mapa. Esta complejidad extra, sugiere de nuevo el uso
de un Factory Method estático si no necesita crear objetos factoría
individuales.
      </p></div><div class="sect2" title="9.11.2. Factorías abstractas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5188864"></a>9.11.2. Factorías abstractas</h3></div></div></div><p>
		El patrón Factoría Abstracta se parece a las factorías que
hemos visto anteriormente, pero con varios Factory Methods. Cada uno
de los Factory Method crea una clase distinta de objeto. Cuando se
crea el objecto factoría, se decide cómo se usarán todos los objetos
creados con esa factoría. El ejemplo del GoF implementa la
portabilidad a través de varias interfaces gráficas de usuario (GUI):
se crea el objeto factoría apropiado para la GUI con la que se está
trabajando y desde ahí en adelante, cuando le pida un menú, botón,
barra deslizante y demás, creará automáticamente la versión apropiada
para la GUI de ese elemento. Por lo tanto, es posible aislar, en un
solo lugar, el efecto de cambiar de una GUI a otra.
      </p><p>
		Por ejemplo, suponga que está creando un entorno para juegos
de propósito general y quiere ser capaz de soportar diferentes tipos
de juegos. Así es como sería usando una Factoría Abstracta:
      </p><div class="example"><a id="idp5191552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:AbstractFactory.cpp</span>
<span class="hl slc">// A gaming environment.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Obstacle <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">action</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Player <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">interactWith</span><span class="hl opt">(</span>Obstacle<span class="hl opt">*) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Kitty<span class="hl opt">:</span> <span class="hl kwc">public</span> Player <span class="hl opt">{</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">interactWith</span><span class="hl opt">(</span>Obstacle<span class="hl opt">*</span> ob<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Kitty has encountered a &quot;</span><span class="hl opt">;</span>
    ob<span class="hl opt">-&gt;</span><span class="hl kwd">action</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> KungFuGuy<span class="hl opt">:</span> <span class="hl kwc">public</span> Player <span class="hl opt">{</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">interactWith</span><span class="hl opt">(</span>Obstacle<span class="hl opt">*</span> ob<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;KungFuGuy now battles against a &quot;</span><span class="hl opt">;</span>
    ob<span class="hl opt">-&gt;</span><span class="hl kwd">action</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Puzzle<span class="hl opt">:</span> <span class="hl kwc">public</span> Obstacle <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">action</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Puzzle&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> NastyWeapon<span class="hl opt">:</span> <span class="hl kwc">public</span> Obstacle <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">action</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;NastyWeapon&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl slc">// The abstract factory:</span>
<span class="hl kwc">class</span> GameElementFactory <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> Player<span class="hl opt">*</span> <span class="hl kwd">makePlayer</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Obstacle<span class="hl opt">*</span> <span class="hl kwd">makeObstacle</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl slc">// Concrete factories:</span>
<span class="hl kwc">class</span> KittiesAndPuzzles <span class="hl opt">:</span> <span class="hl kwc">public</span> GameElementFactory <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> Player<span class="hl opt">*</span> <span class="hl kwd">makePlayer</span><span class="hl opt">() {</span> <span class="hl kwa">return new</span> Kitty<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> Obstacle<span class="hl opt">*</span> <span class="hl kwd">makeObstacle</span><span class="hl opt">() {</span> <span class="hl kwa">return new</span> Puzzle<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> KillAndDismember <span class="hl opt">:</span> <span class="hl kwc">public</span> GameElementFactory <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> Player<span class="hl opt">*</span> <span class="hl kwd">makePlayer</span><span class="hl opt">() {</span> <span class="hl kwa">return new</span> KungFuGuy<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> Obstacle<span class="hl opt">*</span> <span class="hl kwd">makeObstacle</span><span class="hl opt">() {</span>
    <span class="hl kwa">return new</span> NastyWeapon<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> GameEnvironment <span class="hl opt">{</span>
  GameElementFactory<span class="hl opt">*</span> gef<span class="hl opt">;</span>
  Player<span class="hl opt">*</span> p<span class="hl opt">;</span>
  Obstacle<span class="hl opt">*</span> ob<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">GameEnvironment</span><span class="hl opt">(</span>GameElementFactory<span class="hl opt">*</span> factory<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">gef</span><span class="hl opt">(</span>factory<span class="hl opt">),</span> <span class="hl kwd">p</span><span class="hl opt">(</span>factory<span class="hl opt">-&gt;</span><span class="hl kwd">makePlayer</span><span class="hl opt">()),</span>
    <span class="hl kwd">ob</span><span class="hl opt">(</span>factory<span class="hl opt">-&gt;</span><span class="hl kwd">makeObstacle</span><span class="hl opt">()) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">play</span><span class="hl opt">() {</span> p<span class="hl opt">-&gt;</span><span class="hl kwd">interactWith</span><span class="hl opt">(</span>ob<span class="hl opt">); }</span>
  <span class="hl opt">~</span><span class="hl kwd">GameEnvironment</span><span class="hl opt">() {</span>
    <span class="hl kwa">delete</span> p<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> ob<span class="hl opt">;</span>
    <span class="hl kwa">delete</span> gef<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  GameEnvironment
    <span class="hl kwd">g1</span><span class="hl opt">(</span><span class="hl kwa">new</span> KittiesAndPuzzles<span class="hl opt">),</span>
    <span class="hl kwd">g2</span><span class="hl opt">(</span><span class="hl kwa">new</span> KillAndDismember<span class="hl opt">);</span>
  g1<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">();</span>
  g2<span class="hl opt">.</span><span class="hl kwd">play</span><span class="hl opt">();</span>
<span class="hl opt">}</span>
<span class="hl com">/* Output:</span>
<span class="hl com">Kitty has encountered a Puzzle</span>
<span class="hl com">KungFuGuy now battles against a NastyWeapon */</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.25. C10/AbstractFactory.cpp</strong></p></div><br class="example-break" /><p>
		En este entorno, los objetos Player interactúan con objetos
Obstacle, pero los tipos de los jugadores y los obstáculos dependen
del juego. El tipo de juego se determina eligiendo un
GameElementFactory concreto, y luego el GameEnvironment controla la
configuración y ejecución del juego. En este ejemplo, la configuración
y ejecución son simples, pero dichas actividades (las condiciones
iniciales y los cambios de estado) pueden determinar gran parte del
resultado del juego. Aquí, GameEnvironment no está diseñado para ser
heredado, aunque puede tener sentido hacerlo.
      </p><p>
		Este ejemplo también ilustra el despachado doble, que se
explicará más adelante.
      </p></div><div class="sect2" title="9.11.3. Constructores virtuales"><div class="titlepage"><div><div><h3 class="title"><a id="idp5196688"></a>9.11.3. Constructores virtuales</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp5198160"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:VirtualConstructor.cpp</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;stdexcept&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Shape <span class="hl opt">{</span>
  Shape<span class="hl opt">*</span> s<span class="hl opt">;</span>
  <span class="hl slc">// Prevent copy-construction &amp; operator=</span>
  <span class="hl kwd">Shape</span><span class="hl opt">(</span>Shape<span class="hl opt">&amp;);</span>
  Shape <span class="hl kwc">operator</span><span class="hl opt">=(</span>Shape<span class="hl opt">&amp;);</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwd">Shape</span><span class="hl opt">() {</span> s <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> s<span class="hl opt">-&gt;</span><span class="hl kwd">draw</span><span class="hl opt">(); }</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> s<span class="hl opt">-&gt;</span><span class="hl kwd">erase</span><span class="hl opt">(); }</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">test</span><span class="hl opt">() {</span> s<span class="hl opt">-&gt;</span><span class="hl kwd">test</span><span class="hl opt">(); }</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Shape</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~Shape&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>s<span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Making virtual call: &quot;</span><span class="hl opt">;</span>
      s<span class="hl opt">-&gt;</span><span class="hl kwd">erase</span><span class="hl opt">();</span> <span class="hl slc">// Virtual call</span>
    <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;delete s: &quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">delete</span> s<span class="hl opt">;</span> <span class="hl slc">// The polymorphic deletion</span>
    <span class="hl slc">// (delete 0 is legal; it produces a no-op)</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">class</span> BadShapeCreation <span class="hl opt">:</span> <span class="hl kwc">public</span> logic_error <span class="hl opt">{</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">BadShapeCreation</span><span class="hl opt">(</span>string type<span class="hl opt">)</span>
    <span class="hl opt">:</span> <span class="hl kwd">logic_error</span><span class="hl opt">(</span><span class="hl str">&quot;Cannot create type &quot;</span> <span class="hl opt">+</span> type<span class="hl opt">) {}</span>
  <span class="hl opt">};</span>
  <span class="hl kwd">Shape</span><span class="hl opt">(</span>string type<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>BadShapeCreation<span class="hl opt">);</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Circle <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
  <span class="hl kwd">Circle</span><span class="hl opt">(</span>Circle<span class="hl opt">&amp;);</span>
  Circle <span class="hl kwc">operator</span><span class="hl opt">=(</span>Circle<span class="hl opt">&amp;);</span>
  <span class="hl kwd">Circle</span><span class="hl opt">() {}</span> <span class="hl slc">// Private constructor</span>
  <span class="hl kwc">friend class</span> Shape<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::draw&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::erase&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">test</span><span class="hl opt">() {</span> <span class="hl kwd">draw</span><span class="hl opt">(); }</span>
  <span class="hl opt">~</span><span class="hl kwd">Circle</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Circle::~Circle&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Square <span class="hl opt">:</span> <span class="hl kwc">public</span> Shape <span class="hl opt">{</span>
  <span class="hl kwd">Square</span><span class="hl opt">(</span>Square<span class="hl opt">&amp;);</span>
  Square <span class="hl kwc">operator</span><span class="hl opt">=(</span>Square<span class="hl opt">&amp;);</span>
  <span class="hl kwd">Square</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend class</span> Shape<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">draw</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::draw&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">erase</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::erase&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">test</span><span class="hl opt">() {</span> <span class="hl kwd">draw</span><span class="hl opt">(); }</span>
  <span class="hl opt">~</span><span class="hl kwd">Square</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Square::~Square&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
<span class="hl opt">};</span>

Shape<span class="hl opt">::</span><span class="hl kwd">Shape</span><span class="hl opt">(</span>string type<span class="hl opt">)</span> <span class="hl kwa">throw</span><span class="hl opt">(</span>Shape<span class="hl opt">::</span>BadShapeCreation<span class="hl opt">) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>type <span class="hl opt">==</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">)</span>
    s <span class="hl opt">=</span> <span class="hl kwa">new</span> Circle<span class="hl opt">;</span>
  <span class="hl kwa">else if</span><span class="hl opt">(</span>type <span class="hl opt">==</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">)</span>
    s <span class="hl opt">=</span> <span class="hl kwa">new</span> Square<span class="hl opt">;</span>
  <span class="hl kwa">else throw</span> <span class="hl kwd">BadShapeCreation</span><span class="hl opt">(</span>type<span class="hl opt">);</span>
  <span class="hl kwd">draw</span><span class="hl opt">();</span>  <span class="hl slc">// Virtual call in the constructor</span>
<span class="hl opt">}</span>

<span class="hl kwb">char</span><span class="hl opt">*</span> sl<span class="hl opt">[] = {</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Circle&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Square&quot;</span> <span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  vector<span class="hl opt">&lt;</span>Shape<span class="hl opt">*&gt;</span> shapes<span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;virtual constructor calls:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl kwa">sizeof</span> sl <span class="hl opt">/</span> <span class="hl kwa">sizeof</span> sl<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span> i<span class="hl opt">++)</span>
      shapes<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Shape</span><span class="hl opt">(</span>sl<span class="hl opt">[</span>i<span class="hl opt">]));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Shape<span class="hl opt">::</span>BadShapeCreation e<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">purge</span><span class="hl opt">(</span>shapes<span class="hl opt">);</span>
    <span class="hl kwa">return</span> EXIT_FAILURE<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> shapes<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span> i<span class="hl opt">++) {</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">draw</span><span class="hl opt">();</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;test&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">test</span><span class="hl opt">();</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;end test&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    shapes<span class="hl opt">[</span>i<span class="hl opt">]-&gt;</span><span class="hl kwd">erase</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  Shape <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl str">&quot;Circle&quot;</span><span class="hl opt">);</span> <span class="hl slc">// Create on the stack</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;destructor calls:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>shapes<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.26. C10/VirtualConstructor.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="9.12. Builder: creación de objetos complejos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5206568"></a>9.12. Builder: creación de objetos complejos</h2></div></div></div><p>

    </p><p>

    </p><div class="example"><a id="idp5207360"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Bicycle.h</span>
<span class="hl slc">// Defines classes to build bicycles;</span>
<span class="hl slc">// Illustrates the Builder design pattern.</span>
<span class="hl ppc">#ifndef BICYCLE_H</span>
<span class="hl ppc">#define BICYCLE_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using</span> std<span class="hl opt">::</span><span class="hl kwb">size_t</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> BicyclePart <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">enum</span> BPart <span class="hl opt">{</span> FRAME<span class="hl opt">,</span> WHEEL<span class="hl opt">,</span> SEAT<span class="hl opt">,</span> DERAILLEUR<span class="hl opt">,</span>
    HANDLEBAR<span class="hl opt">,</span> SPROCKET<span class="hl opt">,</span> RACK<span class="hl opt">,</span> SHOCK<span class="hl opt">,</span> NPARTS <span class="hl opt">};</span>
<span class="hl kwc">private</span><span class="hl opt">:</span>
  BPart id<span class="hl opt">;</span>
  <span class="hl kwb">static</span> std<span class="hl opt">::</span>string names<span class="hl opt">[</span>NPARTS<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BPart bp<span class="hl opt">) {</span> id <span class="hl opt">=</span> bp<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> BicyclePart<span class="hl opt">&amp;</span> bp<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> bp<span class="hl opt">.</span>names<span class="hl opt">[</span>bp<span class="hl opt">.</span>id<span class="hl opt">];</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bicycle <span class="hl opt">{</span>
  std<span class="hl opt">::</span>vector<span class="hl opt">&lt;</span>BicyclePart<span class="hl opt">*&gt;</span> parts<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl opt">~</span><span class="hl kwd">Bicycle</span><span class="hl opt">() {</span> <span class="hl kwd">purge</span><span class="hl opt">(</span>parts<span class="hl opt">); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addPart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">*</span> bp<span class="hl opt">) {</span> parts<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>bp<span class="hl opt">); }</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Bicycle<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;{ &quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> b<span class="hl opt">.</span>parts<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
      os <span class="hl opt">&lt;&lt; *</span>b<span class="hl opt">.</span>parts<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> <span class="hl str">' '</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">'}'</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> BicycleBuilder <span class="hl opt">{</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  Bicycle<span class="hl opt">*</span> product<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">BicycleBuilder</span><span class="hl opt">() {</span> product <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">createProduct</span><span class="hl opt">() {</span> product <span class="hl opt">=</span> <span class="hl kwa">new</span> Bicycle<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildFrame</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildWheel</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildSeat</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildDerailleur</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildHandlebar</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildSprocket</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildRack</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">buildShock</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> std<span class="hl opt">::</span>string <span class="hl kwd">getBikeName</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  Bicycle<span class="hl opt">*</span> <span class="hl kwd">getProduct</span><span class="hl opt">() {</span>
    Bicycle<span class="hl opt">*</span> temp <span class="hl opt">=</span> product<span class="hl opt">;</span>
    product <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>  <span class="hl slc">// Relinquish product</span>
    <span class="hl kwa">return</span> temp<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> MountainBikeBuilder <span class="hl opt">:</span> <span class="hl kwc">public</span> BicycleBuilder <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildFrame</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildWheel</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildSeat</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildDerailleur</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildHandlebar</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildSprocket</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildRack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildShock</span><span class="hl opt">();</span>
  std<span class="hl opt">::</span>string <span class="hl kwd">getBikeName</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;MountainBike&quot;</span><span class="hl opt">;}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> TouringBikeBuilder <span class="hl opt">:</span> <span class="hl kwc">public</span> BicycleBuilder <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildFrame</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildWheel</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildSeat</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildDerailleur</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildHandlebar</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildSprocket</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildRack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildShock</span><span class="hl opt">();</span>
  std<span class="hl opt">::</span>string <span class="hl kwd">getBikeName</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;TouringBike&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> RacingBikeBuilder <span class="hl opt">:</span> <span class="hl kwc">public</span> BicycleBuilder <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildFrame</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildWheel</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildSeat</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildDerailleur</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildHandlebar</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildSprocket</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildRack</span><span class="hl opt">();</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buildShock</span><span class="hl opt">();</span>
  std<span class="hl opt">::</span>string <span class="hl kwd">getBikeName</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> <span class="hl str">&quot;RacingBike&quot;</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> BicycleTechnician <span class="hl opt">{</span>
  BicycleBuilder<span class="hl opt">*</span> builder<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">BicycleTechnician</span><span class="hl opt">() {</span> builder <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">setBuilder</span><span class="hl opt">(</span>BicycleBuilder<span class="hl opt">*</span> b<span class="hl opt">) {</span> builder <span class="hl opt">=</span> b<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">construct</span><span class="hl opt">();</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// BICYCLE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.27. C10/Bicycle.h</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp5214240"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Bicycle.cpp {O} {-mwcc}</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Bicycle.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;cassert&gt;</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

std<span class="hl opt">::</span>string BicyclePart<span class="hl opt">::</span>names<span class="hl opt">[</span>NPARTS<span class="hl opt">] = {</span>
  <span class="hl str">&quot;Frame&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Wheel&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Seat&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Derailleur&quot;</span><span class="hl opt">,</span>
  <span class="hl str">&quot;Handlebar&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Sprocket&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Rack&quot;</span><span class="hl opt">,</span> <span class="hl str">&quot;Shock&quot;</span> <span class="hl opt">};</span>

<span class="hl slc">// MountainBikeBuilder implementation</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildFrame</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>FRAME<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildWheel</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>WHEEL<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildSeat</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SEAT<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildDerailleur</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span>
    <span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>DERAILLEUR<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildHandlebar</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span>
    <span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>HANDLEBAR<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildSprocket</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SPROCKET<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildRack</span><span class="hl opt">() {}</span>
<span class="hl kwb">void</span> MountainBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildShock</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SHOCK<span class="hl opt">));</span>
<span class="hl opt">}</span>

<span class="hl slc">// TouringBikeBuilder implementation</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildFrame</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>FRAME<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildWheel</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>WHEEL<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildSeat</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SEAT<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildDerailleur</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span>
    <span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>DERAILLEUR<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildHandlebar</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span>
    <span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>HANDLEBAR<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildSprocket</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SPROCKET<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildRack</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>RACK<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> TouringBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildShock</span><span class="hl opt">() {}</span>

<span class="hl slc">// RacingBikeBuilder implementation</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildFrame</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>FRAME<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildWheel</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>WHEEL<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildSeat</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SEAT<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildDerailleur</span><span class="hl opt">() {}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildHandlebar</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span>
    <span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>HANDLEBAR<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildSprocket</span><span class="hl opt">() {</span>
  product<span class="hl opt">-&gt;</span><span class="hl kwd">addPart</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">BicyclePart</span><span class="hl opt">(</span>BicyclePart<span class="hl opt">::</span>SPROCKET<span class="hl opt">));</span>
<span class="hl opt">}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildRack</span><span class="hl opt">() {}</span>
<span class="hl kwb">void</span> RacingBikeBuilder<span class="hl opt">::</span><span class="hl kwd">buildShock</span><span class="hl opt">() {}</span>

<span class="hl slc">// BicycleTechnician implementation</span>
<span class="hl kwb">void</span> BicycleTechnician<span class="hl opt">::</span><span class="hl kwd">construct</span><span class="hl opt">() {</span>
  <span class="hl kwa">assert</span><span class="hl opt">(</span>builder<span class="hl opt">);</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">createProduct</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildFrame</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildWheel</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildSeat</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildDerailleur</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildHandlebar</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildSprocket</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildRack</span><span class="hl opt">();</span>
  builder<span class="hl opt">-&gt;</span><span class="hl kwd">buildShock</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.28. C10/Bicycle.cpp</strong></p></div><br class="example-break" /><p>

    </p><div class="example"><a id="idp5219232"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:BuildBicycles.cpp</span>
<span class="hl slc">//{L} Bicycle</span>
<span class="hl slc">// The Builder design pattern.</span>
<span class="hl ppc">#include &lt;cstddef&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;map&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Bicycle.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Constructs a bike via a concrete builder</span>
Bicycle<span class="hl opt">*</span> <span class="hl kwd">buildMeABike</span><span class="hl opt">(</span>
  BicycleTechnician<span class="hl opt">&amp;</span> t<span class="hl opt">,</span> BicycleBuilder<span class="hl opt">*</span> builder<span class="hl opt">) {</span>
  t<span class="hl opt">.</span><span class="hl kwd">setBuilder</span><span class="hl opt">(</span>builder<span class="hl opt">);</span>
  t<span class="hl opt">.</span><span class="hl kwd">construct</span><span class="hl opt">();</span>
  Bicycle<span class="hl opt">*</span> b <span class="hl opt">=</span> builder<span class="hl opt">-&gt;</span><span class="hl kwd">getProduct</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Built a &quot;</span> <span class="hl opt">&lt;&lt;</span> builder<span class="hl opt">-&gt;</span><span class="hl kwd">getBikeName</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">return</span> b<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl slc">// Create an order for some bicycles</span>
  map <span class="hl opt">&lt;</span>string<span class="hl opt">,</span> <span class="hl kwb">size_t</span><span class="hl opt">&gt;</span> order<span class="hl opt">;</span>
  order<span class="hl opt">[</span><span class="hl str">&quot;mountain&quot;</span><span class="hl opt">] =</span> <span class="hl num">2</span><span class="hl opt">;</span>
  order<span class="hl opt">[</span><span class="hl str">&quot;touring&quot;</span><span class="hl opt">] =</span> <span class="hl num">1</span><span class="hl opt">;</span>
  order<span class="hl opt">[</span><span class="hl str">&quot;racing&quot;</span><span class="hl opt">] =</span> <span class="hl num">3</span><span class="hl opt">;</span>

  <span class="hl slc">// Build bikes</span>
  vector<span class="hl opt">&lt;</span>Bicycle<span class="hl opt">*&gt;</span> bikes<span class="hl opt">;</span>
  BicycleBuilder<span class="hl opt">*</span> m <span class="hl opt">=</span> <span class="hl kwa">new</span> MountainBikeBuilder<span class="hl opt">;</span>
  BicycleBuilder<span class="hl opt">*</span> t <span class="hl opt">=</span> <span class="hl kwa">new</span> TouringBikeBuilder<span class="hl opt">;</span>
  BicycleBuilder<span class="hl opt">*</span> r <span class="hl opt">=</span> <span class="hl kwa">new</span> RacingBikeBuilder<span class="hl opt">;</span>
  BicycleTechnician tech<span class="hl opt">;</span>
  map<span class="hl opt">&lt;</span>string<span class="hl opt">,</span> <span class="hl kwb">size_t</span><span class="hl opt">&gt;::</span>iterator it <span class="hl opt">=</span> order<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> order<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
    BicycleBuilder<span class="hl opt">*</span> builder<span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>it<span class="hl opt">-&gt;</span>first <span class="hl opt">==</span> <span class="hl str">&quot;mountain&quot;</span><span class="hl opt">)</span>
      builder <span class="hl opt">=</span> m<span class="hl opt">;</span>
    <span class="hl kwa">else if</span><span class="hl opt">(</span>it<span class="hl opt">-&gt;</span>first <span class="hl opt">==</span> <span class="hl str">&quot;touring&quot;</span><span class="hl opt">)</span>
      builder <span class="hl opt">=</span> t<span class="hl opt">;</span>
    <span class="hl kwa">else if</span><span class="hl opt">(</span>it<span class="hl opt">-&gt;</span>first <span class="hl opt">==</span> <span class="hl str">&quot;racing&quot;</span><span class="hl opt">)</span>
      builder <span class="hl opt">=</span> r<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> it<span class="hl opt">-&gt;</span>second<span class="hl opt">; ++</span>i<span class="hl opt">)</span>
      bikes<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span><span class="hl kwd">buildMeABike</span><span class="hl opt">(</span>tech<span class="hl opt">,</span> builder<span class="hl opt">));</span>
    <span class="hl opt">++</span>it<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwa">delete</span> m<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> t<span class="hl opt">;</span>
  <span class="hl kwa">delete</span> r<span class="hl opt">;</span>

  <span class="hl slc">// Display inventory</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">size_t</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> bikes<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">(); ++</span>i<span class="hl opt">)</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Bicycle: &quot;</span> <span class="hl opt">&lt;&lt; *</span>bikes<span class="hl opt">[</span>i<span class="hl opt">] &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>bikes<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl com">/* Output:</span>
<span class="hl com">Built a MountainBike</span>
<span class="hl com">Built a MountainBike</span>
<span class="hl com">Built a RacingBike</span>
<span class="hl com">Built a RacingBike</span>
<span class="hl com">Built a RacingBike</span>
<span class="hl com">Built a TouringBike</span>
<span class="hl com">Bicycle: {</span>
<span class="hl com">  Frame Wheel Seat Derailleur Handlebar Sprocket Shock }</span>
<span class="hl com">Bicycle: {</span>
<span class="hl com">  Frame Wheel Seat Derailleur Handlebar Sprocket Shock }</span>
<span class="hl com">Bicycle: { Frame Wheel Seat Handlebar Sprocket }</span>
<span class="hl com">Bicycle: { Frame Wheel Seat Handlebar Sprocket }</span>
<span class="hl com">Bicycle: { Frame Wheel Seat Handlebar Sprocket }</span>
<span class="hl com">Bicycle: {</span>
<span class="hl com">  Frame Wheel Seat Derailleur Handlebar Sprocket Rack }</span>
<span class="hl com">*/</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.29. C10/BuildBicycles.cpp</strong></p></div><br class="example-break" /><p>

    </p></div><div class="sect1" title="9.13. Observador"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5224808"></a>9.13. Observador</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5225896"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Observer.h</span>
<span class="hl slc">// The Observer interface.</span>
<span class="hl ppc">#ifndef OBSERVER_H</span>
<span class="hl ppc">#define OBSERVER_H</span>

<span class="hl kwc">class</span> Observable<span class="hl opt">;</span>
<span class="hl kwc">class</span> Argument <span class="hl opt">{};</span>

<span class="hl kwc">class</span> Observer <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl slc">// Called by the observed object, whenever</span>
  <span class="hl slc">// the observed object is changed:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">update</span><span class="hl opt">(</span>Observable<span class="hl opt">*</span> o<span class="hl opt">,</span> Argument<span class="hl opt">*</span> arg<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Observer</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OBSERVER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.30. C10/Observer.h</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5227664"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:Observable.h</span>
<span class="hl slc">// The Observable class.</span>
<span class="hl ppc">#ifndef OBSERVABLE_H</span>
<span class="hl ppc">#define OBSERVABLE_H</span>
<span class="hl ppc">#include &lt;set&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Observer.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Observable <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> changed<span class="hl opt">;</span>
  std<span class="hl opt">::</span>set<span class="hl opt">&lt;</span>Observer<span class="hl opt">*&gt;</span> observers<span class="hl opt">;</span>
<span class="hl kwc">protected</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">setChanged</span><span class="hl opt">() {</span> changed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">clearChanged</span><span class="hl opt">() {</span> changed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">; }</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">addObserver</span><span class="hl opt">(</span>Observer<span class="hl opt">&amp;</span> o<span class="hl opt">) {</span>
    observers<span class="hl opt">.</span><span class="hl kwd">insert</span><span class="hl opt">(&amp;</span>o<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">deleteObserver</span><span class="hl opt">(</span>Observer<span class="hl opt">&amp;</span> o<span class="hl opt">) {</span>
    observers<span class="hl opt">.</span><span class="hl kwd">erase</span><span class="hl opt">(&amp;</span>o<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">deleteObservers</span><span class="hl opt">() {</span>
    observers<span class="hl opt">.</span><span class="hl kwd">clear</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">int</span> <span class="hl kwd">countObservers</span><span class="hl opt">() {</span>
    <span class="hl kwa">return</span> observers<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">bool</span> <span class="hl kwd">hasChanged</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> changed<span class="hl opt">; }</span>
  <span class="hl slc">// If this object has changed, notify all</span>
  <span class="hl slc">// of its observers:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">notifyObservers</span><span class="hl opt">(</span>Argument<span class="hl opt">*</span> arg <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span><span class="hl kwd">hasChanged</span><span class="hl opt">())</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
    <span class="hl kwd">clearChanged</span><span class="hl opt">();</span> <span class="hl slc">// Not &quot;changed&quot; anymore</span>
    std<span class="hl opt">::</span>set<span class="hl opt">&lt;</span>Observer<span class="hl opt">*&gt;::</span>iterator it<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span>it <span class="hl opt">=</span> observers<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>it <span class="hl opt">!=</span> observers<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span> it<span class="hl opt">++)</span>
      <span class="hl opt">(*</span>it<span class="hl opt">)-&gt;</span><span class="hl kwd">update</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">,</span> arg<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Observable</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// OBSERVABLE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 9.31. C10/Observable.h</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5232552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:InnerClassIdiom.cpp</span>
<span class="hl slc">// Example of the &quot;inner class&quot; idiom.</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Poingable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">poing</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">callPoing</span><span class="hl opt">(</span>Poingable<span class="hl opt">&amp;</span> p<span class="hl opt">) {</span>
  p<span class="hl opt">.</span><span class="hl kwd">poing</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> Bingable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">bing</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwb">void</span> <span class="hl kwd">callBing</span><span class="hl opt">(</span>Bingable<span class="hl opt">&amp;</span> b<span class="hl opt">) {</span>
  b<span class="hl opt">.</span><span class="hl kwd">bing</span><span class="hl opt">();</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> Outer <span class="hl opt">{</span>
  string name<span class="hl opt">;</span>
  <span class="hl slc">// Define one inner class:</span>
  <span class="hl kwc">class</span> Inner1<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Outer<span class="hl opt">::</span>Inner1<span class="hl opt">;</span>
  <span class="hl kwc">class</span> Inner1 <span class="hl opt">:</span> <span class="hl kwc">public</span> Poingable <span class="hl opt">{</span>
    Outer<span class="hl opt">*</span> parent<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">Inner1</span><span class="hl opt">(</span>Outer<span class="hl opt">*</span> p<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>p<span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">poing</span><span class="hl opt">() {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;poing called for &quot;</span>
        <span class="hl opt">&lt;&lt;</span> parent<span class="hl opt">-&gt;</span>name <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl slc">// Accesses data in the outer class object</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> inner1<span class="hl opt">;</span>
  <span class="hl slc">// Define a second inner class:</span>
  <span class="hl kwc">class</span> Inner2<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Outer<span class="hl opt">::</span>Inner2<span class="hl opt">;</span>
  <span class="hl kwc">class</span> Inner2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Bingable <span class="hl opt">{</span>
    Outer<span class="hl opt">*</span> parent<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">Inner2</span><span class="hl opt">(</span>Outer<span class="hl opt">*</span> p<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>p<span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">bing</span><span class="hl opt">() {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;bing called for &quot;</span>
        <span class="hl opt">&lt;&lt;</span> parent<span class="hl opt">-&gt;</span>name <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> inner2<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Outer</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> nm<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">name</span><span class="hl opt">(</span>nm<span class="hl opt">),</span> <span class="hl kwd">inner1</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">),</span> <span class="hl kwd">inner2</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">) {}</span>
  <span class="hl slc">// Return reference to interfaces</span>
  <span class="hl slc">// implemented by the inner classes:</span>
  <span class="hl kwc">operator</span> Poingable<span class="hl opt">&amp;() {</span> <span class="hl kwa">return</span> inner1<span class="hl opt">; }</span>
  <span class="hl kwc">operator</span> Bingable<span class="hl opt">&amp;() {</span> <span class="hl kwa">return</span> inner2<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Outer <span class="hl kwd">x</span><span class="hl opt">(</span><span class="hl str">&quot;Ping Pong&quot;</span><span class="hl opt">);</span>
  <span class="hl slc">// Like upcasting to multiple base types!:</span>
  <span class="hl kwd">callPoing</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
  <span class="hl kwd">callBing</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.32. C10/InnerClassIdiom.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="sect2" title="9.13.1. El ejemplo de observador"><div class="titlepage"><div><div><h3 class="title"><a id="idp5235800"></a>9.13.1. El ejemplo de observador</h3></div></div></div><p>

      </p><div class="example"><a id="idp5236312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:ObservedFlower.cpp</span>
<span class="hl slc">// Demonstration of &quot;observer&quot; pattern.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Observable.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Flower <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> isOpen<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Flower</span><span class="hl opt">() :</span> <span class="hl kwd">isOpen</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span>
    <span class="hl kwd">openNotifier</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">),</span> <span class="hl kwd">closeNotifier</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">open</span><span class="hl opt">() {</span> <span class="hl slc">// Opens its petals</span>
    isOpen <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    openNotifier<span class="hl opt">.</span><span class="hl kwd">notifyObservers</span><span class="hl opt">();</span>
    closeNotifier<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">close</span><span class="hl opt">() {</span> <span class="hl slc">// Closes its petals</span>
    isOpen <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    closeNotifier<span class="hl opt">.</span><span class="hl kwd">notifyObservers</span><span class="hl opt">();</span>
    openNotifier<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Using the &quot;inner class&quot; idiom:</span>
  <span class="hl kwc">class</span> OpenNotifier<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Flower<span class="hl opt">::</span>OpenNotifier<span class="hl opt">;</span>
  <span class="hl kwc">class</span> OpenNotifier <span class="hl opt">:</span> <span class="hl kwc">public</span> Observable <span class="hl opt">{</span>
    Flower<span class="hl opt">*</span> parent<span class="hl opt">;</span>
    <span class="hl kwb">bool</span> alreadyOpen<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">OpenNotifier</span><span class="hl opt">(</span>Flower<span class="hl opt">*</span> f<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>f<span class="hl opt">),</span>
      <span class="hl kwd">alreadyOpen</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">notifyObservers</span><span class="hl opt">(</span>Argument<span class="hl opt">*</span> arg <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>parent<span class="hl opt">-&gt;</span>isOpen <span class="hl opt">&amp;&amp; !</span>alreadyOpen<span class="hl opt">) {</span>
        <span class="hl kwd">setChanged</span><span class="hl opt">();</span>
        Observable<span class="hl opt">::</span><span class="hl kwd">notifyObservers</span><span class="hl opt">();</span>
        alreadyOpen <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">close</span><span class="hl opt">() {</span> alreadyOpen <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">; }</span>
  <span class="hl opt">}</span> openNotifier<span class="hl opt">;</span>
  <span class="hl kwc">class</span> CloseNotifier<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Flower<span class="hl opt">::</span>CloseNotifier<span class="hl opt">;</span>
  <span class="hl kwc">class</span> CloseNotifier <span class="hl opt">:</span> <span class="hl kwc">public</span> Observable <span class="hl opt">{</span>
    Flower<span class="hl opt">*</span> parent<span class="hl opt">;</span>
    <span class="hl kwb">bool</span> alreadyClosed<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">CloseNotifier</span><span class="hl opt">(</span>Flower<span class="hl opt">*</span> f<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>f<span class="hl opt">),</span>
      <span class="hl kwd">alreadyClosed</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">notifyObservers</span><span class="hl opt">(</span>Argument<span class="hl opt">*</span> arg <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(!</span>parent<span class="hl opt">-&gt;</span>isOpen <span class="hl opt">&amp;&amp; !</span>alreadyClosed<span class="hl opt">) {</span>
        <span class="hl kwd">setChanged</span><span class="hl opt">();</span>
        Observable<span class="hl opt">::</span><span class="hl kwd">notifyObservers</span><span class="hl opt">();</span>
        alreadyClosed <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">open</span><span class="hl opt">() {</span> alreadyClosed <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">; }</span>
  <span class="hl opt">}</span> closeNotifier<span class="hl opt">;</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Bee <span class="hl opt">{</span>
  string name<span class="hl opt">;</span>
  <span class="hl slc">// An &quot;inner class&quot; for observing openings:</span>
  <span class="hl kwc">class</span> OpenObserver<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Bee<span class="hl opt">::</span>OpenObserver<span class="hl opt">;</span>
  <span class="hl kwc">class</span> OpenObserver <span class="hl opt">:</span> <span class="hl kwc">public</span> Observer <span class="hl opt">{</span>
    Bee<span class="hl opt">*</span> parent<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">OpenObserver</span><span class="hl opt">(</span>Bee<span class="hl opt">*</span> b<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>b<span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">update</span><span class="hl opt">(</span>Observable<span class="hl opt">*,</span> Argument <span class="hl opt">*) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Bee &quot;</span> <span class="hl opt">&lt;&lt;</span> parent<span class="hl opt">-&gt;</span>name
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;'s breakfast time!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> openObsrv<span class="hl opt">;</span>
  <span class="hl slc">// Another &quot;inner class&quot; for closings:</span>
  <span class="hl kwc">class</span> CloseObserver<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Bee<span class="hl opt">::</span>CloseObserver<span class="hl opt">;</span>
  <span class="hl kwc">class</span> CloseObserver <span class="hl opt">:</span> <span class="hl kwc">public</span> Observer <span class="hl opt">{</span>
    Bee<span class="hl opt">*</span> parent<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">CloseObserver</span><span class="hl opt">(</span>Bee<span class="hl opt">*</span> b<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>b<span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">update</span><span class="hl opt">(</span>Observable<span class="hl opt">*,</span> Argument <span class="hl opt">*) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Bee &quot;</span> <span class="hl opt">&lt;&lt;</span> parent<span class="hl opt">-&gt;</span>name
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;'s bed time!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> closeObsrv<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Bee</span><span class="hl opt">(</span>string nm<span class="hl opt">) :</span> <span class="hl kwd">name</span><span class="hl opt">(</span>nm<span class="hl opt">),</span>
    <span class="hl kwd">openObsrv</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">),</span> <span class="hl kwd">closeObsrv</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">) {}</span>
  Observer<span class="hl opt">&amp;</span> <span class="hl kwd">openObserver</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> openObsrv<span class="hl opt">; }</span>
  Observer<span class="hl opt">&amp;</span> <span class="hl kwd">closeObserver</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> closeObsrv<span class="hl opt">;}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Hummingbird <span class="hl opt">{</span>
  string name<span class="hl opt">;</span>
  <span class="hl kwc">class</span> OpenObserver<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Hummingbird<span class="hl opt">::</span>OpenObserver<span class="hl opt">;</span>
  <span class="hl kwc">class</span> OpenObserver <span class="hl opt">:</span> <span class="hl kwc">public</span> Observer <span class="hl opt">{</span>
    Hummingbird<span class="hl opt">*</span> parent<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">OpenObserver</span><span class="hl opt">(</span>Hummingbird<span class="hl opt">*</span> h<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>h<span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">update</span><span class="hl opt">(</span>Observable<span class="hl opt">*,</span> Argument <span class="hl opt">*) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Hummingbird &quot;</span> <span class="hl opt">&lt;&lt;</span> parent<span class="hl opt">-&gt;</span>name
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;'s breakfast time!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> openObsrv<span class="hl opt">;</span>
  <span class="hl kwc">class</span> CloseObserver<span class="hl opt">;</span>
  <span class="hl kwc">friend class</span> Hummingbird<span class="hl opt">::</span>CloseObserver<span class="hl opt">;</span>
  <span class="hl kwc">class</span> CloseObserver <span class="hl opt">:</span> <span class="hl kwc">public</span> Observer <span class="hl opt">{</span>
    Hummingbird<span class="hl opt">*</span> parent<span class="hl opt">;</span>
  <span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl kwd">CloseObserver</span><span class="hl opt">(</span>Hummingbird<span class="hl opt">*</span> h<span class="hl opt">) :</span> <span class="hl kwd">parent</span><span class="hl opt">(</span>h<span class="hl opt">) {}</span>
    <span class="hl kwb">void</span> <span class="hl kwd">update</span><span class="hl opt">(</span>Observable<span class="hl opt">*,</span> Argument <span class="hl opt">*) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Hummingbird &quot;</span> <span class="hl opt">&lt;&lt;</span> parent<span class="hl opt">-&gt;</span>name
        <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;'s bed time!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> closeObsrv<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Hummingbird</span><span class="hl opt">(</span>string nm<span class="hl opt">) :</span> <span class="hl kwd">name</span><span class="hl opt">(</span>nm<span class="hl opt">),</span>
    <span class="hl kwd">openObsrv</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">),</span> <span class="hl kwd">closeObsrv</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">) {}</span>
  Observer<span class="hl opt">&amp;</span> <span class="hl kwd">openObserver</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> openObsrv<span class="hl opt">; }</span>
  Observer<span class="hl opt">&amp;</span> <span class="hl kwd">closeObserver</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> closeObsrv<span class="hl opt">;}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  Flower f<span class="hl opt">;</span>
  Bee <span class="hl kwd">ba</span><span class="hl opt">(</span><span class="hl str">&quot;A&quot;</span><span class="hl opt">),</span> <span class="hl kwd">bb</span><span class="hl opt">(</span><span class="hl str">&quot;B&quot;</span><span class="hl opt">);</span>
  Hummingbird <span class="hl kwd">ha</span><span class="hl opt">(</span><span class="hl str">&quot;A&quot;</span><span class="hl opt">),</span> <span class="hl kwd">hb</span><span class="hl opt">(</span><span class="hl str">&quot;B&quot;</span><span class="hl opt">);</span>
  f<span class="hl opt">.</span>openNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>ha<span class="hl opt">.</span><span class="hl kwd">openObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>openNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>hb<span class="hl opt">.</span><span class="hl kwd">openObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>openNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>ba<span class="hl opt">.</span><span class="hl kwd">openObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>openNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>bb<span class="hl opt">.</span><span class="hl kwd">openObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>closeNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>ha<span class="hl opt">.</span><span class="hl kwd">closeObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>closeNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>hb<span class="hl opt">.</span><span class="hl kwd">closeObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>closeNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>ba<span class="hl opt">.</span><span class="hl kwd">closeObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span>closeNotifier<span class="hl opt">.</span><span class="hl kwd">addObserver</span><span class="hl opt">(</span>bb<span class="hl opt">.</span><span class="hl kwd">closeObserver</span><span class="hl opt">());</span>
  <span class="hl slc">// Hummingbird B decides to sleep in:</span>
  f<span class="hl opt">.</span>openNotifier<span class="hl opt">.</span><span class="hl kwd">deleteObserver</span><span class="hl opt">(</span>hb<span class="hl opt">.</span><span class="hl kwd">openObserver</span><span class="hl opt">());</span>
  <span class="hl slc">// Something changes that interests observers:</span>
  f<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">();</span>
  f<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">();</span> <span class="hl slc">// It's already open, no change.</span>
  <span class="hl slc">// Bee A doesn't want to go to bed:</span>
  f<span class="hl opt">.</span>closeNotifier<span class="hl opt">.</span><span class="hl kwd">deleteObserver</span><span class="hl opt">(</span>
    ba<span class="hl opt">.</span><span class="hl kwd">closeObserver</span><span class="hl opt">());</span>
  f<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
  f<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span> <span class="hl slc">// It's already closed; no change</span>
  f<span class="hl opt">.</span>openNotifier<span class="hl opt">.</span><span class="hl kwd">deleteObservers</span><span class="hl opt">();</span>
  f<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">();</span>
  f<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.33. C10/ObservedFlower.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="9.14. Despachado múltiple"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5242824"></a>9.14. Despachado múltiple</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5243768"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:PaperScissorsRock.cpp</span>
<span class="hl slc">// Demonstration of multiple dispatching.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;iterator&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Paper<span class="hl opt">;</span>
<span class="hl kwc">class</span> Scissors<span class="hl opt">;</span>
<span class="hl kwc">class</span> Rock<span class="hl opt">;</span>

<span class="hl kwb">enum</span> Outcome <span class="hl opt">{</span> WIN<span class="hl opt">,</span> LOSE<span class="hl opt">,</span> DRAW <span class="hl opt">};</span>

ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Outcome out<span class="hl opt">) {</span>
  <span class="hl kwa">switch</span><span class="hl opt">(</span>out<span class="hl opt">) {</span>
    <span class="hl kwa">default</span><span class="hl opt">:</span>
    <span class="hl kwa">case</span> WIN<span class="hl opt">:</span> <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;win&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> LOSE<span class="hl opt">:</span> <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;lose&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">case</span> DRAW<span class="hl opt">:</span> <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;draw&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span>

<span class="hl kwc">class</span> Item <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> Outcome <span class="hl kwd">compete</span><span class="hl opt">(</span><span class="hl kwb">const</span> Item<span class="hl opt">*) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Paper<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Scissors<span class="hl opt">*)</span> <span class="hl kwb">const</span><span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Rock<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Item</span><span class="hl opt">() {}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Item<span class="hl opt">*</span> it<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> it<span class="hl opt">-&gt;</span><span class="hl kwd">print</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Paper <span class="hl opt">:</span> <span class="hl kwc">public</span> Item <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Outcome <span class="hl kwd">compete</span><span class="hl opt">(</span><span class="hl kwb">const</span> Item<span class="hl opt">*</span> it<span class="hl opt">) {</span> <span class="hl kwa">return</span> it<span class="hl opt">-&gt;</span><span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);}</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Paper<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> DRAW<span class="hl opt">; }</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Scissors<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> WIN<span class="hl opt">; }</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Rock<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> LOSE<span class="hl opt">; }</span>
  ostream<span class="hl opt">&amp;</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Paper   &quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Scissors <span class="hl opt">:</span> <span class="hl kwc">public</span> Item <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Outcome <span class="hl kwd">compete</span><span class="hl opt">(</span><span class="hl kwb">const</span> Item<span class="hl opt">*</span> it<span class="hl opt">) {</span> <span class="hl kwa">return</span> it<span class="hl opt">-&gt;</span><span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);}</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Paper<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> LOSE<span class="hl opt">; }</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Scissors<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> DRAW<span class="hl opt">; }</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Rock<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> WIN<span class="hl opt">; }</span>
  ostream<span class="hl opt">&amp;</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Scissors&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Rock <span class="hl opt">:</span> <span class="hl kwc">public</span> Item <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  Outcome <span class="hl kwd">compete</span><span class="hl opt">(</span><span class="hl kwb">const</span> Item<span class="hl opt">*</span> it<span class="hl opt">) {</span> <span class="hl kwa">return</span> it<span class="hl opt">-&gt;</span><span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);}</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Paper<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> WIN<span class="hl opt">; }</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Scissors<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> LOSE<span class="hl opt">; }</span>
  Outcome <span class="hl kwd">eval</span><span class="hl opt">(</span><span class="hl kwb">const</span> Rock<span class="hl opt">*)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span> <span class="hl kwa">return</span> DRAW<span class="hl opt">; }</span>
  ostream<span class="hl opt">&amp;</span> <span class="hl kwd">print</span><span class="hl opt">(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Rock    &quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">struct</span> ItemGen <span class="hl opt">{</span>
  Item<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwa">switch</span><span class="hl opt">(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">3</span><span class="hl opt">) {</span>
      <span class="hl kwa">default</span><span class="hl opt">:</span>
      <span class="hl kwa">case</span> <span class="hl num">0</span><span class="hl opt">:</span> <span class="hl kwa">return new</span> Scissors<span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl num">1</span><span class="hl opt">:</span> <span class="hl kwa">return new</span> Paper<span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl num">2</span><span class="hl opt">:</span> <span class="hl kwa">return new</span> Rock<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">struct</span> Compete <span class="hl opt">{</span>
  Outcome <span class="hl kwc">operator</span><span class="hl opt">()(</span>Item<span class="hl opt">*</span> a<span class="hl opt">,</span> Item<span class="hl opt">*</span> b<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> a <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">&quot;</span> <span class="hl opt">&lt;&lt;</span> b <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;</span><span class="hl esc">\t</span><span class="hl str">&quot;</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> a<span class="hl opt">-&gt;</span><span class="hl kwd">compete</span><span class="hl opt">(</span>b<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  <span class="hl kwb">const int</span> sz <span class="hl opt">=</span> <span class="hl num">20</span><span class="hl opt">;</span>
  vector<span class="hl opt">&lt;</span>Item<span class="hl opt">*&gt;</span> <span class="hl kwd">v</span><span class="hl opt">(</span>sz<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">);</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">ItemGen</span><span class="hl opt">());</span>
  <span class="hl kwd">transform</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">() +</span> sz<span class="hl opt">,</span>
    v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">() +</span> sz<span class="hl opt">,</span>
    ostream_iterator<span class="hl opt">&lt;</span>Outcome<span class="hl opt">&gt;(</span>cout<span class="hl opt">,</span> <span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">),</span>
    <span class="hl kwd">Compete</span><span class="hl opt">());</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>v<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.34. C10/PaperScissorsRock.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="sect2" title="9.14.1. Despachado múltiple con Visitor"><div class="titlepage"><div><div><h3 class="title"><a id="idp5250328"></a>9.14.1. Despachado múltiple con Visitor</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp5251872"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C10:BeeAndFlowers.cpp</span>
<span class="hl slc">// Demonstration of &quot;visitor&quot; pattern.</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;../purge.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Gladiolus<span class="hl opt">;</span>
<span class="hl kwc">class</span> Renuculus<span class="hl opt">;</span>
<span class="hl kwc">class</span> Chrysanthemum<span class="hl opt">;</span>

<span class="hl kwc">class</span> Visitor <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Gladiolus<span class="hl opt">*</span> f<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Renuculus<span class="hl opt">*</span> f<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Chrysanthemum<span class="hl opt">*</span> f<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Visitor</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Flower <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">accept</span><span class="hl opt">(</span>Visitor<span class="hl opt">&amp;) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Flower</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Gladiolus <span class="hl opt">:</span> <span class="hl kwc">public</span> Flower <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">accept</span><span class="hl opt">(</span>Visitor<span class="hl opt">&amp;</span> v<span class="hl opt">) {</span>
    v<span class="hl opt">.</span><span class="hl kwd">visit</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Renuculus <span class="hl opt">:</span> <span class="hl kwc">public</span> Flower <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">accept</span><span class="hl opt">(</span>Visitor<span class="hl opt">&amp;</span> v<span class="hl opt">) {</span>
    v<span class="hl opt">.</span><span class="hl kwd">visit</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Chrysanthemum <span class="hl opt">:</span> <span class="hl kwc">public</span> Flower <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">accept</span><span class="hl opt">(</span>Visitor<span class="hl opt">&amp;</span> v<span class="hl opt">) {</span>
    v<span class="hl opt">.</span><span class="hl kwd">visit</span><span class="hl opt">(</span><span class="hl kwa">this</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Add the ability to produce a string:</span>
<span class="hl kwc">class</span> StringVal <span class="hl opt">:</span> <span class="hl kwc">public</span> Visitor <span class="hl opt">{</span>
  string s<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">operator</span> <span class="hl kwb">const</span> string<span class="hl opt">&amp;() {</span> <span class="hl kwa">return</span> s<span class="hl opt">; }</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Gladiolus<span class="hl opt">*) {</span>
    s <span class="hl opt">=</span> <span class="hl str">&quot;Gladiolus&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Renuculus<span class="hl opt">*) {</span>
    s <span class="hl opt">=</span> <span class="hl str">&quot;Renuculus&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Chrysanthemum<span class="hl opt">*) {</span>
    s <span class="hl opt">=</span> <span class="hl str">&quot;Chrysanthemum&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Add the ability to do &quot;Bee&quot; activities:</span>
<span class="hl kwc">class</span> Bee <span class="hl opt">:</span> <span class="hl kwc">public</span> Visitor <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Gladiolus<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Bee and Gladiolus&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Renuculus<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Bee and Renuculus&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">visit</span><span class="hl opt">(</span>Chrysanthemum<span class="hl opt">*) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Bee and Chrysanthemum&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">struct</span> FlowerGen <span class="hl opt">{</span>
  Flower<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">()() {</span>
    <span class="hl kwa">switch</span><span class="hl opt">(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">3</span><span class="hl opt">) {</span>
      <span class="hl kwa">default</span><span class="hl opt">:</span>
      <span class="hl kwa">case</span> <span class="hl num">0</span><span class="hl opt">:</span> <span class="hl kwa">return new</span> Gladiolus<span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl num">1</span><span class="hl opt">:</span> <span class="hl kwa">return new</span> Renuculus<span class="hl opt">;</span>
      <span class="hl kwa">case</span> <span class="hl num">2</span><span class="hl opt">:</span> <span class="hl kwa">return new</span> Chrysanthemum<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  vector<span class="hl opt">&lt;</span>Flower<span class="hl opt">*&gt;</span> <span class="hl kwd">v</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  <span class="hl kwd">generate</span><span class="hl opt">(</span>v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">(),</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(),</span> <span class="hl kwd">FlowerGen</span><span class="hl opt">());</span>
  vector<span class="hl opt">&lt;</span>Flower<span class="hl opt">*&gt;::</span>iterator it<span class="hl opt">;</span>
  <span class="hl slc">// It's almost as if I added a virtual function</span>
  <span class="hl slc">// to produce a Flower string representation:</span>
  StringVal sval<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>it <span class="hl opt">=</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span> it <span class="hl opt">!=</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span> it<span class="hl opt">++) {</span>
    <span class="hl opt">(*</span>it<span class="hl opt">)-&gt;</span><span class="hl kwd">accept</span><span class="hl opt">(</span>sval<span class="hl opt">);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">string</span><span class="hl opt">(</span>sval<span class="hl opt">) &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Perform &quot;Bee&quot; operation on all Flowers:</span>
  Bee bee<span class="hl opt">;</span>
  <span class="hl kwa">for</span><span class="hl opt">(</span>it <span class="hl opt">=</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span> it <span class="hl opt">!=</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">();</span> it<span class="hl opt">++)</span>
    <span class="hl opt">(*</span>it<span class="hl opt">)-&gt;</span><span class="hl kwd">accept</span><span class="hl opt">(</span>bee<span class="hl opt">);</span>
  <span class="hl kwd">purge</span><span class="hl opt">(</span>v<span class="hl opt">);</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 9.35. C10/BeeAndFlowers.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="9.15. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5256456"></a>9.15. Resumen</h2></div></div></div><p>

    </p><p>

    </p></div><div class="sect1" title="9.16. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5257224"></a>9.16. Ejercicios</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div></div><div class="chapter" title="10: Concurrencia"><div class="titlepage"><div><div><h2 class="title"><a id="C11"></a>10: Concurrencia</h2></div></div></div><div class="toc"><p><strong>Tabla de contenidos</strong></p><dl><dt><span class="sect1"><a href="#idp5268520">10.1. Motivación</a></span></dt><dt><span class="sect1"><a href="#idp5277184">10.2. Concurrencia en C++</a></span></dt><dt><span class="sect1"><a href="#idp5301632">10.3. Utilización de los hilos</a></span></dt><dt><span class="sect1"><a href="#idp5367656">10.4. Comparición de recursos limitados</a></span></dt><dt><span class="sect1"><a href="#idp5445456">10.5. Finalización de tareas</a></span></dt><dt><span class="sect1"><a href="#idp5503488">10.6. Cooperación entre hilos</a></span></dt><dt><span class="sect1"><a href="#idp5544856">10.7. Bloqueo letal</a></span></dt><dt><span class="sect1"><a href="#idp5556744">10.8. Resumen</a></span></dt><dt><span class="sect1"><a href="#idp5561544">10.9. Ejercicios</a></span></dt></dl></div><p>
  Los objetos ofrecen una forma de dividir un programa en diferentes
  secciones. A menudo, también es necesario dividir un programa,
  independientemente de las subtareas en ejecución.
  </p><p>
  Utilizando multihilado, un hilo de ejecución dirige cada una esas
  subtareas independientes, y puedes programar como si cada hilo tuviera
  su propia CPU. Un mecanismo interno reparte el tiempo de CPU por ti,
  pero en general, no necesitas pensar acerca de eso, lo que ayuda a
  simplificar la programación con múltiples hilos.
  </p><p>
  Un proceso es un programa autocontenido en ejecución con su propio
  espacio de direcciones. Un sistema operativo multitarea puede ejecutar
  más de un proceso (programa) en el mismo tiempo, mientras ....., por
  medio de cambios periódicos de CPU de una tarea a otra. Un hilo es una
  simple flujo de control secuencial con un proceso. Un proceso puede
  tener de este modo múltiples hilos en ejecución concurrentes. Puesto
  que los hilos se ejecutan con un proceso simple, pueden compartir
  memoria y otros recursos.  La dificultad fundamental de escribir
  programas multihilados está en coordinar el uso de esos recursos entre
  los diferentes hilos.
  </p><p>
  Hay muchas aplicaciones posibles para el multihilado, pero lo más
  usual es querer usarlo cuando tienes alguna parte de tu programa
  vinculada a un evento o recurso particular. Para evitar bloquear el
  resto de tu programa, creas un hilo asociado a ese evento o recurso y
  le permites ejecutarse independientemente del programa principal.
  </p><p>
  La programación concurrente se como caminar en un mundo completamente
  nuevo y aprender un nuevo lenguaje de programación, o por lo menos un
  nuevo conjunto de conceptos del lenguaje. Con la aparición del soporte
  para los hilos en la mayoría de los sistemas operativos para
  microcomputadores, han aparecido también en los lenguajes de
  programación o librerías extensiones para los hilos.  En cualquier
  caso, programación hilada:
  </p><p>
  1. Parece misteriosa y requiere un esfuerzo en la forma de pensar
  acerca de la programación.
  </p><p>
  2. En otros lenguajes el soporte a los hilos es similar. Cuando
  entiendas los hilos, comprenderás una jerga común.
  </p><p>
  Comprender la programación concurrente está al mismo nivel de
  dificultad que comprender el polimorfismo. Si pones un poco de
  esfuerzo, podrás entender el mecanismo básico, pero generalmente
  necesitará de un entendimiento y estudio profundo para desarrollar una
  comprensión auténtica sobre el tema. La meta de este capítulo es darte
  una base sólida en los principios de concurrencia para que puedas
  entender los conceptos y escribir programas multihilados
  razonables. Sé consciente de que puedes confiarte fácilmente. Si vas a
  escribir algo complejo, necesitarás estudiar libros específicos sobre
  el tema.
  </p><div class="sect1" title="10.1. Motivación"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5268520"></a>10.1. Motivación</h2></div></div></div><p>
  Una de las razones más convincentes para usar concurrencia es crear
  una interfaz sensible al usuario. Considera un programa que realiza
  una operación de CPU intensiva y, de esta forma, termina ignorando la
  entrada del usuario y comienza a no responder. El programa necesita
  continuar controlandor sus operaciones, y al mismo tiempo necesita
  devolver el control al botón de la interfaz de usuario para que el
  programa pueda responder al usuario. Si tienes un botón de "Salir", no
  querrás estar forzado a sondearlo en todas las partes de código que
  escribas en tu programa. (Esto acoplaría tu botón de salir a lo largo
  del programa y sería un quebradero de cabeza a la hora de
  mantenerlo). .....
  </p><p>
  Una función convencional no puede continuar realizando sus operaciones
  y al mismo tiempo devolver el control al resto del programa. De hecho,
  suena a imposible, como si la CPU estuviera en dos lugares a la vez,
  pero esto es precisamente la "ilusión" que la concurrencia permite (en
  el caso de un sistema multiprocesador, debe haber más de una
  "ilusión").
  </p><p>
  También puedes usar concurrencia para optimizar la carga de trabajo.
  Por ejemplo, podrías necesitar hacer algo importante mientras estás
  estancado esperando la llegada de una entrada del puerto I/O. Sin
  hilos, la única solución razonable es sondear los puertos I/O, que es
  costoso y puede ser difícil.
  </p><p>
  Si tienes una máquina multiprocesador, los múltiples hilos pueden ser
  distribuídos a lo largo de los múltiples procesadores, pudiendo
  mejorar considerablemente la carga de trabajo. Este es el típico caso
  de los potentes servidores web multiprocesdor, que pueden distribuir
  un gran número de peticiones de usuario por todas las CPUs en un
  programa que asigna un hilo por petición.
  </p><p>
  Un programa que usa hilos en una máquina monoprocesador hará una cosa
  en un tiempo dado, por lo que es teóricamente posible escribir el
  mismo programa sin el uso de hilos. Sin embargo, el multihilado
  proporciona un beneficio de optimización importante: El diseño de un
  programa puede ser maravillosamente simple. Algunos tipos de
  problemas, como la simulación - un video juego, por ejemplo - son
  difíciles de resolver sin el soporte de la concurrencia.
  </p><p>
  El modelo hilado es una comodidad de la programación para simplificar
  el manejo de muchas operaciones al mismo tiempo con un simple
  programa: La CPU desapilará y dará a cada hilo algo de su tiempo. Cada
  hilo tiene consciencia de que tiene un tiempo constante de uso de CPU,
  pero el tiempo de CPU está actualmente repartido entre todo los
  hilos. La excepción es un programa que se ejecuta sobre múltiples
  CPU's. Pero una de las cosas fabulosas que tiene el hilado es que te
  abstrae de esta capa, por lo que tu código no necesita saber si está
  ejecutándose sobre una sóla CPU o sobre varias.[149] De este modo,
  usar hilos es una manera de crear programas escalables de forma
  transparente - si un programa se está ejecutando demasiado despacio,
  puedes acelerarlo fácilmente añadiendo CPUs a tu ordenador. La
  multitarea y el multihilado tienden a ser las mejores opciones a
  utilizar en un sistema multiprocesador.
  </p><p>
  El uso de hilos puede reducir la eficiencia computacional un poco,
  pero el aumento neto en el diseño del programa, balanceo de recursos,
  y la comodidad del usuario a menudo es más valorado. En general, los
  hilos te permiten crear diseñor más desacoplados; de lo contrario, las
  partes de tu código estaría obligadas a prestar atención a tareas que
  podrías manejarlas con hilos normalmente.
  </p></div><div class="sect1" title="10.2. Concurrencia en C++"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5277184"></a>10.2. Concurrencia en C++</h2></div></div></div><p>
    Cuando el Comité de Estándares de C++ estaba creando el estándar
    inicial de C++, el mecanismo de concurrencia fue excluído de forma
    explícita porque C no tenía uno y también porque había varíos enfoques
    rivales acerca de su implementación. Parecía demasiado restrictivo
    forzar a los programadores a usar una sola alternativa.
    </p><p>
    Sin embargo, la alternativa resultó ser peor. Para usar concurriencia,
    tenías que encontrar y aprender una librería y ocuparte de su
    indiosincrasia y las incertidumbres de trabajar con un vendedor
    particular. Además, no había garantía de que una librería funcionaría
    en diferentes compiladores o en distintas plataformas. También, desde
    que la concurrencia no formaba parte del estándar del lenguaje, fue
    más difícil encontrar programadores C++ que también entendieran la
    programación concurrente.
    </p><p>
    Otra influencia pudo ser el lenguaje Java, que incluyó concurrencia en
    el núcleo del lenguaje. Aunque el multihilado is aún complicado, los
    programadores de Java tienden a empezar a aprenderlo y usarlo desde el
    principio.
    </p><p>
    El Comité de Estándares de C++ está considerando incluir el soporte a
    la concurrencia en la siguiente iteración de C++, pero en el momento
    de este escrito no estaba claro qué aspecto tendrá la
    librería. Decidimos usar la librería ZThread como base para este
    capítulo. La escogimos por su diseño, y es open-source y gratuitamente
    descargable desde http://zthread.sourceforge.net. Eric Crahen de IBM,
    el autor de la librería ZThread, fue decisivo para crear este
    capítulo.[150]
    </p><p>
    Este capítulo utiliza sólo un subgrupo de la librería ZThread, de
    acuerdo con el convenio de ideas fundamentales sobre los hilos. La
    librería ZThread contiene un soporte a los hilos significativamente
    más sofisticado que el que se muestra aquí, y deberías estudiar esa
    librería más profundamente para comprender completamente sus
    posibilidades.
    </p><div class="sect2" title="10.2.1. Instalación de ZThreads"><div class="titlepage"><div><div><h3 class="title"><a id="idp5281568"></a>10.2.1. Instalación de ZThreads</h3></div></div></div><p>
      Por favor, note que la librería ZThread es un proyecto independiente y
      no está soportada por el autor de este libro; simplemente estamos
      usando la librería en este capítulo y no podemos dar soporte técnico a
      las características de la instalación. Mira el sitio web de ZThread
      para obtener soporte en la instalación y reporte de errores.
      </p><p>
      La librería ZThread se distribuye como código fuente. Después de
      descargarla (versión 2.3 o superior) desde la web de ZThread, debes
      compilar la librería primero, y después configurar tu proyecto para
      que use la librería.
      --&gt;
      </p><p>
      El método habitual para compilar la librería ZThreads para los
      distintos sabores de UNIX (Linux, SunOS, Cygwin, etc) es usar un
      script de configuración. Después de desempaquetar los archivos (usando
      tar), simplemente ejecuta: ./configure &amp;&amp; make install
      </p><p>
      en el directorio principal de ZThreads para compilar e instalar una
      copia de la librería en directorio /usr/local. Puedes personalizar
      algunas opciones cuando uses el script, incluída la localización de
      los ficheros. Para más detalles, utiliza este comando: ./configure
      ?help
      </p><p>
      El código de ZThreads está estructurado para simplificar la
      compilación para otras plataformas (como Borland, Microsoft y
      Metrowerks). Para hacer esto, crea un nuevo proyecto y añade todos los
      archivos .cxx en el directorio src de ZThreads a la lista de archivos
      a compilar.  Además, asegúrate de incluir el directorio incluído del
      archivo en la ruta de búsqueda de la cabecera para tu proyecto???. Los
      detalles exactos variarán de compilador en compilador, por lo que
      necesitarás estar algo familiarizado con tu conjunto de herramientas
      para ser capaz de utilizar esta opción.
      </p><p>
      Una vez la compilación ha finalizado con éxito, el siguiente paso es
      crear un proyecto que use la nueva librería compilada. Primero,
      permite al compilador saber donde están localizadas las cabeceras, por
      lo que tu instrucción #include funcionará
      correctamente. Habitualmente, necesitarás en tu proyecto una opción
      como se muestra:
      </p><pre class="programlisting">
<span class="hl opt">-</span>I<span class="hl opt">/</span>path<span class="hl opt">/</span>to<span class="hl opt">/</span>installation<span class="hl opt">/</span>include
</pre><p>
      Si utilizaste el script de configuración, la ruta de instalación
      será el prefijo de la que definiste (por defecto, /usr/local). Si
      utilizaste uno de los archivos de proyecto en la creación del
      directorio, la ruta instalación debería ser simplemente la ruta al
      directorio principal del archivo ZThreads.
      </p><p>
      Después, necesitarás añadir una opción a tu proyecto que permitirá al
      enlazador saber donde está la librería. Si usaste el script de
      configuración, se parecerá a lo siguiente:
      </p><pre class="programlisting">
<span class="hl opt">-</span>L<span class="hl opt">/</span>path<span class="hl opt">/</span>to<span class="hl opt">/</span>installation<span class="hl opt">/</span>lib ?lZThread
</pre><p>
      Si usaste uno de los archivos del proyecto proporcionados, será
      similar a:
      </p><pre class="programlisting">
<span class="hl opt">-</span>L<span class="hl opt">/</span>path<span class="hl opt">/</span>to<span class="hl opt">/</span>installation<span class="hl opt">/</span>Debug ZThread<span class="hl opt">.</span>lib
</pre><p>
      De nuevo, si usaste el script de configuración, la ruta de instalación
      s será el prefijo de la que definistes. Si su utilizaste un archivo
      del proyecto, la ruta será la misma que la del directorio principal de
      ZThreads.
      </p><p>
      Nota que si estás utilizando Linux, o Cygwin (www.cygwin.com) bajo
      Windows, no deberías necesitar modificar la ruta de include o de la
      librería; el proceso por defecto de instalación tendrá cuidado para
      hacerlo por ti, normalmente.
      </p><p>
	En GNU/Linux, es posible que necesites añadir lo siguiente a tu .bashrc
      para que el sistema pueda encontrar la el archivo de la
      librería compartida LibZThread-x.x.so.0 cuando ejecute programas de
      este capítulo.
      </p><pre class="programlisting">
export LD_LIBRARY_PATH<span class="hl opt">=/</span>usr<span class="hl opt">/</span>local<span class="hl opt">/</span>lib<span class="hl opt">:</span>$<span class="hl opt">{</span>LD_LIBRARY_PATH<span class="hl opt">}</span>
</pre><p>
      (Asumiendo que utilizas el proceso de instalación por defecto y la
      librería compartida acaba en /user/local/lib/; en otro caso, cambia la
      ruta por tu localización.
      </p></div><div class="sect2" title="10.2.2. Definición de tareas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5293720"></a>10.2.2. Definición de tareas</h3></div></div></div><p>
      Un hilo cumple con una tarea, por lo que necesitas un manera de
      describir esa tarea. La clase Runnable proporciona unas interfaces
      comunes a ejecutar para cualquier tarea. Aquí está el núcleo de las
      clase Runnable de ZThread, que la encontrarás en el archivo Runnable.h
      dentro del directorio incluído, después de instalar la librería
      ZThread:
      </p><pre class="programlisting">
<span class="hl kwc">class</span> Runnable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwc">virtual</span> <span class="hl opt">~</span><span class="hl kwd">Runnable</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>
</pre><p>
      Al hacerla una clase base abstracta, Runnable es fácilmente combinable
      con una clase básica u otras clases.
      </p><p>
      Para definir una tarea, simplemente hereda de la clase Runnable y
      sobreescribe run( ) para que la tarea haga lo que quieres.
      </p><p>
      Por ejecomplo, la tarea LiftOff siguiente muestra la cuenta atrás
      antes de despegar:
      </p><div class="example"><a id="idp5296704"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:LiftOff.h</span>
<span class="hl slc">// Demonstration of the Runnable interface.</span>
<span class="hl ppc">#ifndef LIFTOFF_H</span>
<span class="hl ppc">#define LIFTOFF_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Runnable.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> LiftOff <span class="hl opt">:</span> <span class="hl kwc">public</span> ZThread<span class="hl opt">::</span>Runnable <span class="hl opt">{</span>
  <span class="hl kwb">int</span> countDown<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl kwb">int</span> count<span class="hl opt">,</span> <span class="hl kwb">int</span> ident <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span>
    <span class="hl kwd">countDown</span><span class="hl opt">(</span>count<span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">LiftOff</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; completed&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>countDown<span class="hl opt">--)</span>
      std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;:&quot;</span> <span class="hl opt">&lt;&lt;</span> countDown <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Liftoff!&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// LIFTOFF_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.1. C11/LiftOff.h</strong></p></div><br class="example-break" /><p>
	El identificador id sirve como distinción entre multiples instancias
      de la tarea. Si sólo quieres hacer una instancia, debes utilizar el
      valor por defecto para identificarla. El destructor te permitirá
      ver que tarea está destruída correctamente.
      </p><p>
      En el siguiente ejemplo, las tareas de run( ) no están dirigidas por
      hilos separados; directamente es una simple llamada en main( ):
      </p><div class="example"><a id="idp5299696"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:NoThread.cpp</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  LiftOff <span class="hl kwd">launch</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
  launch<span class="hl opt">.</span><span class="hl kwd">run</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.2. C11/NoThread.cpp</strong></p></div><br class="example-break" /><p>
      Cuando una clase deriva de Runnable, debe tene una función run( ),
      pero no tiene nada de especial - no produce ninguna habibilidad innata
      en el hilo.
      </p><p>
      Para llevar a cabo el funcionamiento de los hilos, debes utilizas la
      clase Thread.
      </p></div></div><div class="sect1" title="10.3. Utilización de los hilos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5301632"></a>10.3. Utilización de los hilos</h2></div></div></div><p>
    Para controlar un objeto Runnable con un hilo, crea un objeto Thread
    separado y utiliza un pontero Runnable al constructor de Thread. Esto
    lleva a cabo la inicialización del hilo y, después, llama a run ( ) de
    Runnable como un hilo capaz de ser interrumpido. Manejando LiftOff con
    un hilo, el ejemplo siguiente muestra como cualquier tarea puede ser
    ejecutada en el contexto de cualquier otro hilo:
    </p><div class="example"><a id="idp5303072"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:BasicThreads.cpp</span>
<span class="hl slc">// The most basic use of the Thread class.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">));</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Waiting for LiftOff&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.3. C11/BasicThreads.cpp</strong></p></div><br class="example-break" /><p>
    Synchronization_Exception forma parte de la librería ZThread y la
    clase base para todas las excepciones de ZThread. Se lanzará si hay un
    error al crear o usar un hilo.
    </p><p>
      Un constructor de <code class="classname">Thread</code> sólo necesita un
      puntero a un objeto Runnable. Al crear un objeto
      <code class="classname">Thread</code> se efectuará la incialización
      necesaria del hilo y después se llamará a
      <code class="function">Runnable::run()</code>
    </p><p>
      Puede añadir más hilos fácilmente para controlar más tareas. A
      continuación, puede ver cómo los hilos se ejecutan con algún otro:
    </p><div class="example"><a id="idp5306960"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:MoreBasicThreads.cpp</span>
<span class="hl slc">// Adding more threads.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++)</span>
      Thread <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Waiting for LiftOff&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.4. C11/MoreBasicThreads.cpp</strong></p></div><br class="example-break" /><p>
      El segundo argumento del constructor
      de <code class="classname">LiftOff</code> identifica cada tarea. Cuando
      ejecute el programa, verá que la ejecución de las distintas
      tareas se mezclan a medida que los hilos entran y salen de su
      ejecución. Este intercambio está controlado automáticamente por
      el planificador de hilos. Si tiene múltiples procesadores en su
      máquina, el planificador de hilos distribuirá los hilos entre
      los procesadores de forma transparente.
    </p><p>
      El bucle for puede parecer un poco extraño a priori ya que se
      crea localmente dentro del bucle for e inmediatamente después
      sale del ámbito y es destruído. Esto hace que parezca que el
      hilo propiamente dicho pueda perderse inmediatamente, pero puede
      ver por la salida que los hilos, en efecto, están en ejecución
      hasta su finalización. Cuando crea un
      objeto <code class="classname">Thread</code>, el hilo asociado se
      registra en el sistema de hilos, que lo mantiene vivo. A pesar
      de que el objeto <code class="classname">Thread</code> local se pierde,
      el hilo sigue vivo hasta que su tarea asociada termina. Aunque
      puede ser poco intuitivo desde el punto de vista de C++, el
      concepto de hilos es la excepción de la regla: un hilo crea un
      hilo de ejecución separado que persiste después de que la
      llamada a función finalice. Esta excepción se refleja en la
      persistencia del hilo subyacente después de que el objeto
      desaparezca.
    </p><div class="sect2" title="10.3.1. Creación de interfaces de usuarios interactivas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5311936"></a>10.3.1. Creación de interfaces de usuarios interactivas</h3></div></div></div><p>
	Como se dijo anteriormente, uno de las motivaciones para usar
	hilos es crear interfaces de usuario interactivas. Aunque en
	este libro no cubriremos las interfaces gráficas de usuario,
	verá un ejemplo sencillo de una interfaz de usuario basada en
	consola.
      </p><p>
	El siguiente ejemplo lee líneas de un archivo y las imprime a
	la consola, durmiéndose (suspender el hilo actual) durante un
	segundo después de que cada línea sea mostrada. (Aprenderá más
	sobre el proceso de dormir hilos en el capítulo.) Durante este
	proceso, el programa no busca la entrada del usuario, por lo
	que la IU no es interactiva:
      </p><div class="example"><a id="idp5313952"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:UnresponsiveUI.cpp {RunByHand}</span>
<span class="hl slc">// Lack of threading produces an unresponsive UI.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Enter&gt; to quit:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  ifstream <span class="hl kwd">file</span><span class="hl opt">(</span><span class="hl str">&quot;UnresponsiveUI.cpp&quot;</span><span class="hl opt">);</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>file<span class="hl opt">,</span> line<span class="hl opt">)) {</span>
    cout <span class="hl opt">&lt;&lt;</span> line <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1000</span><span class="hl opt">);</span> <span class="hl slc">// Time in milliseconds</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Read input from the console</span>
  cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Shutting down...&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.5. C11/UnresponsiveUI.cpp</strong></p></div><br class="example-break" /><p>
	Para hacer este programa interactivo, puede ejecutar una tarea
	que muestre el archivo en un hilo separado. De esta forma, el
	hilo principal puede leer la entrada del usuario, por lo que
	el programa se vuelve interactivo:
      </p><div class="example"><a id="idp5315904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ResponsiveUI.cpp {RunByHand}</span>
<span class="hl slc">// Threading for a responsive user interface.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;fstream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> DisplayTask <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  ifstream in<span class="hl opt">;</span>
  string line<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> quitFlag<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DisplayTask</span><span class="hl opt">(</span><span class="hl kwb">const</span> string<span class="hl opt">&amp;</span> file<span class="hl opt">) :</span> <span class="hl kwd">quitFlag</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {</span>
    in<span class="hl opt">.</span><span class="hl kwd">open</span><span class="hl opt">(</span>file<span class="hl opt">.</span><span class="hl kwd">c_str</span><span class="hl opt">());</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">DisplayTask</span><span class="hl opt">() {</span> in<span class="hl opt">.</span><span class="hl kwd">close</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwd">getline</span><span class="hl opt">(</span>in<span class="hl opt">,</span> line<span class="hl opt">) &amp;&amp; !</span>quitFlag<span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt;</span> line <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1000</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">quit</span><span class="hl opt">() {</span> quitFlag <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Enter&gt; to quit:&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    DisplayTask<span class="hl opt">*</span> dt <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">DisplayTask</span><span class="hl opt">(</span><span class="hl str">&quot;ResponsiveUI.cpp&quot;</span><span class="hl opt">);</span>
    Thread <span class="hl kwd">t</span><span class="hl opt">(</span>dt<span class="hl opt">);</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    dt<span class="hl opt">-&gt;</span><span class="hl kwd">quit</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Shutting down...&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.6. C11/ResponsiveUI.cpp</strong></p></div><br class="example-break" /><p>
	Ahora el hilo main() puede responder inmediatamente cuando
	pulse Return e invocar quit()
	sobre <code class="classname">DisplayTask</code>.
      </p><p>
	Este ejemplo también muestra la necesidad de una comunicación
	entre tareas - la tarea en el hilo main() necesita parar
	al <code class="classname">DisplayTask</code>. Dado que tenemos un
	puntero a DisplayTask, puede pensar que bastaría con llamar al
	destructor de ese puntero para matar la tarea, pero esto hace
	que los programas sean poco fiables. El problema es que la
	tarea podría estar en mitad de algo importante cuando lo
	destruye y, por lo tanto, es probable que ponga el programa en
	un estado inestable. En este sentido, la propia tarea decide
	cuando es seguro terminar. La manera más sencilla de hacer
	esto es simplemente notificar a la tarea que desea detener
	mediante una bandera booleana. Cuando la tarea se encuentre en
	un punto estable puede consultar esa bandera y hacer lo que
	sea necesario para limpiar el estado después de regresar de
	run(). Cuando la tarea vuelve de
	run(), <code class="classname">Thread</code> sabe que la tarea se ha
	completado.
      </p><p>
	Aunque este programa es lo suficientemente simple para que no
	haya problemas, hay algunos pequeños defectos respecto a la
	comunicación entre pilas. Es un tema importante que se cubrirá
	más tarde en este capítulo.
      </p></div><div class="sect2" title="10.3.2. Simplificación con Ejecutores"><div class="titlepage"><div><div><h3 class="title"><a id="idp5322256"></a>10.3.2. Simplificación con Ejecutores</h3></div></div></div><p>
	Utilizando los Ejecutores de ZThread, puede simplificar su
	código. Los Ejecutores proporcionan una capa de indirección
	entre un cliente y la ejecución de una tarea; a diferencia de
	un cliente que ejecuta una tarea directamente, un objeto
	intermediario ejecuta la tarea.
      </p><p>
	Podemos verlo utilizando un Ejecutor en vez de la creación
	explícita de objetos <code class="classname">Thread</code> en
	MoreBasicThreads.cpp. Un objeto <code class="classname">LiftOff</code>
	conoce cómo ejecutar una tarea específica; como el patrón
	Command, expone una única función a ejecutar. Un
	objeto <code class="classname">Executor</code> conoce como construir
	el contexto apropiado para lanzar
	objetos <code class="classname">Runnable</code>. En el siguiente
	ejemplo, <code class="classname">ThreadedExecutor</code> crea un hilo
	por tarea:
      </p><div class="example"><a id="idp5325200"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: c11:ThreadedExecutor.cpp</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.7. C11/ThreadedExecutor.cpp</strong></p></div><br class="example-break" /><p>
	Note que algunos casos un <code class="classname">Executor</code>
	individual puede ser usado para crear y gestionar todo los
	hilos en su sistema. Debe colocar el código correspondiente a
	los hilos dentro de un bloque try porque el método execute()
	de un <code class="classname">Executor</code> puede lanzar una
	<code class="classname">Synchronization_Exception</code> si algo va
	mal. Esto es válido para cualquier función que implique
	cambiar el estado de un objeto de sincronización (arranque de
	hilos, la adquisición de mutexes, esperas en condiciones,
	etc.), tal y como aprenderá más adelante en este capítulo.
      </p><p>
	El programa finalizará cuando todas las tareas en
	el <code class="classname">Executor</code> hayan concluido.
      </p><p>
	En el siguiente
	ejemplo, <code class="classname">ThreadedExecutor</code> crea un hilo
	para cada tarea que quiera ejecutar, pero puede cambiar
	fácilmente la forma en la que esas tareas son ejecutadas
	reemplazando el <code class="classname">ThreadedExecutor</code> por un
	tipo diferente de <code class="classname">Executor</code>. En este
	capítulo, usar un <code class="classname">ThreadedExecutor</code> está
	bien, pero para código en producción puede resultar
	excesivamente costoso para la creación de muchos hilos. En ese
	caso, puede reemplazarlo por
	un <code class="classname">PoolExecutor</code>, que utilizará un
	conjunto limitado de hilos para lanzar las tareas registradas
	en paralelo:
      </p><div class="example"><a id="idp5331008"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:PoolExecutor.cpp</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/PoolExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    <span class="hl slc">// Constructor argument is minimum number of threads:</span>
    PoolExecutor <span class="hl kwd">executor</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">);</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.8. C11/PoolExecutor.cpp</strong></p></div><br class="example-break" /><p>
	Con <code class="classname">PoolExecutor</code> puede realizar una
	asignación inicial de hilos costosa de una sola vez, por
	adelantado, y los hilos se reutilizan cuando sea posible. Esto
	ahorra tiempo porque no está pagando el gasto de la creación
	de hilos por cada tarea individual de forma constante. Además,
	en un sistema dirigido por eventos, los eventos que requieren
	hilos para manejarlos puede ser generados tan rápido como
	quiera, basta con traerlos del pool. No excederá los recursos
	disponibles porque <code class="classname">PoolExecutor</code> utiliza
	un número limitado de
	objetos <code class="classname">Thread</code>. Así, aunque en este
	libro se utilizará <code class="classname">ThreadedExecutors</code>,
	tenga en cuenta utilizar <code class="classname">PoolExecutor</code>
	para código en producción.
      </p><p>
	<code class="classname">ConcurrentExecutor</code> es
	como <code class="classname">PoolExecutor</code> pero con un tamaño
	fijo de hilos. Es útil para cualquier cosa que quiera lanzar
	en otro hilo de forma continua (una tarea de larga duración),
	como una tare que escucha conexiones entrantes en un
	socket. También es útil para tareas cortas que quiera lanzar
	en un hilo, por ejemplo, pequeñas tareas que actualizar un log
	local o remoto, o para un hilo que atienda a eventos.
      </p><p>
	Si hay más de una tarea registrada en
	un <code class="classname">ConcurrentExecutor</code>, cada una de
	ellas se ejecutará completamente hasta que la siguiente
	empiece; todas utilizando el mismo hilo. En el ejemplo
	siguiente, verá que cada tarea se completa, en el orden en el
	que fue registrada, antes de que la siguiente comience. De
	esta forma, un <code class="classname">ConcurrentExecutor</code>
	serializa las tareas que le fueron asignadas.
      </p><div class="example"><a id="idp5337176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ConcurrentExecutor.cpp</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ConcurrentExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    ConcurrentExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.9. C11/ConcurrentExecutor.cpp</strong></p></div><br class="example-break" /><p>
	Como un <code class="classname">ConcurrentExecutor</code>,
	un <code class="classname">SynchronousExecutor</code> se usa cuando
	quiera una única tarea se ejecute al mismo tiempo, en serie en
	lugar de concurrente. A diferencia
	de <code class="classname">ConcurrentExecutor</code>,
	un <code class="classname">SynchronousExecutor</code> no crea ni
	gestiona hilos sobre si mismo. Utiliza el hilo que añadió la
	tarea y, así, únicamente actúa como un punto focal para la
	sincronización. Si tiene n tareas registradas en
	un <code class="classname">SynchronousExecutor</code>, nunca habrá 2
	tareas que se ejecuten a la vez. En lugar de eso, cada una se
	ejecutará hasta su finalización y la siguiente en la cola
	comenzará.
      </p><p>
	Por ejemplo, suponga que tiene un número de hilos ejecutando
	tareas que usan un sistema de archivos, pero está escribiendo
	código portable luego no quiere utilizar flock() u otra
	llamada al sistema operativo específica para bloquear un
	archivo. Puede lanzar esas tareas con
	un <code class="classname">SynchronousExecutor</code> para asegurar
	que solamente una de ellas, en un tiempo determinado, está
	ejecutándose desde cualquier hilo. De esta manera, no necesita
	preocuparse por la sincronización del recurso compartido (y,
	de paso, no se cargará el sistema de archivos). Una mejor
	solución pasa por sincronizar el recurso (lo cual aprenderá
	más adelante en este capítulo), sin embargo
	un <code class="classname">SynchronousExecutor</code> le permite
	evitar las molestias de obtener una coordinación adecuada para
	prototipar algo.
      </p><div class="example"><a id="idp5342888"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:SynchronousExecutor.cpp</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/SynchronousExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    SynchronousExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.10. C11/SynchronousExecutor.cpp</strong></p></div><br class="example-break" /><p>
	Cuando ejecuta el programa verá que las tareas son lanzadas en
	el orden en el que fueron registradas, y cada tarea se ejecuta
	completamente antes de que la siguiente empiece. ¿Qué es lo
	que no ve y que hace que no se creen nuevos hilos? El hilo
	main() se usa para cada tarea, y debido a este ejemplo, ese es
	el hilo que registra todas las tareas. Podría no utilizar
	un <code class="classname">SynchronousExecutor</code> en código en
	producción porque, principalmente, es para prototipado.
      </p></div><div class="sect2" title="10.3.3. Ceder el paso"><div class="titlepage"><div><div><h3 class="title"><a id="idp5345648"></a>10.3.3. Ceder el paso</h3></div></div></div><p>
	Si sabe que ha logrado realizar lo que necesita durante una
	pasada a través de un bucle en su función run() (la mayoría de
	las funciones run() suponen un periodo largo de tiempo de
	ejecución), puede darle un toque al mecanismo de planificación
	de hilos, decirle que ya ha hecho suficiente y que algún otro
	hilo puede tener la CPU. Este toque (y es un toque - no hay
	garantía de que su implementación vaya a escucharlo) adopta la
	forma de la función yield().
      </p><p>
	Podemos construir una versión modificada
	de los ejemplos de <code class="classname">LiftOff</code> cediendo el
	paso después de cada bucle:
      </p><div class="example"><a id="idp5347544"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:YieldingTask.cpp</span>
<span class="hl slc">// Suggesting when to switch threads with yield().</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> YieldingTask <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  <span class="hl kwb">int</span> countDown<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">YieldingTask</span><span class="hl opt">(</span><span class="hl kwb">int</span> ident <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">countDown</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">YieldingTask</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; completed&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> YieldingTask<span class="hl opt">&amp;</span> yt<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;#&quot;</span> <span class="hl opt">&lt;&lt;</span> yt<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> yt<span class="hl opt">.</span>countDown<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
      cout <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(--</span>countDown <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">yield</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">YieldingTask</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.11. C11/YieldingTask.cpp</strong></p></div><br class="example-break" /><p>
	Puede ver que la tarea del método <code class="function">run()</code>
	es en un bucle infinito en su totalidad. Utilizando yield(),
	la salida se equilibra bastante que en el caso en el que no se
	cede el paso. Pruebe a comentar la llamada a Thread::yield()
	para ver la diferencia. Sin embargo, en general, yield() es
	útil en raras ocasiones, y no puede contar con ella para
	realizar un afinamiento serio sobre su aplicación.
      </p></div><div class="sect2" title="10.3.4. Dormido"><div class="titlepage"><div><div><h3 class="title"><a id="idp5350768"></a>10.3.4. Dormido</h3></div></div></div><p>
	Otra forma con la que puede tener control sobre el
	comportamiento de su hilos es llamando a sleep() para cesar la
	ejecución de uno de ellos durante un número de milisegundos
	dado. En el ejemplo que viene a continuación, si cambia la llamada a
	yield() por una a sleep(), obtendrá lo siguiente:
      </p><div class="example"><a id="idp5351904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:SleepingTask.cpp</span>
<span class="hl slc">// Calling sleep() to pause for awhile.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> SleepingTask <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  <span class="hl kwb">int</span> countDown<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">SleepingTask</span><span class="hl opt">(</span><span class="hl kwb">int</span> ident <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">) :</span> <span class="hl kwd">countDown</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">SleepingTask</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; completed&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> SleepingTask<span class="hl opt">&amp;</span> st<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;#&quot;</span> <span class="hl opt">&lt;&lt;</span> st<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> st<span class="hl opt">.</span>countDown<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
      <span class="hl kwa">try</span> <span class="hl opt">{</span>
        cout <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl kwa">if</span><span class="hl opt">(--</span>countDown <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>
      <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
        cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">SleepingTask</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.12. C11/SleepingTask.cpp</strong></p></div><br class="example-break" /><p>
	Thread::sleep() puede lanzar
	una <code class="classname">Interrupted_Exception</code>(sobre las
	interrupciones aprenderá más adelante), y puede ver que esta
	excepción se captura en run(). Sin embargo, la tarea se crea y
	se ejecuta dentro de un bloque try en main() que
	captura <code class="classname">Interrupted_Exception</code> (la clase
	base para todas las excepciones de ZThread), por lo que ¿no
	sería posible ignorar la excepción en run() y asumir que se
	propagará al manejador en main()?. Esto no funcionará porque
	las excepciones no se propagarán a lo largo de los hilos para
	volver hacia main(). De esta forma, debe manejar cualquier
	excepción que pueda ocurrir dentro de una tarea de forma
	local.
      </p><p>
	Notará que los hilos tienden a ejecutarse en cualquier orden,
	lo que quiere decir que sleep() tampoco es una forma de
	controlar el orden de la ejecución de los hilos. Simplemente
	para la ejecución del hilo durante un rato. La única garantía
	que tiene es que el hilo se dormirá durante, al menos, 100
	milisegundos (en este ejemplo), pero puede que tarde más
	después de que el hilo reinicie la ejecución ya que el
	planificador de hilos tiene que volver a él tras haber
	expirado el intervalo.
      </p><p>
	Si debe tener control sobre el orden de la ejecución de hilos,
	su mejor baza es el uso de controles de sincronización
	(descritos más adelante) o, en algunos casos, no usar hilos en
	todo, FIXMEbut instead to write your own cooperative routines that
	hand control to each other in a specified order.
      </p></div><div class="sect2" title="10.3.5. Prioridad"><div class="titlepage"><div><div><h3 class="title"><a id="idp5358168"></a>10.3.5. Prioridad</h3></div></div></div><p>
	La prioridad de un hilo representa la importancia de ese hilo
	para el planificador. Pese a que el orden en que la CPU
	ejecuta un conjunto de hilos es indeterminado, el planificador
	tenderá a ejecutar el hilo con mayor prioridad de los que
	estén esperando. Sin embargo, no quiere decir que hilos con
	menos prioridad no se ejecutarán (es decir, no tendrá bloqueo
	de un hilo a causa de las prioridades). Simplemente, los hilos
	con menos prioridad tenderán a ejecutarse menos frecuentemente.
      </p><p>
	Se ha modificado MoreBasicThreads.cpp para mostrar los niveles
	de prioridad. Las prioridades se ajustan utilizando la función
	setPriority() de <code class="classname">Thread</code>.
      </p><div class="example"><a id="idp5360360"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:SimplePriorities.cpp</span>
<span class="hl slc">// Shows the use of thread priorities.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">const double</span> pi <span class="hl opt">=</span> <span class="hl num">3.14159265358979323846</span><span class="hl opt">;</span>
<span class="hl kwb">const double</span> e <span class="hl opt">=</span> <span class="hl num">2.7182818284590452354</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> SimplePriorities <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  <span class="hl kwb">int</span> countDown<span class="hl opt">;</span>
  <span class="hl kwc">volatile</span> <span class="hl kwb">double</span> d<span class="hl opt">;</span> <span class="hl slc">// No optimization</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">SimplePriorities</span><span class="hl opt">(</span><span class="hl kwb">int</span> ident<span class="hl opt">=</span><span class="hl num">0</span><span class="hl opt">):</span> <span class="hl kwd">countDown</span><span class="hl opt">(</span><span class="hl num">5</span><span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">SimplePriorities</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; completed&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> SimplePriorities<span class="hl opt">&amp;</span> sp<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;#&quot;</span> <span class="hl opt">&lt;&lt;</span> sp<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; priority: &quot;</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl kwd">Thread</span><span class="hl opt">().</span><span class="hl kwd">getPriority</span><span class="hl opt">()</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; count: &quot;</span><span class="hl opt">&lt;&lt;</span> sp<span class="hl opt">.</span>countDown<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span><span class="hl kwa">true</span><span class="hl opt">) {</span>
      <span class="hl slc">// An expensive, interruptable operation:</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100000</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
        d <span class="hl opt">=</span> d <span class="hl opt">+ (</span>pi <span class="hl opt">+</span> e<span class="hl opt">) /</span> <span class="hl kwb">double</span><span class="hl opt">(</span>i<span class="hl opt">);</span>
      cout <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">if</span><span class="hl opt">(--</span>countDown <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">high</span><span class="hl opt">(</span><span class="hl kwa">new</span> SimplePriorities<span class="hl opt">);</span>
    high<span class="hl opt">.</span><span class="hl kwd">setPriority</span><span class="hl opt">(</span>High<span class="hl opt">);</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      Thread <span class="hl kwd">low</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">SimplePriorities</span><span class="hl opt">(</span>i<span class="hl opt">));</span>
      low<span class="hl opt">.</span><span class="hl kwd">setPriority</span><span class="hl opt">(</span>Low<span class="hl opt">);</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.13. C11/SimplePriorities.cpp</strong></p></div><br class="example-break" /><p>
	En este ejemplo, el operador &lt;&lt;() se sobreescribe para mostrar
	el identificador, la prioridad y el valor de countDown de la
	tarea.
      </p><p>
	Puede ver que el nivel de prioridad del hilo es el más alto, y
	que el resto de hilos tienen el nivel más bajo. No
	utilizamos <code class="classname">Executor</code> en este ejemplo
	porque necesitamos acceder directamente al hilo para
	configurar sus propiedades.
      </p><p>
	Dentro de SimplePriorities::run() se ejecutan 100,000 veces un
	costoso conjunto de cálculos en punto flotante. La variable d
	es volátil para intentar garantizar que ningún compilador hace
	optimizaciones. Sin este cálculo, no comprobará el efecto de
	la configuración de los niveles de prioridad. (Pruébelo:
	comente el bucle for que contiene los cálculos en doble
	precisión.) Con el cálculo puede ver que el planificador de
	hilos al hilo high se le da más preferencia. (Al menos, este
	fue el comportamiento sobre una máquina Windows). El cálculo
	tarda lo suficiente para que el mecanismo de planificación de
	hilos lo salte, cambie hilos y tome en cuenta las prioridades
	para que el hilo high tenga preferencia.
      </p><p>
	También, puede leer la prioridad de un hilo existente con
	getPriority() y cambiarla en cualquier momento (no sólo antes
	de que el hilo se ejecute, como en SimplePriorities.cpp) con
	setPriority().
      </p><p>
	La correspondencia de las prioridades con el sistema operativo
	es un problema. Por ejemplo, Windows 2000 tiene siete niveles
	de prioridades, mientras que Solaris de Sun tiene 231. El
	único enfoque portable es ceñirse a los niveles discretos de
	prioridad, como Low, Medium y High utilizados en la librería
	ZThread.
      </p></div></div><div class="sect1" title="10.4. Comparición de recursos limitados"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5367656"></a>10.4. Comparición de recursos limitados</h2></div></div></div><p>
      Piense en un programa con un único hilo como una solitaria
      entidad moviéndose a lo largo del espacio de su problema y
      haciendo una cosa en cada instante. Debido a que sólo hay una
      entidad, no tiene que preocuparse por el problema de dos
      entidades intentando usar el mismo recurso al mismo tiempo:
      problemas como dos personas intentando aparcar en el mismo
      sitio, pasar por una puerta al mismo tiempo o incluso hablar al
      mismo tiempo.
    </p><p>
      Con multihilado las cosas ya no son solitarias, pero ahora tiene
      la posibilidad de tener dos o más hilos intentando utilizar un
      mismo recurso a la vez. Esto puede causar dos problemas
      distintos. El primero es que el recurso necesario podría no
      existir. En C++, el programador tiene un control total sobre la
      vida de los objetos, y es fácil crear hilos que intenten usar
      objetos que han sido destruidos antes de que esos hilos hayan
      finalizado.
    </p><p>
      El segundo problema es que dos o más hilos podrían chocar cuando
      intenten acceder al mismo dispositivo al mismo tiempo. Si no
      previene esta colisión, tendrá dos hilos intentando acceder a la
      misma cuenta bancaria al mismo tiempo, imprimir en la misma
      impresora, ajustar la misma válvula, etc.
    </p><p>
      Esta sección presenta el problema de los objetos que desaparecen
      mientras las tareas aún están usándolos y el problema del choque
      entre tareas sobre recursos compartidos. Aprenderá sobre las
      herramientas que se usan para solucionar esos problemas.
    </p><div class="sect2" title="10.4.1. Aseguramiento de la existencia de objetos"><div class="titlepage"><div><div><h3 class="title"><a id="idp5371576"></a>10.4.1. Aseguramiento de la existencia de objetos</h3></div></div></div><p>
	La gestión de memoria y recursos son las principales
	preocupaciones en C++. Cuando crea cualquier programa en C++,
	tiene la opción de crear objetos en la pila o en el heap
	(utilizando new). En un programa con un solo hilo, normalmente
	es sencillo seguir la vida de los objetos con el fin de que no
	tenga que utilizar objetos que ya están destruidos.
      </p><p>
	Los ejemplos mostrados en este capítulo crean
	objetos <code class="classname">Runnable</code> en el heap utilizando
	new, se dará cuenta que esos objetos nunca son destruidos
	explícitamente. Sin embargo, podrá por la salida cuando
	ejecuta el programa que la biblioteca de hilos sigue la pista
	a cada tarea y, eventualmente, las destruye. Esto ocurre
	cuando el método Runnable::run() finaliza - volver de run()
	indica que la tarea ha finalizado.
      </p><p>
	Recargar el hilo al destruir una tarea es un problema. Ese
	hilo sabe necesariamente si otro necesita hacer referencia a
	ese Runnable, y por ello el Runnable podría ser destruido
	prematuramente. Para ocuparse de este problema, el mecanismo
	de la biblioteca ZThread mantiene un conteo de referencias
	sobre las tareas. Una tarea se mantiene viva hasta que su
	contador de referencias se pone a cero, en este punto la tarea
	se destruye. Esto quiere decir que las tareas tienen que ser
	destruidas dinámicamente siempre, por lo que no pueden ser
	creadas en la pila. En vez de eso, las tareas deben ser
	creadas utilizando new, tal y como puede ver en todos los
	ejemplos de este capítulo.  tareas in ZThreads
      </p><p>
	Además, también debe asegurar que los objetos que no son
	tareas estarán vivos tanto tiempo como el que las tareas
	necesiten de ellos. Por otro lado, resulta sencillo para los
	objetos utilizados por las tareas salir del ámbito antes de
	que las tareas hayan concluido. Si ocurre esto, las tareas
	intentarán acceder zonas de almacenamiento ilegales y
	provocará que el programa falle. He aquí un simple ejemplo:
      </p><div class="example"><a id="idp5375904"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Incrementer.cpp {RunByHand}</span>
<span class="hl slc">// Destroying objects while threads are still</span>
<span class="hl slc">// running will cause serious problems.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Count <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> SZ <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> n<span class="hl opt">[</span>SZ<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">increment</span><span class="hl opt">() {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++)</span>
      n<span class="hl opt">[</span>i<span class="hl opt">]++;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Incrementer <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  Count<span class="hl opt">*</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Incrementer</span><span class="hl opt">(</span>Count<span class="hl opt">*</span> c<span class="hl opt">) :</span> <span class="hl kwd">count</span><span class="hl opt">(</span>c<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> n <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span> n <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">;</span> n<span class="hl opt">--) {</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">250</span><span class="hl opt">);</span>
      count<span class="hl opt">-&gt;</span><span class="hl kwd">increment</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;This will cause a segmentation fault!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  Count count<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">t0</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Incrementer</span><span class="hl opt">(&amp;</span>count<span class="hl opt">));</span>
    Thread <span class="hl kwd">t1</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Incrementer</span><span class="hl opt">(&amp;</span>count<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.14. C11/Incrementer.cpp</strong></p></div><br class="example-break" /><p>
	Podría parecer a priori que la
	clase <code class="classname">Count</code> es excesiva, pero si
	únicamente n es un int (en lugar de una matriz), el compilador
	puede ponerlo dentro de un registro y ese almacenamiento
	seguirá estando disponible (aunque técnicamente es ilegal)
	después de que el objeto <code class="classname">Count</code> salga
	del ámbito. Es difícil detectar la violación de memoria en
	este caso. Sus resultados podrían variar dependiendo de su
	compilador y de su sistema operativo, pero pruebe a que n sea
	un int y verá qué ocurre. En cualquier evento,
	si <code class="classname">Count</code> contiene una matriz de ints y
	como antes, el compilador está obligado a ponerlo en la pila y
	no en un registro.
      </p><p>
	<code class="classname">Incrementer</code> es una tarea sencilla que
	utiliza un objeto <code class="classname">Count</code>. En main(),
	puede ver que las tareas <code class="classname">Incrementer</code> se
	ejecutan el tiempo suficiente para que el salga del ámbito,
	por lo que la tarea intentará acceder a un objeto que no
	existe. Esto produce un fallo en el programa.
	objeto <code class="classname">Count</code>
      </p><p>
	Para solucionar este problema, debemos garantizar que
	cualquiera de los objetos compartidos entre tareas estarán
	accesibles tanto tiempo como las tareas los necesiten. (Si los
	objetos no fueran compartidos, podrían estar directamente
	dentro de las clases de las tareas y, así, unir su tiempo de
	vida a la tarea.) Dado que no queremos que el propio ámbito
	estático del programa controle el tiempo de vida del objeto,
	pondremos el en heap. Y para asegurar que el objeto no se
	destruye hasta que no haya objetos (tareas, en este caso) que
	lo estén utilizando, utilizaremos el conteo de referencias.
      </p><p>
	El conteo de referencias se ha explicado a lo largo del
	volumen uno de este libro y además se revisará en este
	volumen. La librería ZThread incluye una plantilla
	llamada <code class="classname">CountedPtr</code> que automáticamente
	realiza el conteo de referencias y destruye un objeto cuando
	su contador de referencias vale cero. A continuación, se ha
	modificado el programa para que
	utilice <code class="classname">CountedPtr</code> para evitar el
	fallo:
      </p><div class="example"><a id="idp5383712"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ReferenceCounting.cpp</span>
<span class="hl slc">// A CountedPtr prevents too-early destruction.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/CountedPtr.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Count <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> SZ <span class="hl opt">=</span> <span class="hl num">100</span> <span class="hl opt">};</span>
  <span class="hl kwb">int</span> n<span class="hl opt">[</span>SZ<span class="hl opt">];</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">increment</span><span class="hl opt">() {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++)</span>
      n<span class="hl opt">[</span>i<span class="hl opt">]++;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Incrementer <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CountedPtr<span class="hl opt">&lt;</span>Count<span class="hl opt">&gt;</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Incrementer</span><span class="hl opt">(</span><span class="hl kwb">const</span> CountedPtr<span class="hl opt">&lt;</span>Count<span class="hl opt">&gt;&amp;</span> c <span class="hl opt">) :</span> <span class="hl kwd">count</span><span class="hl opt">(</span>c<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> n <span class="hl opt">=</span> <span class="hl num">100</span><span class="hl opt">;</span> n <span class="hl opt">&gt;</span> <span class="hl num">0</span><span class="hl opt">;</span> n<span class="hl opt">--) {</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">250</span><span class="hl opt">);</span>
      count<span class="hl opt">-&gt;</span><span class="hl kwd">increment</span><span class="hl opt">();</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  CountedPtr<span class="hl opt">&lt;</span>Count<span class="hl opt">&gt;</span> <span class="hl kwd">count</span><span class="hl opt">(</span><span class="hl kwa">new</span> Count<span class="hl opt">);</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">t0</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Incrementer</span><span class="hl opt">(</span>count<span class="hl opt">));</span>
    Thread <span class="hl kwd">t1</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Incrementer</span><span class="hl opt">(</span>count<span class="hl opt">));</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.15. C11/ReferenceCounting.cpp</strong></p></div><br class="example-break" /><p>
	Ahora <code class="classname">Incrementer</code> contiene un
	objeto <code class="classname">CountedPtr</code>, que gestiona
	un <code class="classname">Count</code>. En la función main(), los
	objetos <code class="classname">CountedPtr</code> se pasan a los dos
	objetos <code class="classname">Incrementer</code> por valor, por lo
	que se llama el constructor de copia, incrementando el
	conteo de referencias. Mientras la tarea esté ejecutándose, el
	contador de referencias no valdrá cero, por lo que el
	objeto <code class="classname">Count</code> utilizado
	por <code class="classname">CountedPtr</code> no será
	destruído. Solamente cuando todas las tareas que utilice
	el <code class="classname">Count</code> terminen se llamará al
	destructor (automáticamente) sobre el
	objeto <code class="classname">Count</code> por
	el <code class="classname">CountedPtr</code>.
     </p><p>
	Siempre que tenga una tarea que utilice más de un objeto, casi
	siempre necesitará controlar aquellos objetos utilizando la
	plantilla <code class="classname">CountedPtr</code> para evitar
	problemas derivados del tiempo de vida de los objetos.
      </p></div><div class="sect2" title="10.4.2. Acceso no apropiado a recursos"><div class="titlepage"><div><div><h3 class="title"><a id="idp5389184"></a>10.4.2. Acceso no apropiado a recursos</h3></div></div></div><p>
	Considere el siguiente ejemplo, donde una tarea genera números
	constantes y otras tareas consumen esos números. Ahora, el
	único trabajo de los hilos consumidores es probar la validez
	de los números constantes.
      </p><p>
	Primeramente, definiremos <code class="classname">EvenChecker</code>,
	el hilo consumidor, puesto que será reutilizado en todos los
	ejemplos siguientes. Para
	desacoplar <code class="classname">EvenChecker</code> de los varios
	tipos de generadores con los que experimentaremos, crearemos
	una interfaz llamada <code class="classname">Generator</code> que
	contiene el número mínimo de funciones
	que <code class="classname">EvenChecker</code> necesita conocer: por
	lo que tiene una función nextValue() y que puede ser
	cancelada.
      </p><div class="example"><a id="idp5391824"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:EvenChecker.h</span>
<span class="hl ppc">#ifndef EVENCHECKER_H</span>
<span class="hl ppc">#define EVENCHECKER_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/CountedPtr.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Cancelable.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Generator <span class="hl opt">:</span> <span class="hl kwc">public</span> ZThread<span class="hl opt">::</span>Cancelable <span class="hl opt">{</span>
  <span class="hl kwb">bool</span> canceled<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Generator</span><span class="hl opt">() :</span> <span class="hl kwd">canceled</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">int</span> <span class="hl kwd">nextValue</span><span class="hl opt">() =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cancel</span><span class="hl opt">() {</span> canceled <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">isCanceled</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> canceled<span class="hl opt">; }</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> EvenChecker <span class="hl opt">:</span> <span class="hl kwc">public</span> ZThread<span class="hl opt">::</span>Runnable <span class="hl opt">{</span>
  ZThread<span class="hl opt">::</span>CountedPtr<span class="hl opt">&lt;</span>Generator<span class="hl opt">&gt;</span> generator<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">EvenChecker</span><span class="hl opt">(</span>ZThread<span class="hl opt">::</span>CountedPtr<span class="hl opt">&lt;</span>Generator<span class="hl opt">&gt;&amp;</span> g<span class="hl opt">,</span> <span class="hl kwb">int</span> ident<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">generator</span><span class="hl opt">(</span>g<span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {}</span>
  <span class="hl opt">~</span><span class="hl kwd">EvenChecker</span><span class="hl opt">() {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~EvenChecker &quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(!</span>generator<span class="hl opt">-&gt;</span><span class="hl kwd">isCanceled</span><span class="hl opt">()) {</span>
      <span class="hl kwb">int</span> val <span class="hl opt">=</span> generator<span class="hl opt">-&gt;</span><span class="hl kwd">nextValue</span><span class="hl opt">();</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>val <span class="hl opt">%</span> <span class="hl num">2</span> <span class="hl opt">!=</span> <span class="hl num">0</span><span class="hl opt">) {</span>
        std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> val <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; not even!&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
        generator<span class="hl opt">-&gt;</span><span class="hl kwd">cancel</span><span class="hl opt">();</span> <span class="hl slc">// Cancels all EvenCheckers</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Test any type of generator:</span>
  <span class="hl kwc">template</span><span class="hl opt">&lt;</span>typename GenType<span class="hl opt">&gt;</span> <span class="hl kwb">static void</span> <span class="hl kwd">test</span><span class="hl opt">(</span><span class="hl kwb">int</span> n <span class="hl opt">=</span> <span class="hl num">10</span><span class="hl opt">) {</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press Control-C to exit&quot;</span> <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      ZThread<span class="hl opt">::</span>ThreadedExecutor executor<span class="hl opt">;</span>
      ZThread<span class="hl opt">::</span>CountedPtr<span class="hl opt">&lt;</span>Generator<span class="hl opt">&gt;</span> <span class="hl kwd">gp</span><span class="hl opt">(</span><span class="hl kwa">new</span> GenType<span class="hl opt">);</span>
      <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> n<span class="hl opt">;</span> i<span class="hl opt">++)</span>
        executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">EvenChecker</span><span class="hl opt">(</span>gp<span class="hl opt">,</span> i<span class="hl opt">));</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>ZThread<span class="hl opt">::</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
      std<span class="hl opt">::</span>cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// EVENCHECKER_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.16. C11/EvenChecker.h</strong></p></div><br class="example-break" /><p>
	La clase <code class="classname">Generator</code> presenta la clase
	abstracta <code class="classname">Cancelable</code>, que es parte de
	la biblioteca de ZThread. El propósito
	de <code class="classname">Cancelable</code> es proporcionar una
	interfaz consistente para cambiar el estado de un objeto via
	cancel() y ver si el objeto ha sido cancelado con la función
	isCanceled(). Aquí utilizamos el enfoque simple de una bandera
	de cancelación booleana similar a quitFlag, vista previamente
	en ResponsiveUI.cpp. Note que en este ejemplo la clase que
	es <code class="classname">Cancelable</code> no
	es <code class="classname">Runnable</code>. En su lugar, toda
	tarea <code class="classname">EvenChecker</code> que dependa de un
	objeto <code class="classname">Cancelable</code>
	(el <code class="classname">Generator</code>) lo comprueba para ver
	que ha sido cancelado, como puede ver en run(). De esta
	manera, las tareas que comparten recursos comunes
	(el <code class="classname">Cancelable</code> <code class="classname">Generator</code>)
	estén atentos a la señal de ese recurso para terminar. Esto
	elimina la también conocida condición de carrera, donde dos o
	más tareas compiten por responder una condición y, así,
	colisionar o producir resultados inconsistentes. Debe pensar
	sobre esto cuidadosamente y protegerse de todas las formas
	posible de los fallos de un sistema concurrente. Por ejemplo,
	una tarea no puede depender de otra porque el orden de
	finalización de las tareas no está garantizado. En este
	sentido, eliminamos la potencial condición de carrera haciendo
	que las tareas dependan de objetos que no son tareas (que son
	contados referencialmente
	utilizando <code class="classname">CountedPtr</code>.
      </p><p>
	En las secciones posteriores, verá que la librería ZThread
	contiene más mecanismos generales para la terminación de hilos.
      </p><p>
	Debido a que muchos objetos <code class="classname">EvenChecker</code>
	podrían terminar compartiendo
	un <code class="classname">Generator</code>, la
	plantilla <code class="classname">CountedPtr</code> se usa para contar
	las referencias de los
	objetos <code class="classname">Generator</code>.
      </p><p>
	El último método en <code class="classname">EvenChecker</code> es un
	miembro estático de la plantilla que configura y realiza una
	comprobación de los tipos de <code class="classname">Generator</code>
	creando un <code class="classname">CountedPtr</code> dentro y,
	seguidamente, lanzar un número
	de <code class="classname">EvenChecker</code>s que usan
	ese <code class="classname">Generator</code>. Si
	el <code class="classname">Generator</code> provoca un fallo, test()
	lo reportará y volverá; en otro caso, deberá pulsar Control-C
	para finalizarlo.
      </p><p>
	Las tareas <code class="classname">EvenChecker</code> leen
	constantemente y comprueban que los valores de
	sus <code class="classname">Generator</code>s asociados. Vea que si
	generator-&gt;isCanceled() es verdadero, run() retorna, con lo
	que se le dice al <code class="classname">Executor</code> de
	EvenChecker::test() que la tarea se ha
	completado. Cualquier tarea <code class="classname">EvenChecker</code>
	puede llamar a cancel() sobre
	su <code class="classname">Generator</code> asociado, lo que causará
	que todos los demás <code class="classname">EvenChecker</code>s que
	utilicen ese <code class="classname">Generator</code> finalicen con
	elegancia.
      </p><p>
	<code class="classname">EvenGenerator</code> es simple -
	nextValue() produce el siguiente valor constante:
      </p><div class="example"><a id="idp5406064"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:EvenGenerator.cpp</span>
<span class="hl slc">// When threads collide.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;EvenChecker.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> EvenGenerator <span class="hl opt">:</span> <span class="hl kwc">public</span> Generator <span class="hl opt">{</span>
  <span class="hl kwb">unsigned int</span> currentEvenValue<span class="hl opt">;</span> <span class="hl slc">// Unsigned can't overflow</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">EvenGenerator</span><span class="hl opt">() {</span> currentEvenValue <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">EvenGenerator</span><span class="hl opt">() {</span> cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~EvenGenerator&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">; }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">nextValue</span><span class="hl opt">() {</span>
    <span class="hl opt">++</span>currentEvenValue<span class="hl opt">;</span> <span class="hl slc">// Danger point here!</span>
    <span class="hl opt">++</span>currentEvenValue<span class="hl opt">;</span>
    <span class="hl kwa">return</span> currentEvenValue<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  EvenChecker<span class="hl opt">::</span>test<span class="hl opt">&lt;</span>EvenGenerator<span class="hl opt">&gt;();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.17. C11/EvenGenerator.cpp</strong></p></div><br class="example-break" /><p>
	Es posible que un hilo llame a nextValue() después de el
	primer incremento de currentEvenValue y antes del segundo (en
	el lugar "Danger point here!" del código comentado), que pone
	el valor en un estado "incorrecto". Para probar que esto puede
	ocurrir, EventChecker::test() crea un grupo de
	objetos <code class="classname">EventChecker</code> para leer
	continuamente la salida de
	un <code class="classname">EvenGenerator</code> y ver si cada valor es
	constante. Si no es así, el error se reporta y el programa
	finaliza.
      </p><p>
	Este programa podría no detectar el problema hasta
	que <code class="classname">EvenGenerator</code> ha completado varios
	ciclos, dependiendo de las particuliaridades de su sistema
	operativo y otros detalles de implementación. Si quiere ver
	que falla mucho más rápido, pruebe a poner una llamada a
	yield() entre el primero y segundo incremento. En algún
	evento, fallará puntualmente a causa de que los
	hilos <code class="classname">EvenChecker</code> pueden acceder a la
	información en <code class="classname">EvenGenerator</code> mientras
	se encuentra en un estado "incorrecto".
      </p></div><div class="sect2" title="10.4.3. Control de acceso"><div class="titlepage"><div><div><h3 class="title"><a id="idp5411048"></a>10.4.3. Control de acceso</h3></div></div></div><p>
	En el ejemplo anterior se muestra el problema fundamental a la
	hora de utilizar hilos: nunca sabrá cuándo un hilo puede ser
	ejecutado. Imagínese sentado en la mesa con un tenedor, a
	punto de coger el último pedazo de comida de un plato y tan
	pronto como su tenedor lo alcanza, de repente, la comida se
	desvanece (debido a que su hilo fue suspendido y otro vino y
	se comió la comida). Ese es el problema que estamos tratando a
	la hora de escribir programas concurrentes.
      </p><p>
	En ocasiones no le importará si un recurso está siendo
	accedido a la vez que intenta usarlo. Pero en la mayoría de
	los casos sí, y para trabajar con múltiples hilos necesitará
	alguna forma de evitar que dos hilos accedan al mismo recurso,
	al menos durante períodos críticos.
      </p><p>
	Para prevenir este tipo de colisiones existe una manera
	sencilla que consiste en poner un bloqueo sobre un recursos
	cuando un hilo trata de usarlo. El primer hilo que accede al
	recursos lo bloquea y, así, otro hilo no puede acceder al
	recurso hasta que no sea desbloqueado, momento en el que este
	hilo lo vuelve a bloquear y lo vuelve a usar, y así
	sucesivamente.
      </p><p>
	De esta forma, tenemos que ser capaces de evitar cualquier
	tarea de acceso a memoria mientras ese almacenamiento no esté
	en un estado adecuado. Esto es, necesitamos tener un mecanismo
	que excluya una segunda tarea sobre el acceso a memoria cuando
	una primera tarea ya está usándola. Esta idea es fundamental
	para todo sistema multihilado y se conoce como exclusión
	mutua; abreviado como mutex. La biblioteca ZThread tiene un
	mecanismo de mutex en el fichero de cabecera Mutex.h.
      </p><p>
	Para solucionar el problema en el programa anterior,
	identificaremos las secciones críticas donde debe aplicarse la
	exclusión mutua; posteriormente, antes de entrar en la sección
	crítica adquiriremos el mutex y lo liberaremos cuando finalice
	la sección crítica. Únicamente un hilo podrá adquirir el mutex
	al mismo tiempo, por lo que se logra exclusión mutua:
      </p><div class="example"><a id="idp5416128"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:MutexEvenGenerator.cpp {RunByHand}</span>
<span class="hl slc">// Preventing thread collisions with mutexes.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;EvenChecker.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> MutexEvenGenerator <span class="hl opt">:</span> <span class="hl kwc">public</span> Generator <span class="hl opt">{</span>
  <span class="hl kwb">unsigned int</span> currentEvenValue<span class="hl opt">;</span>
  Mutex lock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">MutexEvenGenerator</span><span class="hl opt">() {</span> currentEvenValue <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">MutexEvenGenerator</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~MutexEvenGenerator&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">nextValue</span><span class="hl opt">() {</span>
    lock<span class="hl opt">.</span><span class="hl kwd">acquire</span><span class="hl opt">();</span>
    <span class="hl opt">++</span>currentEvenValue<span class="hl opt">;</span>
    Thread<span class="hl opt">::</span><span class="hl kwd">yield</span><span class="hl opt">();</span> <span class="hl slc">// Cause failure faster</span>
    <span class="hl opt">++</span>currentEvenValue<span class="hl opt">;</span>
    <span class="hl kwb">int</span> rval <span class="hl opt">=</span> currentEvenValue<span class="hl opt">;</span>
    lock<span class="hl opt">.</span><span class="hl kwd">release</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> rval<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  EvenChecker<span class="hl opt">::</span>test<span class="hl opt">&lt;</span>MutexEvenGenerator<span class="hl opt">&gt;();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.18. C11/MutexEvenGenerator.cpp</strong></p></div><br class="example-break" /><p>
	<code class="classname">MutexEvenGenerator</code> añade
	un <code class="classname">Mutex</code> llamado lock y utiliza
	acquire() y release() para crear una sección crítica con
	nextValue(). Además, se ha insertado una llamada a
	Thread::yield() entre los dos incrementos, para aumentar la
	probabilidad de que haya un cambio de contexto mientras
	currentEvenValue se encuentra en un estado extraño. Este hecho
	no producirá un fallo ya que el mutex evita que más de un hilo
	esté en la sección crítica al mismo tiempo, pero llamar a
	yield() es una buena forma de provocar un fallo si este
	ocurriera.
      </p><p>
	Note que nextValue() debe capturar el valor de retorno dentro
	de la sección crítica porque si lo devolviera dentro de la
	sección critica no liberaría lock y así evitar que fuera
	adquirido. (Normalmente, esto conllevaría un interbloqueo, de
	lo cual aprenderá sobre ello al final de este capítulo.)
      </p><p>
	El primer hilo que entre en nextValue() adquirirá lock y
	cualquier otro hilo que intente adquirirlo será bloqueado
	hasta que el primer hilo libere lock. En ese momento, el
	mecanismo de planificación selecciona otro hilo que esté
	esperando en lock. De esta manera, solo un hilo puede pasar a
	través del código custodiado por el mutex al mismo tiempo.
      </p></div><div class="sect2" title="10.4.4. Código simplificado mediante guardas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5421224"></a>10.4.4. Código simplificado mediante guardas</h3></div></div></div><p>
	El uso de mutexes se convierte rápidamente complicado cuando
	se introducen excepciones. Para estar seguro de que el mutes
	siempre se libera, debe asegurar que cualquier camino a una
	excepción incluya una llamada a release(). Además, cualquier
	función que tenga múltiples caminos para retornar debe
	asegurar cuidadosamente que se llama a release() en el momento
	adecuado.
      </p><p>
	Esos problemas pueden se fácilmente solucionados utilizando el
	hecho de que los objetos de la pila (automáticos) tiene un
	destructor que siempre se llama sea cual sea la forma en que
	salga del ámbito de la función. En la librería ZThread, esto
	se implementa en la plantilla <code class="classname">Guard</code>. La
	plantilla <code class="classname">Guard</code> crea objetos que
	adquieren un objeto <code class="classname">Lockable</code> cuando se
	construyen y lo liberan cuando son destruidos. Los
	objetos <code class="classname">Guard</code> creados en la pila local
	serán eliminados automáticamente independientemente de la
	forma en el que la función finalice y siempre desbloqueará el
	objeto <code class="classname">Lockable</code>. A continuación, el
	ejemplo anterior reimplementado para
	utilizar <code class="classname">Guard</code>s:
      </p><div class="example"><a id="idp5425024"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:GuardedEvenGenerator.cpp {RunByHand}</span>
<span class="hl slc">// Simplifying mutexes with the Guard template.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;EvenChecker.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> GuardedEvenGenerator <span class="hl opt">:</span> <span class="hl kwc">public</span> Generator <span class="hl opt">{</span>
  <span class="hl kwb">unsigned int</span> currentEvenValue<span class="hl opt">;</span>
  Mutex lock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">GuardedEvenGenerator</span><span class="hl opt">() {</span> currentEvenValue <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">; }</span>
  <span class="hl opt">~</span><span class="hl kwd">GuardedEvenGenerator</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~GuardedEvenGenerator&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">nextValue</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl opt">++</span>currentEvenValue<span class="hl opt">;</span>
    Thread<span class="hl opt">::</span><span class="hl kwd">yield</span><span class="hl opt">();</span>
    <span class="hl opt">++</span>currentEvenValue<span class="hl opt">;</span>
    <span class="hl kwa">return</span> currentEvenValue<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  EvenChecker<span class="hl opt">::</span>test<span class="hl opt">&lt;</span>GuardedEvenGenerator<span class="hl opt">&gt;();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.19. C11/GuardedEvenGenerator.cpp</strong></p></div><br class="example-break" /><p>
	Note que el valor de retorno temporal ya no es necesario en
	nextValue(). En general, hay menos código que escribir y la
	probabilidad de errores por parte del usuario se reduce en
	gran medida.
      </p><p>
	Una característica interesante de la
	plantilla <code class="classname">Guard</code> es que puede ser usada
	para manipular otros elementos de seguridad. Por ejemplo, un
	segundo <code class="classname">Guard</code> puede ser utilizado
	temporalmente para desbloquear un elemento de seguridad:
      </p><div class="example"><a id="idp5428616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:TemporaryUnlocking.cpp</span>
<span class="hl slc">// Temporarily unlocking another guard.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>

<span class="hl kwc">class</span> TemporaryUnlocking <span class="hl opt">{</span>
  Mutex lock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl slc">// lock is acquired</span>
    <span class="hl slc">// ...</span>
    <span class="hl opt">{</span>
      Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">,</span> UnlockedScope<span class="hl opt">&gt;</span> <span class="hl kwd">h</span><span class="hl opt">(</span>g<span class="hl opt">);</span>
      <span class="hl slc">// lock is released</span>
      <span class="hl slc">// ...</span>
      <span class="hl slc">// lock is acquired</span>
    <span class="hl opt">}</span>
    <span class="hl slc">// ...</span>
    <span class="hl slc">// lock is released</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  TemporaryUnlocking t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.20. C11/TemporaryUnlocking.cpp</strong></p></div><br class="example-break" /><p>
	Un <code class="classname">Guard</code> también puede utilizarse para
	adquirir un lock durante un determinado tiempo y, después,
	liberarlo:
      </p><div class="example"><a id="idp5430616"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:TimedLocking.cpp</span>
<span class="hl slc">// Limited time locking.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>

<span class="hl kwc">class</span> TimedLocking <span class="hl opt">{</span>
  Mutex lock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">,</span> TimedLockedScope<span class="hl opt">&lt;</span><span class="hl num">500</span><span class="hl opt">&gt; &gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl slc">// ...</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  TimedLocking t<span class="hl opt">;</span>
  t<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.21. C11/TimedLocking.cpp</strong></p></div><br class="example-break" /><p>
	En este ejemplo, se lanzará
	una <code class="classname">Timeout_Exception</code> si el lock no
	puede ser adquirido en 500 milisegundos.
      </p><p>Sincronización de clases completas</p><p>
	La librería ZThread también proporciona la
	plantilla <code class="classname">GuardedClass</code> para crear
	automáticamente un recubrimiento de sincronización para toda
	una clase. Esto quiere decir que cualquier método de una clase
	estará automáticamente protegido:
      </p><div class="example"><a id="idp5433640"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:SynchronizedClass.cpp {-dmc}</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/GuardedClass.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>

<span class="hl kwc">class</span> MyClass <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">func1</span><span class="hl opt">() {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">func2</span><span class="hl opt">() {}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  MyClass a<span class="hl opt">;</span>
  a<span class="hl opt">.</span><span class="hl kwd">func1</span><span class="hl opt">();</span> <span class="hl slc">// Not synchronized</span>
  a<span class="hl opt">.</span><span class="hl kwd">func2</span><span class="hl opt">();</span> <span class="hl slc">// Not synchronized</span>
  GuardedClass<span class="hl opt">&lt;</span>MyClass<span class="hl opt">&gt;</span> <span class="hl kwd">b</span><span class="hl opt">(</span><span class="hl kwa">new</span> MyClass<span class="hl opt">);</span>
  <span class="hl slc">// Synchronized calls, only one thread at a time allowed:</span>
  b<span class="hl opt">-&gt;</span><span class="hl kwd">func1</span><span class="hl opt">();</span>
  b<span class="hl opt">-&gt;</span><span class="hl kwd">func2</span><span class="hl opt">();</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.22. C11/SynchronizedClass.cpp</strong></p></div><br class="example-break" /><p>
	El objeto a no está sincronizado, por lo que func1() y func2()
	pueden ser llamadas en cualquier momento por cualquier número
	de hilos. El objeto b está protegido por el
	recubrimiento <code class="classname">GuardedClass</code>, así que
	cada método se sincroniza automáticamente y solo se puede
	llamar a una función por objeto en cualquier instante.
      </p><p>
	El recubrimiento bloquea un tipo de nivel de granularidad, que
	podría afectar al rendimiento.[151] Si una clase contiene
	funciones no vinculadas, puede ser mejor sincronizarlas
	internamente con 2 locks diferentes. Sin embargo, si se
	encuentra haciendo esto, significa que la clase contiene
	grupos de datos que puede no estar fuertemente
	asociados. Considere dividir la clase en dos.
      </p><p>
	Proteger todos los métodos de una clase con un mutex no hace
	que esa clase sea segura automáticamente cuando se utilicen
	hilos. Debe tener cuidado con estas cuestiones para garantizar
	la seguridad cuando se usan hilos.
      </p></div><div class="sect2" title="10.4.5. Almacenamiento local al hilo"><div class="titlepage"><div><div><h3 class="title"><a id="idp5437784"></a>10.4.5. Almacenamiento local al hilo</h3></div></div></div><p>
	Una segunda forma de eliminar el problema de colisión de
	tareas sobre recursos compartidos es la eliminación de las
	variables compartidas, lo cual puede realizarse mediante la
	creación de diferentes almacenamientos para la misma variable,
	uno por cada hilo que use el objeto. De esta forma, si tiene
	cinco hilos que usan un objeto con una variable x, el
	almacenamiento local al hilo genera automáticamente cinco
	porciones de memoria distintas para almacenar
	x. Afortunadamente, la creación y gestión del almacenamiento
	local al hilo la lleva a cabo una plantilla de ZThread
	llamada <code class="classname">ThreadLocal</code>, tal y como se
	puede ver aquí:
      </p><div class="example"><a id="idp5439328"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ThreadLocalVariables.cpp {RunByHand}</span>
<span class="hl slc">// Automatically giving each thread its own storage.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Cancelable.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadLocal.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/CountedPtr.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> ThreadLocalVariables <span class="hl opt">:</span> <span class="hl kwc">public</span> Cancelable <span class="hl opt">{</span>
  ThreadLocal<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> value<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> canceled<span class="hl opt">;</span>
  Mutex lock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">ThreadLocalVariables</span><span class="hl opt">() :</span> <span class="hl kwd">canceled</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {</span>
    value<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">increment</span><span class="hl opt">() {</span> value<span class="hl opt">.</span><span class="hl kwd">set</span><span class="hl opt">(</span>value<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">() +</span> <span class="hl num">1</span><span class="hl opt">); }</span>
  <span class="hl kwb">int</span> <span class="hl kwd">get</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> value<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">(); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cancel</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    canceled <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">isCanceled</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">return</span> canceled<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Accessor <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
  CountedPtr<span class="hl opt">&lt;</span>ThreadLocalVariables<span class="hl opt">&gt;</span> tlv<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Accessor</span><span class="hl opt">(</span>CountedPtr<span class="hl opt">&lt;</span>ThreadLocalVariables<span class="hl opt">&gt;&amp;</span> tl<span class="hl opt">,</span> <span class="hl kwb">int</span> idn<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">id</span><span class="hl opt">(</span>idn<span class="hl opt">),</span> <span class="hl kwd">tlv</span><span class="hl opt">(</span>tl<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(!</span>tlv<span class="hl opt">-&gt;</span><span class="hl kwd">isCanceled</span><span class="hl opt">()) {</span>
      tlv<span class="hl opt">-&gt;</span><span class="hl kwd">increment</span><span class="hl opt">();</span>
      cout <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
    <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> Accessor<span class="hl opt">&amp;</span> a<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;#&quot;</span> <span class="hl opt">&lt;&lt;</span> a<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> a<span class="hl opt">.</span>tlv<span class="hl opt">-&gt;</span><span class="hl kwd">get</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Enter&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    CountedPtr<span class="hl opt">&lt;</span>ThreadLocalVariables<span class="hl opt">&gt;</span>
      <span class="hl kwd">tlv</span><span class="hl opt">(</span><span class="hl kwa">new</span> ThreadLocalVariables<span class="hl opt">);</span>
    <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++)</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Accessor</span><span class="hl opt">(</span>tlv<span class="hl opt">,</span> i<span class="hl opt">));</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    tlv<span class="hl opt">-&gt;</span><span class="hl kwd">cancel</span><span class="hl opt">();</span> <span class="hl slc">// All Accessors will quit</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.23. C11/ThreadLocalVariables.cpp</strong></p></div><br class="example-break" /><p>
	Cuando crea un objeto <code class="classname">ThreadLocal</code>
	instanciando la plantilla, únicamente puede acceder al
	contenido del objeto utilizando los métodos set() y get(). El
	método get() devuelve una copia del objeto que está asociado a
	ese hilo, y set() inserta su argumento dentro del objeto
	almacenado para ese hilo, devolviendo el objeto antiguo que se
	encontraba almacenado. Puede comprobar que esto se utiliza en
	increment() y get()
	de <code class="classname">ThreadLocalVariables</code>.
      </p><p>
	Ya que tlv se comparte en múltiples
	objetos <code class="classname">Accessor</code>, está escrito como
	un <code class="classname">Cancelable</code>, por lo que
	los <code class="classname">Accessors</code> puede recibir señales
	cuando queramos parar el sistema.
      </p><p>
	Cuando ejecute este programa se evidenciará que se reserva
	para cada hilo su propio almacenamiento.
      </p></div></div><div class="sect1" title="10.5. Finalización de tareas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5445456"></a>10.5. Finalización de tareas</h2></div></div></div><p>
      En los ejemplos anteriores, hemos visto el uso de una "bandera
      de terminación" o de la
      interfaz <code class="classname">Cancelable</code> para finalizar una
      tarea. Este es un enfoque razonable para el problema. Sin
      embargo, en algunas ocasiones la tarea tiene que ser finalizada
      más abruptamente. En esta sección, aprenderá sobre las
      cuestiones y problemas de este tipo de finalización.
    </p><p>
      Primeramente, veamos en un ejemplo que no sólo demuestra el
      problema de la finalización sino que, además, es un ejemplo
      adicional de comparición de recursos. Para mostrar el ejemplo,
      primero necesitaremos resolver el problema de la colisión de
      iostream.
    </p><div class="sect2" title="10.5.1. Prevención de coliciones en iostream"><div class="titlepage"><div><div><h3 class="title"><a id="idp5447824"></a>10.5.1. Prevención de coliciones en iostream</h3></div></div></div><p>
FIXME: dos versiones:

	Podría haberse dado cuenta en los anteriores ejemplos que la
	salida es confusa en algunas ocasiones. Los iostreams de C++
	no fueron creados pensando en el sistema de hilos, por lo que
	no hay

	Puede haberse dado cuenta en los ejemplos anteriores que la
	salida es FIXMEconfusa. El sistema iostream de C++ no fue
	creado con el sistema de hilos en mente, por no lo que no hay
	nada que prevenga que la salida de un hilo interfiera con la
	salida de otro hilo. Por ello, debe escribir aplicaciones de
	tal forma que sincronicen el uso de iostreams.

      </p><p>
	Para solucionar el problema, primero necesitamos crear un
	paquete completo de salida y, después, decidir explícitamente
	cuando intentamos mandarlo a la consola. Una sencilla solución
	pasa por escribir la informacion en un ostringstream y
	posteriormente utilizar un único objeto con un mutex como
	punto de salida de todos los hilos, para evitar que más de un
	hilo escriba al mismo tiempo:
      </p><div class="example"><a id="idp5450072"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Display.h</span>
<span class="hl slc">// Prevents ostream collisions.</span>
<span class="hl ppc">#ifndef DISPLAY_H</span>
<span class="hl ppc">#define DISPLAY_H</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;sstream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Display <span class="hl opt">{</span> <span class="hl slc">// Share one of these among all threads</span>
  ZThread<span class="hl opt">::</span>Mutex iolock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">output</span><span class="hl opt">(</span>std<span class="hl opt">::</span>ostringstream<span class="hl opt">&amp;</span> os<span class="hl opt">) {</span>
    ZThread<span class="hl opt">::</span>Guard<span class="hl opt">&lt;</span>ZThread<span class="hl opt">::</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>iolock<span class="hl opt">);</span>
    std<span class="hl opt">::</span>cout <span class="hl opt">&lt;&lt;</span> os<span class="hl opt">.</span><span class="hl kwd">str</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DISPLAY_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.24. C11/Display.h</strong></p></div><br class="example-break" /><p>
	De esta manera, predefinimos la función estandar
	<code class="function">operator&lt;&lt;()</code> y el objeto puede ser
	construido en memoria utilizando operadores habituales de
	ostream. Cuando una tarea quiere mostrar una salida, crea un
	objeto ostringstream temporal que utiliza FIXME. Cuando llama
	a output(), el mutex evita que varios hilos escriban a este
	objeto <code class="classname">Display</code>. (Debe usar solo un
	objeto <code class="classname">Display</code> en su programa, tal y
	como verá en los siguientes ejemplos.)
      </p><p>
	Todo esto muestra la idea básica pero, si es necesario, puede
	construir un entorno más elaborado. Por ejemplo, podría forzar
	el requisito de que solo haya un
	objeto <code class="classname">Display</code> en un programa
	haciéndolo Singleton. (La librería ZThread tiene una
	plantilla <code class="classname">Singleton</code> para dar soporte a
	Singletons).
      </p></div><div class="sect2" title="10.5.2. El jardín ornamental"><div class="titlepage"><div><div><h3 class="title"><a id="idp5454384"></a>10.5.2. El jardín ornamental</h3></div></div></div><p>
	En esta simulación, al comité del jardín le gustaría saber
	cuanta gente entra en el jardín cada día a través de distintas
	puertas. Cada puerta tiene un FIXMEturnstile o algún otro tipo
	de contador, y después de que el contador FIXMEturnstile se
	incrementa, aumenta una cuenta compartida que representa el
	número total de gente en el jardín.
      </p><div class="example"><a id="idp5455592"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:OrnamentalGarden.cpp {RunByHand}</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;vector&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Display.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/FastMutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/CountedPtr.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Count <span class="hl opt">:</span> <span class="hl kwc">public</span> Cancelable <span class="hl opt">{</span>
  FastMutex lock<span class="hl opt">;</span>
  <span class="hl kwb">int</span> count<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> paused<span class="hl opt">,</span> canceled<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Count</span><span class="hl opt">() :</span> <span class="hl kwd">count</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">paused</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span> <span class="hl kwd">canceled</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">increment</span><span class="hl opt">() {</span>
    <span class="hl slc">// Comment the following line to see counting fail:</span>
    Guard<span class="hl opt">&lt;</span>FastMutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwb">int</span> temp <span class="hl opt">=</span> count <span class="hl opt">;</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span><span class="hl kwd">rand</span><span class="hl opt">() %</span> <span class="hl num">2</span> <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl slc">// Yield half the time</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">yield</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> <span class="hl opt">(</span>count  <span class="hl opt">= ++</span>temp<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">value</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>FastMutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">return</span> count<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">cancel</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>FastMutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    canceled <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">isCanceled</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>FastMutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">return</span> canceled<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">pause</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>FastMutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    paused <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">isPaused</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>FastMutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">return</span> paused<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Entrance <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CountedPtr<span class="hl opt">&lt;</span>Count<span class="hl opt">&gt;</span> count<span class="hl opt">;</span>
  CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;</span> display<span class="hl opt">;</span>
  <span class="hl kwb">int</span> number<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> waitingForCancel<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Entrance</span><span class="hl opt">(</span>CountedPtr<span class="hl opt">&lt;</span>Count<span class="hl opt">&gt;&amp;</span> cnt<span class="hl opt">,</span>
    CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;&amp;</span> disp<span class="hl opt">,</span> <span class="hl kwb">int</span> idn<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">count</span><span class="hl opt">(</span>cnt<span class="hl opt">),</span> <span class="hl kwd">display</span><span class="hl opt">(</span>disp<span class="hl opt">),</span> <span class="hl kwd">number</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>idn<span class="hl opt">),</span>
    <span class="hl kwd">waitingForCancel</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(!</span>count<span class="hl opt">-&gt;</span><span class="hl kwd">isPaused</span><span class="hl opt">()) {</span>
      <span class="hl opt">++</span>number<span class="hl opt">;</span>
      <span class="hl opt">{</span>
        ostringstream os<span class="hl opt">;</span>
        os <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; Total: &quot;</span>
           <span class="hl opt">&lt;&lt;</span> count<span class="hl opt">-&gt;</span><span class="hl kwd">increment</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
        display<span class="hl opt">-&gt;</span><span class="hl kwd">output</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
      <span class="hl opt">}</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>
    waitingForCancel <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    <span class="hl kwa">while</span><span class="hl opt">(!</span>count<span class="hl opt">-&gt;</span><span class="hl kwd">isCanceled</span><span class="hl opt">())</span> <span class="hl slc">// Hold here...</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>
    ostringstream os<span class="hl opt">;</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Terminating &quot;</span> <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    display<span class="hl opt">-&gt;</span><span class="hl kwd">output</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getValue</span><span class="hl opt">() {</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>count<span class="hl opt">-&gt;</span><span class="hl kwd">isPaused</span><span class="hl opt">() &amp;&amp; !</span>waitingForCancel<span class="hl opt">)</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> number<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Entrance<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Entrance &quot;</span> <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span>number<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;ENTER&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  CountedPtr<span class="hl opt">&lt;</span>Count<span class="hl opt">&gt;</span> <span class="hl kwd">count</span><span class="hl opt">(</span><span class="hl kwa">new</span> Count<span class="hl opt">);</span>
  vector<span class="hl opt">&lt;</span>Entrance<span class="hl opt">*&gt;</span> v<span class="hl opt">;</span>
  CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;</span> <span class="hl kwd">display</span><span class="hl opt">(</span><span class="hl kwa">new</span> Display<span class="hl opt">);</span>
  <span class="hl kwb">const int</span> SZ <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      Entrance<span class="hl opt">*</span> task <span class="hl opt">=</span> <span class="hl kwa">new</span> <span class="hl kwd">Entrance</span><span class="hl opt">(</span>count<span class="hl opt">,</span> display<span class="hl opt">,</span> i<span class="hl opt">);</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>task<span class="hl opt">);</span>
      <span class="hl slc">// Save the pointer to the task:</span>
      v<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>task<span class="hl opt">);</span>
    <span class="hl opt">}</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span> <span class="hl slc">// Wait for user to press &lt;Enter&gt;</span>
    count<span class="hl opt">-&gt;</span><span class="hl kwd">pause</span><span class="hl opt">();</span> <span class="hl slc">// Causes tasks to stop counting</span>
    <span class="hl kwb">int</span> sum <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
    vector<span class="hl opt">&lt;</span>Entrance<span class="hl opt">*&gt;::</span>iterator it <span class="hl opt">=</span> v<span class="hl opt">.</span><span class="hl kwd">begin</span><span class="hl opt">();</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>it <span class="hl opt">!=</span> v<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">()) {</span>
      sum <span class="hl opt">+= (*</span>it<span class="hl opt">)-&gt;</span><span class="hl kwd">getValue</span><span class="hl opt">();</span>
      <span class="hl opt">++</span>it<span class="hl opt">;</span>
    <span class="hl opt">}</span>
    ostringstream os<span class="hl opt">;</span>
    os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Total: &quot;</span> <span class="hl opt">&lt;&lt;</span> count<span class="hl opt">-&gt;</span><span class="hl kwd">value</span><span class="hl opt">() &lt;&lt;</span> endl
       <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Sum of Entrances: &quot;</span> <span class="hl opt">&lt;&lt;</span> sum <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    display<span class="hl opt">-&gt;</span><span class="hl kwd">output</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
    count<span class="hl opt">-&gt;</span><span class="hl kwd">cancel</span><span class="hl opt">();</span> <span class="hl slc">// Causes threads to quit</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.25. C11/OrnamentalGarden.cpp</strong></p></div><br class="example-break" /><p>
	<code class="classname">Count</code> es la clase que conserva el
	contador principal de los visitantes del jardín. El objeto
	único <code class="classname">Count</code> definido en main() como
	contador FIXME is held como
	un <code class="classname">CountedPtr</code>
	en <code class="classname">Entrance</code> y, así, se comparte entre
	todos los objetos <code class="classname">Entrance</code>. En este
	ejemplo, se utiliza un <code class="classname">FastMutex</code>
	llamado lock en vez de un <code class="classname">Mutex</code>
	ordinario ya que un <code class="classname">FastMutex</code> usa el
	mutex nativo del sistema operativo y, por ello, aportará
	resultados más interesantes.
      </p><p>
	Se utiliza un <code class="classname">Guard</code> con bloqueo en
	increment() para sincronizar el acceso a count. Esta función
	usa rand() para realizar una carga de trabajo alta (mediante
	yield()) FIXME  la mitad del tiempo, ....
      </p><p>
	La clase <code class="classname">Entrance</code> también mantiene una
	variable local numbre con el número de visitantes que han
	pasado a través de una entrada concreta. Esto proporciona un
	chequeo doble contra el objeto count para asegurar que el
	verdadero número de visitantes es el que se está
	almacenando. Entrance::run() simplemente incrementa number y
	el objeto count y se duerme durante 100 milisegundos.

      </p><p>
	En main, se carga
	un <code class="type">vector&lt;Entrance*&gt;</code> con
	cada <code class="classname">Entrance</code> que se crean. Después de
	que el usuario pulse Enter, el vector se utiliza para iterar
	sobre el valor de cada <code class="classname">Entrance</code> y
	calcular el total.
      </p><p>
	FIXMEThis program goes to quite a bit of extra trouble to shut
      everything down in a stable fashion.
      </p><p>
	Toda la comunicación entre los objetos
	<code class="classname">Entrance</code> ocurre a través de un único
	objeto <code class="classname">Count</code>. Cuando el usuario pulsa
	Enter, main() manda el mensaje pause() a count. Como cada
	Entrance::run() está vigilando a que el objeto count esté
	pausado, esto hace que cada <code class="classname">Entrance</code> se
	mueva al estado waitingForCancel, donde no se cuenta más, pero
	aún sigue vivo. Esto es esencial porque main() debe poder
	seguir iterando de forma segura sobre los objetos del
	vector&lt;Entrace*&gt;. Note que debido a que existe una
	FIXMEpequeña posibilidad que la iteración pueda ocurrir antes
	de que un <code class="classname">Entrance</code> haya terminado de
	contar y haya ido al estado de waitingForCancel, la función
	getValue() itera a lo largo de las llamadas a sleep() hasta
	que el objeto vaya al estado de waitingForCancel. (Esta es una
	forma, que se conoce como espera activa, y es indeseable. Verá
	un enfoque más apropiado utilizando wait(), más adelante en el
	capítulo). Una vez que main() completa una iteración a lo
	largo del vector&lt;Entrance*&gt;, se manda el mensaje de cancel()
	al objeto count, y de nuevo todos los objetos
	<code class="classname">Entrance</code> esperan a este cambio de
	estado. En ese instante, imprimen un mensaje de finalización y
	salen de run(), por lo que el mecanismo de hilado destruye
	cada tarea.
      </p><p>
	Tal y como este programa se ejecuta, verá que la cuenta total
	y la de cada una de las entradas se muestran a la vez que la
	gente pasa a través de un FIXMEturnstile. Si comenta el
	objeto <code class="classname">Guard</code> en Count::increment(), se
	dará cuenta que el número total de personas no es el que
	espera que sea. El número de personas contadas por cada
	FIXMEturnstile será diferente del valor de count. Tan pronto
	como haya un <code class="classname">Mutex</code> para sincronizar el
	acceso al <code class="classname">Counter</code>, las cosas
	funcionarán correctamente. Tenga en cuenta que
	Count::increment() exagera la situación potencial de fallo que
	supone utilizar temp y yield(). En problemas reales de hilado,
	la probabilidad de fallo puede ser estadísticamente menor, por
	lo que puede caer fácilmente en la trampa de creer que las
	cosas funcionan correctamente. Tal y como muestra el problema
	anterior, existen FIXMElikely problemas ocultos que no le han
	ocurrido, por lo que debe ser excepcionalmente diligente
	cuando revise código concurrente.
      </p><div class="sect3" title="Operaciones atómicas"><div class="titlepage"><div><div><h4 class="title"><a id="idp5472984"></a>Operaciones atómicas</h4></div></div></div><p>
	Note que Count::value() devuelve el valor de count utilizando
	un objeto <code class="classname">Guard</code> para la
	sincronización. Esto ofrece un aspecto interesante porque este
	código probablemente funcionará bien con la mayoría de los
	compiladores y sistemas sin sincronización. El motivo es que,
	en general, una operación simple como devolver un int será una
	operación atómica, que quiere decir que probablemente se
	llevará a cabo con una única instrucción de microprocesador y
	no será interrumpida. (El mecanismo de multihilado no puede
	parar un hilo en mitad de una instrucción de microprocesador.)
	Esto es, las operaciones atómicas no son interrumpibles por el
	mecanismo de hilado y, así, no necesitan ser protegidas.[152]
	De hecho, si elimináramos la asignación de count en temp y
	quitáramos yield(), y en su lugar simplemente incrementáramos
	count directamente, probablemente no necesitaríamos un lock ya
	que la operación de incremento es, normalmente, atómica. [153]
      </p><p>
	El problema es que el estándar de C++ no garantiza la
	atomicidad para ninguna de esas operaciones. Sin embargo, pese
	a que operaciones como devolver un int e incrementar un int
	son atómicas en la mayoría de las máquinas no hay garantías. Y
	puesto que no hay garantía, debe asumir lo peor. En algunas
	ocasiones podría investigar el funcionamiento de la atomicidad
	para una máquina en particular (normalmente mirando el
	lenguaje ensamblador) y escribir código basado en esas
	asunciones. Esto es siempre peligroso y FIXMEill-advised. Es
	muy fácil que esta información se pierda o esté oculta, y la
	siguiente persona que venga podría asumir que el código puede
	ser portado a otra máquina y, por ello, volverse loco
	siguiendo la pista al FIXMEoccsional glitch provocado por la
	colisión de hilos.
      </p><p>
	Por ello, aunque quitar el guarda en Count::value() parezca
	que funciona no es FIXMEairtight y, así, en algunas máquinas
	puede ver un comportamiento aberrante.
      </p></div></div><div class="sect2" title="10.5.3. FIXME:Teminación al bloquear"><div class="titlepage"><div><div><h3 class="title"><a id="idp5478280"></a>10.5.3. FIXME:Teminación al bloquear</h3></div></div></div><p>
	En el ejemplo anterior, Entrance::run() incluye una llamada a
	sleep() en el bucle principal. Sabemos que sleep() se
	despertará eventualmente y que la tarea llegará al principio
	del bucle donde tiene una oportunidad para salir de ese bucle
	chequeando el estado isPaused(). Sin embargo, sleep() es
	simplemente una situación donde un hilo en ejecución se
	bloquea, y a veces necesita terminar una tarea que está
	bloqueada.
      </p><p>
	Un hilo puede estar en alguno de los cuatro estados:
      </p><p>
	1. Nuevo: Un hilo permanece en este estado solamente de forma
	momentánea, tan solo cuando se crea. Reserva todos los
	recursos del sistema necesarios y ejecuta la
	inicialización. En este momento se convierte en FIXMEcandidato
	para recibir tiempo de CPU. A continuación, el planificador
	llevará a este hilo al estado de ejecución o de bloqueo.
      </p><p>
	2. Ejecutable: Esto significa que un hilo puede ser ejecutado
	cuando el mecanismo de fraccionador de tiempo tenga ciclos de
	CPU disponibles para el hilo. Así, el hilo podría o no
	ejecutarse en cualquier momento, pero no hay nada que evite FIXME
      </p><p>
	3. Bloqueado: El hilo pudo ser ejecutado, pero algo lo
	impidió. (Podría estar esperando a que se complete una
	operación de entrada/salida, por ejemplo.) Mientras un hilo
	esté en el estado de bloqueo, el planificador simplemente lo
	ignorará y no le dará tiempo de CPU. Hasta que un hilo no
	vuelva a entrar en el estado de ejecución, no ejecutará
	ninguna operación.
      </p><p>
	4. FIXMEMuerte: Un hilo en el estado de muerto no será
	planificable y no recibirá tiempo de CPU. Sus tareas han
	finalizado, y no será ejecutable nunca más. La forma normal
	que un hilo tiene para morir es volviendo de su función
	run().
      </p><p>
	Un hilo está bloqueado cuando no puede continuar su
	ejecución. Un hilo puede bloquearse debido a los siguientes
	motivos:
      </p><p>
	Puso el hilo a dormir llamando a sleep(milisegundos), en cuyo
	caso no será ejecutado durante el tiempo especificado.
      </p><p>
	Suspendió la ejecución del hilo con wait(). No volverá a ser
	ejecutable hasta que el hilo no obtenga el mensaje signal() o
	broadcast(). Estudiaremos esto en una sección más adelante.
      </p><p>
	El hilo está esperando a que una operación de entrada/salida
	finalice.
      </p><p>
	El hilo está intentando entrar en un bloque de código
	controlado por un mutex, y el mutex ha sido ya adquirido por
	otro hilo.
      </p><p>
	El problema que tenemos ahora es el siguiente: algunas veces
	quiere terminar un hilo que está en el estado de bloqueo. Si
	no puede esperar a que el hilo llegue a un punto en el código
	donde pueda comprobar el valor del estado y decidir si
	terminar por sus propios medios, debe forzar a que el hilo
	salga de su estado de bloqueo.
      </p></div><div class="sect2" title="10.5.4. Interrupción"><div class="titlepage"><div><div><h3 class="title"><a id="idp5486576"></a>10.5.4. Interrupción</h3></div></div></div><p>
	Tal y como podría imaginar, es mucho más FIXMEmessier salir de
	forma brusca en mitad de la función Runnable::run() que si
	espera a que esa función llegue al test de isCanceled() (o a
	algún otro lugar donde el programador esté preparado para
	salir de la función). Cuando sale de una tarea bloqueada,
	podría necesitar destruir objetos y liberar recursos. Debido a
	esto, salir en mitad de un run() de una tarea, más que otra
	cosa, consiste en lanzar una excepción, por lo que en
	ZThreads, las excepciones se utilizan para este tipo de
	terminación. (Esto roza el límite de un uso inapropiado de las
	excepciones, porque significa que las utiliza para el control
	de flujo.)[154] Para volver de esta manera a un buen estado
	conocido a la hora de terminar una tarea, tenga en cuenta
	cuidadosamente los caminos de ejecución de su código y libere
	todo correctamente dentro de los bloques catch. Veremos esta
	técnica en la presente sección.
      </p><p>
	Para finalizar un hilo bloqueado, la librería ZThread
	proporciona la función Thread::interrupted(). Esta configura
	el estado de interrupción para ese hilo. Un hilo con su estado
	de interrupción configurado lanzará una Interrupted_Exception
	si está bloqueado o si espera una operación bloqueante. El
	estado de interrupción será restaurado cuando se haya lanzado
	la excepción o si la tarea llama a Thread::interrupted(). Como
	puede ver, Thread::interrupted() proporciona otra forma de
	salir de su bucle run(), sin lanzar una excepción.
      </p><p>
	A continuación, un ejemplo que ilustra las bases de interrupt():
      </p><div class="example"><a id="idp5490208"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Interrupting.cpp</span>
<span class="hl slc">// Interrupting a blocked thread.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Blocked <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1000</span><span class="hl opt">);</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Waiting for get() in run():&quot;</span><span class="hl opt">;</span>
      cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Caught Interrupted_Exception&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl slc">// Exit the task</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl kwa">new</span> Blocked<span class="hl opt">);</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">&gt;</span> <span class="hl num">1</span><span class="hl opt">)</span>
      Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1100</span><span class="hl opt">);</span>
    t<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.26. C11/Interrupting.cpp</strong></p></div><br class="example-break" /><p>
	Puede ver que, además de la inserción de cout, run() tiene dos
	puntos donde puede ocurrir el bloqueo: la llamada a
	Thread::sleep(1000) y la llamada a cin.get(). Dando cualquier
	argumento por línea de comandos al programa, dirá a main()
	que se duerma lo suficiente para que la tarea finalice su
	sleep() y llame a cin.get().[155] Si no le da un argumento, el
	sleep() de main() se ignora. Ahora, la llamada a interrupt()
	ocurrirá mientras la tarea está dormida, y verá que esto
	provoca que una Interrupted_Exception se lance. Si le da un
	argumento por línea de comandos al programa, descubrirá que la
	tarea no puede ser interrumpida si está bloqueada en la
	entrada/salida. Esto es, puede interrumpir cualquier operación
	bloqueante a excepción de una entrada/salida.[156]
      </p><p>
	Esto es un poco desconcertante si está creando un hilo que
	ejecuta entrada/salida porque quiere decir que la
	entrada/salida tiene posibilidades de bloquear su programa
	multihilado. El problema es que, de nuevo, C++ no fue
	diseñado con el sistema de hilos en mente; muy al contrario,
	FIXMEpresupone que el hilado no existe. Por ello, la librería
	iostream no ses thread-friendly. Si el nuevo estándar de C++
	decide añadir soporte a hilos, la librería iostream podría
	necesitar ser reconsiderada en el proceso. Bloqueo debido a un
	mutex.

      </p><p>
	Si intenta llamar a una función cuyo mutes ha sido adquirido,
	la tarea que llama será suspendida hasta que el mutex esté
	accesible. El siguiente ejemplo comprueba si este tipo de
	bloqueo es interrumpible:
      </p><div class="example"><a id="idp5495152"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Interrupting2.cpp</span>
<span class="hl slc">// Interrupting a thread blocked</span>
<span class="hl slc">// with a synchronization guard.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> BlockedMutex <span class="hl opt">{</span>
  Mutex lock<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">BlockedMutex</span><span class="hl opt">() {</span>
    lock<span class="hl opt">.</span><span class="hl kwd">acquire</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl slc">// This will never be available</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Blocked2 <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  BlockedMutex blocked<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Waiting for f() in BlockedMutex&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      blocked<span class="hl opt">.</span><span class="hl kwd">f</span><span class="hl opt">();</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
      cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl slc">// Exit the task</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl kwa">new</span> Blocked2<span class="hl opt">);</span>
    t<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.27. C11/Interrupting2.cpp</strong></p></div><br class="example-break" /><p>
	La clase <code class="classname">BlockedMutex</code> tiene un
	constructor que adquiere su propio
	objeto <code class="classname">Mutex</code> y nunca lo libera. Por esa
	razón, si intenta llamara a f(), siempre será bloqueado porque
	el <code class="classname">Mutex</code> no puede ser
	adquirido. En <code class="classname">Blocked2</code>, la función
	run() se parará en la llamada blocked.f(). Cuando ejecute el
	programa verá que, a diferencia de la llamada a iostream,
	interrupt() puede salir de una llamada que está bloqueada por
	un mutex.[157] Comprobación de una una interrupción.
      </p><p>
	Note que cuando llama a interrupt() sobre un hilo, la única
	vez que ocurre la interrupción es cuando la tarea entra, o ya
	está dentro, de una operación bloqueante (a excepción, como ya
	ha visto, del caso de la entrada/salida, donde simplemente
      </p><p>

      </p><p>

      </p><div class="example"><a id="idp5499880"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:Interrupting3.cpp {RunByHand}</span>
<span class="hl slc">// General idiom for interrupting a task.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">const double</span> PI <span class="hl opt">=</span> <span class="hl num">3.14159265358979323846</span><span class="hl opt">;</span>
<span class="hl kwb">const double</span> E <span class="hl opt">=</span> <span class="hl num">2.7182818284590452354</span><span class="hl opt">;</span>

<span class="hl kwc">class</span> NeedsCleanup <span class="hl opt">{</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">NeedsCleanup</span><span class="hl opt">(</span><span class="hl kwb">int</span> ident<span class="hl opt">) :</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">) {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;NeedsCleanup &quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl opt">~</span><span class="hl kwd">NeedsCleanup</span><span class="hl opt">() {</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;~NeedsCleanup &quot;</span> <span class="hl opt">&lt;&lt;</span> id <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Blocked3 <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  <span class="hl kwc">volatile</span> <span class="hl kwb">double</span> d<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Blocked3</span><span class="hl opt">() :</span> <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl num">0.0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        point1<span class="hl opt">:</span>
        NeedsCleanup <span class="hl kwd">n1</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Sleeping&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1000</span><span class="hl opt">);</span>
        point2<span class="hl opt">:</span>
        NeedsCleanup <span class="hl kwd">n2</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">);</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Calculating&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl slc">// A time-consuming, non-blocking operation:</span>
        <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">100000</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
          d <span class="hl opt">=</span> d <span class="hl opt">+ (</span>PI <span class="hl opt">+</span> E<span class="hl opt">) / (</span><span class="hl kwb">double</span><span class="hl opt">)</span>i<span class="hl opt">;</span>
      <span class="hl opt">}</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Exiting via while() test&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span>
      cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Exiting via Interrupted_Exception&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwa">if</span><span class="hl opt">(</span>argc <span class="hl opt">!=</span> <span class="hl num">2</span><span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;usage: &quot;</span> <span class="hl opt">&lt;&lt;</span> argv<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; delay-in-milliseconds&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> delay <span class="hl opt">=</span> <span class="hl kwd">atoi</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]);</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    Thread <span class="hl kwd">t</span><span class="hl opt">(</span><span class="hl kwa">new</span> Blocked3<span class="hl opt">);</span>
    Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span>delay<span class="hl opt">);</span>
    t<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.28. C11/Interrupting3.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="10.6. Cooperación entre hilos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5503488"></a>10.6. Cooperación entre hilos</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><div class="sect2" title="10.6.1. Wait y signal"><div class="titlepage"><div><div><h3 class="title"><a id="idp5504440"></a>10.6.1. Wait y signal</h3></div></div></div><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp5505720"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:WaxOMatic.cpp {RunByHand}</span>
<span class="hl slc">// Basic thread cooperation.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Condition.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Car <span class="hl opt">{</span>
  Mutex lock<span class="hl opt">;</span>
  Condition condition<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> waxOn<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Car</span><span class="hl opt">() :</span> <span class="hl kwd">condition</span><span class="hl opt">(</span>lock<span class="hl opt">),</span> <span class="hl kwd">waxOn</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">waxed</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    waxOn <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span> <span class="hl slc">// Ready to buff</span>
    condition<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">buffed</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    waxOn <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span> <span class="hl slc">// Ready for another coat of wax</span>
    condition<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">waitForWaxing</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>waxOn <span class="hl opt">==</span> <span class="hl kwa">false</span><span class="hl opt">)</span>
      condition<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">waitForBuffing</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>waxOn <span class="hl opt">==</span> <span class="hl kwa">true</span><span class="hl opt">)</span>
      condition<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> WaxOn <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CountedPtr<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;</span> car<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">WaxOn</span><span class="hl opt">(</span>CountedPtr<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;&amp;</span> c<span class="hl opt">) :</span> <span class="hl kwd">car</span><span class="hl opt">(</span>c<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Wax On!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">200</span><span class="hl opt">);</span>
        car<span class="hl opt">-&gt;</span><span class="hl kwd">waxed</span><span class="hl opt">();</span>
        car<span class="hl opt">-&gt;</span><span class="hl kwd">waitForBuffing</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Ending Wax On process&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> WaxOff <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CountedPtr<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;</span> car<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">WaxOff</span><span class="hl opt">(</span>CountedPtr<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;&amp;</span> c<span class="hl opt">) :</span> <span class="hl kwd">car</span><span class="hl opt">(</span>c<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        car<span class="hl opt">-&gt;</span><span class="hl kwd">waitForWaxing</span><span class="hl opt">();</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Wax Off!&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">200</span><span class="hl opt">);</span>
        car<span class="hl opt">-&gt;</span><span class="hl kwd">buffed</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Ending Wax Off process&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Enter&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    CountedPtr<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;</span> <span class="hl kwd">car</span><span class="hl opt">(</span><span class="hl kwa">new</span> Car<span class="hl opt">);</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">WaxOff</span><span class="hl opt">(</span>car<span class="hl opt">));</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">WaxOn</span><span class="hl opt">(</span>car<span class="hl opt">));</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.29. C11/WaxOMatic.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="10.6.2. Relación de productor/consumidor"><div class="titlepage"><div><div><h3 class="title"><a id="idp5510400"></a>10.6.2. Relación de productor/consumidor</h3></div></div></div><p>

      </p><p>

      </p><div class="example"><a id="idp5511176"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ToastOMatic.cpp {RunByHand}</span>
<span class="hl slc">// Problems with thread cooperation.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Condition.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl slc">// Apply jam to buttered toast:</span>
<span class="hl kwc">class</span> Jammer <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  Mutex lock<span class="hl opt">;</span>
  Condition butteredToastReady<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> gotButteredToast<span class="hl opt">;</span>
  <span class="hl kwb">int</span> jammed<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Jammer</span><span class="hl opt">() :</span> <span class="hl kwd">butteredToastReady</span><span class="hl opt">(</span>lock<span class="hl opt">) {</span>
    gotButteredToast <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    jammed <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">moreButteredToastReady</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    gotButteredToast <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    butteredToastReady<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl opt">{</span>
          Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
          <span class="hl kwa">while</span><span class="hl opt">(!</span>gotButteredToast<span class="hl opt">)</span>
            butteredToastReady<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
          <span class="hl opt">++</span>jammed<span class="hl opt">;</span>
        <span class="hl opt">}</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Putting jam on toast &quot;</span> <span class="hl opt">&lt;&lt;</span> jammed <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl opt">{</span>
          Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
          gotButteredToast <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
        <span class="hl opt">}</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Jammer off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Apply butter to toast:</span>
<span class="hl kwc">class</span> Butterer <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  Mutex lock<span class="hl opt">;</span>
  Condition toastReady<span class="hl opt">;</span>
  CountedPtr<span class="hl opt">&lt;</span>Jammer<span class="hl opt">&gt;</span> jammer<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> gotToast<span class="hl opt">;</span>
  <span class="hl kwb">int</span> buttered<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Butterer</span><span class="hl opt">(</span>CountedPtr<span class="hl opt">&lt;</span>Jammer<span class="hl opt">&gt;&amp;</span> j<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">toastReady</span><span class="hl opt">(</span>lock<span class="hl opt">),</span> <span class="hl kwd">jammer</span><span class="hl opt">(</span>j<span class="hl opt">) {</span>
    gotToast <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    buttered <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">moreToastReady</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    gotToast <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    toastReady<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl opt">{</span>
          Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
          <span class="hl kwa">while</span><span class="hl opt">(!</span>gotToast<span class="hl opt">)</span>
            toastReady<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
          <span class="hl opt">++</span>buttered<span class="hl opt">;</span>
        <span class="hl opt">}</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Buttering toast &quot;</span> <span class="hl opt">&lt;&lt;</span> buttered <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        jammer<span class="hl opt">-&gt;</span><span class="hl kwd">moreButteredToastReady</span><span class="hl opt">();</span>
        <span class="hl opt">{</span>
          Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
          gotToast <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
        <span class="hl opt">}</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Butterer off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Toaster <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CountedPtr<span class="hl opt">&lt;</span>Butterer<span class="hl opt">&gt;</span> butterer<span class="hl opt">;</span>
  <span class="hl kwb">int</span> toasted<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Toaster</span><span class="hl opt">(</span>CountedPtr<span class="hl opt">&lt;</span>Butterer<span class="hl opt">&gt;&amp;</span> b<span class="hl opt">) :</span> <span class="hl kwd">butterer</span><span class="hl opt">(</span>b<span class="hl opt">) {</span>
    toasted <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl kwd">rand</span><span class="hl opt">()/(</span>RAND_MAX<span class="hl opt">/</span><span class="hl num">5</span><span class="hl opt">)*</span><span class="hl num">100</span><span class="hl opt">);</span>
        <span class="hl slc">// ...</span>
        <span class="hl slc">// Create new toast</span>
        <span class="hl slc">// ...</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;New toast &quot;</span> <span class="hl opt">&lt;&lt; ++</span>toasted <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        butterer<span class="hl opt">-&gt;</span><span class="hl kwd">moreToastReady</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Toaster off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Return&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    CountedPtr<span class="hl opt">&lt;</span>Jammer<span class="hl opt">&gt;</span> <span class="hl kwd">jammer</span><span class="hl opt">(</span><span class="hl kwa">new</span> Jammer<span class="hl opt">);</span>
    CountedPtr<span class="hl opt">&lt;</span>Butterer<span class="hl opt">&gt;</span> <span class="hl kwd">butterer</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Butterer</span><span class="hl opt">(</span>jammer<span class="hl opt">));</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Toaster</span><span class="hl opt">(</span>butterer<span class="hl opt">));</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>butterer<span class="hl opt">);</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>jammer<span class="hl opt">);</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.30. C11/ToastOMatic.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p></div><div class="sect2" title="10.6.3. Resolución de problemas de hilos mediante colas"><div class="titlepage"><div><div><h3 class="title"><a id="idp5515720"></a>10.6.3. Resolución de problemas de hilos mediante colas</h3></div></div></div><p>

      </p><div class="example"><a id="idp5516336"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:TQueue.h</span>
<span class="hl ppc">#ifndef TQUEUE_H</span>
<span class="hl ppc">#define TQUEUE_H</span>
<span class="hl ppc">#include &lt;deque&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Condition.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">template</span><span class="hl opt">&lt;</span><span class="hl kwc">class</span> T<span class="hl opt">&gt;</span> <span class="hl kwc">class</span> TQueue <span class="hl opt">{</span>
  ZThread<span class="hl opt">::</span>Mutex lock<span class="hl opt">;</span>
  ZThread<span class="hl opt">::</span>Condition cond<span class="hl opt">;</span>
  std<span class="hl opt">::</span>deque<span class="hl opt">&lt;</span>T<span class="hl opt">&gt;</span> data<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">TQueue</span><span class="hl opt">() :</span> <span class="hl kwd">cond</span><span class="hl opt">(</span>lock<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">put</span><span class="hl opt">(</span>T item<span class="hl opt">) {</span>
    ZThread<span class="hl opt">::</span>Guard<span class="hl opt">&lt;</span>ZThread<span class="hl opt">::</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    data<span class="hl opt">.</span><span class="hl kwd">push_back</span><span class="hl opt">(</span>item<span class="hl opt">);</span>
    cond<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  T <span class="hl kwd">get</span><span class="hl opt">() {</span>
    ZThread<span class="hl opt">::</span>Guard<span class="hl opt">&lt;</span>ZThread<span class="hl opt">::</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>data<span class="hl opt">.</span><span class="hl kwd">empty</span><span class="hl opt">())</span>
      cond<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
    T returnVal <span class="hl opt">=</span> data<span class="hl opt">.</span><span class="hl kwd">front</span><span class="hl opt">();</span>
    data<span class="hl opt">.</span><span class="hl kwd">pop_front</span><span class="hl opt">();</span>
    <span class="hl kwa">return</span> returnVal<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// TQUEUE_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.31. C11/TQueue.h</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><div class="example"><a id="idp5519552"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:TestTQueue.cpp {RunByHand}</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TQueue.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;LiftOff.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> LiftOffRunner <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  TQueue<span class="hl opt">&lt;</span>LiftOff<span class="hl opt">*&gt;</span> rockets<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">add</span><span class="hl opt">(</span>LiftOff<span class="hl opt">*</span> lo<span class="hl opt">) {</span> rockets<span class="hl opt">.</span><span class="hl kwd">put</span><span class="hl opt">(</span>lo<span class="hl opt">); }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        LiftOff<span class="hl opt">*</span> rocket <span class="hl opt">=</span> rockets<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
        rocket<span class="hl opt">-&gt;</span><span class="hl kwd">run</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Exiting LiftOffRunner&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    LiftOffRunner<span class="hl opt">*</span> lor <span class="hl opt">=</span> <span class="hl kwa">new</span> LiftOffRunner<span class="hl opt">;</span>
    Thread <span class="hl kwd">t</span><span class="hl opt">(</span>lor<span class="hl opt">);</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> i<span class="hl opt">++)</span>
      lor<span class="hl opt">-&gt;</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> i<span class="hl opt">));</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    lor<span class="hl opt">-&gt;</span><span class="hl kwd">add</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">LiftOff</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">99</span><span class="hl opt">));</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    t<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.32. C11/TestTQueue.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><div class="example"><a id="idp5522240"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:ToastOMaticMarkII.cpp {RunByHand}</span>
<span class="hl slc">// Solving the problems using TQueues.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Condition.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TQueue.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Toast <span class="hl opt">{</span>
  <span class="hl kwb">enum</span> Status <span class="hl opt">{</span> DRY<span class="hl opt">,</span> BUTTERED<span class="hl opt">,</span> JAMMED <span class="hl opt">};</span>
  Status status<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Toast</span><span class="hl opt">(</span><span class="hl kwb">int</span> idn<span class="hl opt">) :</span> <span class="hl kwd">status</span><span class="hl opt">(</span>DRY<span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>idn<span class="hl opt">) {}</span>
  <span class="hl ppc">#ifdef __DMC__</span> <span class="hl slc">// Incorrectly requires default</span>
<span class="hl ppc"></span>  <span class="hl kwd">Toast</span><span class="hl opt">() {</span> <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">); }</span> <span class="hl slc">// Should never be called</span>
  <span class="hl ppc">#endif</span>
  <span class="hl kwb">void</span> <span class="hl kwd">butter</span><span class="hl opt">() {</span> status <span class="hl opt">=</span> BUTTERED<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">jam</span><span class="hl opt">() {</span> status <span class="hl opt">=</span> JAMMED<span class="hl opt">; }</span>
  string <span class="hl kwd">getStatus</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
    <span class="hl kwa">switch</span><span class="hl opt">(</span>status<span class="hl opt">) {</span>
      <span class="hl kwa">case</span> DRY<span class="hl opt">:</span> <span class="hl kwa">return</span> <span class="hl str">&quot;dry&quot;</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> BUTTERED<span class="hl opt">:</span> <span class="hl kwa">return</span> <span class="hl str">&quot;buttered&quot;</span><span class="hl opt">;</span>
      <span class="hl kwa">case</span> JAMMED<span class="hl opt">:</span> <span class="hl kwa">return</span> <span class="hl str">&quot;jammed&quot;</span><span class="hl opt">;</span>
      <span class="hl kwa">default</span><span class="hl opt">:</span> <span class="hl kwa">return</span> <span class="hl str">&quot;error&quot;</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getId</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> id<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Toast<span class="hl opt">&amp;</span> t<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Toast &quot;</span> <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;: &quot;</span> <span class="hl opt">&lt;&lt;</span> t<span class="hl opt">.</span><span class="hl kwd">getStatus</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> CountedPtr<span class="hl opt">&lt;</span> TQueue<span class="hl opt">&lt;</span>Toast<span class="hl opt">&gt; &gt;</span> ToastQueue<span class="hl opt">;</span>

<span class="hl kwc">class</span> Toaster <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  ToastQueue toastQueue<span class="hl opt">;</span>
  <span class="hl kwb">int</span> count<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Toaster</span><span class="hl opt">(</span>ToastQueue<span class="hl opt">&amp;</span> tq<span class="hl opt">) :</span> <span class="hl kwd">toastQueue</span><span class="hl opt">(</span>tq<span class="hl opt">),</span> <span class="hl kwd">count</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl kwb">int</span> delay <span class="hl opt">=</span> <span class="hl kwd">rand</span><span class="hl opt">()/(</span>RAND_MAX<span class="hl opt">/</span><span class="hl num">5</span><span class="hl opt">)*</span><span class="hl num">100</span><span class="hl opt">;</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span>delay<span class="hl opt">);</span>
        <span class="hl slc">// Make toast</span>
        Toast <span class="hl kwd">t</span><span class="hl opt">(</span>count<span class="hl opt">++);</span>
        cout <span class="hl opt">&lt;&lt;</span> t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl slc">// Insert into queue</span>
        toastQueue<span class="hl opt">-&gt;</span><span class="hl kwd">put</span><span class="hl opt">(</span>t<span class="hl opt">);</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Toaster off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Apply butter to toast:</span>
<span class="hl kwc">class</span> Butterer <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  ToastQueue dryQueue<span class="hl opt">,</span> butteredQueue<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Butterer</span><span class="hl opt">(</span>ToastQueue<span class="hl opt">&amp;</span> dry<span class="hl opt">,</span> ToastQueue<span class="hl opt">&amp;</span> buttered<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">dryQueue</span><span class="hl opt">(</span>dry<span class="hl opt">),</span> <span class="hl kwd">butteredQueue</span><span class="hl opt">(</span>buttered<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until next piece of toast is available:</span>
        Toast t <span class="hl opt">=</span> dryQueue<span class="hl opt">-&gt;</span><span class="hl kwd">get</span><span class="hl opt">();</span>
        t<span class="hl opt">.</span><span class="hl kwd">butter</span><span class="hl opt">();</span>
        cout <span class="hl opt">&lt;&lt;</span> t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        butteredQueue<span class="hl opt">-&gt;</span><span class="hl kwd">put</span><span class="hl opt">(</span>t<span class="hl opt">);</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Butterer off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Apply jam to buttered toast:</span>
<span class="hl kwc">class</span> Jammer <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  ToastQueue butteredQueue<span class="hl opt">,</span> finishedQueue<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Jammer</span><span class="hl opt">(</span>ToastQueue<span class="hl opt">&amp;</span> buttered<span class="hl opt">,</span> ToastQueue<span class="hl opt">&amp;</span> finished<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">butteredQueue</span><span class="hl opt">(</span>buttered<span class="hl opt">),</span> <span class="hl kwd">finishedQueue</span><span class="hl opt">(</span>finished<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until next piece of toast is available:</span>
        Toast t <span class="hl opt">=</span> butteredQueue<span class="hl opt">-&gt;</span><span class="hl kwd">get</span><span class="hl opt">();</span>
        t<span class="hl opt">.</span><span class="hl kwd">jam</span><span class="hl opt">();</span>
        cout <span class="hl opt">&lt;&lt;</span> t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        finishedQueue<span class="hl opt">-&gt;</span><span class="hl kwd">put</span><span class="hl opt">(</span>t<span class="hl opt">);</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Jammer off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// Consume the toast:</span>
<span class="hl kwc">class</span> Eater <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  ToastQueue finishedQueue<span class="hl opt">;</span>
  <span class="hl kwb">int</span> counter<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Eater</span><span class="hl opt">(</span>ToastQueue<span class="hl opt">&amp;</span> finished<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">finishedQueue</span><span class="hl opt">(</span>finished<span class="hl opt">),</span> <span class="hl kwd">counter</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until next piece of toast is available:</span>
        Toast t <span class="hl opt">=</span> finishedQueue<span class="hl opt">-&gt;</span><span class="hl kwd">get</span><span class="hl opt">();</span>
        <span class="hl slc">// Verify that the toast is coming in order,</span>
        <span class="hl slc">// and that all pieces are getting jammed:</span>
        <span class="hl kwa">if</span><span class="hl opt">(</span>t<span class="hl opt">.</span><span class="hl kwd">getId</span><span class="hl opt">() !=</span> counter<span class="hl opt">++ ||</span>
           t<span class="hl opt">.</span><span class="hl kwd">getStatus</span><span class="hl opt">() !=</span> <span class="hl str">&quot;jammed&quot;</span><span class="hl opt">) {</span>
          cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;&gt;&gt;&gt;&gt; Error: &quot;</span> <span class="hl opt">&lt;&lt;</span> t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
          <span class="hl kwd">exit</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl opt">}</span> <span class="hl kwa">else</span>
          cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Chomp! &quot;</span> <span class="hl opt">&lt;&lt;</span> t <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Eater off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    ToastQueue <span class="hl kwd">dryQueue</span><span class="hl opt">(</span><span class="hl kwa">new</span> TQueue<span class="hl opt">&lt;</span>Toast<span class="hl opt">&gt;),</span>
               <span class="hl kwd">butteredQueue</span><span class="hl opt">(</span><span class="hl kwa">new</span> TQueue<span class="hl opt">&lt;</span>Toast<span class="hl opt">&gt;),</span>
               <span class="hl kwd">finishedQueue</span><span class="hl opt">(</span><span class="hl kwa">new</span> TQueue<span class="hl opt">&lt;</span>Toast<span class="hl opt">&gt;);</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Return&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Toaster</span><span class="hl opt">(</span>dryQueue<span class="hl opt">));</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Butterer</span><span class="hl opt">(</span>dryQueue<span class="hl opt">,</span>butteredQueue<span class="hl opt">));</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>
      <span class="hl kwa">new</span> <span class="hl kwd">Jammer</span><span class="hl opt">(</span>butteredQueue<span class="hl opt">,</span> finishedQueue<span class="hl opt">));</span>
    executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Eater</span><span class="hl opt">(</span>finishedQueue<span class="hl opt">));</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.33. C11/ToastOMaticMarkII.cpp</strong></p></div><br class="example-break" /><p>

      </p></div><div class="sect2" title="10.6.4. Broadcast"><div class="titlepage"><div><div><h3 class="title"><a id="idp5531608"></a>10.6.4. Broadcast </h3></div></div></div><p>

      </p><p>

      </p><div class="example"><a id="idp5532312"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:CarBuilder.cpp {RunByHand}</span>
<span class="hl slc">// How broadcast() works.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Condition.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;TQueue.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwc">class</span> Car <span class="hl opt">{</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> engine<span class="hl opt">,</span> driveTrain<span class="hl opt">,</span> wheels<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Car</span><span class="hl opt">(</span><span class="hl kwb">int</span> idn<span class="hl opt">) :</span> <span class="hl kwd">id</span><span class="hl opt">(</span>idn<span class="hl opt">),</span> <span class="hl kwd">engine</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span>
  <span class="hl kwd">driveTrain</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span> <span class="hl kwd">wheels</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl slc">// Empty Car object:</span>
  <span class="hl kwd">Car</span><span class="hl opt">() :</span> <span class="hl kwd">id</span><span class="hl opt">(-</span><span class="hl num">1</span><span class="hl opt">),</span> <span class="hl kwd">engine</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span>
  <span class="hl kwd">driveTrain</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">),</span> <span class="hl kwd">wheels</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl slc">// Unsynchronized -- assumes atomic bool operations:</span>
  <span class="hl kwb">int</span> <span class="hl kwd">getId</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> id<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addEngine</span><span class="hl opt">() {</span> engine <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">engineInstalled</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> engine<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addDriveTrain</span><span class="hl opt">() {</span> driveTrain <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">driveTrainInstalled</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> driveTrain<span class="hl opt">; }</span>
  <span class="hl kwb">void</span> <span class="hl kwd">addWheels</span><span class="hl opt">() {</span> wheels <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">; }</span>
  <span class="hl kwb">bool</span> <span class="hl kwd">wheelsInstalled</span><span class="hl opt">() {</span> <span class="hl kwa">return</span> wheels<span class="hl opt">; }</span>
  <span class="hl kwc">friend</span> ostream<span class="hl opt">&amp;</span> <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Car<span class="hl opt">&amp;</span> c<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Car &quot;</span> <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>id <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; [&quot;</span>
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; engine: &quot;</span> <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>engine
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; driveTrain: &quot;</span> <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>driveTrain
      <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; wheels: &quot;</span> <span class="hl opt">&lt;&lt;</span> c<span class="hl opt">.</span>wheels <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; ]&quot;</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> CountedPtr<span class="hl opt">&lt;</span> TQueue<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt; &gt;</span> CarQueue<span class="hl opt">;</span>

<span class="hl kwc">class</span> ChassisBuilder <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CarQueue carQueue<span class="hl opt">;</span>
  <span class="hl kwb">int</span> counter<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">ChassisBuilder</span><span class="hl opt">(</span>CarQueue<span class="hl opt">&amp;</span> cq<span class="hl opt">) :</span> <span class="hl kwd">carQueue</span><span class="hl opt">(</span>cq<span class="hl opt">),</span><span class="hl kwd">counter</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl num">1000</span><span class="hl opt">);</span>
        <span class="hl slc">// Make chassis:</span>
        Car <span class="hl kwd">c</span><span class="hl opt">(</span>counter<span class="hl opt">++);</span>
        cout <span class="hl opt">&lt;&lt;</span> c <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl slc">// Insert into queue</span>
        carQueue<span class="hl opt">-&gt;</span><span class="hl kwd">put</span><span class="hl opt">(</span>c<span class="hl opt">);</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;ChassisBuilder off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Cradle <span class="hl opt">{</span>
  Car c<span class="hl opt">;</span> <span class="hl slc">// Holds current car being worked on</span>
  <span class="hl kwb">bool</span> occupied<span class="hl opt">;</span>
  Mutex workLock<span class="hl opt">,</span> readyLock<span class="hl opt">;</span>
  Condition workCondition<span class="hl opt">,</span> readyCondition<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> engineBotHired<span class="hl opt">,</span> wheelBotHired<span class="hl opt">,</span> driveTrainBotHired<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Cradle</span><span class="hl opt">()</span>
  <span class="hl opt">:</span> <span class="hl kwd">workCondition</span><span class="hl opt">(</span>workLock<span class="hl opt">),</span> <span class="hl kwd">readyCondition</span><span class="hl opt">(</span>readyLock<span class="hl opt">) {</span>
    occupied <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    engineBotHired <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    wheelBotHired <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
    driveTrainBotHired <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">insertCar</span><span class="hl opt">(</span>Car chassis<span class="hl opt">) {</span>
    c <span class="hl opt">=</span> chassis<span class="hl opt">;</span>
    occupied <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  Car <span class="hl kwd">getCar</span><span class="hl opt">() {</span> <span class="hl slc">// Can only extract car once</span>
    <span class="hl kwa">if</span><span class="hl opt">(!</span>occupied<span class="hl opt">) {</span>
      cerr <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;No Car in Cradle for getCar()&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl kwa">return</span> <span class="hl kwd">Car</span><span class="hl opt">();</span> <span class="hl slc">// &quot;Null&quot; Car object</span>
    <span class="hl opt">}</span>
    occupied <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> c<span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Access car while in cradle:</span>
  Car<span class="hl opt">*</span> <span class="hl kwc">operator</span><span class="hl opt">-&gt;() {</span> <span class="hl kwa">return</span> <span class="hl opt">&amp;</span>c<span class="hl opt">; }</span>
  <span class="hl slc">// Allow robots to offer services to this cradle:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">offerEngineBotServices</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>workLock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>engineBotHired<span class="hl opt">)</span>
      workCondition<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
    engineBotHired <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span> <span class="hl slc">// Accept the job</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">offerWheelBotServices</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>workLock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>wheelBotHired<span class="hl opt">)</span>
      workCondition<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
    wheelBotHired <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span> <span class="hl slc">// Accept the job</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">offerDriveTrainBotServices</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>workLock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>driveTrainBotHired<span class="hl opt">)</span>
      workCondition<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
    driveTrainBotHired <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span> <span class="hl slc">// Accept the job</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Tell waiting robots that work is ready:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">startWork</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>workLock<span class="hl opt">);</span>
    engineBotHired <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    wheelBotHired <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    driveTrainBotHired <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    workCondition<span class="hl opt">.</span><span class="hl kwd">broadcast</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Each robot reports when their job is done:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">taskFinished</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>readyLock<span class="hl opt">);</span>
    readyCondition<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
  <span class="hl slc">// Director waits until all jobs are done:</span>
  <span class="hl kwb">void</span> <span class="hl kwd">waitUntilWorkFinished</span><span class="hl opt">() {</span>
    Guard<span class="hl opt">&lt;</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>readyLock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(!(</span>c<span class="hl opt">.</span><span class="hl kwd">engineInstalled</span><span class="hl opt">() &amp;&amp;</span> c<span class="hl opt">.</span><span class="hl kwd">driveTrainInstalled</span><span class="hl opt">()</span>
            <span class="hl opt">&amp;&amp;</span> c<span class="hl opt">.</span><span class="hl kwd">wheelsInstalled</span><span class="hl opt">()))</span>
      readyCondition<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> CountedPtr<span class="hl opt">&lt;</span>Cradle<span class="hl opt">&gt;</span> CradlePtr<span class="hl opt">;</span>

<span class="hl kwc">class</span> Director <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CarQueue chassisQueue<span class="hl opt">,</span> finishingQueue<span class="hl opt">;</span>
  CradlePtr cradle<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Director</span><span class="hl opt">(</span>CarQueue<span class="hl opt">&amp;</span> cq<span class="hl opt">,</span> CarQueue<span class="hl opt">&amp;</span> fq<span class="hl opt">,</span> CradlePtr cr<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">chassisQueue</span><span class="hl opt">(</span>cq<span class="hl opt">),</span> <span class="hl kwd">finishingQueue</span><span class="hl opt">(</span>fq<span class="hl opt">),</span> <span class="hl kwd">cradle</span><span class="hl opt">(</span>cr<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until chassis is available:</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">insertCar</span><span class="hl opt">(</span>chassisQueue<span class="hl opt">-&gt;</span><span class="hl kwd">get</span><span class="hl opt">());</span>
        <span class="hl slc">// Notify robots car is ready for work</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">startWork</span><span class="hl opt">();</span>
        <span class="hl slc">// Wait until work completes</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">waitUntilWorkFinished</span><span class="hl opt">();</span>
        <span class="hl slc">// Put car into queue for further work</span>
        finishingQueue<span class="hl opt">-&gt;</span><span class="hl kwd">put</span><span class="hl opt">(</span>cradle<span class="hl opt">-&gt;</span><span class="hl kwd">getCar</span><span class="hl opt">());</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Director off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> EngineRobot <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CradlePtr cradle<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">EngineRobot</span><span class="hl opt">(</span>CradlePtr cr<span class="hl opt">) :</span> <span class="hl kwd">cradle</span><span class="hl opt">(</span>cr<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until job is offered/accepted:</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">offerEngineBotServices</span><span class="hl opt">();</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Installing engine&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl opt">(*</span>cradle<span class="hl opt">)-&gt;</span><span class="hl kwd">addEngine</span><span class="hl opt">();</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">taskFinished</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;EngineRobot off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> DriveTrainRobot <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CradlePtr cradle<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">DriveTrainRobot</span><span class="hl opt">(</span>CradlePtr cr<span class="hl opt">) :</span> <span class="hl kwd">cradle</span><span class="hl opt">(</span>cr<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until job is offered/accepted:</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">offerDriveTrainBotServices</span><span class="hl opt">();</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Installing DriveTrain&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl opt">(*</span>cradle<span class="hl opt">)-&gt;</span><span class="hl kwd">addDriveTrain</span><span class="hl opt">();</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">taskFinished</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;DriveTrainRobot off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> WheelRobot <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CradlePtr cradle<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">WheelRobot</span><span class="hl opt">(</span>CradlePtr cr<span class="hl opt">) :</span> <span class="hl kwd">cradle</span><span class="hl opt">(</span>cr<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl slc">// Blocks until job is offered/accepted:</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">offerWheelBotServices</span><span class="hl opt">();</span>
        cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Installing Wheels&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
        <span class="hl opt">(*</span>cradle<span class="hl opt">)-&gt;</span><span class="hl kwd">addWheels</span><span class="hl opt">();</span>
        cradle<span class="hl opt">-&gt;</span><span class="hl kwd">taskFinished</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;WheelRobot off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Reporter <span class="hl opt">:</span> <span class="hl kwc">public</span> Runnable <span class="hl opt">{</span>
  CarQueue carQueue<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Reporter</span><span class="hl opt">(</span>CarQueue<span class="hl opt">&amp;</span> cq<span class="hl opt">) :</span> <span class="hl kwd">carQueue</span><span class="hl opt">(</span>cq<span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        cout <span class="hl opt">&lt;&lt;</span> carQueue<span class="hl opt">-&gt;</span><span class="hl kwd">get</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Interrupted_Exception<span class="hl opt">&amp;) {</span> <span class="hl com">/* Exit */</span> <span class="hl opt">}</span>
    cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Reporter off&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;Enter&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    CarQueue <span class="hl kwd">chassisQueue</span><span class="hl opt">(</span><span class="hl kwa">new</span> TQueue<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;),</span>
             <span class="hl kwd">finishingQueue</span><span class="hl opt">(</span><span class="hl kwa">new</span> TQueue<span class="hl opt">&lt;</span>Car<span class="hl opt">&gt;);</span>
    CradlePtr <span class="hl kwd">cradle</span><span class="hl opt">(</span><span class="hl kwa">new</span> Cradle<span class="hl opt">);</span>
    ThreadedExecutor assemblyLine<span class="hl opt">;</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">EngineRobot</span><span class="hl opt">(</span>cradle<span class="hl opt">));</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">DriveTrainRobot</span><span class="hl opt">(</span>cradle<span class="hl opt">));</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">WheelRobot</span><span class="hl opt">(</span>cradle<span class="hl opt">));</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>
      <span class="hl kwa">new</span> <span class="hl kwd">Director</span><span class="hl opt">(</span>chassisQueue<span class="hl opt">,</span> finishingQueue<span class="hl opt">,</span> cradle<span class="hl opt">));</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">Reporter</span><span class="hl opt">(</span>finishingQueue<span class="hl opt">));</span>
    <span class="hl slc">// Start everything running by producing chassis:</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span><span class="hl kwa">new</span> <span class="hl kwd">ChassisBuilder</span><span class="hl opt">(</span>chassisQueue<span class="hl opt">));</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    assemblyLine<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.34. C11/CarBuilder.cpp</strong></p></div><br class="example-break" /><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p></div></div><div class="sect1" title="10.7. Bloqueo letal"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5544856"></a>10.7. Bloqueo letal</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5545944"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:DiningPhilosophers.h</span>
<span class="hl slc">// Classes for Dining Philosophers.</span>
<span class="hl ppc">#ifndef DININGPHILOSOPHERS_H</span>
<span class="hl ppc">#define DININGPHILOSOPHERS_H</span>
<span class="hl ppc">#include &lt;string&gt;</span>
<span class="hl ppc">#include &lt;iostream&gt;</span>
<span class="hl ppc">#include &lt;cstdlib&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Condition.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Guard.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Mutex.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/Thread.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;Display.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwc">class</span> Chopstick <span class="hl opt">{</span>
  ZThread<span class="hl opt">::</span>Mutex lock<span class="hl opt">;</span>
  ZThread<span class="hl opt">::</span>Condition notTaken<span class="hl opt">;</span>
  <span class="hl kwb">bool</span> taken<span class="hl opt">;</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Chopstick</span><span class="hl opt">() :</span> <span class="hl kwd">notTaken</span><span class="hl opt">(</span>lock<span class="hl opt">),</span> <span class="hl kwd">taken</span><span class="hl opt">(</span><span class="hl kwa">false</span><span class="hl opt">) {}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">take</span><span class="hl opt">() {</span>
    ZThread<span class="hl opt">::</span>Guard<span class="hl opt">&lt;</span>ZThread<span class="hl opt">::</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    <span class="hl kwa">while</span><span class="hl opt">(</span>taken<span class="hl opt">)</span>
      notTaken<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
    taken <span class="hl opt">=</span> <span class="hl kwa">true</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">drop</span><span class="hl opt">() {</span>
    ZThread<span class="hl opt">::</span>Guard<span class="hl opt">&lt;</span>ZThread<span class="hl opt">::</span>Mutex<span class="hl opt">&gt;</span> <span class="hl kwd">g</span><span class="hl opt">(</span>lock<span class="hl opt">);</span>
    taken <span class="hl opt">=</span> <span class="hl kwa">false</span><span class="hl opt">;</span>
    notTaken<span class="hl opt">.</span><span class="hl kwd">signal</span><span class="hl opt">();</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl kwc">class</span> Philosopher <span class="hl opt">:</span> <span class="hl kwc">public</span> ZThread<span class="hl opt">::</span>Runnable <span class="hl opt">{</span>
  Chopstick<span class="hl opt">&amp;</span> left<span class="hl opt">;</span>
  Chopstick<span class="hl opt">&amp;</span> right<span class="hl opt">;</span>
  <span class="hl kwb">int</span> id<span class="hl opt">;</span>
  <span class="hl kwb">int</span> ponderFactor<span class="hl opt">;</span>
  ZThread<span class="hl opt">::</span>CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;</span> display<span class="hl opt">;</span>
  <span class="hl kwb">int</span> <span class="hl kwd">randSleepTime</span><span class="hl opt">() {</span>
    <span class="hl kwa">if</span><span class="hl opt">(</span>ponderFactor <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
    <span class="hl kwa">return</span> <span class="hl kwd">rand</span><span class="hl opt">()/(</span>RAND_MAX<span class="hl opt">/</span>ponderFactor<span class="hl opt">) *</span> <span class="hl num">250</span><span class="hl opt">;</span>
  <span class="hl opt">}</span>
  <span class="hl kwb">void</span> <span class="hl kwd">output</span><span class="hl opt">(</span>std<span class="hl opt">::</span>string s<span class="hl opt">) {</span>
    std<span class="hl opt">::</span>ostringstream os<span class="hl opt">;</span>
    os <span class="hl opt">&lt;&lt; *</span><span class="hl kwa">this</span> <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot; &quot;</span> <span class="hl opt">&lt;&lt;</span> s <span class="hl opt">&lt;&lt;</span> std<span class="hl opt">::</span>endl<span class="hl opt">;</span>
    display<span class="hl opt">-&gt;</span><span class="hl kwd">output</span><span class="hl opt">(</span>os<span class="hl opt">);</span>
  <span class="hl opt">}</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
  <span class="hl kwd">Philosopher</span><span class="hl opt">(</span>Chopstick<span class="hl opt">&amp;</span> l<span class="hl opt">,</span> Chopstick<span class="hl opt">&amp;</span> r<span class="hl opt">,</span>
  ZThread<span class="hl opt">::</span>CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;&amp;</span> disp<span class="hl opt">,</span> <span class="hl kwb">int</span> ident<span class="hl opt">,</span><span class="hl kwb">int</span> ponder<span class="hl opt">)</span>
  <span class="hl opt">:</span> <span class="hl kwd">left</span><span class="hl opt">(</span>l<span class="hl opt">),</span> <span class="hl kwd">right</span><span class="hl opt">(</span>r<span class="hl opt">),</span> <span class="hl kwd">id</span><span class="hl opt">(</span>ident<span class="hl opt">),</span> <span class="hl kwd">ponderFactor</span><span class="hl opt">(</span>ponder<span class="hl opt">),</span>
    <span class="hl kwd">display</span><span class="hl opt">(</span>disp<span class="hl opt">) {}</span>
  <span class="hl kwc">virtual</span> <span class="hl kwb">void</span> <span class="hl kwd">run</span><span class="hl opt">() {</span>
    <span class="hl kwa">try</span> <span class="hl opt">{</span>
      <span class="hl kwa">while</span><span class="hl opt">(!</span>ZThread<span class="hl opt">::</span>Thread<span class="hl opt">::</span><span class="hl kwd">interrupted</span><span class="hl opt">()) {</span>
        <span class="hl kwd">output</span><span class="hl opt">(</span><span class="hl str">&quot;thinking&quot;</span><span class="hl opt">);</span>
        ZThread<span class="hl opt">::</span>Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl kwd">randSleepTime</span><span class="hl opt">());</span>
        <span class="hl slc">// Hungry</span>
        <span class="hl kwd">output</span><span class="hl opt">(</span><span class="hl str">&quot;grabbing right&quot;</span><span class="hl opt">);</span>
        right<span class="hl opt">.</span><span class="hl kwd">take</span><span class="hl opt">();</span>
        <span class="hl kwd">output</span><span class="hl opt">(</span><span class="hl str">&quot;grabbing left&quot;</span><span class="hl opt">);</span>
        left<span class="hl opt">.</span><span class="hl kwd">take</span><span class="hl opt">();</span>
        <span class="hl kwd">output</span><span class="hl opt">(</span><span class="hl str">&quot;eating&quot;</span><span class="hl opt">);</span>
        ZThread<span class="hl opt">::</span>Thread<span class="hl opt">::</span><span class="hl kwd">sleep</span><span class="hl opt">(</span><span class="hl kwd">randSleepTime</span><span class="hl opt">());</span>
        right<span class="hl opt">.</span><span class="hl kwd">drop</span><span class="hl opt">();</span>
        left<span class="hl opt">.</span><span class="hl kwd">drop</span><span class="hl opt">();</span>
      <span class="hl opt">}</span>
    <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>ZThread<span class="hl opt">::</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
      <span class="hl kwd">output</span><span class="hl opt">(</span>e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">());</span>
    <span class="hl opt">}</span>
  <span class="hl opt">}</span>
  <span class="hl kwc">friend</span> std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span>
  <span class="hl kwc">operator</span><span class="hl opt">&lt;&lt;(</span>std<span class="hl opt">::</span>ostream<span class="hl opt">&amp;</span> os<span class="hl opt">,</span> <span class="hl kwb">const</span> Philosopher<span class="hl opt">&amp;</span> p<span class="hl opt">) {</span>
    <span class="hl kwa">return</span> os <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Philosopher &quot;</span> <span class="hl opt">&lt;&lt;</span> p<span class="hl opt">.</span>id<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">};</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// DININGPHILOSOPHERS_H ///:~</span><span class="hl ppc"></span>
</pre></div><p class="title"><strong>Listado 10.35. C11/DiningPhilosophers.h</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5551088"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:DeadlockingDiningPhilosophers.cpp {RunByHand}</span>
<span class="hl slc">// Dining Philosophers with Deadlock.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DiningPhilosophers.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  <span class="hl kwb">int</span> ponder <span class="hl opt">=</span> argc <span class="hl opt">&gt;</span> <span class="hl num">1</span> ? <span class="hl kwd">atoi</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]) :</span> <span class="hl num">5</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;ENTER&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> SZ <span class="hl opt">=</span> <span class="hl num">5</span> <span class="hl opt">};</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;</span> <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl kwa">new</span> Display<span class="hl opt">);</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    Chopstick c<span class="hl opt">[</span>SZ<span class="hl opt">];</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>
        <span class="hl kwa">new</span> <span class="hl kwd">Philosopher</span><span class="hl opt">(</span>c<span class="hl opt">[</span>i<span class="hl opt">],</span> c<span class="hl opt">[(</span>i<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">) %</span> SZ<span class="hl opt">],</span> d<span class="hl opt">,</span> i<span class="hl opt">,</span>ponder<span class="hl opt">));</span>
    <span class="hl opt">}</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.36. C11/DeadlockingDiningPhilosophers.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><div class="example"><a id="idp5554472"></a><div class="example-contents"><pre class="programlisting">
<span class="hl slc">//: C11:FixedDiningPhilosophers.cpp {RunByHand}</span>
<span class="hl slc">// Dining Philosophers without Deadlock.</span>
<span class="hl slc">//{L} ZThread</span>
<span class="hl ppc">#include &lt;ctime&gt;</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;DiningPhilosophers.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;zthread/ThreadedExecutor.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> ZThread<span class="hl opt">;</span>
<span class="hl kwa">using namespace</span> std<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwd">srand</span><span class="hl opt">(</span><span class="hl kwd">time</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span> <span class="hl slc">// Seed the random number generator</span>
  <span class="hl kwb">int</span> ponder <span class="hl opt">=</span> argc <span class="hl opt">&gt;</span> <span class="hl num">1</span> ? <span class="hl kwd">atoi</span><span class="hl opt">(</span>argv<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]) :</span> <span class="hl num">5</span><span class="hl opt">;</span>
  cout <span class="hl opt">&lt;&lt;</span> <span class="hl str">&quot;Press &lt;ENTER&gt; to quit&quot;</span> <span class="hl opt">&lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl kwb">enum</span> <span class="hl opt">{</span> SZ <span class="hl opt">=</span> <span class="hl num">5</span> <span class="hl opt">};</span>
  <span class="hl kwa">try</span> <span class="hl opt">{</span>
    CountedPtr<span class="hl opt">&lt;</span>Display<span class="hl opt">&gt;</span> <span class="hl kwd">d</span><span class="hl opt">(</span><span class="hl kwa">new</span> Display<span class="hl opt">);</span>
    ThreadedExecutor executor<span class="hl opt">;</span>
    Chopstick c<span class="hl opt">[</span>SZ<span class="hl opt">];</span>
    <span class="hl kwa">for</span><span class="hl opt">(</span><span class="hl kwb">int</span> i <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> i <span class="hl opt">&lt;</span> SZ<span class="hl opt">;</span> i<span class="hl opt">++) {</span>
      <span class="hl kwa">if</span><span class="hl opt">(</span>i <span class="hl opt">&lt; (</span>SZ<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">))</span>
        executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>
          <span class="hl kwa">new</span> <span class="hl kwd">Philosopher</span><span class="hl opt">(</span>c<span class="hl opt">[</span>i<span class="hl opt">],</span> c<span class="hl opt">[</span>i <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">],</span> d<span class="hl opt">,</span> i<span class="hl opt">,</span> ponder<span class="hl opt">));</span>
      <span class="hl kwa">else</span>
        executor<span class="hl opt">.</span><span class="hl kwd">execute</span><span class="hl opt">(</span>
          <span class="hl kwa">new</span> <span class="hl kwd">Philosopher</span><span class="hl opt">(</span>c<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">],</span> c<span class="hl opt">[</span>i<span class="hl opt">],</span> d<span class="hl opt">,</span> i<span class="hl opt">,</span> ponder<span class="hl opt">));</span>
    <span class="hl opt">}</span>
    cin<span class="hl opt">.</span><span class="hl kwd">get</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">interrupt</span><span class="hl opt">();</span>
    executor<span class="hl opt">.</span><span class="hl kwd">wait</span><span class="hl opt">();</span>
  <span class="hl opt">}</span> <span class="hl kwa">catch</span><span class="hl opt">(</span>Synchronization_Exception<span class="hl opt">&amp;</span> e<span class="hl opt">) {</span>
    cerr <span class="hl opt">&lt;&lt;</span> e<span class="hl opt">.</span><span class="hl kwd">what</span><span class="hl opt">() &lt;&lt;</span> endl<span class="hl opt">;</span>
  <span class="hl opt">}</span>
<span class="hl opt">}</span> <span class="hl slc">///:~</span>
</pre></div><p class="title"><strong>Listado 10.37. C11/FixedDiningPhilosophers.cpp</strong></p></div><br class="example-break" /><p>

    </p><p>

    </p></div><div class="sect1" title="10.8. Resumen"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5556744"></a>10.8. Resumen</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div><div class="sect1" title="10.9. Ejercicios"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp5561544"></a>10.9. Ejercicios</h2></div></div></div><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p><p>

    </p></div></div></div></div></body></html>
