<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:               Emacs 21/PSGML
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C3">

  <title>El C en C++</title>

  <!-- 
  Since C++ is based on C, you must be familiar with the syntax of
  C in order to program in C++, just as you must be reasonably fluent in
  algebra in order to tackle calculus.
  -->

  <!-- [PAG:121] -->
  <para>
    Dado que C++ está basado en C, debe estar familiarizado
    con la sintaxsis de C programar adecuadamente en C++, del mismo modo
    que debe tener una fluidez razonable en algebra para poder abordar
    el cálculo.
  </para>


  <!--
  If you??ve never seen C before, this chapter will give you a decent
  background in the style of C used in C++. If you are familiar with the
  style of C described in the first edition of Kernighan & Ritchie
  (often called K&R C), you will find some new and different features in
  C++ as well as in Standard C. If you are familiar with Standard C, you
  should skim through this chapter looking for features that are
  particular to C++. Note that there are some fundamental C++ features
  introduced here, which are basic ideas that are akin to the features
  in C or often modifications to the way that C does things. The more
  sophisticated C++ features will not be introduced until later
  chapters.
  -->

  <!-- [PAG:122] -->
  <para>
    Si nunca antes ha visto C, este capítulo le dará una buena base
    sobre el estilo de C usado en C++. Si está familiarizado con el
    estilo de C descrito en la primera edición de Kernighan &amp;
    Ritchie (también llamado K&amp;R) encontrará algunas
    características nuevas o diferentes tanto en C++ como en el
    estándar C. Si está familiarizado con el estándar C debería
    echar un vistazo al capítulo en busca de las carasterísticas
    particulares de C++. Note que hay algunas características
    fundamentales de C++ que se introducen aquí, que son ideas
    básicas parecidas a características de C o a menudo
    modificaciones en el modo en que C hace las cosas. Las
    características más sofisticadas de C++ serán introducidas en
    capítulos posteriores
  </para> 
  

  <!--
  This chapter is a fairly fast coverage of C constructs and
  introduction to some basic C++ constructs, with the understanding that
  you??ve had some experience programming in another language. A more
  gentle introduction to C is found in the CD ROM packaged in the back
  of this book, titled Thinking in C: Foundations for Java & C++ by
  Chuck Allison (published by MindView, Inc., and also available at
  www.MindView.net). This is a seminar on a CD ROM with the goal of
  taking you carefully through the fundamentals of the C language. It
  focuses on the knowledge necessary for you to be able to move on to
  the C++ or Java languages rather than trying to make you an expert in
  all the dark corners of C (one of the reasons for using a higher-level
  language like C++ or Java is precisely so we can avoid many of these
  dark corners). It also contains exercises and guided solutions. Keep
  in mind that because this chapter goes beyond the Thinking in C CD,
  the CD is not a replacement for this chapter, but should be used
  instead as a preparation for this chapter and for the book.
  -->
  
  <para>
    Este capítulo trata por encima las construciones de C e
    introduce algunas construcciones básicas de C++, suponiendo que
    tiene alguna experiencia programando en otro lenguaje. En el
    CD-ROM que acompaña a este libro hay una introducción más
    suave[FIXME:gentle] a C, titulada <emphasis>Thinking iC:
      Foundations for Java &amp; C++</emphasis> por Chuck Alison
    (publicada por MidView, Inc. y disponible también en <ulink
      url="www.MindView.net"></ulink>). Se trata de un seminario en
    CD-ROM que persigue el objetivo de guiarle cuidadosamente a
    través de los fundamentos del lenguaje C. Se concentra en el
    conocimiento necesario que le permita pasarse a C++ o a Java en
    lugar de intentar convertirle en un experto en todos los oscuros
    recovecos de C (una de las razones para usar un lenguaje de alto
    nivel como C++ o Java es precisamente evitar muchos de estos
    recovecos). También contiene ejercicios y soluciones
    guiadas. Tenga presente que este capítulo va después del CD
    <emphasis>Thinking in C</emphasis>, el CD no reemplaza a este
    capítulo, sino que debería tomarse como una preparación para
    este capítulo y para el libro.
  </para>
  



  <sect1>

    <!-- Creating functions -->
    <title>Creación de funciones</title>
    
    <!--
    In old (pre-Standard) C, you could call a function with any number
    or type of arguments and the compiler wouldn??t complain. Everything
    seemed fine until you ran the program. You got mysterious results
    (or worse, the program crashed) with no hints as to why. The lack of
    help with argument passing and the enigmatic bugs that resulted is
    probably one reason why C was dubbed a ??high-level assembly
    language.?? Pre-Standard C programmers just adapted to it.
    -->

    <para>
      En el antiguo C (previo al estándar), se podía invocar una función
      con cualquier número y tipo de argumentos sin que el compilador se
      quejase. Todo se veía bien hasta que ejecutabas el programa. El
      programa acababa con resultados misteriosos (o peor, el programa
      fallaba) sin ninguna pista de las razones. La falta de ayuda
      acerca del paso de argumentos y los enigmáticos bugs que
      resultaban es, probablemente, la causa de que C se considerase
      <quote>un lenguaje ensamblador de alto nivel</quote>. Los
      programadores de pre-Standard C simplemente se adaptaron a ello.
    </para>
    <!-- [PAG:123] -->

    <!--
    Standard C and C++ use a feature called function prototyping. With
    function prototyping, you must use a description of the types of
    arguments when declaring and defining a function. This description
    is the ??prototype.?? When the function is called, the compiler uses
    the prototype to ensure that the proper arguments are passed in and
    that the return value is treated correctly. If the programmer makes
    a mistake when calling the function, the compiler catches the
    mistake.
    -->
    
    <para>
      Standard C y C++ usan una herramienta llamada prototipado de
      funciones. Con esta herramienta se ha de describir los tipos de
      argumentos al declarar y definir una función. Esta descripción es
      el ??prototipo??. Cuando la función es llamada, el compilador usa
      el ??prototipo??. Cuando la función es llamada, el compilador usa
      el prototipo para asegurarse de que los argumentos pasados sean
      los apropiados, y de que el valor retornado sea tratado
      correctamente. Si el programador comete un error al llamar a la
      función, entonces el compilador detecta el error.
    </para>
 
    <!-- 
    Essentially, you learned about function prototyping (without
    naming it as such) in the previous chapter, since the form of
    function declaration in C++ requires proper prototyping. In a
    function prototype, the argument list contains the types of
    arguments that must be passed to the function and (optionally for
    the declaration) identifiers for the arguments. The order and type
    of the arguments must match in the declaration, definition, and
    function call. Here??s an example of a function prototype in a
    declaration:
    -->

    <para>
      Escencialmente, ha aprendido acerca del prototipado de funciones
      (sin llamarlas de ese modo) en el capítulo previo, ya que la forma
      de declararlas en C++ requiere de un prototipazo apropiado. En un
      prototipo de función, la lista de argumentos contiene los tipos de
      argumentos que deben ser pasados a la función y (opcionalmente
      para la declaración), identificadores para los argumentos. El
      orden y tipo de los argumentos debe coincidir en la declaración,
      definición y llamada a la función. A continuación se muestra un
      ejemplo de un prototipo de función en una declaración: 
    </para>

    int translate(float x, float y, float z);

    <!-- 
    You do not use the same form when declaring variables in function
    prototypes as you do in ordinary variable definitions. That is, you
    cannot say: float x, y, z. You must indicate the type of each
    argument. In a function declaration, the following form is also
    acceptable:
    -->
    
    <para>
      Las declaraciones de variables en prototipos de funciones se hacen
      al declarer variables ordinaries. Esto significa que no se puede
      declarar float x, y, z. Se debe indicar el tipo de cada
      argumento. En una declaración de función, lo siguiente también es
      correcto:
    </para>

    int translate(float, float, float);


    <!--
    Since the compiler doesn??t do anything but check for types when the
    function is called, the identifiers are only included for clarity
    when someone is reading the code.

    In the function definition, names are required because the arguments
    are referenced inside the function:
    -->

    <para>
      Ya que el compilador no hace más que chequear los tipos cuando la
      función es llamada, los identificadores se incluyen solamente para
      propiciar la legibilidad del código cuando alguien lo está
      leyendo.  
    </para>
    <para>
      En la definición, los nombres son necesarios ya que los argumentos
      son referenciados dentro de la función:
    </para>

    int translate(float x, float  y, float z) { x = y = z; // ...  }

    
    <!--
    It turns out this rule applies only to C. In C++, an argument may be
    unnamed in the argument list of the function definition. Since it is
    unnamed, you cannot use it in the function body, of course. Unnamed
    arguments are allowed to give the programmer a way to ??reserve
    space in the argument list.?? Whoever uses the function must still
    call the function with the proper arguments. However, the person
    creating the function can then use the argument in the future
    without forcing modification of code that calls the function. This
    option of ignoring an argument in the list is also possible if you
    leave the name in, but you will get an annoying warning message
    about the value being unused every time you compile the
    function. The warning is eliminated if you remove the name.
    -->

    <para>
      Esta regla sólo se aplica a C. En C++, un argumento puede no ser
      nombrado en la lista de argumentos de la definición de la
      función. Ya que no es nombrado, no es posible utilizarlos en el
      cuerpo de la función, por supuesto. Los argumentos no nombrados se
      permiten para dar al programador una manera de ??reservar espacio
      en la lista de argumentos??. De cualquier modo, la persona que
      crea la función aún así debe de llamar a la función con los
      parametros apropiados. Igualmente, la persona que crea la función
      puede así utilizar el argumento en el futuro sin forzar una
      modificación en el codigo que llama a la función. Esta opción de
      ignorar un argumento en la lista es también posible si se indica
      el nombre, pero siempre aparecería un molesto mensaje de
      advertencia informando que el valor no se utiliza cada vez que se
      compilase la función. La advertencia es eliminada si se quita el
      nombre de dicho argumento.
    </para>

    <!--
    C and C++ have two other ways to declare an argument list. If you
    have an empty argument list, you can declare it as func( ) in C++,
    which tells the compiler there are exactly zero arguments. You
    should be aware that this only means an empty argument list in
    C++. In C it means ??an indeterminate number of arguments (which is
    a ??hole?? in C since it disables type checking in that case). In
    both C and C++, the declaration func(void); means an empty argument
    list. The void keyword means ??nothing?? in this case (it can also
    mean ??no type??in the case of pointers, as you??ll see later in
    this chapter).
    -->

    <para>
      C y C++ tienen otras dos maneras de declarar una lista de
      argumentos. Si se tiene una lista de argumentos vacia, se puede
      declarar esta como func( ) en C++, lo que indica al compilador de
      que hay exactamente cero agumentos. Hay que tener en cuenta que
      esto solo significa una lista de argumentos vacía en C++. Al
      contrario, en C significa ??un número indeterminado de argumentos??
      (lo que es un ??agujero?? en C ya que desabilita la comprobación
      de tipos en este caso). En ambos, C y C++, la declaracion
      func(void); significa una lista de argumentos vacía. La palabra
      clave void significa ??nada?? en este caso (también puede
      significar ??sin tipo?? en el caso de los punteros, como se verá
      mas adelante en este capítulo).
    </para>

    <!--
    The other option for argument lists occurs when you don??t know how
    many arguments or what type of arguments you will have; this is
    called a variable argument list. This ??uncertain argument list?? is
    represented by ellipses (...). Defining a function with a variable
    argument list is significantly more complicated than defining a
    regular function. You can use a variable argument list for a
    function that has a fixed set of arguments if (for some reason) you
    want to disable the error checks of function prototyping. Because of
    this, you should restrict your use of variable argument lists to C
    and avoid them in C++ (in which, as you??ll learn, there are much
    better alternatives). Handling variable argument lists is described
    in the library section of your local C guide.
    -->
    
    <para>
      La otra opción para las listas de argumentos ocurre cuando no se
      sabe cuantos argumentos o qué tipo de argumentos se tendrán; esto
      lleva el nombre de lista de argumentos variable. Esta ??lista
      incierta de agumentos?? es representada con elipses (??). Definir
      una función con una lista de argumentos variable es
      significativamente mas complicado que definir una función
      regular. Se puede utilizar una lista de argumentos variables para
      una función que tiene un grupo de argumentos fijos si (por alguna
      razón) se quiere desabilitar los controles de error del propotipo
      de funciones. Debido a esto, se debe restringir el uso de listas
      de argumentos variables en C y evitarlas en C++ (en el cual, como
      se aprenderá, hay alternativas mucho mejores). El manejo de listas
      de argumentos variables se describe en la sección de librerias de
      la guía local de C.
    </para>


    <sect2>
      <!--Function return values-->
      <title>Valores de retorno de las funciones</title>

      <!--
      A C++ function prototype must specify the return value type of the
      function (in C, if you leave off the return value type it defaults
      to int). The return type specification precedes the function
      name. To specify that no value is returned, use the void
      keyword. This will generate an error if you try to return a value
      from the function. Here are some complete function prototypes:
      -->

      <para>
        Un prototipo de función en C++ debe especificar el tipo de valor
        devuelto de la función (en C, si no se especifica será por
        defecto un int). La especificación del tipo de retorno precede
        al nombre de la función. Para especificar que ningún valor es
        devuelto, se utiliza la palabra clave void. Esto generara un
        error si se intenta devolver un valor desde la función. A
        continuación hay algunos prototipos completos de funciones:
      </para>

int f1(void); // Returns an int, takes no arguments
//Retorna un entero, no tiene argumentos 
int f2(); // Like f1() in C++ but not in Standard C!
//al igual que f1() en C++ pero no en C Stantard
float f3(float, int, char, double); // Returns a float
//Devuelve un real
void f4(void); // Takes no arguments, returns nothing
//No tiene argumentos, no retorna nada

      <!--
      To return a value from a function, you use the return
      statement. return exits the function back to the point right after
      the function call. If return has an argument, that argument
      becomes the return value of the function. If a function says that
      it will return a particular type, then each return statement must
      return that type. You can have more than one return statement in a
      function definition:
      -->

      <para>
        Para devolver un valor desde una función, se utiliza la
        sentencia return. Esta sentencia sale de la función y salta
        hasta la sentencia que se halla justo después de la llamada a la
        función. Si return tiene un arguemento, éste se convierte en el
        valor de retorno de la función. Si una función indica que
        retornara un tipo en particular, entonces cada sentencia return
        debe retornar este tipo. Se puede tener mas de una sentencia
        return en una definición de función:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Return.cpp"/>
</programlisting>


      <!--
      In cfunc( ), the first if that evaluates to true exits the
      function via the return statement. Notice that a function
      declaration is not necessary because the function definition
      appears before it is used in main( ), so the compiler knows about
      it from that function definition.
      -->

      <para>
        En <function>Cfunc()</function>, el primer if que evalua que la
        condición sea true sale de la función via la sentencia
        return. Notar que no es necesaria la declaración de la función
        puesto que la definición de la función aparece antes de ser
        utilizada en main( ), de modo que el compilador sabe de su
        existencia desde dicha definición.
      </para>

    </sect2>

    <sect2>
      <title>Uso de funciones de librerías C</title>

      <!--
      All the functions in your local C function library are available
      while you are programming in C++. You should look hard at the
      function library before defining your own function ? there??s a
      good chance that someone has already solved your problem for you,
      and probably given it a lot more thought and debugging.
      -->
      
      <para>
        Todas las funciones en la librería local de funciones de C están
        disponibles mientras se está programando en C++. Se debería
        buscar bien esta función en la librería antes de definir una
        propia ? hay muchas probabilidades de que alguien haya resuelto
        el problema antes, y probablemente haya dedicado mas tiempo
        pensando y depurando.
      </para>

      <!--
      A word of caution, though: many compilers include a lot of extra
      functions that make life even easier and are tempting to use, but
      are not part of the Standard C library. If you are certain you
      will never want to move the application to another platform (and
      who is certain of that?), go ahead ?use those functions and make
      your life easier. If you want your application to be portable, you
      should restrict yourself to Standard library functions. If you
      must perform platform-specific activities, try to isolate that
      code in one spot so it can be changed easily when porting to
      another platform. In C++, platform-specific activities are often
      encapsulated in a class, which is the ideal solution.
      -->

      <para>
        Una advertencia, igualmente: muchos compiladores incluyen muchas
        funciones extra que hacen la vida mucho mas fácil y son
        tentadoras de usar, pero no son parte de la libreria de C
        Standard. Si se está seguro de que jamás se deseará mover la
        aplicación a otra plataforma (¿y quién está seguro de ello?),
        adelante ?utilizad estas funciones y haceros la vida mas
        fácil. Si se desea que la aplicación pueda migrarse, se debería
        restringir el uso de funciones a las de la libreria Standard
        únicamente. Si se debe realizar actividades específicas de la
        plataforma, se debería intentar aislar este codigo de tal modo
        que pueda cambiarse fácilmente al ser migrado a otra
        plataforma. En C++, las actividades de una plataforma específica
        son a menudo encapsuladas en una clase, lo que es la solución
        ideal.
      </para>

      <!--
      The formula for using a library function is as follows: first,
      find the function in your programming reference (many programming
      references will index the function by category as well as
      alphabetically). The description of the function should include a
      section that demonstrates the syntax of the code. The top of this
      section usually has at least one #include line, showing you the
      header file containing the function prototype. Duplicate this
      #include line in your file so the function is properly
      declared. Now you can call the function in the same way it appears
      in the syntax section. If you make a mistake, the compiler will
      discover it by comparing your function call to the function
      prototype in the header and tell you about your error. The linker
      searches the Standard library by default, so that??s all you need
      to do: include the header file and call the function.
      -->
      
      <para>
        La fórmula para usar una librería de funciones es la siguiente:
        primero, encotrar la función en la referencia de programación
        (muchas referencias de programación ordenan las funciones por
        categoría antes que alfabéticamente). La descripción de la
        función debe incluir una sección que demuestre la sintaxis del
        codigo. La parte superior de esata sección tiene al menos una
        línea #include, mostrando el fichero principal que contiene el
        prototipo de función. Se debe duplicar este #include en vuestro
        fichero para que la función este correctamente declarada. Ahora
        se puede llamar la funcion de la misma manera que aparece en la
        sección de sintaxis. Si se comete un error, el compilador lo
        descubrirá comparando la llamada a la función con el prototipo
        de la cabecera e informará de dicho error. El linker busca la
        librería Standard por defecto, de modo que lo único que hay que
        hacer es: incluir el fichero de cabecera y llamar a la función.
      </para>

    </sect2>

    <sect2>
      <!-- Creating your own libraries with the librarian -->
      <title>Creación de librerías propias</title>

      <!--
      You can collect your own functions together into a library. Most
      programming packages come with a librarian that manages groups of
      object modules. Each librarian has its own commands, but the
      general idea is this: if you want to create a library, make a
      header file containing the function prototypes for all the
      functions in your library. Put this header file somewhere in the
      preprocessor??s search path, either in the local directory (so it
      can be found by #include ??header??) or in the include directory
      (so it can be found by #include <header>). Now take all the object
      modules and hand them to the librarian along with a name for the
      finished library (most librarians require a common extension, such
      as .lib or .a). Place the finished library where the other
      libraries reside so the linker can find it. When you use your
      library, you will have to add something to the command line so the
      linker knows to search the library for the functions you call. You
      must find all the details in your local manual, since they vary
      from system to system.  
      -->

      <para>
        Se pueden coleccionar funciones propias juntas en una
        librería. La mayoróa de paquetes de programación vienen con un
        bibliotecario que maneja grupos de modulos de objetos. Cada
        bibliotecario tiene sus propios comandos, pero la idea general
        es la siguiente: si se desea crear una librería, se debe hacer
        un fichero cabecera conteniendo los prototipos para todas las
        funciones de la librería. Hay que ubicar este fichero cabecera
        en alguna parte del path de búsqueda del preprocesador, ya sea
        en el directorio local (de modo que podrá ser encontrado
        mediante #include ??header??) o bien en el directorio include
        (por lo que se podrá encontrar mediante #include
        &lt;header&gt;). Luego se han de juntar todos los modulos de
        objetos y pasarlos al bibliotecaio junto con un nombre para la
        librería recién construida (la mayoría de los bibliotecrios
        requieren una extensión común, como por ejemplo .lib o .a). Se
        ha de ubicar la librería completa donde residen todas las demás,
        de manera que el linker sabrá buscar estas funciones en dicha
        librería al ser llamadas. Se pueden encontrar todos los detalles
        en el manual local, ya que pueden variar de un sistema a otro.
      </para>

     </sect2>
  </sect1>

  <sect1>
    <!-- Controlling execution  -->
    <title>Control de la ejecuión</title>

    <!--
    This section covers the execution control statements in C++. You
    must be familiar with these statements before you can read and write
    C or C++ code.

    C++ uses all of C??s execution control statements. These include
    if-else, while, do-while, for, and a selection statement called
    switch. C++ also allows the infamous goto, which will be avoided in
    this book.
    -->

    <para>
      Esta sección trata las sentencias de control de ejecución en
      C++. Hay que familiarizarse con estas sentencias antes de que se
      pueda leer o escribir codigo C o C++.  

      C++ usa todas las sentencias de control de ejecución de C. Esto
      incluye if-else, do-while, for, y una sentencia de selección
      llamada switch. C++ también admite el infame goto, el cual será
      evitado en este libro.
    </para>
  
    <sect2>
      <title>Verdadero y falso</title>

      <!--
      All conditional statements use the truth or falsehood of a
      conditional expression to determine the execution path. An example
      of a conditional expression is A == B. This uses the conditional
      operator == to see if the variable A is equivalent to the variable
      B. The expression produces a Boolean true or false (these are
      keywords only in C++; in C an expression is ??true?? if it
      evaluates to a nonzero value). Other conditional operators are >,
      <, >=, etc. Conditional statements are covered more fully later in
      this chapter.
      -->

      <para>
        Todas las sentencias condicionales utilizan la veracidad o la
        falsedad de una expresión condicional para determinar el camino
        de ejecución. Un ejemplo de una expresión condicional es A ==
        B. Esto utiliza el operador condicional == para saber si la
        variable A es equivalente a la variable B. La expresión produce
        un Booleano true o false (esto son palabras clave solo en C++;
        en C una expresión es verdadera(true) si se contrasta contra un
        valor diferente de cero). Otros operadores condicionales son
        &gt;, &lt;, &gt;=, etc. Las sentencias condicional serán
        tratadas a fondo mas adelante en este capítulo.
      </para>
    </sect2>

    <sect2>
      <title>if-else</title>
      
      <!--
      The if-else statement can exist in two forms: with or without the
      else. The two forms are:
      -->

      <para>
        La sentencia if-else puede existir de dos formas: con o sin el
        else. Las dos formas son:        
      </para>

      if(expression) //expresión
      statement //sentencia

      o

      if(expression)
      statement
      else
      statement

      <!--
      The ??expression?? evaluates to true or false. The ??statement??
      means either a simple statement terminated by a semicolon or a
      compound statement, which is a group of simple statements enclosed
      in braces. Any time the word ??statement?? is used, it always
      implies that the statement is simple or compound. Note that this
      statement can also be another if, so they can be strung together.
      -->

      <para>
        Se evalúa que la expresión sea true o false. La ??sentencia??
        puedeq ser una sentencia simple acabada en un punto y coma, o
        bien una sentencia compuesta, lo que no es más que un grupo de
        sentencias simples encerradas entre llaves. Siempre que se
        utiliza la palabra ??sentencia??, implica que la sentencia es
        simple compuesta. Tener en cuenta que dicha sentencia puede ser
        incluso otro if, por lo que pueden ir anidados.
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Ifthen.cpp"/>
</programlisting>


      <!--
      It is conventional to indent the body of a control flow statement
      so the reader may easily determine where it begins and ends[30].
      -->
    
      <para>
        Es costumbre indentar el cuerpo de una sentencia de flujo de
        control, de modo que el lector puede determinar fácilmente donde
        comienza y dónde acaba[30].
      </para>

    </sect2>
    <sect2>
      <title>while</title>
      
      <!--
      while, do-while, and for control looping. A statement repeats
      until the controlling expression evaluates to false. The form of a
      while loop is
      -->
      
      <para>
        Los bucles de control while, do-while, y for. Una sentencia se
        repite hasta que la expresión de control sea false. La
        estructura de un bucle while es:
      </para>

      while(expression) statement

      <!--
      The expression is evaluated once at the beginning of the loop and
      again before each further iteration of the statement.

      This example stays in the body of the while loop until you type
      the secret number or press control-C.
      -->

      <para>
        La expresión es evaluada una vez al comienzo del bucle y cada
        vez antes de cada iteración de la sentencia.
        
        Este ejemplo se ejecuta el cuerpo del bucle while hasta que se
        introduzca el numero secreto o se presione control-C.
      </para>


<programlisting>
<xi:include parse="text" href="./code/C03/Guess.cpp"/>
</programlisting>


      <!--
      The while??s conditional expression is not restricted to a simple
      test as in the example above; it can be as complicated as you like
      as long as it produces a true or false result. You will even see
      code where the loop has no body, just a bare semicolon:
      -->

      <para>
        La expresión condicional del while no está restringida a una
        simple prueba como en el ejemplo anterior; puede ser tant
        complicada como se desee siempre y cuando se produzca un
        resultado true o false. También se puede ver el código sin
        curepo, solo un simple punto y coma:
      </para>

while(/* Do a lot here */)
 ;

      <!--
      In these cases, the programmer has written the conditional
      expression not only to perform the test but also to do the work.
      -->

      <para>
        En estos casos, el programador ha escrito la expresión
        condicional no solo para realizar la evaluación, sino también
        para hacer el trabajo.
      </para>

    </sect2>
      
    <sect2>
      <title>do-while</title>

      <!--
      The form of do-while is
      -->

      <para>
        La estructura de do-while es
      </para>

do
statement
while(expression); 

      <!--
      The do-while is different from the while because the statement
      always executes at least once, even if the expression evaluates to
      false the first time. In a regular while, if the conditional is
      false the first time the statement never executes.
      
      If a do-while is used in Guess.cpp, the variable guess does not
      need an initial dummy value, since it is initialized by the cin
      statement before it is tested:
      -->

      <para>
        El do-while es diferente del while ya que la sentencia siempre
        se ejecuta al menos una vez, aún si la expresión resulta false
        la primera vez. En un while regular, si la condicion es falsa la
        primera vez, la sentencia nunca se ejecuta.
      </para>

      <para>
        Si un do-while se utiliza en Guess.cpp, la variable guess no
        necesita un valor ficticio inicial, ya que se inicializa por la
        sentencia cin antes de que sea evaluada:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Guess2.cpp"/>
</programlisting>


      <!--
      For some reason, most programmers tend to avoid do-while and just
      work with while.
      -->
      
      <para>
        For alguna razón, la mayoría de los programadores tienden a
        evitar el do-while y se limitan a trabajar con el while.
      </para>
    </sect2>

    <sect2>
      <title>for</title>

      <!--
      A for loop performs initialization before the first
      iteration. Then it performs conditional testing and, at the end of
      each iteration, some form of ??stepping.?? The form of the for
      loop is:
      -->

      <para>
        Un bucle for realiza una inicialización antes de la primera
        iteración. Luego ejecuta una evaluación condicional y, al final
        de cada iteración, cierta forma de ??stepping??, avanzar paso a
        paso. La estructura del for es:
      </para>

for(initialization; conditional; step)
statement

      <!--
      Any of the expressions initialization, conditional, or step may be
      empty. The initialization code executes once at the very
      beginning. The conditional is tested before each iteration (if it
      evaluates to false at the beginning, the statement never
      executes). At the end of each loop, the step executes.

      for loops are usually used for ??counting?? tasks:
      -->

      <para>
        Cualquiera de las expresiones de inicialización, condicional, o
        paso puede estar vacía. La inicialización se ejecuta una vez al
        principio de todo. La expresión condicional se evalúa antes de
        cada iteración (si se evalúa a false en desde el principio, el
        cuerpo del bucle nunca llega a ejecutarse). Al final de cada
        iteración del bucle, el step se ejecuta.
      </para>

      <para>
        Los bucles for son generalmente utilizados para tareas de
        ??contar??:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Charlist.cpp"/>
</programlisting>

      <!--
      You may notice that the variable i is defined at the point where
      it is used, instead of at the beginning of the block denoted by
      the open curly brace ??{??. This is in contrast to traditional
      procedural languages (including C), which require that all
      variables be defined at the beginning of the block. This will be
      discussed later in this chapter.
      -->

      <para>
        Puede ocurrir que la variable i sea definida en el punto en el
        que es utilizada, en vez de al principio del bloque delimitado
        por la apertura de la llave ??{??. Esto difiere de los lenguajes
        procedurales tradicionales (incluyendo C), los cuales requieren
        que todas ls variables sean definidas al principio del
        bloque. Esto será discutido mas adelante en este capítulo.
      </para>
    </sect2>

    <sect2>
      <!-- The break and continue keywords -->
      <title>Las pasabras reservadas <literal
      role="keyword">break</literal> y <literal
      role="keyword">continue</literal></title>

      <!--
      Inside the body of any of the looping constructs while, do-while,
      or for, you can control the flow of the loop using break and
      continue. break quits the loop without executing the rest of the
      statements in the loop. continue stops the execution of the
      current iteration and goes back to the beginning of the loop to
      begin a new iteration.
      -->

      <para>
        Dentro del cuerpo de cualquiera de las estructuras de bucle
        while, do-while, o for, se puede controlar el flujo del bucle
        utilizando break y continue. Break abandona el bucle sin
        ejecutar el resto de las sentencias en el bucle. continue para
        la ejecución de la iteración actual y vuelve al principio del
        bucle para comenzar una nueva iteración.
      </para>

      <!-- 
      As an example of break and continue, this program is a very
      simple menu system:
      --> 

      <para>
        A modo de ejemplo de break y continue, este programa es un menu
        de sistema muy simple:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Menu.cpp"/>
</programlisting>

      <!--
      If the user selects ??q?? in the main menu, the break keyword is
      used to quit, otherwise the program just continues to execute
      indefinitely. After each of the sub-menu selections, the continue
      keyword is used to pop back up to the beginning of the while loop.
      -->

      <para>
        Si el usuario selecciona ??q?? en el menu principal, la palabra
        clave break se utiliza para salir, de otro modo, el programa
        continua ejecutandose indefinidamente. Luego de cada selección
        de sub-menu, la palabra clave continue es usada para volver
        atrás hasta el comienzo del bucle while.
      </para>

      <!--
      The while(true) statement is the equivalent of saying ??do this
      loop forever.?? The break statement allows you to break out of
      this infinite while loop when the user types a ??q.??
      -->

      <para>
        El while(true) es el equivalente a decir ??haz este bucle para
        siempre??.  La sentencia break permite romper este bucle
        infinito cuando el usuario teclea ??q??.
      </para>

    </sect2>

    <sect2>
      <title>switch</title>

      <!--
      A switch statement selects from among pieces of code based on the
      value of an integral expression. Its form is:
      -->

      <para>
        La sentencia switch selecciona de un grupo de codigos basados en
        el valor de una expression integral. Su estructura es:
      </para>

switch(selector) {
case integral-value1 : statement; break;
case integral-value2 : statement; break;
case integral-value3 : statement; break;
case integral-value4 : statement; break;
case integral-value5 : statement; break;
    (...)
default: statement;
} 

      <!--
      Selector is an expression that produces an integral value. The
      switch compares the result of selector to each integral value. If
      it finds a match, the corresponding statement (simple or compound)
      executes. If no match occurs, the default statement executes.
      -->
      
      <para>
        Selector es una expression que produce un valor integral. El
        switch compará el resultado de selector para cada valor
        integral. Si encuentra una coincidencia, se ejecutará la
        sentencia correspondiente (ya sea simple o compuesta. Si no se
        encuentra ninguna coincidencia, la sentencia default se
        ejecutará.
      </para>

      <!--
      You will notice in the definition above that each case ends with a
      break, which causes execution to jump to the end of the switch
      body (the closing brace that completes the switch). This is the
      conventional way to build a switch statement, but the break is
      optional. If it is missing, your case ??drops through?? to the one
      after it. That is, the code for the following case statements
      execute until a break is encountered. Although you don??t usually
      want this kind of behavior, it can be useful to an experienced
      programmer.
      -->

      <para>
        Se puede obeservar en la definición anterior que cada case acaba
        con un break, lo que causa que la ejecución salte hasta el final
        del cuerpo del switch (la llave final que completa el
        switch). Esta es la forma convencional de construir una
        sentencia switch, pero la palabra break es opcional. Si no se
        indica, el case que se ha cumplido ??cae?? al siguiente de la
        lista. Esto significa, que el código del siguiente case, se
        ejecutara hasta que un break sea encontrado. Aunque normalmente
        no se desea este tipo de comportamiento, puede ser de ayuda para
        un programador experimentado.
      </para>

      <!--
      The switch statement is a clean way to implement multi-way
      selection (i.e., selecting from among a number of different
      execution paths), but it requires a selector that evaluates to an
      integral value at compile-time. If you want to use, for example, a
      string object as a selector, it won??t work in a switch
      statement. For a string selector, you must instead use a series of
      if statements and compare the string inside the conditional.
      -->

      <para>
        La sentencia switch es una manera limpia de implementer una
        selección multi-modo (por ejemplo, seleccionando de entre un
        numero de diferentes paths de ejecución), pero require un
        selector que evalue esto contra un valor integral en el momento
        de la compilación. Si se quisiera utilizar, por ejemplo un
        objeto de tipo string como selector, no funcionaría en una
        sentencia switch. Para un selector de tipo string, se debe
        utilizar en cambio una serie de sentencias if y comparar la
        string dentro de la condición.
      </para>

      <!--
      The menu example shown above provides a particularly nice example
      of a switch:
      -->

      <para>
        El ejemplo del menu demostrado anteriormente prove un ejemplo
        particularmente fácil de un switch:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Menu2.cpp"/>
</programlisting>

      <!--
      The quit flag is a bool, short for ??Boolean,?? which is a type
      you??ll find only in C++. It can have only the keyword values true
      or false. Selecting ??q?? sets the quit flag to true. The next
      time the selector is evaluated, quit == false returns false so the
      body of the while does not execute.
      -->

      <para>
        El flag quit es un bool, abreviatura para ??Boolean??, el cual
        es un tipo que solo se encuentra en C++. Puede tener unicamente
        los valores clave true o false. Seleccionando ??q?? le da el
        valor true al flag quit. La próxima vez que el selector sea
        evaluado, quit == false retornara false de modo que el cuerpo
        del bucle while no se ejecutará.
      </para>

    </sect2> 

    <sect2>
      <!-- Using and misusing goto -->
      <title>Uso y maluso de <literal
          role="keyword">goto</literal></title>
      
      <!--
      The goto keyword is supported in C++, since it exists in C. Using
      goto is often dismissed as poor programming style, and most of the
      time it is. Anytime you use goto, look at your code and see if
      there??s another way to do it. On rare occasions, you may discover
      goto can solve a problem that can??t be solved otherwise, but
      still, consider it carefully. Here??s an example that might make a
      plausible candidate:
      -->

      <para>
        La palabra clave goto es soportada en C++, ya que existe en
        C. El uso de goto es a menudo calificado de un estilo de
        programación pobre, y la mayor parte del tiempo lo es. Siempre
        que se utilice goto, se debe reviser bien el código par aver si
        hay alguna otra manera de hacerlo. En raras ocasiones, goto
        puede resolvr un problema que no puede ser resuelto de otra
        manera, pero, aún así, se debe considerer cuidadosamente. A
        continuación hay un ejemplo que puede ser un plausible
        candidato:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/gotoKeyword.cpp"/>
</programlisting>

      <!--
      The alternative would be to set a Boolean that is tested in the
      outer for loop, and then do a break from the inner for
      loop. However, if you have several levels of for or while this
      could get awkward.
      -->
     
      <para>
        La alternativa sería dar valor a un booleano que sea evaluado en
        el for externo, y luego hacer un break desde el for interno. De
        todos modos, si hay demasiados niveles de for o while esto puede
        ser tedioso.
      </para>
    </sect2>

    <sect2>
      <title>Recursividad</title>

      <!--
      Recursion is an interesting and sometimes useful programming
      technique whereby you call the function that you??re in. Of
      course, if this is all you do, you??ll keep calling the function
      you??re in until you run out of memory, so there must be some way
      to ??bottom out?? the recursive call. In the following example,
      this ??bottoming out?? is accomplished by simply saying that the
      recursion will go only until the cat exceeds ??Z??:[31]
      -->
      
      <para>
        La recursividad es una interesante y a veces útil técnica de
        programación, en donde se llama a la función dentro de la que se
        está. Por supuesto, si es todo lo que hace, se estaría llamando
        a la función hasta que se acabase la memoria de ejecución, de
        modo que debe existi una manera de ??escapase?? de la llamada
        recursiva. En el siguiente ejemplo, esta ??escapada?? se
        consigue simplemente diciendo que la recursión solo continuará
        hasta que cat exceda ??Z??: [31]
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/CatsInHats.cpp"/>
</programlisting>


      <!--
      In removeHat(), you can see that as long as cat is less than ??Z??,
      removeHat( ) will be called from within removeHat( ), thus
      effecting the recursion. Each time removeHat( ) is called, its
      argument is one greater than the current cat so the argument keeps
      increasing.
      -->

      <para>
        En removeHat( ), se puede ver que mientras cat sea menor que
        ??Z??, removeHat( ) se llamará a sí misma desde dentro, así
        efectuando la recursividad. Cada vez que removeHat( ) es
        llamada, el argumento es una vez mas grande que el actual cat de
        modo que el argumento continua aumentando.
      </para>

      <!--
      Recursion is often used when evaluating some sort of arbitrarily
      complex problem, since you aren??t restricted to a particular
      ??size?? for the solution ? the function can just keep recursing
      until it??s reached the end of the problem.
      -->

      <para>
        La recursividad es amenudo utilizada cuando se evalua algun tipo
        de problema arbitrariamente complejo, ya que no se restringe a
        un nigún tamaño en concreto para la solución ? la function puede
        simplemente efecutar la recursividad hasta que se haya alcanzado
        el final del problema.
      </para>
    </sect2>   
  </sect1>

  <sect1>
    <!-- Introduction to operators -->
    <title>Introducción a los operadores</title>

    <!--
    You can think of operators as a special type of function (you'll
    learn that C++ operator overloading treats operators precisely that
    way). An operator takes one or more arguments and produces a new
    value. The arguments are in a different form than ordinary function
    calls, but the effect is the same.
    -->

    <para>
      Se puede pensar en un operador como un tipo de función especial
      (aprenderá que en C++ la sobrecarga de operadores los trata
      precísamente de esa forma). Un operador recibe uno o más
      argumentos y produce un nuevo valor. Los argumentos se pasan de
      una manera diferente que en las llamadas a funciones normales,
      pero el efecto es el mismo.
    </para>

    <!--
    From your previous programming experience, you should be reasonably
    comfortable with the operators that have been used so far. The
    concepts of addition (+), subtraction and unary minus (-),
    multiplication (*), division (/), and assignment(=) all have
    essentially the same meaning in any programming language. The full
    set of operators is enumerated later in this chapter.
    -->
    
    <para>
      De su experiencia previa en programación, debe estar
      razonablemente cómodo con los operadores que han sido
      utilizados. Los conceptos de adición (+), substracción y resta
      unaria (-), multiplicación (*), división (/), y asignación (=)
      tienen todos el mismo significado en cualquier lenguaje de
      programación. Todo el grupo de operadores se enumera más
      adelante en este capítulo.
    </para>
      
    <sect2>
      <!-- Precedence -->
      <title>Precedencia</title>

      <!--
      Operator precedence defines the order in which an expression
      evaluates when several different operators are present. C and C++
      have specific rules to determine the order of evaluation. The
      easiest to remember is that multiplication and division happen
      before addition and subtraction.  After that, if an expression
      isn't transparent to you it probably won't be for anyone reading
      the code, so you should use parentheses to make the order of
      evaluation explicit. For example:
      -->

      <para>
	La precedencia de operadores define el orden en el cual una
	expresión se evalúa cuando varios diferentes operadores son
	presentados. C y C++ tienen reglas específicas para determinar
	el orden de evaluación. Lo más fácil de recordar es que la
	multiplicación y la división se ejecutan antes que la adición y
	la substracción. Luego, si una expresión no es transparente al
	programador que la escribe, probablemente lo será para nadie que
	lea el código, de modo que se deben usar paréntesis para hacer
	el explícito el orden de la evaluación. Por ejemplo:
      </para>

      <para>
             A = X + Y - 2/2 + Z;
      </para>

      <!--
      evaluating the result with X = 1, Y = 2, and Z = 3.)
      -->

      <para>
	(Intente evaluar el resultado con X =1, Y = 2, y Z = 3.)
      </para>



    </sect2>
    
    <sect2>
      <!-- Auto increment and decrement -->
      <title>Auto incremento y decremento</title>


      <!--
      C, and therefore C++, is full of shortcuts. Shortcuts can make
      code much easier to type, and sometimes much harder to
      read. Perhaps the C language designers thought it would be easier
      to understand a tricky piece of code if your eyes didn't have to
      scan as large an area of print.
      -->

      <para>
	C, y por tanto C++, está lleno de atajos. Los atajos pueden hacer
	el código mucho mas fácil de escribir, y a veces más difícil de
	leer. Quizás los diseñadores del lenguaje C pensaron que sería
	más fácil entender un trozo complicado de código si los ojos no
	tienen que leer una larga línea de letras.
      </para>


      <!--
      One of the nicer shortcuts is the auto-increment and
      auto-decrement operators. You often use these to change loop
      variables, which control the number of times a loop executes.
      -->

      <para>
	Uno de los mejores atajos son los operadores de auto-incremento
	y auto-decremento. Se utilizan a menudo para cambiar variables
	en un bucle, las cuales controlan el número de veces que se
	ejecuta un bucle.
      </para>

      <!--
      The auto-decrement operator is '--' and means "decrease by one
      unit."  The auto-increment operator is '++' and means "increase by
      one unit." If A is an int, for example, the expression ++A is
      equivalent to (A = A + 1). Auto-increment and auto-decrement
      operators produce the value of the variable as a result. If the
      operator appears before the variable, (i.e., ++A), the operation
      is first performed and the resulting value is produced. If the
      operator appears after the variable (i.e. A++), the current value
      is produced, and then the operation is performed. For example:
      -->

      <para> 
	El operador de auto-decremento es '--' y significa
	"decrementar de a una unidad". El operador de auto-incremento es
	'++' y significa "incrementar de a una unidad". Si es un entero,
	por ejemplo, la expresión ++A es equivalente a (A = A + 1). Los
	operadores de auto-incremento o auto-decremento producen el
	valor de la variable como resultado. Si el operador aparece
	antes de la variable (p.e, ++A), la operación se ejecuta primero
	y después se produce el valor resultante. Si el operador aparece
	a continuación de la variable (p.e, A++), primero se produce el
	valor actual, y luego se realiza la operación. Por ejemplo:
      </para>


<programlisting>
<xi:include parse="text" href="./code/C03/AutoIncrement.cpp"/>
</programlisting>

      <!--
      If you've been wondering about the name "C++," now you understand. It
      implies "one step beyond C."
      -->

      <para>
	Si se ha estado preguntando acerca del nombre <quote>C++</quote>, ahora lo
	entiendes. Significa "un paso más allá de C".
      </para>

    </sect2>
  </sect1>    
    

  <sect1>
    <title>Introducción a los tipos de datos</title>
    <para>
    </para>

    <sect2>
      <title>Tipos empotrados básicos</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>booleano, true y false</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Especificadores</title>
      <para>
      </para>
    </sect2>
      
    <sect2>
      <title>Introducción a los punteros</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>FIXME: Modifying the outside object</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Introducción a las referencias de C++</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Punteros y referencias como modificadores</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Alcance</title>
    <para>
    </para>

    <sect2>
      <title>Definición de variables 'al vuelo'</title>
      <para>
      </para>
    </sect2>
  </sect1>

  
  <sect1>
    <!-- Specifying storage allocation -->
    <title>Especificación del almacenamiento</title>
    <para>
    </para>

    <sect2>
      <title>Variables globales</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Variables locales</title>
      <para>
      </para>
      <sect3>
	<title>Varibles-registro</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title><literal>static</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title><literal>extern</literal></title>
      <para>
      </para>
      <sect3>
	<title>Enlace</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Constantes</title>
      <para>
      </para>
      <sect3>
	<title>Valores constantes</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title><literal>volatile</literal></title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Los operadores y su uso</title>
    <para>
    </para>

    <sect2>
      <title>Asignación</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores matemáticos</title>
      <para>
      </para>
      <sect3>
	<title>Introducción a las macros del preprocesador</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Operadores relacionales</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores lógicos</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores para bits</title>
      <!-- Bitwise operators -->
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores de desplazamiento</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores unarios</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador ternario</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador ternario</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador ternario</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador coma</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Trampas habituales cuando se usan los operadores</title>
      <!--  Common pitfalls when using operators -->
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores del molde (casting)</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Moldeado explícito en C++</title>
      <para>
      </para>

      <sect3>
	<title>Molde estático</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Molde constante</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>FIXME:  reinterpret_cast</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title><literal>sizeof</literal> - un operador en si mismo</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>La palabra reservada <literal>keyword</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores explícitos</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Creación de tipos compuestos</title>
    <para>
    </para>
    
    <sect2>
      <title>Operadores explícitos</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Creación de alias usando <literal>typedef</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>
	Combinación de variables por medio de  <literal>struct</literal>
      </title>
      <para>
      </para>
      <sect3>
	<title>Punteros y estructuras</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Programas más claros gracias a <literal>enum</literal></title>
      <para>
      </para>

      <sect3>
	<title>Comprobación de tipos para las enumeraciones</title>
	<para>
	</para>
      </sect3>
    </sect2>


    <sect2>
      <title>Cómo Ahorrar memoria con <literal>union</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Arrays</title>
      <para>
      </para>

      <sect3>
	<title>Punteros y arrays</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>El formato de punto flotante</title>
	<!-- Exploring floating-point format -->
	<para>
	</para>
      </sect3>

     <sect3>
	<title>Aritmética de punteros</title>
	<para>
	</para>
      </sect3>

    </sect2>
  </sect1>


  <sect1>
    <title>FIXME: Debugging hints</title>
    <para>
    </para>

    <sect2>
      <title>Opciones para depuración</title>
      <para>
      </para>

      <sect3>
	<title>Opciones de depuración para el preprocesador</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Opciones de depuración en tiempo de ejecución</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Convertir variables y expresiones en cadenas</title>
      <!-- Turning variables and expressions into strings -->
      <para>
      </para>
    </sect2>

    <sect2>
      <title>La macro C assert()</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Direcciones de función</title>
    <para>
    </para>

    <sect2>
      <title>Definición de un puntero a función</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Declaraciones y definiciones complicadas</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Uso de un puntero a función</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Arrays de punteros a funciones</title>
      <para>
      </para>
    </sect2>
  </sect1>


  <sect1>
    <title>Make: cómo hacer compilación separada</title>
    <para>
    </para>

    <sect2>
      <title>Las actividades de Make</title>
      <para>
      </para>

      <sect3>
	<title>Macros</title>
	<para>
	</para>
      </sect3>


      <sect3>
	<title>Reglas de sufijo</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Objetivos por defecto</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Los Makefiles de este libro</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Un ejemplo de Makefile</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para>
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>
    <para>
    </para>
  </sect1>
</chapter>

