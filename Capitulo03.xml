<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:               Emacs 21/PSGML
  Traducción original:  Bárbara Teruggi
  Formateado DocBook:   David Villa Alises
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C3">

  <title>El C en C++</title>

  <!-- 
  Since C++ is based on C, you must be familiar with the syntax of
  C in order to program in C++, just as you must be reasonably fluent in
  algebra in order to tackle calculus.
  -->

  <!-- [PAG:121] -->
  <highlights>
  <para>
    Como C++ está basado en C, debe estar familiarizado con la sintaxis
    de C para poder programar en C++, del mismo modo que debe tener una
    fluidez razonable en algebra para poder abordar el cálculo.
  </para>
  </highlights>

  <!--
  If you??ve never seen C before, this chapter will give you a decent
  background in the style of C used in C++. If you are familiar with the
  style of C described in the first edition of Kernighan & Ritchie
  (often called K&R C), you will find some new and different features in
  C++ as well as in Standard C. If you are familiar with Standard C, you
  should skim through this chapter looking for features that are
  particular to C++. Note that there are some fundamental C++ features
  introduced here, which are basic ideas that are akin to the features
  in C or often modifications to the way that C does things. The more
  sophisticated C++ features will not be introduced until later
  chapters.
  -->

  <!-- [PAG:122] -->
  <para>
    Si nunca antes ha visto C, este capítulo le dará una buena base
    sobre el estilo de C usado en C++. Si está familiarizado con el
    estilo de C descrito en la primera edición de Kernighan &amp;
    Ritchie (también llamado K&amp;R) encontrará algunas
    características nuevas o diferentes tanto en C++ como en el
    estándar C. Si está familiarizado con el estándar C debería
    echar un vistazo al capítulo en busca de las carasterísticas
    particulares de C++. Note que hay algunas características
    fundamentales de C++ que se introducen aquí, que son ideas
    básicas parecidas a características de C o a menudo
    modificaciones en el modo en que C hace las cosas. Las
    características más sofisticadas de C++ serán introducidas en
    capítulos posteriores
  </para> 
  

  <!--
  This chapter is a fairly fast coverage of C constructs and
  introduction to some basic C++ constructs, with the understanding that
  you??ve had some experience programming in another language. A more
  gentle introduction to C is found in the CD ROM packaged in the back
  of this book, titled Thinking in C: Foundations for Java & C++ by
  Chuck Allison (published by MindView, Inc., and also available at
  www.MindView.net). This is a seminar on a CD ROM with the goal of
  taking you carefully through the fundamentals of the C language. It
  focuses on the knowledge necessary for you to be able to move on to
  the C++ or Java languages rather than trying to make you an expert in
  all the dark corners of C (one of the reasons for using a higher-level
  language like C++ or Java is precisely so we can avoid many of these
  dark corners). It also contains exercises and guided solutions. Keep
  in mind that because this chapter goes beyond the Thinking in C CD,
  the CD is not a replacement for this chapter, but should be used
  instead as a preparation for this chapter and for the book.
  -->
  
  <para>
    Este capítulo trata por encima las construciones de C e
    introduce algunas construcciones básicas de C++, suponiendo que
    tiene alguna experiencia programando en otro lenguaje. En el
    CD-ROM que acompaña a este libro hay una introducción más
    suave[FIXME:gentle] a C, titulada <emphasis>Thinking iC:
      Foundations for Java &amp; C++</emphasis> por Chuck Alison
    (publicada por MidView, Inc. y disponible también en <ulink
      url="www.MindView.net"></ulink>). Se trata de un seminario en
    CD-ROM que persigue el objetivo de guiarle cuidadosamente a
    través de los fundamentos del lenguaje C. Se concentra en el
    conocimiento necesario que le permita pasarse a C++ o a Java en
    lugar de intentar convertirle en un experto en todos los oscuros
    recovecos de C (una de las razones para usar un lenguaje de alto
    nivel como C++ o Java es precisamente evitar muchos de estos
    recovecos). También contiene ejercicios y soluciones
    guiadas. Tenga presente que este capítulo va después del CD
    <emphasis>Thinking in C</emphasis>, el CD no reemplaza a este
    capítulo, sino que debería tomarse como una preparación para
    este capítulo y para el libro.
  </para>
  



  <sect1>
    <!-- Creating functions -->
    <title>Creación de funciones</title>
    
    <!--
    In old (pre-Standard) C, you could call a function with any number
    or type of arguments and the compiler wouldn??t complain. Everything
    seemed fine until you ran the program. You got mysterious results
    (or worse, the program crashed) with no hints as to why. The lack of
    help with argument passing and the enigmatic bugs that resulted is
    probably one reason why C was dubbed a ??high-level assembly
    language.?? Pre-Standard C programmers just adapted to it.
    -->

    <para>
      En el antiguo C (previo al estándar), se podía invocar una función
      con cualquier número y tipo de argumentos sin que el compilador se
      quejase. Todo se veía bien hasta que ejecutabas el programa. El
      programa acababa con resultados misteriosos (o peor, el programa
      fallaba) sin ninguna pista de las razones. La falta de ayuda
      acerca del paso de argumentos y los enigmáticos bugs que
      resultaban es, probablemente, la causa de que C se considerase
      <quote>un lenguaje ensamblador de alto nivel</quote>. Los
      programadores de pre-Standard C simplemente se adaptaron a ello.
    </para>
    <!-- [PAG:123] -->

    <!--
    Standard C and C++ use a feature called function prototyping. With
    function prototyping, you must use a description of the types of
    arguments when declaring and defining a function. This description
    is the ??prototype.?? When the function is called, the compiler uses
    the prototype to ensure that the proper arguments are passed in and
    that the return value is treated correctly. If the programmer makes
    a mistake when calling the function, the compiler catches the
    mistake.
    -->
    
    <para>
      Standard C y C++ usan una herramienta llamada prototipado de
      funciones. Con esta herramienta se ha de describir los tipos de
      argumentos al declarar y definir una función. Esta descripción es
      el ??prototipo??. Cuando la función es llamada, el compilador usa
      el ??prototipo??. Cuando la función es llamada, el compilador usa
      el prototipo para asegurarse de que los argumentos pasados sean
      los apropiados, y de que el valor retornado sea tratado
      correctamente. Si el programador comete un error al llamar a la
      función, entonces el compilador detecta el error.
    </para>
 
    <!-- 
    Essentially, you learned about function prototyping (without
    naming it as such) in the previous chapter, since the form of
    function declaration in C++ requires proper prototyping. In a
    function prototype, the argument list contains the types of
    arguments that must be passed to the function and (optionally for
    the declaration) identifiers for the arguments. The order and type
    of the arguments must match in the declaration, definition, and
    function call. Here??s an example of a function prototype in a
    declaration:
    -->

    <para>
      Escencialmente, ha aprendido acerca del prototipado de funciones
      (sin llamarlas de ese modo) en el capítulo previo, ya que la forma
      de declararlas en C++ requiere de un prototipazo apropiado. En un
      prototipo de función, la lista de argumentos contiene los tipos de
      argumentos que deben ser pasados a la función y (opcionalmente
      para la declaración), identificadores para los argumentos. El
      orden y tipo de los argumentos debe coincidir en la declaración,
      definición y llamada a la función. A continuación se muestra un
      ejemplo de un prototipo de función en una declaración: 
    </para>

    <programlisting>
    int translate(float x, float y, float z);
</programlisting>

    <!-- 
    You do not use the same form when declaring variables in function
    prototypes as you do in ordinary variable definitions. That is, you
    cannot say: float x, y, z. You must indicate the type of each
    argument. In a function declaration, the following form is also
    acceptable:
    -->
    
    <para>
      Las declaraciones de variables en prototipos de funciones se hacen
      al declarer variables ordinaries. Esto significa que no se puede
      declarar float x, y, z. Se debe indicar el tipo de cada
      argumento. En una declaración de función, lo siguiente también es
      correcto:
    </para>

    <programlisting>
    int translate(float, float, float);
</programlisting>

    <!--
    Since the compiler doesn??t do anything but check for types when the
    function is called, the identifiers are only included for clarity
    when someone is reading the code.
    -->

    <para>
      Ya que el compilador no hace más que chequear los tipos cuando la
      función es llamada, los identificadores se incluyen solamente para
      propiciar la legibilidad del código cuando alguien lo está
      leyendo.  
    </para>

    <!--
    In the function definition, names are required because the arguments
    are referenced inside the function:
    -->

    <para>
      En la definición, los nombres son necesarios ya que los argumentos
      son referenciados dentro de la función:
    </para>

    <programlisting>
    int translate(float x, float  y, float z) { x = y = z; // ...  }
</programlisting>

    
    <!--
    It turns out this rule applies only to C. In C++, an argument may be
    unnamed in the argument list of the function definition. Since it is
    unnamed, you cannot use it in the function body, of course. Unnamed
    arguments are allowed to give the programmer a way to ??reserve
    space in the argument list.?? Whoever uses the function must still
    call the function with the proper arguments. However, the person
    creating the function can then use the argument in the future
    without forcing modification of code that calls the function. This
    option of ignoring an argument in the list is also possible if you
    leave the name in, but you will get an annoying warning message
    about the value being unused every time you compile the
    function. The warning is eliminated if you remove the name.
    -->

    <para>
      Esta regla sólo se aplica a C. En C++, un argumento puede no ser
      nombrado en la lista de argumentos de la definición de la
      función. Ya que no es nombrado, no es posible utilizarlos en el
      cuerpo de la función, por supuesto. Los argumentos no nombrados se
      permiten para dar al programador una manera de ??reservar espacio
      en la lista de argumentos??. De cualquier modo, la persona que
      crea la función aún así debe de llamar a la función con los
      parametros apropiados. Igualmente, la persona que crea la función
      puede así utilizar el argumento en el futuro sin forzar una
      modificación en el codigo que llama a la función. Esta opción de
      ignorar un argumento en la lista es también posible si se indica
      el nombre, pero siempre aparecería un molesto mensaje de
      advertencia informando que el valor no se utiliza cada vez que se
      compilase la función. La advertencia es eliminada si se quita el
      nombre de dicho argumento.
    </para>

    <!--
    C and C++ have two other ways to declare an argument list. If you
    have an empty argument list, you can declare it as func( ) in C++,
    which tells the compiler there are exactly zero arguments. You
    should be aware that this only means an empty argument list in
    C++. In C it means ??an indeterminate number of arguments (which is
    a ??hole?? in C since it disables type checking in that case). In
    both C and C++, the declaration func(void); means an empty argument
    list. The void keyword means ??nothing?? in this case (it can also
    mean ??no type??in the case of pointers, as you??ll see later in
    this chapter).
    -->

    <para>
      C y C++ tienen otras dos maneras de declarar una lista de
      argumentos. Si se tiene una lista de argumentos vacia, se puede
      declarar esta como func( ) en C++, lo que indica al compilador de
      que hay exactamente cero agumentos. Hay que tener en cuenta que
      esto solo significa una lista de argumentos vacía en C++. Al
      contrario, en C significa ??un número indeterminado de argumentos??
      (lo que es un ??agujero?? en C ya que desabilita la comprobación
      de tipos en este caso). En ambos, C y C++, la declaracion
      func(void); significa una lista de argumentos vacía. La palabra
      clave void significa ??nada?? en este caso (también puede
      significar ??sin tipo?? en el caso de los punteros, como se verá
      mas adelante en este capítulo).
    </para>

    <!--
    The other option for argument lists occurs when you don??t know how
    many arguments or what type of arguments you will have; this is
    called a variable argument list. This ??uncertain argument list?? is
    represented by ellipses (...). Defining a function with a variable
    argument list is significantly more complicated than defining a
    regular function. You can use a variable argument list for a
    function that has a fixed set of arguments if (for some reason) you
    want to disable the error checks of function prototyping. Because of
    this, you should restrict your use of variable argument lists to C
    and avoid them in C++ (in which, as you??ll learn, there are much
    better alternatives). Handling variable argument lists is described
    in the library section of your local C guide.
    -->
    
    <para>
      La otra opción para las listas de argumentos ocurre cuando no se
      sabe cuantos argumentos o qué tipo de argumentos se tendrán; esto
      lleva el nombre de lista de argumentos variable. Esta ??lista
      incierta de agumentos?? es representada con elipses (??). Definir
      una función con una lista de argumentos variable es
      significativamente mas complicado que definir una función
      regular. Se puede utilizar una lista de argumentos variables para
      una función que tiene un grupo de argumentos fijos si (por alguna
      razón) se quiere desabilitar los controles de error del propotipo
      de funciones. Debido a esto, se debe restringir el uso de listas
      de argumentos variables en C y evitarlas en C++ (en el cual, como
      se aprenderá, hay alternativas mucho mejores). El manejo de listas
      de argumentos variables se describe en la sección de librerias de
      la guía local de C.
    </para>


    <sect2>
      <!--Function return values-->
      <title>Valores de retorno de las funciones</title>

      <!--
      A C++ function prototype must specify the return value type of the
      function (in C, if you leave off the return value type it defaults
      to int). The return type specification precedes the function
      name. To specify that no value is returned, use the void
      keyword. This will generate an error if you try to return a value
      from the function. Here are some complete function prototypes:
      -->

      <para>
        Un prototipo de función en C++ debe especificar el tipo de valor
        devuelto de la función (en C, si no se especifica será por
        defecto un int). La especificación del tipo de retorno precede
        al nombre de la función. Para especificar que ningún valor es
        devuelto, se utiliza la palabra clave void. Esto generara un
        error si se intenta devolver un valor desde la función. A
        continuación hay algunos prototipos completos de funciones:
      </para>

      <programlisting>
int f1(void); // Returns an int, takes no arguments
//Retorna un entero, no tiene argumentos 
int f2(); // Like f1() in C++ but not in Standard C!
//al igual que f1() en C++ pero no en C Stantard
float f3(float, int, char, double); // Returns a float
//Devuelve un real
void f4(void); // Takes no arguments, returns nothing
//No tiene argumentos, no retorna nada
</programlisting>

      <!--
      To return a value from a function, you use the return
      statement. return exits the function back to the point right after
      the function call. If return has an argument, that argument
      becomes the return value of the function. If a function says that
      it will return a particular type, then each return statement must
      return that type. You can have more than one return statement in a
      function definition:
      -->

      <para>
        Para devolver un valor desde una función, se utiliza la
        sentencia return. Esta sentencia sale de la función y salta
        hasta la sentencia que se halla justo después de la llamada a la
        función. Si return tiene un arguemento, éste se convierte en el
        valor de retorno de la función. Si una función indica que
        retornara un tipo en particular, entonces cada sentencia return
        debe retornar este tipo. Se puede tener mas de una sentencia
        return en una definición de función:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Return.cpp"/>
</programlisting>


      <!--
      In cfunc( ), the first if that evaluates to true exits the
      function via the return statement. Notice that a function
      declaration is not necessary because the function definition
      appears before it is used in main( ), so the compiler knows about
      it from that function definition.
      -->

      <para>
        En <function>Cfunc()</function>, el primer if que evalua que la
        condición sea true sale de la función via la sentencia
        return. Notar que no es necesaria la declaración de la función
        puesto que la definición de la función aparece antes de ser
        utilizada en main( ), de modo que el compilador sabe de su
        existencia desde dicha definición.
      </para>

    </sect2>

    <sect2>
      <title>Uso de funciones de librerías C</title>

      <!--
      All the functions in your local C function library are available
      while you are programming in C++. You should look hard at the
      function library before defining your own function ? there??s a
      good chance that someone has already solved your problem for you,
      and probably given it a lot more thought and debugging.
      -->
      
      <para>
        Todas las funciones en la librería local de funciones de C están
        disponibles mientras se está programando en C++. Se debería
        buscar bien esta función en la librería antes de definir una
        propia ? hay muchas probabilidades de que alguien haya resuelto
        el problema antes, y probablemente haya dedicado mas tiempo
        pensando y depurando.
      </para>

      <!--
      A word of caution, though: many compilers include a lot of extra
      functions that make life even easier and are tempting to use, but
      are not part of the Standard C library. If you are certain you
      will never want to move the application to another platform (and
      who is certain of that?), go ahead ?use those functions and make
      your life easier. If you want your application to be portable, you
      should restrict yourself to Standard library functions. If you
      must perform platform-specific activities, try to isolate that
      code in one spot so it can be changed easily when porting to
      another platform. In C++, platform-specific activities are often
      encapsulated in a class, which is the ideal solution.
      -->

      <para>
        Una advertencia, igualmente: muchos compiladores incluyen muchas
        funciones extra que hacen la vida mucho mas fácil y son
        tentadoras de usar, pero no son parte de la libreria de C
        Standard. Si se está seguro de que jamás se deseará mover la
        aplicación a otra plataforma (¿y quién está seguro de ello?),
        adelante ?utilizad estas funciones y haceros la vida mas
        fácil. Si se desea que la aplicación pueda migrarse, se debería
        restringir el uso de funciones a las de la libreria Standard
        únicamente. Si se debe realizar actividades específicas de la
        plataforma, se debería intentar aislar este codigo de tal modo
        que pueda cambiarse fácilmente al ser migrado a otra
        plataforma. En C++, las actividades de una plataforma específica
        son a menudo encapsuladas en una clase, lo que es la solución
        ideal.
      </para>

      <!--
      The formula for using a library function is as follows: first,
      find the function in your programming reference (many programming
      references will index the function by category as well as
      alphabetically). The description of the function should include a
      section that demonstrates the syntax of the code. The top of this
      section usually has at least one #include line, showing you the
      header file containing the function prototype. Duplicate this
      #include line in your file so the function is properly
      declared. Now you can call the function in the same way it appears
      in the syntax section. If you make a mistake, the compiler will
      discover it by comparing your function call to the function
      prototype in the header and tell you about your error. The linker
      searches the Standard library by default, so that??s all you need
      to do: include the header file and call the function.
      -->
      
      <para>
        La fórmula para usar una librería de funciones es la siguiente:
        primero, encotrar la función en la referencia de programación
        (muchas referencias de programación ordenan las funciones por
        categoría antes que alfabéticamente). La descripción de la
        función debe incluir una sección que demuestre la sintaxis del
        codigo. La parte superior de esata sección tiene al menos una
        línea #include, mostrando el fichero principal que contiene el
        prototipo de función. Se debe duplicar este #include en vuestro
        fichero para que la función este correctamente declarada. Ahora
        se puede llamar la funcion de la misma manera que aparece en la
        sección de sintaxis. Si se comete un error, el compilador lo
        descubrirá comparando la llamada a la función con el prototipo
        de la cabecera e informará de dicho error. El linker busca la
        librería Standard por defecto, de modo que lo único que hay que
        hacer es: incluir el fichero de cabecera y llamar a la función.
      </para>

    </sect2>

    <sect2>
      <!-- Creating your own libraries with the librarian -->
      <title>Creación de librerías propias</title>

      <!--
      You can collect your own functions together into a library. Most
      programming packages come with a librarian that manages groups of
      object modules. Each librarian has its own commands, but the
      general idea is this: if you want to create a library, make a
      header file containing the function prototypes for all the
      functions in your library. Put this header file somewhere in the
      preprocessor??s search path, either in the local directory (so it
      can be found by #include ??header??) or in the include directory
      (so it can be found by #include <header>). Now take all the object
      modules and hand them to the librarian along with a name for the
      finished library (most librarians require a common extension, such
      as .lib or .a). Place the finished library where the other
      libraries reside so the linker can find it. When you use your
      library, you will have to add something to the command line so the
      linker knows to search the library for the functions you call. You
      must find all the details in your local manual, since they vary
      from system to system.  
      -->

      <para>
        Se pueden coleccionar funciones propias juntas en una
        librería. La mayoróa de paquetes de programación vienen con un
        bibliotecario que maneja grupos de modulos de objetos. Cada
        bibliotecario tiene sus propios comandos, pero la idea general
        es la siguiente: si se desea crear una librería, se debe hacer
        un fichero cabecera conteniendo los prototipos para todas las
        funciones de la librería. Hay que ubicar este fichero cabecera
        en alguna parte del path de búsqueda del preprocesador, ya sea
        en el directorio local (de modo que podrá ser encontrado
        mediante #include ??header??) o bien en el directorio include
        (por lo que se podrá encontrar mediante #include
        &lt;header&gt;). Luego se han de juntar todos los modulos de
        objetos y pasarlos al bibliotecaio junto con un nombre para la
        librería recién construida (la mayoría de los bibliotecrios
        requieren una extensión común, como por ejemplo .lib o .a). Se
        ha de ubicar la librería completa donde residen todas las demás,
        de manera que el linker sabrá buscar estas funciones en dicha
        librería al ser llamadas. Se pueden encontrar todos los detalles
        en el manual local, ya que pueden variar de un sistema a otro.
      </para>

     </sect2>
  </sect1>

  <sect1>
    <!-- Controlling execution  -->
    <title>Control de la ejecuión</title>

    <!--
    This section covers the execution control statements in C++. You
    must be familiar with these statements before you can read and write
    C or C++ code.
    -->

    <para>
      Esta sección trata las sentencias de control de ejecución en
      C++. Hay que familiarizarse con estas sentencias antes de que se
      pueda leer o escribir codigo C o C++.  
    </para>


    <!--
    C++ uses all of C??s execution control statements. These include
    if-else, while, do-while, for, and a selection statement called
    switch. C++ also allows the infamous goto, which will be avoided in
    this book.
    -->

    <para>
      C++ usa todas las sentencias de control de ejecución de C. Esto
      incluye if-else, do-while, for, y una sentencia de selección
      llamada switch. C++ también admite el infame goto, el cual será
      evitado en este libro.
    </para>
  
    <sect2>
      <title>Verdadero y falso</title>

      <!--
      All conditional statements use the truth or falsehood of a
      conditional expression to determine the execution path. An example
      of a conditional expression is A == B. This uses the conditional
      operator == to see if the variable A is equivalent to the variable
      B. The expression produces a Boolean true or false (these are
      keywords only in C++; in C an expression is ??true?? if it
      evaluates to a nonzero value). Other conditional operators are >,
      <, >=, etc. Conditional statements are covered more fully later in
      this chapter.
      -->

      <para>
        Todas las sentencias condicionales utilizan la veracidad o la
        falsedad de una expresión condicional para determinar el camino
        de ejecución. Un ejemplo de una expresión condicional es A ==
        B. Esto utiliza el operador condicional == para saber si la
        variable A es equivalente a la variable B. La expresión produce
        un Booleano true o false (esto son palabras clave solo en C++;
        en C una expresión es verdadera(true) si se contrasta contra un
        valor diferente de cero). Otros operadores condicionales son
        &gt;, &lt;, &gt;=, etc. Las sentencias condicional serán
        tratadas a fondo mas adelante en este capítulo.
      </para>
    </sect2>

    <sect2>
      <title>if-else</title>
      
      <!--
      The if-else statement can exist in two forms: with or without the
      else. The two forms are:
      -->

      <para>
        La sentencia if-else puede existir de dos formas: con o sin el
        else. Las dos formas son:        
      </para>

      <programlisting>
      if(expression) //expresión
      statement //sentencia
</programlisting>

<para>
      o
      </para>

      <programlisting>
      if(expression)
      statement
      else
      statement
</programlisting>

      <!--
      The ??expression?? evaluates to true or false. The ??statement??
      means either a simple statement terminated by a semicolon or a
      compound statement, which is a group of simple statements enclosed
      in braces. Any time the word ??statement?? is used, it always
      implies that the statement is simple or compound. Note that this
      statement can also be another if, so they can be strung together.
      -->

      <para>
        Se evalúa que la expresión sea true o false. La ??sentencia??
        puedeq ser una sentencia simple acabada en un punto y coma, o
        bien una sentencia compuesta, lo que no es más que un grupo de
        sentencias simples encerradas entre llaves. Siempre que se
        utiliza la palabra ??sentencia??, implica que la sentencia es
        simple compuesta. Tener en cuenta que dicha sentencia puede ser
        incluso otro if, por lo que pueden ir anidados.
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Ifthen.cpp"/>
</programlisting>


      <!--
      It is conventional to indent the body of a control flow statement
      so the reader may easily determine where it begins and ends[30].
      -->
    
      <para>
        Es costumbre indentar el cuerpo de una sentencia de flujo de
        control, de modo que el lector puede determinar fácilmente donde
        comienza y dónde acaba[30].
      </para>

    </sect2>
    <sect2>
      <title>while</title>
      
      <!--
      while, do-while, and for control looping. A statement repeats
      until the controlling expression evaluates to false. The form of a
      while loop is
      -->
      
      <para>
        Los bucles de control while, do-while, y for. Una sentencia se
        repite hasta que la expresión de control sea false. La
        estructura de un bucle while es:
      </para>

      <programlisting>
      while(expression) statement
</programlisting>

      <!--
      The expression is evaluated once at the beginning of the loop and
      again before each further iteration of the statement.
      -->

      <para>
        La expresión es evaluada una vez al comienzo del bucle y cada
        vez antes de cada iteración de la sentencia.
      </para>        

      
      <!--
      This example stays in the body of the while loop until you type
      the secret number or press control-C.
      -->

      <para>
        Este ejemplo se ejecuta el cuerpo del bucle while hasta que se
        introduzca el numero secreto o se presione control-C.
      </para>


<programlisting>
<xi:include parse="text" href="./code/C03/Guess.cpp"/>
</programlisting>


      <!--
      The while??s conditional expression is not restricted to a simple
      test as in the example above; it can be as complicated as you like
      as long as it produces a true or false result. You will even see
      code where the loop has no body, just a bare semicolon:
      -->

      <para>
        La expresión condicional del while no está restringida a una
        simple prueba como en el ejemplo anterior; puede ser tant
        complicada como se desee siempre y cuando se produzca un
        resultado true o false. También se puede ver el código sin
        curepo, solo un simple punto y coma:
      </para>

      <programlisting>
while(/* Do a lot here */)
 ;
</programlisting>

      <!--
      In these cases, the programmer has written the conditional
      expression not only to perform the test but also to do the work.
      -->

      <para>
        En estos casos, el programador ha escrito la expresión
        condicional no solo para realizar la evaluación, sino también
        para hacer el trabajo.
      </para>

    </sect2>
      
    <sect2>
      <title>do-while</title>

      <!--
      The form of do-while is
      -->

      <para>
        La estructura de do-while es
      </para>

      <programlisting>
do
statement
while(expression); 
</programlisting>

      <!--
      The do-while is different from the while because the statement
      always executes at least once, even if the expression evaluates to
      false the first time. In a regular while, if the conditional is
      false the first time the statement never executes.
      
      If a do-while is used in Guess.cpp, the variable guess does not
      need an initial dummy value, since it is initialized by the cin
      statement before it is tested:
      -->

      <para>
        El do-while es diferente del while ya que la sentencia siempre
        se ejecuta al menos una vez, aún si la expresión resulta false
        la primera vez. En un while regular, si la condicion es falsa la
        primera vez, la sentencia nunca se ejecuta.
      </para>

      <para>
        Si un do-while se utiliza en Guess.cpp, la variable guess no
        necesita un valor ficticio inicial, ya que se inicializa por la
        sentencia cin antes de que sea evaluada:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Guess2.cpp"/>
</programlisting>


      <!--
      For some reason, most programmers tend to avoid do-while and just
      work with while.
      -->
      
      <para>
        For alguna razón, la mayoría de los programadores tienden a
        evitar el do-while y se limitan a trabajar con el while.
      </para>
    </sect2>

    <sect2>
      <title>for</title>

      <!--
      A for loop performs initialization before the first
      iteration. Then it performs conditional testing and, at the end of
      each iteration, some form of ??stepping.?? The form of the for
      loop is:
      -->

      <para>
        Un bucle for realiza una inicialización antes de la primera
        iteración. Luego ejecuta una evaluación condicional y, al final
        de cada iteración, cierta forma de ??stepping??, avanzar paso a
        paso. La estructura del for es:
      </para>

      <programlisting>
for(initialization; conditional; step)
statement
</programlisting>

      <!--
      Any of the expressions initialization, conditional, or step may be
      empty. The initialization code executes once at the very
      beginning. The conditional is tested before each iteration (if it
      evaluates to false at the beginning, the statement never
      executes). At the end of each loop, the step executes.

      for loops are usually used for ??counting?? tasks:
      -->

      <para>
        Cualquiera de las expresiones de inicialización, condicional, o
        paso puede estar vacía. La inicialización se ejecuta una vez al
        principio de todo. La expresión condicional se evalúa antes de
        cada iteración (si se evalúa a false en desde el principio, el
        cuerpo del bucle nunca llega a ejecutarse). Al final de cada
        iteración del bucle, el step se ejecuta.
      </para>

      <para>
        Los bucles for son generalmente utilizados para tareas de
        ??contar??:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Charlist.cpp"/>
</programlisting>

      <!--
      You may notice that the variable i is defined at the point where
      it is used, instead of at the beginning of the block denoted by
      the open curly brace ??{??. This is in contrast to traditional
      procedural languages (including C), which require that all
      variables be defined at the beginning of the block. This will be
      discussed later in this chapter.
      -->

      <para>
        Puede ocurrir que la variable i sea definida en el punto en el
        que es utilizada, en vez de al principio del bloque delimitado
        por la apertura de la llave ??{??. Esto difiere de los lenguajes
        procedurales tradicionales (incluyendo C), los cuales requieren
        que todas ls variables sean definidas al principio del
        bloque. Esto será discutido mas adelante en este capítulo.
      </para>
    </sect2>

    <sect2>
      <!-- The break and continue keywords -->
      <title>Las pasabras reservadas <kw>break</kw> y <kw>continue</kw></title>

      <!--
      Inside the body of any of the looping constructs while, do-while,
      or for, you can control the flow of the loop using break and
      continue. break quits the loop without executing the rest of the
      statements in the loop. continue stops the execution of the
      current iteration and goes back to the beginning of the loop to
      begin a new iteration.
      -->

      <para>
        Dentro del cuerpo de cualquiera de las estructuras de bucle
        while, do-while, o for, se puede controlar el flujo del bucle
        utilizando break y continue. Break abandona el bucle sin
        ejecutar el resto de las sentencias en el bucle. continue para
        la ejecución de la iteración actual y vuelve al principio del
        bucle para comenzar una nueva iteración.
      </para>

      <!-- 
      As an example of break and continue, this program is a very
      simple menu system:
      --> 

      <para>
        A modo de ejemplo de break y continue, este programa es un menu
        de sistema muy simple:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Menu.cpp"/>
</programlisting>

      <!--
      If the user selects ??q?? in the main menu, the break keyword is
      used to quit, otherwise the program just continues to execute
      indefinitely. After each of the sub-menu selections, the continue
      keyword is used to pop back up to the beginning of the while loop.
      -->

      <para>
        Si el usuario selecciona ??q?? en el menu principal, la palabra
        clave break se utiliza para salir, de otro modo, el programa
        continua ejecutandose indefinidamente. Luego de cada selección
        de sub-menu, la palabra clave continue es usada para volver
        atrás hasta el comienzo del bucle while.
      </para>

      <!--
      The while(true) statement is the equivalent of saying ??do this
      loop forever.?? The break statement allows you to break out of
      this infinite while loop when the user types a ??q.??
      -->

      <para>
        El while(true) es el equivalente a decir ??haz este bucle para
        siempre??.  La sentencia break permite romper este bucle
        infinito cuando el usuario teclea ??q??.
      </para>

    </sect2>

    <sect2>
      <title>switch</title>

      <!--
      A switch statement selects from among pieces of code based on the
      value of an integral expression. Its form is:
      -->

      <para>
        La sentencia switch selecciona de un grupo de codigos basados en
        el valor de una expression integral. Su estructura es:
      </para>

      <programlisting>
switch(selector) {
case integral-value1 : statement; break;
case integral-value2 : statement; break;
case integral-value3 : statement; break;
case integral-value4 : statement; break;
case integral-value5 : statement; break;
    (...)
default: statement;
} 
</programlisting>

      <!--
      Selector is an expression that produces an integral value. The
      switch compares the result of selector to each integral value. If
      it finds a match, the corresponding statement (simple or compound)
      executes. If no match occurs, the default statement executes.
      -->
      
      <para>
        Selector es una expression que produce un valor integral. El
        switch compará el resultado de selector para cada valor
        integral. Si encuentra una coincidencia, se ejecutará la
        sentencia correspondiente (ya sea simple o compuesta. Si no se
        encuentra ninguna coincidencia, la sentencia default se
        ejecutará.
      </para>

      <!--
      You will notice in the definition above that each case ends with a
      break, which causes execution to jump to the end of the switch
      body (the closing brace that completes the switch). This is the
      conventional way to build a switch statement, but the break is
      optional. If it is missing, your case ??drops through?? to the one
      after it. That is, the code for the following case statements
      execute until a break is encountered. Although you don??t usually
      want this kind of behavior, it can be useful to an experienced
      programmer.
      -->

      <para>
        Se puede obeservar en la definición anterior que cada case acaba
        con un break, lo que causa que la ejecución salte hasta el final
        del cuerpo del switch (la llave final que completa el
        switch). Esta es la forma convencional de construir una
        sentencia switch, pero la palabra break es opcional. Si no se
        indica, el case que se ha cumplido ??cae?? al siguiente de la
        lista. Esto significa, que el código del siguiente case, se
        ejecutara hasta que un break sea encontrado. Aunque normalmente
        no se desea este tipo de comportamiento, puede ser de ayuda para
        un programador experimentado.
      </para>

      <!--
      The switch statement is a clean way to implement multi-way
      selection (i.e., selecting from among a number of different
      execution paths), but it requires a selector that evaluates to an
      integral value at compile-time. If you want to use, for example, a
      string object as a selector, it won??t work in a switch
      statement. For a string selector, you must instead use a series of
      if statements and compare the string inside the conditional.
      -->

      <para>
        La sentencia switch es una manera limpia de implementer una
        selección multi-modo (por ejemplo, seleccionando de entre un
        numero de diferentes paths de ejecución), pero require un
        selector que evalue esto contra un valor integral en el momento
        de la compilación. Si se quisiera utilizar, por ejemplo un
        objeto de tipo string como selector, no funcionaría en una
        sentencia switch. Para un selector de tipo string, se debe
        utilizar en cambio una serie de sentencias if y comparar la
        string dentro de la condición.
      </para>

      <!--
      The menu example shown above provides a particularly nice example
      of a switch:
      -->

      <para>
        El ejemplo del menu demostrado anteriormente prove un ejemplo
        particularmente fácil de un switch:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Menu2.cpp"/>
</programlisting>

      <!--
      The quit flag is a bool, short for ??Boolean,?? which is a type
      you??ll find only in C++. It can have only the keyword values true
      or false. Selecting ??q?? sets the quit flag to true. The next
      time the selector is evaluated, quit == false returns false so the
      body of the while does not execute.
      -->

      <para>
        El flag quit es un bool, abreviatura para ??Boolean??, el cual
        es un tipo que solo se encuentra en C++. Puede tener unicamente
        los valores clave true o false. Seleccionando ??q?? le da el
        valor true al flag quit. La próxima vez que el selector sea
        evaluado, quit == false retornara false de modo que el cuerpo
        del bucle while no se ejecutará.
      </para>
    </sect2> 

    <sect2>
      <!-- Using and misusing goto -->
      <title>Uso y maluso de <kw>goto</kw></title>
      
      <!--
      The goto keyword is supported in C++, since it exists in C. Using
      goto is often dismissed as poor programming style, and most of the
      time it is. Anytime you use goto, look at your code and see if
      there??s another way to do it. On rare occasions, you may discover
      goto can solve a problem that can??t be solved otherwise, but
      still, consider it carefully. Here??s an example that might make a
      plausible candidate:
      -->

      <para>
        La palabra clave goto es soportada en C++, ya que existe en
        C. El uso de goto es a menudo calificado de un estilo de
        programación pobre, y la mayor parte del tiempo lo es. Siempre
        que se utilice goto, se debe reviser bien el código par aver si
        hay alguna otra manera de hacerlo. En raras ocasiones, goto
        puede resolvr un problema que no puede ser resuelto de otra
        manera, pero, aún así, se debe considerer cuidadosamente. A
        continuación hay un ejemplo que puede ser un plausible
        candidato:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/gotoKeyword.cpp"/>
</programlisting>

      <!--
      The alternative would be to set a Boolean that is tested in the
      outer for loop, and then do a break from the inner for
      loop. However, if you have several levels of for or while this
      could get awkward.
      -->
     
      <para>
        La alternativa sería dar valor a un booleano que sea evaluado en
        el for externo, y luego hacer un break desde el for interno. De
        todos modos, si hay demasiados niveles de for o while esto puede
        ser tedioso.
      </para>
    </sect2>

    <sect2>
      <title>Recursividad</title>

      <!--
      Recursion is an interesting and sometimes useful programming
      technique whereby you call the function that you??re in. Of
      course, if this is all you do, you??ll keep calling the function
      you??re in until you run out of memory, so there must be some way
      to ??bottom out?? the recursive call. In the following example,
      this ??bottoming out?? is accomplished by simply saying that the
      recursion will go only until the cat exceeds ??Z??:[31]
      -->
      
      <para>
        La recursividad es una interesante y a veces útil técnica de
        programación, en donde se llama a la función dentro de la que se
        está. Por supuesto, si es todo lo que hace, se estaría llamando
        a la función hasta que se acabase la memoria de ejecución, de
        modo que debe existi una manera de ??escapase?? de la llamada
        recursiva. En el siguiente ejemplo, esta ??escapada?? se
        consigue simplemente diciendo que la recursión solo continuará
        hasta que cat exceda ??Z??: [31]
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/CatsInHats.cpp"/>
</programlisting>


      <!--
      In removeHat(), you can see that as long as cat is less than ??Z??,
      removeHat( ) will be called from within removeHat( ), thus
      effecting the recursion. Each time removeHat( ) is called, its
      argument is one greater than the current cat so the argument keeps
      increasing.
      -->

      <para>
        En removeHat( ), se puede ver que mientras cat sea menor que
        ??Z??, removeHat( ) se llamará a sí misma desde dentro, así
        efectuando la recursividad. Cada vez que removeHat( ) es
        llamada, el argumento es una vez mas grande que el actual cat de
        modo que el argumento continua aumentando.
      </para>

      <!--
      Recursion is often used when evaluating some sort of arbitrarily
      complex problem, since you aren??t restricted to a particular
      ??size?? for the solution ? the function can just keep recursing
      until it??s reached the end of the problem.
      -->

      <para>
        La recursividad es amenudo utilizada cuando se evalua algun tipo
        de problema arbitrariamente complejo, ya que no se restringe a
        un nigún tamaño en concreto para la solución ? la function puede
        simplemente efecutar la recursividad hasta que se haya alcanzado
        el final del problema.
      </para>
    </sect2>   
  </sect1>

  <sect1>
    <!-- Introduction to operators -->
    <title>Introducción a los operadores</title>

    <!--
    You can think of operators as a special type of function (you'll
    learn that C++ operator overloading treats operators precisely that
    way). An operator takes one or more arguments and produces a new
    value. The arguments are in a different form than ordinary function
    calls, but the effect is the same.
    -->

    <para>
      Se puede pensar en un operador como un tipo de función especial
      (aprenderá que en C++ la sobrecarga de operadores los trata
      precísamente de esa forma). Un operador recibe uno o más
      argumentos y produce un nuevo valor. Los argumentos se pasan de
      una manera diferente que en las llamadas a funciones normales,
      pero el efecto es el mismo.
    </para>

    <!--
    From your previous programming experience, you should be reasonably
    comfortable with the operators that have been used so far. The
    concepts of addition (+), subtraction and unary minus (-),
    multiplication (*), division (/), and assignment(=) all have
    essentially the same meaning in any programming language. The full
    set of operators is enumerated later in this chapter.
    -->
    
    <para>
      De su experiencia previa en programación, debe estar
      razonablemente cómodo con los operadores que han sido
      utilizados. Los conceptos de adición (+), substracción y resta
      unaria (-), multiplicación (*), división (/), y asignación (=)
      tienen todos el mismo significado en cualquier lenguaje de
      programación. Todo el grupo de operadores se enumera más
      adelante en este capítulo.
    </para>
      
    <sect2>
      <!-- Precedence -->
      <title>Precedencia</title>

      <!--
      Operator precedence defines the order in which an expression
      evaluates when several different operators are present. C and C++
      have specific rules to determine the order of evaluation. The
      easiest to remember is that multiplication and division happen
      before addition and subtraction.  After that, if an expression
      isn't transparent to you it probably won't be for anyone reading
      the code, so you should use parentheses to make the order of
      evaluation explicit. For example:
      -->

      <para>
	La precedencia de operadores define el orden en el cual una
	expresión se evalúa cuando varios diferentes operadores son
	presentados. C y C++ tienen reglas específicas para determinar
	el orden de evaluación. Lo más fácil de recordar es que la
	multiplicación y la división se ejecutan antes que la adición y
	la substracción. Luego, si una expresión no es transparente al
	programador que la escribe, probablemente lo será para nadie que
	lea el código, de modo que se deben usar paréntesis para hacer
	el explícito el orden de la evaluación. Por ejemplo:
      </para>

      <para>
             A = X + Y - 2/2 + Z;
      </para>

      <!--
      evaluating the result with X = 1, Y = 2, and Z = 3.)
      -->

      <para>
	(Intente evaluar el resultado con X =1, Y = 2, y Z = 3.)
      </para>



    </sect2>
    
    <sect2>
      <!-- Auto increment and decrement -->
      <title>Auto incremento y decremento</title>


      <!--
      C, and therefore C++, is full of shortcuts. Shortcuts can make
      code much easier to type, and sometimes much harder to
      read. Perhaps the C language designers thought it would be easier
      to understand a tricky piece of code if your eyes didn't have to
      scan as large an area of print.
      -->

      <para>
	C, y por tanto C++, está lleno de atajos. Los atajos pueden hacer
	el código mucho mas fácil de escribir, y a veces más difícil de
	leer. Quizás los diseñadores del lenguaje C pensaron que sería
	más fácil entender un trozo complicado de código si los ojos no
	tienen que leer una larga línea de letras.
      </para>


      <!--
      One of the nicer shortcuts is the auto-increment and
      auto-decrement operators. You often use these to change loop
      variables, which control the number of times a loop executes.
      -->

      <para>
	Uno de los mejores atajos son los operadores de auto-incremento
	y auto-decremento. Se utilizan a menudo para cambiar variables
	en un bucle, las cuales controlan el número de veces que se
	ejecuta un bucle.
      </para>


      <!--
      The auto-decrement operator is '- -' and means "decrease by one
      unit."  The auto-increment operator is '++' and means "increase by
      one unit." If A is an int, for example, the expression ++A is
      equivalent to (A = A + 1). Auto-increment and auto-decrement
      operators produce the value of the variable as a result. If the
      operator appears before the variable, (i.e., ++A), the operation
      is first performed and the resulting value is produced. If the
      operator appears after the variable (i.e. A++), the current value
      is produced, and then the operation is performed. For example:
      -->

      <para> 
	El operador de auto-decremento es '--' y significa
	"decrementar de a una unidad". El operador de auto-incremento es
	'++' y significa "incrementar de a una unidad". Si es un entero,
	por ejemplo, la expresión ++A es equivalente a (A = A + 1). Los
	operadores de auto-incremento o auto-decremento producen el
	valor de la variable como resultado. Si el operador aparece
	antes de la variable (p.e, ++A), la operación se ejecuta primero
	y después se produce el valor resultante. Si el operador aparece
	a continuación de la variable (p.e, A++), primero se produce el
	valor actual, y luego se realiza la operación. Por ejemplo:
      </para>


<programlisting>
<xi:include parse="text" href="./code/C03/AutoIncrement.cpp"/>
</programlisting>

      <!--
      If you've been wondering about the name "C++," now you understand. It
      implies "one step beyond C."
      -->

      <para>
	Si se ha estado preguntando acerca del nombre
	<quote>C++</quote>, ahora lo entiendes. Significa "un paso más
	allá de C".
      </para>

    </sect2>
  </sect1>    



  <sect1>
    <title>Introducción a los tipos de datos</title>
    
    <!--
    Data types define the way you use storage (memory) in the programs
    you write. By specifying a data type, you tell the compiler how to
    create a particular piece of storage, and also how to manipulate
    that storage.
    -->

    <para>
      Los tipos de datos definen el modo en que se usa el espacio
      (memoria) en los programas que escribes.  Especificando un tipo de
      datos, estás indicando al compilador como crear un espacio en
      particular, y también como manipular este espacio.
    </para>

    <!--
    Data types can be built-in or abstract. A built-in data type is one
    that the compiler intrinsically understands, one that is wired
    directly into the compiler. The types of built-in data are almost
    identical in C and C++. In contrast, a user-defined data type is one
    that you or another programmer create as a class. These are commonly
    referred to as abstract data types. The compiler knows how to handle
    built-in types when it starts up; it "learns" how to handle abstract
    data types by reading header files containing class declarations
    (you'll learn about this in later chapters).
    -->

    <para>
      Los tipos de datos pueden ser genéricos del lenguaje o
      abstractos. Un tipo de dato genérico es intrínsecamente
      comprendido por el compilador, es introducido directamente al
      compilador. Estos tipos de datos son casi identicos en C y C++. En
      contraste, un tipo de datos definido por el usuario es aquel que
      tu o cualquier otro programador crean comouna clase. Estos son
      comunmente referidos como tipos de datos abstractos. El
      commpilador sabe como manejar tipos genéricos cuando arranca;
      "aprende" como manejar tipos de datos abstractos leyendo los
      ficheros de cabeceras que contienen las declaraciones de las
      clases (aprenderás sobre esto en los siguientes capítulos). 
    </para>



    <sect2>
      <title>Tipos predefinidos básicos</title>

      <!--
      The Standard C specification for built-in types (which C++
      inherits) doesn't say how many bits each of the built-in types
      must contain. Instead, it stipulates the minimum and maximum
      values that the built-in type must be able to hold. When a machine
      is based on binary, this maximum value can be directly translated
      into a minimum number of bits necessary to hold that
      value. However, if a machine uses, for example, binary-coded
      decimal (BCD) to represent numbers, then the amount of space in
      the machine required to hold the maximum numbers for each data
      type will be different. The minimum and maximum values that can be
      stored in the various data types are defined in the system header
      files limits.h and float.h (in C++ you will generally #include
      climits> and cfloat> instead).
      -->

      <para>
        La especificación de Standard C para los tipos genericos (los
        cuales hereda C++) no indica cuantos bits debe contenter cada
        uno de estos. En vez de esto, estipula el minimo y maximo valor
        que dicho tipo genérico es capaz de almacenar. Cuando una
        máquina se basa en sistema binario, este valor máximo puede ser
        directamente traducido a un numero minimo necesario de bits para
        alojar este valor. De todos modos, si una maquina usar, por
        ejemplo, el codigo binario decimal (BCD) para representar los
        numeros, entonces el espacio en la maquina requerido para alojar
        el maximo numero para cada tipo de datos sera diferente. El
        minimo y maximo valor que puede ser almacenado en los distintos
        tipos de datos se definen en los ficheros de cabeceras del
        sistema limits.h y float.h (en C++ escribirias generalmente
        #include &lt;climits> y &lt;cfloat> en su lugar).
      </para>

      
      <!--
      C and C++ have four basic built-in data types, described here for
      binary-based machines. A char is for character storage and uses a
      minimum of 8 bits (one byte) of storage, although it may be
      larger. An int stores an integral number and uses a minimum of two
      bytes of storage. The float and double types store floating-point
      numbers, usually in IEEE floating-point format. float is for
      single-precision floating point and double is for double-precision
      floating point.
      -->
      
      <para>
        C y C++ tienen cuatro tipos genericos básicos, describidos aqui
        para maquinas basadas en sistema binario. Un chat es para
        almacenar carácteres y utiliza un mínimo de 8 bits (un byte) de
        espacio, aunque puede ser mas largo. Un int almacena un numero
        entero y utiliza un minimo de dos bytes de espacio. Los tipos
        float y el double almacenan numeros con coma flotante,
        usualmente en formato de coma flotante IEEE. el float es para
        precision simple de la coma y el double es para la doble
        precision de la coma.
      </para>


      <!-- 
      As mentioned previously, you can define variables anywhere in
      a scope, and you can define and initialize them at the same
      time. Here's how to define variables using the four basic data
      types:
      -->

      <para>
        Como hemos mencionado previamente, puedes degfinir variables en
        cualquier sitio en un ámbito determinado, y puedes definirlas e
        inicializarlas al mismo tiempo.  A continuación se indica como
        definir variables utilizando los cuatro tipos básicos de datos
      </para>

      <programlisting>
        //: C03:Basic.cpp
</programlisting>


      <!-- 
      The first part of the program defines variables of the four
      basic data types without initializing them. If you don't
      initialize a variable, the Standard says that its contents are
      undefined (usually, this means they contain garbage). The second
      part of the program defines and initializes variables at the same
      time (it's always best, if possible, to provide an initialization
      value at the point of definition). Notice the use of exponential
      notation in the constant 6e-4, meaning "6 times 10 to the minus
      fourth power."
      -->

      <para>
        La primera parte del programa define variables de los cuatro
        tipos básicos sin inicializarlas. Si no inicializas una
        variable, el Standard dice que su contenido es indefinido
        (normalmente, esto significa que contienen basura). La segunda
        parte del programa define e inicializa viariables al mismo
        tiempo (Siempre es mejor, si es posible, proveer un valor
        inicial al momento de la definición). Notar que el uso de
        notación exponencial en la contante 6e-4, significa "6 veces 10
        para el menor cuarto poder?????????????????"
      </para>

    </sect2>

    <sect2>
      <title>booleano, true y false</title>

      <!--
      Before bool became part of Standard C++, everyone tended to use
      different techniques in order to produce Boolean-like
      behavior. These produced portability problems and could introduce
      subtle errors.
      -->

      <para>
        Antes de que bool se convirtiese en parte del Standard C++,
        todos tendiand a utilizar diferentes técnicas para producir
        comportamientos similares a los booleanos. Esto produjo problemas
        de portabilidad y podían acarrear errores subyacentes.
      </para>


      <!--
      The Standard C++ bool type can have two states expressed by the
      built-in constants true (which converts to an integral one) and
      false (which converts to an integral zero). All three names are
      keywords. In addition, some language elements have been adapted:
      -->

      <para>
        El tipo bool de Standard C++ puede tener dos estados expresados
        por las constantes genéricas true (lo que lo convierte en un uno
        entero) y false (lo que lo convierte a un zero entero). Estos
        tres nombres son palabras clave. En suma, algunos elementos del
        lenguaje han sido adaptados:
      </para>

      <!-- [FIXME: tabla de booleanos] -->
      

      <!--
      Because there's a lot of existing code that uses an int to
      represent a flag, the compiler will implicitly convert from an int
      to a bool (nonzero values will produce true while zero values
      produce false). Ideally, the compiler will give you a warning as a
      suggestion to correct the situation.
      -->

      <para>
        Ya que hay mucho código existente que utiliza un int para
        representar un flag (opción), el compilador lo convertira
        implicitamente de un int a un bool (los valores diferentes de
        cero produciran el true, mientras que los valores cero,
        produciran false). Idealmente, el compilador te dará in warning
        a modo de aviso para corregir la situacion.
      </para>


      <!--
      An idiom that falls under "poor programming style" is the use of
      ++ to set a flag to true. This is still allowed, but deprecated,
      which means that at some time in the future it will be made
      illegal. The problem is that you're making an implicit type
      conversion from bool to int, incrementing the value (perhaps
      beyond the range of the normal bool values of zero and one), and
      then implicitly converting it back again.
      -->

      <para>
        Al que es calificado de "estilo pobre de programacion" es el uso
        de ++ para indicar que un flag es verdadero. Esto aún se
        permite, pero no es aprobado, lo que significa que alguna vez en
        el futuro será ilegal. El problema es que estás haciendo una
        conversión implicita de un bool a un entero, incrementando el
        valor (a lo mejor mas alla del rango cero y uno normal del
        booleano), y luego implicitamente convirtiendolo otra vez a
        bool.
      </para>


      <!-- 
      Pointers (which will be introduced later in this chapter)
      will also be automatically converted to bool when necessary.  
      -->

      <para>
        Los punteros (los cuales van a ser descriptos mas adelante en este
        capitulo) tambien seran automaticamente convertidos a booleano
        cuando sea necesario.
      </para>
    </sect2>

    <sect2>
      <title>Especificadores</title>
      
      <!--
      Specifiers modify the meanings of the basic built-in types and
      expand them to a much larger set. There are four specifiers: long,
      short, signed, and unsigned.
      -->

      <para>
        Los especificadores modifican los significados de los tipos genéricos
        basicos y los expanden a un rango mas grande. Hay cuatro
        especificadores: long, short, signed y unsigned.
      </para>

      <!--
      long and short modify the maximum and minimum values that a
      data type will hold. A plain int must be at least the size of a
      short. The size hierarchy for integral types is: short int, int,
      long int. All the sizes could conceivably be the same, as long as
      they satisfy the minimum/maximum value requirements. On a machine
      with a 64-bit word, for instance, all the data types might be 64
      bits.
      -->

      <para>
        long y short modifican los valores maximos y minumos que un tipo
        de datos almacenara. Un int plano debe al menos tener el tamaño
        de un short. La jerarquía de tamaños para tipos integrales es:
        short int, int , long int.  Todos pueden ser el mismo tamaño ,
        siempre y cuando satisfagan los requerimentos de
        minimo/maximo. En una maquina donde una palabra mide 64 bits,
        por defecto, todos los tipos de datos deben medir 64 bits
        minimo.
      </para>


      <!--
      The size hierarchy for floating point numbers is: float, double,
      and long double. "long float" is not a legal type. There are no
      short floating-point numbers.
      -->

      <para>
        La jerarquía de tamaño para los numeros con coma flotante es:
        float, double, y long double. "long float" no es un tipo legal. No
        hay numeros con coma flotantes de tamaño short.
      </para>

      <!--
      The signed and unsigned specifiers tell the compiler how to
      use the sign bit with integral types and characters
      (floating-point numbers always contain a sign). An unsigned number
      does not keep track of the sign and thus has an extra bit
      available, so it can store positive numbers twice as large as the
      positive numbers that can be stored in a signed number. signed is
      the default and is only necessary with char; char may or may not
      default to signed. By specifying signed char, you force the sign
      bit to be used.
      -->

      <para>
        Los especificadores signed y unsigned, indican al compilador
        como utilizar el bit del signo con los tipos integrales y los
        caracteres (los numeros de coma flotante siempre contienen un
        signo). Un numero unsigned no guarda el valor del signo y además
        tiene un bit extra disponible, de modo que puede guardar el
        doble de numeros positivos que pueden guardarse en un numero
        signed. signed es dado por defecto y solo es necesario con chat,
        char puede ser o no por defecto un signed. Especificando signed
        chat, estás forzando a que se utilice el bit del signo.
      </para>

      <!--
      The following example shows the size of the data types in bytes by
      using the sizeof operator, introduced later in this chapter:
      -->

      <para>
        El siguiente ejemplo muestra el tamaño de los tipos de datos en
        bytes utilizando el operador sizeof, descripto mas adelante en
        ese capítulo:
      </para>
        
      <programlisting>
        //: C03:Specify.cpp
</programlisting>

      <!--
      Be aware that the results you get by running this program will
      probably be different from one machine/operating system/compiler
      to the next, since (as mentioned previously) the only thing that
      must be consistent is that each different type hold the minimum
      and maximum values specified in the Standard.
      -->

      <para>
        Ten en cuenta que los resultados que consigues ejecutando este
        programa pueden ser probablemente diferentes de una
        maquina/sistema operativo / compilador a otro, ya que (como
        mencionamos anteriormente) lo único que ha de ser consistente es
        que cada tipo diferente almacene los valores minimos y máximos
        especificados en el Standard.
      </para>

      <!--
      When you are modifying an int with short or long, the keyword int
      is optional, as shown above.
      -->

      <para>
        Cuando está modificando un int con short o long, la palabra
        clave int es opcional, como se muestra a
        continuacion.

      </para> 
    </sect2>
      

    <sect2>
      <!-- Introduction to pointers -->
      <title>Introducción a punteros</title>


    
    <!--
    Whenever you run a program, it is first loaded (typically from disk)
    into the computer's memory. Thus, all elements of your program are
    located somewhere in memory. Memory is typically laid out as a
    sequential series of memory locations; we usually refer to these
    locations as eight-bit bytes but actually the size of each space
    depends on the architecture of the particular machine and is usually
    called that machine's word size. Each space can be uniquely
    distinguished from all other spaces by its address. For the purposes
    of this discussion, we'll just say that all machines use bytes that
    have sequential addresses starting at zero and going up to however
    much memory you have in your computer.
    -->    
 
      <para>
        Siempre que se ejecuta un programa, se carga al principio
        (tipicamente desde el disco duro) a la memoria del ordenador. De
        este modo, todos los elementos del programa se ubican en algun
        sitio en la memoria. La memoria es representada normalmente como
        series secuenciales de localización de memoria; normalmente se
        hace referencia a estas localizaciones como bytes de ocho bits,
        pero actualmente el tamaño de cada espacio depende de la
        arquitectura de la máquina en particular y es llamada usualmente
        tamaño de palabra de dicha máquina. Cada espacio puede ser
        distinguido unívocamente de todos los demás espacios por su
        dirección. Para este tema en particular, se establecerá que
        todas las máquinas usan bytes que tienen direcciones
        secuenciales, comenzando en cero y subiendo hasta cuanta memoria
        posea la máquina.
      </para>

      <!--
      Since your program lives in memory while it's being run, every element 
      of your program has an address. Suppose we start with a simple program:
      -->

      <para>
      Debido a que el programa reside en memoria mientras está siendo
      ejecutado, cada elemento de dicho programa tiene una dirección. Se
      supone el caso en el que se ejecuta un programa simple:
      </para>

      <programlisting>
//: C03:YourPets1.cpp
</programlisting>


      <!--
      Each of the elements in this program has a location in storage when the 
      program is running. Even the function occupies storage. As you'll see,
      it turns out that what an element is and the way you define it usually
      determines the area of memory where that element is placed.
      -->
         
      <para>
        Cada uno de los elementos de este programa tiene una
        localización en el espacio cuando el programa se está
        ejecutando. Incluso las funciones ocupan espacio. Como se verá,
        se da por sentado que lo que el tipo de un elemento y la forma
        en que se define normalmente determina el área de memoria donde
        dicho elemento es ubicado.
      </para>

      
      <!--
      There is an operator in C and C++ that will tell you the address
      of an element. This is the '&amp;' operator. All you do is precede
      the identifier name with '&' and it will produce the address of
      that identifier.  YourPets1.cpp can be modified to print out the
      addresses of all its elements, like this: 
      -->
   
      <para>
      Hay un operador en C y C++ que aloja la dirección de un
      elemento. Este es el operador '&amp;'. Solo hay que anteponer el
      operador '&amp;' antes del nombre identificador y se obtendra la
      dirección de dicho identificador. YourPets1.cpp se puede modificar
      para mostrar las direcciones de todos sus elementos, del siguiente
      modo:
      </para>

      <programlisting>
      //: C03:YourPets2.cpp
</programlisting>
      
      <!--
      The (long) is a cast. It says "Don't treat this as if it's normal
      type, instead treat it as a long." The cast isn't essential, but
      if it wasn't there, the addresses would have been printed out in
      hexadecimal instead, so casting to a long makes things a little
      more readable.
      -->
      
      <para>
      El (loqng) es una conversión. Indica "No tratar como su tipo
      normal, sino como un long". La conversión no es escencial, pero si
      no existiese, las direcciones habrían sido mostradas en
      hexadecimal, de modo que la conversión a long hace las cosas mas
      legibles.
      </para>

      <!--
      The results of this program will vary depending on your computer, OS, 
      and all sorts of other factors, but it will always give you some
      interesting insights. For a single run on my computer, the results
      looked like this:
      -->

      <para>
      Los resultados de este programa variarán dependiendo deñ
      ordenador, del sistema operativo, y de muchos otros tipos de
      factores, pero siempre darán un resultado interesante. Con una
      simple ejecución en un ordenador, los resultados son como estos:
      </para>

      <programlisting>
       f(): 4198736
               dog: 4323632
               cat: 4323636
               bird: 4323640
               fish: 4323644
               i: 6684160
               j: 6684156
               k: 6684152
</programlisting>
        
      <!-- 
      You can see how the variables that are defined inside main( )
      are in a different area than the variables defined outside of
      main( ); you'll understand why as you learn more about the
      language. Also, f( ) appears to be in its own area; code is
      typically separated from data in memory.
      -->      
   
      <para>
      Se puede apreciar como las variables que se han definido dentro de
      main() estan en un área distinta que las variables definidas fuera
      del main(); se entenderá el porque cuando se profundise mas en el
      lenguaje. Además, f() parece estar en su propia area; el código
      normalmente se separa del resto de la información en memoria.
      </para>

      <!-- 
      Another interesting thing to note is that variables defined
      one right after the other appear to be placed contiguously in
      memory. They are separated by the number of bytes that are
      required by their data type.  Here, the only data type used is
      int, and cat is four bytes away from dog, bird is four bytes away
      from cat, etc. So it would appear that, on this machine, an int is
      four bytes long.
      -->

      <para>
      Otra cosa a tener en cuenta es que las variables definidas una a
      continuación de la otra parecen estar ubicadas contiguamente en
      memoria. Estas estan separadas por el numero de bytes que son
      requeridos por su tipo de datos. En este programa el único tipo de
      datos utilizado es el int, y la variable cat esta separada de dog
      por cuatro bytes, bird esta separada por cuatro bytes de cat,
      etc. De modo que en el ordenador en que ha sido ejecutado el
      programa, un entero mide cuatro bytes.
      </para>

      <!--
      Other than this interesting experiment showing how memory is
      mapped out, what can you do with an address? The most important
      thing you can do is store it inside another variable for later
      use. C and C++ have a special type of variable that holds an
      address. This variable is called a pointer.
      -->         

      <para>
      ¿Qué se puede hacer con las direcciones de memoria, además de este
      interesante experimento de mostrar cuanta memoria es ocupada? Lo
      más importante que se puede hacer es guardarlo dentro de otra
      variable para su uso posterior. C y C++ tienen un tipo de variable
      especial que guarda una dirección. Esta variable se llama puntero.
      </para>

      <!--
      The operator that defines a pointer is the same as the one used for 
      multiplication: '*'. The compiler knows that it isn't multiplication
      because of the context in which it is used, as you will see.
      -->         

      <para>
      El operador que define un puntero es el mismo que se utiliza para
      la multiplicación: '*'. El compilador sabe que no es una
      multiplicación debido al contexto en el que es utilizado, como se
      verá.
      </para>

      <!--
      When you define a pointer, you must specify the type of variable
      it points to. You start out by giving the type name, then instead
      of immediately giving an identifier for the variable, you say
      "Wait, it's a pointer" by inserting a star between the type and
      the identifier. So a pointer to an int looks like this:
      -->

      <para>
      Cuando se define un puntero, se debe especificar el tipo de
      variable al que apunta. Se comienza dando el nombre de dicho tipo;
      a continuación, en lugar de dar un identificador para la variable
      inmediatamente, se indica que es un puntero insertando un
      asterisco entre el tipo y el identificador. De modo que un puntero
      para un int tiene este aspecto:
      </para>
      
      <programlisting>
      int* ip; // ip points to an int variable
</programlisting>        

      <!--
      The association of the '*' with the type looks sensible and reads
      easily, but it can actually be a bit deceiving. Your inclination
      might be to say "intpointer" as if it is a single discrete
      type. However, with an int or other basic data type, it's possible
      to say:
      -->

      <para>
      La asociación de '*' con el tipo parece sensible y de fácil
      legibilidad, pero puede ser un poco confusa. La tendencia podría
      ser de decir "intpuntero" como un si fuese un tipo simple. De
      todas manera con un int u otro tipo básico de datos, es posible
      decir:
      </para>

      <programlisting>
       int a, b, c;
</programlisting>        

      <!--
      whereas with a pointer, you'd like to say:
      -->
      
      <para>
      así como con un puntero se diría:
      </para>

      <programlisting>
   int* ipa, ipb, ipc;
</programlisting>        

      <!--
      C syntax (and by inheritance, C++ syntax) does not allow such
      sensible expressions. In the definitions above, only ipa is a
      pointer, but ipb and ipc are ordinary ints (you can say that "*
      binds more tightly to the identifier"). Consequently, the best
      results can be achieved by using only one definition per line; you
      still get the sensible syntax without the confusion:
      -->

      <para>
      La sintaxis de C (y por herencia, la de C++) no permite
      expresiones tan sensibles. En las defniniciones anteriores, solo
      <varname>ipa</varname> es un puntero, pero <varname>ipb</varname>
      e <varname>ipc</varname> son ints normales (se puede decir que
      <quote>* está mas unido al
      identificador</quote>). Consecuentemente, los mejores resultados
      se pueden alcanzar utilizando solo una definición por línea; y aún
      se conserva una sintaxis sensible sin la confusión:
      </para>

      <programlisting>
       int* ipa;
               int* ipb;
               int* ipc;
</programlisting>        

      <!--
      Since a general guideline for C++ programming is that you should
      always initialize a variable at the point of definition, this form
      actually works better. For example, the variables above are not
      initialized to any particular value; they hold garbage. It's much
      better to say something like:
      -->

      <para>
      Ya que una pauta de programación de C++ es que siempre se debe
      inicializar una variable al definirla, esta manera es mejor. Por
      ejemplo, Las variables anteriores no se inicializan con ningún
      valor en particular; alojan basura. Es mas facil decir algo como:
      </para>

      <programlisting>
   int a = 47;
        int* ipa = &amp;a;
</programlisting>        
      
      <!--
      Now both a and ipa have been initialized, and ipa holds the address of 
        a.
      -->

      <para>
	Ahora tanto <varname>a</varname> como <varname>ipa</varname> han
      sido inicializadas, y <varname>ipa</varname> aloja la dirección de
      <varname>a</varname>.
      </para>


      <!--
      Once you have an initialized pointer, the most basic thing you can
      do with it is to use it to modify the value it points to. To
      access a variable through a pointer, you dereference the pointer
      using the same operator that you used to define it, like this:
      -->

      <para>
      Una vez que se inicializa un puntero, lo más básico que se puede
      hacer con el es utilizarlo para modificar el valor al que este
      apunta. Para acceder a la variable a través del puntero, se
      diferencia el puntero utilizando el mismo operador que se usó para
      definirlo, como sigue:
      </para>

      <programlisting>
       *ipa = 100;
</programlisting>

      <!--
        Now a contains the value 100 instead of 47.
      -->
      
      <para>
      Ahora "a" contiene el valor 100 en vez de 47.
      </para>

      <!--
      These are the basics of pointers: you can hold an address, and you
      can use that address to modify the original variable. But the
      question still remains: why do you want to modify one variable
      using another variable as a proxy?
      -->

      <para>
      Estas son las normas básicas de los punteros: se puede guardar una
      dirección, y se puede utilizar dicha dirección para modificar la
      variable original. Pero la cuestión siempre permanece: ¿por qué se
      requiere cambiar una variable utilizando otra variable como
      acceso?
      </para>

      <!--
      For this introductory view of pointers, we can put the answer into two 
      broad categories:
      -->

      <para>
      Para esta aproximación a los punteros, se puede dividir la
      respuesta en dos amplias categorías:
      </para>

      <!--
      1. To change "outside objects" from within a function. This is 
      perhaps the most basic use of pointers, and it will be examined
      here.
      -->
         
      <para>
      Para cambiar "objetos externos" desde dentro de una función. Esto
      es posiblemente el uso más básico de los punteros, y será
      examinado mas adelante.
      </para>

      <!--
      2. To achieve many other clever programming techniques, which
      you'll learn about in portions of the rest of the book.
      -->
   
      <para>
      Para alcanzar muchas otras inteligentes técnicas de programación,
      acerca de lo cual se aprenderá de apoco en el resto del libro.
      </para>
    </sect2>

    <sect2>
      <!-- Modifying the outside object -->
      <title>FIXME: Modifying the outside object</title>


      <!-- 
      Ordinarily, when you pass an argument to a function, a copy of that
      argument is made inside the function. This is referred to as
      pass-by-value. You can see the effect of pass-by-value in the
      following program:
      -->

      <para>
        Normalmente, cuando se pasa un argumento a una función, una copia de
        dicho argumento se hace dentro de la función. Esto se llama
        paso-por-valor. Se puede ver el efecto de un paso-por-valor en el
        siguiente programa:
      </para>

      <programlisting>
       //: C03:PassByValue.cpp
</programlisting>
        
      <!--
        In f( ), a is a local variable, so it exists only for the duration of 
        the function call to f( ). Because it's a function argument, the value
        of a is initialized by the arguments that are passed when the function
        is called; in main( ) the argument is x, which has a value of 47, so
        this value is copied into a when f( ) is called.
      -->

      <para>
      En f(), "a" es una variable local, de modo que existe únicamente
      mientras dure la llamada a la funcion f(). Ya que es un argumento
      de una funcion, el valor de "a" se inicializa mediante los
      argumentos que son pasados cuando la función es llamada; en main()
      el argumento es "x", el cual tiene un valor de 47, de modo que el
      valor es copiado a "a" cuando se llama a f().
      </para>

      <!--
      When you run this program you'll see:
      -->
         
      <para>
      Cuando se ejecute el program se verá:
      </para>

      <programlisting>
      x = 47
               a = 47
               a = 5
               x = 47
</programlisting>        

      <!--
      Initially, of course, x is 47. When f( ) is called, temporary
      space is created to hold the variable a for the duration of the
      function call, and a is initialized by copying the value of x,
      which is verified by printing it out. Of course, you can change
      the value of a and show that it is changed. But when f( ) is
      completed, the temporary space that was created for a disappears,
      and we see that the only connection that ever existed between a
      and x happened when the value of x was copied into a.
      -->

      <para>
      Por supuesto, inicialmente "x" es 47. CUando f() es llamada, un
      espacio temporal se crea para alojar la variable "a" durante la
      llamada a la función, y "a" se inicializa copiando el valor de
      "x", el cual es verificado mostrandolo por pantalla. Se puede
      cambiar el valor de "a" y mostrar que ha sido cambiado. Pero
      cuando f() se completa, el espacio temporal que había sido creado
      para "a" desaparece, y se puede observar que la única conección
      que existía entre "a" y "x" ocurrió cuando el valor de "x" se
      copió en "a".
      </para>


      <!--
      When you're inside f( ), x is the outside object (my terminology),
      and changing the local variable does not affect the outside
      object, naturally enough, since they are two separate locations in
      storage. But what if you do want to modify the outside object?
      This is where pointers come in handy. In a sense, a pointer is an
      alias for another variable.  So if we pass a pointer into a
      function instead of an ordinary value, we are actually passing an
      alias to the outside object, enabling the function to modify that
      outside object, like this:
      -->

      <para>
      Cuando se está dentro de f(), "x" es el objeto externo (mi
      terminología), y el cambiar el valor de la variable local no
      afecta al objeto externo, lo cual es naturalmente suficiente, ya
      que son dos ubicaciones separadas en el espacio. ¿Pero y si se
      quiere modificar el objecto externo? Aquí es donde los punteros
      entran en acción. En cierto sentido, un puntero es un alias de
      otra variable. De modo que si a una función se le pasa un puntero
      en lugar de un valor ordinario, se está pasando de hecho un alias
      del objeto externo, dando la posibilidad a la función de que pueda
      modificar el objeto externo, como sigue:
      </para>

      <programlisting>
   //: C03:PassAddress.cpp
</programlisting>

      <!--
      Now f( ) takes a pointer as an argument and dereferences the pointer 
      during assignment, and this causes the outside object x to be modified.
      The output is:
      -->
         
      <para>
      Ahora f() toma el puntero como un argumento y referencia el
      puntero durante la asignación, lo que causa que el objeto externo
      "x" sea modificado. La salida es:
      </para>

      <programlisting>
   x = 47
               &amp;x = 0065FE00
               p = 0065FE00
               *p = 47 
               p = 0065FE00
           x = 5
</programlisting>

        
      <!--
      Notice that the value contained in pis the same as the address of
      x - the pointer p does indeed point to x. If that isn't convincing
      enough, when p is dereferenced to assign the value 5, we see that
      the value of x is now changed to 5 as well.
      -->

      <para>
      Notar que el valor contenido en "p" es el mismo que la dirección
      de "x" - el puntero "p" de hecho apunta a "x". Si esto no es
      suficientemente convincente, cuando "p" es dereferenciado para
      asinarle el valor 5, se ve que el valor de "x" cambia a 5 también.
      </para>

      <!--
      Thus, passing a pointer into a function will allow that function
      to modify the outside object. You'll see plenty of other uses for
      pointers later, but this is arguably the most basic and possibly
      the most common use.
      -->

      <para>
      Así, pasando un puntero a una función se permitirá a dicha función
      la modificación del objeto externo. Se verán muchos otros usos de
      los punteros más adelante, pero este es posiblemente el uso más
      básico y común.
      </para>
    </sect2>

 
   <sect2>
      <!-- Introduction to C++ references -->
      <title>Introducción a las referencias de C++</title>

      <!--
      Pointers work roughly the same in C and in C++, but C++ adds an
      additional way to pass an address into a function. This is
      pass-by-reference and it exists in several other programming
      languages so it was not a C++ invention.
      -->

      <para>
	Los punteros funcionan igual de toscamente en C y en C++, pero
	C++ añade un modo adicional de pasar una dirección a una
	función. Este es el paso-por-referencia y existe en otros muchos
	lenguajes, de modo que no es una invención de C ++.
      </para>

      <!--
      Your initial perception of references may be that they are
      unnecessary, that you could write all your programs without
      references. In general, this is true, with the exception of a few
      important places that you'll learn about later in the book. You'll
      also learn more about references later, but the basic idea is the
      same as the demonstration of pointer use above: you can pass the
      address of an argument using a reference.  The difference between
      references and pointers is that calling a function that takes
      references is cleaner, syntactically, than calling a function that
      takes pointers (and it is exactly this syntactic difference that
      makes references essential in certain situations). If
      PassAddress.cpp is modified to use references, you can see the
      difference in the function call in main( ):
      -->

      <para>
	La primera impresión que dan las referencias es que pueden ser
	innecesarias, que se pueden escribir todos los programas sin
	referencias. En general, esto es cierto, con la excepción de
	unos pocos sitios importantes que se aprenderán más adelante en
	este libro, pero la idea básica es la misma que la demostración
	del puntero utilizado anteriormente: se puede pasar la dirección
	de un argumento utilizando una referencia.  La diferencia entre
	referencias y punteros es que el llamar una función que recibe
	referencias es mas limpio, sintácticamente, que llamar a una
	función que recibe punteros (y es exactamente esa diferencia
	sintáctica la que hace a las referencias escenciales en ciertas
	situaciones). Si <filename>PassAddress.cpp</filename> se
	modifica para utilizar referencias, se puede ver la diferencia
	en la llamada a la funcion en <function>main()</function>:
      </para>

      <programlisting>
       //: C03:PassReference.cpp
</programlisting>


      <!--
      In f( )'s argument list, instead of saying int* to pass a pointer,
      you say int& to pass a reference. Inside f( ), if you just say 'r'
      (which would produce the address if r were a pointer) you get the
      value in the variable that r references. If you assign to r, you
      actually assign to the variable that r references. In fact, the
      only way to get the address that's held inside r is with the '&'
      operator.
      -->

      <para>
        En la lista de argumentos de <function>f()</function>, en lugar
        de decir <type>int*</type> para pasar un puntero, se dice
        <type>int&amp;</type> para pasar una referencia. Dentro de
        <function>f()</function>, si simplemente se dice 'r' (lo cual
        produciría la dirección si r fuese un puntero) se obtiene el
        valor en la variable que referencia r. Si se asigna a r, en
        realidad se esta asignado a la variable que r referencia.  De
        hecho, la única manera de obtener la dirección que se aloja
        dentro de r es con el operador '&amp;'.
      </para>

      <!--
      In main( ), you can see the key effect of references in the syntax
      of the call to f( ), which is just f(x). Even though this looks
      like an ordinary pass-by-value, the effect of the reference is
      that it actually takes the address and passes it in, rather than
      making a copy of the value. The output is:
      -->

      <para>
	En main( ), se puede ver el efecto clave de las referencias en la
	sintaxis de la llamada a f( ), lo que es simplemente f(x). Aunque
	esto se ve como un paso-por-valor ordinario, el efecto de la
	referencia es que en realidad recibe la dirección e importa,
	preferiblemente a hacer una copia del valor. La salida es:
      </para>

      <programlisting>
      x = 47
      &amp;x = 0065FE00
      r = 47
      &amp;r = 0065FE00
      r = 5
      x = 5
</programlisting>

      <!--
      So you can see that pass-by-reference allows a function to modify
      the outside object, just like passing a pointer does (you can also
      observe that the reference obscures the fact that an address is
      being passed; this will be examined later in the book). Thus, for
      this simple introduction you can assume that references are just a
      syntactically different way (sometimes referred to as "syntactic
      sugar") to accomplish the same thing that pointers do: allow
      functions to change outside objects.
      -->

      <para>
      De manera que se puede ver que un paso-por-referencia permite a
      una función modificar el objeto externo, al igual que el pasar un
      puntero lo hace (también se puede observar que la referencia
      esconde el hecho de que una dirección está siendo pasada; esto
      será examinado más adelante en el libro). Así, gracias a esta
      pequeña introducción se puede asumir que las referencias son sólo
      un modo sintácticamente distinto (a veces referenciado como
      "azúcar sintáctico") para conseguir lo mismo que los punteros:
      permitir a las funciones cambiar los objetos externos.
      </para>
    </sect2>

    <sect2>
      <!-- Pointers and references as modifiers -->
      <title> Punteros y Referencias como modificadores </title>

      <!--
      So far, you've seen the basic data types char, int, float, and
      double, along with the specifiers signed, unsigned, short, and
      long, which can be used with the basic data types in almost any
      combination. Now we've added pointers and references that are
      orthogonal to the basic data types and specifiers, so the possible
      combinations have just tripled:
      -->

      <para>
	Hasta ahora, se han visto los tipos básicos de datos char, int,
	float, y double, junto con los especificadores signed, unsigned,
	short, y long, los cuales pueden ser utilizados con los tipos
	básicos de datos en casi cualquier combinación. Ahora se han
	sumado los punteros y las referencias que son lo ortogonal a los
	tipos básicos de datos y los especificadores, de modo que las
	combinaciones posibles se acaban de triplicar:
      </para>

      <programlisting>
      //: C03:AllDefinitions.cpp
</programlisting>


      <!-- 
      Pointers and references also work when passing objects into
      and out of functions; you'll learn about this in a later chapter.
      -->

      <para>
      Los punteros y las referencias funcionan ademas cuando se pasan
      objetos dentro y fuera de las funciones; se aprenderá acerca de
      esto en otro capítulo.
      </para>

      <!--
      There's one other type that works with pointers: void. If you
      state that a pointer is a void*, it means that any type of address
      at all can be assigned to that pointer (whereas if you have an
      int*, you can assign only the address of an int variable to that
      pointer). For example:
      -->

      <para>
	Sólo hay otro tipo que funciona con punteros: void. Si se
	establece que un puntero es un void*, esto significa que
	cualquier tipo de dirección puede ser asignada a ese puntero (en
	cambio si se tiene un int*, solo se puede asignar la dirección
	de una variable int a ese puntero). Por ejemplo:
      </para>

      <programlisting>
      //: C03:VoidPointer.cpp
</programlisting>


      <!--
      Once you assign to a void* you lose any information about what
      type it is. This means that before you can use the pointer, you
      must cast it to the correct type:
      -->

      <para>
      Una vez que se asigna a un void* se pierde cualquier información
      sobre de qué tipo es. Esto significa que antes de que se pueda
      utilizar el puntero, se debe convertir al tipo correcto:
      </para>

      <programlisting>
      //: C03:CastFromVoidPointer.cpp
</programlisting>


      <!--
      The cast (int*)vp takes the void* and tells the compiler to treat
      it as an int*, and thus it can be successfully dereferenced. You
      might observe that this syntax is ugly, and it is, but it's worse
      than that - the void* introduces a hole in the language's type
      system. That is, it allows, or even promotes, the treatment of one
      type as another type. In the example above, I treat an int as an
      int by casting vp to an int*, but there's nothing that says I
      can't cast it to a char* or double*, which would modify a
      different amount of storage that had been allocated for the int,
      possibly crashing the program. In general, void pointers should be
      avoided, and used only in rare special cases, the likes of which
      you won't be ready to consider until significantly later in the
      book.
      -->

      <para>
      La conversion (int*)vp recibe el void* y le dice al compilador que
      lo trate como un int*, y de este modo fuede ser distinguido
      exitosamente.  Se puede observar que esta sintaxis es horrible, y
      lo es, pero es peor que eso - el void* introduce un hoyo en el
      sistema de tipo de lenguaje.  Esto significa, que permite, o
      incluso promueve, el tratamiento de un tipo como otro tipo. En el
      ejemplo anterior, se trata un int como un int mediante la
      conversión de vp a int*, pero no hay nada que indique que no se lo
      puede convertir a chat* o double*, lo que modificaría una cantidad
      diferente de espacio que ha sido generada para el int,
      posiblemente haciendo fallar el programa. En general, los punteros
      void deberían ser evitados, y utilizados únicamente en raras
      ocasiones, las cuales no se podrán considerar hasta bastante más
      adelante en este libro.
      </para>

      <!--
      You cannot have a void reference, for reasons that will be
      explained in Chapter 11.
      -->

      <para>
      No se puede tener una referencia void, por razones que serán
      explicadas en el capítulo 11.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <!-- Scoping -->
    <!-- FIXME:Estableciendo ámbitos] -->
    <title>Alcance</title>

    <!--
    Scoping rules tell you where a variable is valid, where it is
    created, and where it gets destroyed (i.e., goes out of scope). The
    scope of a variable extends from the point where it is defined to
    the first closing brace that matches the closest opening brace
    before the variable was defined. That is, a scope is defined by its
    "nearest" set of braces. To illustrate:
    -->

    <para>
    Las reglas del establecimiento de ámbitos dicen cuando una variable
    es válida, dónde es creada, y cuándo se detruye (p.e, se sale de
    ámbito).  El ámbito de una variable se extiende desde el punto donde
    es definida hasta la primera llave que se empareja con la llave de
    apertura antes de que la variable fuese definida. Esto quiere decir
    que un ámbito se define por su juego de llaves "mas cercanas". Para
    ilustrarlo:
    </para>

    <programlisting>
    //: C03:Scope.cpp
</programlisting>


    <!--
    The example above shows when variables are visible and when they are
    unavailable (that is, when they go out of scope). A variable can be
    used only when inside its scope. Scopes can be nested, indicated by
    matched pairs of braces inside other matched pairs of
    braces. Nesting means that you can access a variable in a scope that
    encloses the scope you are in.  In the example above, the variable
    scp1 is available inside all of the other scopes, while scp3 is
    available only in the innermost scope.
    -->

    <para>
    El ejemplo anterior muestra cuándo las variables son visibles y
    cuando no están disponibles (es decir, cuando se salen del
    ámbito). Una variable puede ser utilizada sólo cuando está dentro de
    su ámbito. Los ámbitos pueden ser anidados, indicados por parejas de
    llaves dentro de otras parejas de llaves. El anidado significa que
    se puede acceder a una variable en un ámbito que incluye el ámbito
    en el que se está.  En el ejemplo anterior, la variable scp1 está
    dispobible dentro de todos los demás ámbitos, mientras que scp3 sólo
    está disponible en el ámbito más interno.
    </para>

    <sect2>
      <!-- Defining variables on the fly -->
      <title>Definición de variables 'al vuelo'</title>

      <!--
      As noted earlier in this chapter, there is a significant
      difference between C and C++ when defining variables. Both
      languages require that variables be defined before they are used,
      but C (and many other traditional procedural languages) forces you
      to define all the variables at the beginning of a scope, so that
      when the compiler creates a block it can allocate space for those
      variables.
      -->

      <para>
      Como se ha mencionado antes en este capítulo, hay una diferencia
      importante entre C y C++ al definir variables. Ambos lenguajes
      requieren que las variables sean definidas antes de utilizarse,
      pero C (y muchos otros lenguajes procedurales tradicionales)
      fuerzan a que se definan todas las variables al principio de un
      ámbito, de modo que cuando el compilador crea un bloque puede
      crear espacio para esas variables.
      </para>

      <!--
      While reading C code, a block of variable definitions is usually
      the first thing you see when entering a scope. Declaring all
      variables at the beginning of the block requires the programmer to
      write in a particular way because of the implementation details of
      the language.  Most people don't know all the variables they are
      going to use before they write the code, so they must keep jumping
      back to the beginning of the block to insert new variables, which
      is awkward and causes errors.  These variable definitions don't
      usually mean much to the reader, and they actually tend to be
      confusing because they appear apart from the context in which they
      are used.
      -->

      <para>
      Cuando se lee código C, un bloque de definiciones variables
      es usualmente la primera cosa que se ve cuando se introduce un
      ámbito.  Declarando todas las variables al comienzo de un bloque
      requiere que el programador escriba de un modo particular debido a
      los detalles de implementación del lenguaje.  La mayoría de las
      personas no saben todas las variables que van a utilizar antes de
      escribir el código, de modo que siempre están volviendo al
      principio del bloque para insertar nuevas variables, lo que es
      pesado y causa errores.  Estas definiciones de variables no
      significan demasiado para el lector normalmente, y de hecho
      tienden a ser confusas porque aparecen separadas del contexto en
      el cual son utilizadas.
      </para>

      
      <!--
      C++ (not C) allows you to define variables anywhere in a scope, so
      you can define a variable right before you use it. In addition,
      you can initialize the variable at the point you define it, which
      prevents a certain class of errors. Defining variables this way
      makes the code much easier to write and reduces the errors you get
      from being forced to jump back and forth within a scope. It makes
      the code easier to understand because you see a variable defined
      in the context of its use. This is especially important when you
      are defining and initializing a variable at the same time - you
      can see the meaning of the initialization value by the way the
      variable is used.
      -->

      <para>
      C++ (pero C) permite definir variables en cualquier sitio dentro
      de un ámbito, de modo que se puede definir una variable justo
      antes de usarla.  En adición, se puede inicializar la variable en
      el momento de la definición, lo que previene una cierta clase de
      errores. Definiendo variables de este modo hace el código más
      fácil de escribir y reduce los errores que se obtienen de estar
      forzado a volver atrás y adelante dentro de un ámbito. Hace el
      código mas fácil de entender porque es una variable definida en el
      contexto de su utilización. Esto es especialmente importante
      cuando se está definiendo e inicializando una variable al mismo
      tiempo - se puede ver el significado del valor de inicialización
      por el modo en el que una variable es usada.
      </para>


      <!--
      You can also define variables inside the control expressions of
      for loops and while loops, inside the conditional of an if
      statement, and inside the selector statement of a switch. Here's
      an example showing on-the-fly variable definitions:
      -->

      <para>
      Se puede definir tambien variables dentro de expresiones de
      control tales como los bucles for y while, dentro de las
      sentencias de condiciones if, y dentro de la sentencia de
      selección switch. A continuación hay un ejemplo mostrando la
      definición de variables al vuelo:
      </para>

      <programlisting>
       //: C03:OnTheFly.cpp
</programlisting>

      <!--
      In the innermost scope, p is defined right before the scope ends,
      so it is really a useless gesture (but it shows you can define a
      variable anywhere). The p in the outer scope is in the same
      situation.
      -->

      <para>
      En el ámbito más interno, p es definida antes de que el ámbito
      acabe, de modo que realmente es un gesto inútil (pero demuestra
      que se puede definir una variable en cualquier sitio). La variable
      p en el ámbito exterior está en la misma situación.
      </para>

      <!--
      The definition of i in the control expression of the for loop is
      an example of being able to define a variable exactly at the point
      you need it (you can do this only in C++). The scope of i is the
      scope of the expression controlled by the for loop, so you can
      turn around and re-use i in the next for loop. This is a
      convenient and commonly-used idiom in C++; i is the classic name
      for a loop counter and you don't have to keep inventing new names.
      -->

      <para>
      La definición de i en el la expresión de control del bucle for es
      un ejemplo de ser capaz de definir una variable exactamente en el
      punto en que es necesaria (sólo se puede hacer esto en C++). El
      ámbito de i es el ámbito de la expresión controlada por el bucle
      for, de modo que se puede re-utilizar i en el siguiente bucle
      for. Esto es un idioma conveniente y comunmente usado en C++; i es
      el nombre corriente para el contador de un for y no se tienen que
      inventar nuevos nombres.
      </para>

      <!--
      Although the example also shows variables defined within while,
      if, and switch statements, this kind of definition is much less
      common than those in for expressions, possibly because the syntax
      is so constrained.  For example, you cannot have any
      parentheses. That is, you cannot say:
      -->

      <para>
      A pesar de que el ejemplo también muestra variables definidas
      dentro de las sentencias while, if y switch, este tipo de
      definiciones es menos común que aquellas definidas en expresiones
      for, quizas debido a que la sintaxis es tan rígida.  Por ejemplo,
      no se puede tener nigún paréntesis. Es decir, que no se puede
      indicar:
      </para>

      <programlisting>
      while((char c = cin.get()) != 'q')
</programlisting>

      <!--
      The addition of the extra parentheses would seem like an innocent
      and useful thing to do, and because you cannot use them, the
      results are not what you might like. The problem occurs because
      '!=' has a higher precedence than '=', so the char c ends up
      containing a bool converted to char. When that's printed, on many
      terminals you'll see a smiley-face character.
      -->

      <para>
      La adición de los paréntesis extra parecería una acción inocente y
      útil, y debido a que no se pueden utilizar, los resultados no son
      los esperados. El problema ocurre porque '!=' tiene una
      importancia mas alta que '=', de modo que el char c acaba
      conteniendo un bool convertido a un char. Cuando esto es mostrado,
      en muchos terminales se vería el carácter de la cara sonriente.
      </para>

      <!--
      In general, you can consider the ability to define variables
      within while, if, and switch statements as being there for
      completeness, but the only place you're likely to use this kind of
      variable definition is in a for loop (where you'll use it quite
      often).
      -->

      <para>
	En general, se puede considerar la habilidad de definir
	variables dentro de las sentencias while, if y switch como
	complementos, pero el único lugar donde se debería utilizar este
	tipo de definición de variables es en el bucle for (donde se
	utilizarán más a menudo).
      </para>
    </sect2>
  </sect1>

  
  <sect1>
    <!-- Specifying storage allocation -->
    <title> Especificar la ubicación del espacio de almacenamiento</title>

    <!--
    When creating a variable, you have a number of options to specify
    the lifetime of the variable, how the storage is allocated for that
    variable, and how the variable is treated by the compiler.
    -->
    
    <para>
      Al crear una variable, hay un número de opciones para especificar
      la vida de dicha variable, como el espacio de ésta es ubicado, y
      como la variable es tratada por el compilador.
    </para>
    
    <sect2>
      <!-- Global variables -->
      <title> Variables globales</title>

      <!--
      Global variables are defined outside all function bodies and are
      available to all parts of the program (even code in other
      files). Global variables are unaffected by scopes and are always
      available ( i.e., the lifetime of a global variable lasts until
      the program ends). If the existence of a global variable in one
      file is declared using the  extern keyword in another file, the
      data is available for use by the second file. Here's an example of
      the use of global variables:
      -->

      <para>
      Las variables globales se definen fuera de todos los cuerpos de
      las funciones y están disponibles para todas las partes del
      programa (incluso el código de otros ficheros). Las variables
      globales no están afectadas por ámbitos y están siempre
      disponibles ( p.e, la vida de una variable global dura hasta la
      finalización del programa). Si la existencia de una variable
      global en un fichero es declarada usando la palabra clave extern
      en otro fichero, la información está disponible para su
      utilización en el segundo fichero. A continuación un ejemplo del
      uso de variables globales:
      </para>

      <programlisting>
//: C03:Global.cpp
</programlisting>

      <!--
      Here's a file that accesses globe as an extern:
      -->

      <para>
      Y el fichero que accede a globe como un extern:
      </para>

      <programlisting>
//: C03:Global2.cpp {O}
</programlisting>

      <!--
      Storage for the variable globe is created by the definition in
      Global.cpp, and that same variable is accessed by the code in
      Global2.cpp. Since the code in Global2.cpp is compiled separately
      from the code in Global.cpp, the compiler must be informed that
      the variable exists elsewhere by the declaration
      -->

      <para>
      El espacio para la variable globe se crea mediante la definición
      en Global.cpp, y esa misma variable es accedida por el código de
      Global2.cpp. Ya que el código de Global2.cpp se compila separado
      del código de Global.cpp, el compilador debe ser informado de que
      la variable existe en cualquier sitio mediante la declaración
      </para>

      <programlisting>
extern 
int globe;
</programlisting>


      <!--
      When you run the program, you'll see that the call to func( ) does
      indeed affect the single global instance of globe.
      -->

      <para>
      Cuando se ejecute el programa, se observará que la llamada a fun()
      de hecho afecta la instancia global individual de globe.
      </para>


      <!--
      In Global.cpp, you can see the special comment tag (which is my
      own design):
      -->

      <programlisting>
//{L} Global2
</programlisting>

      <!--
      This says that to create the final program, the object file with
      the name Global2 must be linked in (there is no extension because
      the extension names of object files differ from one system to the
      next). In Global2.cpp, the first line has another special comment
      tag {O}, which says "Don't try to create an executable out of this
      file, it's being compiled so that it can be linked into some other
      executable." The ExtractCode.cpp program in Volume 2 of this book
      (downloadable at www.BruceEckel.com) reads these tags and creates
      the appropriate makefile so everything compiles properly (you'll
      learn about makefiles at the end of this chapter).
      -->

      <para>
      Eso indica que para crear el programa final, el fichero object con
      el nombre Global2 debe estar enlazado (no hay extensión ya que los
      nombres de las extensiones de los ficheros object difieren de un
      sistema a otro). En Global2.cpp, la primera linea tiene otro tag
      de comentario especial {O}, el cual dice "No intentar crear un
      ejecutable de este fichero, se compila para que pueda enlazarse
      dentro de algún otro ejecutable". El programa ExtractCode.cpp en e
      l Volumen 2 de este libro (se puede descargar en
      www.BruceEckel.com) lee estos tags y crea el makefile apropiado de
      modo que todo se compila correctamente (se aprenderá sobre
      makefiles al final de este capítulo).
      </para>
    </sect2>

    <sect2>
      <!-- Local variables -->
      <title>Variables locales</title>

      <!--
      Local variables occur within a scope; they are "local" to a
      function. They are often called automatic variables because they
      automatically come into being when the scope is entered and
      automatically go away when the scope closes. The keyword auto
      makes this explicit, but local variables default to auto so it is
      never necessary to declare something as an auto. 
      -->

      <para>
      Las variables locales se encuentran dentro de un ámbito; son
      "locales" de una función. A menudo son llamadas variables
      automáticas porque aparecen automáticamente cuando se entra en un
      ámbito y automáticamente desaparecen cuando el ámbito se acaba. La
      palabra clave auto hace esto explícito, pero las variables locales
      llevan auto por defecto, de modo que nunca es necesario declarar
      algo como auto.
      </para>


      <sect3>
        <!-- Register variables -->
        <title>Variables de registro</title>

	<!--
        A register variable is a type of local variable. The register
        keyword tells the compiler "Make accesses to this variable as
        fast as possible." Increasing the access speed is implementation
        dependent, but, as the name suggests, it is often done by
        placing the variable in a register. There is no guarantee that
        the variable will be placed in a register or even that the
        access speed will increase. It is a hint to the compiler.
	-->

        <para>
        Una variable de registro es un tipo de variable local. La
        palabra clave registro indica al compilador "Has los accesos a
        esta variable lo mas rápidos posible". Aumentar la velocidad de
        acceso depende de la implementación, pero,   como el nombre lo
        sugiere, a menudo se hace situando la variable en un
        registro. No hay garantía alguna de que la variable será ubicada
        en un registro y tampoco de que la velocidad de acceso
        aumente. Es una ayuda para el compilador.
        </para>

	<!--
        There are restrictions to the use of register variables. You
        cannot take or compute the address of a register variable. A
        register variable can be declared only within a block (you
        cannot have global or static register variables). You can,
        however, use a register variable as a formal argument in a
        function ( i.e., in the argument list).
        -->

        <para>
        Hay restricciones a la hora de utilizar variables de
        registro. No se puede tomar o calcular la dirección de una
        variable de registro. Una variable de registro puede ser
        declarada solo dentro de un bloque (no se puede tener variables
        de registro globales o estáticas). De todos modos, se las puede
        utilizar como un argumento formal en una función (p.e, en la
        lista de argumentos).
        </para>

	<!--
        In general, you shouldn't try to second-guess the compiler's optimizer,
        since it will probably do a better job than you can. Thus, the
        register keyword is best avoided.
	-->

        <para>
	  En general, no se debería contradecir el optimizador del
	  compilador, ya que este probablemente haría mejor el
	  trabajo. Así, es mejor evitar la palabra clave register.
        </para>
      </sect3>
    </sect2>

    <sect2>
      <title>Static</title>

      <!--
        The static keyword has several distinct meanings. Normally,
        variables defined local to a function disappear at the end of
        the function scope. When you call the function again, storage
        for the variables is created anew and the values are
        re-initialized. If you want a value to be extant throughout the
        life of a program, you can define a function's local variable to
        be static and give it an initial value. The initialization is
        performed only the first time the function is called, and the
        data retains its value between function calls. This way, a
        function can "remember" some piece of information between
        function calls.
      -->
      
        <para>
        La palabra clave static tiene diversos
        significados. Normalmente, las variables definidas localmente en
        una función desaparecen al final del ámbito de ésta. Cuando se
        llama de nuevo a la función, el espacio de las variables se
        vuelve a pedir y las variables son re-inicializadas. Si se
        desear que un valor se conserve durante la vida de un programa,
        se puede definir una variable local de una función como static
        (estática) y darle un valor inicial. La inicialización se
        realiza solo la primera vez que la función es llamada, y la
        información se conserva entre llamada y llamada a la función. De
        este modo, una función puede "recordar" una cierta información
        entre una llamada y otra.
        </para>

      <!--
        You may wonder why a global variable isn't used instead. The
        beauty of a static variable is that it is unavailable outside
        the scope of the function, so it can't be inadvertently
        changed. This localizes errors.
      -->

        <para>
        Puede surgir la duda de por qué no se utiliza una variable
        global en este caso. El encanto de una variable static es que no
        está disponible fuera del ámbito de la función, de modo que no
        puede ser modificada accidentalmente. Esto reduce los errores.
        </para>

      <!--
      Here's an example of the use of static variables:
      -->

      <para>
        A continuación un ejemplo del uso de variables static:
      </para>
 
      <programlisting>
//: C03:Static.cpp
</programlisting>

      <!--
        Each time func() is called in the for loop, it prints a
        different value. If the keyword static is not used, the value
        printed will always be '1'.
      -->

      <para>
        Cada vez que se llama a func( ) dentro del bucle, se imprime un
        valor diferente. Si la palabra clave static no se utilizara, el
        valor mostrado sería siempre '1'.
      </para>

      <!--
        The second meaning of static is related to the first in the
        "unavailable outside a certain scope" sense. When static is
        applied to a function name or to a variable that is outside of
        all functions, it means "This name is unavailable outside of
        this file." The function name or variable is local to the file;
        we say it has  file scope. As a demonstration, compiling and
        linking the following two files will cause a linker error: 
      -->

      <para>
        El segundo significado de static está relacionado al primero en
        el sentido de que "no está disponible fuera de cierto
        ámbito". Cuando static se aplica al nombre de una función o de
        una variable que está fuera de todas las funciones, significa
        "Este nombre no está disponible fuera de este fichero". El
        nombre de la función o de la variable es local al fichero; se
        llama a esto ámbito de fichero. Como demostración, al compilar y
        enlazar los dos ficheros siguientes se causa un error de enlace:
      </para>

      <programlisting>
//: C03:FileStatic.cpp
</programlisting>

      <!--
        Even though the variable fs is claimed to exist as an extern  in
        the following file, the linker won't find it because it has been
        declared static in FileStatic.cpp.
      -->

      <para>
        Aunque la variable fs está destinada a existir como un extern en
        el siguiente fichero, el enlazador  no la encontraría porque ha
        sido declarada static en FileStatic.cpp.
      </para>

      <programlisting>
//: C03:FileStatic2.cpp {O}
</programlisting>


      <!--
        The static specifier may also be used inside a class. This
        explanation will be delayed until you learn to create classes,
        later in the book.
      -->

      <para>
        El especificador static también se puede usar dentro de una
        class (clase). Esta explicación  se dará mas adelante en este
        libro, cuando se aprenda a crear clases.
      </para>
    </sect2>

    <sect2>
      <title>extern</title>

      <!--
        The extern keyword has already been briefly described and
        demonstrated. It tells the compiler that a variable or a
        function exists, even if the compiler hasn't yet seen it in the
        file currently being compiled. This variable or function may be
        defined in another file or further down in the current file. As
        an example of the latter:
      -->

      <para>
      La palabra clave extern ya ha sido brevemente descripta y
      demostrada. Le dice al compilador que una variable o una función
      existe, incluso si el compilado aún no la ha visto en el fichero
      que está siendo compilado en ese momento. Esta variable o función
      puede definirse en otro fichero o más abajo en el fichero
      actual. A modo de ejemplo de lo anterior:
      </para>

      <programlisting>
//: C03:Forward.cpp
</programlisting>

      <!--
      When the compiler encounters the declaration 'extern int i', it
      knows that the definition for i must exist somewhere as a global
      variable. When the compiler reaches the definition of i, no other
      declaration is visible, so it knows it has found the same i
      declared earlier in the file. If you were to define i as static,
      you would be telling the compiler that i is defined globally (via
      the extern), but it also has file scope (via the static), so the
      compiler will generate an error.
      -->

      <para>
	Cuando el compilador encuentra la declaración 'extern int i'
	sabe que la definición para i debe existir en algún sitio como
	una variable global. Cuando el compilador alcanza la definición
	de i, ninguna otra declaración es visible, de modo que sabe que
	ha encontrado la misma i declarada anteriormente en el
	fichero. Si se fuese a definir i como static, se estaría
	indicando al compilador que i se define globalmente (via
	extern), pero también tiene el ámbito del fichero (via static),
	de modo que el compilador generará un error.
      </para>

      <sect3>
        <!--Linkage-->
        <title>Enlazado</title>

        <!--
      To understand the behavior of C and C++ programs, you need to know
      about linkage. In an executing program, an identifier is
      represented by storage in memory that holds a variable or a
      compiled function body. Linkage describes this storage as it is
      seen by the linker. There are two types of linkage: internal
      linkage and external linkage.
        -->

        <para>
	  Para comprender el comportamiento de los programas en C y C++,
	  es necesario saber sobre enlaces. En un programa en ejecución,
	  un identificador se representa como espacio en memoria que
	  aloja una variable o un cuerpo de función compilada. El enlace
	  describe este espacio como es visto por el enlazador. Hay dos
	  formas de enlazar: enlace interno y enlace externo.
        </para>

	<!-- Internal linkage means that storage is created to represent
	the identifier only for the file being compiled. Other files may
	use the same identifier name with internal linkage, or for a
	global variable, and no conflicts will be found by the linker -
	separate storage is created for each identifier. Internal
	linkage is specified by the keyword static in C and C++.  -->

        <para>
	  Enlace interno significa que el espacio se pide para
	  representar al identificador sólo mientras el fichero está
	  siendo compilado. Otros ficheros pueden utilizar el mismo
	  nombre de identificador con un enlace interno, o para una
	  variable global, y el enlazador no encontraría conflictos - se
	  pide un espacio separado para cada identificador. El enlace
	  interno se especifica mediante la palabra clave static en C y
	  C++.
        </para>

	<!--
      External linkage means that a single piece of storage is created
      to represent the identifier for all files being compiled. The
      storage is created once, and the linker must resolve all other
      references to that storage. Global variables and function names
      have external linkage. These are accessed from other files by
      declaring them with the keyword extern. Variables defined outside
      all functions (with the exception of const in C++) and function
      definitions default to external linkage. You can specifically
      force them to have internal linkage using the static keyword. You
      can explicitly state that an identifier has external linkage by
      defining it with the extern keyword. Defining a variable or
      function with extern is not necessary in C, but it is sometimes
      necessary for const in C++.
	-->
        
	<para>
      Enlace externo significa que se pide un solo espacio para
      representar el identificador para todos los ficheros que se estén
      compilando. El espacio se pide una vez, y el enlazador debe
      resolver todas las demás referencias en ese espacio. Las variables
      globales y los nombres de función tienen enlace externo. Estas son
      accedidas desde otros ficheros declarándolas con la palabra clave
      extern. Las variables se definen fuera de todas las funciones (con
      la excepción de const en C++)   y las definiciones de las
      funciones acarrean por defecto el enlace externo. Se pueden forzar
      específicamente a tener enlace interno utilizando static. Se puede
      establecer explícitamente que un identificador tiene enlace
      externo definiéndolo como extern. No es necesario definir una
      variable o una función como extern en C, pero a veces es necesario
      para const en C++.
        </para>

	<!--
      Automatic (local) variables exist only temporarily, on the stack,
      while a function is being called. The linker doesn't know about
      automatic variables , and so these have no linkage.
	-->

	<para>
      Las variables automáticas (locales) existen sólo temporalmente, en
      la pila, mientras una función es llamada. El enlazador no entiende
      de variables automáticas, de modo que no tienen enlace.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Constantes</title>

      <!--
      In old (pre-Standard) C, if you wanted to make a constant, you had
      to use the preprocessor :
      -->

      <para>
      En el antiguo C (pre-Standard),  si se deseaba crear una constante, se
      debía utilizar el preprocesador:
      </para>

      <programlisting>
#define PI 3.14159
</programlisting>

      <!--
      Everywhere you used PI, the value 3.14159 was substituted by the
      preprocessor (you can still use this method in C and C++).
      -->

      <para>
	En cualquier sitio en el que se utilizase PI, el valor 3.14159
	se sustituía por el preprocesador (aun se puede utilizar este
	método en C y C++).
      </para>

      <!--
      When you use the preprocessor to create constants, you place
      control of those constants outside the scope of the compiler. No
      type checking  is performed on the name PI and you can't take the
      address of PI (so you can't pass a pointer or a reference to
      PI). PI cannot be a variable of a user-defined type. The meaning
      of PI lasts from the point it is defined to the end of the file;
      the preprocessor doesn't recognize scoping.
      -->

      <para>
	Cuando se utiliza el preprocesador para crear constantes, se da
	el control de éstas fuera del ámbito del compilador. Ninguna
	comprobación sintáctica se aplica a PI y no se puede obtener la
	dirección de PI (de modo que no se puede pasar un puntero o una
	referencia a PI). PI no puede ser una variable de un tipo
	definido por el usuario. El significado de PI dura desde el
	punto en que es definida, hasta el final del fichero; el
	preprocesador no reconoce el ámbito.
      </para>


      <!--
      C++ introduces the concept of a named constant that is just like a
      variable, except that its value cannot be changed. The modifier
      const tells the compiler that a name represents a constant. Any
      data type, built-in or user-defined, may be defined as const. If
      you define something as const and then attempt to modify it, the
      compiler will generate an error.
      -->

      <para>
	C++ introduce el concepto de una constante nombrada que es igual
	que una variable, excepto que su valor no se puede cambiar. El
	modificador const le indica al compilador que un nombre
	representa una constante. Cualquier tipo de datos, predefinido o
	definido por el usuario, puede ser definido como const. Si se
	define algo como const y luego se intenta modificarlo, el
	compilador generara un error.
      </para>

      <!--
      You must specify the type of a const, like this:
      -->

      <para>
	Se debe especificar el tipo de un const, de este modo:
      </para>

      <programlisting>
const
 int x = 10;
</programlisting>


      <!--
      In Standard C and C++, you can use a named constant in an argument
      list, even if the argument it fills is a pointer or a reference (
      i.e., you can take the address of a const). A const has a scope,
      just like a regular variable, so you can "hide" a const inside a
      function and be sure that the name will not affect the rest of the
      program.
      -->

      <para>
	En Standard C y C++, se puede usar una constante en una lista de
	argumentos, incluso si el argumento que ocupa es un puntero o
	una referencia (p.e, se puede obtener la direccion de una
	const). Una const tiene un ámbito, al igual que una variable
	ordinaria, de modo que se puede "esconder" una const dentro de
	una función y estar seguro de que ésta no afectará al resto del
	programa.
      </para>


      <!--
      The const was taken from C++ and incorporated into Standard C,
      albeit quite differently. In C, the compiler treats a const just
      like a variable that has a special tag attached that says "Don't
      change me." When you define a const in C, the compiler creates
      storage for it, so if you define more than one const with the same
      name in two different files (or put the definition in a header
      file), the linker will generate error messages about
      conflicts. The intended use of const in C is quite different from
      its intended use in C++ (in short, it's nicer in C++).
      -->

      <para>
	Const ha sido tomado de C++ e incorporado en Standard C, pero un
	poco distinto. En C, el compilador trata a const del mismo modo
	que a una variable que tiene el adjunto un tag especial que dice
	"No me cambies". Cuando se define un const en C, el compilador
	pide espacio para el, de modo que si se define más de un const
	con el mismo nombre en dos ficheros distintos (o se ubica la
	definición en un fichero de cabeceras), el enlazador generará
	mensajes de error acerca de conflictos. El concepto de utilizar
	const en C es diferente de su utilización en C++ (para abreviar,
	es mas bonito en C++).
      </para>

      <sect3>
	<!-- Constant values -->
	<title>Valores constantes</title>

	<!--
	In C++, a const must always have an initialization value (in C,
	this is not true). Constant values for built-in types are
	expressed as decimal, octal, hexadecimal, or floating-point
	numbers (sadly, binary numbers were not considered important),
	or as characters.
	-->

	<para>
	  En C++, una constante siempre debe tener un valor inicial (En
	  C, esto no es cierto). Los valores de las constantes para
	  tipos predefinidos se expresan en decimal, octal, hexadecimal,
	  o números con punto flotante (desgraciadamente, los números
	  binarios no fueron considerados importantes, o como
	  caracteres.
	</para>


	<!--
	In the absence of any other clues, the compiler assumes a
	constant value is a decimal number. The numbers 47, 0, and 1101
	are all treated as decimal numbers.
	-->

	<para>
	  En ausencia de ninguna otra pista, el compilador assume que el
	  valor de una constante es un número decimal. Los numeros 47,
	  . y 1101 serán tratados como números decimales.
	</para>


	<!--
	A constant value with a leading 0 is treated as an octal number
	(base 8). Base 8 numbers can contain only digits 0-7; the
	compiler flags other digits as an error. A legitimate octal
	number is 017 (15 in base 10).
	-->

	<para>
	Un valor constante con un cero al principio se trata como
	un número octal (base 8). Los números con base 8 pueden contener
	únicamente dígitos del 0 al 7; el compilador interpreta otros
	dígitos como un error. Un número octal legítimo es 017 (15 en
	base 10).
	</para>

	<!--
	A constant value with a leading 0x is treated as a hexadecimal
	number (base 16). Base 16 numbers contain the digits 0-9 and a-f
	or A-F. A legitimate hexadecimal number is 0x1fe (510 in base
	10).
	-->

	<para>
	Un valor constante con 0x al principio se trata como un
	número hexadecimal (base 16). Los números con base 16 pueden
	contener dígitos del 0 al 9 y letras de la 'a' a la 'f' o "A' a
	'F'. Un número hexadecimal legítimo es 0x1fe (510 en base 10).
	</para>


	<!--
	Floating point numbers can contain decimal points and
	exponential powers (represented by e, which means "10 to the
	power of"). Both the decimal point and the e are optional. If
	you assign a constant to a floating-point variable, the compiler
	will take the constant value and convert it to a floating-point
	number (this process is one form of what's called implicit type
	conversion). However, it is a good idea to use either a decimal
	point or an e to remind the reader that you are using a
	floating-point number; some older compilers also need the hint.
	-->

	<para>
	  Los números con punto flotante pueden contener comas decimales
	  y potencias exponenciales (representadas mediante 'e', lo que
	  significa "10 elevado a"). Tanto el punto decimal como la e
	  son opcionales. Si se asigna una constante a una variable de
	  punto flotante, el compilador tomara el valor de la constante
	  y la convertirá a un número en punto flotante (este proceso es
	  una manera de que se conoce como conversión implícita de
	  tipo). De todos modos, es una buena idea el usar el punto
	  decimal o una e para recordar al lector que se esta utilizando
	  un número en punto flotante; algunos compiladores incluso
	  necesitan esta pista.
	</para>

	<!--
	Legitimate floating-point constant values are: 1e4, 1.0001,
	47.0, 0.0, and -1.159e-77. You can add suffixes to force the
	type of floating-point number: f or F forces a float, L or l
	forces a long double; otherwise the number will be a double.
	-->

	<para>
	  Los valores legítimos de una constante con punto flotante son:
	  1e4, 1.0001, 47.0, 0.0 y 1.159e-77. Se pueden añadir sufijos
	  para forzar el tipo de número de punto flotante: f o F fuerza
	  a que sea flota, L o l fuerza a que sea un long double; de lo
	  contrario, el número será un double.
	</para>

	<!--
	Character constants are characters surrounded by single quotes,
	as: 'A', '0', ' '. Notice there is a big difference between the
	character '0' (ASCII 96) and the value 0. Special characters are
	represented with the "backslash escape": ' \n' (newline), '\t'
	(tab), '\\' (backslash), '\r' (carriage return), '\"' (double
	quotes), '\'' (single quote), etc. You can also express char
	constants in octal: '\17 ' or hexadecimal: '\xff'.
	-->

	<para>
	  Las constantes de tipo char son caracteres rodeados de
	  comillas simples, tales como: 'A', 'o', ''. Notar que hay una
	  gran diferencia entre el carácter 'o' (ASCII 96) y el valor
	  0. Los caracteres especiales se representan con la "barra
	  invertida": '\n' (nueva línea), '\t' (tabulación), '\\' (barra
	  invertida), '\r' (retorno de carro), '\"' (comillas dobles),
	  '\'' (comilla simple), etc. Incluso se puede expresar
	  constantes de tipo char en octal: '\17' o hexadecimal: '\
	  xff'.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Volatile</title>
      
      <!--
      Whereas the qualifier const tells the compiler "This never
      changes" (which allows the compiler to perform extra
      optimizations), the qualifier volatile tells the compiler "You
      never know when this will change," and prevents the compiler from
      performing any optimizations based on the stability of that
      variable. Use this keyword when you read some value outside the
      control of your code, such as a register in a piece of
      communication hardware. A volatile variable is always read
      whenever its value is required, even if it was just read the line
      before.
      -->

      <para>
	Mientras que el calificador const le indica al compilador "Esto
	nunca cambia" (lo que permite al compilador realizar
	optimizaciones extra), el calificador volatile le indica al
	compilador "Nunca se sabe cuando esto cambiará", y previente al
	compilador de realizar ninguna optimización basada en la
	estabilidad de esa variable. Se utiliza esta palabra clave
	cuando se lee algún valor fuera del control del código, algo así
	como un registro en un hardware de comunicación. Una variable
	volatile se lee siempre que su valor sea requerido, incluso si
	se ha leído en la línea anterior.
      </para>


      <!--
      A special case of some storage being "outside the control of your
      code" is in a multithreaded program. If you're watching a
      particular flag that is modified by another thread or process,
      that flag should be volatile so the compiler doesn't make the
      assumption that it can optimize away multiple reads of the flag.
      -->

      <para>
	Un caso especial de un cierto espacio que está "fuera del
	control del código" es en un programa multi-hilo. Si se ve un
	flan particular que se modifica por otro hilo o proceso, este
	flan debería ser volatile de modo que el compilador no asume que
	puede optimizar múltiples lecturas del flan.
      </para>


      <!--
      Note that volatile may have no effect when a compiler is not
      optimizing, but may prevent critical bugs when you start
      optimizing the code (which is when the compiler will begin looking
      for redundant reads).
      -->
      
      <para>
	Notar que volatile puede no tener efecto cuando un compilador no
	está optimizando, pero puede prevenir errores críticos cuando se
	comienza a optimizar el código (que es cuando el compilador
	comenzara a buscar lecturas redundantes).
      </para>
      

      <!--
      The const and volatile keywords will be further illuminated in a
      later chapter.
      -->

      <para>
	Las palabras clave const y volatile se verán con más detalle en un
	capítulo posterior.
      </para>
    </sect2>
  </sect1>


  <sect1>
    <!-- Operators and their use -->
    <title>
      Los operadores y su uso
    </title>

    <!--
    This section covers all the operators in C and C++.
    -->

    <para>
    Esta sección cubre todos los operadores de C y C++.
    </para>

    <!--
    All operators produce a value from their operands. This value is
    produced without modifying the operands, except with the assignment,
    increment, and decrement operators. Modifying an operand is called a
    side effect. The most common use for operators that modify their
    operands is to generate the side effect, but you should keep in mind
    that the value produced is available for your use just as in
    operators without side effects.
    -->

    <para>
      Todos los operadores producen un valor a partir de sus
      operandos. Este valor es producido sin modificar los operandos,
      excepto con los operadores de asignación, incremento y
      decremento. El hecho de modificar un operando es llamado efecto
      colateral. El uso más común para operadores que modifican sus
      operandos es generar el efecto colateral, pero se debería tener en
      cuenta que el valor producido está disponible para su uso al igual
      que el de los operadores sin efectos colaterales.
    </para>

    <sect2>
      <!-- Assignment -->
      <title>Asignación</title>

      <!--
      Assignment is performed with the operator =. It means "Take the
      right-hand side (often called the rvalue) and copy it into the
      left-hand side (often called the lvalue)." An rvalue is any
      constant, variable, or expression that can produce a value, but an
      lvalue must be a distinct, named variable (that is, there must be
      a physical space in which to store data). For instance, you can
      assign a constant value to a variable ( A = 4;), but you cannot
      assign anything to constant value - it cannot be an lvalue (you
      can't say 4 = A;).
      -->

      <para>
	La asignación se realiza mediante el operador =. Esto significa
	"Toma el valor de la derecha (a menudo llamado rvalue) y cópialo
	en la variable de la izquierda (a menudo llamado lvalue)." Un
	rvalue es cualquier constante, variable o expresión que pueda
	producir un valor, pero un lvalue debe ser una variable con un
	nombre distintivo y único (esto quiere decir que debe haber un
	espacio físico donde guardar la información). De hecho, se puede
	asignar el valor de una constante a una variable ( A = 4;), pero
	no se puede asignar nada a una constante - no puede ser un
	lvalue (no se puede escribir 4 = A;).
      </para>
    </sect2>


    <sect2>
      <!--Mathematical operators -->
      <title>Operadores matemáticos</title>

      <!--
      The basic mathematical operators are the same as the ones available
      in most programming languages: addition (+), subtraction (-),
      division (/), multiplication (*), and modulus (%; this produces the
      remainder from integer division). Integer division truncates the
      result (it doesn't round). The modulus operator cannot be used with
      floating-point numbers.
      -->

      <para>
    Los operadores matemáticos básicos son los mismos que están
    disponibles en la mayoría de los lenguajes de programación: adición
    (+), substracción (-), división (/), multiplicación (*), y resto (%;
    esto produce el resto de una división entera). La división entera
    altera el resultado (no lo redondea). El operador de resto no puede
    ser utilizado con números con punto flotante.
      </para>
    
      <!--
      C and C++ also use a shorthand notation to perform an operation
      and an assignment at the same time. This is denoted by an operator
      followed by an equal sign, and is consistent with all the
      operators in the language (whenever it makes sense). For example,
      to add 4 to the variable x and assign x to the result, you say: x
      += 4;.
      -->

      <para>
    Cy C++ también utilizan notaciones abreviadas para efectuar una
    operación y una asignación al mismo tiempo. Esto es denotado por un
    operador seguido de un signo igual, y es consistente con todos los
    operadores en el lenguaje (siempre que tenga sentido). Por ejemplo,
    para añadir 4 a la variable x y asignar x al resultado, se escribe:
    x += 4;.
      </para>

      <!--
      This example shows the use of the mathematical operators:
      -->

      <para>
	Este ejemplo muestra el uso de los operadores matemáticos:
      </para>

//: C03:Mathops.cpp

      <!--
      The rvalues of all the assignments can, of course, be much more complex.
      -->
      
      <para>
    Los rvalues de todas las asignaciones pueden, por supuesto, se mucho
    mas complejas.
      </para>

      <sect3>
	<!-- Introduction to preprocessor macros -->
	<title>Introducción a las macros del preprocesador</title>

	<!--
      Notice the use of the macro PRINT( ) to save typing (and typing
      errors!). Preprocessor macros are traditionally named with all
      uppercase letters so they stand out - you'll learn later that macros
      can quickly become dangerous (and they can also be very useful). 
	-->

	<para>
    Observar el uso de la macro PRINT( ) para ahorrar líneas (y errores
    de sintaxis!). Las macros de preprocesador se nombran
    tradicionalmente con todas sus letras en mayúsculas de modo que se
    distinguen - se aprenderá más adelante que las macros pueden
    tornarse peligrosas rápidamente (y también pueden ser muy útiles).
	</para>

      <!--
      The arguments in the parenthesized list following the macro name
      are substituted in all the code following the closing
      parenthesis. The preprocessor removes the name PRINT and
      substitutes the code wherever the macro is called, so the compiler
      cannot generate any error messages using the macro name, and it
      doesn't do any type checking on the arguments (the latter can be
      beneficial, as shown in the debugging macros at the end of the
      chapter).
      -->

	<para>
    Los argumentos dentro de la lista entre paréntesis que sigue al
    nombre de la macro son sustituidos en todo el código que sigue al
    paréntesis de cierre. El preprocesador elimina el nombre PRINT y
    sustituye el código en donde sea que la macro sea llamada, entonces
    el compilador no puede generar ningún mensaje de error al utilizar
    el nombre de la macro, y no realiza ninguna comprobación de sintaxis
    sobre los argumentos (lo último puede ser beneficioso, como se
    muestra en las macros de depuración al final del capítulo).
	</para>
      </sect3>
    </sect2>

    <sect2>
      <!-- Relational operators -->
      <title>Operadores relacionales</title>

      <!--
      Relational operators establish a relationship between the values
      of the operands. They produce a Boolean (specified with the bool
      keyword in C++) true if the relationship is true, and false if the
      relationship is false. The relational operators are: less than
      (<), greater than ( >), less than or equal to (<=), greater than
      or equal to (>=), equivalent ( ==), and not equivalent (!=). They
      may be used with all built-in data types in C and C++. They may be
      given special definitions for user-defined data types in C++
      (you'll learn about this in Chapter 12, which covers operator
      overloading).
      -->

      <para>
    Los operadores relacionales establecen una relación entre los
    valores de los operandos. Estos producen el Bolean (especificado con
    la palabra clave bool en C++) trae si la relación es verdadera, y
    false si la relación es falsa. Los operadores relacionales son:
    menor que (&lt;), mayor que (>), menor o igual a (&lt;=), mayor o igual a
    (>=), equivalente (==), y no equivalente ( !=). Pueden ser
    utilizados con todos los tipos de datos predefinidos en C y
    C++. Pueden darse definiciones especiales para tipos definidos por
    el usuario en C++ (se aprenderá acerca de ello en el Capítulo 12,
    que cubre la sobrecarga de operadores).
      </para>
    </sect2>

    <sect2>
      <!-- Logical operators -->
      <title>Operadores lógicos</title>

      <!--
      The logical operators and ( &&) and or (||) produce a true or
      false based on the logical relationship of its arguments. Remember
      that in C and C++, a statement is true if it has a non-zero value,
      and false if it has a value of zero. If you print a bool, you'll
      typically see a '1' for true and '0' for false.
      -->

      <para>
    Los operadores lógicos and (&amp;&amp;) y or (||) producen true o false
    basándose en la relación lógica de sus argumentos. Recordar que en C
    y C++, una condición es trae si tiene un valor diferente de cero, y
    false si vale cero. Si se imprime un bool, por lo general se verá un
    ' 1' para true y '0' para false.
      </para>

      <!--
    This example uses the relational and logical operators:
      -->

      <para>
    Este ejemplo utiliza los operadores relacionales y lógicos:
      </para>

//: C03:Boolean.cpp

      <!--
      You can replace the definition for int with float or double in the
      program above. Be aware, however, that the comparison of a
      floating-point number with the value of zero is strict; a number
      that is the tiniest fraction different from another number is
      still "not equal." A floating-point number that is the tiniest bit
      above zero is still true.
      -->

      <para>
      Se puede reemplazar la definición de int con flota o double en el
    programa anterior. De todos modos, advertirse de que la comparación
    de un número con punto flotante con el valor cero es estricto; un
    numero que es la fracción más pequeña diferente de otro número aún
    se considera "distinto de". Un número con punto flotante que es el
    bit mas pequeño antes de cero aún se considera verdadero.
      </para>
    </sect2>

    <sect2>
      <!--Bitwise operators-->
      <title>Operadores para bits</title>

      <!--
      The bitwise operators allow you to manipulate individual bits in a
      number (since floating point values use a special internal format,
      the bitwise operators work only with integral types: char, int and
      long). Bitwise operators perform Boolean algebra on the
      corresponding bits in the arguments to produce the result.
      -->

      <para>
    Los operadores de bits permiten manipular bits individuales y dar
    como salida un número (ya que los valores con punto flotante
    utilizan un formato interno especial, los operadores de bit sólo
    funcionan con tipos enteros: char, int y long). Los operadores de
    bit efectúan álgebra booleana en los bits correspondientes de los
    argumentos para producir el resultado.
      </para>
      
    <!--
    The bitwise and operator ( &) produces a one in the output bit if
    both input bits are one; otherwise it produces a zero. The bitwise
    or operator (|) produces a one in the output bit if either input bit
    is a one and produces a zero only if both input bits are zero. The
    bitwise exclusive or, or xor (^) produces a one in the output bit if
    one or the other input bit is a one, but not both. The bitwise not
    (~, also called the ones complement operator) is a unary operator -
    it only takes one argument (all other bitwise operators are binary
    operators ). Bitwise not produces the opposite of the input bit - a
    one if the input bit is zero, a zero if the input bit is one.
    -->

      <para>
    El operador de bit and (&amp;) produce uno en la salida si ambos bits de
    entrada valen uno; de otro modo produce un cero. El operador de bit
    or (|) produce un uno en la salida si cualquiera de los dos valores
    de entrada vale uno, y produce un cero solo si ambos valores de
    entrada son cero. El operador de bit or absoluto, o xor (^) produce
    uno en la salida si uno y otro valor de la entrada es uno, pero no
    ambos. El operador de bit not (~, también llamado operador de
    complemento a uno) es un operador unario - solo toma un argumento
    (todos los demás operadores son binarios). El operador de bit not
    produce el valor contrario a la entrada - uno si el bit de entrada
    es cero, y cero si el bit de entrada es uno.
      </para>

      <!--
      Bitwise operators can be combined with the = sign to unite the
      operation and assignment: &=, |=, and ^= are all legitimate
      operations (since ~ is a unary operator it cannot be combined with
      the = sign).
      -->

      <para>
	Los operadores de bit pueden combinarse con el signo = para unir
	la operación y la asignación: &amp;=, |=, y ^= son todas operaciones
	legales (dado que ~ es un operador unario no puede combinarse
	con el signo =).
      </para>
    </sect2>


    <sect2>
      <!-- Shift operators -->
      <title>Operadores de desplazamiento</title>

      <!--
    The shift operators also manipulate bits. The left-shift operator
    (<<) produces the operand to the left of the operator shifted to the
    left by the number of bits specified after the operator. The
    right-shift operator ( &gt;&gt;) produces the operand to the left of the
    operator shifted to the right by the number of bits specified after
    the operator. If the value after the shift operator is greater than
    the number of bits in the left-hand operand, the result is
    undefined. If the left-hand operand is unsigned, the right shift is
    a logical shift so the upper bits will be filled with zeros. If the
      left-hand operand is signed, the right shift may or may not be a
    logical shift (that is, the behavior is undefined).
      -->

<!--
   FIXME: (REVISA PORFA LA COHERENCIA DE ESTE TROZO QUE ES UN TRABALENGUAS!!!!!!!!!!!!!!!!)
-->

      <para>
    Los operadores de desplazamiento también manipulan bits. El operador
    de desplazamiento izquierdo (&lt;&lt;) produce el desplazamiento del
    operando a la izquierda del operador tantos bits a la izquierda como
    haya sido especificado por el número a la derecha del operador. El
    operador de desplazamiento derecho produce el desplazamiento del
    operando de la izquierda hacia la derecha tantos bits como haya sido
    especificado por el número a la derecha del operador. Si el valor
    que sigue al operador de desplazamiento es mayor que el número de
    bits del lado izquierdo, el resultado es indefinido. Si el operando
    de la izquierda no tiene signo, el desplazamiento derecho es un
    desplazamiento lógico de modo que los bits del principio serán
    rellenados con ceros. Si el operando de la izquierda tiene signo, el
    desplazamiento derecho puede o puede no ser un desplazamiento lógico
    (eso significa que el comportamiento es indeterminado). 
      </para>

      <!--
      Shifts can be combined with the equal sign (<<= and &gt;&gt;=) . The
      lvalue is replaced by the lvalue shifted by the rvalue.
      -->

      <para>
    Los desplazamientos pueden combinarse con el signo igual (&lt;&lt;= y
    &gt;&gt;=). El lvalue se reemplaza por lvalue desplazado por el rvalue.
      </para>

      <!--
      What follows is an example that demonstrates the use of all the
      operators involving bits. First, here's a general-purpose function
      that prints a byte in binary format, created separately so that it
      may be easily reused. The header file declares the function:
      -->

      <para>
    Lo que sigue a continuación es un ejemplo que demuestra el uso de
    todos los operadores que involucran bits. Primero, una función de
    propósitos generales que imprime un byte en formato binario, creada
    separadamente para que pueda ser fácilmente reutilizada. El fichero
    cabecera declara la función:
      </para>

//: C03:printBinary.h

      <!--
      Here's the implementation of the function:
      -->
 
      <para>
    A continuación la implementación de la función:
      </para>

//: C03:printBinary.cpp {O}

      <!-- 
      The printBinary( ) function takes a single byte and displays
      it bit-by-bit. The expression
      -->

      <para>
    La función printBinary( ) toma un único byte y lo muestra bit a
    bit. La expresión
      </para>

      <programlisting>
(1 &lt;&lt; i) 
</programlisting>

      <!--
      produces a one in each successive bit position; in binary:
      00000001, 00000010, etc. If this bit is bitwise anded with val and
      the result is nonzero, it means there was a one in that position
      in val.
      -->

      <para>
    produce uno en cada posición de bit sucesiva; en binario: 00000001,
    00000010, etc. Si el bit es tratado pasado por and con val y el
    resultado es diferente de cero, significa que había un uno en esa
    posición en val.
      </para>

      <!--
      Finally, the function is used in the example that shows the
      bit-manipulation operators:
      -->

      <para>
    Finalmente, la función se utiliza en el ejemplo que muestra los
    operadores de manipulación de bits:
      </para>

//: C03:Bitwise.cpp

      <!--
      Once again, a preprocessor macro is used to save typing. It prints
      the string of your choice, then the binary representation of an
      expression, then a newline.
      -->

      <para>
    Una vez más, una macro de preprocesador se utiliza para ahorrar
    líneas. Imprime la cadena elegida, y luego la representación binaria
    de una expresión, y luego una nueva línea. 
      </para>

      <!--
      In main( ), the variables are unsigned. This is because, in
      general, you don't want signs when you are working with bytes. An
      int must be used instead of a char for getval because the " cin
      >>" statement will otherwise treat the first digit as a
      character. By assigning getval to a and b, the value is converted
      to a single byte (by truncating it).
      -->

      <para>
    En main(), las variables son unsigned. Esto es porque, en general,
    no se desean signos cuando se trabaja con bytes. Un int debe ser
    utilizado en vez de un char para getval porque la sentencia "cin &gt;&gt;"
    de otro modo trataría el primer dígito como un carácter. Asignando
    getval a a y b, el valor se convierte a un solo byte (alterándolo).
      </para>

      <!--
      The << and >> provide bit-shifting behavior, but when they shift
      bits off the end of the number, those bits are lost (it's commonly
      said that they fall into the mythical bit bucket, a place where
      discarded bits end up, presumably so they can be reused...). When
      manipulating bits you can also perform rotation, which means that
      the bits that fall off one end are inserted back at the other end,
      as if they're being rotated around a loop. Even though most
      computer processors provide a machine-level rotate command (so
      you'll see it in the assembly language for that processor), there
      is no direct support for "rotate" in C or C++. Presumably the
      designers of C felt justified in leaving "rotate" off (aiming, as
      they said, for a minimal language) because you can build your own
      rotate command. For example, here are functions to perform left
      and right rotations:
      -->

      <para>
    El &lt;&lt; y &gt;&gt; proporcionan un comportamiento de desplazamiento de bits, pero
    cuando desplazan bits que están al final del número, estos bits se
    pierden (comúnmente se dice que se caen en el mítico cubo de bits,
    un lugar donde los bits descartados acaban, presumiblemente para que
    puedan ser utilizados...). Cuando de manipulan bits también se puede
    realizar rotación, lo que significa que los bits que se salen de uno
    de los extremos pueden ser insertados en el otro extremo, como si
    estuviesen rotando en un bucle. Aunque la mayoría de los
    procesadores de ordenadores proveen de un comando de rotación a
    nivel máquina (que se puede ver en el lenguaje ensamblador de ese
    procesador), no hay un soporte directo para "rotate" en C o
    C++. Presumiblemente los diseñadores de C vieron justificado el
    hecho de prescindir de "rotate" (en pro, como dijeron, de un
    lenguaje minimalista) ya que se puede construir un comando rotate
    propio. Por ejemplo, a continuación hay funciones para realizar
    rotaciones a izquierda y derecha:
      </para>

//: C03:Rotation.cpp {O}

      <!--
      Try using these functions in Bitwise.cpp. Notice the definitions (or
      at least declarations) of rol( ) and ror( ) must be seen by the
      compiler in Bitwise.cpp before the functions are used.
      -->

      <para>
    Al intentar utilizar estas funciones en Bitwise.cpp, notar que las
    definiciones (o cuando menos las declaraciones) de rol( ) y ror( )
    deben ser vistas por el compilador en Bitwise.cpp antes de que las
    funciones sean utilizadas.
      </para>

      <!--
      The bitwise functions are generally extremely efficient to use
      because they translate directly into assembly language
      statements. Sometimes a single C or C++ statement will generate a
      single line of assembly code.
      -->

      <para>
    L as funciones de tratamiento de bits son por lo general de uso
    extremadamente eficientes ya que traducen directamente las
    sentencias a lenguaje ensamblador. A veces una simple sentencia en C
    o C++ generara una simple línea de código ensamblador.
      </para>
    </sect2>


    <sect2>
      <!--Unary operators -->
      <title>Operadores unarios</title>

      <!--
      Bitwise not isn't the only operator that takes a single
      argument. Its companion, the logical not (!), will take a true
      value and produce a false value. The unary minus (-) and unary
      plus (+) are the same operators as binary minus and plus; the
      compiler figures out which usage is intended by the way you write
      the expression. For instance, the statement
      -->

      <para>
    not no es el único operador de bit que toma un solo argumento. Su
    compañero, el not lógico (!), tomará un valor trae y producirá un
    valor false. El menos unario (-)  y el más unario (+)  son los
    mismos operadores que los binarios menos y mas; el compilador deduce
    que uso se le pretende dar por el modo en el que se escribe la
    expresión. De hecho, la sentencia
      </para>

      <programlisting>
x = -a;
</programlisting>

      <!--
      has an obvious meaning. The compiler can figure out:
      -->

      <para>
    tiene un significado obvio. El compilador puede deducir:
      </para>

      <programlisting>
x = a * -b;
</programlisting>

      <!--
      but the reader might get confused, so it is safer to say:
      -->

      <para>
    pero el lector puede confundirse, de modo que es mas seguro escribir:
      </para>

      <programlisting>
x = a * (-b);
</programlisting>

      <!--
      The unary minus produces the negative of the value. Unary plus
      provides symmetry with unary minus, although it doesn't actually
      do anything.
      -->

      <para>
    El menos unario produce el valor contrario. El mas unario provee
    simetría con el menos unario, aunque en realidad no hace nada.
      </para>

      <!-- 
      The increment and decrement operators (++ and ) were
      introduced earlier in this chapter. These are the only operators
      other than those involving assignment that have side effects
      . These operators increase or decrease the variable by one unit,
      although "unit" can have different meanings according to the data
      type - this is especially true with pointers.
      -->

      <para>
    Los operadores de incremento y decremento (++ y --) fueron
    introducidos antes en este capítulo. Estos son los únicos
    operadores, además de los que involucran asignación, que tienen
    efectos colaterales. Estos operadores incrementan o decrementan la
    variable en una unidad, aunque "unidad" puede tener diferentes
    significados dependiendo del tipo de datos - esto es especialmente
    cierto en el caso de los punteros.
      </para>
      
      <!--
      The last unary operators are the address-of (&), dereference (*
      and ->), and cast operators in C and C++, and new and delete in
      C++. Address-of and dereference are used with pointers , described
      in this chapter. Casting is described later in this chapter, and
      new and delete are introduced in Chapter 4.
      -->

      <para>
    Los últimos operadores unarios son la dirección-de (&amp;), deferencia
    (* y ->), y operadores de moldeo en C y C++, y new y delete en
    C++. La dirección-de y la deferencia se utilizan con los punteros,
    descriptos en este capítulo. El moldeo se describe mas adelante en
    este capítulo, y new y delete son introducidos en el Capítulo 4. 
      </para>
    </sect2>


    <sect2>
      <!--The ternary operator-->
      <title>El operador ternario</title>

      <!--
      The ternary if-else is unusual because it has three operands. It
      is truly an operator because it produces a value, unlike the
      ordinary if-else statement. It consists of three expressions: if
      the first expression (followed by a ?) evaluates to true, the
      expression following the ? is evaluated and its result becomes the
      value produced by the operator. If the first expression is false,
      the third expression (following a :) is executed and its result
      becomes the value produced by the operator.
      -->

      <para>
      El ternario if-else es inusual porque tiene tres operandos. Es
      verdaderamente un operador porque produce un valor, al contrario
      de la sentencia ordinaria if-else. Consiste en tres expresiones:
      si la primera expresión (seguida de un ?) evalúa a true, la
      expresión que sigue el ? se evalúa y su resultado se vuelve el
      valor producido por el operados. Si la primera expresión es false,
      la tercera expresión (que sigue a :) se ejecuta y su resultado se
      convierte en el valor producido por el operador.
      </para>

      <!--
      The conditional operator can be used for its side effects or for
      the value it produces. Here's a code fragment that demonstrates
      both:
      -->

      <para>
      El operador condicional puede usarse por sus efectos colaterales o
      por el valor que produce. A continuación un fragmento de código
      que demuestra ambas cosas:
      </para>      

      <programlisting>
a = --b ? b : (b = -99);
</programlisting>

      <!--
      Here, the conditional produces the rvalue. a is assigned to the
      value of b if the result of decrementing b is nonzero. If b became
      zero, a and b are both assigned to -99. b is always decremented,
      but it is assigned to -99 only if the decrement causes b to become
      0. A similar statement can be used without the "a =" just for its
      side effects:
      -->

      <para>
      Aquí, el condicional produce el rvalue. a es asignado al valor de
      b si el resultado de decrementar b es diferente de cero. Si b se
      queda a cero, a y b son ambas asignadas a -99. b siempre se
      decrementa, pero se asigna a -99 solo si el decremento provoca que
      b valga 0. Una sentencia similar puede utilizarse sin la "a ="
      solo por sus efectos colaterales:
      </para>

      <programlisting>
--b ? b : (b = -99);
</programlisting>

      <!--
      Here the second B is superfluous, since the value produced by the
      operator is unused. An expression is required between the ? and
      :. In this case, the expression could simply be a constant that
      might make the code run a bit faster.
      -->

      <para>
      Aquí la segunda B es superflua, ya que el valor producido por el
      operador no se utiliza. Una expresión es requerida entre el ? y
      :. En este caso, la expresión puede simplemente ser una constante
      que puede hacer que el código se ejecute un poco más rápido.
      </para>      
    </sect2>

    <sect2>
      <!--The comma operator-->
      <title>El operador coma</title>

      <!--
      The comma is not restricted to separating variable names in
      multiple definitions, such as
      -->

      <para>
      La coma no se restringe a separar nombres de variables en
      multiples definiciones, tales como
      </para>

      <programlisting>
int i, j, k;
</programlisting>
    
      <!--
      Of course, it's also used in function argument lists. However, it
      can also be used as an operator to separate expressions - in this
      case it produces only the value of the last expression. All the
      rest of the expressions in the comma-separated list are evaluated
      only for their side effects. This example increments a list of
      variables and uses the last one as the rvalue:
      -->

      <para>
    Por supuesto, también se usa en listas de argumentos de
    funciones. De todos modos, puede también utilizarse como un operador
    para separar expresiones - en este caso produce solo el valor de la
    última expresión. El resto de expresiones en la lista separada por
    comas es evaluada solo por sus efectos colaterales. Este ejemplo
    incrementa una lista de variables y usas la última como el rvalue:
      </para>

//: C03:CommaOperator.cpp

      <!-- 
      In general, it's best to avoid using the comma as anything
      other than a separator, since people are not used to seeing it as
      an operator.
      -->

      <para>
    En general, es mejor evitar el uso de la coma como cualquier cosa
    mas que para separar, ya que la gente no está acostumbrada a verla
    como un operador. 
      </para>
    </sect2>


    <sect2>
      <!--Common pitfalls when using operators-->
      <title>Trampas habituales cuando se usan operadores</title>

      <!--
      As illustrated above, one of the pitfalls when using operators is
      trying to get away without parentheses when you are even the least
      bit uncertain about how an expression will evaluate (consult your
      local C manual for the order of expression evaluation).
      -->

      <para>
      Como se ha ilustrado anteriormente, una de las trampas al usar
      operadores es tratar de trabajar aún cuando se está mínimamente
    inseguro de cómo una expresión va a ser evaluada (consultar el
    manual local de C para el orden de la evaluación de una expresión).
      </para>

      <!--
      Another extremely common error looks like this:
      -->

      <para>
    Otro error extremadamente común se ve como el que sigue:
      </para>

//: C03:Pitfall.cpp

      <!--
      The statement a = b will always evaluate to true when b is
      non-zero. The variable a is assigned to the value of b, and the
      value of b is also produced by the operator =. In general, you
      want to use the equivalence operator == inside a conditional
      statement, not assignment. This one bites a lot of programmers
      (however, some compilers will point out the problem to you, which
      is helpful).
      -->

      <para>
    La sentencia a = b siempre se va a evaluar como cierta cuando b es
    distinta de cero. La variable a es asignada al valor de b, y el
    valor de b es incluso producido por el operador =. En general, se
    desea utilizar el operador de equivalencia dentro de una sentencia
    condicional, no la asignación. Esto le ocurre a muchos programadores
    (de todos modos, algunos compiladores señalaran el problema, lo que
    es de ayuda).
      </para>

      <!--
      A similar problem is using bitwise and and or instead of their
      logical counterparts. Bitwise and and or use one of the characters
      (& or |), while logical and and or use two (&& and ||). Just as
      with = and ==, it's easy to just type one character instead of
      two. A useful mnemonic device is to observe that "Bits are
      smaller, so they don't need as many characters in their
      operators."
      -->

      <para>
      Un problema similar es el uso del operador de bit and y or en
      lugar de sus colegas lógicos. Los operadores de bit and y or usan
      uno de los caracteres (&amp; o |), mientras que los operadores lógicos
      and y or utilizan dos (&amp;&amp; y ||). Al igual que con = y ==, es fácil
      escribir simplemente un carácter en vez de dos. Una forma muy
      fácil de observar esto es que "los bits son mas pequeños, de modo
      que no necesitan tantos caracteres en sus operadores".
      </para>
    </sect2>

    <sect2>
      <!--Casting operators-->
      <title>Operadores de moldeado</title>

      <!--
      The word cast is used in the sense of "casting into a mold." The
      compiler will automatically change one type of data into another
      if it makes sense. For instance, if you assign an integral value
      to a floating-point variable, the compiler will secretly call a
      function (or more probably, insert code) to convert the int to a
      float. Casting allows you to make this type conversion explicit,
      or to force it when it wouldn't normally happen.
      -->

      <para>
    La palabra molde se usa en el sentido de "colocar dentro de un
    molde". El compilador cambiara automáticamente un tipo de dato a
    otro si esto tiene sentido. De hecho, si se asigna un valor entero a
    una variable de punto flotante, el compilador llamara secretamente a
    una función (o mas probablemente, insertará código) para convertir
    el int a un float. El moldeo permite hacer este tipo de conversión
    explicita, o forzarla cuando normalmente no pasaría.
      </para>

      <!--
      To perform a cast, put the desired data type (including all
      modifiers) inside parentheses to the left of the value. This value
      can be a variable, a constant, the value produced by an
      expression, or the return value of a function. Here's an example:
      -->

      <para>
    Para realizar un moldeo, se debe situar el tipo deseado (incluyendo
    todos los modificadores) dentro del paréntesis a la izquierda del
    valor. Este valor puede ser una variable, una constante, el valor
    producido por una expresión, o el valor retornado por una función. A
    continuación un ejemplo:
      </para>

//: C03:SimpleCast.cpp

      <!--
      Casting is powerful, but it can cause headaches because in some
      situations it forces the compiler to treat data as if it were (for
      instance) larger than it really is, so it will occupy more space
      in memory; this can trample over other data. This usually occurs
      when casting pointers, not when making simple casts like the one
      shown above.
      -->

      <para>
      El moldeo es poderoso, pero puede causar dolores de cabeza porque
      en algunas situaciones fuerza al compilador a tratar datos como si
      estos fuesen (por instancia) más largos de lo que realmente son,
      de modo que ocupará más espacio en memoria; esto puede repercutir
      en otros datos. Esto a menudo ocurre cuando se moldean punteros, y
      no cuando se hacen moldeos simples como los anteriores mostrados.
      </para>

      <!--
      C++ has an additional casting syntax, which follows the function
      call syntax. This syntax puts the parentheses around the argument,
      like a function call, rather than around the data type:
      -->

      <para>
    C++ tiene una sintaxis de moldeo adicional, que sigue a la sintaxis
    de la llamada a funciones. Esta sintaxis ubica el paréntesis
    alrededor del argumento, como en una llama a una función,
    preferiblemente a ubicarla alrededor del tipo de dato:
      </para>

//: C03:FunctionCallCast.cpp
    
      <!--
      Of course in the case above you wouldn't really need a cast; you
      could just say 200.f or 200.0f(in effect, that's typically what
      the compiler will do for the above expression). Casts are
      generally usually used instead with variables, rather than with
      constants.
      -->

      <para>
	Por supuesto en el caso anterior en realidad no se necesitaría
	un moldeo; simplemente se puede decir 200.f o 200.0f (en efecto,
	esto es típicamente lo que el compilador hará para la expresión
	anterior). Los moldeos son usualmente utilizados preferiblemente
	con variables, en lugar de con constantes.
      </para>
    </sect2>


    <sect2>
      <title>Los moldes explícitos de C++</title>
      <para>
      </para>

      <sect3>
	<title>Molde estático (static_cast)</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Molde constante (static_const)</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>FIXME (reinterpret_cast)</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title><oper>sizeof</oper> - un operador en si mismo</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>La palabra reservada <kw>asm</kw></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores explícitos</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Creación de tipos compuestos</title>
    <para>
    </para>
    
    <sect2>
      <title>Operadores explícitos</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Creación de alias usando <kw>typedef</kw></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>
	Combinación de variables por medio de  <kw>struct</kw>
      </title>
      <para>
      </para>
      <sect3>
	<title>Punteros y estructuras</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Programas más claros gracias a <kw>enum</kw></title>
      <para>
      </para>

      <sect3>
	<title>Comprobación de tipos para las enumeraciones</title>
	<para>
	</para>
      </sect3>
    </sect2>


    <sect2>
      <title>Cómo Ahorrar memoria con <kw>union</kw></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Arrays</title>
      <para>
      </para>

      <sect3>
	<title>Punteros y arrays</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>El formato de punto flotante</title>
	<!-- Exploring floating-point format -->
	<para>
	</para>
      </sect3>

     <sect3>
	<title>Aritmética de punteros</title>
	<para>
	</para>
      </sect3>

    </sect2>
  </sect1>


  <sect1>
    <title>FIXME: Debugging hints</title>
    <para>
    </para>

    <sect2>
      <title>Opciones para depuración</title>
      <para>
      </para>

      <sect3>
	<title>Opciones de depuración para el preprocesador</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Opciones de depuración en tiempo de ejecución</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <!-- Turning variables and expressions into strings -->
      <title>Convertir variables y expresiones en cadenas</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>La macro C assert()</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Direcciones de función</title>
    <para>
    </para>

    <sect2>
      <title>Definición de un puntero a función</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Declaraciones y definiciones complicadas</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Uso de un puntero a función</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Arrays de punteros a funciones</title>
      <para>
      </para>
    </sect2>
  </sect1>


  <sect1>
    <title>Make: cómo hacer compilación separada</title>
    <para>
    </para>

    <sect2>
      <title>Las actividades de Make</title>
      <para>
      </para>

      <sect3>
	<title>Macros</title>
	<para>
	</para>
      </sect3>


      <sect3>
	<title>Reglas de sufijo</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Objetivos por defecto</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Los Makefiles de este libro</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Un ejemplo de Makefile</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para>
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>
    <xi:include parse="xml" href="./ejercicios.xml"/>

    <para>
    </para>
  </sect1>
</chapter>

