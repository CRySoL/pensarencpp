<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:               Emacs 21/PSGML
  Traducción original: 
  Formateado DocBook:  
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C3">

  <title>El C en C++</title>

  <!-- 
  Since C++ is based on C, you must be familiar with the syntax of
  C in order to program in C++, just as you must be reasonably fluent in
  algebra in order to tackle calculus.
  -->

  <!-- [PAG:121] -->
  <para>
    Dado que C++ está basado en C, debe estar familiarizado
    con la sintaxsis de C programar adecuadamente en C++, del mismo modo
    que debe tener una fluidez razonable en algebra para poder abordar
    el cálculo.
  </para>


  <!--
  If you??ve never seen C before, this chapter will give you a decent
  background in the style of C used in C++. If you are familiar with the
  style of C described in the first edition of Kernighan & Ritchie
  (often called K&R C), you will find some new and different features in
  C++ as well as in Standard C. If you are familiar with Standard C, you
  should skim through this chapter looking for features that are
  particular to C++. Note that there are some fundamental C++ features
  introduced here, which are basic ideas that are akin to the features
  in C or often modifications to the way that C does things. The more
  sophisticated C++ features will not be introduced until later
  chapters.
  -->

  <!-- [PAG:122] -->
  <para>
    Si nunca antes ha visto C, este capítulo le dará una buena base
    sobre el estilo de C usado en C++. Si está familiarizado con el
    estilo de C descrito en la primera edición de Kernighan &amp;
    Ritchie (también llamado K&amp;R) encontrará algunas
    características nuevas o diferentes tanto en C++ como en el
    estándar C. Si está familiarizado con el estándar C debería
    echar un vistazo al capítulo en busca de las carasterísticas
    particulares de C++. Note que hay algunas características
    fundamentales de C++ que se introducen aquí, que son ideas
    básicas parecidas a características de C o a menudo
    modificaciones en el modo en que C hace las cosas. Las
    características más sofisticadas de C++ serán introducidas en
    capítulos posteriores
  </para> 
  

  <!--
  This chapter is a fairly fast coverage of C constructs and
  introduction to some basic C++ constructs, with the understanding that
  you??ve had some experience programming in another language. A more
  gentle introduction to C is found in the CD ROM packaged in the back
  of this book, titled Thinking in C: Foundations for Java & C++ by
  Chuck Allison (published by MindView, Inc., and also available at
  www.MindView.net). This is a seminar on a CD ROM with the goal of
  taking you carefully through the fundamentals of the C language. It
  focuses on the knowledge necessary for you to be able to move on to
  the C++ or Java languages rather than trying to make you an expert in
  all the dark corners of C (one of the reasons for using a higher-level
  language like C++ or Java is precisely so we can avoid many of these
  dark corners). It also contains exercises and guided solutions. Keep
  in mind that because this chapter goes beyond the Thinking in C CD,
  the CD is not a replacement for this chapter, but should be used
  instead as a preparation for this chapter and for the book.
  -->
  
  <para>
    Este capítulo trata por encima las construciones de C e
    introduce algunas construcciones básicas de C++, suponiendo que
    tiene alguna experiencia programando en otro lenguaje. En el
    CD-ROM que acompaña a este libro hay una introducción más
    suave[FIXME:gentle] a C, titulada <emphasis>Thinking iC:
      Foundations for Java &amp; C++</emphasis> por Chuck Alison
    (publicada por MidView, Inc. y disponible también en <ulink
      url="www.MindView.net"></ulink>). Se trata de un seminario en
    CD-ROM que persigue el objetivo de guiarle cuidadosamente a
    través de los fundamentos del lenguaje C. Se concentra en el
    conocimiento necesario que le permita pasarse a C++ o a Java en
    lugar de intentar convertirle en un experto en todos los oscuros
    recovecos de C (una de las razones para usar un lenguaje de alto
    nivel como C++ o Java es precisamente evitar muchos de estos
    recovecos). También contiene ejercicios y soluciones
    guiadas. Tenga presente que este capítulo va después del CD
    <emphasis>Thinking in C</emphasis>, el CD no reemplaza a este
    capítulo, sino que debería tomarse como una preparación para
    este capítulo y para el libro.
  </para>
  



  <sect1>

    <!-- Creating functions -->
    <title>Creación de funciones</title>
    
    <!--
    In old (pre-Standard) C, you could call a function with any number
    or type of arguments and the compiler wouldn??t complain. Everything
    seemed fine until you ran the program. You got mysterious results
    (or worse, the program crashed) with no hints as to why. The lack of
    help with argument passing and the enigmatic bugs that resulted is
    probably one reason why C was dubbed a ??high-level assembly
    language.?? Pre-Standard C programmers just adapted to it.
    -->

    <para>
      En el antiguo C (previo al estándar), se podía invocar una función
      con cualquier número y tipo de argumentos sin que el compilador se
      quejase. Todo se veía bien hasta que ejecutabas el programa. El
      programa acababa con resultados misteriosos (o peor, el programa
      fallaba) sin ninguna pista de las razones. La falta de ayuda
      acerca del paso de argumentos y los enigmáticos bugs que
      resultaban es, probablemente, la causa de que C se considerase
      <quote>un lenguaje ensamblador de alto nivel</quote>. Los
      programadores de pre-Standard C simplemente se adaptaron a ello.
    </para>
    <!-- [PAG:123] -->

    <!--
    Standard C and C++ use a feature called function prototyping. With
    function prototyping, you must use a description of the types of
    arguments when declaring and defining a function. This description
    is the ??prototype.?? When the function is called, the compiler uses
    the prototype to ensure that the proper arguments are passed in and
    that the return value is treated correctly. If the programmer makes
    a mistake when calling the function, the compiler catches the
    mistake.
    -->
    
    <para>
      Standard C y C++ usan una herramienta llamada prototipado de
      funciones. Con esta herramienta se ha de describir los tipos de
      argumentos al declarar y definir una función. Esta descripción es
      el ??prototipo??. Cuando la función es llamada, el compilador usa
      el ??prototipo??. Cuando la función es llamada, el compilador usa
      el prototipo para asegurarse de que los argumentos pasados sean
      los apropiados, y de que el valor retornado sea tratado
      correctamente. Si el programador comete un error al llamar a la
      función, entonces el compilador detecta el error.
    </para>
 
    <!-- 
    Essentially, you learned about function prototyping (without
    naming it as such) in the previous chapter, since the form of
    function declaration in C++ requires proper prototyping. In a
    function prototype, the argument list contains the types of
    arguments that must be passed to the function and (optionally for
    the declaration) identifiers for the arguments. The order and type
    of the arguments must match in the declaration, definition, and
    function call. Here??s an example of a function prototype in a
    declaration:
    -->

    <para>
      Escencialmente, ha aprendido acerca del prototipado de funciones
      (sin llamarlas de ese modo) en el capítulo previo, ya que la forma
      de declararlas en C++ requiere de un prototipazo apropiado. En un
      prototipo de función, la lista de argumentos contiene los tipos de
      argumentos que deben ser pasados a la función y (opcionalmente
      para la declaración), identificadores para los argumentos. El
      orden y tipo de los argumentos debe coincidir en la declaración,
      definición y llamada a la función. A continuación se muestra un
      ejemplo de un prototipo de función en una declaración: 
    </para>

    int translate(float x, float y, float z);

    <!-- 
    You do not use the same form when declaring variables in function
    prototypes as you do in ordinary variable definitions. That is, you
    cannot say: float x, y, z. You must indicate the type of each
    argument. In a function declaration, the following form is also
    acceptable:
    -->
    
    <para>
      Las declaraciones de variables en prototipos de funciones se hacen
      al declarer variables ordinaries. Esto significa que no se puede
      declarar float x, y, z. Se debe indicar el tipo de cada
      argumento. En una declaración de función, lo siguiente también es
      correcto:
    </para>

    int translate(float, float, float);


    <!--
    Since the compiler doesn??t do anything but check for types when the
    function is called, the identifiers are only included for clarity
    when someone is reading the code.

    In the function definition, names are required because the arguments
    are referenced inside the function:
    -->

    <para>
      Ya que el compilador no hace más que chequear los tipos cuando la
      función es llamada, los identificadores se incluyen solamente para
      propiciar la legibilidad del código cuando alguien lo está
      leyendo.  
    </para>
    <para>
      En la definición, los nombres son necesarios ya que los argumentos
      son referenciados dentro de la función:
    </para>

    int translate(float x, float  y, float z) { x = y = z; // ...  }

    
    <!--
    It turns out this rule applies only to C. In C++, an argument may be
    unnamed in the argument list of the function definition. Since it is
    unnamed, you cannot use it in the function body, of course. Unnamed
    arguments are allowed to give the programmer a way to ??reserve
    space in the argument list.?? Whoever uses the function must still
    call the function with the proper arguments. However, the person
    creating the function can then use the argument in the future
    without forcing modification of code that calls the function. This
    option of ignoring an argument in the list is also possible if you
    leave the name in, but you will get an annoying warning message
    about the value being unused every time you compile the
    function. The warning is eliminated if you remove the name.
    -->

    <para>
      Esta regla sólo se aplica a C. En C++, un argumento puede no ser
      nombrado en la lista de argumentos de la definición de la
      función. Ya que no es nombrado, no es posible utilizarlos en el
      cuerpo de la función, por supuesto. Los argumentos no nombrados se
      permiten para dar al programador una manera de ??reservar espacio
      en la lista de argumentos??. De cualquier modo, la persona que
      crea la función aún así debe de llamar a la función con los
      parametros apropiados. Igualmente, la persona que crea la función
      puede así utilizar el argumento en el futuro sin forzar una
      modificación en el codigo que llama a la función. Esta opción de
      ignorar un argumento en la lista es también posible si se indica
      el nombre, pero siempre aparecería un molesto mensaje de
      advertencia informando que el valor no se utiliza cada vez que se
      compilase la función. La advertencia es eliminada si se quita el
      nombre de dicho argumento.
    </para>

    <!--
    C and C++ have two other ways to declare an argument list. If you
    have an empty argument list, you can declare it as func( ) in C++,
    which tells the compiler there are exactly zero arguments. You
    should be aware that this only means an empty argument list in
    C++. In C it means ??an indeterminate number of arguments (which is
    a ??hole?? in C since it disables type checking in that case). In
    both C and C++, the declaration func(void); means an empty argument
    list. The void keyword means ??nothing?? in this case (it can also
    mean ??no type??in the case of pointers, as you??ll see later in
    this chapter).
    -->

    <para>
      C y C++ tienen otras dos maneras de declarar una lista de
      argumentos. Si se tiene una lista de argumentos vacia, se puede
      declarar esta como func( ) en C++, lo que indica al compilador de
      que hay exactamente cero agumentos. Hay que tener en cuenta que
      esto solo significa una lista de argumentos vacía en C++. Al
      contrario, en C significa ??un número indeterminado de argumentos??
      (lo que es un ??agujero?? en C ya que desabilita la comprobación
      de tipos en este caso). En ambos, C y C++, la declaracion
      func(void); significa una lista de argumentos vacía. La palabra
      clave void significa ??nada?? en este caso (también puede
      significar ??sin tipo?? en el caso de los punteros, como se verá
      mas adelante en este capítulo).
    </para>

    <!--
    The other option for argument lists occurs when you don??t know how
    many arguments or what type of arguments you will have; this is
    called a variable argument list. This ??uncertain argument list?? is
    represented by ellipses (...). Defining a function with a variable
    argument list is significantly more complicated than defining a
    regular function. You can use a variable argument list for a
    function that has a fixed set of arguments if (for some reason) you
    want to disable the error checks of function prototyping. Because of
    this, you should restrict your use of variable argument lists to C
    and avoid them in C++ (in which, as you??ll learn, there are much
    better alternatives). Handling variable argument lists is described
    in the library section of your local C guide.
    -->
    
    <para>
      La otra opción para las listas de argumentos ocurre cuando no se
      sabe cuantos argumentos o qué tipo de argumentos se tendrán; esto
      lleva el nombre de lista de argumentos variable. Esta ??lista
      incierta de agumentos?? es representada con elipses (??). Definir
      una función con una lista de argumentos variable es
      significativamente mas complicado que definir una función
      regular. Se puede utilizar una lista de argumentos variables para
      una función que tiene un grupo de argumentos fijos si (por alguna
      razón) se quiere desabilitar los controles de error del propotipo
      de funciones. Debido a esto, se debe restringir el uso de listas
      de argumentos variables en C y evitarlas en C++ (en el cual, como
      se aprenderá, hay alternativas mucho mejores). El manejo de listas
      de argumentos variables se describe en la sección de librerias de
      la guía local de C.
    </para>


    <sect2>
      <!--Function return values-->
      <title>Valores de retorno de las funciones</title>

      <!--
      A C++ function prototype must specify the return value type of the
      function (in C, if you leave off the return value type it defaults
      to int). The return type specification precedes the function
      name. To specify that no value is returned, use the void
      keyword. This will generate an error if you try to return a value
      from the function. Here are some complete function prototypes:
      -->

      <para>
        Un prototipo de función en C++ debe especificar el tipo de valor
        devuelto de la función (en C, si no se especifica será por
        defecto un int). La especificación del tipo de retorno precede
        al nombre de la función. Para especificar que ningún valor es
        devuelto, se utiliza la palabra clave void. Esto generara un
        error si se intenta devolver un valor desde la función. A
        continuación hay algunos prototipos completos de funciones:
      </para>

int f1(void); // Returns an int, takes no arguments
//Retorna un entero, no tiene argumentos 
int f2(); // Like f1() in C++ but not in Standard C!
//al igual que f1() en C++ pero no en C Stantard
float f3(float, int, char, double); // Returns a float
//Devuelve un real
void f4(void); // Takes no arguments, returns nothing
//No tiene argumentos, no retorna nada

      <!--
      To return a value from a function, you use the return
      statement. return exits the function back to the point right after
      the function call. If return has an argument, that argument
      becomes the return value of the function. If a function says that
      it will return a particular type, then each return statement must
      return that type. You can have more than one return statement in a
      function definition:
      -->

      <para>
        Para devolver un valor desde una función, se utiliza la
        sentencia return. Esta sentencia sale de la función y salta
        hasta la sentencia que se halla justo después de la llamada a la
        función. Si return tiene un arguemento, éste se convierte en el
        valor de retorno de la función. Si una función indica que
        retornara un tipo en particular, entonces cada sentencia return
        debe retornar este tipo. Se puede tener mas de una sentencia
        return en una definición de función:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Return.cpp"/>
</programlisting>


      <!--
      In cfunc( ), the first if that evaluates to true exits the
      function via the return statement. Notice that a function
      declaration is not necessary because the function definition
      appears before it is used in main( ), so the compiler knows about
      it from that function definition.
      -->

      <para>
        En <function>Cfunc()</function>, el primer if que evalua que la
        condición sea true sale de la función via la sentencia
        return. Notar que no es necesaria la declaración de la función
        puesto que la definición de la función aparece antes de ser
        utilizada en main( ), de modo que el compilador sabe de su
        existencia desde dicha definición.
      </para>

    </sect2>

    <sect2>
      <title>Uso de funciones de librerías C</title>

      <!--
      All the functions in your local C function library are available
      while you are programming in C++. You should look hard at the
      function library before defining your own function ? there??s a
      good chance that someone has already solved your problem for you,
      and probably given it a lot more thought and debugging.
      -->
      
      <para>
        Todas las funciones en la librería local de funciones de C están
        disponibles mientras se está programando en C++. Se debería
        buscar bien esta función en la librería antes de definir una
        propia ? hay muchas probabilidades de que alguien haya resuelto
        el problema antes, y probablemente haya dedicado mas tiempo
        pensando y depurando.
      </para>

      <!--
      A word of caution, though: many compilers include a lot of extra
      functions that make life even easier and are tempting to use, but
      are not part of the Standard C library. If you are certain you
      will never want to move the application to another platform (and
      who is certain of that?), go ahead ?use those functions and make
      your life easier. If you want your application to be portable, you
      should restrict yourself to Standard library functions. If you
      must perform platform-specific activities, try to isolate that
      code in one spot so it can be changed easily when porting to
      another platform. In C++, platform-specific activities are often
      encapsulated in a class, which is the ideal solution.
      -->

      <para>
        Una advertencia, igualmente: muchos compiladores incluyen muchas
        funciones extra que hacen la vida mucho mas fácil y son
        tentadoras de usar, pero no son parte de la libreria de C
        Standard. Si se está seguro de que jamás se deseará mover la
        aplicación a otra plataforma (¿y quién está seguro de ello?),
        adelante ?utilizad estas funciones y haceros la vida mas
        fácil. Si se desea que la aplicación pueda migrarse, se debería
        restringir el uso de funciones a las de la libreria Standard
        únicamente. Si se debe realizar actividades específicas de la
        plataforma, se debería intentar aislar este codigo de tal modo
        que pueda cambiarse fácilmente al ser migrado a otra
        plataforma. En C++, las actividades de una plataforma específica
        son a menudo encapsuladas en una clase, lo que es la solución
        ideal.
      </para>

      <!--
      The formula for using a library function is as follows: first,
      find the function in your programming reference (many programming
      references will index the function by category as well as
      alphabetically). The description of the function should include a
      section that demonstrates the syntax of the code. The top of this
      section usually has at least one #include line, showing you the
      header file containing the function prototype. Duplicate this
      #include line in your file so the function is properly
      declared. Now you can call the function in the same way it appears
      in the syntax section. If you make a mistake, the compiler will
      discover it by comparing your function call to the function
      prototype in the header and tell you about your error. The linker
      searches the Standard library by default, so that??s all you need
      to do: include the header file and call the function.
      -->
      
      <para>
        La fórmula para usar una librería de funciones es la siguiente:
        primero, encotrar la función en la referencia de programación
        (muchas referencias de programación ordenan las funciones por
        categoría antes que alfabéticamente). La descripción de la
        función debe incluir una sección que demuestre la sintaxis del
        codigo. La parte superior de esata sección tiene al menos una
        línea #include, mostrando el fichero principal que contiene el
        prototipo de función. Se debe duplicar este #include en vuestro
        fichero para que la función este correctamente declarada. Ahora
        se puede llamar la funcion de la misma manera que aparece en la
        sección de sintaxis. Si se comete un error, el compilador lo
        descubrirá comparando la llamada a la función con el prototipo
        de la cabecera e informará de dicho error. El linker busca la
        librería Standard por defecto, de modo que lo único que hay que
        hacer es: incluir el fichero de cabecera y llamar a la función.
      </para>

    </sect2>

    <sect2>
      <!-- Creating your own libraries with the librarian -->
      <title>Creación de librerías propias</title>

      <!--
      You can collect your own functions together into a library. Most
      programming packages come with a librarian that manages groups of
      object modules. Each librarian has its own commands, but the
      general idea is this: if you want to create a library, make a
      header file containing the function prototypes for all the
      functions in your library. Put this header file somewhere in the
      preprocessor??s search path, either in the local directory (so it
      can be found by #include ??header??) or in the include directory
      (so it can be found by #include <header>). Now take all the object
      modules and hand them to the librarian along with a name for the
      finished library (most librarians require a common extension, such
      as .lib or .a). Place the finished library where the other
      libraries reside so the linker can find it. When you use your
      library, you will have to add something to the command line so the
      linker knows to search the library for the functions you call. You
      must find all the details in your local manual, since they vary
      from system to system.  
      -->

      <para>
        Se pueden coleccionar funciones propias juntas en una
        librería. La mayoróa de paquetes de programación vienen con un
        bibliotecario que maneja grupos de modulos de objetos. Cada
        bibliotecario tiene sus propios comandos, pero la idea general
        es la siguiente: si se desea crear una librería, se debe hacer
        un fichero cabecera conteniendo los prototipos para todas las
        funciones de la librería. Hay que ubicar este fichero cabecera
        en alguna parte del path de búsqueda del preprocesador, ya sea
        en el directorio local (de modo que podrá ser encontrado
        mediante #include ??header??) o bien en el directorio include
        (por lo que se podrá encontrar mediante #include
        &lt;header&gt;). Luego se han de juntar todos los modulos de
        objetos y pasarlos al bibliotecaio junto con un nombre para la
        librería recién construida (la mayoría de los bibliotecrios
        requieren una extensión común, como por ejemplo .lib o .a). Se
        ha de ubicar la librería completa donde residen todas las demás,
        de manera que el linker sabrá buscar estas funciones en dicha
        librería al ser llamadas. Se pueden encontrar todos los detalles
        en el manual local, ya que pueden variar de un sistema a otro.
      </para>

     </sect2>
  </sect1>

  <sect1>
    <!-- Controlling execution  -->
    <title>Control de la ejecuión</title>

    <!--
    This section covers the execution control statements in C++. You
    must be familiar with these statements before you can read and write
    C or C++ code.

    C++ uses all of C??s execution control statements. These include
    if-else, while, do-while, for, and a selection statement called
    switch. C++ also allows the infamous goto, which will be avoided in
    this book.
    -->

    <para>
      Esta sección trata las sentencias de control de ejecución en
      C++. Hay que familiarizarse con estas sentencias antes de que se
      pueda leer o escribir codigo C o C++.  

      C++ usa todas las sentencias de control de ejecución de C. Esto
      incluye if-else, do-while, for, y una sentencia de selección
      llamada switch. C++ también admite el infame goto, el cual será
      evitado en este libro.
    </para>
  
    <sect2>
      <title>Verdadero y falso</title>

      <!--
      All conditional statements use the truth or falsehood of a
      conditional expression to determine the execution path. An example
      of a conditional expression is A == B. This uses the conditional
      operator == to see if the variable A is equivalent to the variable
      B. The expression produces a Boolean true or false (these are
      keywords only in C++; in C an expression is ??true?? if it
      evaluates to a nonzero value). Other conditional operators are >,
      <, >=, etc. Conditional statements are covered more fully later in
      this chapter.
      -->

      <para>
        Todas las sentencias condicionales utilizan la veracidad o la
        falsedad de una expresión condicional para determinar el camino
        de ejecución. Un ejemplo de una expresión condicional es A ==
        B. Esto utiliza el operador condicional == para saber si la
        variable A es equivalente a la variable B. La expresión produce
        un Booleano true o false (esto son palabras clave solo en C++;
        en C una expresión es verdadera(true) si se contrasta contra un
        valor diferente de cero). Otros operadores condicionales son
        &gt;, &lt;, &gt;=, etc. Las sentencias condicional serán
        tratadas a fondo mas adelante en este capítulo.
      </para>
    </sect2>

    <sect2>
      <title>if-else</title>
      
      <!--
      The if-else statement can exist in two forms: with or without the
      else. The two forms are:
      -->

      <para>
        La sentencia if-else puede existir de dos formas: con o sin el
        else. Las dos formas son:        
      </para>

      if(expression) //expresión
      statement //sentencia

      o

      if(expression)
      statement
      else
      statement

      <!--
      The ??expression?? evaluates to true or false. The ??statement??
      means either a simple statement terminated by a semicolon or a
      compound statement, which is a group of simple statements enclosed
      in braces. Any time the word ??statement?? is used, it always
      implies that the statement is simple or compound. Note that this
      statement can also be another if, so they can be strung together.
      -->

      <para>
        Se evalúa que la expresión sea true o false. La ??sentencia??
        puedeq ser una sentencia simple acabada en un punto y coma, o
        bien una sentencia compuesta, lo que no es más que un grupo de
        sentencias simples encerradas entre llaves. Siempre que se
        utiliza la palabra ??sentencia??, implica que la sentencia es
        simple compuesta. Tener en cuenta que dicha sentencia puede ser
        incluso otro if, por lo que pueden ir anidados.
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Ifthen.cpp"/>
</programlisting>


      <!--
      It is conventional to indent the body of a control flow statement
      so the reader may easily determine where it begins and ends[30].
      -->
    
      <para>
        Es costumbre indentar el cuerpo de una sentencia de flujo de
        control, de modo que el lector puede determinar fácilmente donde
        comienza y dónde acaba[30].
      </para>

    </sect2>
    <sect2>
      <title>while</title>
      
      <!--
      while, do-while, and for control looping. A statement repeats
      until the controlling expression evaluates to false. The form of a
      while loop is
      -->
      
      <para>
        Los bucles de control while, do-while, y for. Una sentencia se
        repite hasta que la expresión de control sea false. La
        estructura de un bucle while es:
      </para>

      while(expression) statement

      <!--
      The expression is evaluated once at the beginning of the loop and
      again before each further iteration of the statement.

      This example stays in the body of the while loop until you type
      the secret number or press control-C.
      -->

      <para>
        La expresión es evaluada una vez al comienzo del bucle y cada
        vez antes de cada iteración de la sentencia.
        
        Este ejemplo se ejecuta el cuerpo del bucle while hasta que se
        introduzca el numero secreto o se presione control-C.
      </para>


<programlisting>
<xi:include parse="text" href="./code/C03/Guess.cpp"/>
</programlisting>


      <!--
      The while??s conditional expression is not restricted to a simple
      test as in the example above; it can be as complicated as you like
      as long as it produces a true or false result. You will even see
      code where the loop has no body, just a bare semicolon:
      -->

      <para>
        La expresión condicional del while no está restringida a una
        simple prueba como en el ejemplo anterior; puede ser tant
        complicada como se desee siempre y cuando se produzca un
        resultado true o false. También se puede ver el código sin
        curepo, solo un simple punto y coma:
      </para>

while(/* Do a lot here */)
 ;

      <!--
      In these cases, the programmer has written the conditional
      expression not only to perform the test but also to do the work.
      -->

      <para>
        En estos casos, el programador ha escrito la expresión
        condicional no solo para realizar la evaluación, sino también
        para hacer el trabajo.
      </para>

    </sect2>
      
    <sect2>
      <title>do-while</title>

      <!--
      The form of do-while is
      -->

      <para>
        La estructura de do-while es
      </para>

do
statement
while(expression); 

      <!--
      The do-while is different from the while because the statement
      always executes at least once, even if the expression evaluates to
      false the first time. In a regular while, if the conditional is
      false the first time the statement never executes.
      
      If a do-while is used in Guess.cpp, the variable guess does not
      need an initial dummy value, since it is initialized by the cin
      statement before it is tested:
      -->

      <para>
        El do-while es diferente del while ya que la sentencia siempre
        se ejecuta al menos una vez, aún si la expresión resulta false
        la primera vez. En un while regular, si la condicion es falsa la
        primera vez, la sentencia nunca se ejecuta.
      </para>

      <para>
        Si un do-while se utiliza en Guess.cpp, la variable guess no
        necesita un valor ficticio inicial, ya que se inicializa por la
        sentencia cin antes de que sea evaluada:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Guess2.cpp"/>
</programlisting>


      <!--
      For some reason, most programmers tend to avoid do-while and just
      work with while.
      -->
      
      <para>
        For alguna razón, la mayoría de los programadores tienden a
        evitar el do-while y se limitan a trabajar con el while.
      </para>
    </sect2>

    <sect2>
      <title>for</title>

      <!--
      A for loop performs initialization before the first
      iteration. Then it performs conditional testing and, at the end of
      each iteration, some form of ??stepping.?? The form of the for
      loop is:
      -->

      <para>
        Un bucle for realiza una inicialización antes de la primera
        iteración. Luego ejecuta una evaluación condicional y, al final
        de cada iteración, cierta forma de ??stepping??, avanzar paso a
        paso. La estructura del for es:
      </para>

for(initialization; conditional; step)
statement

      <!--
      Any of the expressions initialization, conditional, or step may be
      empty. The initialization code executes once at the very
      beginning. The conditional is tested before each iteration (if it
      evaluates to false at the beginning, the statement never
      executes). At the end of each loop, the step executes.

      for loops are usually used for ??counting?? tasks:
      -->

      <para>
        Cualquiera de las expresiones de inicialización, condicional, o
        paso puede estar vacía. La inicialización se ejecuta una vez al
        principio de todo. La expresión condicional se evalúa antes de
        cada iteración (si se evalúa a false en desde el principio, el
        cuerpo del bucle nunca llega a ejecutarse). Al final de cada
        iteración del bucle, el step se ejecuta.
      </para>

      <para>
        Los bucles for son generalmente utilizados para tareas de
        ??contar??:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Charlist.cpp"/>
</programlisting>

      <!--
      You may notice that the variable i is defined at the point where
      it is used, instead of at the beginning of the block denoted by
      the open curly brace ??{??. This is in contrast to traditional
      procedural languages (including C), which require that all
      variables be defined at the beginning of the block. This will be
      discussed later in this chapter.
      -->

      <para>
        Puede ocurrir que la variable i sea definida en el punto en el
        que es utilizada, en vez de al principio del bloque delimitado
        por la apertura de la llave ??{??. Esto difiere de los lenguajes
        procedurales tradicionales (incluyendo C), los cuales requieren
        que todas ls variables sean definidas al principio del
        bloque. Esto será discutido mas adelante en este capítulo.
      </para>
    </sect2>

    <sect2>
      <!-- The break and continue keywords -->
      <title>Las pasabras reservadas <literal
      role="keyword">break</literal> y <literal
      role="keyword">continue</literal></title>

      <!--
      Inside the body of any of the looping constructs while, do-while,
      or for, you can control the flow of the loop using break and
      continue. break quits the loop without executing the rest of the
      statements in the loop. continue stops the execution of the
      current iteration and goes back to the beginning of the loop to
      begin a new iteration.
      -->

      <para>
        Dentro del cuerpo de cualquiera de las estructuras de bucle
        while, do-while, o for, se puede controlar el flujo del bucle
        utilizando break y continue. Break abandona el bucle sin
        ejecutar el resto de las sentencias en el bucle. continue para
        la ejecución de la iteración actual y vuelve al principio del
        bucle para comenzar una nueva iteración.
      </para>

      <!-- 
      As an example of break and continue, this program is a very
      simple menu system:
      --> 

      <para>
        A modo de ejemplo de break y continue, este programa es un menu
        de sistema muy simple:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Menu.cpp"/>
</programlisting>

      <!--
      If the user selects ??q?? in the main menu, the break keyword is
      used to quit, otherwise the program just continues to execute
      indefinitely. After each of the sub-menu selections, the continue
      keyword is used to pop back up to the beginning of the while loop.
      -->

      <para>
        Si el usuario selecciona ??q?? en el menu principal, la palabra
        clave break se utiliza para salir, de otro modo, el programa
        continua ejecutandose indefinidamente. Luego de cada selección
        de sub-menu, la palabra clave continue es usada para volver
        atrás hasta el comienzo del bucle while.
      </para>

      <!--
      The while(true) statement is the equivalent of saying ??do this
      loop forever.?? The break statement allows you to break out of
      this infinite while loop when the user types a ??q.??
      -->

      <para>
        El while(true) es el equivalente a decir ??haz este bucle para
        siempre??.  La sentencia break permite romper este bucle
        infinito cuando el usuario teclea ??q??.
      </para>

    </sect2>

    <sect2>
      <title>switch</title>

      <!--
      A switch statement selects from among pieces of code based on the
      value of an integral expression. Its form is:
      -->

      <para>
        La sentencia switch selecciona de un grupo de codigos basados en
        el valor de una expression integral. Su estructura es:
      </para>

switch(selector) {
case integral-value1 : statement; break;
case integral-value2 : statement; break;
case integral-value3 : statement; break;
case integral-value4 : statement; break;
case integral-value5 : statement; break;
    (...)
default: statement;
} 

      <!--
      Selector is an expression that produces an integral value. The
      switch compares the result of selector to each integral value. If
      it finds a match, the corresponding statement (simple or compound)
      executes. If no match occurs, the default statement executes.
      -->
      
      <para>
        Selector es una expression que produce un valor integral. El
        switch compará el resultado de selector para cada valor
        integral. Si encuentra una coincidencia, se ejecutará la
        sentencia correspondiente (ya sea simple o compuesta. Si no se
        encuentra ninguna coincidencia, la sentencia default se
        ejecutará.
      </para>

      <!--
      You will notice in the definition above that each case ends with a
      break, which causes execution to jump to the end of the switch
      body (the closing brace that completes the switch). This is the
      conventional way to build a switch statement, but the break is
      optional. If it is missing, your case ??drops through?? to the one
      after it. That is, the code for the following case statements
      execute until a break is encountered. Although you don??t usually
      want this kind of behavior, it can be useful to an experienced
      programmer.
      -->

      <para>
        Se puede obeservar en la definición anterior que cada case acaba
        con un break, lo que causa que la ejecución salte hasta el final
        del cuerpo del switch (la llave final que completa el
        switch). Esta es la forma convencional de construir una
        sentencia switch, pero la palabra break es opcional. Si no se
        indica, el case que se ha cumplido ??cae?? al siguiente de la
        lista. Esto significa, que el código del siguiente case, se
        ejecutara hasta que un break sea encontrado. Aunque normalmente
        no se desea este tipo de comportamiento, puede ser de ayuda para
        un programador experimentado.
      </para>

      <!--
      The switch statement is a clean way to implement multi-way
      selection (i.e., selecting from among a number of different
      execution paths), but it requires a selector that evaluates to an
      integral value at compile-time. If you want to use, for example, a
      string object as a selector, it won??t work in a switch
      statement. For a string selector, you must instead use a series of
      if statements and compare the string inside the conditional.
      -->

      <para>
        La sentencia switch es una manera limpia de implementer una
        selección multi-modo (por ejemplo, seleccionando de entre un
        numero de diferentes paths de ejecución), pero require un
        selector que evalue esto contra un valor integral en el momento
        de la compilación. Si se quisiera utilizar, por ejemplo un
        objeto de tipo string como selector, no funcionaría en una
        sentencia switch. Para un selector de tipo string, se debe
        utilizar en cambio una serie de sentencias if y comparar la
        string dentro de la condición.
      </para>

      <!--
      The menu example shown above provides a particularly nice example
      of a switch:
      -->

      <para>
        El ejemplo del menu demostrado anteriormente prove un ejemplo
        particularmente fácil de un switch:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/Menu2.cpp"/>
</programlisting>

      <!--
      The quit flag is a bool, short for ??Boolean,?? which is a type
      you??ll find only in C++. It can have only the keyword values true
      or false. Selecting ??q?? sets the quit flag to true. The next
      time the selector is evaluated, quit == false returns false so the
      body of the while does not execute.
      -->

      <para>
        El flag quit es un bool, abreviatura para ??Boolean??, el cual
        es un tipo que solo se encuentra en C++. Puede tener unicamente
        los valores clave true o false. Seleccionando ??q?? le da el
        valor true al flag quit. La próxima vez que el selector sea
        evaluado, quit == false retornara false de modo que el cuerpo
        del bucle while no se ejecutará.
      </para>

    </sect2> 

    <sect2>
      <!-- Using and misusing goto -->
      <title>Uso y maluso de <literal
          role="keyword">goto</literal></title>
      
      <!--
      The goto keyword is supported in C++, since it exists in C. Using
      goto is often dismissed as poor programming style, and most of the
      time it is. Anytime you use goto, look at your code and see if
      there??s another way to do it. On rare occasions, you may discover
      goto can solve a problem that can??t be solved otherwise, but
      still, consider it carefully. Here??s an example that might make a
      plausible candidate:
      -->

      <para>
        La palabra clave goto es soportada en C++, ya que existe en
        C. El uso de goto es a menudo calificado de un estilo de
        programación pobre, y la mayor parte del tiempo lo es. Siempre
        que se utilice goto, se debe reviser bien el código par aver si
        hay alguna otra manera de hacerlo. En raras ocasiones, goto
        puede resolvr un problema que no puede ser resuelto de otra
        manera, pero, aún así, se debe considerer cuidadosamente. A
        continuación hay un ejemplo que puede ser un plausible
        candidato:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/gotoKeyword.cpp"/>
</programlisting>

      <!--
      The alternative would be to set a Boolean that is tested in the
      outer for loop, and then do a break from the inner for
      loop. However, if you have several levels of for or while this
      could get awkward.
      -->
     
      <para>
        La alternativa sería dar valor a un booleano que sea evaluado en
        el for externo, y luego hacer un break desde el for interno. De
        todos modos, si hay demasiados niveles de for o while esto puede
        ser tedioso.
      </para>
    </sect2>

    <sect2>
      <title>Recursividad</title>

      <!--
      Recursion is an interesting and sometimes useful programming
      technique whereby you call the function that you??re in. Of
      course, if this is all you do, you??ll keep calling the function
      you??re in until you run out of memory, so there must be some way
      to ??bottom out?? the recursive call. In the following example,
      this ??bottoming out?? is accomplished by simply saying that the
      recursion will go only until the cat exceeds ??Z??:[31]
      -->
      
      <para>
        La recursividad es una interesante y a veces útil técnica de
        programación, en donde se llama a la función dentro de la que se
        está. Por supuesto, si es todo lo que hace, se estaría llamando
        a la función hasta que se acabase la memoria de ejecución, de
        modo que debe existi una manera de ??escapase?? de la llamada
        recursiva. En el siguiente ejemplo, esta ??escapada?? se
        consigue simplemente diciendo que la recursión solo continuará
        hasta que cat exceda ??Z??: [31]
      </para>

<programlisting>
<xi:include parse="text" href="./code/C03/CatsInHats.cpp"/>
</programlisting>


      <!--
      In removeHat(), you can see that as long as cat is less than ??Z??,
      removeHat( ) will be called from within removeHat( ), thus
      effecting the recursion. Each time removeHat( ) is called, its
      argument is one greater than the current cat so the argument keeps
      increasing.
      -->

      <para>
        En removeHat( ), se puede ver que mientras cat sea menor que
        ??Z??, removeHat( ) se llamará a sí misma desde dentro, así
        efectuando la recursividad. Cada vez que removeHat( ) es
        llamada, el argumento es una vez mas grande que el actual cat de
        modo que el argumento continua aumentando.
      </para>

      <!--
      Recursion is often used when evaluating some sort of arbitrarily
      complex problem, since you aren??t restricted to a particular
      ??size?? for the solution ? the function can just keep recursing
      until it??s reached the end of the problem.
      -->

      <para>
        La recursividad es amenudo utilizada cuando se evalua algun tipo
        de problema arbitrariamente complejo, ya que no se restringe a
        un nigún tamaño en concreto para la solución ? la function puede
        simplemente efecutar la recursividad hasta que se haya alcanzado
        el final del problema.
      </para>
    </sect2>   
  </sect1>

  <sect1>
    <!-- Introduction to operators -->
    <title>Introducción a los operadores</title>

    <!--
    You can think of operators as a special type of function (you'll
    learn that C++ operator overloading treats operators precisely that
    way). An operator takes one or more arguments and produces a new
    value. The arguments are in a different form than ordinary function
    calls, but the effect is the same.
    -->

    <para>
      Se puede pensar en un operador como un tipo de función especial
      (aprenderá que en C++ la sobrecarga de operadores los trata
      precísamente de esa forma). Un operador recibe uno o más
      argumentos y produce un nuevo valor. Los argumentos se pasan de
      una manera diferente que en las llamadas a funciones normales,
      pero el efecto es el mismo.
    </para>

    <!--
    From your previous programming experience, you should be reasonably
    comfortable with the operators that have been used so far. The
    concepts of addition (+), subtraction and unary minus (-),
    multiplication (*), division (/), and assignment(=) all have
    essentially the same meaning in any programming language. The full
    set of operators is enumerated later in this chapter.
    -->
    
    <para>
      De su experiencia previa en programación, debe estar
      razonablemente cómodo con los operadores que han sido
      utilizados. Los conceptos de adición (+), substracción y resta
      unaria (-), multiplicación (*), división (/), y asignación (=)
      tienen todos el mismo significado en cualquier lenguaje de
      programación. Todo el grupo de operadores se enumera más
      adelante en este capítulo.
    </para>
      
    <sect2>
      <!-- Precedence -->
      <title>Precedencia</title>

      <!--
      Operator precedence defines the order in which an expression
      evaluates when several different operators are present. C and C++
      have specific rules to determine the order of evaluation. The
      easiest to remember is that multiplication and division happen
      before addition and subtraction.  After that, if an expression
      isn't transparent to you it probably won't be for anyone reading
      the code, so you should use parentheses to make the order of
      evaluation explicit. For example:
      -->

      <para>
	La precedencia de operadores define el orden en el cual una
	expresión se evalúa cuando varios diferentes operadores son
	presentados. C y C++ tienen reglas específicas para determinar
	el orden de evaluación. Lo más fácil de recordar es que la
	multiplicación y la división se ejecutan antes que la adición y
	la substracción. Luego, si una expresión no es transparente al
	programador que la escribe, probablemente lo será para nadie que
	lea el código, de modo que se deben usar paréntesis para hacer
	el explícito el orden de la evaluación. Por ejemplo:
      </para>

      <para>
             A = X + Y - 2/2 + Z;
      </para>

      <!--
      evaluating the result with X = 1, Y = 2, and Z = 3.)
      -->

      <para>
	(Intente evaluar el resultado con X =1, Y = 2, y Z = 3.)
      </para>



    </sect2>
    
    <sect2>
      <!-- Auto increment and decrement -->
      <title>Auto incremento y decremento</title>


      <!--
      C, and therefore C++, is full of shortcuts. Shortcuts can make
      code much easier to type, and sometimes much harder to
      read. Perhaps the C language designers thought it would be easier
      to understand a tricky piece of code if your eyes didn't have to
      scan as large an area of print.
      -->

      <para>
	C, y por tanto C++, está lleno de atajos. Los atajos pueden hacer
	el código mucho mas fácil de escribir, y a veces más difícil de
	leer. Quizás los diseñadores del lenguaje C pensaron que sería
	más fácil entender un trozo complicado de código si los ojos no
	tienen que leer una larga línea de letras.
      </para>


      <!--
      One of the nicer shortcuts is the auto-increment and
      auto-decrement operators. You often use these to change loop
      variables, which control the number of times a loop executes.
      -->

      <para>
	Uno de los mejores atajos son los operadores de auto-incremento
	y auto-decremento. Se utilizan a menudo para cambiar variables
	en un bucle, las cuales controlan el número de veces que se
	ejecuta un bucle.
      </para>

      <!--
      The auto-decrement operator is '- -' and means "decrease by one
      unit."  The auto-increment operator is '++' and means "increase by
      one unit." If A is an int, for example, the expression ++A is
      equivalent to (A = A + 1). Auto-increment and auto-decrement
      operators produce the value of the variable as a result. If the
      operator appears before the variable, (i.e., ++A), the operation
      is first performed and the resulting value is produced. If the
      operator appears after the variable (i.e. A++), the current value
      is produced, and then the operation is performed. For example:
      -->

      <para> 
	El operador de auto-decremento es '--' y significa
	"decrementar de a una unidad". El operador de auto-incremento es
	'++' y significa "incrementar de a una unidad". Si es un entero,
	por ejemplo, la expresión ++A es equivalente a (A = A + 1). Los
	operadores de auto-incremento o auto-decremento producen el
	valor de la variable como resultado. Si el operador aparece
	antes de la variable (p.e, ++A), la operación se ejecuta primero
	y después se produce el valor resultante. Si el operador aparece
	a continuación de la variable (p.e, A++), primero se produce el
	valor actual, y luego se realiza la operación. Por ejemplo:
      </para>


<programlisting>
<xi:include parse="text" href="./code/C03/AutoIncrement.cpp"/>
</programlisting>

      <!--
      If you've been wondering about the name "C++," now you understand. It
      implies "one step beyond C."
      -->

      <para>
	Si se ha estado preguntando acerca del nombre
	<quote>C++</quote>, ahora lo entiendes. Significa "un paso más
	allá de C".
      </para>

    </sect2>
  </sect1>    
    





  <sect1>
    <title>Introducción a los tipos de datos</title>
    
    <!--
    Data types define the way you use storage (memory) in the programs
    you write. By specifying a data type, you tell the compiler how to
    create a particular piece of storage, and also how to manipulate
    that storage.
    -->

    <para>
      Los tipos de datos definen el modo en que se usa el espacio
      (memoria) en los programas que escribes.  Especificando un tipo de
      datos, estás indicando al compilador como crear un espacio en
      particular, y también como manipular este espacio.
    </para>

    <!--
    Data types can be built-in or abstract. A built-in data type is one
    that the compiler intrinsically understands, one that is wired
    directly into the compiler. The types of built-in data are almost
    identical in C and C++. In contrast, a user-defined data type is one
    that you or another programmer create as a class. These are commonly
    referred to as abstract data types. The compiler knows how to handle
    built-in types when it starts up; it "learns" how to handle abstract
    data types by reading header files containing class declarations
    (you'll learn about this in later chapters).
    -->

    <para>
      Los tipos de datos pueden ser genéricos del lenguaje o
      abstractos. Un tipo de dato genérico es intrínsecamente
      comprendido por el compilador, es introducido directamente al
      compilador. Estos tipos de datos son casi identicos en C y C++. En
      contraste, un tipo de datos definido por el usuario es aquel que
      tu o cualquier otro programador crean comouna clase. Estos son
      comunmente referidos como tipos de datos abstractos. El
      commpilador sabe como manejar tipos genéricos cuando arranca;
      "aprende" como manejar tipos de datos abstractos leyendo los
      ficheros de cabeceras que contienen las declaraciones de las
      clases (aprenderás sobre esto en los siguientes capítulos). 
    </para>



    <sect2>
      <title>Tipos predefinidos básicos</title>

      <!--
      The Standard C specification for built-in types (which C++
      inherits) doesn't say how many bits each of the built-in types
      must contain. Instead, it stipulates the minimum and maximum
      values that the built-in type must be able to hold. When a machine
      is based on binary, this maximum value can be directly translated
      into a minimum number of bits necessary to hold that
      value. However, if a machine uses, for example, binary-coded
      decimal (BCD) to represent numbers, then the amount of space in
      the machine required to hold the maximum numbers for each data
      type will be different. The minimum and maximum values that can be
      stored in the various data types are defined in the system header
      files limits.h and float.h (in C++ you will generally #include
      climits> and cfloat> instead).
      -->

      <para>
        La especificación de Standard C para los tipos genericos (los
        cuales hereda C++) no indica cuantos bits debe contenter cada
        uno de estos. En vez de esto, estipula el minimo y maximo valor
        que dicho tipo genérico es capaz de almacenar. Cuando una
        máquina se basa en sistema binario, este valor máximo puede ser
        directamente traducido a un numero minimo necesario de bits para
        alojar este valor. De todos modos, si una maquina usar, por
        ejemplo, el codigo binario decimal (BCD) para representar los
        numeros, entonces el espacio en la maquina requerido para alojar
        el maximo numero para cada tipo de datos sera diferente. El
        minimo y maximo valor que puede ser almacenado en los distintos
        tipos de datos se definen en los ficheros de cabeceras del
        sistema limits.h y float.h (en C++ escribirias generalmente
        #include &lt;climits> y &lt;cfloat> en su lugar).
      </para>
      
      <!--
      C and C++ have four basic built-in data types, described here for
      binary-based machines. A char is for character storage and uses a
      minimum of 8 bits (one byte) of storage, although it may be
      larger. An int stores an integral number and uses a minimum of two
      bytes of storage. The float and double types store floating-point
      numbers, usually in IEEE floating-point format. float is for
      single-precision floating point and double is for double-precision
      floating point.
      -->
      
      <para>
        C y C++ tienen cuatro tipos genericos básicos, describidos aqui
        para maquinas basadas en sistema binario. Un chat es para
        almacenar carácteres y utiliza un mínimo de 8 bits (un byte) de
        espacio, aunque puede ser mas largo. Un int almacena un numero
        entero y utiliza un minimo de dos bytes de espacio. Los tipos
        float y el double almacenan numeros con coma flotante,
        usualmente en formato de coma flotante IEEE. el float es para
        precision simple de la coma y el double es para la doble
        precision de la coma.
      </para>


      <!-- 
      As mentioned previously, you can define variables anywhere in
      a scope, and you can define and initialize them at the same
      time. Here's how to define variables using the four basic data
      types:
      -->

      <para>
        Como hemos mencionado previamente, puedes degfinir variables en
        cualquier sitio en un ámbito determinado, y puedes definirlas e
        inicializarlas al mismo tiempo.  A continuación se indica como
        definir variables utilizando los cuatro tipos básicos de datos
      </para>


        //: C03:Basic.cpp

      <!-- 
      The first part of the program defines variables of the four
      basic data types without initializing them. If you don't
      initialize a variable, the Standard says that its contents are
      undefined (usually, this means they contain garbage). The second
      part of the program defines and initializes variables at the same
      time (it's always best, if possible, to provide an initialization
      value at the point of definition). Notice the use of exponential
      notation in the constant 6e-4, meaning "6 times 10 to the minus
      fourth power."
      -->

      <para>
        La primera parte del programa define variables de los cuatro
        tipos básicos sin inicializarlas. Si no inicializas una
        variable, el Standard dice que su contenido es indefinido
        (normalmente, esto significa que contienen basura). La segunda
        parte del programa define e inicializa viariables al mismo
        tiempo (Siempre es mejor, si es posible, proveer un valor
        inicial al momento de la definición). Notar que el uso de
        notación exponencial en la contante 6e-4, significa "6 veces 10
        para el menor cuarto poder?????????????????"
      </para>

    </sect2>

    <sect2>
      <title>booleano, true y false</title>

      <!--
      Before bool became part of Standard C++, everyone tended to use
      different techniques in order to produce Boolean-like
      behavior. These produced portability problems and could introduce
      subtle errors.
      -->

      <para>
        Antes de que bool se convirtiese en parte del Standard C++,
        todos tendiand a utilizar diferentes técnicas para producir
        comportamientos similares a los booleanos. Esto produjo problemas
        de portabilidad y podían acarrear errores subyacentes.
      </para>


      <!--
      The Standard C++ bool type can have two states expressed by the
      built-in constants true (which converts to an integral one) and
      false (which converts to an integral zero). All three names are
      keywords. In addition, some language elements have been adapted:
      -->

      <para>
        El tipo bool de Standard C++ puede tener dos estados expresados
        por las constantes genéricas true (lo que lo convierte en un uno
        entero) y false (lo que lo convierte a un zero entero). Estos
        tres nombres son palabras clave. En suma, algunos elementos del
        lenguaje han sido adaptados:
      </para>

      [FIXME: tabla de booleanos]
      

      <!--
      Because there's a lot of existing code that uses an int to
      represent a flag, the compiler will implicitly convert from an int
      to a bool (nonzero values will produce true while zero values
      produce false). Ideally, the compiler will give you a warning as a
      suggestion to correct the situation.
      -->

      <para>
        Ya que hay mucho código existente que utiliza un int para
        representar un flag (opción), el compilador lo convertira
        implicitamente de un int a un bool (los valores diferentes de
        cero produciran el true, mientras que los valores cero,
        produciran false). Idealmente, el compilador te dará in warning
        a modo de aviso para corregir la situacion.
      </para>


      <!--
      An idiom that falls under "poor programming style" is the use of
      ++ to set a flag to true. This is still allowed, but deprecated,
      which means that at some time in the future it will be made
      illegal. The problem is that you're making an implicit type
      conversion from bool to int, incrementing the value (perhaps
      beyond the range of the normal bool values of zero and one), and
      then implicitly converting it back again.
      -->

      <para>
        Al que es calificado de "estilo pobre de programacion" es el uso
        de ++ para indicar que un flag es verdadero. Esto aún se
        permite, pero no es aprobado, lo que significa que alguna vez en
        el futuro será ilegal. El problema es que estás haciendo una
        conversión implicita de un bool a un entero, incrementando el
        valor (a lo mejor mas alla del rango cero y uno normal del
        booleano), y luego implicitamente convirtiendolo otra vez a
        bool.
      </para>


      <!-- 
      Pointers (which will be introduced later in this chapter)
      will also be automatically converted to bool when necessary.  
      -->

      <para>
        Los punteros (los cuales van a ser descriptos mas adelante en este
        capitulo) tambien seran automaticamente convertidos a booleano
        cuando sea necesario.
      </para>
    </sect2>

    <sect2>
      <title>Especificadores</title>
      
      <!--
      Specifiers modify the meanings of the basic built-in types and
      expand them to a much larger set. There are four specifiers: long,
      short, signed, and unsigned.
      -->

      <para>
        Los especificadores modifican los significados de los tipos genéricos
        basicos y los expanden a un rango mas grande. Hay cuatro
        especificadores: long, short, signed y unsigned.
      </para>

      <!--
      long and short modify the maximum and minimum values that a
      data type will hold. A plain int must be at least the size of a
      short. The size hierarchy for integral types is: short int, int,
      long int. All the sizes could conceivably be the same, as long as
      they satisfy the minimum/maximum value requirements. On a machine
      with a 64-bit word, for instance, all the data types might be 64
      bits.
      -->

      <para>
        long y short modifican los valores maximos y minumos que un tipo
        de datos almacenara. Un int plano debe al menos tener el tamaño
        de un short. La jerarquía de tamaños para tipos integrales es:
        short int, int , long int.  Todos pueden ser el mismo tamaño ,
        siempre y cuando satisfagan los requerimentos de
        minimo/maximo. En una maquina donde una palabra mide 64 bits,
        por defecto, todos los tipos de datos deben medir 64 bits
        minimo.
      </para>


      <!--
      The size hierarchy for floating point numbers is: float, double,
      and long double. "long float" is not a legal type. There are no
      short floating-point numbers.
      -->

      <para>
        La jerarquía de tamaño para los numeros con coma flotante es:
        float, double, y long double. "long float" no es un tipo legal. No
        hay numeros con coma flotantes de tamaño short.
      </para>

      <!--
      The signed and unsigned specifiers tell the compiler how to
      use the sign bit with integral types and characters
      (floating-point numbers always contain a sign). An unsigned number
      does not keep track of the sign and thus has an extra bit
      available, so it can store positive numbers twice as large as the
      positive numbers that can be stored in a signed number. signed is
      the default and is only necessary with char; char may or may not
      default to signed. By specifying signed char, you force the sign
      bit to be used.
      -->

      <para>
        Los especificadores signed y unsigned, indican al compilador
        como utilizar el bit del signo con los tipos integrales y los
        caracteres (los numeros de coma flotante siempre contienen un
        signo). Un numero unsigned no guarda el valor del signo y además
        tiene un bit extra disponible, de modo que puede guardar el
        doble de numeros positivos que pueden guardarse en un numero
        signed. signed es dado por defecto y solo es necesario con chat,
        char puede ser o no por defecto un signed. Especificando signed
        chat, estás forzando a que se utilice el bit del signo.
      </para>

      <!--
      The following example shows the size of the data types in bytes by
      using the sizeof operator, introduced later in this chapter:
      -->

      <para>
        El siguiente ejemplo muestra el tamaño de los tipos de datos en
        bytes utilizando el operador sizeof, descripto mas adelante en
        ese capítulo:
      </para>
        
        //: C03:Specify.cpp


      <!--
      Be aware that the results you get by running this program will
      probably be different from one machine/operating system/compiler
      to the next, since (as mentioned previously) the only thing that
      must be consistent is that each different type hold the minimum
      and maximum values specified in the Standard.
      -->

      <para>
        Ten en cuenta que los resultados que consigues ejecutando este
        programa pueden ser probablemente diferentes de una
        maquina/sistema operativo / compilador a otro, ya que (como
        mencionamos anteriormente) lo único que ha de ser consistente es
        que cada tipo diferente almacene los valores minimos y máximos
        especificados en el Standard.
      </para>

      <!--
      When you are modifying an int with short or long, the keyword int
      is optional, as shown above.
      -->

      <para>
        Cuando está modificando un int con short o long, la palabra
        clave int es opcional, como se muestra a
        continuacion.

      </para> 
    </sect2>
      

    <sect2>
      <!-- Introduction to pointers -->
      <title>Introducción a punteros</title>


    
    <!--
    Whenever you run a program, it is first loaded (typically from disk)
    into the computer's memory. Thus, all elements of your program are
    located somewhere in memory. Memory is typically laid out as a
    sequential series of memory locations; we usually refer to these
    locations as eight-bit bytes but actually the size of each space
    depends on the architecture of the particular machine and is usually
    called that machine's word size. Each space can be uniquely
    distinguished from all other spaces by its address. For the purposes
    of this discussion, we'll just say that all machines use bytes that
    have sequential addresses starting at zero and going up to however
    much memory you have in your computer.
    -->    
 
      <para>
        Siempre que se ejecuta un programa, se carga al principio
        (tipicamente desde el disco duro) a la memoria del ordenador. De
        este modo, todos los elementos del programa se ubican en algun
        sitio en la memoria. La memoria es representada normalmente como
        series secuenciales de localización de memoria; normalmente se
        hace referencia a estas localizaciones como bytes de ocho bits,
        pero actualmente el tamaño de cada espacio depende de la
        arquitectura de la máquina en particular y es llamada usualmente
        tamaño de palabra de dicha máquina. Cada espacio puede ser
        distinguido unívocamente de todos los demás espacios por su
        dirección. Para este tema en particular, se establecerá que
        todas las máquinas usan bytes que tienen direcciones
        secuenciales, comenzando en cero y subiendo hasta cuanta memoria
        posea la máquina.
      </para>

      <!--
      Since your program lives in memory while it's being run, every element 
      of your program has an address. Suppose we start with a simple program:
      -->

      <para>
      Debido a que el programa reside en memoria mientras está siendo
      ejecutado, cada elemento de dicho programa tiene una dirección. Se
      supone el caso en el que se ejecuta un programa simple:
      </para>

//: C03:YourPets1.cpp

      <!--
      Each of the elements in this program has a location in storage when the 
      program is running. Even the function occupies storage. As you'll see,
      it turns out that what an element is and the way you define it usually
      determines the area of memory where that element is placed.
      -->
         
      <para>
        Cada uno de los elementos de este programa tiene una
        localización en el espacio cuando el programa se está
        ejecutando. Incluso las funciones ocupan espacio. Como se verá,
        se da por sentado que lo que el tipo de un elemento y la forma
        en que se define normalmente determina el área de memoria donde
        dicho elemento es ubicado.
      </para>

      
      <!--
      There is an operator in C and C++ that will tell you the address of an 
      element. This is the  '&' operator. All you do is precede the identifier
      name with '&' and it will produce the address of that identifier.
      YourPets1.cpp can be modified to print out the addresses of all its 
      elements, like this:
      -->      
   
      <para>
      Hay un operador en C y C++ que aloja la dirección de un
      elemento. Este es el operador '&'. Solo hay que anteponer el
      operador '&' antes del nombre identificador y se obtendra la
      dirección de dicho identificador. YourPets1.cpp se puede modificar
      para mostrar las direcciones de todos sus elementos, del siguiente
      modo:
      </para>

      //: C03:YourPets2.cpp
      
      <!--
      The (long) is a cast. It says "Don't treat this as if it's normal
      type, instead treat it as a long." The cast isn't essential, but
      if it wasn't there, the addresses would have been printed out in
      hexadecimal instead, so casting to a long makes things a little
      more readable.
      -->
      
      <para>
      El (loqng) es una conversión. Indica "No tratar como su tipo
      normal, sino como un long". La conversión no es escencial, pero si
      no existiese, las direcciones habrían sido mostradas en
      hexadecimal, de modo que la conversión a long hace las cosas mas
      legibles.
      </para>

      <!--
      The results of this program will vary depending on your computer, OS, 
      and all sorts of other factors, but it will always give you some
      interesting insights. For a single run on my computer, the results
      looked like this:
      -->

      <para>
      Los resultados de este programa variarán dependiendo deñ
      ordenador, del sistema operativo, y de muchos otros tipos de
      factores, pero siempre darán un resultado interesante. Con una
      simple ejecución en un ordenador, los resultados son como estos:
      </para>

      <programlisting>
       f(): 4198736
               dog: 4323632
               cat: 4323636
               bird: 4323640
               fish: 4323644
               i: 6684160
               j: 6684156
               k: 6684152
</programlisting>
        
      <!-- 
      You can see how the variables that are defined inside main( )
      are in a different area than the variables defined outside of
      main( ); you'll understand why as you learn more about the
      language. Also, f( ) appears to be in its own area; code is
      typically separated from data in memory.
      -->      
   
      <para>
      Se puede apreciar como las variables que se han definido dentro de
      main() estan en un área distinta que las variables definidas fuera
      del main(); se entenderá el porque cuando se profundise mas en el
      lenguaje. Además, f() parece estar en su propia area; el código
      normalmente se separa del resto de la información en memoria.
      </para>

      <!-- 
      Another interesting thing to note is that variables defined
      one right after the other appear to be placed contiguously in
      memory. They are separated by the number of bytes that are
      required by their data type.  Here, the only data type used is
      int, and cat is four bytes away from dog, bird is four bytes away
      from cat, etc. So it would appear that, on this machine, an int is
      four bytes long.
      -->

      <para>
      Otra cosa a tener en cuenta es que las variables definidas una a
      continuación de la otra parecen estar ubicadas contiguamente en
      memoria. Estas estan separadas por el numero de bytes que son
      requeridos por su tipo de datos. En este programa el único tipo de
      datos utilizado es el int, y la variable cat esta separada de dog
      por cuatro bytes, bird esta separada por cuatro bytes de cat,
      etc. De modo que en el ordenador en que ha sido ejecutado el
      programa, un entero mide cuatro bytes.
      </para>

      <!--
      Other than this interesting experiment showing how memory is
      mapped out, what can you do with an address? The most important
      thing you can do is store it inside another variable for later
      use. C and C++ have a special type of variable that holds an
      address. This variable is called a pointer.
      -->         

      <para>
      ¿Qué se puede hacer con las direcciones de memoria, además de este
      interesante experimento de mostrar cuanta memoria es ocupada? Lo
      más importante que se puede hacer es guardarlo dentro de otra
      variable para su uso posterior. C y C++ tienen un tipo de variable
      especial que guarda una dirección. Esta variable se llama puntero.
      </para>

      <!--
      The operator that defines a pointer is the same as the one used for 
      multiplication: '*'. The compiler knows that it isn't multiplication
      because of the context in which it is used, as you will see.
      -->         

      <para>
      El operador que define un puntero es el mismo que se utiliza para
      la multiplicación: '*'. El compilador sabe que no es una
      multiplicación debido al contexto en el que es utilizado, como se
      verá.
      </para>

      <!--
      When you define a pointer, you must specify the type of variable
      it points to. You start out by giving the type name, then instead
      of immediately giving an identifier for the variable, you say
      "Wait, it's a pointer" by inserting a star between the type and
      the identifier. So a pointer to an int looks like this:
      -->

      <para>
      Cuando se define un puntero, se debe especificar el tipo de
      variable al que apunta. Se comienza dando el nombre de dicho tipo;
      a continuación, en lugar de dar un identificador para la variable
      inmediatamente, se indica que es un puntero insertando un
      asterisco entre el tipo y el identificador. De modo que un puntero
      para un int tiene este aspecto:
      </para>
      
      <programlisting>
      int* ip; // ip points to an int variable
</programlisting>        

      <!--
      The association of the '*' with the type looks sensible and reads
      easily, but it can actually be a bit deceiving. Your inclination
      might be to say "intpointer" as if it is a single discrete
      type. However, with an int or other basic data type, it's possible
      to say:
      -->

      <para>
      La asociación de '*' con el tipo parece sensible y de fácil
      legibilidad, pero puede ser un poco confusa. La tendencia podría
      ser de decir "intpuntero" como un si fuese un tipo simple. De
      todas manera con un int u otro tipo básico de datos, es posible
      decir:
      </para>

      <programlisting>
       int a, b, c;
</programlisting>        

      <!--
      whereas with a pointer, you'd like to say:
      -->
      
      <para>
      así como con un puntero se diría:
      </para>

      <programlisting>
   int* ipa, ipb, ipc;
</programlisting>        

      <!--
      C syntax (and by inheritance, C++ syntax) does not allow such
      sensible expressions. In the definitions above, only ipa is a
      pointer, but ipb and ipc are ordinary ints (you can say that "*
      binds more tightly to the identifier"). Consequently, the best
      results can be achieved by using only one definition per line; you
      still get the sensible syntax without the confusion:
      -->

      <para>
      La sintaxis de C (y por herencia, la de C++) no permite
      expresiones tan sensibles. En las defniniciones anteriores, solo
      "ipa" es un puntero, pero "ipb" e "ipc" son ints normales (se
      puede decir que "* está mas unido al
      identificador"). Consecuentemente, los mejores resultados se
      pueden alcanzar utilizando solo una definición por línea; y aún se
      conserva una sintaxis sensible sin la confusión:
      </para>

      <programlisting>
       int* ipa;
               int* ipb;
               int* ipc;
</programlisting>        

      <!--
      Since a general guideline for C++ programming is that you should
      always initialize a variable at the point of definition, this form
      actually works better. For example, the variables above are not
      initialized to any particular value; they hold garbage. It's much
      better to say something like:
      -->

      <para>
      Ya que una pauta de programación de C++ es que siempre se debe
      inicializar una variable al definirla, esta manera es mejor. Por
      ejemplo, Las variables anteriores no se inicializan con ningún
      valor en particular; alojan basura. Es mas facil decir algo como:
      </para>

      <programlisting>
   int a = 47;
        int* ipa = &a;
</programlisting>        
      
      <!--
      Now both a and ipa have been initialized, and ipa holds the address of 
        a.
      -->

      <para>
      Ahora tanto "a" como "ipa" han sido inicializadas, y "ipa" aloja
      la dirección de "a".
      </para>


      <!--
      Once you have an initialized pointer, the most basic thing you can
      do with it is to use it to modify the value it points to. To
      access a variable through a pointer, you dereference the pointer
      using the same operator that you used to define it, like this:
      -->

      <para>
      Una vez que se inicializa un puntero, lo más básico que se puede
      hacer con el es utilizarlo para modificar el valor al que este
      apunta. Para acceder a la variable a través del puntero, se
      diferencia el puntero utilizando el mismo operador que se usó para
      definirlo, como sigue:
      </para>

      <programlisting>
       *ipa = 100;
</programlisting>

      <!--
        Now a contains the value 100 instead of 47.
      -->
      
      <para>
      Ahora "a" contiene el valor 100 en vez de 47.
      </para>

      <!--
      These are the basics of pointers: you can hold an address, and you
      can use that address to modify the original variable. But the
      question still remains: why do you want to modify one variable
      using another variable as a proxy?
      -->

      <para>
      Estas son las normas básicas de los punteros: se puede guardar una
      dirección, y se puede utilizar dicha dirección para modificar la
      variable original. Pero la cuestión siempre permanece: ¿por qué se
      requiere cambiar una variable utilizando otra variable como
      acceso?
      </para>

      <!--
      For this introductory view of pointers, we can put the answer into two 
      broad categories:
      -->

      <para>
      Para esta aproximación a los punteros, se puede dividir la
      respuesta en dos amplias categorías:
      </para>

      <!--
      1. To change "outside objects" from within a function. This is 
      perhaps the most basic use of pointers, and it will be examined
      here.
      -->
         
      <para>
      Para cambiar "objetos externos" desde dentro de una función. Esto
      es posiblemente el uso más básico de los punteros, y será
      examinado mas adelante.
      </para>

      <!--
      2. To achieve many other clever programming techniques, which
      you'll learn about in portions of the rest of the book.
      -->
   
      <para>
      Para alcanzar muchas otras inteligentes técnicas de programación,
      acerca de lo cual se aprenderá de apoco en el resto del libro.
      </para>
    </sect2>

    <sect2>
      <!-- Modifying the outside object -->
      <title>FIXME: Modifying the outside object</title>


      <!-- 
      Ordinarily, when you pass an argument to a function, a copy of that
      argument is made inside the function. This is referred to as
      pass-by-value. You can see the effect of pass-by-value in the
      following program:
      -->

      <para>
        Normalmente, cuando se pasa un argumento a una función, una copia de
        dicho argumento se hace dentro de la función. Esto se llama
        paso-por-valor. Se puede ver el efecto de un paso-por-valor en el
        siguiente programa:
      </para>
    
       //: C03:PassByValue.cpp
        
      <!--
        In f( ), a is a local variable, so it exists only for the duration of 
        the function call to f( ). Because it's a function argument, the value
        of a is initialized by the arguments that are passed when the function
        is called; in main( ) the argument is x, which has a value of 47, so
        this value is copied into a when f( ) is called.
      -->

      <para>
      En f(), "a" es una variable local, de modo que existe únicamente
      mientras dure la llamada a la funcion f(). Ya que es un argumento
      de una funcion, el valor de "a" se inicializa mediante los
      argumentos que son pasados cuando la función es llamada; en main()
      el argumento es "x", el cual tiene un valor de 47, de modo que el
      valor es copiado a "a" cuando se llama a f().
      </para>

      <!--
      When you run this program you'll see:
      -->
         
      <para>
      Cuando se ejecute el program se verá:
      </para>

      <programlisting>
      x = 47
               a = 47
               a = 5
               x = 47
</programlisting>        

      <!--
      Initially, of course, x is 47. When f( ) is called, temporary
      space is created to hold the variable a for the duration of the
      function call, and a is initialized by copying the value of x,
      which is verified by printing it out. Of course, you can change
      the value of a and show that it is changed. But when f( ) is
      completed, the temporary space that was created for a disappears,
      and we see that the only connection that ever existed between a
      and x happened when the value of x was copied into a.
      -->

      <para>
      Por supuesto, inicialmente "x" es 47. CUando f() es llamada, un
      espacio temporal se crea para alojar la variable "a" durante la
      llamada a la función, y "a" se inicializa copiando el valor de
      "x", el cual es verificado mostrandolo por pantalla. Se puede
      cambiar el valor de "a" y mostrar que ha sido cambiado. Pero
      cuando f() se completa, el espacio temporal que había sido creado
      para "a" desaparece, y se puede observar que la única conección
      que existía entre "a" y "x" ocurrió cuando el valor de "x" se
      copió en "a".
      </para>


      <!--
      When you're inside f( ), x is the outside object (my terminology),
      and changing the local variable does not affect the outside
      object, naturally enough, since they are two separate locations in
      storage. But what if you do want to modify the outside object?
      This is where pointers come in handy. In a sense, a pointer is an
      alias for another variable.  So if we pass a pointer into a
      function instead of an ordinary value, we are actually passing an
      alias to the outside object, enabling the function to modify that
      outside object, like this:
      -->

      <para>
      Cuando se está dentro de f(), "x" es el objeto externo (mi
      terminología), y el cambiar el valor de la variable local no
      afecta al objeto externo, lo cual es naturalmente suficiente, ya
      que son dos ubicaciones separadas en el espacio. ¿Pero y si se
      quiere modificar el objecto externo? Aquí es donde los punteros
      entran en acción. En cierto sentido, un puntero es un alias de
      otra variable. De modo que si a una función se le pasa un puntero
      en lugar de un valor ordinario, se está pasando de hecho un alias
      del objeto externo, dando la posibilidad a la función de que pueda
      modificar el objeto externo, como sigue:
      </para>


   //: C03:PassAddress.cpp

      <!--
      Now f( ) takes a pointer as an argument and dereferences the pointer 
      during assignment, and this causes the outside object x to be modified.
      The output is:
      -->
         
      <para>
      Ahora f() toma el puntero como un argumento y referencia el
      puntero durante la asignación, lo que causa que el objeto externo
      "x" sea modificado. La salida es:
      </para>

      <programlisting>
   x = 47
               &x = 0065FE00
               p = 0065FE00
               *p = 47 
               p = 0065FE00
           x = 5
</programlisting>

        
      <!--
      Notice that the value contained in pis the same as the address of
      x - the pointer p does indeed point to x. If that isn't convincing
      enough, when p is dereferenced to assign the value 5, we see that
      the value of x is now changed to 5 as well.
      -->

      <para>
      Notar que el valor contenido en "p" es el mismo que la dirección
      de "x" - el puntero "p" de hecho apunta a "x". Si esto no es
      suficientemente convincente, cuando "p" es dereferenciado para
      asinarle el valor 5, se ve que el valor de "x" cambia a 5 también.
      </para>

      <!--
      Thus, passing a pointer into a function will allow that function
      to modify the outside object. You'll see plenty of other uses for
      pointers later, but this is arguably the most basic and possibly
      the most common use.
      -->

      <para>
      Así, pasando un puntero a una función se permitirá a dicha función
      la modificación del objeto externo. Se verán muchos otros usos de
      los punteros más adelante, pero este es posiblemente el uso más
      básico y común.
      </para>
    </sect2>

 

    <sect2>
      <title>Introducción a las referencias de C++</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Punteros y referencias como modificadores</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Alcance</title>
    <para>
    </para>

    <sect2>
      <title>Definición de variables 'al vuelo'</title>
      <para>
      </para>
    </sect2>
  </sect1>

  
  <sect1>
    <!-- Specifying storage allocation -->
    <title>Especificación del almacenamiento</title>
    <para>
    </para>

    <sect2>
      <title>Variables globales</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Variables locales</title>
      <para>
      </para>
      <sect3>
	<title>Varibles-registro</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title><literal>static</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title><literal>extern</literal></title>
      <para>
      </para>
      <sect3>
	<title>Enlace</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Constantes</title>
      <para>
      </para>
      <sect3>
	<title>Valores constantes</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title><literal>volatile</literal></title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Los operadores y su uso</title>
    <para>
    </para>

    <sect2>
      <title>Asignación</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores matemáticos</title>
      <para>
      </para>
      <sect3>
	<title>Introducción a las macros del preprocesador</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Operadores relacionales</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores lógicos</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores para bits</title>
      <!-- Bitwise operators -->
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores de desplazamiento</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores unarios</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador ternario</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador ternario</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador ternario</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>El operador coma</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Trampas habituales cuando se usan los operadores</title>
      <!--  Common pitfalls when using operators -->
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores del molde (casting)</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Moldeado explícito en C++</title>
      <para>
      </para>

      <sect3>
	<title>Molde estático</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Molde constante</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>FIXME:  reinterpret_cast</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title><literal>sizeof</literal> - un operador en si mismo</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>La palabra reservada <literal>keyword</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Operadores explícitos</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Creación de tipos compuestos</title>
    <para>
    </para>
    
    <sect2>
      <title>Operadores explícitos</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Creación de alias usando <literal>typedef</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>
	Combinación de variables por medio de  <literal>struct</literal>
      </title>
      <para>
      </para>
      <sect3>
	<title>Punteros y estructuras</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Programas más claros gracias a <literal>enum</literal></title>
      <para>
      </para>

      <sect3>
	<title>Comprobación de tipos para las enumeraciones</title>
	<para>
	</para>
      </sect3>
    </sect2>


    <sect2>
      <title>Cómo Ahorrar memoria con <literal>union</literal></title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Arrays</title>
      <para>
      </para>

      <sect3>
	<title>Punteros y arrays</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>El formato de punto flotante</title>
	<!-- Exploring floating-point format -->
	<para>
	</para>
      </sect3>

     <sect3>
	<title>Aritmética de punteros</title>
	<para>
	</para>
      </sect3>

    </sect2>
  </sect1>


  <sect1>
    <title>FIXME: Debugging hints</title>
    <para>
    </para>

    <sect2>
      <title>Opciones para depuración</title>
      <para>
      </para>

      <sect3>
	<title>Opciones de depuración para el preprocesador</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Opciones de depuración en tiempo de ejecución</title>
	<para>
	</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Convertir variables y expresiones en cadenas</title>
      <!-- Turning variables and expressions into strings -->
      <para>
      </para>
    </sect2>

    <sect2>
      <title>La macro C assert()</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Direcciones de función</title>
    <para>
    </para>

    <sect2>
      <title>Definición de un puntero a función</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Declaraciones y definiciones complicadas</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Uso de un puntero a función</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Arrays de punteros a funciones</title>
      <para>
      </para>
    </sect2>
  </sect1>


  <sect1>
    <title>Make: cómo hacer compilación separada</title>
    <para>
    </para>

    <sect2>
      <title>Las actividades de Make</title>
      <para>
      </para>

      <sect3>
	<title>Macros</title>
	<para>
	</para>
      </sect3>


      <sect3>
	<title>Reglas de sufijo</title>
	<para>
	</para>
      </sect3>

      <sect3>
	<title>Objetivos por defecto</title>
	<para>
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Los Makefiles de este libro</title>
      <para>
      </para>
    </sect2>

    <sect2>
      <title>Un ejemplo de Makefile</title>
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>
    <para>
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>
    <xi:include parse="xml" href="./ejercicios.xml"/>

    <para>
    </para>
  </sect1>
</chapter>

