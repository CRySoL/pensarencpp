<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Sebastián Gurin <cancerbero_sgx@users.sourceforge.net>
  Formateado DocBook: Sebastián Gurin 
      <cancerbero_sgx@users.sourceforge.net> y David Villa <dvilla@gmx.net>
  1ª Revisión:
  2ª Revisión
-->

<!--

Traductor: Sebastián Gurin <cancerbero_sgx@users.sourceforge.net>

cosas por hacer:

(1) en los <programlisting> que comienzan con //:
    CXX:archivo-duente.cpp hay que hacer un Xinclude. 



(2) etiquetado de palabras reservadas:
    palabras reservadas -> <literal role="keyword"> </literal>
    operadores -> <literal role="operator"> </literal>

(3) [traducir] - significa traducir el término anterior al español. 

-->

<!-- 
	glosario de este capítulo:

	translation unit: unidad de traducción
	name clashes: conflicto entre nombres
	heap: heap
	heap compaction: defragmentación del heap 
	heap compactor: defragmentador del heap
	linker: enlazador
	linking: enlazamiento
	object file: archivo objeto
	header file: archivo de cabecera
	memory chunks: trozos de memoria
	handler: manipulador
	stack: stack
	push: meter
	pop: sacar
	cast: moldear, moldeado
	name space: espacio de nombres
	initialize: inicializar
	cleanup: destruir
	scope: ámbito
	scope resolution operator: operador de resolución de ámbito
        built in data type: tipo de dato integrado, predefinido
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">


<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C4">

    <title>Abstracción de Datos</title>
    
    <para>C++ es una herramienta de producción que ha sido
      mejorada con respecto a sus tecnologías predecesoras. ¿Por
      qué otro motivo usted debería hacer el esfuerzo de
      cambiarse a C++ (y es un esfuerzo, sin importar cuán
      fácilmente intentemos hacer esta transición), desde un
      lenguaje que le es bien conocido y con el cual ya es
      productivo? Sin lugar a dudas, una transición de este tipo
      hará que, mientras aprende el nuevo lenguaje, su nivel de
      productividad sea malo. ¿Por qué entonces hacerlo?  Déjeme
      responderle: es porque está convencido de que usando a esta
      nueva herramienta le podrá sacar mucho más
      provecho. </para>

    <para>En términos de programación, productividad significa
      que menos personas, en menos tiempo, puedan realizar
      programas más complejos y significativos. Desde luego, hay
      otras cuestiones que deben importarnos a la hora de escojer
      un lenguaje de programación. Aspectos a tener en cuenta son
      la eficiencia (¿la naturaleza del lenguaje hace que
      nuestros programas se enlentezcan o que sean demesiado
      grandes?), la seguridad (¿nos ayuda el lenguaje a
      asegurarnos de que nuestros programas hagan siempre lo que
      queremos? ¿maneja el lenguaje los errores apropiadamente?)
      y el mantenimiento (¿de qué manera nos ayuda el lenguaje a
      realizar código que sea fácil de entender, modificar y
      extender?). Estos son, con certeza, factores importantes
      que serán examinados en este libro. </para>

    <para>Hablando más toscamente, productividad significa que un
      programa que antiguamente les costaba a tres de ustedes una
      semana de trabajo en ser escrito, ahora le tome a tan sólo
      uno de ustede un día o dos. Esto toca varios niveles de la
      esfera económica. Usted se pone contento al ver que es
      capaz de construir algo en menos tiempo, sus clientes (o
      jefe) se sienten felices porque los productos les llegan
      más rápido y utilizando menos mano de obra y finalmente los
      compradores se sientes contentos porque pueden obtener
      productos más baratos. La única manera de obtener
      incrementos masivos en productividad es apoyándose en el
      código de otras personas; o sea, usando librerías.  </para>

    <para>Una librería es simplemente un manojo de código que
      alguien ha escrito y empaquetado todo junto. Muchas veces,
      el paquete mínimo es tan sólo un archivo con una extensión
      especial como <filename>lib</filename> y uno o más archivos
      de cabecera que le dicen al compilador qué hay en la
      librería. El enlazador sabrá cómo buscar el archivo de la
      librería y extraer el código compilado correcto. Sin
      embargo, esta es sólo una forma de entregar una
      librería. En plataformas que abarcan muchas arquitecturas,
      como Linux/Unix, el único modo sensato de entregar una
      libraría es con código fuente para que así pueda ser
      reconfigurado y reconstruido en el nuevo objetivo. </para>

    <para>De esta forma, las librerías probablemente sean las
      formas más importantes de progresar en términos de
      productividad y uno de los principales objetivos del diseño
      de C++ es hacer más fácil el uso de librerías. Esto implica
      entonces, que hay algo difícil en usar librerías en C. Si
      se entiende este factor, uno puede empezar a comprender el
      diseño de C++, y por lo tanto, cómo usarlo. </para>

  <sect1>
    <title>Una librería pequeña al estilo de C</title>

      <para>Aunque muchas veces, una librería comienza como una
        colección de funciones, si se ha usado alguna librería C
        relativamente seria se habrá observado que la cosa no
        termina ahí. Del mismo modo que "vida" es mucho más que
        comportamiento, acciones y transformaciones, en una
        biblioteca, además de funciones tenemos características
        (color, peso, textura, luminiscencia) las cuales son
        representados por datos. En C, cuando debemos representar
        características, es muy conveniente agruparlas todas
        juntas en una <emphasis>estructura</emphasis>,
        especialmente cuando queremos representar más de un tipo
        de cosa en nuestro problema. Así, se puede trabajar con
        una variable de estas <emphasis>estructuras</emphasis>
        para representar cada cosa. </para>
    
    <para>Así, la mayoría de las librerías en C constan de un
      conjunto de estructuras y un conjunto de funciones las
      cuales actúan sobre las primeras. Como un ejemplo sobre
      esta técnica, considérese la siguiente herramienta para
      programar la cual se comporta como un array, pero cuyo
      tamaño puede ser fijado en tiempo de ejecución, cuando se
      crea. La llamaremos <varname>CStash</varname><footnote>
        
        <para><quote>Stash</quote> se podría traducir al inglés
          como <quote>Acumulador</quote>. Nota del T. </para>

      </footnote>. Aunque la siguiente síntaxis es de C++, tiene
        el estilo clásico de una librería escrita en C:</para>


    <programlisting>
//: C04:CLib.h
// Archivo de cabecera para una librería al estilo C
// Una entidad parecida a un array cuyo tamaño puede 
// variar en tiempo de ejecución

typedef struct CStashTag {
   int size;      // Tamaño de cada espacio
   int quantity;  // Cantidad de espacios de almacenamiento
   int next;      // Próximo espacio vacío
   // Array dinámico de bytes:
   unsigned char* storage;
} CStash;

void initialize(CStash* s, int size);
void cleanup(CStash* s);
int add(CStash* s, const void* element);
void* fetch(CStash* s, int index);
int count(CStash* s);
void inflate(CStash* s, int increase);

///:~ 
      </programlisting>

      <para>Una etiqueta como <varname>CStashTag</varname> casi
        siempre se usa en aquellas estructuras que necesitan ser
        referenciadas dentro de ellas mismas. Tal es el caso de
        una <emphasis>lista enlazada</emphasis> en la cual se
        necesita un puntero a la siguiente variable de
        estructura, o sea, una manera de identificar el tipo de
        ese puntero dentro de la misma estructura. También es muy
        común ver en la declaración de las estructuras de una
        librería escrita en C el uso de
        <literal>typedef</literal> análogo al del ejemplo. Esto
        permite al programador tratar las estructuras como un
        nuevo tipo de dato y así definir nuevas variables (de esa
        estructura) del siguiente modo:</para>

    <programlisting>CStash A, B, C;</programlisting>

      <para>El puntero <varname>storage</varname> es un
        <type>unsigned char*</type>. Un <type>unsigned
        char</type> es la menor pieza de datos que un compilador
        C soporta aunque, en algunas máquinas puede ser de igual
        tamaño que la mayor. Aunque esto es dependiente de la
        implementación, por lo general un <type>unsigned
        char</type> es de un byte de tamaño. Dado que el
        <type>CStash</type> está diseñado para almacenar
        cualquier tipo de estructura el lector se puede preguntar
        si un puntero <type>void *</type> no sería más
        apropiado. Sin embargo, la idea no es tratar este puntero
        de almacenamiento como un bloque de datos de tipo
        desconocido, sino como un bloque de bytes
        contiguos. </para>

      <para>El archivo de código fuente para la implementación
        luce del siguiente modo (tener en cuenta que si la
        librería fuera comercial, es probable que no tengamos
        acceso al código fuente y sólo dispongamos de un archivo
        ya compilado <filename>obj</filename>,
        <filename>lib</filename> o <filename>dll</filename>,
        etc): </para>

<programlisting>
<xi:include parse="text" href="./code/C04/CLib.cpp"/>
</programlisting>

      <para><function>initialize()</function> realiza las
        disposiciones iniciales necesarias para la <type>struct
        CStash</type>, poniendo los valores apropiados en las
        variables internas. Inicialmente, el puntero
        <varname>storage</varname> es puesto a cero dado que aún
        no se ha almacenado nada. </para>

      <para>La función <function>add()</function> inserta un
        elemento en el siguiente lugar disponible de la
        <type>CStash</type>. Para esto, primero verifica que
        halla suficiente espacio disponible. Si no lo hay,
        expande el almacenaje (storage) usando la función
        <function>inflate()</function> que será descripta en
        breve.</para>

      <para>Dado que en tiempo de ejecución el compilador es
        incapaz de reconocer el tipo de variable que va a ser
        almacenado (la función tan sólo acepta un <type>void
        *</type>), no puede hacerse una simple asignación, que
        sería lo más conveniente. En lugar de esto, la variable
        es copiada byte a byte. La manera más directa de hacer
        esto es utilizando el indexado de arrays. En un momento
        dado, el caso más probable es que en
        <varname>storage</varname> ya hallan bytes almacenados,
        lo cual es indicado por <varname>next</varname>. Para
        obtener la posición de inserción correcta en el array, se
        multiplica <varname>next</varname> por el tamaño de cada
        elemento (en bytes) lo cual queda determinado en
        <varname>startBytes</varname>. Luego el argumento
        <varname>element</varname> se moldea a <type>unsigned
        char*</type> para que pueda ser referenciado y copiado
        byte a byte en el espacio disponible de
        <varname>storage</varname>. Se incrementa
        <varname>next</varname> de modo que indique el siguiente
        lugar de almacenamiento disponible y sae devuelve el
        número de índice del elemento insertado para que pueda
        ser recuperado con <function>fetch()</function>.  </para>
    
      <!-- Because the comqpiler doesn?t know the specific type
      of the variable being stored (all the function gets is a
      void*), you can?t just do an assignment, which would
      certainly be the convenient thing. Instead, you must copy
      the variable byte-by-byte. The most straightforward way to
      perform the copying is with array indexing. Typically,
      there are already data bytes in storage, and this is
      indicated by the value of next. To start with the right
      byte offset, next is multiplied by the size of each element
      (in bytes) to produce startBytes. Then the argument element
      is cast to an unsigned char* so that it can be addressed
      byte-by-byte and copied into the available storage
      space. next is incremented so that it indicates the next
      available piece of storage, and the ?index number? where
      the value was stored so that value can be retrieved using
      this index number with fetch( ).  -->

      <para><function>fetch()</function> verifica que el índice
        tenga un valor correcto y devuelve la dirección de la
        variable deseada, la cual se calcula en función del
        argumento <varname>index</varname>. Dado que
        <varname>index</varname> es el número de elementos a
        desplazarnos desde el principio [fixme: "the number of
        elements to offset into the CStash"] en la CStash, éste
        debe ser multiplicado por el tamaño en bytes que ocupa un
        elemento para obtener dicho desplazamiento pero en
        bytes. Cuando utilizamos este desplazamiento como índice
        del array <varname>storage</varname> lo que obtenemos no
        es la dirección, sino el byte almacenado en esta. Lo que
        hacemos entonces es utilizar el operador de dirección de
        memoria <literal role="operator">&amp;</literal>. </para>
    
      <!--fetch( ) checks to see that the index isn?t out of
      bounds and then returns the address of the desired
      variable, calculated using the index argument. Since index
      indicates the number of elements to offset into the CStash,
      it must be multiplied by the number of bytes occupied by
      each piece to produce the numerical offset in bytes. When
      this offset is used to index into storage using array
      indexing, you don?t get the address, but instead the byte
      at the address. To produce the address, you must use the
      address-of operator &.-->
    
      <para><function>count()</function> puede parecer un poco
        extraña a los programadores experimentados en C. Podría
        parecer demasiada complicación para una tarea que
        probablemente sea mucho más fácil de hacer a mano. Por
        ejemplo, si tenemos una <type>CStash</type> llamada
        <varname>intStash</varname>, es mucho más directo
        preguntar por la cantidad de elementos utilizando
        <varname>intStash.next</varname>, que llamando a la
        función (lo cual agrega un costo de velocidad adicional)
        <function>count(&amp;intStash)</function>. Sin embargo,
        la cantidad de elementos se calcula en función tanto del
        puntero <varname>next</varname> como del tamaño en bytes
        de cada elemento de la CStash; así la interfaz de la
        función <function>count()</function> nos permite la
        flexibilidad necesaria para no tener que preocuparnos por
        estas cosas. Pero, ¡hay!, la mayoría de los programadores
        no se preocuparán por descubrir lo que para nosotros es
        el <quote>mejor</quote> diseño para la
        librería. Probablemente lo que harán es mirar dentro de
        la estructura y obtener el valor de
        <varname>next</varname> directamente. Peor aún, podrían
        hasta cambiar el valor de <varname>next</varname> sin
        nuestro permiso. ¡Si sólo hubiera alguna manera para el
        diseñador de la librería de tener un mejor control sobre
        este tipo de cosas! (Si, estamos anunciando el comienzo
        de temas que vendrán...[fixme: ver abajo en inglés:
        foreshadowing]). </para>
    
      <!--count( ) may look a bit strange at first to a seasoned
      C programmer. It seems like a lot of trouble to go through
      to do something that would probably be a lot easier to do
      by hand. If you have a struct CStash called intStash, for
      example, it would seem much more straightforward to find
      out how many elements it has by saying intStash.next
      instead of making a function call (which has overhead),
      such as count(&intStash). However, if you wanted to change
      the internal representation of CStash and thus the way the
      count was calculated, the function call interface allows
      the necessary flexibility. But alas, most programmers won?t
      bother to find out about your ?better? design for the
      library. They?ll look at the struct and grab the next value
      directly, and possibly even change next without your
      permission. If only there were some way for the library
      designer to have better control over things like this!
      (Yes, that?s foreshadowing.)-->



    <sect2>
      <title>Almacenamiento dinámico</title>

        <!-- [FIXME: yo le hubiera llamado <title>Asignación de
      memoria dinámica</title>]-->

        <para>Dado que nunca conoceremos la cantidad máxima de
          almacenamiento que necesitaremos para una
          <type>CStash</type>, la memoria a la que apuntan los
          elementos de <varname>storage</varname> es asignada
          desde el <emphasis>heap</emphasis><footnote>

            <para><emphasis>heap</emphasis> puede traducirse al
              español como "montón" o "montículo". </para>

          </footnote>. El heap es un gran montón de memoria usado
          para asignar pequeñas piezas en tiempo de
          ejecución. Usamos el heap cuando no sabemos de antemano
          la cantidad de memoria que necesitará el programa que
          estamos escribiendo. Por ejemplo, esto se da en un
          programa en el que sólo en tiempo de ejecución sabremos
          si necesitamos memoria para 200 variables
          <type>Avion</type> o para 20. En C stándar, las
          funciones para asignación de memoria dinámica incluyen
          a <function>malloc()</function>,
          <function>calloc()</function>,
          <function>realloc()</function> y
          <function>free()</function>. En lugar de llamadas a
          librerías, C++ cuenta con una técnica más sofisticada
          (y por lo tanto más fácil de usar) para tratar con
          memoria dinámica. Esta técnica está integrada en el
          lenguaje por medio de las palabras reservadas <literal
          role="keyword">new</literal> y <literal
          role="keyword">delete</literal>. </para>

        <!-- You never know the maximum amount of storage you
        might need for a CStash, so the memory pointed to by
        storage is allocated from the heap. The heap is a big
        block of memory used for allocating smaller pieces at
        runtime. You use the heap when you don?t know the size of
        the memory you?ll need while you?re writing a
        program. That is, only at runtime will you find out that
        you need space to hold 200 Airplane variables instead of
        20. In Standard C, dynamic-memory allocation functions
        include malloc( ), calloc( ), realloc( ), and free(
        ). Instead of library calls, however, C++ has a more
        sophisticated (albeit simpler to use) approach to dynamic
        memory that is integrated into the language via the
        keywords new and delete.  -->

        <para>La función <function>inflate()</function> usa
          <literal role="keyword">new</literal> para obtener más memoria
          para la <type>CStash</type>. En este caso sólo
          expandiremos el espaciode memoria y nunca lo
          achicaremos. <function>assert()</function> garantizará
          que no se pase un número negativo como argumento a
          <function>inflate()</function> como valor de
          incremento. La nueva cantidad de elmentos que se podrán
          almacenar (una vez se halla completado
          <function>inflate()</function> se determina en la
          variable <varname>newQuantity</varname> la cual es
          multiplicada por el número de bytes que ocupa cada
          elemento para obtener el nuevo número de bytes totales
          de la asignación en la variable
          <varname>newBytes</varname>. Dado que conocemos cuántos
          bytes copiar desde la ubicación anterios,
          <varname>oldBytes</varname> es calculado usando la
          cantidad vieja de bytes
          (<varname>quantity</varname>). </para>

        <!--The inflate( ) function uses new to get a bigger
        chunk of space for the CStash. In this situation, we will
        only expand memory and not shrink it, and the assert( )
        will guarantee that a negative number is not passed to
        inflate( ) as the increase value. The new number of
        elements that can be held (after inflate( ) completes) is
        calculated as newQuantity, and this is multiplied by the
        number of bytes per element to produce newBytes, which
        will be the number of bytes in the allocation. So that we
        know how many bytes to copy over from the old location,
        oldBytes is calculated using the old quantity.-->

        <para>La asignación de memoria ocurre en la
          <emphasis>expresión-new</emphasis> la cual involucra la
          palabra clave <literal role="keyword">new</literal>:
	</para>

      <para><programlisting>
new unsigned char[newBytes];
      </programlisting></para>

        <para>La forma general de una
          <emphasis>expresión-new</emphasis> es</para>

      <programlisting>new Type;</programlisting>

        <para>donde <literal>Type</literal> describe el tipo de
          variable para la cual deseamos asignar memoria en el
          <emphasis>heap</emphasis>. Dado que en este caso,
          deseamos asignar memoria para un array de
          <type>unsigned char</type> de
          <varname>newBytes</varname> elementos, eso es lo que
          ponemos como <literal>Type</literal>. De igual forma
          podemos asignar memoria para algo más simple como un
          <type>int</type> con la expresión
	</para>

      <programlisting>new int;</programlisting>

        <para>y aunque esto no sea muy útil muestra que la forma
          de la <emphasis>expresión-new</emphasis> es
          consistente. </para>

        <para>Una <emphasis>expresión-new</emphasis> devuelve un
          puntero a un objeto de tipo (Type) igual al
          especificado por nosotros. Así, si pedimos <literal>new
          Type</literal> obtendremos un puntero a un objeto de
          tipo <literal>Type</literal>, si decimos <literal>new
          int</literal> obtendremos un puntero a un entero. Si
          queremos un nuevo array de <type>unsigned char</type>
          (a <literal>new unsigned char </literal>array, en
          inglés) la expresión nos devolverá un puntero al primer
          elemento de dicho array. El compilador verificará que
          se asigne lo que devuelve una
          <emphasis>expresión-new</emphasis> a una variable
          puntero de tipo correcto. </para>

        <para>Por supuesto, es posible que al pedir memoria, la
          petición falle, por ejemplo, si no hay más memoria
          libre en el sistema. Como se aprenderá más adelante,
          C++ cuenta con mecanismos que entran en juego cuando la
          operación de asignación de memoria no fue
          exitosa. </para>

        <para>Sigamos con nuestro código. Una vez que hemos
          asignado memoria para el nuevo espacio de
          almacenamiento (variable <varname>storage</varname>),
          los datos que están en el viejo espacio de
          almacenamiento deben ser copiados al nuevo. Esto se
          hace, nuevamente, en un bucle, utilizando la notación
          de índexado de arrays, copiando un byte en cada
          iteración del bucle. Una vez finalizada esta copia, ya
          no necesitaremos los datos que están en el espacio de
          almacenamiento viejo por lo que pueden ser liberados de
          la memoria para que otras partes del programa puedan
          usar este espacio cuando lo necesiten. La palabra
          reservada <literal role="keyword">delete</literal> es
          el complemento de <literal role="keyword">new</literal> y debe
          ser utilizada sobre todas aquellas variables a las
          cuales se les halla asignado memoria con <literal
          role="keyword">new</literal>. (Si nos olvidamos de utilizar
          <literal role="keyword">delete</literal> la memoria del heap
          asignada con <literal role="keyword">new</literal> permanecerá
          no disponible. Si estas fugas de memoria
          (<emphasis>memory leak</emphasis>) son muchas podremos
          quedarnos sin memoria disponible para asignar.) La
          síntaxis de <literal role="keyword">delete</literal> es
          consistente con la de <literal role="keyword">new</literal>
          salvo para el caso de los arrays: cuando queremos
          liberar un array, debemos informarle al compilador que
          el puntero no apunta a un simple objeto sino a un array
          de objetos. Para esto se inserta un par de paréntesis
          rectos como prefijo del puntero que va a ser liberado:
          </para>

      <programlisting>delete []myArray;</programlisting>

        <para>Luego de liberar el viejo espacio de almacenamiento
        se asigna el nuevo (en el cual ya hicimos la copia del
        viejo) al puntero <varname>storage</varname> y se
        actualiza <varname>quantity</varname>. Así termina la
        función <function>inflate()</function>. </para>

<!-- FIXME: en el siguiente párrafo traduje "heap compaction" -->
<!-- como "defragmentación del heap" y "heap compactor" como -->
<!-- "defragmentador del heap". -->

        <para>A este punto es bueno notar que el administrador de
          memoria del heap es una primitiva del lenguaje. Nos
          provee de trozos [FIXME:chunks] de memoria cuando se lo
          pedimos con <literal role="keyword">new</literal> y nos los
          quita cuando invocamos a <literal
          role="keyword">delete</literal>. Si un programa asigna y
          libera memoria muchas veces, terminaremos con un heap
          <emphasis>fragmentado</emphasis>, es decir un heap en
          el que si bien puede haber memoria libre para ser
          utilizada, los trozos de memoria están divididos de
          modo tal que no exista un trozo lo que sea lo grande
          que necesitamos en un momento dado. Lamentablemente no
          existe una capacidad inherente del lenguaje para
          efectuar <emphasis>defragmentaciones del heap</emphasis>. Un
          defragmentador del heap complica las cosas dado que
          tiene que mover pedazos de memoria, y por lo tanto,
          hacer que los punteros dejen de apuntar a valores
          válidos. Algunos entornos operativos vienen con este
          tipo de facilidades pero obligan al programador a
          utilizar manipuladores [FIXME:handles] de memoria
          especiales en lugar de punteros (estos manipuladores
          pueden ser convertidos temporalmente en punteros luego
          de bloquear la memoria para que el defragmentador del
          heap no la modifique). También podemos construir por
          nosotros mismos uno de estos artilugios, aunque no es
          una tarea liviana.</para>

          <para>Cuando creamos una variable en el stack en tiempo
          de compilación el mismo compilador es quien se encarga
          de crearla y liberar la memoria ocupada por ella
          automáticamente. Conoce exactamente el tamaño y la
          duración de este tipo de variables dada por las reglas
          de scoping [traducir]. Sin embargo, en el caso de las
          variables almacenadas dinámicamente, el compilador no
          poseerá información ni del tamaño requerido por las
          mismas, ni de su duración. Esto significa que el
          compilador no puede encargarse de liberar
          automáticamente la memoria ocupada por este tipo de
          variables y de aquí que el responsable de esta tarea
          sea el programador (o sea usted). Para esto se debe
          utilizar <literal role="keyword">delete</literal> lo
          cual le indica al administrador del heap que ese
          espacio de memoria puede ser utilizado por la próxima
          llamada a <literal role="keyword">new</literal>. En
          nuestra librería de ejemplo, el lugar lógico para esta
          tarea es la función <function>cleanup()</function> dado que
          allí es dónde se deben realizar todas las labores de
          finalización de uso del objeto. </para>

	<para>Para testear la librería creamos dos Cstash, una
        que almacene enteros y otra para cadenas de 80
        caracteres:
	</para>

<programlisting>
<xi:include parse="text" href="./code/C04/CLibTest.cpp"/>
</programlisting>


	<para>Dado que debemos respetar la sintaxis de C, todas
        las variables se deben declarar al comienzo de
        <function>main()</function>. Obviamente, no nos podemos
        olvidar de inicializar todas las variables
        <type>Cstash</type> más adelante en el bloque main(), pero
        antes de usarlas llamando a
        <function>initialize()</function>. Uno de los problemas con las
        librerías en C es que uno debe asegurarse de convencer al
        usuario de la importancia de las funciones de
        inicialización y destrucción.  Habrá muchos problemas si
        estas funciones se omiten!  Lamentablemente el usuario no
        siempre se preguntará si la inicialización y el limpiado
        de los objetos son obligatorios. Ellos le darán
        importancia a lo que <emphasis>ellos</emphasis> quieren hacer y
        no nos darán tanta importancia a nosotros (el programador
        de la librería) cuando les digamos <quote>¡Hey! ¡espera
        un poco! ¡Debes hacer <emphasis>esto</emphasis>
        primero!"</quote>. Otro problema que puede presentarse es el
        hecho de que algunos usuarios quieran inicializar los
        elementos (datos internos) de una estructura por si
        mismos. En C no hay un mecanismo para prevenir este tipo
        de conductas (más presagios de los temás que
        vendrán...). </para>

      <para>La <varname>intStash</varname> se va llenando con enteros
        mientras que el <varname>stringStash</varname> se va llenando
        con arrays de caracteres. Estos arrays de caracteres son
        producidos leyendo el archivo fuente
        <filename>CLibTest.cpp</filename> y almacenando las
        líneas de este archivo en el <type>string</type>
        <varname>line</varname>. Obtenemos la representación "puntero a
        caracter" de <varname>line</varname> con la función miembro
        <function>c_str()</function>. </para>

      <para>Luego de cargadas las <type>Stash</type> ambas se
      muestran en pantalla. La <varname>intStash</varname> se imprime
      usando un bucle <literal role="keyword">for</literal> en el
      cual se usa <function>count()</function> para determinar la
      cantidad de elementos. La <varname>stringStash</varname> se
      muestra utilizando un bucle <literal
      role="keyword">while</literal> dentro del cual se va llamando a
      <function>fetch()</function>. Cuando esta función devuelve cero se
      rompe el bucle ya que esto significará que hemos
      sobrepasado los límites de la estructura. </para>

      <para>El lector también pudo haber visto un moldeado[fixme:
      cast] adicional en la línea:</para>

<programlisting>
cp = (char*)fetch(&amp;stringStash,i++)
	</programlisting>

      <para>Esto se debe a la comprobación estricta de tipos en
      C++ lo cual no nos permite asignar un <type>void *</type> a una
      variable de cualquier tipo, mientras que C sí nos permite
      esto. </para>


    </sect2>
    



    <sect2>

      <title>Suposiciones equivocadas</title>

      <para>Antes de meternos en los problemas principales de
      crear una librería en C, discutiremos un último asunto que
      nos parece importante tener claro. El archivo de cabecera
      <filename>CLib.h</filename> <emphasis>debe</emphasis> ser incluído en cada
      archivo fuente que haga referencia al tipo <type>CStash</type>
      ya que el compilador nisiquiera tiene formas de
      adivinar[FIXME:poner sinónimo] qué forma tiene la
      estructura. Sin embargo, <emphasis>sí</emphasis> puede adivinar la
      forma de una función. Aunque esto pueda parecernos una
      característica positiva, veremos porqué, en realidad, es un
      fallo mayor de C. 
	</para>

      <para>Aunque siempre deberíamos declarar las funciones
      incluyendo un archivo de cabecera, en C las declaraciones
      de funciones no son esenciales. En este lenguaje (pero no
      en C++), es posible llamar a una función que no ha sido
      declarada. Un buen compilador seguramente nos avisará de
      que deberíamos declarar una función antes de usarla, pero
      nos permitirá seguir dado que no es obligatorio hacerlo en
      C estándar. Esta es una práctica peligrosa ya que el
      compilador puede asumir que una función que ha sido llamada
      con un <type>int</type> como argumento, tenga un <type>int</type>
      como argumento mientras que, en realidad, contiene un
      <type>float</type>. Como veremos, esto puede producir errores
      en los programas que pueden ser muy difíciles de
      depurar. </para>

      <para>Se dice que cada archivo de implementación C (los
      archivos de extensión <filename>.c</filename>) es una unidad de
      traducción [fixme:translation unit]. El compilador se
      ejecuta independientemente sobre cada unidad de traducción
      ocupándose, en ese momento, solamente en ese archivo. Así,
      la información que le demos al compilador por medio de los
      archivos de cabecera es muy importante dado que determina
      cómo ese archivo se relaciona con las demás partes del
      programa. Luego, las declaraciones en los archivos de
      cabecera son particularmente importantes dado que, en cada
      lugar que se incluyen, el compilador sabrá exactamente qué
      hacer. Por ejemplo, si en un archivo de cabecera tenemos la
      declaración <function>void func(float) </function>,si llamamos a
      <function>func()</function> con un <type>int</type> como argumento, el
      compilador sabrá que deberá convertir el <type>int</type> a
      <type>float</type> antes de pasarle el valor a la función (a
      esto se le llama <emphasis>promoción</emphasis>). Sin la
      declaración, el compilador asumirá que la declaración
      función tiene la forma <function>func(int)</function>, no se
      realizará la promoción y se pasarán, por lo tanto, datos
      incorrectos a la función. </para>

      <para>Para cada unidad de traducción el compilador crea un
      archivo objeto, de extensión <filename>.o</filename>,
      <filename>.obj</filename> o algo por el estilo. Estos archivos
      objeto, junto con algo de código de arranque son unidos por
      el enlazador[fixme:linker] para crear el programa
      ejecutable. Durante el enlazamiento[fixme:linking], todas
      las referencias externas deven ser resueltas. Por ejemplo,
      en archivos como <filename>CLibTest.cpp</filename>, funciones como
      <function>initialize()</function> y <function>fetch()</function> son
      declaradas (o sea, se le informa al compilador qué forma
      tienen estas funciones) y usadas, pero no son
      definidas. Están definidas en otro lugar, en este caso en
      el archivo <filename>CLib.cpp</filename>. Así, las llamadas que se
      hacen en <filename>CLibTest.cpp</filename> a estas funciones son
      referencias externas. Cuando se unen los archivos objeto
      para formar el programa ejecutable, el enlazador debe, para
      cada referencia externa no resuelta, encontrar la dirección
      a la que hace referencia y reemplazar cada referencia
      externa con su correspondiente dirección. 
	</para>

      <para>Es importante destacar que en C, estas referencias
      externas que el enlazador busca son simples nombres de
      funciones, generalmente precedidas por un guión bajo. De
      esta forma, todo lo que el enlazador debe efectuar es,
      hacer corresponder el nombre de la función que se llama,
      con el cuerpo (definición, código) de la función del
      archivo objeto, en el lugar exacto de la llamada a dicha
      función. Si, por ejemplo, accidentalmente hacemos una
      llamada a una función que el compilador interprete como
      <function>func(int)</function> y existe una definición de función
      para <function>func(float)</function> en algún archivo objeto, el
      enlazador verá <function>_func</function> en un lugar y
      <function>_func</function> en otro, por lo que <emphasis>pensará</emphasis>
      que todo está bien. En la llamada a <function>func()</function> se
      meterá[fixme:push] un <type>int</type> en el stack pero el
      cuerpo de la función <function>func()</function> esperará que un
      <type>float</type> esté en el stack. Si la función sólo lee el
      valor de este dato y no lo escribe, el stack no
      reventará. De hecho, el supuesto <type>float</type> leído del
      stack puede terner algo de sentido: la función seguirá
      corriendo aunque sobre basura, y es por esto que las fallas
      originadas por esta clase de errores son muy difíciles de
      encontrar. </para>


    </sect2>

  </sect1>





  <sect1>
    <title>¿Qué está mal?</title>
    
    <para>Somos seres realmente destinados a la adaptación: nos
    adaptamos a situaciones en las que, quizá, no <emphasis>no
    deberíamos</emphasis> hacerlo. El estilo de la librería
    <type>Cstash</type> ha sido un modelo a seguir por los
    programadores en C durante mucho tiempo. Sin embargo, si nos
    ponemos a examinarla por un momento, nos daremos cuenta de
    que utilizar esta librería puede resultar algo
    engorroso[fixme: awkward]. Cuando la usamos debemos, por
    ejemplo, pasar la dirección de la estructura a cada función
    de la librería. Así, cuando leemos el código, los mecanismos
    de la librería se mezclan con el significado de las llamadas
    a las funciones, lo cual dificulta el entender lo que el
    programa hace.  </para>

    <para>Sin embargo, uno de los mayores obstáculos de trabajar
    con librerías en C es el problema llamado <emphasis>conflicto
    de nombres</emphasis>[FIXME:name clashes]. C trabaja con un único
    espacio de nombres de funciones. Esto significa que, cuando
    el enlazador busca por el nombre de una función, lo hace en
    una única lista de nombres maestra. Más aún, cuando el
    compilador trabaja sobre una unidad de traducción, un nombre
    de función sólo puede hacer referencia a una única función
    con ese nombre. 
      </para>

    <para>Supongamos que compramos dos librerías de diferentes
      proveedores y que cada librería consta de una estructura
      que debe ser inicializada y destruida. Supongamos que cada
      proveedor ha decidido nombrar a dichas operaciones
      <function>initialize()</function> y <function>cleanup()</function>. ¿Cómo
      se comportaría el compilador si incluyéramos los archivos
      de cabecera de ambas librerías en la misma unidad de
      traducción? Afortunadamente, el compilador C dará un
      mensaje de error diciéndonos que hay una incoherencia de
      tipos en las listas de argumentos de ambas
      declaraciones. No obstante, aunque no incluyamos los
      archivos de cabecera en la unidad de traducción igual
      tendremos problemas con el enlazador. Un buen enlazador
      detectará y avisará cuando se produzca uno de estos
      conflictos de nombres. Sin embargo, hay otros que
      simplemente tomarán el primer nombre de la función que se
      les aparezca, buscando en los archivos objetos en el orden
      en el que fueron pasados en la lista de enlazamiento. (Este
      comportamiento puede ser considerado como una ventaja ya
      que nos permite reemplazar las funciones de las librerías
      ajenas con nuestras propias funciones.)
      </para>

    <para>En cualquiera de los dos casos, llegamos a la
    conclusión de que en C es imposible usar dos bibliotecas en
    las cuales existan funciones con nombres idénticos. Para
    solucionar este problema, los proveedores de librerías en C
    ponen un prefijo único a todas las funciones de la
    librería. En nuestro ejemplo, a las funciones
    <function>initialize()</function> y <function>cleanup()</function> podríamos
    renombrarlas como <function>CStash_initialize()</function> y
    <function>CStash_cleanup()</function>. Esta es una técnica lógica:
    decoramos los nombres de las funciones con el nombre de la
    estructura sobre la cual éstas trabajan.</para>

    <para>Este es el momento de dirigir nuestros pasos a las
    primeras nociones de construcción de clases en C++. Como el
    lector ha de saber, las variables declaradas dentro de una
    estructura no tienen conflictos de nombres con las variables
    globales. ¿Por qué, entonces, no aprovechar esta
    característica de las variables para evitar los conflictos de
    nombres de funciones declarándolas dentro de la estructura
    sobre la cual operan? O sea, ¿por qué no hacer que las
    funciones sean también miembros de las estructuras?
      </para>

  </sect1>




  <sect1>

    <title>El objeto básico</title>

    <para>Nuestro primer paso será exactamente lo mencionado
    anteriormente: Meter las funciones C++ dentro de las
    estructuras como "funciones miembro". Así se verá nuestra
    estructura luego de realizados estos cambios de la versión C
    de la <type>CStash</type> a la versión en C++ a la cual
    llamaremos <type>Stash</type>:  </para>


<programlisting>
//: C04:CppLib.h
// Librería al estilo C convertida a C++ 
struct Stash {
  int size;      // Tamaño de cada espacio
  int quantity;  // Cantidad de espacios de almacenamiento
  int next;      // Próximo espacio vacío
   // Array de bytes almacenado dinámicamente :
  unsigned char* storage;
  // Funciones!
  void initialize(int size);
  void cleanup();
  int add(const void* element);
  void* fetch(int index);
  int count();
  void inflate(int increase);
}; ///:~

      </programlisting>

    <para>La primera diferencia que puede notarse es que no se
    usa <literal role="keyword">typedef</literal>. A diferencia de C que
    requiere el uso de <literal role="keyword">typedef</literal> para
    crear nuevos tipos de datos, el compilador de C++ hará que el
    nombre de la estructura sea un nuevo tipo de dato
    automáticamente en nuestro programa (tal como los nombres de
    tipos de datos <type>int</type>, <type>char</type>, <type>float</type> y
    <type>double</type>).
      </para>
    
    <para>Todos los datos miembros de la estructura están
    declarados igual que antes; sin embargo, ahora las funciones
    están declaradas dentro del cuerpo de la <literal
    role="keyword">struct</literal>. Más aún, nótese que el primer
    argumento de todas las funciones ha sido quitado de estas. En
    C++, en lugar de forzar al usuario a que pase la dirección de
    la estructura sobre la que trabaja una función como primer
    argumento, el compilador hará este trabajo,
    secretamente. Ahora sólo deberemos preocuparnos por los
    argumentos que le dan sentido a lo que la función
    <emphasis>hace</emphasis> y no de los mecanismos internos de
    funcionamiento de la función.</para>

    <para>Es importante saber que el código generado por estas
    funciones es el mismo que el de las funciones de la librería
    al estilo C. El número de argumentos es el mismo (aunque no
    veamos que se pase la dirección de la estructura como primer
    argumento, en realidad sí se hace) y sigue existiendo un
    único cuerpo (definición) de cada función. Esto último quiere
    decir que, aunque declaremos múltiples variables

      <programlisting>Stash A, B, C;</programlisting> 

      no existirán múltiples definiciones de, por ejemplo, la
      función <function>add()</function>, una para cada variable. 
      </para>

    <para>Como ya dijimos, el código generado es casi idéntico al
    que hubiésemos escrito para una versión en C de la librería,
    incluyendo la "decoración de nombres" ya mencionada para
    evitar los conflictos de nombres, nombrando a las funciones
    <function>Stash_initialize()</function>, <function>Stash_cleanup(
    )</function> y demás. Cuando una función está dentro de una
    estructura, el compilador C++ hace lo mismo y así, una función
    llamada <function>initialize()</function> dentro de una estructura no
    estará en conflicto con otra función
    <function>initialize()</function> dentro de otra estructura o con una
    función <function>initialize()</function> global. De este modo, en
    general no tendremos que preocuparnos por el conflicto de
    nombres de funciones --usamos el nombre sin decoración. Sin
    embargo, habrán situaciones en las que deseamos especificar
    que, por ejemplo, esta <function>initialize()</function> pertenece a
    la estructura <type>Stash</type> y no a ninguna otra. En
    particular, cuando definimos la función, necesitamos
    especificar a qué estructura pertenece para lo cual, en C++
    contamos con el operador <literal role="operator">[FIXME:
    arreglar etiqueta]::</literal> llamado operador de resolución de
    ámbito (llamado así ya que ahora, como vimos, un nombre puede
    estar en diferentes ámbitos: el el ámbito global o dentro del
    ámbito de una estructura. Por ejemplo, si nos queremos
    referir a una función <function>initialize()</function> que se
    encuentra dentro de la estructura <type>Stash</type> lo podremos
    hacer con la expresión <function>Stash::initialize(int
    size)</function>. A continuación se podrá ver cómo se usa el operador
    de resolución de ámbito para definir funciones: [fixme:
    traducir el siguiente programlisting]</para>


<programlisting>
<xi:include parse="text" href="./code/C04/CppLib.cpp"/>
</programlisting>

    <para>Hay muchas otras cosas que son diferentes entre C y
      C++. Para empezar, el compilador
      <emphasis>requiere</emphasis> que declaremos las funciones
      en los archivos de cabecera: en C++ no podremos llamar a
      una función sin antes haberla declarado y si no se cumple
      con esta regla el compilador dará un error. Esta es una
      forma importante de asegurar que las llamadas a una función
      son consistentes entre el punto en el cual fue llamada y el
      punto y el cual fue definida. Al forzarnos a declarar una
      función antes de usarla, el compilador de C++ virtualmente
      se asegura de que realizaremos esta declaración por medio
      de la inclusión de un archivo de cabecera. Además, si
      también incluímos el mismo archivo de cabecera en el mismo
      lugar donde las funciones son definidas, el compilador
      también verificará que las declaraciones en el archivo
      cabecera y las definiciones coincidan. Puede decirse
      entonces que, de alguna manera, los archivos de cabecera se
      vuelven un repositorio de validación de funciones y
      permiten asegurarnos de que las funciones son usadas de
      modo consistente en todas las unidades de traducción del
      proyecto. </para>

    <para>Obviamente, las funciones globales se pueden seguir
    declarando a mano en aquellos lugares en las que son
    definidas y usadas. (Sin embargo, esta práctica es tan
    tediosa que se ha vuelto en desuso.) De cualquier modo, las
    estructuras siempre deben ser declaradas antes de ser usadas
    y el mejor lugar para esto es un archivo de cabecera,
    exceptuando aquellas que queremos esconder intencionalmente
    en otro archivo. </para>

    <para>Se puede ver que todas las funciones miembros tienen
    casi la misma forma que sus versiones respectivas en C. Las
    únicas diferencias son su alcance [fixme: scope resolution] y
    el hecho de que el primer argumento ya no aparece explícito
    en el prototipo de la función. Por supuesto que sigue ahí ya
    que la función debe ser capaz de trabajar sobre una variable
    <literal role="keyword">struct</literal> en particular. Sin
    embargo, ¡notar también que, dentro de la función miembro, la
    selección de esta estructura en particular también ha
    desaparecido! Así, en lugar de decir <programlisting>s->size
    = sz;</programlisting> ahora decimos <programlisting>size =
    sz;</programlisting> eliminando el tedioso
    <literal>s-></literal> que en realidad no aportaba nada al
    significado semántico de lo que estamos
    escribiendo. Aparentemente, el compilador de C++ está
    realizando estas tareas por nosotros. De hecho, está tomando
    el primer argumento "secreto" (la dirección de la estructura
    que antes teníamos que pasar a mano) y aplicándole el
    selector de miembro (->) siempre que escribamos el nombre de
    uno de los datos miembro. Esto significa que, siempre y
    cuando estemos dentro de la definición de una función miembro
    de una estructura podemos hacer referencia a cualquier otro
    miembro (incluyendo otra función miembro) simplemente dando
    su nombre. El compilador buscará primero en los nombres
    locales de la estructura antes de buscar en versiones más
    globales de dichos nombres. El lector podrá descubrir que
    esta característica no sólo agiliza la escritura del código,
    sino que también hace la lectura del mismo mucho más
    tribial. </para>

    <para>Pero qué pasaría si, por alguna razón,
    <emphasis>deseáramos</emphasis> hacer referencia a la
    dirección de memoria de la estructura. En la versión en C de
    la librería esta se podía obtener fácilmente del primer
    argumento de cualquier función. En C++ la cosa e más
    consistente: existe la palabra reservada <literal
    role="keyword">this</literal> la cual produce la dirección de
    la variable <literal role="keyword">struct</literal>
      actual. Es el equivalente a la expresión
    '<varname>s</varname>' de la versión en C de la
    librería. Así, podremos volver al estilo de C
    escribiendo</para>

    <programlisting>this->size = Size;</programlisting>

    <para>El código generado por el compilador será exactamente
      el mismo por lo que no es necesario usar <literal
      role="keyword">this</literal> en este tipo de casos. A
      propósito, se podrá ver por ahí código en dónde la gente
      usa <literal role="keyword">this</literal> en todos lados
      sin agregar nada al significado del código (esta práctica
      nos da indicios de programadores inexperientes). Por lo
      general, <literal role="keyword">this</literal> no se usa
      muy a menudo pero, cuando se lo necesite siempre estará
      allí (en ejemplos posteriores del libro se verá más sobre
      su uso). </para>

    <para>Queda aún un último tema que tocar. En C, se puede
      asignar un <type>void *</type> a cualquier otro
      puntero. Por ejemplo al compilar

    <programlisting>
int i = 10;
void* vp = &amp;i; // OK tanto en C como en C++
int* ip = vp; // Sólo aceptable en C
    </programlisting>

      no habrá ningún tipo de quejas. Sin embargo, en C++, lo
      anterior no estará permitido. ¿Por qué? Porque C no es tan
      estricto con los tipos de información y nos deja asignar un
      puntero sin un tipo específico a un puntero de un tipo bien
      determinado. No así C++ en el cual la verificación de tipos
      es crítica y el compilador se detendrá quejándose en
      cualquier violación de tipos. Esto siempre ha sido
      importante, pero es especialmente importante en C++ ya que
      dentro de las estructuras podemos tener funciones
      miembros. Si en C++ estuviera permitido pasar punteros a
      estructuras sin ningún tipo de impunidad en cuanto a
      violaciones de tipos, ¡podríamos terminar llamando a
      una función miembro de una estructura en la cual no
      existiera lógicamente dicha función miembro! Una verdadera
      fórmula para el desastre. Así, mientras C++ sí nos deja
      asignar cualquier puntero a un <type>void *</type> (en
      realidad este es el propósito original del puntero a
      <type>void</type>: que sea suficientemente largo
      como para apuntar a cualquier tipo) no nos dejará asignar
      un <type>void *</type> a cualquier otro tipo de
      puntero. Para ello se requiere un moldeado para indicarle
      tanto al lector como al compilador que realmente queremos
      tratarlo como el puntero destino. 
      </para> 

    <para>Y esto nos lleva a discutir un asunto interesante. Uno
    de los objetivos importantes de C++ es poder compilar la
    mayor cantidad posible de código en C para así, permitir una
    fácil transición al nuevo lenguaje. Sin embargo, esto no
    significa, como hemos visto que cualquier segmento de código
    que sea válido en C, será automáticamente permitido en
    C++. Hay varias cosas que un compilador de C nos permite
    hacer que son potencialmente peligrosas y propensas a generar
    errores (se verán ejemplos de estas a lo largo de libro). El
    compilador de C++ genera errores y avisos en este tipo de
    situaciones y como veremos esto es más una ventaja que un
    obstáculo a pesar de su naturaleza restrictiva. ¡De hecho,
    existen muchas situaciones en las cuales tratamos de detectar
    sin éxito un error en C y cuando recompilamos el programa con
    un compilador de C++ este nos avisa exactamente la causa del
    problema!. En C, muy a menudo nos hallamos con que para que
    un programa funcione correctamente, además de compilarlo,
    luego deberemos <emphasis>hacer que ande</emphasis>. ¡En C++,
    por el contrario, veremos que muchas veces si un programa
    compila correctamente es probable de que ya funcione bien!
    Esto se debe a que este último lenguaje es mucho más estricto
    respecto a la comprobación de tipos de información. </para>

    <para>En el siguiente programa test se podrá apreciar
    nuevas cosas con respecto a cómo se utiliza la nueva versión
    de la <type>Stash</type>:</para>


<programlisting>
<xi:include parse="text" href="./code/C04/CppLibTest.cpp"/>
</programlisting>


    <para>Una de las cosas que el lector habrá podido observar en
      el código anterior es que las variables se definen
      <quote>al vuelo</quote>, o sea (como se introdujo en el
      capítulo anterior) en cualquier parte de un bloque y no
      necesariamente - como en C - al comienzo de los
      mismos. </para>

    <para>El código es bastante similar al visto en
    <filename>CLibTest.cpp</filename> con la diferencia de que,
    cuando se llama a una función miembro, se utiliza el operador
      de selección de miembro '<literal
    role="operator">.</literal>' precedido por el nombre de la
    variable. Esta es una síntaxis conveniente ya que imita a la
    selección o acceso de un dato miembro de una estructura. La
    única diferencia es que, al ser una función miembro, su
    llamada implica una lista de argumentos. </para>

    <para>Tal y cómo lo hemos dicho antes, la llamada que el
      compilador hace <emphasis>realmente</emphasis> es en
      realidad mucho más parecida a la llamada a la función de la
      librería en C. Consideremos la decoración de nombres y el
      pasaje del puntero <literal role="keyword">this</literal>:
      la llamada en C++ de
      <function>intStash.initialize(sizeof(int), 100)</function>
      se transformará en algo parecido a
      <function>Stash_initialize(&amp;intStash, sizeof(int),
      100)</function>. Si el lector se pregunta qué es lo que
      sucede realmente debajo del envoltorio, debería recordar
      que el compilador original de C++
      <application>cfront</application> de AT&amp;T producía
      código C como salida la que luego debía ser compilada con
      un compilador de C para generar el ejecutable. Este método
      permitía a <application>cfront</application> ser
      rápidamente portable a cualquier máquina que soportara un
      compilador estándar de C y ayudó a la rápida diseminación
      de C++. Así, dado que los compiladores antiguos de C++ tenían que
      generar código C, sabemos ahora que existe una manera de
      representar síntaxis C++ en C (algunos compiladores de hoy
      en día aún permiten generar código C).   </para>

    <para>Comparando con <filename>CLibTest.cpp</filename>
    observamos un cambio: la introducción del archivo de cabecera
    <filename>require.h</filename>. He creado este archivo de
    cabecera para realizar chequeo de errores más sofisticados
    que los que provee <function>assert()</function>. Contiene
    varias funciones incluyendo la llamada en este último
    ejemplo, <function>assure()</function> la cual es usada sobre
    archivos. Esta función verifica que un archivo se ha abierto
    exitosamente y en caso contrario reporta a la salida de
    errores estándar un aviso de error (por lo que también
    necesitará el nombre del archivo como segundo argumento) y
    sale del programa. Las funciones de
    <filename>require.h</filename> se usarán a lo largo de este
    libro especialmente para asegurarnos de que se ha ingresado
    la cantidad correcta de argumentos en la línea de comandos y
    para verificar que los archivos son abiertos
    correctamente. Las funciones de
    <filename>require.h</filename> reemplazan el código de
    detección de errores repetitivo y que muchas veces es causa
    de distracciones y más aún, proveen de mensajes útiles para
    la detección de estos posibles errores. Estas funciones serán
    totalmente explicadas más adelante en el libro. </para>

  </sect1>





  <sect1>

    <title>¿Qué es un objeto?</title>

    <para>Ahora que ya se ha visto y discutido un ejemplo incial
    es hora de retroceder para definir la terminología. El acto
    de meter funciones dentro de las estructuras es el eje
    central del cambio que C++ propone sobre C e introduce una
    nueva forma de ver las estructuras: como conceptos. En C, una
    estructura (<literal role="keyword">struct</literal>) es tan
    sólo una aglomeración de datos: una manera de empaquetar
    datos para que puedan ser tratados como un grupo. De esta
    forma, cuesta hacernos la idea de que representan algo más
    que sólo sólo una conveniencia de programación. Las funciones
    que operan sobre esas estructuras están sueltas por ahí. Sin
    embargo, cuando vemos las funciones dentro del mismo paquete
    que los datos la estructura se vuelve una nueva criatura,
    capáz de representar características (como las <literal
    role="keyword">struct</literal>s de C) <emphasis>y</emphasis>
    comportamientos. El concepto de un objeto, una entidad
    independiente y bien limitada que puede recordar
    <emphasis>y</emphasis> actuar, se sugiere a si mismo como
    definición. </para>

    <para>En C++ un objeto es simplemente una variable, y la
      definición más pura es <quote>una región de
      almacenamiento</quote> (esto último es una manera más
      específica de decir <quote>un objeto debe tener un único
      identificador</quote> el cual, en el caso de C++, es una
      única dirección de memoria). Es un lugar en el cual se
      puede almacenar datos y en el cual está implícita la
      existencia de operaciones sobre esos datos.  </para>

    <para>Desafortunadamente no existe una completa consistencia
    entre los distintos lenguajes cuando se habla de estos
    términos aunque son bastante bien aceptados. También se podrán
    encontrar discrepancias sobre lo que es un lenguaje orientado
    a objetos aunque parece estarse estableciendo un
    concenso sobre esto hoy en día también. Hay lenguajes que se
      denominan <emphasis>basados en objetos</emphasis> los
    cuales, cuentan con estructuras-con-funciones como las que
    hemos visto aquí de C++. Sin embargo, esto tan sólo es una
      parte de lo que denominamos lenguaje <emphasis>orientado a
    objetos</emphasis> y afirmamos que los lenguajes que
    solamente llegan a empaquetar las funciones dentro de las
    estructuras son lenguajes basados en objetos y no orientados
    a objetos. </para>

  </sect1>




  <sect1>

    <!-- Abstract data typing --> 
    <!-- "Tipado de datos abstracto" no me gustó-->
    <title>Definición de tipos abstractos de datos</title>

    <para>El ser capaces de empaquetar datos junto con funciones
    nos permite la creación de nuevos tipos de datos. Esto es
    muchas veces llamado <emphasis>encapsulación</emphasis>

      <footnote>
        <para>Este término puede causar debates. Algunas personas
          lo utilizan tal y como está definido aquí, aunque
          otras lo usan para describir el <emphasis>control de
          acceso</emphasis>, término que se discutirá en el
          siguiente capítulo. </para>
      </footnote>

      . Un tipo de dato ya existente puede contener varias piezas
      de datos juntas. Por ejemplo, un <type>float</type> tiene
      un exponente, una mantissa y un bit de signo. Le podemos
      pedir que haga varias cosas, entre ellas, sumarse a otro
      <type>float</type>, a un <type>int</type>, etc. Así,
      podemos decir que tiene características y
      comportamiento. </para>

    <para>La definición de un <type>Stash</type> crea un nuevo
      tipo de dato. Le podemos agregar nuevos elementos
      (<function>add()</function>), sacar
      (<function>fetch()</function>) y agrandarlo
      (<function>inflate()</function>). Creamos uno escribiendo
      <literal>Stash s;</literal> igual que cuando creamos un
      <type>float</type> diciendo <literal>float x;</literal>. Un
      <type>Stash</type> también tiene características y un
      comportamiento bien determinado. Aunque actúe igual que un
      tipo de dato predefinido como <type>float</type> diremos
      que un <type>Stash</type> es un <emphasis>tipo abstracto de
      dato</emphasis> talvez porque permite abstraer un concepto
      desde el espacio de los problemas al espacio
      solución. Además, el compilador de C++ lo tratará
      exactamente como a un nuevo tipo de dato y si, por ejemplo,
      declaramos una función para que espere un
      <type>Stash</type> como argumento, el compilador se
      asegurará de que no se le pase otra cosa a la función. Así,
      la comprobación de tipos se realiza al mismo nivel tanto
      para los tipos abstractos de datos (a veces también
      llamados <emphasis>tipos definidos por el
      usuario</emphasis>) como para los tipos
      predefinidos. </para>

    <para>Sin embargo, se notará inmediatamente una diferencia en
      cómo se realizan las operaciones sobre los objetos. Hacemos
      <literal>objeto.funciónMiembro(listaArgumentos)</literal> o
      sea, <quote>llamamos a una función miembro para el
      objeto</quote>. No obstante, en la jerga de los lenguajes
      orientados a objetos, nos referimos a lo anterior también
      como <quote>enviar un mensaje al objeto</quote>. Así, para
      una <varname>Stash s</varname>, en esta jerga la sentencia
      <literal>s.add(&amp;i)</literal> le <quote>envía un mensaje
      a <varname>s</varname></quote> diciéndole <quote>agrégate
      (<function>add()</function>) <varname>i</varname> a ti
      mismo</quote>. De hecho, la programación orientada a
      objetos puede ser resumida en la siguiente frase:
      <emphasis>enviar mensajes a objetos</emphasis>. Y es
      realmente todo lo que se hace: se crea un conjunto de
      objetos y se les envía mensajes. El truco, ovbiamente, es
      entender qué <emphasis>son</emphasis> en nuestro problema
      los objetos y los mensajes, pero una vez que se ha cumplido
      esa etapa, la implementación en C++ será sorprendentemente
      directa. </para>


  </sect1>





  <sect1>
    <title>Detalles del objeto</title>
    <para>
    </para>
  </sect1>





  <sect1>
    <title>Conveciones de los ficheros de cabecera</title>
    <para>
    </para>
    


    <sect2>
      <title>Importancia de los ficheros de cabecera</title>
      <para>
      </para>
    </sect2>



    <sect2>
      <title>El problema de la declaración múltiple</title>
      <para>
      </para>
    </sect2>



    <sect2>
      <title>
	Las directivas del preprocesador #define, #ifndef y #endif
      </title>
      <para>
      </para>
    </sect2>



    <sect2>
      <title>Un estándar para los ficheros de cabecera</title>
      <para>
      </para>
    </sect2>



    <sect2>
      <title>Espacios de nombres en las cabeceras</title>
      <para>
      </para>
    </sect2>



    <sect2>
      <title>Uso de las cabeceras en proyectos</title>
      <para>
      </para>
    </sect2>


  </sect1>





  <sect1>
    <title>Estructuras anidadas</title>
    <para>
    </para>



    <sect2>
      <title>Resolución del alcance global</title>
      <para>
      </para>
    </sect2>


  </sect1>






  <sect1>
    <title>Resumen</title>
    <para>
    </para>
  </sect1>






  <sect1>
    <title>Ejercicios</title>
    <para>
    </para>
  </sect1>
</chapter>





<!-- Local Variables: -->
<!-- sgml-parent-document:"PensarEnC++.sgml" -->
<!-- End: -->

