<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Sebastián Gurin <sgurin@motevideo.com.uy>
                       David Villa <dvilla@gmx.net>
  Formateado DocBook:  Sebastián Gurin <sgurin@motevideo.com.uy>
                       David Villa <dvilla@gmx.net>
  1ª Revisión:
  2ª Revisión
-->

<!--

Traductor: Sebastián Gurin <cancerbero_sgx@users.sourceforge.net>

cosas por hacer:

(1) en los <programlisting> que comienzan con //:
    CXX:archivo-duente.cpp hay que hacer un Xinclude. 

(2) etiquetado de palabras reservadas:
    palabras reservadas -> <literal role="keyword"> </literal>
    operadores -> <literal role="operator"> </literal>

(3) [traducir] - significa traducir el término anterior al español. 

  glosario de este capítulo: en el fichero TRADUCCION
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">


<chapter 
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C4">

  <title>Abstracción de Datos</title>
    
  <para>
    C++ es una herramienta de producción que ha sido mejorada con
    respecto a sus tecnologías predecesoras. ¿Por qué otro motivo usted
    debería hacer el esfuerzo de cambiarse a C++ (y es un esfuerzo, sin
    importar cuán fácilmente intentemos hacer esta transición), desde un
    lenguaje que le es bien conocido y con el cual ya es productivo? Sin
    lugar a dudas, una transición de este tipo hará que, mientras
    aprende el nuevo lenguaje, su nivel de productividad sea malo. ¿Por
    qué entonces hacerlo?  Déjeme responderle: es porque está convencido
    de que usando a esta nueva herramienta le podrá sacar mucho más
    provecho. 
  </para>

  <para>
    En términos de programación, productividad significa que menos
    personas, en menos tiempo, puedan realizar programas más complejos y
    significativos. Desde luego, hay otras cuestiones que deben
    importarnos a la hora de escojer un lenguaje de
    programación. Aspectos a tener en cuenta son la eficiencia (¿la
    naturaleza del lenguaje hace que nuestros programas se enlentezcan o
    que sean demesiado grandes?), la seguridad (¿nos ayuda el lenguaje a
    asegurarnos de que nuestros programas hagan siempre lo que queremos?
    ¿maneja el lenguaje los errores apropiadamente?)  y el mantenimiento
    (¿de qué manera nos ayuda el lenguaje a realizar código que sea
    fácil de entender, modificar y extender?). Estos son, con certeza,
    factores importantes que serán examinados en este libro. 
  </para>

  <para>
    Hablando más toscamente, productividad significa que un programa que
    antiguamente les costaba a tres de ustedes una semana de trabajo en
    ser escrito, ahora le tome a tan sólo uno de ustede un día o
    dos. Esto toca varios niveles de la esfera económica. Usted se pone
    contento al ver que es capaz de construir algo en menos tiempo, sus
    clientes (o jefe) se sienten felices porque los productos les llegan
    más rápido y utilizando menos mano de obra y finalmente los
    compradores se sientes contentos porque pueden obtener productos más
    baratos. La única manera de obtener incrementos masivos en
    productividad es apoyándose en el código de otras personas; o sea,
    usando librerías.  
  </para>

  <para>
    Una librería es simplemente un montón de código que alguien ha
    escrito y empaquetado todo junto. Muchas veces, el paquete mínimo es
    tan sólo un archivo con una extensión especial como
    <filename>lib</filename> y uno o más archivos de cabecera que le
    dicen al compilador qué hay en la librería. El enlazador sabrá cómo
    buscar el archivo de la librería y extraer el código compilado
    correcto. Sin embargo, esta es sólo una forma de entregar una
    librería. En plataformas que abarcan muchas arquitecturas, como
    Linux/Unix, el único modo sensato de entregar una libraría es con
    código fuente para que así pueda ser reconfigurado y reconstruido en
    el nuevo objetivo. 
  </para>

  <para>
    De esta forma, las librerías probablemente sean las formas más
    importantes de progresar en términos de productividad y uno de los
    principales objetivos del diseño de C++ es hacer más fácil el uso de
    librerías. Esto implica entonces, que hay algo difícil en usar
    librerías en C. Si se entiende este factor, uno puede empezar a
    comprender el diseño de C++, y por lo tanto, cómo usarlo.
  </para>

  <sect1>
    <title>Una librería pequeña al estilo de C</title>

    <para>
      Aunque muchas veces, una librería comienza como una colección de
      funciones, si se ha usado alguna librería C relativamente seria se
      habrá observado que la cosa no termina ahí. Del mismo modo que
      "vida" es mucho más que comportamiento, acciones y
      transformaciones, en una biblioteca, además de funciones tenemos
      características (color, peso, textura, luminiscencia) las cuales
      son representados por datos. En C, cuando debemos representar
      características, es muy conveniente agruparlas todas juntas en una
      <emphasis>estructura</emphasis>, especialmente cuando queremos
      representar más de un tipo de cosa en nuestro problema. Así, se
      puede trabajar con una variable de estas
      <emphasis>estructuras</emphasis> para representar cada
      cosa.
    </para>
    
    <para>
      Así, la mayoría de las librerías en C constan de un conjunto de
      estructuras y un conjunto de funciones las cuales actúan sobre las
      primeras. Como un ejemplo sobre esta técnica, considérese la
      siguiente herramienta para programar la cual se comporta como un
      array, pero cuyo tamaño puede ser fijado en tiempo de ejecución,
      cuando se crea. La llamaremos <varname>CStash</varname>
      <footnote>
	<para>
	  <quote>Stash</quote> se podría traducir al inglés como
          <quote>Acumulador</quote>. Nota del T. </para>
      </footnote>. Aunque la siguiente síntaxis es de C++, tiene
      el estilo clásico de una librería escrita en C:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C04/CLib.h"/>
</programlisting>

    <para>
      Una etiqueta como <varname>CStashTag</varname> casi siempre se usa
      en aquellas estructuras que necesitan ser referenciadas dentro de
      ellas mismas. Tal es el caso de una <emphasis>lista
      enlazada</emphasis> en la cual se necesita un puntero a la
      siguiente variable de estructura, o sea, una manera de identificar
      el tipo de ese puntero dentro de la misma estructura. También es
      muy común ver en la declaración de las estructuras de una librería
      escrita en C el uso de <literal>typedef</literal> análogo al del
      ejemplo. Esto permite al programador tratar las estructuras como
      un nuevo tipo de dato y así definir nuevas variables (de esa
      estructura) del siguiente modo:
    </para>

<programlisting>
CStash A, B, C;
</programlisting>

    <para>
      El puntero <varname>storage</varname> es un <type>unsigned
      char*</type>. Un <type>unsigned char</type> es la menor pieza de
      datos que un compilador C soporta aunque, en algunas máquinas
      puede ser de igual tamaño que la mayor. Aunque esto es dependiente
      de la implementación, por lo general un <type>unsigned char</type>
      es de un byte de tamaño. Dado que el <type>CStash</type> está
      diseñado para almacenar cualquier tipo de estructura el lector se
      puede preguntar si un puntero <type>void *</type> no sería más
      apropiado. Sin embargo, la idea no es tratar este puntero de
      almacenamiento como un bloque de datos de tipo desconocido, sino
      como un bloque de bytes contiguos.
    </para>

    <para>
      El archivo de código fuente para la implementación luce del
      siguiente modo (tener en cuenta que si la librería fuera
      comercial, es probable que no tengamos acceso al código fuente y
      sólo dispongamos de un archivo ya compilado
      <filename>obj</filename>, <filename>lib</filename> o
      <filename>dll</filename>, etc):
    </para>

<programlisting>
<xi:include parse="text" href="./code/C04/CLib.cpp"/>
</programlisting>

    <para>
      <function>initialize()</function> realiza las disposiciones
      iniciales necesarias para la <type>struct CStash</type>, poniendo
      los valores apropiados en las variables internas. Inicialmente, el
      puntero <varname>storage</varname> es puesto a cero dado que aún
      no se ha almacenado nada.
    </para>

    <para>
      La función <function>add()</function> inserta un elemento en el
      siguiente lugar disponible de la <type>CStash</type>. Para esto,
      primero verifica que halla suficiente espacio disponible. Si no lo
      hay, expande el almacenaje (storage) usando la función
      <function>inflate()</function> que será descripta en breve.
    </para>

    <!--
    Because the comqpiler doesn?t know the specific type of the
    variable being stored (all the function gets is a void*), you can?t
    just do an assignment, which would certainly be the convenient
    thing. Instead, you must copy the variable byte-by-byte. The most
    straightforward way to perform the copying is with array
    indexing. Typically, there are already data bytes in storage, and
    this is indicated by the value of next. To start with the right byte
    offset, next is multiplied by the size of each element (in bytes) to
    produce startBytes. Then the argument element is cast to an unsigned
    char* so that it can be addressed byte-by-byte and copied into the
    available storage space. next is incremented so that it indicates
    the next available piece of storage, and the ?index number? where
    the value was stored so that value can be retrieved using this index
    number with fetch( ).
    -->
    
    <para>
      Dado que en tiempo de ejecución el compilador es incapaz de
      reconocer el tipo de variable que va a ser almacenado (la función
      tan sólo acepta un <type>void *</type>), no puede hacerse una
      simple asignación, que sería lo más conveniente. En lugar de esto,
      la variable es copiada byte a byte. La manera más directa de hacer
      esto es utilizando el indexado de arrays. En un momento dado, el
      caso más probable es que en <varname>storage</varname> ya hallan
      bytes almacenados, lo cual es indicado por
      <varname>next</varname>. Para obtener la posición de inserción
      correcta en el array, se multiplica <varname>next</varname> por el
      tamaño de cada elemento (en bytes) lo cual queda determinado en
      <varname>startBytes</varname>. Luego el argumento
      <varname>element</varname> se moldea a <type>unsigned char*</type>
      para que pueda ser referenciado y copiado byte a byte en el
      espacio disponible de <varname>storage</varname>. Se incrementa
      <varname>next</varname> de modo que indique el siguiente lugar de
      almacenamiento disponible y sae devuelve el número de índice del
      elemento insertado para que pueda ser recuperado con
      <function>fetch()</function>.  
    </para>


    <!--
    fetch( ) checks to see that the index isn?t out of bounds and then
    returns the address of the desired variable, calculated using the
    index argument. Since index indicates the number of elements to
    offset into the CStash, it must be multiplied by the number of bytes
    occupied by each piece to produce the numerical offset in
    bytes. When this offset is used to index into storage using array
    indexing, you don?t get the address, but instead the byte at the
    address. To produce the address, you must use the address-of
    operator &.
    -->

    <para>
      <function>fetch()</function> verifica que el índice tenga un valor
      correcto y devuelve la dirección de la variable deseada, la cual
      se calcula en función del argumento <varname>index</varname>. Dado
      que <varname>index</varname> es el número de elementos a
      desplazarnos desde el principio [fixme: "the number of elements to
      offset into the CStash"] en la CStash, éste debe ser multiplicado
      por el tamaño en bytes que ocupa un elemento para obtener dicho
      desplazamiento pero en bytes. Cuando utilizamos este
      desplazamiento como índice del array <varname>storage</varname> lo
      que obtenemos no es la dirección, sino el byte almacenado en
      esta. Lo que hacemos entonces es utilizar el operador de dirección
      de memoria <literal role="operator">&amp;</literal>.
    </para>
   
    <!--count( ) may look a bit strange at first to a seasoned C
    programmer. It seems like a lot of trouble to go through to do
    something that would probably be a lot easier to do by hand. If you
    have a struct CStash called intStash, for example, it would seem
    much more straightforward to find out how many elements it has by
    saying intStash.next instead of making a function call (which has
    overhead), such as count(&intStash). However, if you wanted to
    change the internal representation of CStash and thus the way the
    count was calculated, the function call interface allows the
    necessary flexibility. But alas, most programmers won?t bother to
    find out about your ?better? design for the library. They?ll look at
    the struct and grab the next value directly, and possibly even
    change next without your permission. If only there were some way for
    the library designer to have better control over things like this!
    (Yes, that?s foreshadowing.)-->

    <para>
      <function>count()</function> puede parecer un poco extraña a los
      programadores experimentados en C. Podría parecer demasiada
      complicación para una tarea que probablemente sea mucho más fácil
      de hacer a mano. Por ejemplo, si tenemos una <type>CStash</type>
      llamada <varname>intStash</varname>, es mucho más directo
      preguntar por la cantidad de elementos utilizando
      <varname>intStash.next</varname>, que llamando a la función (lo
      cual agrega un costo de velocidad adicional)
      <function>count(&amp;intStash)</function>. Sin embargo, la
      cantidad de elementos se calcula en función tanto del puntero
      <varname>next</varname> como del tamaño en bytes de cada elemento
      de la CStash; así la interfaz de la función
      <function>count()</function> nos permite la flexibilidad necesaria
      para no tener que preocuparnos por estas cosas. Pero, ¡hay!, la
      mayoría de los programadores no se preocuparán por descubrir lo
      que para nosotros es el <quote>mejor</quote> diseño para la
      librería. Probablemente lo que harán es mirar dentro de la
      estructura y obtener el valor de <varname>next</varname>
      directamente. Peor aún, podrían hasta cambiar el valor de
      <varname>next</varname> sin nuestro permiso. ¡Si sólo hubiera
      alguna manera para el diseñador de la librería de tener un mejor
      control sobre este tipo de cosas! (Si, estamos anunciando el
      comienzo de temas que vendrán...[fixme: ver abajo en inglés:
      foreshadowing]). 
    </para>

    <sect2>
      <title>Almacenamiento dinámico</title>

      <!-- [FIXME: yo le hubiera llamado <title>Asignación de
      memoria dinámica</title>]-->


      <!-- You never know the maximum amount of storage you might need
      for a CStash, so the memory pointed to by storage is allocated
      from the heap. The heap is a big block of memory used for
      allocating smaller pieces at runtime. You use the heap when you
      don?t know the size of the memory you?ll need while you?re writing
      a program. That is, only at runtime will you find out that you
      need space to hold 200 Airplane variables instead of 20. In
      Standard C, dynamic-memory allocation functions include malloc( ),
      calloc( ), realloc( ), and free( ). Instead of library calls,
      however, C++ has a more sophisticated (albeit simpler to use)
      approach to dynamic memory that is integrated into the language
      via the keywords new and delete.  -->


      <para>
	Dado que nunca conoceremos la cantidad máxima de almacenamiento
	que necesitaremos para una <type>CStash</type>, la memoria a la
	que apuntan los elementos de <varname>storage</varname> es
	asignada desde el <emphasis>heap</emphasis>
	<footnote>
	  <para><emphasis>heap</emphasis> puede traducirse al español
	    como "montón" o "montículo". </para>
	</footnote>.  El heap es un gran montón de memoria usado para
	asignar pequeñas piezas en tiempo de ejecución. Usamos el heap
	cuando no sabemos de antemano la cantidad de memoria que
	necesitará el programa que estamos escribiendo. Por ejemplo,
	esto se da en un programa en el que sólo en tiempo de ejecución
	sabremos si necesitamos memoria para 200 variables
	<type>Avion</type> o para 20. En C stándar, las funciones para
	asignación de memoria dinámica incluyen a
	<function>malloc()</function>, <function>calloc()</function>,
	<function>realloc()</function> y <function>free()</function>. En
	lugar de llamadas a librerías, C++ cuenta con una técnica más
	sofisticada (y por lo tanto más fácil de usar) para tratar con
	memoria dinámica. Esta técnica está integrada en el lenguaje por
	medio de las palabras reservadas <literal
	role="keyword">new</literal> y <literal
	role="keyword">delete</literal>.
      </para>

      <!--The inflate( ) function uses new to get a bigger chunk of
      space for the CStash. In this situation, we will only expand
      memory and not shrink it, and the assert( ) will guarantee that a
      negative number is not passed to inflate( ) as the increase
      value. The new number of elements that can be held (after inflate(
      ) completes) is calculated as newQuantity, and this is multiplied
      by the number of bytes per element to produce newBytes, which will
      be the number of bytes in the allocation. So that we know how many
      bytes to copy over from the old location, oldBytes is calculated
      using the old quantity.-->

      <para>
	La función <function>inflate()</function> usa <literal
	role="keyword">new</literal> para obtener más memoria para la
	<type>CStash</type>. En este caso sólo expandiremos el espaciode
	memoria y nunca lo achicaremos. <function>assert()</function>
	garantizará que no se pase un número negativo como argumento a
	<function>inflate()</function> como valor de incremento. La
	nueva cantidad de elmentos que se podrán almacenar (una vez se
	halla completado <function>inflate()</function> se determina en
	la variable <varname>newQuantity</varname> la cual es
	multiplicada por el número de bytes que ocupa cada elemento para
	obtener el nuevo número de bytes totales de la asignación en la
	variable <varname>newBytes</varname>. Dado que conocemos cuántos
	bytes copiar desde la ubicación anterios,
	<varname>oldBytes</varname> es calculado usando la cantidad
	vieja de bytes (<varname>quantity</varname>). 
      </para>

      <para>
	La asignación de memoria ocurre en la
	<emphasis>expresión-new</emphasis> la cual involucra la palabra
	clave <literal role="keyword">new</literal>:
      </para>

<para><programlisting>
new unsigned char[newBytes];
</programlisting></para>

      <para>
	La forma general de una <emphasis>expresión-new</emphasis>
	es
      </para>

<programlisting>new Type;</programlisting>

      <para>
	donde <literal>Type</literal> describe el tipo de variable para
	la cual deseamos asignar memoria en el
	<emphasis>heap</emphasis>. Dado que en este caso, deseamos
	asignar memoria para un array de <type>unsigned char</type> de
	<varname>newBytes</varname> elementos, eso es lo que ponemos
	como <literal>Type</literal>. De igual forma podemos asignar
	memoria para algo más simple como un <type>int</type> con la
	expresión
      </para>

<programlisting>new int;</programlisting>

      <para>
	y aunque esto no sea muy útil muestra que la forma
	de la <emphasis>expresión-new</emphasis> es
	consistente. 
      </para>

      <para>
	Una <emphasis>expresión-new</emphasis> devuelve un puntero a un
	objeto de tipo (Type) igual al especificado por nosotros. Así,
	si pedimos <literal>new Type</literal> obtendremos un puntero a
	un objeto de tipo <literal>Type</literal>, si decimos
	<literal>new int</literal> obtendremos un puntero a un
	entero. Si queremos un nuevo array de <type>unsigned char</type>
	(a <literal>new unsigned char </literal>array, en inglés) la
	expresión nos devolverá un puntero al primer elemento de dicho
	array. El compilador verificará que se asigne lo que devuelve
	una <emphasis>expresión-new</emphasis> a una variable puntero de
	tipo correcto.
      </para>

      <para>
	Por supuesto, es posible que al pedir memoria, la petición
	falle, por ejemplo, si no hay más memoria libre en el
	sistema. Como se aprenderá más adelante, C++ cuenta con
	mecanismos que entran en juego cuando la operación de asignación
	de memoria no fue exitosa.
      </para>

      <para>
	Sigamos con nuestro código. Una vez que hemos asignado memoria
	para el nuevo espacio de almacenamiento (variable
	<varname>storage</varname>), los datos que están en el viejo
	espacio de almacenamiento deben ser copiados al nuevo. Esto se
	hace, nuevamente, en un bucle, utilizando la notación de
	índexado de arrays, copiando un byte en cada iteración del
	bucle. Una vez finalizada esta copia, ya no necesitaremos los
	datos que están en el espacio de almacenamiento viejo por lo que
	pueden ser liberados de la memoria para que otras partes del
	programa puedan usar este espacio cuando lo necesiten. La
	palabra reservada <literal role="keyword">delete</literal> es el
	complemento de <literal role="keyword">new</literal> y debe ser
	utilizada sobre todas aquellas variables a las cuales se les
	halla asignado memoria con <literal
	role="keyword">new</literal>. (Si nos olvidamos de utilizar
	<literal role="keyword">delete</literal> la memoria del heap
	asignada con <literal role="keyword">new</literal> permanecerá
	no disponible. Si estas fugas de memoria (<emphasis>memory
	leak</emphasis>) son muchas podremos quedarnos sin memoria
	disponible para asignar.) La síntaxis de <literal
	role="keyword">delete</literal> es consistente con la de
	<literal role="keyword">new</literal> salvo para el caso de los
	arrays: cuando queremos liberar un array, debemos informarle al
	compilador que el puntero no apunta a un simple objeto sino a un
	array de objetos. Para esto se inserta un par de paréntesis
	rectos como prefijo del puntero que va a ser liberado:
      </para>

      <programlisting>delete []myArray;</programlisting>

      <para>
	Luego de liberar el viejo espacio de almacenamiento se asigna el
        nuevo (en el cual ya hicimos la copia del viejo) al puntero
        <varname>storage</varname> y se actualiza
        <varname>quantity</varname>. Así termina la función
        <function>inflate()</function>.
      </para>

<!-- FIXME: en el siguiente párrafo traduje "heap compaction" -->
<!-- como "defragmentación del heap" y "heap compactor" como -->
<!-- "defragmentador del heap". -->

      <para>
	A este punto es bueno notar que el administrador de memoria del
	heap es una primitiva del lenguaje. Nos provee de trozos
	[FIXME:chunks] de memoria cuando se lo pedimos con <literal
	role="keyword">new</literal> y nos los quita cuando invocamos a
	<literal role="keyword">delete</literal>. Si un programa asigna
	y libera memoria muchas veces, terminaremos con un heap
	<emphasis>fragmentado</emphasis>, es decir un heap en el que si
	bien puede haber memoria libre para ser utilizada, los trozos de
	memoria están divididos de modo tal que no exista un trozo lo
	que sea lo grande que necesitamos en un momento
	dado. Lamentablemente no existe una capacidad inherente del
	lenguaje para efectuar <emphasis>defragmentaciones del
	heap</emphasis>. Un defragmentador del heap complica las cosas
	dado que tiene que mover pedazos de memoria, y por lo tanto,
	hacer que los punteros dejen de apuntar a valores
	válidos. Algunos entornos operativos vienen con este tipo de
	facilidades pero obligan al programador a utilizar manipuladores
	[FIXME:handles] de memoria especiales en lugar de punteros
	(estos manipuladores pueden ser convertidos temporalmente en
	punteros luego de bloquear la memoria para que el defragmentador
	del heap no la modifique). También podemos construir por
	nosotros mismos uno de estos artilugios, aunque no es una tarea
	liviana.
      </para>

      <para>
	Cuando creamos una variable en el stack en tiempo de compilación
	el mismo compilador es quien se encarga de crearla y liberar la
	memoria ocupada por ella automáticamente. Conoce exactamente el
	tamaño y la duración de este tipo de variables dada por las
	reglas de scoping [traducir]. Sin embargo, en el caso de las
	variables almacenadas dinámicamente, el compilador no poseerá
	información ni del tamaño requerido por las mismas, ni de su
	duración. Esto significa que el compilador no puede encargarse
	de liberar automáticamente la memoria ocupada por este tipo de
	variables y de aquí que el responsable de esta tarea sea el
	programador (o sea usted). Para esto se debe utilizar <literal
	role="keyword">delete</literal> lo cual le indica al
	administrador del heap que ese espacio de memoria puede ser
	utilizado por la próxima llamada a <literal
	role="keyword">new</literal>. En nuestra librería de ejemplo, el
	lugar lógico para esta tarea es la función
	<function>cleanup()</function> dado que allí es dónde se deben
	realizar todas las labores de finalización de uso del
	objeto. 
      </para>

      <para>
	Para testear la librería creamos dos Cstash, una que almacene
        enteros y otra para cadenas de 80 caracteres:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C04/CLibTest.cpp"/>
</programlisting>


      <para>
	Dado que debemos respetar la sintaxis de C, todas las variables
        se deben declarar al comienzo de
        <function>main()</function>. Obviamente, no nos podemos olvidar
        de inicializar todas las variables <type>Cstash</type> más
        adelante en el bloque main(), pero antes de usarlas llamando a
        <function>initialize()</function>. Uno de los problemas con las
        librerías en C es que uno debe asegurarse de convencer al
        usuario de la importancia de las funciones de inicialización y
        destrucción.  Habrá muchos problemas si estas funciones se
        omiten!  Lamentablemente el usuario no siempre se preguntará si
        la inicialización y el limpiado de los objetos son
        obligatorios. Ellos le darán importancia a lo que
        <emphasis>ellos</emphasis> quieren hacer y no nos darán tanta
        importancia a nosotros (el programador de la librería) cuando
        les digamos <quote>¡Hey! ¡espera un poco! ¡Debes hacer
        <emphasis>esto</emphasis> primero!</quote>. Otro problema que
        puede presentarse es el hecho de que algunos usuarios quieran
        inicializar los elementos (datos internos) de una estructura por
        si mismos. En C no hay un mecanismo para prevenir este tipo de
        conductas (más presagios de los temás que vendrán...).
      </para>

      <para>La <varname>intStash</varname> se va llenando con enteros
        mientras que el <varname>stringStash</varname> se va llenando
        con arrays de caracteres. Estos arrays de caracteres son
        producidos leyendo el archivo fuente
        <filename>CLibTest.cpp</filename> y almacenando las
        líneas de este archivo en el <type>string</type>
        <varname>line</varname>. Obtenemos la representación "puntero a
        caracter" de <varname>line</varname> con la función miembro
        <function>c_str()</function>. </para>

      <para>
	Luego de cargadas las <type>Stash</type> ambas se muestran en
	pantalla. La <varname>intStash</varname> se imprime usando un
	bucle <literal role="keyword">for</literal> en el cual se usa
	<function>count()</function> para determinar la cantidad de
	elementos. La <varname>stringStash</varname> se muestra
	utilizando un bucle <literal role="keyword">while</literal>
	dentro del cual se va llamando a
	<function>fetch()</function>. Cuando esta función devuelve cero
	se rompe el bucle ya que esto significará que hemos sobrepasado
	los límites de la estructura. 
      </para>

      <para>
	El lector también pudo haber visto un moldeado[fixme: cast]
	adicional en la línea:</para>

<programlisting>
cp = (char*)fetch(&amp;stringStash,i++)
</programlisting>

      <para>
	Esto se debe a la comprobación estricta de tipos en C++ lo cual
	no nos permite asignar un <type>void *</type> a una variable de
	cualquier tipo, mientras que C sí nos permite esto.
      </para>
    </sect2>
    

    <sect2>
      <title>Malas suposiciones</title>

      <para>
	Antes de meternos en los problemas principales de crear una
	librería en C, discutiremos un último asunto que nos parece
	importante tener claro. El archivo de cabecera
	<filename>CLib.h</filename> <emphasis>debe</emphasis> ser
	incluído en cada archivo fuente que haga referencia al tipo
	<type>CStash</type> ya que el compilador nisiquiera tiene formas
	de adivinar[FIXME:poner sinónimo] qué forma tiene la
	estructura. Sin embargo, <emphasis>sí</emphasis> puede adivinar
	la forma de una función. Aunque esto pueda parecernos una
	característica positiva, veremos porqué, en realidad, es un
	fallo mayor de C.
      </para>

      <para>
	Aunque siempre deberíamos declarar las funciones incluyendo un
	archivo de cabecera, en C las declaraciones de funciones no son
	esenciales. En este lenguaje (pero no en C++), es posible llamar
	a una función que no ha sido declarada. Un buen compilador
	seguramente nos avisará de que deberíamos declarar una función
	antes de usarla, pero nos permitirá seguir dado que no es
	obligatorio hacerlo en C estándar. Esta es una práctica
	peligrosa ya que el compilador puede asumir que una función que
	ha sido llamada con un <type>int</type> como argumento, tenga un
	<type>int</type> como argumento mientras que, en realidad,
	contiene un <type>float</type>. Como veremos, esto puede
	producir errores en los programas que pueden ser muy difíciles
	de depurar.
      </para>

      <para>
	Se dice que cada archivo de implementación C (los archivos de
	extensión <filename>.c</filename>) es una unidad de traducción
	[fixme:translation unit]. El compilador se ejecuta
	independientemente sobre cada unidad de traducción ocupándose,
	en ese momento, solamente en ese archivo. Así, la información
	que le demos al compilador por medio de los archivos de cabecera
	es muy importante dado que determina cómo ese archivo se
	relaciona con las demás partes del programa. Luego, las
	declaraciones en los archivos de cabecera son particularmente
	importantes dado que, en cada lugar que se incluyen, el
	compilador sabrá exactamente qué hacer. Por ejemplo, si en un
	archivo de cabecera tenemos la declaración <function>void
	func(float) </function>,si llamamos a
	<function>func()</function> con un <type>int</type> como
	argumento, el compilador sabrá que deberá convertir el
	<type>int</type> a <type>float</type> antes de pasarle el valor
	a la función (a esto se le llama
	<emphasis>promoción</emphasis>). Sin la declaración, el
	compilador asumirá que la declaración función tiene la forma
	<function>func(int)</function>, no se realizará la promoción y
	se pasarán, por lo tanto, datos incorrectos a la
	función.
      </para>

      <para>
	Para cada unidad de traducción el compilador crea un archivo
	objeto, de extensión <filename>.o</filename>,
	<filename>.obj</filename> o algo por el estilo. Estos archivos
	objeto, junto con algo de código de arranque son unidos por el
	enlazador[fixme:linker] para crear el programa
	ejecutable. Durante el enlazado[FIXME:linking], todas las
	referencias externas deven ser resueltas. Por ejemplo, en
	archivos como <filename>CLibTest.cpp</filename>, funciones como
	<function>initialize()</function> y <function>fetch()</function>
	son declaradas (o sea, se le informa al compilador qué forma
	tienen estas funciones) y usadas, pero no son definidas. Están
	definidas en otro lugar, en este caso en el archivo
	<filename>CLib.cpp</filename>. Así, las llamadas que se hacen en
	<filename>CLibTest.cpp</filename> a estas funciones son
	referencias externas. Cuando se unen los archivos objeto para
	formar el programa ejecutable, el enlazador debe, para cada
	referencia externa no resuelta, encontrar la dirección a la que
	hace referencia y reemplazar cada referencia externa con su
	correspondiente dirección.
      </para>

      <para>
	Es importante destacar que en C, estas referencias externas que
	el enlazador busca son simples nombres de funciones,
	generalmente precedidas por un guión bajo. De esta forma, todo
	lo que el enlazador debe efectuar es, hacer corresponder el
	nombre de la función que se llama, con el cuerpo (definición,
	código) de la función del archivo objeto, en el lugar exacto de
	la llamada a dicha función. Si, por ejemplo, accidentalmente
	hacemos una llamada a una función que el compilador interprete
	como <function>func(int)</function> y existe una definición de
	función para <function>func(float)</function> en algún archivo
	objeto, el enlazador verá <function>_func</function> en un lugar
	y <function>_func</function> en otro, por lo que
	<emphasis>pensará</emphasis> que todo está bien. En la llamada a
	<function>func()</function> se meterá[fixme:push] un
	<type>int</type> en el stack pero el cuerpo de la función
	<function>func()</function> esperará que un <type>float</type>
	esté en el stack. Si la función sólo lee el valor de este dato y
	no lo escribe, el stack no reventará. De hecho, el supuesto
	<type>float</type> leído del stack puede terner algo de sentido:
	la función seguirá corriendo aunque sobre basura, y es por esto
	que las fallas originadas por esta clase de errores son muy
	difíciles de encontrar.
      </para>
    </sect2>
  </sect1>



  <sect1>
    <title>¿Qué está mal?</title>
    
    <para>
      Somos seres realmente destinados a la adaptación: nos adaptamos a
      situaciones en las que, quizá, <emphasis>no
      deberíamos</emphasis>. El estilo de la librería
      <type>CStash</type> ha sido un modelo a seguir por los
      programadores en C durante mucho tiempo. Sin embargo, si nos
      ponemos a examinarla por un momento, nos daremos cuenta de que
      utilizar esta librería puede resultar incómoda. Cuando la usamos
      debemos, por ejemplo, pasar la dirección de la estructura a cada
      función de la librería. Así, cuando leemos el código, los
      mecanismos de la librería se mezclan con el significado de las
      llamadas a las funciones, lo cual dificulta la comprecsión del
      programa.
    </para>

    <para>
      Sin embargo, uno de los mayores obstáculos de trabajar con
      librerías en C es el problema llamado <emphasis>conflicto de
      nombres</emphasis>[FIXME:name clashes]. C trabaja con un único
      espacio de nombres de funciones. Esto significa que, cuando el
      enlazador busca por el nombre de una función, lo hace en una única
      lista de nombres maestra. Más aún, cuando el compilador trabaja
      sobre una unidad de traducción, un nombre de función sólo puede
      hacer referencia a una única función con ese nombre.
    </para>

    <para>
      Supongamos que compramos dos librerías de diferentes proveedores y
      que cada librería consta de una estructura que debe ser
      inicializada y destruida. Supongamos que cada proveedor ha
      decidido nombrar a dichas operaciones
      <function>initialize()</function> y
      <function>cleanup()</function>. ¿Cómo se comportaría el compilador
      si incluyéramos los archivos de cabecera de ambas librerías en la
      misma unidad de traducción? Afortunadamente, el compilador C dará
      un mensaje de error diciéndonos que hay una incoherencia de tipos
      en las listas de argumentos de ambas declaraciones. No obstante,
      aunque no incluyamos los archivos de cabecera en la unidad de
      traducción igual tendremos problemas con el enlazador. Un buen
      enlazador detectará y avisará cuando se produzca uno de estos
      conflictos de nombres. Sin embargo, hay otros que simplemente
      tomarán el primer nombre de la función que se les aparezca,
      buscando en los archivos objetos en el orden en el que fueron
      pasados en la lista de enlazamiento. (Este comportamiento puede
      ser considerado como una ventaja ya que nos permite reemplazar las
      funciones de las librerías ajenas con nuestras propias funciones.)
    </para>
    
    <para>
      En cualquiera de los dos casos, llegamos a la conclusión de que en
      C es imposible usar dos bibliotecas en las cuales existan
      funciones con nombres idénticos. Para solucionar este problema,
      los proveedores de librerías en C ponen un prefijo único a todas
      las funciones de la librería. En nuestro ejemplo, a las funciones
      <function>initialize()</function> y <function>cleanup()</function>
      podríamos renombrarlas como
      <function>CStash_initialize()</function> y
      <function>CStash_cleanup()</function>. Esta es una técnica lógica:
      decoramos los nombres de las funciones con el nombre de la
      estructura sobre la cual éstas trabajan.
    </para>

    <para>
      Este es el momento de dirigir nuestros pasos a las primeras
      nociones de construcción de clases en C++. Como el lector ha de
      saber, las variables declaradas dentro de una estructura no tienen
      conflictos de nombres con las variables globales. ¿Por qué,
      entonces, no aprovechar esta característica de las variables para
      evitar los conflictos de nombres de funciones declarándolas dentro
      de la estructura sobre la cual operan? O sea, ¿por qué no hacer
      que las funciones sean también miembros de las estructuras?
    </para>
  </sect1>


  <sect1>
    <title>El objeto básico</title>

    <para>
      Nuestro primer paso será exactamente lo mencionado anteriormente:
      Meter las funciones C++ dentro de las estructuras como
      <quote>funciones miembro</quote>. Así se verá nuestra estructura
      luego de realizados estos cambios de la versión C de la
      <type>CStash</type> a la versión en C++ a la cual llamaremos
      <type>Stash</type>:
    </para>


<programlisting>
<xi:include parse="text" href="./code/C04/CppLib.h"/>
</programlisting>

    <para>
      La primera diferencia que puede notarse es que no se usa <literal
      role="keyword">typedef</literal>. A diferencia de C que requiere
      el uso de <literal role="keyword">typedef</literal> para crear
      nuevos tipos de datos, el compilador de C++ hará que el nombre de
      la estructura sea un nuevo tipo de dato automáticamente en nuestro
      programa (tal como los nombres de tipos de datos <type>int</type>,
      <type>char</type>, <type>float</type> y <type>double</type>).
    </para>
    
    <para>
      Todos los datos miembros de la estructura están declarados igual
      que antes; sin embargo, ahora las funciones están declaradas
      dentro del cuerpo de la <literal
      role="keyword">struct</literal>. Más aún, nótese que el primer
      argumento de todas las funciones ha sido quitado de estas. En C++,
      en lugar de forzar al usuario a que pase la dirección de la
      estructura sobre la que trabaja una función como primer argumento,
      el compilador hará este trabajo, secretamente. Ahora sólo
      deberemos preocuparnos por los argumentos que le dan sentido a lo
      que la función <emphasis>hace</emphasis> y no de los mecanismos
      internos de funcionamiento de la función.
    </para>

    <para>
      Es importante saber que el código generado por estas funciones es
      el mismo que el de las funciones de la librería al estilo C. El
      número de argumentos es el mismo (aunque no veamos que se pase la
      dirección de la estructura como primer argumento, en realidad sí
      se hace) y sigue existiendo un único cuerpo (definición) de cada
      función. Esto último quiere decir que, aunque declaremos múltiples
      variables

      <programlisting>Stash A, B, C;</programlisting> 

      no existirán múltiples definiciones de, por ejemplo, la
      función <function>add()</function>, una para cada variable. 
    </para>

    <para>
      Como ya dijimos, el código generado es casi idéntico al que
      hubiésemos escrito para una versión en C de la librería,
      incluyendo la "decoración de nombres" ya mencionada para evitar
      los conflictos de nombres, nombrando a las funciones
      <function>Stash_initialize()</function>, <function>Stash_cleanup(
      )</function> y demás. Cuando una función está dentro de una
      estructura, el compilador C++ hace lo mismo y así, una función
      llamada <function>initialize()</function> dentro de una estructura
      no estará en conflicto con otra función
      <function>initialize()</function> dentro de otra estructura o con
      una función <function>initialize()</function> global. De este
      modo, en general no tendremos que preocuparnos por el conflicto de
      nombres de funciones --usamos el nombre sin decoración. Sin
      embargo, habrán situaciones en las que deseamos especificar que,
      por ejemplo, esta <function>initialize()</function> pertenece a la
      estructura <type>Stash</type> y no a ninguna otra. En particular,
      cuando definimos la función, necesitamos especificar a qué
      estructura pertenece para lo cual, en C++ contamos con el operador
      <literal role="operator">[FIXME: arreglar etiqueta]::</literal>
      llamado operador de resolución de ámbito (llamado así ya que
      ahora, como vimos, un nombre puede estar en diferentes ámbitos: el
      el ámbito global o dentro del ámbito de una estructura. Por
      ejemplo, si nos queremos referir a una función
      <function>initialize()</function> que se encuentra dentro de la
      estructura <type>Stash</type> lo podremos hacer con la expresión
      <function>Stash::initialize(int size)</function>. A continuación
      se podrá ver cómo se usa el operador de resolución de ámbito para
      definir funciones: [fixme: traducir el siguiente
      programlisting]
    </para>


<programlisting>
<xi:include parse="text" href="./code/C04/CppLib.cpp"/>
</programlisting>

    <para>
      Hay muchas otras cosas que son diferentes entre C y C++. Para
      empezar, el compilador <emphasis>requiere</emphasis> que
      declaremos las funciones en los archivos de cabecera: en C++ no
      podremos llamar a una función sin antes haberla declarado y si no
      se cumple con esta regla el compilador dará un error. Esta es una
      forma importante de asegurar que las llamadas a una función son
      consistentes entre el punto en el cual fue llamada y el punto y el
      cual fue definida. Al forzarnos a declarar una función antes de
      usarla, el compilador de C++ virtualmente se asegura de que
      realizaremos esta declaración por medio de la inclusión de un
      archivo de cabecera. Además, si también incluímos el mismo archivo
      de cabecera en el mismo lugar donde las funciones son definidas,
      el compilador también verificará que las declaraciones en el
      archivo cabecera y las definiciones coincidan. Puede decirse
      entonces que, de alguna manera, los archivos de cabecera se
      vuelven un repositorio de validación de funciones y permiten
      asegurarnos de que las funciones son usadas de modo consistente en
      todas las unidades de traducción del proyecto. 
    </para>

    <para>
      Obviamente, las funciones globales se pueden seguir declarando a
      mano en aquellos lugares en las que son definidas y usadas. (Sin
      embargo, esta práctica es tan tediosa que se ha vuelto en desuso.)
      De cualquier modo, las estructuras siempre deben ser declaradas
      antes de ser usadas y el mejor lugar para esto es un archivo de
      cabecera, exceptuando aquellas que queremos esconder
      intencionalmente en otro archivo. 
    </para>

    <para>
      Se puede ver que todas las funciones miembros tienen casi la misma
      forma que sus versiones respectivas en C. Las únicas diferencias
      son su alcance [fixme: scope resolution] y el hecho de que el
      primer argumento ya no aparece explícito en el prototipo de la
      función. Por supuesto que sigue ahí ya que la función debe ser
      capaz de trabajar sobre una variable <literal
      role="keyword">struct</literal> en particular. Sin embargo, ¡notar
      también que, dentro de la función miembro, la selección de esta
      estructura en particular también ha desaparecido! Así, en lugar de
      decir <programlisting>s->size = sz;</programlisting> ahora decimos
      <programlisting>size = sz;</programlisting> eliminando el tedioso
      <literal>s-></literal> que en realidad no aportaba nada al
      significado semántico de lo que estamos
      escribiendo. Aparentemente, el compilador de C++ está realizando
      estas tareas por nosotros. De hecho, está tomando el primer
      argumento "secreto" (la dirección de la estructura que antes
      teníamos que pasar a mano) y aplicándole el selector de miembro
      (->) siempre que escribamos el nombre de uno de los datos
      miembro. Esto significa que, siempre y cuando estemos dentro de la
      definición de una función miembro de una estructura podemos hacer
      referencia a cualquier otro miembro (incluyendo otra función
      miembro) simplemente dando su nombre. El compilador buscará
      primero en los nombres locales de la estructura antes de buscar en
      versiones más globales de dichos nombres. El lector podrá
      descubrir que esta característica no sólo agiliza la escritura del
      código, sino que también hace la lectura del mismo mucho más
      tribial.
    </para>
    
    <para>
      Pero qué pasaría si, por alguna razón,
      <emphasis>deseáramos</emphasis> hacer referencia a la dirección de
      memoria de la estructura. En la versión en C de la librería esta
      se podía obtener fácilmente del primer argumento de cualquier
      función. En C++ la cosa e más consistente: existe la palabra
      reservada <literal role="keyword">this</literal> la cual produce
      la dirección de la variable <literal
      role="keyword">struct</literal> actual. Es el equivalente a la
      expresión '<varname>s</varname>' de la versión en C de la
      librería. Así, podremos volver al estilo de C escribiendo
    </para>

    <programlisting>this->size = Size;</programlisting>

    <para>
      El código generado por el compilador será exactamente el mismo por
      lo que no es necesario usar <literal role="keyword">this</literal>
      en este tipo de casos. A propósito, se podrá ver por ahí código en
      dónde la gente usa <literal role="keyword">this</literal> en todos
      lados sin agregar nada al significado del código (esta práctica
      nos da indicios de programadores inexperientes). Por lo general,
      <literal role="keyword">this</literal> no se usa muy a menudo
      pero, cuando se lo necesite siempre estará allí (en ejemplos
      posteriores del libro se verá más sobre su uso).
    </para>

    <para>
      Queda aún un último tema que tocar. En C, se puede asignar un
      <type>void *</type> a cualquier otro puntero, algo como esto:
    </para>

<programlisting>
int i = 10;
void* vp = &amp;i; // OK tanto en C como en C++
int* ip = vp; // Sólo aceptable en C
</programlisting>

    <para>
      y no habrá ningún tipo de queja por parte de compilador. Sin
      embargo, en C++, lo anterior no estará permitido. ¿Por qué? Porque
      C no es tan estricto con los tipos de información y nos deja
      asignar un puntero sin un tipo específico a un puntero de un tipo
      bien determinado. No así C++ en el cual la verificación de tipos
      es crítica y el compilador se detendrá quejándose en cualquier
      violación de tipos. Esto siempre ha sido importante, pero es
      especialmente importante en C++ ya que dentro de las estructuras
      podemos tener funciones miembros. Si en C++ estuviera permitido
      pasar punteros a estructuras sin ningún tipo de impunidad en
      cuanto a violaciones de tipos, ¡podríamos terminar llamando a una
      función miembro de una estructura en la cual no existiera
      lógicamente dicha función miembro! Una verdadera fórmula para el
      desastre. Así, mientras C++ sí nos deja asignar cualquier puntero
      a un <type>void *</type> (en realidad este es el propósito
      original del puntero a <type>void</type>: que sea suficientemente
      largo como para apuntar a cualquier tipo) no nos dejará asignar un
      <type>void *</type> a cualquier otro tipo de puntero. Para ello se
      requiere un moldeado para indicarle tanto al lector como al
      compilador que realmente queremos tratarlo como el puntero
      destino.
    </para>

    <para>
      Y esto nos lleva a discutir un asunto interesante. Uno de los
      objetivos importantes de C++ es poder compilar la mayor cantidad
      posible de código en C para así, permitir una fácil transición al
      nuevo lenguaje. Sin embargo, esto no significa, como hemos visto
      que cualquier segmento de código que sea válido en C, será
      automáticamente permitido en C++. Hay varias cosas que un
      compilador de C nos permite hacer que son potencialmente
      peligrosas y propensas a generar errores (se verán ejemplos de
      estas a lo largo de libro). El compilador de C++ genera errores y
      avisos en este tipo de situaciones y como veremos esto es más una
      ventaja que un obstáculo a pesar de su naturaleza restrictiva. ¡De
      hecho, existen muchas situaciones en las cuales tratamos de
      detectar sin éxito un error en C y cuando recompilamos el programa
      con un compilador de C++ este nos avisa exactamente la causa del
      problema!. En C, muy a menudo nos hallamos con que para que un
      programa funcione correctamente, además de compilarlo, luego
      deberemos <emphasis>hacer que ande</emphasis>. ¡En C++, por el
      contrario, veremos que muchas veces si un programa compila
      correctamente es probable de que ya funcione bien!  Esto se debe a
      que este último lenguaje es mucho más estricto respecto a la
      comprobación de tipos de información.
    </para>

    <para>
      En el siguiente programa test se podrá apreciar nuevas cosas con
      respecto a cómo se utiliza la nueva versión de la
      <type>Stash</type>:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C04/CppLibTest.cpp"/>
</programlisting>


    <para>
      Una de las cosas que el lector habrá podido observar en el código
      anterior es que las variables se definen <quote>al vuelo</quote>,
      o sea (como se introdujo en el capítulo anterior) en cualquier
      parte de un bloque y no necesariamente - como en C - al comienzo
      de los mismos. 
    </para>

    <para>
      El código es bastante similar al visto en
      <filename>CLibTest.cpp</filename> con la diferencia de que, cuando
      se llama a una función miembro, se utiliza el operador de
      selección de miembro '<literal role="operator">.</literal>'
      precedido por el nombre de la variable. Esta es una síntaxis
      conveniente ya que imita a la selección o acceso de un dato
      miembro de una estructura. La única diferencia es que, al ser una
      función miembro, su llamada implica una lista de
      argumentos.
    </para>

    <para>
      Tal y cómo lo hemos dicho antes, la llamada que el compilador hace
      <emphasis>realmente</emphasis> es en realidad mucho más parecida a
      la llamada a la función de la librería en C. Consideremos la
      decoración de nombres y el pasaje del puntero <literal
      role="keyword">this</literal>: la llamada en C++ de
      <function>intStash.initialize(sizeof(int), 100)</function> se
      transformará en algo parecido a
      <function>Stash_initialize(&amp;intStash, sizeof(int),
      100)</function>. Si el lector se pregunta qué es lo que sucede
      realmente debajo del envoltorio, debería recordar que el
      compilador original de C++ <application>cfront</application> de
      AT&amp;T producía código C como salida la que luego debía ser
      compilada con un compilador de C para generar el ejecutable. Este
      método permitía a <application>cfront</application> ser
      rápidamente portable a cualquier máquina que soportara un
      compilador estándar de C y ayudó a la rápida diseminación de
      C++. Así, dado que los compiladores antiguos de C++ tenían que
      generar código C, sabemos ahora que existe una manera de
      representar síntaxis C++ en C (algunos compiladores de hoy en día
      aún permiten generar código C).
    </para>

    <para>
      Comparando con <filename>CLibTest.cpp</filename> observamos un
      cambio: la introducción del archivo de cabecera
      <filename>require.h</filename>. He creado este archivo de cabecera
      para realizar chequeo de errores más sofisticados que los que
      provee <function>assert()</function>. Contiene varias funciones
      incluyendo la llamada en este último ejemplo,
      <function>assure()</function> la cual es usada sobre
      archivos. Esta función verifica que un archivo se ha abierto
      exitosamente y en caso contrario reporta a la salida de errores
      estándar un aviso de error (por lo que también necesitará el
      nombre del archivo como segundo argumento) y sale del
      programa. Las funciones de <filename>require.h</filename> se
      usarán a lo largo de este libro especialmente para asegurarnos de
      que se ha ingresado la cantidad correcta de argumentos en la línea
      de comandos y para verificar que los archivos son abiertos
      correctamente. Las funciones de <filename>require.h</filename>
      reemplazan el código de detección de errores repetitivo y que
      muchas veces es causa de distracciones y más aún, proveen de
      mensajes útiles para la detección de estos posibles errores. Estas
      funciones serán totalmente explicadas más adelante en el
      libro.
    </para>
  </sect1>


  <sect1>
    <title>¿Qué es un objeto?</title>

    <para>
      Ahora que ya se ha visto y discutido un ejemplo incial es hora de
      retroceder para definir la terminología. El acto de meter
      funciones dentro de las estructuras es el eje central del cambio
      que C++ propone sobre C e introduce una nueva forma de ver las
      estructuras: como conceptos. En C, una estructura (<literal
      role="keyword">struct</literal>) es tan sólo una aglomeración de
      datos: una manera de empaquetar datos para que puedan ser tratados
      como un grupo. De esta forma, cuesta hacernos la idea de que
      representan algo más que sólo sólo una conveniencia de
      programación. Las funciones que operan sobre esas estructuras
      están sueltas por ahí. Sin embargo, cuando vemos las funciones
      dentro del mismo paquete que los datos la estructura se vuelve una
      nueva criatura, capáz de representar características (como las
      <literal role="keyword">struct</literal>s de C)
      <emphasis>y</emphasis> comportamientos. El concepto de un objeto,
      una entidad independiente y bien limitada que puede recordar
      <emphasis>y</emphasis> actuar, se sugiere a si mismo como
      definición.
    </para>

    <para>
      En C++ un objeto es simplemente una variable, y la definición más
      pura es <quote>una región de almacenamiento</quote> (esto último
      es una manera más específica de decir <quote>un objeto debe tener
      un único identificador</quote> el cual, en el caso de C++, es una
      única dirección de memoria). Es un lugar en el cual se puede
      almacenar datos y en el cual está implícita la existencia de
      operaciones sobre esos datos.
    </para>

    <para>
      Desafortunadamente no existe una completa consistencia entre los
      distintos lenguajes cuando se habla de estos términos aunque son
      bastante bien aceptados. También se podrán encontrar discrepancias
      sobre lo que es un lenguaje orientado a objetos aunque parece
      estarse estableciendo un concenso sobre esto hoy en día
      también. Hay lenguajes que se denominan <emphasis>basados en
      objetos</emphasis> los cuales, cuentan con
      estructuras-con-funciones como las que hemos visto aquí de
      C++. Sin embargo, esto tan sólo es una parte de lo que denominamos
      lenguaje <emphasis>orientado a objetos</emphasis> y afirmamos que
      los lenguajes que solamente llegan a empaquetar las funciones
      dentro de las estructuras son lenguajes basados en objetos y no
      orientados a objetos.
    </para>
  </sect1>


  <sect1>

    <!-- Abstract data typing --> 
    <!-- "Tipado de datos abstracto" no me gustó-->
    <title>Tipos abstractos de datos</title>

    <para>
      El ser capaces de empaquetar datos junto con funciones nos permite
      la creación de nuevos tipos de datos. Esto es muchas veces llamado
      <emphasis>encapsulación</emphasis>

      <footnote>
        <para>Este término puede causar debates. Algunas personas
          lo utilizan tal y como está definido aquí, aunque
          otras lo usan para describir el <emphasis>control de
          acceso</emphasis>, término que se discutirá en el
          siguiente capítulo. </para>
      </footnote>

      Un tipo de dato ya existente puede contener varias piezas de datos
      juntas. Por ejemplo, un <type>float</type> tiene un exponente, una
      mantissa y un bit de signo. Le podemos pedir que haga varias
      cosas, entre ellas, sumarse a otro <type>float</type>, a un
      <type>int</type>, etc. Así, podemos decir que tiene
      características y comportamiento.
    </para>

    <para>
      La definición de un <type>Stash</type> crea un nuevo tipo de
      dato. Le podemos agregar nuevos elementos
      (<function>add()</function>), sacar (<function>fetch()</function>)
      y agrandarlo (<function>inflate()</function>). Creamos uno
      escribiendo <literal>Stash s;</literal> igual que cuando creamos
      un <type>float</type> diciendo <literal>float x;</literal>. Un
      <type>Stash</type> también tiene características y un
      comportamiento bien determinado. Aunque actúe igual que un tipo de
      dato predefinido como <type>float</type> diremos que un
      <type>Stash</type> es un <emphasis>tipo abstracto de
      dato</emphasis> talvez porque permite abstraer un concepto desde
      el espacio de los problemas al espacio solución. Además, el
      compilador de C++ lo tratará exactamente como a un nuevo tipo de
      dato y si, por ejemplo, declaramos una función para que espere un
      <type>Stash</type> como argumento, el compilador se asegurará de
      que no se le pase otra cosa a la función. Así, la comprobación de
      tipos se realiza al mismo nivel tanto para los tipos abstractos de
      datos (a veces también llamados <emphasis>tipos definidos por el
      usuario</emphasis>) como para los tipos predefinidos.
    </para>

    <para>
      Sin embargo, se notará inmediatamente una diferencia en cómo se
      realizan las operaciones sobre los objetos. Hacemos
      <literal>objeto.funciónMiembro(listaArgumentos)</literal> o sea,
      <quote>llamamos a una función miembro para el objeto</quote>. No
      obstante, en la jerga de los lenguajes orientados a objetos, nos
      referimos a lo anterior también como <quote>enviar un mensaje al
      objeto</quote>. Así, para una <varname>Stash s</varname>, en esta
      jerga la sentencia <literal>s.add(&amp;i)</literal> le
      <quote>envía un mensaje a <varname>s</varname></quote> diciéndole
      <quote>agrégate (<function>add()</function>) <varname>i</varname>
      a ti mismo</quote>. De hecho, la programación orientada a objetos
      puede ser resumida en la siguiente frase: <emphasis>enviar
      mensajes a objetos</emphasis>. Y es realmente todo lo que se hace:
      se crea un conjunto de objetos y se les envía mensajes. El truco,
      obviamente, es entender qué <emphasis>son</emphasis> en nuestro
      problema los objetos y los mensajes, pero una vez que se ha
      cumplido esa etapa, la implementación en C++ será
      sorprendentemente directa.
    </para>
  </sect1>

<!--
Hasta aquí tradujo Sebastián Gurin
-->


  <sect1>
    <title>Detalles del objeto</title>
    
    <!--
    A question that often comes up in seminars is, "How big is an
    object, and what does it look like?" The answer is "about what you
    expect from a C struct." In fact, the code the C compiler produces
    for a C struct (with no C++ adornments) will usually look exactly
    the same as the code produced by a C++ compiler. This is reassuring
    to those C programmers who depend on the details of size and layout
    in their code, and for some reason directly access structure bytes
    instead of using identifiers (relying on a particular size and
    layout for a structure is a nonportable activity).
    -->

    <para>
      Una pregunta que surge a menudo en seminarios es <quote>¿Cómo de
      grande es un objeto y qué pinta tiene?</quote> La respuesta es
      <quote>más o menos lo que esperas de un <keyword>struct</keyword>
      C</quote>. De hecho, el código que produce el compilador de C para
      un <keyword>struct</keyword> C (sin adornos C++) normalmente será
      <emphasis>exactamente</emphasis> el mismo que el producido por un
      compilador C++. Eso tranquiliza a aquellos programadores C que
      dependan de los detalles de tamaño y distribución de su código, y
      que por alguna razón accedan directamente a los bytes de la
      estructura en lugar de usar identificadores (confiar en un tamaño
      y distribución particular para una estructura no es portable).
    </para>


    <!--
    The size of a struct is the combined size of all of its
    members. Sometimes when the compiler lays out a struct, it adds
    extra bytes to make the boundaries come out neatly - this may
    increase execution efficiency. In Chapter 15, you'll see how in
    some cases "secret" pointers are added to the structure, but you
    don't need to worry about that right now.
    -->
    
    <para>
      El tamaño de una <keyword>struct</keyword> es la combinación de
      los tamaños de todos sus miembros. A veces cuando el compilador
      crea una <keyword>struct</keyword>, añade bytes extra para hacer
      que los límites encajen limpiamente - eso puede incrementar la
      eficiencia de la ejecución. En el Capítulo 14, verá cómo en
      algunos casos se añaden punteros <quote>secretos</quote> a la
      estructura, pero no tiene que preocuparse de eso ahora.
    </para>
  
    <!--
    You can determine the size of a struct using the sizeof
    operator. Here's a small example:
    -->

    <para>
      Puede determinar el tamaño de una <keyword>struct</keyword> usando
      el operador <literal role="operator">sizeof</literal>. Aquí tiene
      un pequeño ejemplo:
    </para>

<programlisting>
<xi:include parse="text" href="./code/C04/Sizeof.cpp"/>
</programlisting>

    <!--
    On my machine (your results may vary) the first print statement
    produces 200 because each int occupies two bytes. struct B is
    something of an anomaly because it is a struct with no data
    members. In C, this is illegal, but in C++ we need the option of
    creating a struct whose sole task is to scope function names, so it
    is allowed. Still, the result produced by the second print statement
    is a somewhat surprising nonzero value. In early versions of the
    language, the size was zero, but an awkward situation arises when
    you create such objects: They have the same address as the object
    created directly after them, and so are not distinct. One of the
    fundamental rules of objects is that each object must have a unique
    address, so structures with no data members will always have some
    minimum nonzero size.
    -->

    <para>
      En mi máquina (sus resultado pueden variar) el primer resultado
      produce 200 porque cada <type>int</type> ocupa 2 bytes. La
      <keyword>struct</keyword> <type>B</type> es algo anómalo porque es
      una <keyword>struct</keyword> sin atributos. En C, eso es ilegal,
      pero en C++ necesitamos la posibilidad de crear una
      <keyword>struct</keyword> cuya única tarea es ofrecer un ámbito a
      nombres de funciones, de modo que está permitido. Aún asi, el
      segundo resultado es un sorprendente valor distinto de cero. En
      versiones anteriores del lenguage, el tamaño era cero, pero
      aparecia una situación incómoda cuando se creaban estos objetos:
      tenían la misma dirección que el objeto creado antes que él, y
      eran indistinguibles. Una de las reglas fundamentales de los
      objetos es que cada objeto debe tener una dirección única, así que
      las estructuras sin atributos siempre tendrán tamaño mínimo
      distinto de cero.
    </para>

    <!--
    The last two sizeof statements show you that the size of the
    structure in C++ is the same as the size of the equivalent version
    in C. C++ tries not to add any unnecessary overhead.
    -->

    <para>
      Las dos últimas sentencias <literal
      role="operator">sizeof</literal> muestran que el tamaño de la
      estructura en C++ es el mismo que en la versión en C. C++ intenta
      no añadir ninguna sobrecarga innecesaria.
    </para>
  </sect1>


  <sect1>
    <title>Conveciones para los ficheros de cabecera</title>

    <!--
    When you create a struct containing member functions, you are
    creating a new data type. In general, you want this type to be
    easily accessible to yourself and others. In addition, you want to
    separate the interface (the declaration) from the implementation
    (the definition of the member functions) so the implementation can
    be changed without forcing a re-compile of the entire system. You
    achieve this end by putting the declaration for your new type in a
    header file.
    -->

    <para>
      Cuando se crea una <keyword>struct</keyword> que contiene
      funciones miembro, se está creando un nuevo tipo de dato. En
      general, se intenta que ese tipo sean fácilmente accesible. En
      resumen, se quiere que la interface (la declaración) está separada
      de la implmentación (la definición de las funciones miembro) de
      modo que la implementación pueda cambiar sin obligar a recompilar
      el sistema completo. Puede conseguir esto poniendo la declaración
      del nuevo tipo en un fichero de cabecera.
    </para>


    <!--
    When I first learned to program in C, the header file was a mystery
    to me. Many C books don't seem to emphasize it, and the compiler
    didn't enforce function declarations, so it seemed optional most of
    the time, except when structures were declared. In C++ the use of
    header files becomes crystal clear. They are virtually mandatory for
    easy program development, and you put very specific information in
    them: declarations. The header file tells the compiler what is
    available in your library. You can use the library even if you only
    possess the header file along with the object file or library file;
    you don't need the source code for the cpp file. The header file is
    where the interface specification is stored.
    -->

    <para>
      Cuando yo aprendí a programar en C, el fichero de cabecera era un
      misterio para mi. Muchos libros de C no hacen hincapié, y el
      compilador no obliga la declaración de las funciones, así que
      parecía algo opcional la mayor parte de las veces, excepto cuando
      se declaraban estrucutras. En C++ el uso de los ficheros de
      cabecera se vuelve clara como el cristal. SOn práctimente
      obligatorios para el desarrollo de programas sencillos, y ponga en
      ellos información muy específica: declaraciones. El fichero de
      cabecera informa al compilador lo que hay disponible en la
      librería. Puede usar la librería incluso si sólo se dispone del
      fichero de cabecera y el fichero objeto o el fichero de librería;
      no necesita disponer del código fuente del fichero
      <filename>cpp</filename>. El fichero de cabecera es donde se
      guarda la especificación de la interfaz.
    </para>

    <!--
    Although it is not enforced by the compiler, the best approach to
    building large projects in C is to use libraries; collect associated
    functions into the same object module or library, and use a header
    file to hold all the declarations for the functions. It is de
    rigueur in C++; you could throw any function into a C library, but
    the C++ abstract data type determines the functions that are
    associated by dint of their common access to the data in a
    struct. Any member function must be declared in the struct
    declaration; you cannot put it elsewhere. The use of function
    libraries was encouraged in C and institutionalized in C++.
    -->

    <para>
      Aunque el compilador no lo obliga, el mejor modo de construir
      grandes proyectos en C es usar librerías; colecciones de funciones
      asociadas en un mismo módulo objeto o librería, y usar un fichero
      de cabecera para colocar todas las declaraciones de las
      funciones. Es <emphasis>de rigor</emphasis> en C++, Podría meter
      cualquier función en una librería C, pero el tipo abstrato de dato
      C++ determina las funciones que están asociadas por medio del
      acceso común a los datos de una
      <keyword>struct</keyword>. Cualquier función miembro debe ser
      declarada en la declaración de la <keyword>struct</keyword>; no
      puede ponerse en otro lugar. El uso de librerías de funciones fue
      fomentado en C y institucionalizado en C++.
    </para>
    

    <sect2>
      <title>Importancia de los ficheros de cabecera</title>

      <!--
      When using a function from a library, C allows you the option of
      ignoring the header file and simply declaring the function by
      hand. In the past, people would sometimes do this to speed up the
      compiler just a bit by avoiding the task of opening and including
      the file (this is usually not an issue with modern compilers). For
      example, here's an extremely lazy declaration of the C function
      printf( ) (from %amp;stdio.h>):
      -->

      <para>
	Cuando se una función de una librería, C le permite la
	posibilidad de ignorar el fichero de cabecera y simplemente
	declarar la función a mano. En el pasado, la gente hacía eso a
	veces para acelerar un poquito la compilación evitando la tarea
	de abrir e incluir el fichero (eso no supone ventaja alguna con
	los compiladores modernos). Por ejemplo, la siguiente es una
	declaración extremadamente vaga de la función
	<function>printf()</function> (de
	<filename>&lt;stdio.h></filename>):
      </para>

<programlisting>
printf(...);
</programlisting>

      <!--
      The ellipses specify a variable argument list[34], which says:
      printf( ) has some arguments, each of which has a type, but ignore
      that. Just take whatever arguments you see and accept them. By
      using this kind of declaration, you suspend all error checking on
      the arguments.
      -->

      <para>
	Estos puntos suspensivos (N. de
	T. <emphasis>ellipsis</emphasis>) en inglés) especifican una
	lista de argumentos variable[34], que dice:
	<function>printf()</function> tiene algunos argumentos, cada uno
	con su tipo, pero no se sabe cuales. Simplemente, coge los
	argumentos que veas y aceptalos. Usando este tipo de
	declaración, se suspende la comprobación de errores en los
	argumentos.
      </para>

      <!--
      This practice can cause subtle problems. If you declare functions
      by hand, in one file you may make a mistake. Since the compiler
      sees only your hand-declaration in that file, it may be able to
      adapt to your mistake. The program will then link correctly, but
      the use of the function in that one file will be faulty. This is a
      tough error to find, and is easily avoided by using a header file.
      -->

      <para>
	Esta práctica puede causar problemas sutiles. Si declara
	funciones <quote>a mano</quote>, en un fichero puede cometer un
	error. Dado que el compilador sólo verá las declaración hechas a
	mano en ese fichero, se adaptará al error. El programa enlazará
	correctamente, pero el uso de la función en ese fichero será
	defectuoso. Se trata de un error dificil de encontrar, y que se
	puede evitar fácilmente usando el fichero de cabecera
	correspondiente.
      </para>

      <!--
      If you place all your function declarations in a header file, and
      include that header everywhere you use the function and where you
      define the function, you ensure a consistent declaration across
      the whole system. You also ensure that the declaration and the
      definition match by including the header in the definition file.
      -->

      <para>
	Si se colocan todas las declaraciones de funciones en un fichero
	de cabecera, y se incluye ese fichero allí donde se use la
	función se asegurará una declaración consistente a través del
	sistema completo. También se asegurará de que la declaración y
	la definición corresponden incluyendo el fichero de cabecera en
	el fichero de definición.
      </para>


      <!--
      If a struct is declared in a header file in C++, you must include
      the header file everywhere a struct is used and where struct
      member functions are defined. The C++ compiler will give an error
      message if you try to call a regular function, or to call or
      define a member function, without declaring it first. By enforcing
      the proper use of header files, the language ensures consistency
      in libraries, and reduces bugs by forcing the same interface to be
      used everywhere.
      -->

      <para>
	Si se declara una <keyword>struct</keyword> en un fichero de
	cabecera en C++, se <emphasis>debe</emphasis> incluir ese
	fichero allí donde se use una <keyword>struct</keyword> y
	también donde se definan los métodos la
	<keyword>struct</keyword>. El compilador de C++ devolverá un
	mensaje de error si intenta llamar a una función, o llamar o
	definir un método, sin declararla primero. Imponiendo el uso
	apropiado de los ficheros de cabecera, el lenguaje asegura la
	cosistencia de las librerías, y reduce el número de error
	forzando que se use la misma interface en todas partes.
      </para>


      <!--
      The header is a contract between you and the user of your
      library. The contract describes your data structures, and states
      the arguments and return values for the function calls. It says,
      "Here's what my library does." The user needs some of this
      information to develop the application and the compiler needs all
      of it to generate proper code. The user of the struct simply
      includes the header file, creates objects (instances) of that
      struct, and links in the object module or library (i.e.: the
      compiled code).
      -->
      
      <para>
	El fichero de cabecera es un contrato entre el programador de la
	librería y el que la usa. El contrato describe las estructuras
	de datos, expone los argumentos y valores de retorno para las
	funciones. Dice, <quote>Esto es lo que hace mi
	librería</quote>. El usuario necesita parte de esta información
	para desarrollar la aplicación, y el compilador necesita toda
	ella para generar el código correcto. El usuario de la
	<keyword>struct</keyword> simplemente incluye el fichero de
	cabecera, crea objetos (instancias) de esa
	<keyword>struct</keyword>, y enlaza con el módulo objeto o
	librería (es decir, el código compilado)
      </para>

      <!--
      The compiler enforces the contract by requiring you to declare all
      structures and functions before they are used and, in the case of
      member functions, before they are defined. Thus, you're forced to
      put the declarations in the header and to include the header in
      the file where the member functions are defined and the file(s)
      where they are used. Because a single header file describing your
      library is included throughout the system, the compiler can ensure
      consistency and prevent errors.
      -->

      <para>
	El compilador impone el contrato obligando a declarar todas las
	estruturas y funciones antes que de ser usadas y, en el caso de
	métodos, antes de ser definidas. De ese modo, se le obliga a
	poner las declaraciones en el fichero de cabecera e incluirlo en
	el fichero en el que se definen los métodos y en los ficheros en
	los que se usen. Como se incluye un único fichero que describe
	la librería para todo el sistema, el compilador puede asegurar
	la consistencia y prevenir errores.
      </para>

      <!--
      There are certain issues that you must be aware of in order to
      organize your code properly and write effective header files. The
      first issue concerns what you can put into header files. The basic
      rule is "only declarations," that is, only information to the
      compiler but nothing that allocates storage by generating code or
      creating variables. This is because the header file will typically
      be included in several translation units in a project, and if
      storage for one identifier is allocated in more than one place,
      the linker will come up with a multiple definition error (this is
      C++'s one definition rule: You can declare things as many times
      as you want, but there can be only one actual definition for each
      thing).
      -->

      <para>
	Hay ciertos asuntos a los que debe prestar atención para
	organizar su código apropiadamente y escribir ficheros de
	cabecera eficaces. La regla básica es <quote>únicamente
	declaraciones</quote>, es decir, sólo información para el
	compiladore pero nada que requiera alojamiento en memoria ya sea
	generando código o creando variables. Esto es así porque el
	fichero de cabecera normalmente es incluido en varios unidades
	de traducción en un proyecto, y si el almacenamiento para un
	identificador se pide en más de un sitio, el enlazador indicará
	un error de definición múltiple (ésta es la <emphasis>regla de
	definición única</emphasis> de C++: Se puede declarar tantas
	veces como se quiera, pero sólo puede haber una definición real
	para cada cosa).
      </para>

      <!--
      This rule isn't completely hard and fast. If you define a
      variable that is "file static" (has visibility only within a
      file) inside a header file, there will be multiple instances of
      that data across the project, but the linker won't have a
      collision[35]. Basically, you don't want to do anything in the
      header file that will cause an ambiguity at link time.
      -->

      <para>
	Esta regla no es completamente [FIXME:hard and fast]. Si se
	define una variable que es <quote>file static</quote> (que tiene
	visibilidad sólo en un fichero) dentro de un fichero de
	cabecera, habrá múltiples instancias de ese dato a lo largo del
	proyecto, pero el enlazador no tendrá una
	colisión[35]. Básicamente, se debe evitar cualquier cosa en los
	ficheros de cabecera que pueda causar una ambigüedad en tiempo
	de enlazado.
      </para>
    </sect2>


    <sect2>
      <title>El problema de la declaración múltiple</title>

      <!--
      The second header-file issue is this: when you put a struct
      declaration in a header file, it is possible for the file to be
      included more than once in a complicated program. Iostreams are a
      good example. Any time a struct does I/O it may include one of the
      iostream headers. If the cpp file you are working on uses more
      than one kind of struct (typically including a header file for
      each one), you run the risk of including the iostream> header
      more than once and re-declaring iostreams.
      -->


      <para>
	La segunda cuestión respecto a los ficheros de cabecera es ésta:
	cuando se pone una declaración de <keyword>struct</keyword> en
	un fichero de cabecera, es posible que el fichero sea incluido
	más de una vez en un programa complicado. Los iostreams son un
	buen ejemplo. Cada vez que una <keyword>struct</keyword> hace
	E/S debe incluir uno de los ficheros de cabecera iostream. Si el
	fichero <filename>cpp</filename> sobre el que se está trabajando
	utiliza más de un tipo de <keyword>struct</keyword> (tipicamente
	incluyendo un fichero de cabecera para cada una), se está
	corriendo el riesgo de incluir el fichero
	<filename>&lt;isotream></filename> más de una vez y re-declarar
	los iostreams.
      </para>

      <!--
      The compiler considers the redeclaration of a structure (this
      includes both structs and classes) to be an error, since it would
      otherwise allow you to use the same name for different types. To
      prevent this error when multiple header files are included, you
      need to build some intelligence into your header files using the
      preprocessor (Standard C++ header files like iostream> already
      have this "intelligence").
      -->

      <para>
	El compilador considera que la redeclaración de una estructura (eso
	es aplicable tando a las <keyword>struct</keyword> como a las
	<keyword>class</keyword>) es un error, dado que de otro modo,
	debería permitir el uso del mismo nombre para tipos
	diferentes. Para prevenir este error cuando se incluyen
	múltiples ficheros de cabecera, es necesario dar algo de
	inteligencia a los ficheros de cabecera usando el preprocesador
	(los ficheros de cabecera estándares como
	<filename>&ltMiostream></filename> también tienes esta
	<quote>inteligencia</quote>).
      </para>


      <!--
      Both C and C++ allow you to redeclare a function, as long as the
      two declarations match, but neither will allow the redeclaration
      of a structure. In C++ this rule is especially important because
      if the compiler allowed you to redeclare a structure and the two
      declarations differed, which one would it use?
      -->

      <para>
	Tanto C como C++ permiten redeclarar una función, siempre que
	las dos declaración coincidan, pero ni en ese caso se permite la
	redeclaración de una estructura. En C++ esta regla es
	especialmente importante porque si el compilador permitiera la
	redeclaración de una estructura y las dos declaraciones
	difirieran, ¿cuál debería usar? 
      </para>

      <!--
      The problem of redeclaration comes up quite a bit in C++ because
      each data type (structure with functions) generally has its own
      header file, and you have to include one header in another if you
      want to create another data type that uses the first one. 
      In any cpp file in your project, it's likely that you'll include several
      files that include the same header file. During a single
      compilation, the compiler can see the same header file several
      times. Unless you do something about it, the compiler will see the
      redeclaration of your structure and report a compile-time
      error. To solve the problem, you need to know a bit more about the
      preprocessor.  -->

      <para>
	El problema de la redeclaración se agrava un poco en C++ porque
	cada tipo de dato (estructura con funciones) generalmente tiene
	su propio fichero de cabecera, y hay que incluir un fichero de
	cabecera en otro si se quiere crear otro tipo de dato que use al
	primero. Es probable que en algún fichero
	<filename>cpp</filename> de su proyecto, que se incluyan varios
	ficheros que incluyan al mismo fichero de cabecera. Durante una
	compilación simple, el compilador puede ver el mismo fichero de
	cabecera varias veces. A menos que se haga algo al respecto, el
	compilador verá la redeclaración de la estructura e informará un
	error en tiempo de compilación. Para resolver el problema,
	necesitará saber un poco más acerca del preprocesador.
      </para>
    </sect2>


    <sect2>
      <title>
	Las directivas del preprocesador #define, #ifndef y #endif
      </title>

      <!--
      The preprocessor directive #define can be used to create
      compile-time flags. You have two choices: you can simply tell
      the preprocessor that the flag is defined, without specifying a
      value:
      -->
      
      <para>
	La directiva de preprocesador <keyword>#define</keyword> se
	puede usar para crear banderas en tiempo de compilación. Tiene
	dos opciones: puede simplemente indicar al preprocesador que la
	bandera está definida, sin especificar un valor:
      </para>

<programlisting>
    #define FLAG
</programlisting>

      <!--
      or you can give it a value (which is the typical C way to define
      a constant):
      -->

      <para>
	o puede darle un valor (que es la manera habitual en C para
	definir una constante):
      </para>

<programlisting>
    #define PI 3.14159
</programlisting>

      <!--
      In either case, the label can now be tested by the preprocessor
      to see if it has been defined:
      -->

      <para>
	En cualquier caso, ahora el preprocesador puede comprobar si la
	etiqueta ha sido definida:
      </para>

<programlisting>
    #ifdef FLAG
</programlisting>


      <!--
      This will yield a true result, and the code following the #ifdef
      will be included in the package sent to the compiler. This
      inclusion stops when the preprocessor encounters the statement
      -->

      <para>
	Esto producirá un resultado verdadero, y el código que sigue al
	<keyword>#ifdef</keyword> será incluido en el paquete que se
	envía al compilador. Esta inclusión acaba cuando el
	preprocesador encuentra la sentencia:
      </para>

      <programlisting>
    #endif
      </programlisting>

      <!--
      or
      -->

      <para>
	o
      </para>

      <programlisting>
    #endif // FLAG
      </programlisting>

      <!--
      Any non-comment after the #endif on the same line is illegal,
      even though some compilers may accept it. The #ifdef/#endif
      pairs may be nested within each other.
      -->
      
      <para>
	Cualquier cosa después de <keyword>#endif</keyword>, en la misma
	línea, que no sea un comentario es ilegal, incluso aunque
	algunos compiladores lo acepten. Los pares
	<keyword>#ifdef</keyword>/<keyword>#endif</keyword> se pueden
	anidar.
      </para>

      <!--
      The complement of #define is #undef (short for "un-define"),
      which will make an #ifdef statement using the same variable
      yield a false result. #undef will also cause the preprocessor to
      stop using a macro. The complement of #ifdef is #ifndef, which
      will yield a true if the label has not been defined (this is the
      one we will use in header files).
      -->

      <para>
	El complementario de <keyword>#define</keyword> es
	<keyword>#undef</keyword> (abreviación de
	<quote>un-define</quote> que hará que una sentencia
	<keyword>#ifdef</keyword> que use la misma variable produzca un
	resultado falso. <keyword>#undef</keyword> también causará que
	el preprocesador deje de usar una macro. El complementario de
	<keyword>#ifdef</keyword> es <keyword>#ifndef</keyword>, que
	producirá verdadero si la etiqueta no ha sido definida (éste es
	el que usaremos en los ficheros de cabecera).
      </para>

      <!--
      There are other useful features in the C preprocessor. You
      should check your local documentation for the full set. 
      -->
      
      <para>
	Hay otras características útiles en el preprocesador de
	C. Consulte la documentación de su preprocesador para ver todas
	ellas.
      </para>
    </sect2>


    <sect2>
      <title>Un estándar para los ficheros de cabecera</title>

      <!--
      In each header file that contains a structure, you should first
      check to see if this header has already been included in this
      particular cpp file. You do this by testing a preprocessor
      flag. If the flag isn't set, the file wasn't included and you
      should set the flag (so the structure can't get re-declared) and
      declare the structure. If the flag was set then that type has
      already been declared so you should just ignore the code that
      declares it. Here's how the header file should look:
      -->

      <para>
	En cada fichero de cabecera que contiene una estructura, primero
	debería comprobar si ese fichero ya ha sido includo en este
	fichero <filename>cpp</filename> particular. Hágalo testeando
	una bandera del preprocesador. Si la bandera no está definida, el
	fichero no fue incluido y se debería definir la bandera (de modo
	que la estructura no pueda ser redeclarada) y declarar la
	estructura. Si la bandera estaba definida entonces el tipo ya
	ha sido declarado de modo que debería ignorar el código que la
	declara. Así es como debería ser un fichero de cabecera:
      </para>

      <programlisting>
    #ifndef HEADER_FLAG
    #define HEADER_FLAG
    // Type declaration here...
    #endif // HEADER_FLAG
      </programlisting>

    <!--
      As you can see, the first time the header file is included, the
      contents of the header file (including your type declaration) will
      be included by the preprocessor. All the subsequent times it is
      included - in a single compilation unit - the type declaration
      will be ignored. The name HEADER_FLAG can be any unique name, but
      a reliable standard to follow is to capitalize the name of the
      header file and replace periods with underscores (leading
      underscores, however, are reserved for system names). Here's an
      example:
    -->

      <para>
	Como puede ver, la primera vez que se incluye el fichero de
	cabecera, los contenidos del fichero (incluyendo la declaración
	del tipo) son incluidos por el preprocesador. Las demás veces
	que sea includio -en una única unidad de programación- la
	declaración del tipo será ignorada. El nombre HEADER_FLAG puede
	ser cualquier nombre único, pero un estándar fiable a seguir es
	poner el nombre del fichero de cabecera en mayúsculas y
	reemplazar los puntos por guiones bajos (sin embago, el guión
	bajo al comienzo está reservado para nombres del sistema). Este
	es un ejemplo:
      </para>

<programlisting>
<xi:include parse="text" href="./code/C04/Simple.h"/>
</programlisting>


      <!--
      Although the SIMPLE_H after the #endif is commented out and thus
      ignored by the preprocessor, it is useful for documentation.
      -->

      <para>
	Aunque el <varname>SIMPLE_H</varname> después de
	<keyword>#endif</keyword> está comentado y es ignorado por el
	preprocesador, es útil para documentación.
      </para>

      <!--
      These preprocessor statements that prevent multiple inclusion are
      often referred to as include guards
      -->
      
      <para>
	Estas sentencias del preprocesador que impiden inclusiones
	múltiples se denominan a menudo <emphasis>guardias de
	inclusión</emphasis> (<emphasis>include guards</emphasis>)
      </para>
    </sect2>
    

    <sect2>
      <title>Espacios de nombres en los ficheros de cabecera</title>

      <!--
      You'll notice that using directives are present in nearly all the
      cpp files in this book, usually in the form:
      -->

      <para>
	Notará que las <emphasis>directivas using</emphasis> están
	presente en casi todos los ficheros <filename>cpp</filename> de
	esto libro, normalmente en la forma:
      </para>

      <programlisting>
    using namespace std;
      </programlisting>

      <!--
      Since std is the namespace that surrounds the entire Standard C++
      library, this particular using directive allows the names in the
      Standard C++ library to be used without qualification. However,
      you'll virtually never see a using directive in a header file (at
      least, not outside of a scope). The reason is that the using
      directive eliminates the protection of that particular namespace,
      and the effect lasts until the end of the current compilation
      unit. If you put a using directive (outside of a scope) in a
      header file, it means that this loss of "namespace protection"
      will occur with any file that includes this header, which often
      means other header files. Thus, if you start putting using
      directives in header files, it's very easy to end up "turning
      off" namespaces practically everywhere, and thereby neutralizing
      the beneficial effects of namespaces.
      -->

      <para>
	Como <classname role="namespace">std</classname> es el espacio
	de nombres que encierra la librería Estándar C++ al completo,
	está directiva using en particular permite que se puedan usar
	los nombres de la librería Estándar C++. Sin embargo, casí nunca
	verá una directiva using en un fichero de cabecera (al menos, no
	fuera de un bloque). La razón es uqe la directiva using elmina
	la protección de ese espacio de nombres en particular, y el
	efecto dura hasta que termina la unidad de compilación
	actual. Si pone una directiva using (fuera de un bloque) e un
	fichero de cabecera, significa que esta perdida de
	<quote>protección del espacio de nombres</quote> ocurrirá con
	cualquier fichero que incluya este fichero de cabecera, lo que a
	menudo significa otros ficheros de cabecera, es muy fácil acabar
	<quote>desactivando</quote> los espacios de nombres en todos
	sitios, y por tanto, neutralizando los efectos beneficiosos de
	los espacios de nombres.
      </para>

      <!--
      In short: don't put using directives in header files.
      -->

      <para>
	En resumen: no ponga directivas using en ficheros de cabecera.
      </para>

    </sect2>


    <sect2>
      <title>Uso de los ficheros de cabecera en proyectos</title>

      <!--
      When building a project in C++, you'll usually create it by
      bringing together a lot of different types (data structures with
      associated functions). You'll usually put the declaration for
      each type or group of associated types in a separate header file,
      then define the functions for that type in a translation
      unit. When you use that type, you must include the header file to
      perform the declarations properly.
      -->

      <para>
	Cuando se construye un proyecto en C++, normalmente lo creará
	poniendo juntos un montón de tipos diferentes (estructuras de
	datos con funciones asociadas). Normalmente pondrá la
	declaración para cada tipo o grupo de tipos asociados en un
	fichero de cabecera separado, entonces definirá las funciones
	para ese tipo en una unidad de traducción. Cuando use ese tipo,
	deberá incluir el fichero de cabecera para efectuar las
	declaraciones apropiadamente.
      </para>


      <!--
      Sometimes that pattern will be followed in this book, but more
      often the examples will be very small, so everything - the
      structure declarations, function definitions, and the main( )
      function - may appear in a single file. However, keep in mind that
      you'll want to use separate files and header files in practice.
      -->

      <para>
	A veces ese patrón se seguirá en este libro, pero más a menudo
	los ejemplos serán muy pequeños, así que todo - la declaracione
	de las estructuras, la definición de las funciones, y la función
	<function>main()</function> - puede aparecer en un único
	fichero. Sin embargo, tenga presente que debería usar ficheros
	separados y ficheros de cabecera para aplicaciones reales.
      </para>

    </sect2>
  </sect1>


  <sect1>
    <title>Estructuras anidadas</title>

    <!--
    The convenience of taking data and function names out of the global
    name space extends to structures. You can nest a structure within
    another structure, and therefore keep associated elements
    together. The declaration syntax is what you would expect, as you
    can see in the following structure, which implements a push-down
    stack as a simple linked list so it "never" runs out of memory:
    -->

    <para>
      La conveniencia de coger nombres de funciones y datos fuera del
      espacio de nombre global es aplicable a las estructuras. Puede
      anidar una estructura dentro de otra estructura, y por tanto
      guardar juntos elementos asociados. La sintaxis de declaración es
      la que podría esperarse, tal como puede ver en la siguiente
      estructura, que implemente una pila como un lista enlazada simple
      de modo que <quote>nunca</quote> se queda sin memoria.
    </para>


<programlisting>
<xi:include parse="text" href="./code/C04/Stack.h"/>
</programlisting>


    <!--
    The nested struct is called Link, and it contains a pointer to the
    next Link in the list and a pointer to the data stored in the
    Link. If the next pointer is zero, it means you're at the end of
    the list.
    -->

    <para>
      La <keyword>struck</keyword> anidada se llama
      <type>Link</type>, y contiene un puntero al siguiente
      <type>Link</type> en la lista y un puntero al dato almacenado en
      el <type>Link</type>. Si el siguiente puntero es cero, significa
      que es el último elemento de la lista.
    </para>

    <!--
    Notice that the head pointer is defined right after the declaration
    for struct Link, instead of a separate definition Link* head. This
    is a syntax that came from C, but it emphasizes the importance of
    the semicolon after the structure declaration; the semicolon
    indicates the end of the comma-separated list of definitions of that
    structure type. (Usually the list is empty.)
    -->


    <!--
    The nested structure has its own initialize( ) function, like all
    the structures presented so far, to ensure proper
    initialization. Stack has both an initialize( ) and cleanup( )
    function, as well as push( ), which takes a pointer to the data you
    wish to store (it assumes this has been allocated on the heap), and
    pop( ), which returns the data pointer from the top of the Stack and
    removes the top element. (When you pop( ) an element, you are
    responsible for destroying the object pointed to by the data.) The
    peek( ) function also returns the data pointer from the top element,
    but it leaves the top element on the Stack.
    -->


    <!--
    Here are the definitions for the member functions:
    -->


<programlisting>
<xi:include parse="text" href="./code/C04/Stack.cpp"/>
</programlisting>


    <!--
    The first definition is particularly interesting because it shows
    you how to define a member of a nested structure. You simply use an
    additional level of scope resolution to specify the name of the
    enclosing struct. Stack::Link::initialize( ) takes the arguments and
    assigns them to its members.
    -->


    <!-- 
    Stack::initialize( ) sets head to zero, so the object knows it
    has an empty list. 
    -->


    <!--
    Stack::push( ) takes the argument, which is a pointer to the
    variable you want to keep track of, and pushes it on the
    Stack. First, it uses new to allocate storage for the Link it will
    insert at the top. Then it calls Link's initialize( ) function to
    assign the appropriate values to the members of the Link. Notice
    that the next pointer is assigned to the current head; then head is
    assigned to the new Link pointer. This effectively pushes the Link
    in at the top of the list.
    -->


    <!--
    Stack::pop( ) captures the data pointer at the current top of the
    Stack; then it moves the head pointer down and deletes the old top
    of the Stack, finally returning the captured pointer. When pop( )
    removes the last element, then head again becomes zero, meaning the
    Stack is empty.
    -->


    <!--
    Stack::cleanup( ) doesn't actually do any cleanup. Instead, it
    establishes a firm policy that "you (the client programmer using
    this Stack object) are responsible for popping all the elements off
    this Stack and deleting them." The require( ) is used to indicate
    that a programming error has occurred if the Stack is not empty.
    -->

    <!--
    Why couldn't the Stack destructor be responsible for all the
    objects that the client programmer didn't pop( )? The problem is
    that the Stack is holding void pointers, and you'll learn in
    Chapter 13 that calling delete for a void* doesn't clean things up
    properly. The subject of "who's responsible for the memory" is
    not even that simple, as we'll see in later chapters.
    -->

    <!--
    Here's an example to test the Stack:
    -->

<programlisting>
<xi:include parse="text" href="./code/C04/StackTest.cpp"/>
</programlisting>


    <!--
    This is similar to the earlier example, but it pushes lines from a
    file (as string pointers) on the Stack and then pops them off, which
    results in the file being printed out in reverse order. Note that
    the pop( ) member function returns a void* and this must be cast
    back to a string* before it can be used. To print the string, the
    pointer is dereferenced.
    -->


    <!--
    As textlines is being filled, the contents of line is "cloned" for
    each push( ) by making a new string(line). The value returned from
    the new-expression is a pointer to the new string that was created
    and that copied the information from line. If you had simply passed
    the address of line to push( ), you would end up with a Stack filled
    with identical addresses, all pointing to line. You'll learn more
    about this "cloning" process later in the book.
    -->


    <!--
    The file name is taken from the command line. To guarantee that
    there are enough arguments on the command line, you see a second
    function used from the require.h header file: requireArgs( ), which
    compares argc to the desired number of arguments and prints an
    appropriate error message and exits the program if there aren't
    enough arguments.
    -->

    <sect2>
      <title>Resolución de ámbito global</title>

    <!--
      The scope resolution operator gets you out of situations in which
      the name the compiler chooses by default (the "nearest" name)
      isn't what you want. For example, suppose you have a structure
      with a local identifier a, and you want to select a global
      identifier a from inside a member function. The compiler would
      default to choosing the local one, so you must tell it to do
      otherwise. When you want to specify a global name using scope
      resolution, you use the operator with nothing in front of it. Here'
      s an example that shows global scope resolution for both a
      variable and a function:
    -->

<programlisting>
<xi:include parse="text" href="./code/C04/Scoperes.cpp"/>
</programlisting>

    <!--
      Without scope resolution in S::f( ), the compiler would default to
      selecting the member versions of f( ) and a
    -->
      <para>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>

    <!--
    In this chapter, you've learned the fundamental "twist" of C++:
    that you can place functions inside of structures. This new type of
    structure is called an abstract data type, and variables you create
    using this structure are called objects, or instances, of that
    type. Calling a member function for an object is called sending a
    message to that object. The primary action in object-oriented
    programming is sending messages to objects.
    -->

    <!--
    Although packaging data and functions together is a significant
    benefit for code organization and makes library use easier because
    it prevents name clashes by hiding the names, there's a lot more
    you can do to make programming safer in C++. In the next chapter,
    you'll learn how to protect some members of a struct so that only
    you can manipulate them. This establishes a clear boundary between
    what the user of the structure can change and what only the
    programmer may change.
    -->

    <para>
    </para>
  </sect1>


  <sect1>
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>




   1. In the Standard C library, the function puts( ) prints a char array to the console (so you can say puts("hello")). Write a C program that uses puts( ) but does not include &lt;stdio.h> or otherwise declare the function. Compile this program with your C compiler. (Some C++ compilers are not distinct from their C compilers; in this case you may need to discover a command-line flag that forces a C compilation.) Now compile it with the C++ compiler and note the difference.
   2. Create a struct declaration with a single member function, then create a definition for that member function. Create an object of your new data type, and call the member function.
   3. Change your solution to Exercise 2 so the struct is declared in a properly "guarded" header file, with the definition in one cpp file and your main( ) in another.
   4. Create a struct with a single int data member, and two global functions, each of which takes a pointer to that struct. The first function has a second int argument and sets the struct's int to the argument value, the second displays the int from the struct. Test the functions.
   5. Repeat Exercise 4 but move the functions so they are member functions of the struct, and test again.
   6. Create a class that (redundantly) performs data member selection and a member function call using the this keyword (which refers to the address of the current object).
   7. Make a Stash that holds doubles. Fill it with 25 double values, then print them out to the console.
   8. Repeat Exercise 7 with Stack.
   9. Create a file containing a function f( ) that takes an int argument and prints it to the console using the printf( ) function in &lt;stdio.h> by saying: printf("%d\n", i) in which i is the int you wish to print. Create a separate file containing main( ), and in this file declare f( ) to take a float argument. Call f( ) from inside main( ). Try to compile and link your program with the C++ compiler and see what happens. Now compile and link the program using the C compiler, and see what happens when it runs. Explain the behavior.
  10. Find out how to produce assembly language from your C and C++ compilers. Write a function in C and a struct with a single member function in C++. Produce assembly language from each and find the function names that are produced by your C function and your C++ member function, so you can see what sort of name decoration occurs inside the compiler.
  11. Write a program with conditionally-compiled code in main( ), so that when a preprocessor value is defined one message is printed, but when it is not defined another message is printed. Compile this code experimenting with a #define within the program, then discover the way your compiler takes preprocessor definitions on the command line and experiment with that.
  12. Write a program that uses assert( ) with an argument that is always false (zero) to see what happens when you run it. Now compile it with #define NDEBUG and run it again to see the difference.
  13. Create an abstract data type that represents a videotape in a video rental store. Try to consider all the data and operations that may be necessary for the Video type to work well within the video rental management system. Include a print( ) member function that displays information about the Video.
  14. Create a Stack object to hold the Video objects from Exercise 13. Create several Video objects, store them in the Stack, then display them using Video::print( ).
  15. Write a program that prints out all the sizes for the fundamental data types on your computer using sizeof.
  16. Modify Stash to use a vector&lt;char> as its underlying data structure.
  17. Dynamically create pieces of storage of the following types, using new: int, long, an array of 100 chars, an array of 100 floats. Print the addresses of these and then free the storage using delete.
  18. Write a function that takes a char* argument. Using new, dynamically allocate an array of char that is the size of the char array that's passed to the function. Using array indexing, copy the characters from the argument to the dynamically allocated array (don't forget the null terminator) and return the pointer to the copy. In your main( ), test the function by passing a static quoted character array, then take the result of that and pass it back into the function. Print both strings and both pointers so you can see they are different storage. Using delete, clean up all the dynamic storage.
  19. Show an example of a structure declared within another structure (a nested structure). Declare data members in both structs, and declare and define member functions in both structs. Write a main( ) that tests your new types.
  20. How big is a structure? Write a piece of code that prints the size of various structures. Create structures that have data members only and ones that have data members and function members. Then create a structure that has no members at all. Print out the sizes of all these. Explain the reason for the result of the structure with no data members at all.
  21. C++ automatically creates the equivalent of a typedef for structs, as you've seen in this chapter. It also does this for enumerations and unions. Write a small program that demonstrates this.
  22. Create a Stack that holds Stashes. Each Stash will hold five lines from an input file. Create the Stashes using new. Read a file into your Stack, then reprint it in its original form by extracting it from the Stack.
  23. Modify Exercise 22 so that you create a struct that encapsulates the Stack of Stashes. The user should only add and get lines via member functions, but under the covers the struct happens to use a Stack of Stashes.
  24. Create a struct that holds an int and a pointer to another instance of the same struct. Write a function that takes the address of one of these structs and an int indicating the length of the list you want created. This function will make a whole chain of these structs (a linked list), starting from the argument (the head of the list), with each one pointing to the next. Make the new structs using new, and put the count (which object number this is) in the int. In the last struct in the list, put a zero value in the pointer to indicate that it's the end. Write a second function that takes the head of your list and moves through to the end, printing out both the pointer value and the int value for each one.
  25. Repeat Exercise 24, but put the functions inside a struct instead of using "raw" structs and functions.


    <para>
    </para>
  </sect1>
</chapter>




