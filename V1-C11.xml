<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Javier Corrales García
  Formateado DocBook:  Javier Corrales García
  1ª Revisión:         David Villa (Informe al final del texto)
  2ª Revisión:
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C11">

  <title>Las referencias y el constructor de copia</title>

  <highlights>
  <!--
  References are like constant pointers that are automatically
  dereferenced by the compiler.
  -->
    <para>
      Las referencias son como punteros constantes que el compilador utiliza
      para acceder directamente a su contenido.
    </para>
  </highlights>

  <!--
  Although references also exist in Pascal, the C++ version was taken
  from the Algol language. They are essential in C++ to support the
  syntax of operator overloading (see Chapter 12), but they are also a
  general convenience to control the way arguments are passed into and
  out of functions.
  -->
  <para>
    Aunque las referencias también existen en Pascal, la versión de C++ se
    copió del lenguaje Algol. Las referencias son esenciales en C++ para
    ayudar en la sintaxis de los operadores sobrecargados (vea Capítulo 12)
    y, además, son una buena forma para controlar la manera en que los
    argumentos se pasan a las funciones tanto hacia dentro como hacia fuera.
  </para>

  <!--
  This chapter will first look briefly at the differences between
  pointers in C and C++, then introduce references. But the bulk of the
  chapter will delve into a rather confusing issue for the new C++
  programmer: the copy-constructor, a special constructor (requiring
  references) that makes a new object from an existing object of the
  same type. The copy-constructor is used by the compiler to pass and
  return objects by value into and out of functions.
  -->
  <para>
    En este capítulo se verá primero la diferencia entre los punteros en C
    y en C++., y luego se presentarán las referencias. Pero la mayor parte
    del capítulo ahondará en el asunto un tanto confuso para los programadores
    de C++ novatos: el constructor copia, un constructor especial (que necesita
    referencias) que construye un nuevo objeto de otro ya existente del
    mismo tipo. El compilador utiliza el constructor copia para pasar y
    retornar objetos <emphasis>por valor</emphasis> a las funciones.
  </para>

  <!-- Finally, the somewhat obscure C++ pointer-to-member feature is illuminated. -->
  <para>
    Finalmente, se hablará sobre la característica (un tanto oscura) de
    los <emphasis>punteros a miembro</emphasis> de C++.
  </para>


  <sect1>
    <!-- : Pointers in C++ -->
    <title>Punteros en C++</title>

    <!--
    The most important difference between pointers in C and those in C++
    is that C++ is a more strongly typed language. This stands out where
    void* is concerned. C doesn't let you casually assign a pointer of one
    type to another, but it does allow you to accomplish this through a
    void*. Thus,
    -->
    <para>
      La diferencia más importante entre los punteros en C y en C++ es
      que los de C++ están fuertemente tipados. Sobre todo en lo que
      al tipo <emphasis>void *</emphasis> se refiere. C no permite
      asignar un puntero de un tipo a otro de forma casual, pero
      <emphasis>sí</emphasis> permite hacerlo mediante el tipo
      <emphasis>void *</emphasis>. Por ejemplo,
    </para>

<programlisting>
Bird* b;
Rock* r;
void* v;
v = r;
b = v;
</programlisting>

    <!--
    Because this "feature" of C allows you to quietly treat any type like
    any other type, it leaves a big hole in the type system. C++ doesn't
    allow this; the compiler gives you an error message, and if you really
    want to treat one type as another, you must make it explicit, both to
    the compiler and to the reader, using a cast. (Chapter 3 introduced
    C++'s improved "explicit" casting syntax.)
    -->
    <para>
      A causa de esta "característica" de C, puede utilizar cualquier
      tipo como si de otro se tratara sin ningún aviso por parte del
      compilador. C++ no permite hacer esto; el compilador da un mensaje
      de error, y si realmente quiere utilizar un tipo como otro
      diferente, debe hacerlo explícitamente, tanto para el compilador
      como para el lector, haciendo molde (denominado
      <emphasis>cast</emphasis> en inglés). (En el capítulo 3 se habló
      sobre la sintaxis mejorada del molde "explícito".)
    </para>
  </sect1>

  <sect1>    <!-- : References in C++ -->
    <title>Referencias en C++</title>

    <!--
    A reference (&) is like a constant pointer that is automatically
    dereferenced. It is usually used for function argument lists and
    function return values. But you can also make a free-standing
    reference. For example,
    -->
    <para>
      Una <emphasis>referencia</emphasis> (<emphasis>&amp;</emphasis>)
      es como un puntero constante que se destruye
      automáticamente. Normalmente se utiliza en la lista de argumentos
      y en el valor de retorno de una función. Pero también se puede hacer
      una referencia que apunte a algo que no ha sido asignado. Por
      ejemplo:
    </para>


//: V1C11:FreeStandingReferences.cpp

    <!--
    In line (1), the compiler allocates a piece of storage, initializes it
    with the value 12, and ties the reference to that piece of
    storage. The point is that any reference must be tied to someone
    else's piece of storage. When you access a reference, you're accessing
    that storage. Thus, if you write lines like (2) and (3), then
    incrementing a is actually incrementing x, as is shown in main(
    ). Again, the easiest way to think about a reference is as a fancy
    pointer. One advantage of this "pointer" is that you never have to
    wonder whether it's been initialized (the compiler enforces it) and
    how to dereference it (the compiler does it).
    -->
    <para>
      En la linea (1) el compilador asigna la cantidad necesaria de
      memoria, la inicializa con el valor 12, y liga la referencia a esa
      memoria. Lo importante es que una referencia debe estar ligada a
      la memoria de <emphasis>alguien</emphasis>. Cuando se accede a una
      referencia, se está accediendo a esa memoria. Así pues, si escribe
      las lineas (2) y (3) incrementará <emphasis>x</emphasis>
      cuando se incremente <emphasis>a</emphasis>, tal como se muestra
      en el <emphasis>main()</emphasis>. Lo más fácil es pensar que una
      referencia es como un puntero de lujo. La ventaja de este
      "puntero" es que nunca hay que preguntarse si ha sido inicializado
      (pues el compilador lo impone) o si hay que destruirlo (pues el
      compilador lo hace).
    </para>

   <!-- There are certain rules when using references: -->
    <para>
      Hay que seguir unas determinadas reglas cuando se utilizan
      referencias:
      <orderedlist>
	<listitem>    <!--
    1. A reference must be initialized when it is created. (Pointers
    can be initialized at any time.)
    -->
	  <para>
	    Cuando se crea una referencia, se ha de inicializar. (Los
	    punteros pueden inicializarse en cualquier momento.)
	  </para>
	</listitem>
	<listitem>    <!--
    2. Once a reference is initialized to an object, it cannot be
    changed to refer to another object. (Pointers can be pointed to
    another object at any time.)
    -->
	  <para>
	    Una vez que se inicializa una referencia, ligándola a un
	    objeto, no se puede ligar a otro objeto. (Los punteros
	    pueden apuntar a otro objeto en cualquier momento.)
	  </para>
	</listitem>
	<listitem>    <!--
    3. You cannot have NULL references. You must always be able to
    assume that a reference is connected to a legitimate piece of
    storage.
    -->
	  <para>
	    No se pueden tener referencias con valor
	    nulo. Siempre ha de suponer que una referencia está conectada
	    a una trozo de memoria ya asignada.
	  </para>
	</listitem>
      </orderedlist>
    </para>

    <sect2>      <!-- : References in functions -->
      <title>Referencias en las funciones</title>

      <!--
      The most common place you'll see references is as function arguments
      and return values. When a reference is used as a function argument,
      any modification to the reference inside the function will cause
      changes to the argument outside the function. Of course, you could do
      the same thing by passing a pointer, but a reference has much cleaner
      syntax. (You can think of a reference as nothing more than a syntax
      convenience, if you want.)
      -->
      <para>
	El lugar más común en el que verá referencias es en los
	argumentos y valor de retorno de las funciones. Cuando se
	utiliza una referencia como un argumento de una función,
	cualquier cambio realizado en la
	referencia <emphasis>dentro</emphasis> de la función se
	realizará realmente sobre en el argumento
	<emphasis>fuera</emphasis> de la función.  Por supuesto que
	podría hacer lo mismo pasando un puntero como argumento, pero
	una referencia es sintácticamente más clara.  (Si lo desea,
	puede pensar que una referencia es, nada más y nada menos,
	sintácticamente más conveniente.)
      </para>
      <!--
      If you return a reference from a function, you must take the same care
      as if you return a pointer from a function. Whatever the reference is
      connected to shouldn't go away when the function returns, otherwise
      you'll be referring to unknown memory.
      -->
      <para>
	Si una función retorna una referencia, ha de tener el mismo
	cuidado que si la función retornara un puntero. La referencia
	que se devuelva debe estar ligada a algo que no sea liberado
	cuando la función retorne. Si no, la referencia se referirá a un
	trozo de memoria sobre el que ya no tiene control.
      </para>

      <!-- Here's an example: -->
      <para>
	He aquí un ejemplo:
      </para>


//: V1C11:Reference.cpp

      <!--
      The call to f() doesn't have the convenience and cleanliness of using
      references, but it's clear that an address is being passed. In the
      call to g(), an address is being passed (via a reference), but you
      don't see it.
      -->
      <para>
	La llamada a <function>f()</function> no tiene la ventaja ni la
	claridad que la utilización de referencias, pero está claro que
	se está pasando una dirección mediante un puntero. En la llamada
	a <function>g()</function>, también se pasa una dirección
	(mediante una referencia), pero no se ve.
      </para>
      <sect3>        <!-- : const references -->
	<title>Referencias constantes</title>        <!--
        The reference argument in Reference.cpp works only when the argument
        is a non-const object. If it is a const object, the function g() will
        not accept the argument, which is actually a good thing, because the
        function does modify the outside argument. If you know the function
        will respect the constness of an object, making the argument a const
        reference will allow the function to be used in all situations. This
        means that, for built-in types, the function will not modify the
        argument, and for user-defined types, the function will call only
        const member functions, and won't modify any public data members.
        -->
	<para>
	  El argumento referencia en <filename>Reference.cpp</filename>
	  funciona solamente en caso de que el argumento no sea un
	  objeto constante (es decir, no sea
	  <emphasis>const</emphasis>).  Si fuera un objeto
	  <emphasis>constante</emphasis>, la función
	  <emphasis>g()</emphasis> no aceptaría el argumento, lo cual es
	  positivo porque la función <emphasis>modificaría</emphasis> el
	  argumento que está <emphasis>fuera</emphasis> del ámbito de la
	  función. Si sabe que la función respetará el valor "constante"
	  de un objeto, el hecho de que el argumento sea una referencia
	  constante permitirá que la función se pueda utilizar en
	  cualquier situación. Esto significa que para tipos
	  predefinidos, la función no modificará el argumento, y para
	  tipos definidos por el usuario, la función llamará solamente a
	  métodos <emphasis>constantes</emphasis>, y no modificara
	  ningún atributo <emphasis>público</emphasis>.
	</para>
        <!--
        The use of const references in function arguments is especially
        important because your function may receive a temporary object. This
        might have been created as a return value of another function or
        explicitly by the user of your function. Temporary objects are always
        const, so if you don't use a const reference, that argument won't be
        accepted by the compiler. As a very simple example,
        -->
	<para>
	  La utilización de referencias <emphasis>constantes</emphasis>
	  en argumentos de funciones es especialmente importante porque
	  una función puede recibir un objeto temporal. Éste podría
	  haber sido creado como valor de retorno de otra función o
	  explícitamente por el usuario de la función. Los objetos
	  temporales son siempre <emphasis>constantes</emphasis>.  Así,
	  si no utiliza una referencia <emphasis>constante</emphasis>,
	  el compilador se quejará. Como ejemplo muy simple:
	</para>


//: V1C11:ConstReferenceArguments.cpp

        <!--
        The call to f(1) causes a compile-time error because the compiler must
        first create a reference. It does so by allocating storage for an int,
        initializing it to one and producing the address to bind to the
        reference. The storage must be a const because changing it would make
        no sense - you can never get your hands on it again. With all
        temporary objects you must make the same assumption: that they're
        inaccessible. It's valuable for the compiler to tell you when you're
        changing such data because the result would be lost information.
        -->
	<para>
	  La llamada <emphasis>f(1)</emphasis> provoca un error en
	  tiempo de compilación porque el compilador debe primero crear
	  una referencia. Lo hace asignando memoria para un
	  <emphasis>int</emphasis>, iniciánlizándolo a uno y generando
	  la dirección de memoria para ligarla a la referencia. La
	  memoria debe ser <emphasis>constante</emphasis> porque no
	  tendría sentido cambiarlo: no puede cambiarse de nuevo. Puede
	  hacer la misma suposición para todos los objetos temporales:
	  son FIXME:inaccesibles. Es importante que el compilador le diga
	  cuándo está intentando cambiar algo de este estilo porque
	  podría perder información.
	</para>

      </sect3>
      <sect3>        <!-- : Pointer references -->
	<title>Referencias a puntero</title>        <!--
        In C, if you want to modify the contents of the pointer rather than
        what it points to, your function declaration looks like:
        -->
	<para>
	  En C, si desea modificar el <emphasis>contenido</emphasis> del
	  puntero en sí en vez de modificar a lo que apunta, la
	  declaración de la función sería:
	</para>
<programlisting>
void f(int**);
</programlisting>
	<para>        <!-- and you'd have to take the address of the pointer when passing it in: -->
	  y tendría que coger la dirección del puntero cuando se llamara
	  a la función:
	</para>
<programlisting>
int i = 47;
int* ip = &amp;i;
f(&amp;ip);
</programlisting>        <!--
        With references in C++, the syntax is cleaner. The function argument
        becomes a reference to a pointer, and you no longer have to take the
        address of that pointer. Thus,
        -->
	<para>
	  La sintaxis es más clara con las referencias en C++. El
	  argumento de la función pasa a ser de una referencia a un
	  puntero, y así no ha de manejar la dirección del puntero.
	  Así,
	</para>


//: V1C11:ReferenceToPointer.cpp

        <!--
        By running this program, you'll prove to yourself that the pointer is
        incremented, not what it points to.
        -->
	<para>
	  Al ejecutar este programa se observa que el puntero se
	  incrementa en vez de incrementar a lo que apunta.
	</para>
      </sect3>
    </sect2>
    <sect2>      <!-- : Argument-passing guidelines -->
      <title>Consejos para el paso de argumentos</title>      <!--
      Your normal habit when passing an argument to a function should be to
      pass by const reference. Although at first this may seem like only an
      efficiency concern (and you normally don't want to concern yourself
      with efficiency tuning while you're designing and assembling your
      program), there's more at stake: as you'll see in the remainder of the
      chapter, a copy-constructor is required to pass an object by value,
      and this isn't always available.
      -->
      <para>
	Cuando se pasa un argumento a un función, lo normal debería ser
	pasarlo como una referencia <emphasis>constante</emphasis>. A
	Aunque al principio puede parecer que sólo tiene ventajas en
	términos de eficacia (y normalmente en diseño e implementación
	inicial no se tiene muy en cuenta la eficacia), además tiene
	otras: como se podrá ver en el resto del capítulo, se requiere
	un constructor copia para pasar un objeto por valor, y esto no
	siempre es posible.
      </para>      <!--
      The efficiency savings can be substantial for such a simple habit: to
      pass an argument by value requires a constructor and destructor call,
      but if you're not going to modify the argument then passing by const
      reference only needs an address pushed on the stack.
      -->
      <para>
	La eficacia puede mejorar substancialmente por este simple
	hábito: pasar un argumento por valor necesita una llamada a un
	constructor y otra a un destructor, pero si no se va a modificar
	el argumento, el hecho de pasarlo como una referencia
	<emphasis>constante</emphasis> sólo necesita poner una dirección
	en la pila.
      </para>      <!--
      In fact, virtually the only time passing an address isn't preferable
      is when you're going to do such damage to an object that passing by
      value is the only safe approach (rather than modifying the outside
      object, something the caller doesn't usually expect). This is the
      subject of the next section.
      -->
      <para>
	De hecho, prácticamente la única situación en la que no es
	preferible pasar la dirección, es cuando se le va a producir al
	objeto tal daño que la única forma segura de que no ocurra es
	pasándolo por valor (en vez de modificar el objeto que está
	fuera del ámbito de la función, algo que el que llama a la
	función normalmente no espera). Esto es el asunto de la
	siguiente sección.
      </para>
    </sect2>
  </sect1>

  <sect1>    <!-- : The copy-constructor -->
    <title>El constructor de copia</title>    <!--
    Now that you understand the basics of the reference in C++, you're
    ready to tackle one of the more confusing concepts in the language:
    the copy-constructor, often called X(X&) ("X of X ref"). This
    constructor is essential to control passing and returning of
    user-defined types by value during function calls. It's so important,
    in fact, that the compiler will automatically synthesize a
    copy-constructor if you don't provide one yourself, as you will see.
    -->
    <para>
      Ahora que entiende lo básico de las referencias en C++, está
      preparado para tratar uno de los conceptos más confusos del
      lenguaje: el constructor de copia, a menudo denominado
      <emphasis>X(X&amp;)</emphasis> ("X de la referencia X"). Este
      constructor es esencial para controlar el paso y retorno por valor
      de los tipos definidos por el usuario durante las llamadas a
      funciones. De hecho es tan importante que el compilador crea
      automáticamente un constructor de copia en caso de que no se
      proporcione explícitamente.
    </para>
    <sect2>
      <!-- : Passing & returning by value -->
      <title>Paso y retorno por valor</title>      <!--
      To understand the need for the copy-constructor, consider the way C
      handles passing and returning variables by value during function
      calls. If you declare a function and make a function call,
      -->
      <para>
	Para entender la necesidad del constructor copia, considere la
	forma en que C maneja el paso y retorno por valor de variables
	cuando se llama a una función. Si declara una función y la
	llama,
      </para>

<programlisting>
int f(int x, char c);
int g = f(a, b);
</programlisting>
      <!--
      how does the compiler know how to pass and return those variables? It
      just knows! The range of the types it must deal with is so small -
      char, int, float, double, and their variations - that this information
      is built into the compiler.
      -->
      <para>
	¿cómo sabe el compilador cómo pasar y retornar esas variables?
	¡Simplemente lo sabe! El rango de tipo con los que trata es tan
	pequeño (<emphasis>char</emphasis>,<emphasis>int</emphasis>,
	<emphasis>float</emphasis>, <emphasis>double</emphasis>, y sus
	variaciones), que tal información ya está dentro del compilador.
      </para>      <!--
      If you figure out how to generate assembly code with your compiler and
      determine the statements generated by the function call to f(),
      you'll get the equivalent of:
      -->
      <para>
	Si el compilador generara código ensamblador y quisiera ver qué
	sentencias se generan por llamar a la función
	<emphasis>f()</emphasis>, tendría el equivalente a:
      </para>
<programlisting>
push  b
push  a
call  f()
add  sp,4
mov  g, register a
</programlisting>      <!--
      This code has been cleaned up significantly to make it generic; the
      expressions for b and a will be different depending on whether the
      variables are global (in which case they will be _b and _a) or local
      (the compiler will index them off the stack pointer). This is also
      true for the expression for g. The appearance of the call to f() will
      depend on your name-decoration scheme, and "register a" depends on how
      the CPU registers are named within your assembler. The logic behind
      the code, however, will remain the same.
      -->
      <para>
	Este código se ha simplificado para hacerlo genérico; las
        expresiones <emphasis>b</emphasis> y <emphasis>a</emphasis>
        serían diferentes dependiendo de si las variables son globales
        (en cuyo caso serían <emphasis>_b</emphasis> y
        <emphasis>_a</emphasis>) o locales (el compilador las pondría en
        la pila). Esto también es cierto para <emphasis>g</emphasis>. La
        sintaxis de la llamada a <emphasis>f()</emphasis> dependería de
        su guía de estilo, y "register a" dependería de cómo su
        ensamblador llama a los registros de la CPU. A pesar de la
        simplificación, la lógica del código sería la misma.
      </para>      <!--
      In C and C++, arguments are first pushed on the stack from right to
      left, then the function call is made. The calling code is responsible
      for cleaning the arguments off the stack (which accounts for the add
      sp,4). But notice that to pass the arguments by value, the compiler
      simply pushes copies on the stack - it knows how big they are and that
      pushing those arguments makes accurate copies of them.
      -->
      <para>
	Tanto en C como en C++, primero se ponen los argumentos en la
	pila de derecha a izquierda, y luego se llama a la función. El
	código de llamada es responsable de retirar los argumentos de la
	pila (lo cual explica la sentencia <emphasis>add
	sp,4</emphasis>).  Pero tenga en cuenta que cuando se pasan
	argumentos por valor, el compilador simplemente pone copias en
	la pila (sabe el tamaño de cada uno, por lo que los puede
	copiar).
      </para>      <!--
      The return value of f() is placed in a register. Again, the compiler
      knows everything there is to know about the return value type because
      that type is built into the language, so the compiler can return it by
      placing it in a register. With the primitive data types in C, the
      simple act of copying the bits of the value is equivalent to copying
      the object.
      -->
      <para>
	El valor de retorno de <emphasis>f()</emphasis> se coloca en un
	registro. Como el compilador sabe lo que se está retornando,
	porque la información del tipo ya está en el lenguaje, puede
	retornarlo colocándolo en un registro. En C, con tipos
	primitivos, el simple hecho de copiar los bits del valor es
	equivalente a copiar el objeto.
      </para>

      <sect3>        <!-- : Passing & returning large objects -->
	<title>Paso y retorno de objetos grandes</title>        <!--
        But now consider user-defined types. If you create a class and you
        want to pass an object of that class by value, how is the compiler
        supposed to know what to do? This is not a type built into the
        compiler; it's a type you have created.
        -->
	<para>
	  Considere ahora los tipos definidos por el usuario. Si crea
	  una clase y desea pasar un objeto de esa clase por valor,
	  ¿cómo sabe el compilador lo que tiene que hacer?  La
	  información de la clase no está en el compilador, pues está
	  definida por el usuario.
	</para>        <!--
        To investigate this, you can start with a simple structure that is
        clearly too large to return in registers:
        -->
	<para>
	  Para investigar esto, puede empezar con una estructura simple
	  que, claramente, es demasiado grande para ser devuelta a
	  través de los registros:
	</para>


//: V1C11:PassingBigStructures.cpp

        <!--
        Decoding the assembly output is a little more complicated here because
        most compilers use "helper" functions instead of putting all
        functionality inline. In main(), the call to bigfun() starts as you
        might guess - the entire contents of B is pushed on the stack. (Here,
        you might see some compilers load registers with the address of the
        Big and its size, then call a helper function to push the Big onto the
        stack.)
        -->
	<para>
	  La conversión a código ensamblador es un poco más complicada
	  porque la mayoría de los compiladores utilizan funciones
	  "auxiliares" en vez de <emphasis>inline</emphasis>. En la
	  función <emphasis>main()</emphasis>, la llamada a
	  <emphasis>bigfun()</emphasis> empieza como debe: se coloca el
	  contenido de <emphasis>B</emphasis> en la pila. (Aquí podría
	  ocurrir que algunos compiladores carguen registros con la
	  dirección y tamaño de <emphasis>Big</emphasis> y luego una
	  función auxiliar se encargue de colocar a
	  <emphasis>Big</emphasis> en la pila.)
	</para>        <!--
        In the previous code fragment, pushing the arguments onto the stack
        was all that was required before making the function call. In
        PassingBigStructures.cpp, however, you'll see an additional action:
        the address of B2 is pushed before making the call, even though it's
        obviously not an argument. To comprehend what's going on here, you
        need to understand the constraints on the compiler when it's making a
        function call.
        -->
	<para>
	  En el anterior fragmento de código fuente, lo único necesario
	  antes de llamar a la función es colocar los argumentos en la
	  pila. Sin embargo, en el código ensamblador de
	  <emphasis>PassingBigStructures.cpp</emphasis> se ve una acción
	  de más: la dirección de <emphasis>B2</emphasis> se coloca en
	  la pila antes de hacer la llamada a la función aunque,
	  obviamente, no sea un argumento. Para entender qué pasa,
	  necesita entender las restricciones del compilador cuando
	  llama a una función.
	</para>
      </sect3>
      <sect3>        <!-- : Function-call stack frame -->
	<title>Ámbito de la pila para una llamada a una función</title>        <!--
        When the compiler generates code for a function call, it first pushes
        all the arguments on the stack, then makes the call. Inside the
        function, code is generated to move the stack pointer down even
        farther to provide storage for the function's local variables. ("Down"
        is relative here; your machine may increment or decrement the stack
        pointer during a push.) But during the assembly-language CALL, the CPU
        pushes the address in the program code where the function call came
        from, so the assembly-language RETURN can use that address to return
        to the calling point. This address is of course sacred, because
        without it your program will get completely lost. Here's what the
        stack frame looks like after the CALL and the allocation of local
        variable storage in the function:
        -->
	<para>
	  Cuando el compilador genera código para llamar a una función,
	  primero coloca en la pila todos los argumentos y luego hace la
	  llamada. Dentro de la función se genera código para mover el
	  puntero de la pila hacia abajo, y así proporciona memoria para
	  las variables locales dentro de la función.  ("hacia abajo" es
	  relativo, la máquina puede incrementar o disminuir el puntero
	  de pila al colocar un argumento.) Pero cuando se hace el CALL
	  del ensamblador para llamar a la función, la CPU coloca la
	  <emphasis>dirección de procedencia</emphasis> desde donde se
	  realiza la llamada, y en el RETURN del ensamblador se utiliza
	  tal dirección para volver al punto desde donde la llamada se
	  realizó. Esta dirección es intocable, porque sin ella el
	  programa se perdería por completo. He aquí lo que en el ámbito
	  de la pila para la llamada a esa función aparece después de
	  que se ejecute un CALL y se pongan las variables locales de la
	  función:
	</para>


	<figure>
	  <title>Llamada a una función</title>
	  <mediaobject>
	    <imageobject role="latex">
	      <imagedata fileref="./images/V1_14.pdf" align="center" format="PDF"/>
	    </imageobject>
	    <imageobject role="html">
	      <imagedata fileref="./images/V1_14.png" align="center" format="PNG"/>
	    </imageobject>
	  </mediaobject>
	</figure>

        <!--
        The code generated for the rest of the function expects the memory to
        be laid out exactly this way, so that it can carefully pick from the
        function arguments and local variables without touching the return
        address. I shall call this block of memory, which is everything used
        by a function in the process of the function call, the function frame.
        -->
	<para>
	  El código generado por el resto de la función espera que la
	  memoria tenga esta disposición para que pueda utilizar los
	  argumentos y las variables locales sin tocar la dirección al
	  punto de retorno. Llámese a este bloque de memoria, que es
	  todo lo que una función necesita cuando se le llama,
	  <emphasis>ámbito de la función</emphasis>.
	</para>        <!--
        You might think it reasonable to try to return values on the
        stack. The compiler could simply push it, and the function could
        return an offset to indicate how far down in the stack the return
        value begins.
        -->
	<para>
	  Podría creer que es razonable intentar el retorno de valores
	  mediante la utilización de la pila. El compilador simplemente
	  los colocaría allí y la función devolvería un desplazamiento
	  que indicara cuándo empieza el valor de retorno.
	</para>
      </sect3>

      <sect3>
	<!-- Re-entrancy -->
	<title>Re-entrada</title>
        <!--
        The problem occurs because functions in C and C++ support interrupts;
        that is, the languages are re-entrant. They also support recursive
        function calls. This means that at any point in the execution of a
        program an interrupt can occur without breaking the program. Of
        course, the person who writes the interrupt service routine (ISR) is
        responsible for saving and restoring all the registers that are used
        in the ISR, but if the ISR needs to use any memory further down on the
        stack, this must be a safe thing to do. (You can think of an ISR as an
        ordinary function with no arguments and void return value that saves
        and restores the CPU state. An ISR function call is triggered by some
        hardware event instead of an explicit call from within a program.)
        -->
	<para>
	  Este problema ocurre porque las funciones en C y C++ pueden
	  sufrir interrupciones; esto es, los lenguajes han de ser (y de
	  hecho son) <emphasis>re-entrantes</emphasis>. También permiten
	  llamadas a funciones recursivas. Esto quiere decir que en
	  cualquier punto de ejecución de un programa puede sufrir una
	  interrupción sin que el programa se vea afectado por
	  ello. Obviamente la persona que escribe la rutina de servicio
	  de interrupciones (ISR) es responsable de guardar y restaurar
	  todos los registros que se utilicen en la ISR. Pero si la ISR
	  necesita utilizar la pila, ha de hacerlo con
	  seguridad. (Piense que una ISR es como una función normal sin
	  argumentos y con valor de retorno <emphasis>void</emphasis>
	  que guarda y restaura el estado de la CPU. Una llamada a una
	  ISR se provoca con un evento hardware, y no con una llamada
	  dentro del programa de forma explícita.)
	</para>        <!--
        Now imagine what would happen if an ordinary function tried to return
        values on the stack. You can't touch any part of the stack that's
        above the return address, so the function would have to push the
        values below the return address. But when the assembly-language RETURN
        is executed, the stack pointer must be pointing to the return address
        (or right below it, depending on your machine), so right before the
        RETURN, the function must move the stack pointer up, thus clearing off
        all its local variables. If you're trying to return values on the
        stack below the return address, you become vulnerable at that moment
        because an interrupt could come along. The ISR would move the stack
        pointer down to hold its return address and its local variables and
        overwrite your return value.
        -->
	<para>
	  Ahora imagine que pasaría si una función normal intentara
	  retornar valores en la pila. No puede tocar la pila por encima
	  del la dirección del punto de retorno, así que la función
	  tendría que colocar los valores de retorno debajo de la
	  dirección del punto de retorno. Pero cuando el RETURN del
	  ensamblador se ejecuta, el puntero de la pila debería estar
	  apuntando a la dirección del punto de retorno (o justo debajo,
	  depende de la máquina), así que la función debe subir el
	  puntero de la pila, desechando todas las variables locales. Si
	  intenta retornar valores con la pila por debajo de la
	  dirección del punto de retorno, en ese momento es vulnerable a
	  una interrupción. La ISR escribiría encima de los valores de
	  retorno para colocar su dirección de punto de retorno y sus
	  variables locales.
	</para>        <!--
        To solve this problem, the caller could be responsible for allocating
        the extra storage on the stack for the return values before calling
        the function. However, C was not designed this way, and C++ must be
        compatible. As you'll see shortly, the C++ compiler uses a more
        efficient scheme.
        -->
	<para>
	  Para resolver este problema, el que llama a la
	  función <emphasis>podría</emphasis> ser
	  responsable de asignar la memoria extra en la
	  pila para los valores de retorno antes de
	  llamar a la función. Sin embargo, C no se
	  diseñó de esta manera y C++ ha de ser
	  compatible. Como pronto verá, el compilador de
	  C++ utiliza un esquema más eficaz.
	</para>        <!--
        Your next idea might be to return the value in some global data area,
        but this doesn't work either. Reentrancy means that any function can
        be an interrupt routine for any other function, including the same
        function you're currently inside. Thus, if you put the return value in
        a global area, you might return into the same function, which would
        overwrite that return value. The same logic applies to recursion.
        -->
	<para>
	  Otra idea sería retornar el valor utilizando un área de datos
	  global, pero tampoco funcionaría. La re-entrada significa que
	  cualquier función puede ser una rutina de interrupción para
	  otra función, <emphasis>incluida la función en la que ya se
	  está dentro</emphasis>. Por lo tanto, si coloca un valor de
	  retorno en un área global, podría retornar a la misma función,
	  lo cual sobreescribiría el valor de retorno. La misma lógica
	  se aplica a la recurrencia.
	</para>        <!--
        The only safe place to return values is in the registers, so you're
        back to the problem of what to do when the registers aren't large
        enough to hold the return value. The answer is to push the address of
        the return value's destination on the stack as one of the function
        arguments, and let the function copy the return information directly
        into the destination. This not only solves all the problems, it's more
        efficient. It's also the reason that, in PassingBigStructures.cpp, the
        compiler pushes the address of B2 before the call to bigfun() in
        main(). If you look at the assembly output for bigfun(), you can see
        it expects this hidden argument and performs the copy to the
        destination inside the function.
        -->
	<para>
	  Los registros son el único lugar seguro para devolver valores,
	  así que se vuelve al problema de qué hacer cuando los
	  registros no son lo suficientemente grandes para contener el
	  valor de retorno. La respuesta es colocar la dirección de la
	  ubicación del valor de retorno en la pila como uno de los
	  argumentos de la función, y dejar que la función copie la
	  información que se devuelve directamente en la ubicación. Esto
	  no solo soluciona todo los problemas, si no que además es más
	  eficaz. Ésta es la razón por la que el compilador coloca la
	  dirección de <emphasis>B2</emphasis> antes de llamar a
	  <emphasis>bigfun</emphasis> en la función
	  <emphasis>main()</emphasis> de
	  <emphasis>PassingBigStructures.cpp</emphasis>.  Si mirara
	  <emphasis>bigfun()</emphasis> en el código ensamblador,
	  observaría que la función espera este argumento escondido y
	  copia el valor de retorno <emphasis>ahí</emphasis>.
	</para>
      </sect3>
      <sect3>        <!-- : Bitcopy versus initialization -->
	<title>Copia bit a bit vs. inicialización</title>
        <!--
        So far, so good. There's a workable process for passing and returning
        large simple structures. But notice that all you have is a way to copy
        the bits from one place to another, which certainly works fine for the
        primitive way that C looks at variables. But in C++ objects can be
        much more sophisticated than a patch of bits; they have meaning. This
        meaning may not respond well to having its bits copied.
        -->
	<para> Hasta
	aquí, todo bien. Tenemos un procedimiento para pasar y retornar
	estructuras simples grandes. Pero note que lo único que tiene es
	una manera de copiar los bits de un lugar a otro, lo que
	ciertamente funciona bien para la forma (muy primitiva) en que C
	trata las variables. Sin embargo, en C++ los objetos pueden ser
	mucho más avanzados que un puñado de bits, pues tienen
	significado y, por lo tanto, puede que no responda bien a ser
	copiado.
	</para>
        <!--
        Consider a simple example: a class that knows how many objects of its
        type exist at any one time. From Chapter 10, you know the way to do
        this is by including a static data member:
        -->
	<para>
	  Considere un simple ejemplo: una clase que conoce cuantos
	  objetos de un tipo existen en cualquier momento. En el
	  Capítulo 10 se vio la manera de hacerlo incluyendo un atributo
	  estático (<emphasis>static</emphasis>):
	</para>


//: V1C11:HowMany.cpp

        <!--
        The class HowMany contains a static int objectCount and a static
        member function print() to report the value of that objectCount,
        along with an optional message argument. The constructor increments
        the count each time an object is created, and the destructor
        decrements it.
        -->
	<para>
	  La clase <emphasis>HowMany</emphasis> contiene un entero
	  estático llamado <emphasis>objectCount</emphasis> y un método
	  <emphasis>estático</emphasis> llamado
	  <emphasis>print()</emphasis> para presentar el valor de
	  <emphasis>objectCount</emphasis>, junto con argumento de
	  mensaje optativo. El constructor incrementa
	  <emphasis>objectCount</emphasis> cada vez que se crea un
	  objeto, y el destructor lo disminuye.
	</para>
	<para>
	  Sin embargo la salida no es lo que uno esperaría:
	</para>

<screen>
after construction of h: objectCount = 1
x argument inside f(): objectCount = 1
~HowMany(): objectCount = 0
after call to f(): objectCount = 0
~HowMany(): objectCount = -1
~HowMany(): objectCount = -2
</screen>

        <!--
        After h is created, the object count is one, which is fine. But after
        the call to f() you would expect to have an object count of two,
        because h2 is now in scope as well. Instead, the count is zero, which
        indicates something has gone horribly wrong. This is confirmed by the
        fact that the two destructors at the end make the object count go
        negative, something that should never happen.
        -->
	  <para>
	  Después de crear <emphasis>h</emphasis>, el contador es uno,
	  lo cual está bien. Pero después de la llamada a
	  <emphasis>f()</emphasis> se esperaría que el contador
	  estuviera a dos, porque <emphasis>h2</emphasis> está ahora
	  también dentro de ámbito. Sin embargo, el contador es cero, lo
	  cual indica que algo ha ido muy mal. Esto se confirma por el
	  hecho de que los dos destructores, llamados al final de
	  <emphasis>main()</emphasis>, hacen que el contador se pase a
	  negativo, algo que nunca debería ocurrir.
	</para>        <!--
        Look at the point inside f(), which occurs after the argument is
        passed by value. This means the original object h exists outside the
        function frame, and there's an additional object inside the function
        frame, which is the copy that has been passed by value. However, the
        argument has been passed using C's primitive notion of bitcopying,
        whereas the C++ HowMany class requires true initialization to maintain
        its integrity, so the default bitcopy fails to produce the desired
        effect.
        -->
	<para>
	  Mire lo que ocurre dentro de <emphasis>f()</emphasis> después
	  de que el argumento se pase por valor. Esto quiere decir que
	  el objeto original <emphasis>h</emphasis> existe fuera del
	  ámbito de la función y, por otro lado, hay un objeto de más
	  <emphasis>dentro</emphasis> del ámbito de la función, el cual
	  es la copia del objeto que se pasó por valor. El argumento que
	  se pasó utiliza el primitivo concepto de copia bit a bit de C,
	  pero la clase C++ <emphasis>HowMany</emphasis> necesita
	  inicializarse correctamente para mantener su integridad. Por
	  lo tanto, se demuestra que la copia bit a bit no logra el
	  efecto deseado.
	</para>        <!--
        When the local object goes out of scope at the end of the call to f(
        ), the destructor is called, which decrements objectCount, so outside
        the function, objectCount is zero. The creation of h2 is also
        performed using a bitcopy, so the constructor isn't called there
        either, and when h and h2 go out of scope, their destructors cause the
        negative values of objectCount.
        -->
	<para>
	  Cuando el objeto local se sale de ámbito al salir de la
	  función <emphasis>f()</emphasis>, se llama a su destructor, lo
	  cual disminuye <emphasis>objectCount</emphasis>, y por lo
	  tanto el <emphasis>objectCount</emphasis> se pone a cero. La
	  creación de <emphasis>h2</emphasis> se realiza también
	  mediante la copia bit a bit, así que tampoco se llama al
	  constructor, y cuando <emphasis>h</emphasis> y
	  <emphasis>h2</emphasis> se salen de ámbito, sus destructores
	  causan el valor negativo en <emphasis>objectCount</emphasis>.
	</para>
      </sect3>
    </sect2>
    <sect2>      <!-- : Copy-construction -->
      <title>Construcción por copia</title>      <!--
      The problem occurs because the compiler makes an assumption about how
      to create a new object from an existing object. When you pass an
      object by value, you create a new object, the passed object inside the
      function frame, from an existing object, the original object outside
      the function frame. This is also often true when returning an object
      from a function. In the expression
      -->
      <para>
	El problema se produce debido a que el compilador hace una
	suposición sobre cómo crear <emphasis>un nuevo objeto de otro ya
	existente</emphasis>.  Cuando se pasa un objeto por valor, se
	crea un nuevo objeto, que estará dentro del ámbito de la
	función, del objeto original ya existente fuera del ámbito de la
	función. Esto también es a menudo cierto cuando una función
	retorna un objeto. En la expresión
      </para>
<programlisting>
HowMany h2 = f(h);
</programlisting>      <!--
      h2, a previously unconstructed object, is created from the return
      value of f(), so again a new object is created from an existing one.
      -->
      <para>
	<emphasis>h2</emphasis>, un objeto que no estaba creado
	anteriormente, se crea a partir del valor que retorna
	<emphasis>f()</emphasis>, y otra vez un nuevo objeto se crea de
	otro ya existente.
      </para>      <!--
      The compiler's assumption is that you want to perform this creation
      using a bitcopy, and in many cases this may work fine, but in HowMany
      it doesn't fly because the meaning of initialization goes beyond
      simply copying. Another common example occurs if the class contains
      pointers - what do they point to, and should you copy them or should
      they be connected to some new piece of memory?
      -->
      <para>
	El compilador supone que la creación ha de hacerse con una copia
	bit a bit, lo que en muchos casos funciona bien, pero en
	<emphasis>HowMany</emphasis> no funciona porque la
	inicialización va más allá de una simple copia. Otro ejemplo muy
	común ocurre cuando la clase contiene punteros pues, ¿a qué
	deben apuntar?  ¿debería copiar sólo los punteros o debería
	asignar memoria y que apuntaran a ella?
      </para>      <!--
      Fortunately, you can intervene in this process and prevent the
      compiler from doing a bitcopy. You do this by defining your own
      function to be used whenever the compiler needs to make a new object
      from an existing object. Logically enough, you're making a new object,
      so this function is a constructor, and also logically enough, the
      single argument to this constructor has to do with the object you're
      constructing from. But that object can't be passed into the
      constructor by value because you're trying to define the function that
      handles passing by value, and syntactically it doesn't make sense to
      pass a pointer because, after all, you're creating the new object from
      an existing object. Here, references come to the rescue, so you take
      the reference of the source object. This function is called the
      copy-constructor and is often referred to as X(X&), which is its
      appearance for a class called X.
      -->
      <para>
	Afortunadamente, puede intervenir en este proceso y prevenir que
	el compilador haga una copia bit a bit. Se soluciona definiendo
	su propia función siempre que el compilador necesite crear un
	nuevo objeto de otro ya existente. Lógicamente, está creando un
	nuevo objeto, por lo que esta función es un constructor, y
	también el único argumento del constructor tiene que ver con el
	objeto del que se pretende partir para crear el nuevo. Pero no
	puede pasar ese objeto por valor al constructor porque usted
	está intentando <emphasis>definir</emphasis> la función que
	maneja el paso por valor, y, por otro lado, sintácticamente no
	tiene sentido pasar un puntero porque, después de todo, está
	creando un objeto de otro ya existente. Aquí es cuando las
	referencias vienen al rescate, y puede utilizar la referencia
	del objeto origen. Esta función se llama el
	<emphasis>constructor copia</emphasis>, que también se lo puede
	encontrar como <emphasis>X(X&amp;)</emphasis>, que es el
	constructor copia de una clase denominada
	<emphasis>X</emphasis>.
      </para>      <!--
      If you create a copy-constructor, the compiler will not perform a
      bitcopy when creating a new object from an existing one. It will
      always call your copy-constructor. So, if you don't create a
      copy-constructor, the compiler will do something sensible, but you
      have the choice of taking over complete control of the process.
      -->
      <para>
	Si crea un constructor copia, el compilador no realizará una
	copia bit a bit cuando cree un nuevo objeto de otro ya
	existente.  El compilador siempre llamará al constructor
	copia. Si no crea el constructor copia, el compilador hará algo
	sensato, pero usted tiene la opción de tener control total del
	proceso.
      </para>      <!-- Now it's possible to fix the problem in HowMany.cpp: -->
      <para>
	Ahora es posible solucionar el problema en
	<emphasis>HowMany.cpp</emphasis>:
      </para>


//: V1C11:HowMany2.cpp

      <!--
      There are a number of new twists thrown in here so you can get a
      better idea of what's happening. First, the string name acts as an
      object identifier when information about that object is printed. In
      the constructor, you can put an identifier string (usually the name of
      the object) that is copied to name using the string constructor. The
      default = "" creates an empty string. The constructor increments the
      objectCount as before, and the destructor decrements it.
      -->
      <para>
	Hay unas cuantas cosas nuevas para que pueda hacerse una idea
	mejor de lo que pasa. Primeramente, el <emphasis>string
	name</emphasis> hace de identificador de objeto cuando se
	imprima en la salida.  Puede poner un identificador (normalmente
	el nombre del objeto) en el constructor para que se copie en
	<emphasis>name</emphasis> utilizando el constructor con un
	<emphasis>string</emphasis> como argumento. Por defecto se crea
	un <emphasis>string</emphasis> vacío. El constructor incrementa
	<emphasis>objectCount</emphasis> y el destructor lo disminuye,
	igual que en el ejemplo anterior.
      </para>      <!--
      Next is the copy-constructor, HowMany2(const HowMany2&). The
      copy-constructor can create a new object only from an existing one, so
      the existing object's name is copied to name, followed by the word
      "copy" so you can see where it came from. If you look closely, you'll
      see that the call name(h.name) in the constructor initializer list is
      actually calling the string copy-constructor.
      -->
      <para>
	Lo siguiente es el constructor copia, <emphasis>HowMany2(const
	HowMany2&amp;)</emphasis>. El constructor copia crea un objeto
	solamente desde otro ya existente, así que copia en
	<emphasis>name</emphasis> el identificador del objeto origen,
	seguido de la palabra "copy", y así puede ver de dónde procede.
	Si mira atentamente, verá que la llamada
	<emphasis>name(h.name)</emphasis> en la lista de inicializadores
	del constructor está llamando al constructor copia de la clase
	<emphasis>string</emphasis>.
      </para>      <!--
      Inside the copy-constructor, the object count is incremented just as
      it is inside the normal constructor. This means you'll now get an
      accurate object count when passing and returning by value.
      -->
      <para>
	Dentro del constructor copia, se incrementa el contador igual
	que en el constructor normal. Esto quiere decir que obtendrá un
	contador de objetos preciso cuando pase y retorne por valor.
      </para>
      <para>      <!--
      The print() function has been modified to print out a message, the
      object identifier, and the object count. It must now access the name
      data of a particular object, so it can no longer be a static member
      function.
      -->
	La función <emphasis>print()</emphasis> se ha modificado para
	imprimir en la salida un mensaje, el identificador del objeto y
	el contador de objetos. Como ahora accede al miembro
	<emphasis>name</emphasis> de un objeto en particular, ya no
	puede ser un método <emphasis>estático</emphasis>.
      </para>      <!--
      Inside main(), you can see that a second call to f() has been
      added. However, this call uses the common C approach of ignoring the
      return value. But now that you know how the value is returned (that
      is, code inside the function handles the return process, putting the
      result in a destination whose address is passed as a hidden argument),
      you might wonder what happens when the return value is ignored. The
      output of the program will throw some illumination on this.
      -->
      <para>
	Dentro de <emphasis>main()</emphasis> puede ver que hay una
	segunda llamada a <emphasis>f()</emphasis>. Sin embargo esta
	llamada utiliza la característica de C para ningunear el valor
	de retorno. Pero ahora que sabe cómo se retorna el valor (esto
	es, código <emphasis>dentro</emphasis> de la función que maneja
	el proceso de retorno poniendo el resultado en un lugar cuya
	dirección se pasa como un argumento escondido), podría
	preguntarse qué ocurre cuando se ningunea el valor de
	retorno. La salida del programa mostrará alguna luz sobre el
	asunto.
      </para>      <!--
      Before showing the output, here's a little program that uses iostreams
      to add line numbers to any file:
      -->
      <para>
	Pero antes de mostrar la salida, he aquí un pequeño programa que
	utiliza iostreams para añadir números de línea a cualquier
	archivo:
      </para>


//: V1C11:Linenum.cpp

      <!--
      The entire file is read into a vector<string>, using the same code
      that you've seen earlier in the book. When printing the line numbers,
      we'd like all the lines to be aligned with each other, and this
      requires adjusting for the number of lines in the file so that the
      width allowed for the line numbers is consistent. We can easily
      determine the number of lines using vector::size(), but what we
      really need to know is whether there are more than 10 lines, 100
      lines, 1,000 lines, etc. If you take the logarithm, base 10, of the
      number of lines in the file, truncate it to an int and add one to the
      value, you'll find out the maximum width that your line count will be.
      -->
      <para>
	El archivo se pasa a un <emphasis>vector(string)</emphasis>,
	utilizando el mismo código fuente que se ha visto anteriormente
	en este libro. Cuando se pone los números de línea, nos gustaría
	que todas las líneas estuvieran alineadas, y esto necesita
	conocer el número de líneas en el archivo para que sea
	coherente.  Se puede conocer el número de líneas con
	<emphasis>vector::size()</emphasis>, pero lo que realmente
	necesitamos es conocer si hay más líneas de 10, 100, 1000, etc.
	Si se utiliza el logaritmo en base 10 sobre el número de líneas
	en el archivo, se trunca a un entero y se añade uno al valor
	resultante y eso determinará el ancho máximo en dígitos que un
	número de línea puede tener.
      </para>      <!--
      You'll notice a couple of strange calls inside the for loop: setf()
      and width(). These are ostream calls that allow you to control, in
      this case, the justification and width of the output. However, they
      must be called each time a line is output and that is why they are
      inside the for loop. Volume 2 of this book has an entire chapter
      explaining iostreams that will tell you more about these calls as well
      as other ways to control iostreams.
      -->
      <para>
	Nótese que hay un par de llamadas extrañas dentro del bucle
	<emphasis>for</emphasis>: <emphasis>setf()</emphasis> y
	<emphasis>width()</emphasis>. Hay llamadas de
	<emphasis>ostream</emphasis> que permiten controlar, en este
	caso, la justificación y anchura de la salida. Sin embargo se
	debe llamar cada vez que una línea se imprime y por eso están
	dentro del bucle <emphasis>for</emphasis>. El Volumen 2 de este
	libro tiene un capítulo entero que explica los iostreams y que
	cuenta más sobre estas llamadas así como otras formas de
	controlar los iostreams.
      </para>      <!-- When Linenum.cpp is applied to HowMany2.out, the result is -->
      <para>
	Cuando se aplica <filename>Linenum.cpp</filename> abactor
	<filename>HowMany2.out</filename>, resulta:
      </para>

<programlisting>
1) HowMany2()
2)   h: objectCount = 1
3) Entering f()
4) HowMany2(const HowMany2&amp;)
5)   h copy: objectCount = 2
6) x argument inside f()
7)   h copy: objectCount = 2
8) Returning from f()
9) HowMany2(const HowMany2&amp;)
10)   h copy copy: objectCount = 3
11) ~HowMany2()
12)   h copy: objectCount = 2
13) h2 after call to f()
14)   h copy copy: objectCount = 2
15) Call f(), no return value
16) HowMany2(const HowMany2&amp;)
17)   h copy: objectCount = 3
18) x argument inside f()
19)   h copy: objectCount = 3
20) Returning from f()
21) HowMany2(const HowMany2&amp;)
22)   h copy copy: objectCount = 4
23) ~HowMany2()
24)   h copy: objectCount = 3
25) ~HowMany2()
26)   h copy copy: objectCount = 2
27) After call to f()
28) ~HowMany2()
29)   h copy copy: objectCount = 1
30) ~HowMany2()
31)   h: objectCount = 0
</programlisting>
      <!--
      As you would expect, the first thing that happens is that the normal
      constructor is called for h, which increments the object count to
      one. But then, as f() is entered, the copy-constructor is quietly
      called by the compiler to perform the pass-by-value. A new object is
      created, which is the copy of h (thus the name "h copy") inside the
      function frame of f(), so the object count becomes two, courtesy of
      the copy-constructor.
      -->
      <para>
	Como se esperaba, la primera cosa que ocurre es que para
	<emphasis>h</emphasis> se llama al constructor normal, el cual
	incrementa el contador de objetos a uno. Pero entonces, mientras
	se entra en <emphasis>f()</emphasis>, el compilador llama
	silenciosamente al constructor copia para hacer el paso por
	valor. Se crea un nuevo objeto, que es la copia de
	<emphasis>h</emphasis> (y por tanto tendrá el identificador "h
	copy") dentro del ámbito de la función <emphasis>f()</emphasis>.
	Así pues, el contador de objetos se incrementa a dos, por
	cortesía del constructor copia.
      </para>      <!--
      Line eight indicates the beginning of the return from f(). But before
      the local variable "h copy" can be destroyed (it goes out of scope at
      the end of the function), it must be copied into the return value,
      which happens to be h2. A previously unconstructed object (h2) is
      created from an existing object (the local variable inside f()), so
      of course the copy-constructor is used again in line nine. Now the
      name becomes "h copy copy" for h2's identifier because it's being
      copied from the copy that is the local object inside f(). After the
      object is returned, but before the function ends, the object count
      becomes temporarily three, but then the local object "h copy" is
      destroyed. After the call to f() completes in line 13, there are only
      two objects, h and h2, and you can see that h2 did indeed end up as "h
      copy copy."
      -->
      <para>
	La línea ocho indica el principio del retorno de
	<emphasis>f()</emphasis>. Pero antes de que se destruya la
	variable local "h copy" (pues sale de ámbito al final de la
	función), se debe copiar al valor de retorno, que es
	<emphasis>h2</emphasis>. Por tanto <emphasis>h2</emphasis>, que
	no estaba creado previamente, se crea de un objeto ya existente
	(la variable local dentro de <emphasis>f()</emphasis>) y el
	constructor copia vuelve a utilizarse en la línea 9. Ahora el
	identificador de <emphasis>h2</emphasis> es "h copy copy" porque
	copió el identificador de la variable local de
	<emphasis>f()</emphasis>. Cuando se devuelve el objeto, pero
	antes de que la función termine, el contador de objetos se
	incrementa temporalmente a tres, pero la variable local con
	identificador "h copy" se destruye, disminuyendo a dos. Después
	de que se complete la llamada a <emphasis>f()</emphasis> en la
	línea 13, sólo hay dos objetos, <emphasis>h</emphasis> y
	<emphasis>h2</emphasis>, y puede comprobar, de hecho, que
	<emphasis>h2</emphasis> terminó con el identificador "h copy
	copy".
      </para>

      <sect3>        <!-- : Temporary objects -->
	<title>Objetos temporales</title>        <!--
        Line 15 begins the call to f(h), this time ignoring the return
        value. You can see in line 16 that the copy-constructor is called just
        as before to pass the argument in. And also, as before, line 21 shows
        the copy-constructor is called for the return value. But the
        copy-constructor must have an address to work on as its destination (a
        this pointer). Where does this address come from?
        -->
	<para>
	  En la línea 15 se empieza la llamada a
	  <emphasis>f(h)</emphasis>, y esta vez ningunea el valor de
	  retorno. Puede ver en la línea 16 que el constructor copia se
	  llama, igual que antes, para pasar el argumento.  Y también,
	  igual que antes, en la línea 21 se llama al constructor copia
	  para el valor de retorno. Pero el constructor copia necesita
	  una dirección con la que trabajar como su destino ( es decir,
	  para trabajar con el puntero <emphasis>this</emphasis>). ¿De
	  dónde procede esta dirección?
	</para>        <!--
        It turns out the compiler can create a temporary object whenever it
        needs one to properly evaluate an expression. In this case it creates
        one you don't even see to act as the destination for the ignored
        return value of f(). The lifetime of this temporary object is as
        short as possible so the landscape doesn't get cluttered up with
        temporaries waiting to be destroyed and taking up valuable
        resources. In some cases, the temporary might immediately be passed to
        another function, but in this case it isn't needed after the function
        call, so as soon as the function call ends by calling the destructor
        for the local object (lines 23 and 24), the temporary object is
        destroyed (lines 25 and 26).
        -->
	<para>
	  Esto prueba que el compilador puede crear un objeto temporal
	  cuando lo necesita para evaluar una expresión
	  adecuadamente. En este caso él crea uno que ni siquiera se le
	  ve actuar como el destino para el ninguneado valor que
	  <emphasis>f()</emphasis> retorna. El tiempo de vida de este
	  objeto temporal es tan corto como sea posible para que el
	  programa no se llene de objetos temporales esperando a ser
	  destruidos, lo cual provocaría la utilización ineficaz de
	  recursos valiosos. En algunos casos, el objeto temporal podría
	  pasarse inmediatamente a otra función, pero en este caso no se
	  necesita después de la llamada a la función, así que tan
	  pronto como la función termina llamando al destructor del
	  objeto local (líneas 23 y 24), el objeto temporal también se
	  destruye (líneas 25 y 26).
	</para>        <!--
        Finally, in lines 28-31, the h2 object is destroyed, followed by h,
        and the object count goes correctly back to zero.
        -->
	<para>
	  Finalmente, de la línea 28 a la línea 31, se destruye el
	  objeto <emphasis>h2</emphasis>, seguido de
	  <emphasis>h</emphasis> y el contador de objetos vuelve a cero.
	</para>
      </sect3>
    </sect2>
    <sect2>      <!-- : Default copy-constructor -->
      <title>Constructor copia por defecto</title>      <!--
      Because the copy-constructor implements pass and return by value, it's
      important that the compiler creates one for you in the case of simple
      structures - effectively, the same thing it does in C. However, all
      you've seen so far is the default primitive behavior: a bitcopy.
      -->
      <para>
	Como el constructor de copia implementa el paso y retorno por
	valor, es importante que el compilador cree uno en el caso de
	estructuras simples (de hecho, es lo mismo que hace C). Sin
	embargo todo lo que se ha visto es el comportamiento por
	defecto: una copia bit a bit.
      </para>      <!--
      When more complex types are involved, the C++ compiler will still
      automatically create a copy-constructor if you don't make one. Again,
      however, a bitcopy doesn't make sense, because it doesn't necessarily
      implement the proper meaning.
      -->
      <para>
	Cuando se utilizan tipos más complejos, el compilador de C++
	creará un constructor copia automáticamente si no se implementa
	explícitamente. Se insiste en que una copia bit a bit no tiene
	sentido, pues no tiene porqué ser el comportamiento que se
	necesita.
      </para>      <!--
      Here's an example to show the more intelligent approach the compiler
      takes. Suppose you create a new class composed of objects of several
      existing classes. This is called, appropriately enough, composition,
      and it's one of the ways you can make new classes from existing
      classes. Now take the role of a naive user who's trying to solve a
      problem quickly by creating a new class this way. You don't know about
      copy-constructors, so you don't create one. The example demonstrates
      what the compiler does while creating the default copy-constructor for
      your new class:
      -->
      <para>
	He aquí un ejemplo para mostrar el comportamiento más
	inteligente del compilador. Suponga que crea una nueva clase
	compuesta por objetos de varias clases diferentes. A esto se le
	denomina <emphasis>composición</emphasis>, y es una de las
	formas en las que se pueden hacer nuevas clases a partir de las
	ya existentes. Ahora desempeñe el papel de un novato que trata
	de resolver un problema rápidamente creando una nueva clase de
	esta manera. No sabe nada sobre los constructores de copia, así
	que no lo implementa. El ejemplo muestra lo que el compilador
	hace cuando crea un constructor copia por defecto para su nueva
	clase:
      </para>


//: V1C11:DefaultCopyConstructor.cpp

      <!--
      The class WithCC contains a copy-constructor, which simply announces
      that it has been called, and this brings up an interesting issue. In
      the class Composite, an object of WithCC is created using a default
      constructor. If there were no constructors at all in WithCC, the
      compiler would automatically create a default constructor, which would
      do nothing in this case. However, if you add a copy-constructor,
      you've told the compiler you're going to handle constructor creation,
      so it no longer creates a default constructor for you and will
      complain unless you explicitly create a default constructor as was
      done for WithCC.
      -->
      <para>
	La clase <emphasis>WithCC</emphasis> contiene un constructor
	copia, que simplemente anuncia que ha sido llamado, y esto
	muestra un asunto interesante: dentro de la clase
	<emphasis>Composite</emphasis> se crea un objeto tipo
	<emphasis>WithCC</emphasis> utilizando el constructor por
	defecto. Si <emphasis>WithCC</emphasis> no tuviera ningún
	constructor, el compilador crearía uno por defecto
	automáticamente, el cual, en este caso, no haría nada. No
	obstante, si añade un constructor por defecto, al compilador se
	le está diciendo que ha de utilizar los constructores
	disponibles, por lo que no crea ningún constructor por defecto y
	se quejará a no ser que explícitamente cree un constructor por
	defecto, como se hizo en <emphasis>WithCC</emphasis>.
      </para>      <!--
      The class WoCC has no copy-constructor, but its constructor will store
      a message in an internal string that can be printed out using print(
      ). This constructor is explicitly called in Composite's constructor
      initializer list (briefly introduced in Chapter 8 and covered fully in
      Chapter 14). The reason for this becomes apparent later.
      -->
      <para>
	La clase <emphasis>WoCC</emphasis> no tiene constructor copia,
	pero su constructor mantendrá un <emphasis>string</emphasis>
	interno imprimible por la función <emphasis>print()</emphasis>.
	La lista de inicializadores en el constructor de
	<emphasis>Composite</emphasis> llama explícitamente a este
	constructor (presentado brevemente en el Capítulo 8 y tratado
	completamente en el Capítulo 14). La razón de esto se verá
	posteriormente.
      </para>      <!--
      The class Composite has member objects of both WithCC and WoCC (note
      the embedded object wocc is initialized in the constructor-initializer
      list, as it must be), and no explicitly defined
      copy-constructor. However, in main() an object is created using the
      copy-constructor in the definition:
      -->
      <para>
	La clase <emphasis>Composite</emphasis> tiene miembros objeto
	tanto de <emphasis>WithCC</emphasis> como de
	<emphasis>WoCC</emphasis> (note que el objeto interno
	<emphasis>wocc</emphasis> se inicializa en la lista de
	inicializadores del constructor de
	<emphasis>Composite</emphasis>, como debe ser), pero no están
	inicializados explícitamente en el constructor copia. Sin
	embargo un objeto <emphasis>Composite</emphasis> se crea en
	<emphasis>main()</emphasis> utilizando el constructor copia:
      </para>

<programlisting>
Composite c2 = c;
</programlisting>

      <!--
      The copy-constructor for Composite is created automatically by the
      compiler, and the output of the program reveals the way that it is
      created:
      -->
      <para>
	El compilador ha creado un constructor copia para
	<emphasis>Composite</emphasis> automáticamente, y la salida del
	programa revela la manera en que se crea:
      </para>

<programlisting>
Contents of c: Composite()
Calling Composite copy-constructor
WithCC(WithCC&amp;)
Contents of c2: Composite()
</programlisting>

      <!--
      To create a copy-constructor for a class that uses composition (and
      inheritance, which is introduced in Chapter 14), the compiler
      recursively calls the copy-constructors for all the member objects and
      base classes. That is, if the member object also contains another
      object, its copy-constructor is also called. So in this case, the
      compiler calls the copy-constructor for WithCC. The output shows this
      constructor being called. Because WoCC has no copy-constructor, the
      compiler creates one for it that just performs a bitcopy, and calls
      that inside the Composite copy-constructor. The call to
      Composite::print() in main shows that this happens because the
      contents of c2.wocc are identical to the contents of c.wocc. The
      process the compiler goes through to synthesize a copy-constructor is
      called memberwise initialization.
      -->
      <para>
	Para la creación de un constructor copia para una clase que
	utiliza composición (y herencia, que se trata en el Capítulo
	14), el compilador llama a todos los constructores copia de
	todos los miembros objeto y de las clases base de manera
	recursiva. Es decir, si el miembro objeto también contiene otro
	objeto, también se llama a su constructor copia. En el ejemplo,
	el compilador llama al constructor copia de
	<emphasis>WithCC</emphasis>. La salida muestra que se llama a
	este constructor. Como <emphasis>WoCC</emphasis> no tiene
	constructor copia, el compilador crea uno que realiza
	simplemente una copia bit a bit para que el constructor copia de
	<emphasis>Composite</emphasis> lo pueda llamar. La llamada a
	<emphasis>Composite::print()</emphasis> en
	<emphasis>main()</emphasis> muestra que esto ocurre, porque el
	contenido de <emphasis>c2.wocc</emphasis> es idéntico al
	contenido de <emphasis>c.wocc</emphasis>. El proceso que realiza
	el compilador para crear un constructor copia se denomina
	<emphasis>inicialización inteligente de miembros(memberwise
	initialization)</emphasis>.
      </para>      <!--
      It's always best to create your own copy-constructor instead of
      letting the compiler do it for you. This guarantees that it will be
      under your control.
      -->
      <para>
	Se recomienda definir constructor copia propio en vez del que
	hace el compilador. Esto garantiza que estará bajo control.
      </para>
    </sect2>
    <sect2>
      <!-- : Alternatives to copy-construction -->
      <title>Alternativas a la construcción por copia</title>      <!--
      At this point your head may be swimming, and you might be wondering
      how you could have possibly written a working class without knowing
      about the copy-constructor. But remember: You need a copy-constructor
      only if you're going to pass an object of your class by value. If that
      never happens, you don't need a copy-constructor.
      -->
      <para>
	A estas alturas su cabeza debe estar echando humo, y se
	preguntará cómo es posible que pudiera escribir una clase que
	funcionase sin saber nada acerca del constructor copia. No
	obstante, recuerde que el constructor copia sólo es necesario
	cuando la clase se pasa <emphasis>por valor</emphasis>. Si esto
	no va a ocurrir, entonces no lo necesita.
      </para>
      <sect3>        <!-- : Preventing pass-by-value -->
	<title>Prevención del paso por valor</title>
        <!--
        "But," you say, "if I don't make a copy-constructor, the compiler will
        create one for me. So how do I know that an object will never be
        passed by value?"
        -->
	<para>
	  "Pero", puede decir, "si no defino el constructor copia, el
	  compilador lo creará por mí. ¿Cómo sé que un objeto nunca se
	  pasará por valor?
	</para>        <!--
        There's a simple technique for preventing pass-by-value: declare a
        private copy-constructor. You don't even need to create a definition,
        unless one of your member functions or a friend function needs to
        perform a pass-by-value. If the user tries to pass or return the
        object by value, the compiler will produce an error message because
        the copy-constructor is private. It can no longer create a default
        copy-constructor because you've explicitly stated that you're taking
        over that job.
        -->
	<para>
	  Existe una técnica simple que previene el paso por valor:
	  declare un constructor copia <emphasis>private</emphasis>.  Ni
	  siquiera necesita definirlo (sólo declararlo), a no ser que un
	  método o una función <emphasis>friend</emphasis> necesite
	  realizar un paso por valor. Si el usuario intenta pasar o
	  retornar el objeto por valor, el compilador se quejará con un
	  error porque el constructor copia es
	  <emphasis>private</emphasis>. El compilador ya no puede crear
	  un constructor copia por defecto porque explícitamente ya hay
	  uno creado.
	</para>        <!-- Here's an example: -->
	<para>
	  He aquí un ejemplo:
	</para>


//: V1C11:NoCopyConstruction.cpp

        <!-- Notice the use of the more general form -->
	<para>
	  Note la  utilización de la forma más general
	</para>


<programlisting>
NoCC(const NoCC&amp;);
</programlisting>

        <!-- using the const. -->
	<para>
	  utilizando <emphasis>const</emphasis>
	</para>
      </sect3>
      <sect3>        <!-- : Functions that modify outside objects -->
	<title>Funciones que modifican objetos externos</title>        <!--
        Reference syntax is nicer to use than pointer syntax, yet it clouds
        the meaning for the reader. For example, in the iostreams library one
        overloaded version of the get() function takes a char& as an
        argument, and the whole point of the function is to modify its
        argument by inserting the result of the get(). However, when you read
        code using this function it's not immediately obvious to you that the
        outside object is being modified:
        -->
	<para>
	  La sintaxis de referencias es más agradable que la de
	  punteros, aunque oculte significado al que lea el código
	  fuente. Por ejemplo, en la librería iostreams existe una
	  versión sobrecargada de la función <emphasis>get()</emphasis>
	  que tiene como argumento un <emphasis>char &amp;</emphasis>, y
	  su cometido es modificar ese argumento y utilizarlo como el
	  valor que retorna <emphasis>get()</emphasis>. No obstante,
	  cuando se lee el código fuente de esta función, no es
	  inmediatamente obvio que la variable que se pasa como
	  argumento vaya a ser modificada:
	</para>

<programlisting>
char c;
cin.get(c);
</programlisting>
        <!--
        Instead, the function call looks like a pass-by-value, which suggests
        the outside object is not modified.
        -->
	<para>
	  Parece que a la función se le pasa por valor, lo que sugiere
	  que el argumento que se pasa <emphasis>no</emphasis> se
	  modifica.
	</para>        <!--
        Because of this, it's probably safer from a code maintenance
        standpoint to use pointers when you're passing the address of an
        argument to modify. If you always pass addresses as const references
        except when you intend to modify the outside object via the address,
        where you pass by non-const pointer, then your code is far easier for
        the reader to follow.
        -->
	<para>
	  A causa de esto, es probablemente más seguro, desde el punto
	  de vista de mantenimiento del código fuente, utilizar punteros
	  que pasen la dirección del argumento que se desee
	  modificar. Si <emphasis>siempre</emphasis> pasa direcciones
	  como referencias constantes <emphasis>excepto</emphasis>
	  cuando intenta modificar el argumento que se pasa a través de
	  la dirección, donde pasaría un puntero no constante, entonces
	  es más fácil para el lector seguir el código fuente.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>    <!-- : Pointers to members -->
    <title>Punteros a miembros</title>    <!--
    A pointer is a variable that holds the address of some location. You
    can change what a pointer selects at runtime, and the destination of
    the pointer can be either data or a function. The C++
    pointer-to-member follows this same concept, except that what it
    selects is a location inside a class. The dilemma here is that a
    pointer needs an address, but there is no "address" inside a class;
    selecting a member of a class means offsetting into that class. You
    can't produce an actual address until you combine that offset with the
    starting address of a particular object. The syntax of pointers to
    members requires that you select an object at the same time you're
    dereferencing the pointer to member.
    -->
    <para>
      Un puntero es una variable que contiene la dirección de una
      ubicación. Se puede cambiar a lo que el puntero apunta en tiempo
      de ejecución. La ubicación a la que apunta puede ser un dato o
      función. El <emphasis>puntero a miembro</emphasis> de C++ sigue el
      mismo concepto, excepto que a lo que apunta es una ubicación
      dentro de una clase. Pero surge el dilema de que un puntero
      necesita una dirección, pero no hay "dirección" alguna dentro de
      una clase; La selección de un miembro de una clase se realiza
      mediante un desplazamiento dentro de la clase. Pero primero hay
      que conocer la dirección donde comienza un objeto en particular
      para luego sumarle el desplazamiento y así localizar el miembro de
      la clase. La sintaxis de los punteros a miembros requiere que
      usted seleccione un objeto al mismo tiempo que está accediendo al
      contenido del puntero al miembro.
    </para>    <!--
    To understand this syntax, consider a simple structure, with a pointer
    sp and an object so for this structure. You can select members with
    the syntax shown:
    -->
    <para>
      Para entender esta sintaxis, considere una simple estructura, con
      un puntero <emphasis>sp</emphasis> y un objeto
      <emphasis>so</emphasis>.  Puede seleccionar sus miembros de la
      misma manera que en el siguiente ejemplo:
    </para>


//: V1C11:SimpleStructure.cpp
    <!--
    Now suppose you have an ordinary pointer to an integer, ip. To access
    what ip is pointing to, you dereference the pointer with a '*':
    -->

    <para>
      Ahora suponga que tiene un puntero normal que se llama
      <emphasis>ip</emphasis> y que apunta a un entero. Para acceder a
      lo que <emphasis>ip</emphasis> está apuntando, ha de estar
      precedido por un '*':
    </para>

<programlisting>
*ip=4;
</programlisting>
    <!--
    Finally, consider what happens if you have a pointer that happens to
    point to something inside a class object, even if it does in fact
    represent an offset into the object. To access what it's pointing at,
    you must dereference it with *. But it's an offset into an object, so
    you must also refer to that particular object. Thus, the * is combined
    with the object dereference. So the new syntax becomes ->* for a
    pointer to an object, and .* for the object or a reference, like this:
    -->
    <para>
      Finalmente, se preguntará qué pasa si tiene un puntero que está
      apuntando a algo que está dentro de un objeto, incluso si lo que
      realmente representa es un desplazamiento dentro del objeto. Para
      acceder a lo que está apuntando, debe preceder el puntero con '*'.
      Pero como es un desplazamiento dentro de un objeto, también ha de
      referirse al objeto con el que estamos tratando. Así, el * se
      combina con el objeto. Por tanto, la nueva sintaxis se escribe
      <emphasis>->*</emphasis> para un puntero que apunta a un objeto, y
      <emphasis>.*</emphasis> para un objeto o referencia, tal como
      esto:
    </para>

<programlisting>
objectPointer->*pointerToMember = 47;
object.*pointerToMember = 47;
</programlisting>
    <!--
    Now, what is the syntax for defining pointerToMember? Like any
    pointer, you have to say what type it's pointing at, and you use a *
    in the definition. The only difference is that you must say what class
    of objects this pointer-to-member is used with. Of course, this is
    accomplished with the name of the class and the scope resolution
    operator. Thus,
    -->
    <para>
      Pero, ¿cuál es la sintaxis para definir el
      <emphasis>pointerToMember</emphasis>? Pues como cualquier puntero,
      tiene que decir el tipo al que apuntará, por lo que se utilizaría
      el * en la definición. La única diferencia es que debe decir a qué
      clase de objetos este miembro puntero apuntará. Obviamente, esto
      se consigue con el nombre de la clase y el operador de resolución
      de ámbito. Así,
    </para>

<programlisting>
int ObjectClass::*pointerToMember;
</programlisting>
    <!--
    defines a pointer-to-member variable called pointerToMember that
    points to any int inside ObjectClass. You can also initialize the
    pointer-to-member when you define it (or at any other time):
    -->
    <para>
      define una variable miembro puntero llamado
      <emphasis>pointerToMember</emphasis> que apunta a cualquier entero
      dentro de <emphasis>ObjectClass</emphasis>. También puede
      inicializar el miembro puntero cuando se define (o en cualquier
      otro momento):
    </para>

<programlisting>
int ObjectClass::*pointerToMember = &amp;ObjectClass::a;
</programlisting>
    <!--
    There is actually no "address" of ObjectClass::a because you're just
    referring to the class and not an object of that class. Thus,
    &ObjectClass::a can be used only as pointer-to-member syntax.
    -->
    <para>
      Realmente no existe una "dirección" de
      <emphasis>ObjectClass::a</emphasis> porque se está refiriendo a la
      clase y no a un objeto de esa clase.  Así,
      <emphasis>&amp;ObjectClass::a</emphasis> se puede utilizar sólo
      con la sintaxis de un puntero a miembro.
    </para>    <!--
    Here's an example that shows how to create and use pointers to data
    members:
    -->
    <para>
      He aquí un ejemplo que muestra cómo crear y utilizar punteros a
      atributos:
    </para>


//: V1C11:PointerToMemberData.cpp

    <!--
    Obviously, these are too awkward to use anywhere except for special
    cases (which is exactly what they were intended for).
    -->
    <para>
      Obviamente, son muy desagradables de utilizar en cualquier lugar
      excepto para caso especiales (que es exactamente para lo que
      crearon).
    </para>    <!--
    Also, pointers to members are quite limited: they can be assigned only
    to a specific location inside a class. You could not, for example,
    increment or compare them as you can with ordinary pointers.
    -->
    <para>
      Además, los punteros a miembro son bastante limitados: pueden
      asignarse solamente a una ubicación específica dentro de una
      clase.  No podría, por ejemplo, incrementarlos o compararlos tal
      como puede hacer con punteros normales.
    </para>
    <sect2>      <!-- : Functions -->
      <title>Funciones</title>      <!--
      A similar exercise produces the pointer-to-member syntax for member
      functions. A pointer to a function (introduced at the end of Chapter
      3) is defined like this:
      -->
      <para>
	Un ejercicio similar se produce con la sintaxis de puntero a
	miembro para métodos. Un puntero a una función (presentado al
	final del Capítulo 3) se define como:
      </para>

<programlisting>
  int (*fp)(float);
</programlisting>
      <!--
      The parentheses around (*fp) are necessary to force the compiler to
      evaluate the definition properly. Without them this would appear to be
      a function that returns an int*.
      -->
      <para>
	Los paréntesis que engloban a <emphasis>(*fb)</emphasis> son
	necesarios para que fuercen la evaluación de la definición
	apropiadamente. Sin ellos sería una función que devuelve un
	<emphasis>int*</emphasis>.
      </para>      <!--
      Parentheses also play an important role when defining and using
      pointers to member functions. If you have a function inside a class,
      you define a pointer to that member function by inserting the class
      name and scope resolution operator into an ordinary function pointer
      definition:
      -->
      <para>
	Los paréntesis también desempeñan un papel importante cuando
	definen y utilizan punteros a métodos. Si tiene una función
	dentro de una clase, puede definir un puntero a ese método
	insertando el nombre de la clase y el operador de resolución de
	ámbito en una definición normal de puntero a función:
      </para>


//: V1C11:PmemFunDefinition.cpp

      <!--
      In the definition for fp2 you can see that a pointer to member
      function can also be initialized when it is created, or at any other
      time. Unlike non-member functions, the & is not optional when taking
      the address of a member function. However, you can give the function
      identifier without an argument list, because overload resolution can
      be determined by the type of the pointer to member.
      -->
      <para>
	En la definición de <emphasis>fp2</emphasis> puede verse que el
	puntero a un método puede inicializarse cuando se crea, o en
	cualquier otro momento. A diferencia de las funciones que no son
	miembros, el <emphasis>&amp;</emphasis> <emphasis>no</emphasis>
	es optativo para obtener la dirección de un método. Sin embargo,
	se puede dar el identificador de la función sin la lista de
	argumentos, porque la sobrecarga se resuelve por el tipo de
	puntero a miembro.
      </para>
      <sect3>        <!-- : An example -->
	<title>Un ejemplo</title>        <!--
        The value of a pointer is that you can change what it points to at
        runtime, which provides an important flexibility in your programming
        because through a pointer you can select or change behavior at
        runtime. A pointer-to-member is no different; it allows you to choose
        a member at runtime. Typically, your classes will only have member
        functions publicly visible (data members are usually considered part
        of the underlying implementation), so the following example selects
        member functions at runtime.
        -->
	<para>
	  Lo interesante de un puntero es que se puede cambiar el valor
	  del mismo para apuntar a otro lugar en tiempo de ejecución, lo
	  cual proporciona mucha flexibilidad en la programación porque
	  a través de un puntero se puede cambiar el
	  <emphasis>comportamiento</emphasis> del programa en tiempo de
	  ejecución. Un puntero a miembro no es diferente; le permite
	  elegir un miembro en tiempo de ejecución. Típicamente, sus
	  clases sólo tendrán métodos visibles públicamente (los
	  atributos normalmente se consideran parte de la implementación
	  que va oculta), así que el siguiente ejemplo elige métodos en
	  tiempo de ejecución.
	</para>


//: V1C11:PointerToMemberFunction.cpp

        <!--
        Of course, it isn't particularly reasonable to expect the casual user
        to create such complicated expressions. If the user must directly
        manipulate a pointer-to-member, then a typedef is in order. To really
        clean things up, you can use the pointer-to-member as part of the
        internal implementation mechanism. Here's the preceding example using
        a pointer-to-member inside the class. All the user needs to do is pass
        a number in to select a function.[48]
        -->
	<para>
	  Por supuesto, no es razonable esperar que el usuario casual
	  cree expresiones tan complejas. Si el usuario necesita
	  manipular directamente un puntero a miembro, los
	  <emphasis>typedef</emphasis> vienen al rescate. Para dejar aún
	  mejor las cosas, puede utilizar un puntero a función como
	  parte del mecanismo interno de la implementación. He aquí un
	  ejemplo que utiliza un puntero a miembro
	  <emphasis>dentro</emphasis> de la clase. Todo lo que el
	  usuario necesita es pasar un número para elegir una función.
	  <footnote>
	    <para>
	      Gracias a Owen Mortensen por este ejemplo
	    </para>
	  </footnote>
	</para>


//: V1C11:PointerToMemberFunction2.cpp

        <!--
        In the class interface and in main(), you can see that the entire
        implementation, including the functions, has been hidden away. The
        code must even ask for the count() of functions. This way, the class
        implementer can change the quantity of functions in the underlying
        implementation without affecting the code where the class is used.
        -->
	<para>
	  En la interfaz de la clase y en <emphasis>main()</emphasis>,
	  puede observar que toda la implementación, funciones
	  incluidas, han sido puestas como privadas. El código ha de
	  pedir el <emphasis>count()</emphasis> de las funciones. De
	  esta manera, el que implementa la clase puede cambiar la
	  cantidad de funciones en la implementación por debajo sin que
	  afecte al código que utilice la clase.
	</para>        <!--
        The initialization of the pointers-to-members in the constructor may
        seem overspecified. Shouldn't you be able to say
        -->
	<para>
	  La inicialización de los punteros a miembro en el constructor
	  para que estén sobre especificado. ¿No debería ser capaz de
	  poner
	</para>

<programlisting>
fptr[1] = &amp;g;
</programlisting>
        <!--
        because the name g occurs in the member function, which is
        automatically in the scope of the class? The problem is this doesn't
        conform to the pointer-to-member syntax, which is required so
        everyone, especially the compiler, can figure out what's going
        on. Similarly, when the pointer-to-member is dereferenced, it seems
        like
        -->
	<para>
	  porque el nombre <emphasis>g</emphasis> es un método, la cual
	  está en el ámbito de la clase? El problema aquí es que no
	  sería conforme a la sintaxis de puntero a miembro.  Así todo
	  el mundo, incluido el compilador, puede imaginarse qué está
	  pasando.  De igual forma, cuando se accede al contenido del
	  puntero a miembro, parece que
	</para>

<programlisting>
(this->*fptr[i])(j);
</programlisting>
        <!--
        is also over-specified; this looks redundant. Again, the syntax
        requires that a pointer-to-member always be bound to an object when it
        is dereferenced.
        -->
	<para>
	  también está sobre especificado; <emphasis>this</emphasis>
	  parece redundante. La sintaxis necesita que un puntero a
	  miembro siempre esté ligado a un objeto cuando se accede al
	  contenido al que que apunta.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>    <!-- : Summary -->
    <title>Resumen</title>    <!--
    Pointers in C++ are almost identical to pointers in C, which is
    good. Otherwise, a lot of C code wouldn't compile properly under
    C++. The only compile-time errors you will produce occur with
    dangerous assignments. If these are in fact what are intended, the
    compile-time errors can be removed with a simple (and explicit!) cast.
    -->
    <para>
      Los puntero en C++ son casi idénticos a los punteros en C, lo cual
      es bueno. De otra manera, gran cantidad de código C no compilaría
      bajo C++. Los únicos errores en tiempo de compilación serán
      aquéllos que realicen asignaciones peligrosas. Esos errores pueden
      eliminarse con una simple (¡pero explícito!) molde al tipo
      deseado.
    </para>    <!--
    C++ also adds the reference from Algol and Pascal, which is like a
    constant pointer that is automatically dereferenced by the compiler. A
    reference holds an address, but you treat it like an
    object. References are essential for clean syntax with operator
    overloading (the subject of the next chapter), but they also add
    syntactic convenience for passing and returning objects for ordinary
    functions.
    -->
    <para>
      C++ también añade la <emphasis>referencia</emphasis> de Algol y
      Pascal, que es como un puntero constante que el compilador hace
      que se acceda directamente al contenido al que apunta. Una
      referencia contiene una dirección, pero lo trata como un
      objeto. Las referencias son esenciales para una sintaxis clara con
      la sobrecarga de operadores (el tema del siguiente capítulo), pero
      también proporcionan mejoras sintácticas para el paso y retorno de
      objetos en funciones normales.
    </para>    <!--
    The copy-constructor takes a reference to an existing object of the
    same type as its argument, and it is used to create a new object from
    an existing one. The compiler automatically calls the copy-constructor
    when you pass or return an object by value. Although the compiler will
    automatically create a copy-constructor for you, if you think one will
    be needed for your class, you should always define it yourself to
    ensure that the proper behavior occurs. If you don't want the object
    passed or returned by value, you should create a private
    copy-constructor.
    -->
    <para>
      El constructor copia coge una referencia de un objeto ya existente
      del mismo tipo que el argumento, y lo utiliza para la creación de
      un nuevo objeto procedente del ya existente. El compilador llama
      automáticamente al constructor copia cuando pasa o retorna un
      objeto por valor. Aunque el compilador crea un constructor copia
      automáticamente, si cree que su clase necesita uno, debería
      definirlo para asegurar un comportamiento apropiado. Si no desea
      que el objeto se pase o retorne por valor, debería crear un
      constructor copia privado.
    </para>    <!--
    Pointers-to-members have the same functionality as ordinary pointers:
    You can choose a particular region of storage (data or function) at
    runtime. Pointers-to-members just happen to work with class members
    instead of with global data or functions. You get the programming
    flexibility that allows you to change behavior at runtime.
    -->
    <para>
      Los punteros a miembro tienen la misma capacidad que los punteros
      normales: puede elegir una región de memoria particular (atributo
      o método) en tiempo de ejecución. Los punteros a miembro funcionan
      con los miembros de una clase en vez de datos o funciones
      globales.  Tiene la suficiente flexibilidad para cambiar el
      comportamiento en tiempo de ejecución.
    </para>
  </sect1>

  <sect1>    <!-- : Exercises -->
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
	<listitem>    <!--
    1. Turn the "bird & rock" code fragment at the beginning of this
    chapter into a C program (using structs for the data types), and
    show that it compiles. Now try to compile it with the C++ compiler
    and see what happens.
    -->
	  <para>
	    Convierta el fragmento de código "bird &amp; rock" al
	    principio de este capítulo a un programa C (utilizando <emphasis>
	      struct</emphasis>uras para los tipos de datos), y que compile.
	    Ahora intente compilarlo con un compilador de C++ y vea qué
	    ocurre.
	  </para>
	</listitem>

	<listitem>    <!--
    2. Take the code fragments in the beginning of the section titled
    "References in C++" and put them into a main(). Add statements to
    print output so that you can prove to yourself that references are
    like pointers that are automatically dereferenced.
    -->
	  <para>
	    Coja los fragmentos de código al principio de la
	    sección titulada "Referencias en C++" y póngalos en un
	    <emphasis>main()</emphasis>.  Añada sentencias para imprimir
	    en la salida para que pueda demostrar usted mismo que las
	    referencias son como punteros que acceden automáticamente a lo
	    que apuntan.
	  </para>
	</listitem>

	<listitem>    <!--
    3. Write a program in which you try to (1) Create a reference that
    is not initialized when it is created. (2) Change a reference to
    refer to another object after it is initialized. (3) Create a NULL
    reference.
    -->
	  <para>
	    Escriba un programa en el cual intente (1) Crear una
	    referencia que no esté inicializada cuando se crea. (2)
	    Cambiar una referencia para que se refiera a otro objeto
	    después de que se haya inicializado. (3) Crear una
	    referencia nula.
	  </para>
	</listitem>

	<listitem>    <!--
    4. Write a function that takes a pointer argument, modifies what
    the pointer points to, and then returns the destination of the
    pointer as a reference.
    -->
	  <para>
	    Escriba una función que tenga un puntero por argumento,
	    modifique el contenido de lo que el puntero apunta, y retorno
	    ese mismo contenido como si de una referencia se tratara.
	  </para>
	</listitem>

	<listitem>    <!--
    5. Create a class with some member functions, and make that the
    object that is pointed to by the argument of Exercise 4. Make the
    pointer a const and make some of the member functions const and
    prove that you can only call the const member functions inside your
    function. Make the argument to your function a reference instead of
    a pointer.
    -->
	  <para>
	    Cree una nueva clase con algunos métodos, y haga que el
	    objeto que sea apuntado por el argumento del Ejercicio 4. Haga que
	    el puntero pasado por como argumento y algunos métodos sean
	    constantes y pruebe que sólo puede llamar a los métodos constantes
	    dentro de su función. Haga que el argumento de su función sea una
	    referencia en vez de un puntero.
	  </para>
	</listitem>

	<listitem>    <!--
    6. Take the code fragments at the beginning of the section titled
    "Pointer references" and turn them into a program.
    -->
	  <para>
	    Coja los fragmentos de código al principio de la sección
	    "referencias a puntero" y conviértalos en un programa.
	  </para>
	</listitem>

	<listitem>    <!--
    7. Create a function that takes an argument of a reference to a
    pointer to a pointer and modifies that argument. In main(), call
    the function.
    -->
	  <para>
	    Cree una función que tome como argumento una referencia a
	    un puntero que apunta a otro puntero y modifique ese argumento. En
	    <emphasis>main()</emphasis>, llame a la función.
	  </para>
	</listitem>

	<listitem>    <!--
    8. Create a function that takes a char& argument and modifies that
    argument. In main(), print out a char variable, call your function
    for that variable, and print it out again to prove to yourself that
    it has been changed. How does this affect program readability?
    -->
	  <para>
	    Cree una función que toma un argumento del tipo
	    <emphasis>char&amp;</emphasis> y lo modifica. En el
	    <emphasis>main()</emphasis> imprima a la salida una variable
	    <emphasis>char</emphasis>, llame a su función con esa variable e
	    imprima la variable de nuevo para demostrar que ha sido cambiada.
	    ¿Cómo afecta esto a la legibilidad del programa?
	  </para>
	</listitem>

	<listitem>    <!--
    9. Write a class that has a const member function and a non-const
    member function. Write three functions that take an object of that
    class as an argument; the first takes it by value, the second by
    reference, and the third by const reference. Inside the functions,
    try to call both member functions of your class and explain the
    results.
    -->
	  <para>
	    Escriba una clase que tiene un método constante y otra que
	    no lo sea. Escriba tres funciones que toman un objeto de esa clase
	    como argumento; la primera lo toma por valor, la segunda lo toma
	    por referencia y la tercera lo toma mediante una referencia
	    constante. Dentro de las funciones, intente llamar a las dos
	    funciones de su clase y explique los resultados.
	  </para>
	</listitem>

	<listitem>    <!--
    10. (Somewhat challenging) Write a simple function that takes an int
    as an argument, increments the value, and returns it. In main(),
    call your function. Now discover how your compiler generates
    assembly code and trace through the assembly statements so that you
    understand how arguments are passed and returned, and how local
    variables are indexed off the stack.
    -->
	  <para>
	    (Algo difícil) Escriba una función simple que toma un
	    entero como argumento, incrementa el valor, y lo retorna. En el
	    <emphasis>main()</emphasis>, llame a su función. Intente que el
	    compilador genere el código ensamblador e intente entender cómo
	    los argumentos se pasan y se retornan, y cómo las variables locales
	    se colocan en la pila.
	  </para>
	</listitem>

      <listitem><!--
    11. Write a function that takes as its arguments a char, int, float,
    and double. Generate assembly code with your compiler and find the
    statements that push the arguments on the stack before a function
    call.
    -->
	<para></para>
      </listitem>
      <listitem>  <!--
    12. Write a function that returns a double. Generate assembly code
    and determine how the value is returned.
    -->
	<para>
	    Escriba una función que devuelva un
	    <emphasis>double</emphasis>.  Genere el código ensamblador y
	    explique cómo se retorna el valor.
	  </para>
      </listitem>

	<listitem>   <!--
    13. Produce assembly code for PassingBigStructures.cpp. Trace
    through and demystify the way your compiler generates code to pass
    and return large structures.
    -->
	  <para>
	    Genere el código ensamblador de
	    <emphasis>PassingBigStructures.cpp</emphasis>. Recorra y
	    desmitifique la manera en que su compilador genera el código
	    para pasar y devolver estructuras grandes.
	  </para>
	</listitem>

	<listitem>     <!--
    14. Write a simple recursive function that decrements its argument
    and returns zero if the argument becomes zero, otherwise it calls
    itself. Generate assembly code for this function and explain how the
    way that the assembly code is created by the compiler supports
    recursion.
    -->
	  <para>
	    Escriba una simple función recursiva que disminuya su
	    argumento y retorne cero si el argumento llega a cero, o que
	    se vuelva a llamar. Genere el código ensamblador para esta
	    función y explique la forma en el el compilador implementa la
	    recurrencia.
	  </para>
	</listitem>

	<listitem>   <!--
    15. Write code to prove that the compiler automatically synthesizes
    a copy-constructor if you don't create one yourself. Prove that the
    synthesized copy-constructor performs a bitcopy of primitive types
    and calls the copy-constructor of user-defined types.
    -->
	  <para>
	    Escriba código para demostrar que el compilador
	    genera un constructor copia automáticamente en caso de que
	    usted no lo implemente. Demuestre que el constructor copia
	    generado por el compilador realiza una copia bit a bit de
	    tipos primitivos y llama a los constructores copia de los
	    tipos definidos por el usuario.
	  </para>
	</listitem>

	<listitem>   <!--
    16. Write a class with a copy-constructor that announces itself to
    cout. Now create a function that passes an object of your new class
    in by value and another one that creates a local object of your new
    class and returns it by value. Call these functions to prove to
    yourself that the copy-constructor is indeed quietly called when
    passing and returning objects by value.
    -->
	  <para>
	    Escriba una clase que en el constructor copia se anuncia a
	    sí mismo a través de un <emphasis>cout</emphasis>. Ahora
	    cree una función que pasa un objeto de su nueva clase por
	    valor y otro más que crea un objeto local de su nueva clase
	    y lo devuelve por valor.  Llame a estas funciones para
	    demostrar que el constructor copia es, en efecto, llamado
	    cuando se pasan y retornan objetos por valor.
	  </para>
	</listitem>

	<listitem>    <!--
    17. Create a class that contains a double*. The constructor
    initializes the double* by calling new double and assigning a value
    to the resulting storage from the constructor argument. The
    destructor prints the value that's pointed to, assigns that value to
    -1, calls delete for the storage, and then sets the pointer to
    zero. Now create a function that takes an object of your class by
    value, and call this function in main(). What happens? Fix the
    problem by writing a copy-constructor.
    -->
	  <para>
	    Cree un objeto que contenga un <emphasis>double*</emphasis>.
	    Que el constructor inicialice el
	    <emphasis>double*</emphasis> llamando a <emphasis>new
	    double</emphasis> y asignando un valor. Entonces, que el
	    destructor imprima el valor al que apunta, asigne ese valor
	    a -1, llame a <emphasis>delete</emphasis> para liberar la
	    memoria y que ponga el puntero a cero. Ahora cree una
	    función que tome un objeto de su clase por valor, y llame a
	    esta función en el <emphasis>main()</emphasis>. ¿Qué ocurre?
	    Solucione el problema implementando un constructor copia.
	  </para>
	</listitem>

	<listitem>   <!--
    18. Create a class with a constructor that looks like a
    copy-constructor, but that has an extra argument with a default
    value. Show that this is still used as the copy-constructor.
    -->
	  <para>
	    Cree una clase con un constructor que parezca un constructor
	    copia, pero que tenga un argumento de más con un valor por
	    defecto. Muestre que aún así se utiliza como constructor
	    copia.
	  </para>
	</listitem>

	<listitem>       <!--
    19. Create a class with a copy-constructor that announces
    itself. Make a second class containing a member object of the first
    class, but do not create a copy-constructor. Show that the
    synthesized copy-constructor in the second class automatically calls
    the copy-constructor of the first class.
    -->
	  <para>
	    Cree una clase con un constructor copia que se anuncie a sí
	    mismo (es decir que imprima por la salida que ha sido
	    llamado).  Haga una segunda clase que contenga un objeto
	    miembro de la primera clase, pero no cree un constructor
	    copia. Muestre que el constructor copia, que el compilador
	    genera automáticamente en la segunda clase, llama al
	    constructor copia de la primera.
	  </para>
	</listitem>

	<listitem>    <!--
    20. Create a very simple class, and a function that returns an
    object of that class by value. Create a second function that takes a
    reference to an object of your class. Call the first function as the
    argument of the second function, and demonstrate that the second
    function must use a const reference as its argument.
    -->
	  <para>
	    Cree una clase muy simple, y una función que devuelva un
	    objeto de esa clase por valor. Cree una segunda función que
	    tome una referencia de un objeto de su clase. Llame a la
	    segunda función pasándole como argumento una llamada a la
	    primera función, y demuestre que la segunda función debe
	    utilizar una referencia constante como argumento.
	  </para>
	</listitem>

	<listitem>    <!--
    21. Create a simple class without a copy-constructor, and a simple
    function that takes an object of that class by value. Now change
    your class by adding a private declaration (only) for the
    copy-constructor. Explain what happens when your function is
    compiled.
    -->
	  <para>
	    Cree una clase simple sin constructor copia, y una simple
	    función que tome un objeto de esa clase por valor. Ahora
	    cambie su clase añadiéndola una declaración (sólo declare,
	    no defina) privada de un constructor copia. Explique lo que
	    ocurre cuando compila la función.
	  </para>
	</listitem>

	<listitem>    <!--
    22. This exercise creates an alternative to using the
    copy-constructor. Create a class X and declare (but don't define) a
    private copy-constructor. Make a public clone() function as a const
    member function that returns a copy of the object that is created
    using new. Now write a function that takes as an argument a const X&
    and clones a local copy that can be modified. The drawback to this
    approach is that you are responsible for explicitly destroying the
    cloned object (using delete) when you're done with it.
    -->
	  <para>
	    Este ejercicio crea una alternativa a la utilización del
	    constructor copia. Cree una clase <emphasis>X</emphasis> y
	    declare (pero no defina) un constructor copia privado. Haga
	    una función <emphasis>clone()</emphasis> pública como un
	    método constante que devuelve una copia del objeto creado
	    utilizando <emphasis>new</emphasis>. Ahora escriba una
	    función que tome como argumento un <emphasis>const
	    X&amp;</emphasis> y clone una copia local que puede
	    modificarse. El inconveniente de esto es que usted es
	    responsable de destruir explícitamente el objeto clonado
	    (utilizando <emphasis>delete</emphasis>) cuando ya haya
	    terminado con él.
	  </para>
	</listitem>

	<listitem>    <!--
    23. Explain what's wrong with both Mem.cpp and MemTest.cpp from
    Chapter 7. Fix the problem.
    -->
	  <para>
	    Explique qué está mal en <emphasis>Mem.cpp</emphasis>
	    y <emphasis>MemTest.cpp</emphasis> del Capítulo 7. Solucione
	    el problema.
	  </para>
	</listitem>

	<listitem>    <!--
    24. Create a class containing a double and a print() function that
    prints the double. In main(), create pointers to members for both
    the data member and the function in your class. Create an object of
    your class and a pointer to that object, and manipulate both class
    elements via your pointers to members, using both the object and the
    pointer to the object.
    -->
	  <para>
	    Cree una clase que contenga un <emphasis>double</emphasis> y
	    una función <emphasis>print()</emphasis> que imprima el
	    <emphasis>double</emphasis>. Cree punteros a miembro tanto
	    para el atributo como al método de su clase. Cree un objeto
	    de su clase y un puntero a ese objeto, y manipule ambos
	    elementos de la clase a través de los punteros a miembro,
	    utilizando tanto el objeto como el puntero al objeto.
	  </para>
	</listitem>

	<listitem>    <!--
    25. Create a class containing an array of int. Can you index through
    this array using a pointer to member?
    -->
	  <para>
	    Cree una clase que contenga un array de
	    enteros. ¿Puede recorrer el array mediante un puntero a
	    miembro?
	  </para>
	</listitem>

	<listitem>    <!--
    26. Modify PmemFunDefinition.cpp by adding an overloaded member
    function f() (you can determine the argument list that causes the
    overload). Now make a second pointer to member, assign it to the
    overloaded version of f(), and call the function through that
    pointer. How does the overload resolution happen in this case?
    -->
	  <para>
	    Modifique <emphasis>PmemFunDefinition.cpp</emphasis>
	    añadiendo un método <emphasis>f()</emphasis> sobrecargada
	    (puede determinar la lista de argumentos que provoque la
	    sobrecarga).  Ahora haga un segundo puntero a miembro,
	    asígnelo a la versión sobrecargada de
	    <emphasis>f()</emphasis>, y llame al método a través del
	    puntero. ¿Cómo sucede la resolución de función sobrecargada
	    en este caso?
	  </para>
	</listitem>

	<listitem>    <!--
    27. Start with FunctionTable.cpp from Chapter 3. Create a class that
    contains a vector of pointers to functions, with add() and remove(
    ) member functions to add and remove pointers to functions. Add a
    run() function that moves through the vector and calls all of the
    functions.
    -->
	  <para>
	    Empiece con la función <filename>FunctionTable.cpp</filename>
	    del Capítulo 3. Cree una clase que contenga un
	    <emphasis>vector</emphasis> de punteros a funciones, con
	    métodos <emphasis>add()</emphasis> y
	    <emphasis>remove()</emphasis> para añadir y quitar punteros
	    a función. Añada una función denominada
	    <emphasis>run()</emphasis> que recorra el
	    <emphasis>vector</emphasis> y llame a todas la funciones.
	  </para>
	</listitem>

	<listitem>
	<!--
	Modify the above Exercise 27 so that it works with
	pointers to member functions instead. -->
	  <para>
	    Modifique el Ejercicio 27 para que funcione con punteros a
	    métodos.
	  </para>
	</listitem>

      </orderedlist>
  </sect1>
</chapter>

<!--
David Villa: 1ª REVISIÓN. (NO TERMINADA)
  - Marcado DocBook muy deficiente (Completar)
  - Uso masivo e injustificado de 'emphasis'
  - Dentro de los 'programlisting' aparecen cosas como <iostream>
    que lógicamente dan al traste con la compilación DocBook
  - La calidad de la traducción es buena aunque fallan algunos
    términos técnicos (p.ej: "Constructor copia")
  - Sólo he hecho los cambios necesarios para que compile pero la mayor
    parte de los errores que cito aún no están corregidos
-->
