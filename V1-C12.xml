<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: José María Requena López
                       (anterior a LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:         David Villa
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C12">

  <title>Sobrecarga de operadores</title>

  <highlights>
    <!-- Operator overloading is just "syntactic sugar", which means it is simply another
         way for you to make a function call.  -->

    <para>
      La sobrecarga de operadores es solamente <quote>azúcar sintáctico</quote>, lo que
      significa que es simplemente otra manera de invocar funciones.
    </para>
  </highlights>

  <!-- The difference is that the arguments for this function don't appear inside
       parentheses, but instead they surround or are next to characters you've always
       thought of as immutable operators.  -->
  <para>
    La diferencia es que los argumentos para estas funciones no aparecen entre paréntesis,
    sino que rodean o siguen a los caracteres que siempre pensó como operadores
    inalterables.
  </para>


  <!-- There are two differences between the use of an operator and an ordinary function
       call.  The syntax is different; an operator is often "called" by placing it between
       or sometimes after the arguments. The second difference is that the compiler
       determines which "function" to call. For instance, if you are using the operator +
       with floating-point arguments, the compiler "calls" the function to perform
       floating-point addition (this "call" is typically the act of inserting in-line
       code, or a floating-point-processor instruction). If you use operator + with a
       floating-point number and an integer, the compiler "calls" a special function to
       turn the int into a float, and then "calls" the floating-point addition code.  -->
  <para>
    Hay dos diferencias entre el uso de un operador y el de una llamada a función
    normal. La sintaxis es diferente: un operador es a menudo <quote>llamado</quote>
    situándolo entre (o después de) los argumentos.  La segunda diferencia es que el
    compilador determina qué <quote>función</quote> llamar. Por ejemplo, si está usando el
    operador <oper>+</oper> con argumentos de punto flotante, el compilador
    <quote>llama</quote> a la función para realizar una suma de punto flotante (esta
    <quote>llamada</quote> normalmente consiste en insertar código en linea, o una
    instrucción de punto flotante del procesador). Si usa el operador <oper>+</oper> con
    un número de punto flotante y un entero, el compilador <quote>llama</quote> a una
    función especial para convertir el <type>int</type> a un <type>float</type>,y entonces
    <quote>llama</quote> a la función de suma en punto flotante.
  </para>

  <!-- But in C++, it's possible to define new operators that work with classes. This
       definition is just like an ordinary function definition except that the name of the
       function consists of the keyword operator followed by the operator. That's the only
       difference, and it becomes a function like any other function, which the compiler
       calls when it sees the appropriate pattern. -->
  <para>
    Sin embargo, en C++ es posible definir nuevos operadores que trabajen con clases. Esta
    definición es exactamente como la definición de una función ordinaria, excepto que el
    nombre de la función consiste en la palabra reservada <kw>operator</kw> seguida del
    operador. Siendo esta la única diferencia, el operador se convierte en una función
    como otra cualquiera que el compilador llama cuando ve el prototipo adecuado.
  </para>

  <sect1>
    <!-- : Warning & reassurance -->
    <title>Precaución y tranquilidad </title>

    <!--
		 It's tempting to become overenthusiastic with operator overloading. It's a fun
		 toy, at first. But remember it's only syntactic sugar, another way of calling a
		 function.  Looking at it this way, you have no reason to overload an operator
		 except if it will make the code involving your class easier to write and
		 especially easier to read.  (Remember, code is read much more than it is
		 written.) If this isn't the case, don't bother.
	-->
    <para>
      Es tentador convertirse en un super-entusiasta de la sobrecarga de operadores. Son
      un juguete divertido, al principio. Pero recuerde que es sólo un endulzamiento
      sintáctico, otra manera de llamar a una función. Mirándolo desde esa perspectiva, no
      hay razón para sobrecargar un operador excepto si eso hace al código implicado con
      la clase más sencillo e intuitivo de escribir y especialmente de leer. (Recuerde, el
      código se lee mucho más que se escribe). Si éste no es el caso no se moleste.
    </para>

    <!--
    Another common response to operator overloading is panic; suddenly, C operators have
    no familiar meaning anymore. "Everything's changed and all my C code will do different
    things!" This isn't true. All the operators used in expressions that contain only
    built-in data types cannot be changed. You can never overload operators such that
    -->
    <para>
      Otra reacción cmún frente al uso de la sobrecarga de operadores es el pánico: de
      repente, los operadores de C pierden su significado familiar.<quote>¡Todo ha
      cambiado y mi código C por completo hará cosas diferentes!</quote>. Esto no es
      verdad. Todos los operadores usados en expresiones que contienen solo tipos de datos
      incorporados no pueden ser cambiados. Nunca podrá sobrecargar operadores así:
    </para>


<programlisting>
    1 &lt;&lt; 4;
</programlisting>

    <!-- behaves differently, or -->
    <para>
      para que se comporten de forman diferente, o que
    </para>


<programlisting>
    1.414 &lt;&lt; 2;
</programlisting>

    <!--
    has meaning. Only an expression containing a user-defined type can have an overloaded
    operator.
    -->
    <para>
	  tenga significado. Sólo una expresión que contenga tipos de datos definidos por el
	  usuario podrá tener operadores sobrecargados.
    </para>
  </sect1>


  <sect1>
    <!-- : Syntax -->
    <title>Sintaxis</title>

    <!--
    Defining an overloaded operator is like defining a function, but the name of that
    function is operator@, in which @ represents the operator that's being overloaded. The
    number of arguments in the overloaded operator's argument list depends on two factors:
    -->
    <para>
      Definir un operador sobrecargado es como definir una función, pero el nombre de esa
      función es <function>operator@</function> en la que <oper>@</oper> representa el
      operador que está siendo sobrecargado. El número de argumentos en la lista de
      argumentos del operador sobrecargado depende de dos factores:
    </para>

    <!--
    1. Whether it's a unary operator (one argument) or a binary operator (two arguments).
    2. Whether the operator is defined as a global function (one argument for unary, two
    for binary) or a member function (zero arguments for unary, one for binary - the
    object becomes the left-hand argument).
    -->
    <orderedlist>
      <listitem>
		<para>
		  Si es un operador unario (un argumento) o un operador binario (dos argumentos)
		</para>
      </listitem>
      <listitem>
		<para>
		  Si el operador está definido como una función global (un argumento para los
		  unarios, dos para los binarios) o un método (cero argumentos para los unarios y
		  uno para los binarios. En este último caso el objeto (<kw>this</kw>) se
		  convierte en el argumento del lado izquierdo al operador).
		</para>
      </listitem>
    </orderedlist>

    <!-- Here's a small class that shows the syntax for operator overloading: -->
    <para>
      He aquí una pequeña clase que muestra la sintaxis de la sobrecarga de operadores:
    </para>



//: V1C12:OperatorOverloadingSyntax.cpp


    <!--
    The two overloaded operators are defined as inline member functions that announce when
    they are called. The single argument is what appears on the right-hand side of the
    operator for binary operators. Unary operators have no arguments when defined as member
    functions. The member function is called for the object on the left-hand side of the
    operator.
    -->
    <para>
      Los dos operadores sobrecargados están definidos como métodos en línea que imprimen
      un mensaje al ser llamados. El único argumento de estas funciones miembro será el
      que aparezca del lado derecho del operador binario. Los operadores unarios no tienen
      argumentos cuando se definen como métodos. El método es invocado por el objeto de la
      parte izquierda del operador.
    </para>

    <!--
    For non-conditional operators (conditionals usually return a Boolean value), you'll
    almost always want to return an object or reference of the same type you're operating on
    if the two arguments are the same type. (If they're not the same type, the
    interpretation of what it should produce is up to you.) This way, complicated
    expressions can be built up:
    -->
    <para>
      Para los operadores incondicionales (los condicionales generalmente devuelven un
      valor booleano), generalmente se deseará devolver un objeto o una referencia del
      mismo tipo que está operando, si los dos argumentos son del mismo tipo. (Si no son
      del mismo tipo, la interpretación de lo que debería pasar es responsabilidad
      suya). De esta manera, se pueden construir expresiones tan complicadas como la
      siguiente:
    </para>


<programlisting>
    kk += ii + jj;
</programlisting>


    <!--
    The operator+ produces a new Integer (a temporary) that is used as the rv argument for
    the operator+=. This temporary is destroyed as soon as it is no longer needed.
    -->
    <para>
      La expresión <function>operator+</function> crea un nuevo objeto
      <classname>Integer</classname> (un temporario) que se usa como argumento
      <varname>rv</varname> para el operador <function>operator+=</function>. Este objeto
      temporal se destruye tan pronto como deja de necesitarse.
    </para>
  </sect1>


  <sect1>
    <!-- : Overloadable operators -->
    <title>Operadores sobrecargables </title>

    <!--
    Although you can overload almost all the operators available in C, the use of operator
    overloading is fairly restrictive. In particular, you cannot combine operators that
    currently have no meaning in C (such as ** to represent exponentiation), you cannot
    change the evaluation precedence of operators, and you cannot change the number of
    arguments required by an operator. This makes sense - all of these actions would produce
    operators that confuse meaning rather than clarify it.
    -->
    <para>
      Aunque puede sobrecargar casi todos los operadores disponibles en C, el uso de
      operadores sobrecargados es bastante restrictivo. En particular, no puede combinar
      operadores que actualmente no tienen significado en C (como <oper>**</oper> para
      representar la potencia), no puede cambiar la precedencia de evaluación de operadores,
      y tampoco el número de argumentos requeridos por un operador. Estas restricciones
      existen para prevenir que la creación de nuevos operadores ofusquen el significado
	  en lugar de clarificarlo.
	</para>

   <!--
    The next two subsections give examples of all the "regular" operators, overloaded in the
    form that you'll most likely use.
    -->
    <para>
      Las siguientes dos subsecciones muestran ejemplos de todos los operadores normales,
      sobrecargados en la forma habitual.
    </para>

    <sect2>
      <!-- : Unary operators -->
      <title>Operadores unarios</title>

      <!--
      The following example shows the syntax to overload all the unary operators, in the form
      of both global functions (non-member friend functions) and as member functions. These
      will expand upon the Integer class shown previously and add a new byte class. The
      meaning of your particular operators will depend on the way you want to use them, but
      consider the client programmer before doing something unexpected.
      -->

      <!-- Here is a catalog of all the unary functions: -->
      <para>
		El siguiente ejemplo muestra la sintaxis para sobrecargar todos los operadores
		unarios, en ambas formas: como funciones globales (funciones <kw>friend</kw>, no
		métodos) y como métodos. Estas expandirán la clase <classname>Integer</classname>
		vista previamente y añadirá una nueva clase <classname>byte</classname>. El
		significado de sus operadores particulares dependerá de la forma en que los use,
		pero considere a los programadores del grupo antes de hacer algo inesperado.  He
		aquí un catálogo de todas las funciones unarias:
      </para>



//: V1C12:OverloadingUnaryOperators.cpp


      <!--
      The functions are grouped according to the way their arguments are passed. Guidelines
      for how to pass and return arguments are given later. The forms above (and the ones that
      follow in the next section) are typically what you'll use, so start with them as a
      pattern when overloading your own operators.
      -->
      <para>
		Las funciones están agrupadas de acuerdo a la forma en que se pasan los
		argumentos.  Más tarde se darán unas cuantas directrices de cómo pasar y devolver
		argumentos. Las clases expuestas anteriormente (y las que siguen en la siguiente
		sección) son las típicas, así que empiece con ellas como un patrón cuando
		sobrecargue sus propios operadores.
      </para>

      <sect3>
        <!-- : Increment & decrement -->
		<title>Incremento y decremento</title>

        <!--
        The overloaded ++ and - - operators present a dilemma because you want to be able to
        call different functions depending on whether they appear before (prefix) or after
        (postfix) the object they're acting upon. The solution is simple, but people sometimes
        find it a bit confusing at first. When the compiler sees, for example, ++a (a
        pre-increment), it generates a call to operator++(a); but when it sees a++, it generates
        a call to operator++(a, int). That is, the compiler differentiates between the two forms
        by making calls to different overloaded functions. In OverloadingUnaryOperators.cpp for
        the member function versions, if the compiler sees ++b, it generates a call to
        B::operator++( ); if it sees b++ it calls B::operator++(int).
        -->

		<para>
		  Los operadores de incremento<oper>++</oper> y de decremento <oper>--</oper>
		  provocan un conflicto porque querrá ser capaz de llamar diferentes funciones
		  dependiendo de si aparecen antes (prefijo) o después (sufijo) del objeto sobre
		  el que actúan. La solución es simple, pero la gente a veces lo encuentra un poco
		  confusa inicialmente. Cuando el compilador ve, por ejemplo, <code>++a</code> (un
		  pre-incremento), genera una llamada al <function>operator++(a)</function> pero
		  cuando ve <literal>a++</literal>, genera una llamada a <function>operator++(a,
		  int)</function>. Así es como el compilador diferencia entre los dos tipos,
		  generando llamadas a funciones sobrecargadas diferentes. En
		  <filename>OverloadingUnaryOperators.cpp</filename> para la versión de funciones
		  miembro, si el compilador ve <code>++b</code>, genera una llamada a
		  <function>B::operator++()</function>y si ve <code>b++</code>genera una llamada a
		  <function>B::operator++(int)</function>.
		</para>

		<!--
			All the user sees is that a different function gets called for the prefix and
			postfix versions. Underneath, however, the two functions calls have different
			signatures, so they link to two different function bodies. The compiler passes
			a dummy constant value for the int argument (which is never given an
			identifier because the value is never used) to generate the different
			signature for the postfix version.
        -->
		<para>
		  Todo lo que el usuario ve es que se llama a una función diferente para las
		  versiones sufija y prefija. Internamente, sin embargo, las dos llamadas de
		  funciones tienen diferentes firmas, así que conectan con dos cuerpos
		  diferentes. El compilador pasa un valor constante ficticio para el argumento
		  <type>int</type> (el cual nunca se proporcionada por un identificador porque el
		  valor nunca se usa) para generar las diferentes firmas para la versión sufija.
		</para>
      </sect3>
    </sect2>


    <sect2>
      <!-- : Binary operators -->
      <title>Operadores binarios</title>

      <!--
      The following listing repeats the example of OverloadingUnaryOperators.cpp for binary
      operators so you have an example of all the operators you might want to overload. Again,
      both global versions and member function versions are shown.
      -->
      <para>
		Los siguientes listados repiten el ejemplo de
		<filename>OverloadingUnaryOperators.cpp</filename> para los operadores binarios
		presentándole un ejemplo de todos los operadores que pueda querer sobrecargar. De
		nuevo se muestran ambas versiones, la global y la de método.
      </para>



 //: V1C12:Integer.h



 //: V1C12:Integer.cpp



 //: V1C12:IntegerTest.cpp



 //: V1C12:Byte.h



//: V1C12:ByteTest.cpp


     <!--
      You can see that operator= is only allowed to be a member function. This is
      explained later.
      -->
      <para>
		Puede ver que <oper>operator=</oper> solo puede ser un método. Esto se explica después.
      </para>


      <!--
      Notice that all of the assignment operators have code to check for self-assignment; this
      is a general guideline. In some cases this is not necessary; for example, with operator+
      = you often want to say A+=A and have it add A to itself. The most important place to
      check for self-assignment is operator= because with complicated objects disastrous
      results may occur. (In some cases it's OK, but you should always keep it in mind when
      writing operator=.)
      -->
      <para>
		Fíjese que todos los operadores de asignación tienen código para comprobar la auto
		asignación; ésta es una directiva general. En algunos casos esto no es necesario;
		por ejemplo, con <function>operator+=</function> a menudo querrá decir <code>A +=
		A</code> y sumar <varname>A</varname> a sí mismo. El lugar más importante para
		situar las comprobaciones para la auto asignación es
		<function>operator=</function> porque con objetos complicados pueden ocurrir
		resultados desastrosos. (En algunos casos es correcto, pero siempre debería
		tenerlo en mente cuando escriba <function>operator=</function>).
      </para>

		<!--
			All of the operators shown in the previous two examples are overloaded to
			handle a single type. It's also possible to overload operators to handle mixed
			types, so you can add apples to oranges, for example. Before you start on an
			exhaustive overloading of operators, however, you should look at the section
			on automatic type conversion later in this chapter. Often, a type conversion
			in the right place can save you a lot of overloaded operators.
		-->
      <para>
		Todos los operadores mostrados en los dos ejemplos previos son sobrecargados para
		manejar un tipo simple. También es posible sobrecargar operadores para manejar
		tipos compuestos, de manera que pueda sumar manzanas a naranjas, por
		ejemplo. Antes de que empiece una sobrecarga exhaustiva de operadores, no
		obstante, debería mirar la sección de conversión automática de tipos más adelante
		en este capitulo. A menudo, una conversión de tipos en el lugar adecuado puede
		ahorrarle un montón de operadores sobrecargados.
      </para>
    </sect2>


    <sect2>
      <!-- : Arguments & return values -->
      <title>Argumentos y valores de retorno</title>

      <!--
      It may seem a little confusing at first when you look at OverloadingUnaryOperators.cpp,
      Integer.h and Byte.h and see all the different ways that arguments are passed and
      returned. Although you can pass and return arguments any way you want to, the choices in
      these examples were not selected at random. They follow a logical pattern, the same one
      you'll want to use in most of your choices.
      -->
      <para>
		Puede parecer un poco confuso inicialmente cuando lea los archivos
		<filename>OverloadingUnaryOperators.cpp</filename>, <filename>Integer.h</filename>
		y <filename>Byte.h</filename> y vea todas las maneras diferentes en que se pasan y
		devuelven los argumentos. Aunque usted pueda pasar y devolver argumentos de la
		forma que prefiera, las decisiones en estos ejemplos no se han realizado al
		azar. Siguen un patrón lógico, el mismo que querrá usar en la mayoría de sus
		decisiones.
      </para>


      <!--
      1. As with any function argument, if you only need to read from the argument and not
      change it, default to passing it as a const reference. Ordinary arithmetic
      operations (like + and -, etc.) and Booleans will not change their arguments, so
      pass by const reference is predominantly what you'll use. When the function is a
      class member, this translates to making it a const member function. Only with the
      operator-assignments (like +=) and the operator=, which change the left-hand
      argument, is the left argument not a constant, but it's still passed in as an
      address because it will be changed.
      2. The type of return value you should select depends on the expected meaning of the
      operator. (Again, you can do anything you want with the arguments and return
      values.) If the effect of the operator is to produce a new value, you will need to
      generate a new object as the return value. For example, Integer::operator+ must
      produce an Integer object that is the sum of the operands. This object is returned
      by value as a const, so the result cannot be modified as an lvalue.
      3. All the assignment operators modify the lvalue. To allow the result of the
      assignment to be used in chained expressions, like a=b=c, it's expected that you
      will return a reference to that same lvalue that was just modified. But should this
      reference be a const or nonconst? Although you read a=b=c from left to right, the
      compiler parses it from right to left, so you're not forced to return a nonconst to
      support assignment chaining. However, people do sometimes expect to be able to
      perform an operation on the thing that was just assigned to, such as (a=b).func( );
      to call func( ) on a after assigning b to it. Thus, the return value for all of the
      assignment operators should be a nonconst reference to the lvalue.
      4. For the logical operators, everyone expects to get at worst an int back, and at best
      a bool. (Libraries developed before most compilers supported C++'s built-in bool
      will use int or an equivalent typedef.)
      -->
      <orderedlist>
		<listitem>
		  <para>
			Como con cualquier argumento de función, si sólo necesita leer el argumento y
			no cambiarlo, lo usual es pasarlo como una referencia
			<kw>const</kw>. Normalmente operaciones aritméticas (como <oper>+</oper> y
			<oper>-</oper>, etc.) y booleanas no cambiarán sus argumentos, así que
			pasarlas como una referencia <kw>const</kw> es lo que veré
			mayoritariamente. Cuando la función es un método, esto se traduce en una
			método <kw>const</kw>. Sólo con los operadores de asignación (como
			<oper>+=</oper>) y <function>operator=</function>, que cambian el argumento de
			la parte derecha, no es el argumento derecho una constante, pero todavía se
			pasa en dirección porque será cambiado.
		  </para>
		</listitem>
		<listitem>
		  <para>
			El tipo de valor de retorno que debe seleccionar depende del significado
			esperado del operador. (Otra vez, puede hacer cualquier cosa que desee con los
			argumentos y con los valores de retorno). Si el efecto del operador es
			producir un nuevo valor, necesitará generar un nuevo objeto como el valor de
			retorno. Por ejemplo, <function>Integer::operator+</function> debe producir un
			objeto <classname>Integer</classname> que es la suma de los operandos. Este
			objeto se devuelve por valor como una constante así que el resultado no se
			puede modificar como un <quote>valor izquierdo</quote>.
		  </para>
		</listitem>
		<listitem>
		  <para>
			Todas los operadores de asignación modifican el valor izquierdo. Para permitir
			que el resultado de la asignación pueda ser usado en expresiones encadenadas,
			como <code>a = b = c</code>, se espera que devuelva una referencia al mismo
			valor izquierdo que acaba de ser modificado. Pero ¿debería ser esta referencia
			<kw>const</kw> o no <kw>const</kw>?. Aunque lea <code>a = b = c</code> de
			izquierda a derecha, el compilador la analiza de derecha a izquierda, así que
			no está obligado a devolver una referencia no <kw>const</kw> para soportar
			asignaciones encadenadas. Sin embargo, la gente a veces espera ser capaz de
			realizar una operación sobre el elemento de acaba de ser asignado, como
			<code>(a = b).func();</code> para llamar a <function>func</function> de
			<varname>a</varname> después de asignarle <varname>b</varname>. De ese modo,
			el valor de retorno para todos los operadores de asignación debería ser una
			referencia no <kw>const</kw> para el valor izquierdo.
		  </para>
		</listitem>
		<listitem>
		  <para>
			Para los operadores lógicos, todo el mundo espera obtener en el peor de los
			casos un tipo <type>int</type>, y en el mejor un tipo <type>bool</type>. (Las
			librerías desarrolladas antes de que los compiladores de C++ soportaran el
			tipo incorporado <type>bool</type> usaban un tipo <type>int</type> o un
			<type>typedef</type> equivalente).
		  </para>
		</listitem>
      </orderedlist>
	  <!--
		  The increment and decrement operators present a dilemma because of the pre- and
		  postfix versions. Both versions change the object and so cannot treat the object
		  as a const. The prefix version returns the value of the object after it was
		  changed, so you expect to get back the object that was changed. Thus, with
		  prefix you can just return *this as a reference. The postfix version is supposed
		  to return the value before the value is changed, so you're forced to create a
		  separate object to represent that value and return it. So with postfix you must
		  return by value if you want to preserve the expected meaning. (Note that you'll
		  sometimes find the increment and decrement operators returning an int or bool to
		  indicate, for example, whether an object designed to move through a list is at
		  the end of that list.) Now the question is: Should these be returned as const or
		  nonconst? If you allow the object to be modified and someone writes (++a).func(
		  ), func( ) will be operating on a itself, but with (a++).func( ), func( )
		  operates on the temporary object returned by the postfix operator++. Temporary
		  objects are automatically const, so this would be flagged by the compiler, but
		  for consistency's sake it may make more sense to make them both const, as was
		  done here. Or you may choose to make the prefix version non-const and the
		  postfix const. Because of the variety of meanings you may want to give the
		  increment and decrement operators, they will need to be considered on a
		  case-by-case basis.
      -->

      <para>
		Los operadores de incremento y decremento presentan un dilema a causa de las
		versiones sufija y prefija. Ambas versiones cambian el objeto y por tanto no
		pueden tratar el objeto como un <kw>const</kw>. La versión prefija devuelve el
		valor del objeto después de cambiarlo, así que usted espera recuperar el objeto
		que fue cambiado. De este modo, con la versión prefija puede simplemente revolver
		<varname>*this</varname> como una referencia. Se supone que la versión sufija
		devolverá el valor antes de que sea cambiado, luego está forzado a crear un objeto
		separado para representar el valor y devolverlo. Así que con la versión sufija
		debe devolverlo por valor si quiere mantener el significado esperado. (Advierta
		que a veces encontrará operadores de incremento y decremento que devuelven un
		<type>int</type> o un <type>bool</type> para indicar, por ejemplo, que un objeto
		preparado para moverse a través de una lista está al final de ella). Ahora la
		pregunta es: ¿Debería éste devolverse como una referencia <kw>const</kw> o no
		<kw>const</kw>?. Si permite que el objeto sea modificado y alguien escribe
		<code>(a++).func()</code>, <function>func</function> operará en la propia
		<varname>a</varname>, pero con <code>(++a).func()</code>,
		<function>func</function>opera en el objeto temporal devuelto por el operador
		sufijo <function>operator++</function>. Los objetos temporales son automáticamente
		<kw>const</kw>, así que esto podría ser rechazado por el compilador, pero en favor
		de la consistencia tendría más sentido hacerlos ambos <kw>const</kw> como hemos
		hecho aquí. O puede elegir hacer la versión prefija no <kw>const</kw> y la sufija
		<kw>const</kw>. Debido a la variedad de significados que puede darle a los
		operadores de incremento y decremento, deben considerarse en términos del caso
		individual.
      </para>


      <sect3>
		<!-- : Return by value as const -->
		<title>Retorno por valor como constante</title>

        <!--
        Returning by value as a const can seem a bit subtle at first, so it deserves a bit more
        explanation. Consider the binary operator+. If you use it in an expression such as f
        (a+b), the result of a+b becomes a temporary object that is used in the call to f( ).
        Because it's a temporary, it's automatically const, so whether you explicitly make the
        return value const or not has no effect.
        -->
		<para>
		  El retorno por valor como una constante puede parecer un poco sutil al
		  principio, así que es digno de un poco más de explicación. Considere el operador
		  binario <function>operator+</function>. Si lo ve en una expresión como
		  <code>f(a+b)</code>, el resultado de <code>a+b</code> se convierte en un objeto
		  temporal que se usará en la llamada a <function>f()</function>. Debido a que es
		  temporal, es automáticamente <kw>const</kw>, así que aunque, de forma
		  explicita, haga el valor de retorno <kw>const</kw> o no, no tendrá efecto.
		</para>

        <!--
        However, it's also possible for you to send a message to the return value of a+b, rather
        than just passing it to a function. For example, you can say (a+b).g( ), in which g( )
        is some member function of Integer, in this case. By making the return value const, you
        state that only a const member function can be called for that return value. This is
        const-correct, because it prevents you from storing potentially valuable information in
        an object that will most likely be lost.
        -->
		<para>
		  Sin embargo, también es posible mandar un mensaje al valor de retorno de
		  <code>a+b</code>, mejor que simplemente pasarlo a la función. Por ejemplo, puede
		  decir <code>(a+b).g()</code> en la que <function>g()</function> es algún método
		  de <classname>Integer</classname>, en este caso. Haciendo el valor de retorno
		  <kw>const</kw>, está indicando que sólo un método <kw>const</kw> puede ser
		  llamado sobre ese valor de retorno. Esto es correcto desde el punto de vista del
		  <kw>const</kw>, porque le evita almacenar información potencialmente importante
		  en un objeto que probablemente será destruido.
		</para>
      </sect3>

      <sect3>
        <!-- : The return optimization -->
		<title>Optimización del retorno</title>

        <!--
        When new objects are created to return by value, notice the form used. In operator+, for
        example:
        -->
		<para>
		  Advierta la manera que se usa cuando se crean nuevos objetos para ser devueltos
		  por valor. En <function>operator+</function>, por ejemplo:
		</para>


<programlisting>
    return Integer(left.i + right.i);
</programlisting>

        <!--
        This may look at first like a "function call to a constructor," but it's not. The syntax
        is that of a temporary object; the statement says "make a temporary Integer object and
        return it." Because of this, you might think that the result is the same as creating a
        named local object and returning that. However, it's quite different. If you were to say
        instead:
        -->
		<para>
		  Esto puede parecer en principio como una <quote>función de llamada a un
		  constructor</quote> pero no lo es. La sintaxis es la de un objeto temporal; la
		  sentencia dice <quote>crea un objeto <classname>Integer</classname> temporal y
		  desvuélvelo</quote>. A causa de esto, puede pensar que el resultado es el mismo
		  que crear un objeto local con nombre y devolverlo. Sin embargo, es algo
		  diferente. Si en su lugar escribiera:
		</para>


<programlisting>
    Integer tmp(left.i + right.i);
    return tmp;
</programlisting>

        <!--
        three things will happen. First, the tmp object is created including its constructor
        call. Second, the copy-constructor copies the tmp to the location of the outside return
        value. Third, the destructor is called for tmp at the end of the scope.
        -->
		<para>
		  sucederían tres cosas. La primera, se crea el objeto <varname>tmp</varname>
		  incluyendo la llamada a su constructor. La segunda, el constructor de copia
		  duplica <varname>tmp</varname> en la localización del valor de retorno
		  externo. La tercera, se llama al destructor para <varname>tmp</varname> cuando
		  sale del ámbito.
		</para>

        <!--
		In contrast, the "returning a temporary" approach works quite
        differently. When the compiler sees you do this, it knows that you have no other
        need for the object it's creating than to return it. The compiler takes advantage
        of this by building the object directly into the location of the outside return
        value. This requires only a single ordinary constructor call (no copy-constructor
        is necessary) and there's no destructor call because you never actually create a
        local object. Thus, while it doesn't cost anything but programmer awareness, it's
        significantly more efficient. This is often called the return value optimization.
        -->
		<para>
		  En contraste, la aproximación de <quote>devolver un objeto temporal</quote>
		  funciona de manera bastante diferente. Cuando el compilador ve eso, sabe que no
		  tiene otra razón para crearlo mas que para devolverlo. El compilador aprovecha
		  la ventaja que ofrece para construir el objeto directamente en la localización
		  del valor de retorno externo a la función. Esto necesita de una sola y ordinaria
		  llamada al constructor (la llamada al constructor de copia no es necesaria) y no
		  hay llamadas al destructor porque nunca se crea un objeto local. De esta manera,
		  no requiere nada más que el conocimiento del programador, y es
		  significativamente mas eficiente. Esto a menudo se llama optimización del valor
		  de retorno.
		</para>
      </sect3>
    </sect2>


    <sect2>
      <!-- : Unusual operators -->
      <title>Operadores poco usuales</title>

      <!-- Several additional operators have a slightly different
      syntax for overloading. -->
	  <para>
		Varios operadores adicionales tienen una forma ligeramente diferente de ser
		sobrecargados.
	  </para>

      <!--
      The subscript, operator[ ], must be a member function and it requires a single argument.
      Because operator[ ] implies that the object it's being called for acts like an array,
      you will often return a reference from this operator, so it can be conveniently used on
      the left-hand side of an equal sign. This operator is commonly overloaded; you'll see
      examples in the rest of the book.
      -->
      <para>
		El subíndice, <function>operator[]</function> debe ser un método y precisa de un
		único argumento. Dado que <function>operator[]</function> implica que el objeto
		que está siendo utilizado como un array, a menudo devolverá una referencia de este
		operador, así que puede ser convenientemente usado en la parte derecha de un signo
		de igualdad. Este operador es muy comúnmente sobrecargado; verá ejemplos en el
		resto del libro.
      </para>

      <!--
      The operators new and delete control dynamic storage allocation and can be overloaded in
      a number of different ways. This topic is covered in the Chapter 13.
      -->
      <para>
		Los operadores <kw>new</kw> y <kw>delete</kw> controlan la reserva dinámica de
		almacenamiento y se pueden sobrecargar de muchas maneras diferentes. Este tema se
		cubre en el capitulo 13. <!-- FIXME referencia -->
      </para>


      <sect3>
		<!-- : Operator comma -->
		<title>El operador coma</title>

        <!--
        The comma operator is called when it appears next to an object of the type the comma is
        defined for. However, "operator," is not called for function argument lists, only for
        objects that are out in the open, separated by commas. There doesn't seem to be a lot of
        practical uses for this operator; it's in the language for consistency. Here's an
        example showing how the comma function can be called when the comma appears before an
        object, as well as after:
        -->
		<para>
		  El operador coma se llama cuando aparece después de un objeto del tipo para el
		  que está definido. Sin embargo, <quote><function>operator,</function></quote> no
		  se llama para listas de argumentos de funciones, sólo para objetos fuera de ese
		  lugar separados por comas. No parece haber un montón de usos prácticos para este
		  operador, solo es por consistencia del lenguaje. He aquí un ejemplo que muestra
		  como la función coma se puede llamar cuando aparece antes de un objeto, así como
		  después:
	</para>



//: V1C12:OverloadingOperatorComma.cpp


        <!--
        The global function allows the comma to be placed before the object in question. The
        usage shown is fairly obscure and questionable. Although you would probably use a
        comma-separated list as part of a more complex expression, it's too subtle to use in
        most situations.
        -->
		<para>
		  Las funciones globales permiten situar la coma antes del objeto en cuestión. El
		  uso mostrado es bastante oscuro y cuestionable. Probablemente podría una lista
		  separada por comas como parte de una expresión más complicada, es demasiado
		  refinado en la mayoría de las ocasiones.
		</para>
      </sect3>

      <sect3>
        <!-- : Operator-> -->
		<title>El operador -></title>

        <!--
        The operator-> is generally used when you want to make an object appear to be a pointer.
        Since such an object has more "smarts" built into it than exist for a typical pointer,
        an object like this is often called a smart pointer. These are especially useful if you
        want to "wrap" a class around a pointer to make that pointer safe, or in the common
        usage of an iterator, which is an object that moves through a collection /container of
        other objects and selects them one at a time, without providing direct access to the
        implementation of the container. (You'll often find containers and iterators in class
        libraries, such as in the Standard C++ Library, described in Volume 2 of this book.)
        -->
		<para>
		  El operador <oper>-></oper> se usa generalmente cuando quiere hacer que un
		  objeto parezca un puntero. Este tipo de objeto se suele llamar <emphasis>puntero
		  inteligente</emphasis> o más a menudo por su equivalente en inglés:
		  <emphasis>smart pointer</emphasis>. Resultan especialmente utiles si quiere
		  <quote>envolver</quote> una clase con un puntero para hacer que ese puntero sea
		  seguro, o en la forma común de un <classname>iterador</classname>, que es un
		  objeto que se mueve a través de una <classname>colección</classname> o
		  <classname>contenedor</classname> de otros objetos y los selecciona de uno en
		  uno cada vez, sin proporcionar acceso directo a la implementación del
		  contenedor. (A menudo encontrará iteradores y contenedores en las librerías de
		  clases, como en la Biblioteca Estándar de C++, descrita en el volumen 2 de este
		  libro).
		</para>

        <!--
        A pointer dereference operator must be a member function. It has additional, atypical
        constraints: It must return an object (or reference to an object) that also has a
        pointer dereference operator, or it must return a pointer that can be used to select
        what the pointer dereference operator arrow is pointing at. Here's a simple example:
        -->
		<para>
		  El operador de indirección de punteros (*) debe ser un método. Tiene otras
		  restricciones atípicas: debe devolver un objeto (o una referencia a un objeto)
		  que también tenga un operador de indirección de punteros, o debe devolver un
		  puntero que pueda ser usado para encontrar a lo que apunta la flecha del
		  operador de indireción de punteros. He aquí un ejemplo simple:
		</para>



//: V1C12:SmartPointer.cpp


        <!--
        The class Obj defines the objects that are manipulated in this program. The functions f
        ( ) and g( ) simply print out interesting values using static data members. Pointers to
        these objects are stored inside containers of type ObjContainer using its add( )
        function. ObjContainer looks like an array of pointers, but you'll notice there's no way
        to get the pointers back out again. However, SmartPointer is declared as a friend class,
        so it has permission to look inside the container. The SmartPointer class looks very
        much like an intelligent pointer - you can move it forward using operator++ (you can
        also define an operator- -), it won't go past the end of the container it's pointing to,
        and it produces (via the pointer dereference operator) the value it's pointing to.
        Notice that the SmartPointer is a custom fit for the container it's created for; unlike
        an ordinary pointer, there isn't a "general purpose" smart pointer. You will learn more
        about the smart pointers called "iterators" in the last chapter of this book and in
        Volume 2 (downloadable from www.BruceEckel.com).
        -->
		<para>
		  La clase <classname>Obj</classname> define los objetos que son manipulados en
		  este programa. Las funciones <function>f()</function> y <function>g()</function>
		  simplemente escriben en pantalla los valores interesantes usando miembros de
		  datos estáticos. Los punteros a estos objetos son almacenados en el interior de
		  los contenedores del tipo <classname>ObjContainer</classname> usando su función
		  <function>add()</function>. <classname>ObjContanier</classname> parece un array
		  de punteros, pero advertirá que no hay forma de traer de nuevo los punteros. Sin
		  embargo, <classname>SmartPointer</classname> se declara como una clase
		  <classname>friend</classname>, así que tiene permiso para mirar dentro del
		  contenedor. La clase <classname>SmartPointer</classname> se parece mucho a un
		  puntero inteligente - puede moverlo hacia adelante usando
		  <function>operator++</function> (también puede definir un
		  <function>operator--</function>, no pasará del final del contenedor al que
		  apunta, y genera (a través del operador de indireccion de punteros) el valor al
		  que apunta. Advierta que <classname>SmartPointer</classname> está hecho a medida
		  sobre el contenedor para el que se crea; a diferencia de un puntero normal, no
		  hay punteros inteligentes de <quote>propósito general</quote>. Aprenderá más
		  sobre los punteros inteligentes llamados <quote>iteradores</quote> en el último
		  capitulo de este libro y en el volumen 2 (descargable desde FIXME:url
		  www. BruceEckel. com).
		</para>

        <!--
        In main( ), once the container oc is filled with Obj objects, a SmartPointer sp is
        created. The smart pointer calls happen in the expressions:
        -->
		<para>
		  En <function>main()</function>, una vez que el contenedor <varname>oc</varname>
		  se rellena con objetos <classname>Obj</classname> se crea un <code>SmartPointer
		  sp</code>. La llamada al puntero inteligente sucede en las expresiones:
	</para>


 <programlisting>
     sp->f();    // Llamada al puntero inteligente
     sp->g();
 </programlisting>

        <!--
        Here, even though sp doesn't actually have f( ) and g( ) member functions, the pointer
        dereference operator automatically calls those functions for the Obj* that is returned
        by SmartPointer::operator->. The compiler performs all the checking to make sure the
        function call works properly.
        -->
		<para>
		  Aquí, incluso aunque <varname>sp</varname> no tiene métodos
		  <function>f()</function> y <function>g()</function>, el operador de indirección
		  de punteros automáticamente llama a esas funciones para <type>Obj*</type> que es
		  devuelto por <function>SmartPointer::operator-></function>. El compilador
		  realiza todas las comprobaciones pertinentes para asegurar que la llamada a
		  función funciona de forma correcta.
		</para>

        <!--
        Although the underlying mechanics of the pointer dereference operator are more complex
        than the other operators, the goal is exactly the same: to provide a more convenient
        syntax for the users of your classes.
        -->
		<para>
		  Aunque la mecánica subyacente de los operadores de indirección de punteros es
		  más compleja que la de los otros operadores, el objetivo es exactamente el
		  mismo: proporcionar una sintaxis más conveniente para los usuarios de sus
		  clases.
		</para>
      </sect3>

      <sect3>
        <!-- : A nested iterator -->
		<title>Un operador anidado</title>

        <!--
        It's more common to see a "smart pointer" or "iterator" class nested within the class
        that it services. The previous example can be rewritten to nest SmartPointer inside
        ObjContainer like this:
        -->
		<para>
		  Es más común ver un puntero inteligente o un clase iteradora anidada dentro de
		  la clase a la que sirve. Se puede reescribir el ejemplo anterior para anidar
		  <classname>SmartPointer</classname> dentro de
		  <classname>ObjContainer</classname> así:
	</para>



//: V1C12:NestedSmartPointer.cpp


        <!--
        Besides the actual nesting of the class, there are only two differences here. The first
        is in the declaration of the class so that it can be a friend:
        -->
		<para>
		  Además del anidamiento de la clase, hay solo dos diferencias aquí. La primera es
		  la declaración de la clase para que pueda ser <kw>friend</kw>:
		</para>


<programlisting>
		  class SmartPointer;
		  friend SmartPointer;
</programlisting>


        <!--
        The compiler must first know that the class exists before it can be told that it's a
        friend.
        -->
		<para>
		  El compilador debe saber primero que la clase existe, antes de que se le diga
		  que es <quote>amiga</quote>.
		</para>

        <!-- The second difference is in the ObjContainer member function begin( ), which
        produces a SmartPointer that points to the beginning of the ObjContainer
        sequence. Although it's really only a convenience, it's valuable because it
        follows part of the form used in the Standard C++ Library.  -->
		<para>
		  La segunda diferencia es en <classname>ObjContainer</classname> donde el método
		  <function>begin()</function> produce el <classname>SmartPointer</classname> que
		  apunta al principio de la secuencia del
		  <classname>ObjContainer</classname>. Aunque realmente es sólo por conveniencia,
		  es adecuado porque sigue la manera habitual de la librería estándar de C++.
		</para>
      </sect3>

      <sect3>
        <!-- : Operator->* -->
		<title>Operador ->*</title>

        <!--
        The operator->* is a binary operator that behaves like all the other binary operators.
        It is provided for those situations when you want to mimic the behavior provided by the
        built-in pointer-to-member syntax, described in the previous chapter.
        -->
		<para>
		  El operador <oper>->*</oper> es un operador binario que se comporta como todos
		  los otros operadores binarios. Se proporciona para aquellas situaciones en las
		  que quiera imitar el comportamiento producido por la sintaxis incorporada
		  <emphasis>puntero a miembro</emphasis>, descrita en el capitulo anterior.
		</para>

        <!--
        Just like operator->, the pointer-to-member dereference operator is generally used with
        some kind of object that represents a "smart pointer," although the example shown here
        will be simpler so it's understandable. The trick when defining operator->* is that it
        must return an object for which the operator( ) can be called with the arguments for the
        member function you're calling.
        -->
		<para>
		  Igual que <oper>operator-></oper>, el operador de indirección de puntero a
		  miembro se usa normalmente con alguna clase de objetos que representan un
		  <quote>puntero inteligente</quote>, aunque el ejemplo mostrado aquí será más
		  simple para que sea comprensible. El truco cuando se define
		  <function>operator->*</function> es que debe devolver un objeto para el que
		  <function>operator()</function> pueda ser llamado con los argumentos para la
		  función miembro que usted llama.
		</para>

        <!--
        The function call operator( ) must be a member function, and it is unique in that it
        allows any number of arguments. It makes your object look like it's actually a function.
        Although you could define several overloaded operator( ) functions with different
        arguments, it's often used for types that only have a single operation, or at least an
        especially prominent one. You'll see in Volume 2 that the Standard C++ Library uses the
        function call operator in order to create "function objects."
        -->
		<para>
		  La llamada a función <function>operator()</function> debe ser un método, y es
		  único en que permite cualquier número de argumentos. Hace que el objeto parezca
		  realmente una función. Aunque podría definir varias funciones sobrecargadas
		  <function>operator()</function> con diferentes argumentos, a menudo se usa para
		  tipos que solo tienen una operación simple, o al menos una especialmente
		  destacada. En el Volumen2 verá que la Librería Estándar de C++ usa el operador
		  de llamada a función para crear <quote>objetos-función</quote>.
		</para>

        <!--
        To create an operator->* you must first create a class with an operator( ) that is the
        type of object that operator->* will return. This class must somehow capture the
        necessary information so that when the operator( ) is called (which happens
        automatically), the pointer-to-member will be dereferenced for the object. In the
        following example, the FunctionObject constructor captures and stores both the pointer
        to the object and the pointer to the member function, and then the operator( ) uses
        those to make the actual pointer-to-member call:
        -->
		<para>
		  Para crear un <oper>operator->*</oper> debe primero crear una clase con un
		  <function>operator()</function> que sea el tipo de objeto que
		  <oper>operator->*</oper> devolverá.  Esta clase debe, de algún modo, capturar la
		  información necesaria para que cuando <function>operator()</function> sea
		  llamada (lo que sucede automáticamente), el puntero a miembro sea indireccionado
		  para el objeto. En el siguiente ejemplo, el constructor de
		  <classname>FunctionObject</classname> captura y almacena el puntero al objeto y
		  el puntero a la función miembro, y entonces <function>operator()</function> los
		  usa para hacer la verdadera llamada puntero a miembro:
		</para>



//: V1C12:PointerToMemberOperator.cpp


        <!--
        Dog has three member functions, all of which take an int argument and return an int. PMF
        is a typedef to simplify defining a pointer-to-member to Dog's member functions.
        -->
		<para>
		  <classname>Dog</classname> tiene tres métodos, todos toman un argumento entero y
		  devuelven un entero. <varname>PMC</varname> es un <type>typedef</type> para
		  simplificar la definición de un puntero a miembro para los métodos de
		  <classname>Dog</classname>.
		</para>

        <!--
        A FunctionObject is created and returned by operator->*. Notice that operator->* knows
        both the object that the pointer-to-member is being called for (this) and the
        pointer-to-member, and it passes those to the FunctionObject constructor that stores the
        values. When operator->* is called, the compiler immediately turns around and calls
        operator( ) for the return value of operator->*, passing in the arguments that were
        given to operator->*. The FunctionObject::operator( ) takes the arguments and then
        dereferences the "real" pointer-to-member using its stored object pointer and
        pointer-to-member.
        -->
		<para>
		  Una <function>FunctionObject</function> es creada y devuelta por
		  <oper>operator->*</oper>. Dese cuenta que <oper>operator->*</oper> conoce el
		  objeto para el que puntero a miembro está siendo llamado
		  (<varname>this</varname>) y el puntero a miembro, y los pasa al constructor
		  <function>FunctionObject</function> que almacena sus valores. Cuando se llama a
		  <oper>operator->*</oper>, el compilador inmediatamente lo revuelve y llama a
		  <function>operator()</function> para el valor de retorno de
		  <oper>operator->*</oper>, pasándole los argumentos que le fueron pasados a
		  <oper>operator->*</oper>.  <function>FunctionObject::operator()</function> toma
		  los argumentos e desreferencia el puntero a miembro <quote>real</quote> usando
		  los punteros a objeto y a miembro almacenados.
		</para>

        <!--
        Notice that what you are doing here, just as with operator->, is inserting yourself in
        the middle of the call to operator->*. This allows you to perform some extra operations
        if you need to.
        -->
		<para>
		  Percátese de que lo que está ocurriendo aquí, justo como con
		  <oper>operator-></oper>, se inserta en la mitad de la llamada a
		  <oper>operator->*</oper>. Esto permite realizar algunas operaciones adicionales
		  si se necesita.
		</para>

        <!--
        The operator->* mechanism implemented here only works for member functions that take an
        int argument and return an int. This is limiting, but if you try to create overloaded
        mechanisms for each different possibility, it seems like a prohibitive task.
        Fortunately, C++'s template mechanism (described in the last chapter of this book, and
        in Volume 2) is designed to handle just such a problem.
        -->
		<para>
		  El mecanismo <oper>operator->*</oper> implementado aquí solo trabaja para
		  funciones miembro que toman un argumento entero y devuelven otro entero. Esto es
		  una limitación, pero si intenta crear mecanismos sobrecargados para cada
		  posibilidad diferente, verá que es una tarea prohibitiva. Afortunadamente, el
		  mecanismo de plantillas de C++ (descrito el el ultimo capitulo de este libro, y
		  en el volumen2) está diseñado para manejar semejante problema.
		</para>
      </sect3>
    </sect2>



    <sect2>
      <!-- : Operators you can't overload -->
      <title>Operadores que no puede sobrecargar</title>

      <!--
      There are certain operators in the available set that cannot be overloaded. The general
      reason for the restriction is safety. If these operators were overloadable, it would
      somehow jeopardize or break safety mechanisms, make things harder, or confuse existing
      practice.
      -->
      <para>
		Hay cierta clase de operadores en el conjunto disponible que no pueden ser
		sobrecargados. La razón general para esta restricción es la seguridad. Si estos
		operadores fuesen sobrecargables, podría de algún modo arriesgar o romper los
		mecanismos de seguridad, hacer las cosas mas difíciles o confundir las costumbres
		existentes.
      </para>

      <!--
      * The member selection operator.. Currently, the dot has a meaning for any member in a
      class, but if you allow it to be overloaded, then you couldn't access members in the
      normal way; instead you'd have to use a pointer and the arrow operator->.
      * The pointer to member dereference operator.*, for the same reason as operator..
      * There's no exponentiation operator. The most popular choice for this was operator**
      from Fortran, but this raised difficult parsing questions. Also, C has no
      exponentiation operator, so C++ didn't seem to need one either because you can
      always perform a function call. An exponentiation operator would add a convenient
      notation, but no new language functionality to account for the added complexity of
      the compiler.
      * There are no user-defined operators. That is, you can't make up new operators that
      aren't currently in the set. Part of the problem is how to determine precedence, and
      part of the problem is an insufficient need to account for the necessary trouble.
      * You can't change the precedence rules. They're hard enough to remember as it is
      without letting people play with them.
      -->
      <orderedlist>
		<listitem>
		  <para>
			El operador de selección de miembros <kw>operator.</kw>. Actualmente, el punto
			tiene significado para cualquier miembro de una clase, pero si se pudiera
			sobrecargar, no se podría acceder a miembros de la forma normal; en lugar de
			eso debería usar un puntero y la flecha <function>operator-></function>.
	  </para>
		</listitem>
		<listitem>
		  <para>
			La indirección de punteros a miembros <literal>operator.*</literal> por la
			misma razón que <literal>operator.</literal>.
		  </para>
		</listitem>
		<listitem>
		  <para>
			No hay un operador de potencia. La elección más popular para éste era
			<literal>operator**</literal> de Fortram, pero provoca casos de análisis
			gramatical difíciles. C tampoco tiene un operador de potencia, así que C++ no
			parece tener necesidad de uno porque siempre puede realizar una llamada a una
			función. Un operador de potencia añadirá una notación adecuada, pero ninguna
			nueva funcionalidad a cuenta de una mayor complejidad del compilador.
		  </para>
		</listitem>
		<listitem>
		  <para>
			No hay operadores definidos por el usuario. Esto es, no puede crear nuevos
			operadores que no existan ya. Una parte del problema es como determinar la
			precedencia, y otra parte es la falta de necesidad a costa del problema
			inherente.
		  </para>
		</listitem>
		<listitem>
          <para>
            No puede cambiar las reglas de precedencia. Son lo suficientemente difíciles de
            recordar como son sin dejar a la gente jugar con ellas.
          </para>
        </listitem>
      </orderedlist>
    </sect2>
  </sect1>


<!-- revisando por aquí -->


  <sect1>
    <!-- : Non-member operators -->
    <title>Operadores no miembros</title>

    <!--
    In some of the previous examples, the operators may be members or non-members, and it
    doesn't seem to make much difference. This usually raises the question, "Which should I
    choose?" In general, if it doesn't make any difference, they should be members, to
    emphasize the association between the operator and its class. When the left-hand operand
    is always an object of the current class, this works fine.
    -->
    <para>
      En algunos de los ejemplos anteriores, los operadores pueden ser
      miembros o no miembros, y no parece haber mucha diferencia. Esto
      normalmente provoca la pregunta, <quote>¿Cual debería
      elegir?</quote>. En general, si no hay ninguna diferencia
      deberían ser miembros, para enfatizar la asociación entre el
      operador y su clase. Cuando el operando de la izquierda es
      siempre un objeto de la clase actual funciona bien.
    </para>

    <!--
    However, sometimes you want the left-hand operand to be an object of some other class. A
    common place you'll see this is when the operators << and >> are overloaded for
    iostreams. Since iostreams is a fundamental C++ library, you'll probably want to
    overload these operators for most of your classes, so the process is worth memorizing:
    -->
    <para>
      Sin embargo, a veces querrá que el operando de la izquierda sea
      un objeto de alguna otra clase. Un caso típico en el que ocurre
      eso es cuando se sobrecargan los
      operadores <oper>&lt;&lt;</oper> y
      <oper>&gt;&gt;</oper> para los flujos de entrada/salida. Dado
      que estos flujos son una librería fundamental en C++,
      probablemente querrá sobrecargar estos operadores para la
      mayoría de sus clases, por eso el proceso es digno de tratarse:
    </para>



//: V1C12:IostreamOperatorOverloading.cpp

    <!--
    This class also contains an overloaded operator [ ], which returns a reference to a
    legitimate value in the array. Because a reference is returned, the expression
    -->
    <para>
      Esta clase contiene también un operador sobrecargado
      <oper>operator[]</oper> la cual devuelve una referencia a un valor
      a licito en el array. Dado que se devuelve una referencia, la
      expresión:
    </para>


<programlisting>
    I[4] = -1;
</programlisting>

    <!--
    not only looks much more civilized than if pointers were used, it also accomplishes the
    desired effect.
    -->
    <para>
      No sólo parece mucho más adecuada que si se usaran punteros,
      también causa el efecto deseado.
    </para>

    <!--
    It's important that the overloaded shift operators pass and return by reference, so the
    actions will affect the external objects. In the function definitions, expressions like
    -->
    <para>
      Es importante que los operadores de desplazamiento sobrecargados
      pasen y devuelvan por referencia, para que los cambios afecten a
      los objetos externos. En las definiciones de las funciones,
      expresiones como:
    </para>


<programlisting>
    os &#60;&#60; ia.i[j];
</programlisting>

    <!--
    cause the existing overloaded operator functions to be called (that is, those defined in
    because ia.i[j] resolves to an int.
    -->
    <para>
      provocan que sean llamadas las funciones de los operadores
      sobrecargados(esto es, aquellas definidas en
      <classname>iostream</classname>). En este caso, la función llamada
      es <function>ostream&amp; operator&#60;&#60;(ostream&amp;,
      int)</function> dado que <varname>ia[i].j</varname> se resuelve en
      un <type>int</type>.
    </para>

    <!--
    Once all the actions are performed on the istream or ostream, it is returned so it can
    be used in a more complicated expression.
    -->
    <para>
      Una vez que las operaciones se han realizado en
      <classname>istream</classname> o en <classname>ostream</classname>
      se devuelve para que pueda ser usado en expresiones mas complejas.
    </para>

    <!--
    In main( ), a new type of iostream is used: the stringstream (declared in <sstream>).
    This is a class that takes a string (which it can create from a char array, as shown
    here) and turns it into an iostream. In the example above, this means that the shift
    operators can be tested without opening a file or typing data in on the command line.
    -->
    <para>
      En <function>main()</function> se usa un nuevo tipo de
      <classname>iostream</classname>: el
      <type>stringstream</type>(declarado en
      <classname>&#60;sstream></classname>). Esta es una clase que toma
      una cadena(que se puede crear de un array de <type>char</type>,
      como se ve aquí) y lo convierte en un
      <classname>iostream</classname>. En el ejemplo de arriba, esto
      significa que los operadores de desplazamiento pueden ser
      comprobados sin abrir un archivo o sin escribir datos en la línea
      de comandos.
    </para>

    <!--
    The form shown in this example for the inserter and extractor is standard. If you want
    to create these operators for your own class, copy the function signatures and return
    types above and follow the form of the body.
    -->
    <para>
      La manera mostrada en este ejemplo para el extractor y el
      insertador es estándar. Si quiere crear estos operadores para su
      propia clase, copie el prototipo de la función y los tipos de
      retorno de arriba y siga el estilo del cuerpo.
    </para>

    <sect2>
     <!-- : Basic guidelines -->
      <title>Directrices básicas</title>

      <!-- Murray[49] suggests these guidelines for choosing between members and non-members: -->
      <para>
	Murray
	<footnote>
	  <para>
	  Rob Murray, <citetitle pubwork="book">
	      C++ Strategies &amp; Tactics
	    </citetitle>, Addison Wesley, 1993, pagina 47.
	  </para>
	</footnote> sugiere estas reglas
	de estilo para elegir entre miembros y no miembros:
      </para>


      <table>
	<!-- TABLA Guidelines for choosing between members and non-members -->
	<title>Directrices para elegir entre miembro y no-miembro</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Operador</entry>
	      <entry>Uso recomendado</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Todos los operadores unarios</entry>
	      <entry>miembro</entry>
	    </row>
	    <row>
	      <entry>= () [] -> ->*</entry>
	      <entry><emphasis>debe</emphasis> ser miembro</entry>
	    </row>
	    <row>
	      <entry>+= -= /= *= ^= &amp;= |= %= >>=
				  &lt;&lt;=</entry>
	      <entry>miembro</entry>
	    </row>
	    <row>
	      <entry>El resto de operadores binarios</entry>
	      <entry>no miembro</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>


  <sect1>
    <!-- : Overloading assignment -->
    <title>Sobrecargar la asignación</title>

    <!--
    A common source of confusion with new C++ programmers is assignment. This is no doubt
    because the = sign is such a fundamental operation in programming, right down to copying
    a register at the machine level. In addition, the copy-constructor (described in Chapter
    11) is also sometimes invoked when the = sign is used:
    -->
    <para>
      Una causa común de confusión para los nuevos programadores de C++
      es la asignación. De esto no hay duda dado que el signo
      <literal>=</literal> es una operación fundamental en la
      programación, directamente hasta copiar un registro al nivel
      maquina. Adicionalmente, el constructor de copia (descrito en el
      capítulo 11) es llamado a veces cuando el signo
      <literal>=</literal> se usa:
    </para>


<programlisting>
    MyType b;
    MyType a = b;
    a = b;
</programlisting>

    <!--
    In the second line, the object a is being defined. A new object is being created where
    one didn't exist before. Because you know by now how defensive the C++ compiler is about
    object initialization, you know that a constructor must always be called at the point
    where an object is defined. But which constructor? a is being created from an existing
    MyType object (b, on the right side of the equal sign), so there's only one choice: the
    copy-constructor. Even though an equal sign is involved, the copy-constructor is called.
    -->
    <para>
      En la segunda línea, se define el objeto <varname>a</varname>. Se
      crea un nuevo objeto donde no existía ninguno. Dado que por ahora
      conoce como de quisquilloso es el compilador de C++ respecto a la
      inicialización de objetos, sabrá que un constructor debe siempre
      ser llamado cuando se define un objeto.
    </para>


    <para>
      ¿Pero qué constructor?, <varname>a</varname> se crea desde un
      objeto existente <classname>MyType</classname>
      (<varname>b</varname>, en el lado derecho del signo de igualdad),
      así que hay solo un elección: el constructor de copia. Incluso
      aunque el signo de igualdad está involucrado, se llama al
      constructor de copia.
    </para>

    <!--
    In the third line, things are different. On the left side of the equal sign, there's a
    previously initialized object. Clearly, you don't call a constructor for an object
    that's already been created. In this case MyType::operator= is called for a, taking as
    an argument whatever appears on the right-hand side. (You can have multiple operator=
    functions to take different types of right-hand arguments.)
    -->
    <para>
      En la tercera línea, las cosas son diferentes. En la parte
      izquierda del signo igual, hay un objeto previamente
      inicializado. Claramente, usted no llama a un constructor para un
      objeto que ya ha sido creado. En este caso
      <function>MyType::operator=</function> se llama para
      <varname>a</varname>, tomando como argumento lo que sea que
      aparezca en la parte derecha. (Puede tener varios funciones
      <function>operator=</function> que tomen diferentes argumentos en
      la parte derecha).
    </para>

    <!--
    This behavior is not restricted to the copy-constructor. Any time you're initializing an
    object using an = instead of the ordinary function-call form of the constructor, the
    compiler will look for a constructor that accepts whatever is on the right-hand side:
    -->
    <para>
      Este comportamiento no está restringido al constructor de
      copia. Cada vez que inicializa un objeto usando un signo
      <literal>=</literal> en lugar de la forma usual de llamada al
      constructor, el compilador buscará un constructor que acepte lo
      que sea que haya en la parte derecha:
    </para>



//: V1C12:CopyingVsInitialization.cpp


    <!--
    When dealing with the = sign, it's important to keep this distinction in mind: If the
    object hasn't been created yet, initialization is required; otherwise the assignment
    operator= is used.
    -->
    <para>
      Cuando se trata con el signo <oper>=</oper>, es importante
      mantener la diferencia en mente:Si el objeto ha sido creado ya, se
      requiere una inicialización;en otro caso el operador de asignación
      <oper>=</oper> se usa.
    </para>

    <!--
    It's even better to avoid writing code that uses the = for initialization; instead,
    always use the explicit constructor form. The two constructions with the equal sign then
    become:
    -->
    <para>
      Es incluso mejor el evitar escribir código que usa
      <oper>=</oper> para la inicialización; en cambio, use
      siempre la manera del constructor explícito. Las dos
      construcciones con el signo igual se convierten en:
    </para>

<programlisting>
    Fee fee(1);
    Fee fum(fi);
</programlisting>

    <!-- This way, you'll avoid confusing your readers. -->
    <para>
      De esta manera, evitará confundir a sus lectores.
    </para>


    <sect2>
      <!-- : Behavior of operator= -->
      <title>Comportamiento del operador =</title>

     <!--
      In Integer.h and Byte.h, you saw that operator= can be only a member function. It is
      intimately connected to the object on the left side of the '='. If it was possible to
      define operator= globally, then you might attempt to redefine the built-in '=' sign:
      -->
      <para>
	En <filename>Integer.h</filename> y en
	<filename>Byte.h</filename> usted vio que el operador
	<oper>=</oper> sólo puede ser una función miembro. Está
	íntimamente ligado al objeto que hay en la parte izquierda del
	<oper>=</oper>. Si fuese posible definir
	<function>operator=</function> de forma global, entonces podría
	intentar redefinir el signo incorporado <oper>=</oper>:
      </para>


<programlisting>
    int operator=(int, MyType);   // Global = !No permitido!
</programlisting>

      <!-- The compiler skirts this whole issue by forcing you to make operator= a member function. -->
      <para>
	El compilador evita esta situación obligandole a hacer una
	función miembro <function>operator=</function>.
      </para>

      <!--
      When you create an operator=, you must copy all of the necessary information from the
      right-hand object into the current object (that is, the object that operator= is being
      called for) to perform whatever you consider "assignment" for your class. For simple
      objects, this is obvious:
      -->
      <para>
	Cuando usted crea un <kw>operator=</kw>, debe copiar todo la
	información necesaria desde el objeto de la parte derecha al
	objeto actual(esto es, el objeto para el que <oper>operator=</oper> está siendo llamado) para
	realizar lo que sea que considere <quote>asignación</quote> para
	su clase. Para objetos simples, esto es trivial:
      </para>



//: V1C12:SimpleAssignment.cpp


      <!--
      Here, the object on the left side of the = copies all the elements of the object on the
      right, then returns a reference to itself, which allows a more complex expression to be
      created.
      -->
      <para>
	Aquí, el objeto de la parte izquierda del igual copia todos los
	elementos del objeto de la parte derecha, y entonces devuelve
	una referencia a sí mismo, lo que permite crear expresiones
	mas complejas.
      </para>

      <!--
      This example includes a common mistake. When you're assigning two objects of the same
      type, you should always check first for self-assignment: is the object being assigned to
      itself? In some cases, such as this one, it's harmless if you perform the assignment
      operations anyway, but if changes are made to the implementation of the class, it can
      make a difference, and if you don't do it as a matter of habit, you may forget and cause
      hard-to-find bugs.
      -->
      <para>
	Este ejemplo incluye un error comón. Cuando usted está asignando
	dos objetos del mismo tipo, siempre debería comprobar primero la
	auto asignación: ¿Está el objeto siendo asignado a sí mismo?. En
	algunos casos como éste, es inofensivo si realiza la operación
	de asignación, de todas formas, pero si se realizan cambios a la
	implementación de la clase, puede haber diferencias y si no lo
	toma con una cuestión de costumbre, puede olvidarlo y provocar
	errores difíciles de encontrar.
      </para>
      <sect3>

        <!-- : Pointers in classes -->
	<title>Punteros en clases</title>

        <!--
        What happens if the object is not so simple? For example, what if the object contains
        pointers to other objects? Simply copying a pointer means that you'll end up with two
        objects pointing to the same storage location. In situations like these, you need to do
        bookkeeping of your own.
        -->
	<para>
	  ¿Qué ocurre si el objeto no es tan simple?. Por ejemplo,
	  &iquest;qué pasa si el objeto contiene punteros a otros
	  objetos?. Simplemente copiar el puntero significa que usted
	  terminará con dos objetos apuntando a la misma localización de
	  memoria. En situaciones como ésta, necesita hacer algo de
	  contabilidad.
	</para>

        <!--
        There are two common approaches to this problem. The simplest technique is to copy
        whatever the pointer refers to when you do an assignment or a copy-construction. This is
        straightforward:
        -->
	<para>
	  Hay dos aproximaciones a este problema. La técnica mas simple
	  es copiar lo que quiera que apunta el puntero cuando realiza
	  una asignación o una construcción de copia. Es es
	  directamente:
	</para>



//: V1C12:CopyingWithPointers.cpp


        <!--
        Dog is a simple class that contains only a string that holds the name of the dog.
        However, you'll generally know when something happens to a Dog because the constructors
        and destructors print information when they are called. Notice that the second
        constructor is a bit like a copy-constructor except that it takes a pointer to a Dog
        instead of a reference, and it has a second argument that is a message that's
        concatenated to the argument Dog's name. This is used to help trace the behavior of the
        program.
        -->
	<para>
	  <classname>Dog</classname> es una clase simple que contiene
	  solo una cadena con el nombre del perro. Sin embargo,
	  generalmente sabrá cuando le sucede algo al perro dado que los
	  constructores y destructores imprimen información cuando son
	  llamados. Advierta que el segundo constructor es un poco como
	  un constructor de copia excepto que toma un puntero a
	  <classname>Dog</classname> en vez de una referencia, y tiene
	  un segundo argumento que es un mensaje a ser concatenado con
	  el nombre del perro. Esto se hace así para ayudar a rastrear
	  el comportamiento del programa.
	</para>

        <!--
        You can see that whenever a member function prints information, it doesn't access that
        information directly but instead sends *this to cout. This in turn calls the ostream
        operator<<. It's valuable to do it this way because if you want to reformat the way that
        Dog information is displayed (as I did by adding the '[' and ']') you only need to do it
        in one place.
        -->
	<para>
	  Puede ver que cuando sea que una función miembro imprime
	  información, no accede a esa información directamente sino en
	  su lugar manda <varname>*this</varname> a
	  <function>cout</function>. Este a su vez llama a
	  <function>ostream operator&#60;&#60;</function>. Es
	  aconsejable hacer esto así dado que si quiere reformatear la
	  manera en la que información del perro es mostrada(como hice
	  añadiendo el <quote>[</quote> y el <quote>]</quote>) solo
	  necesita hacerlo en un lugar.
	</para>

        <!--
        A DogHouse contains a Dog* and demonstrates the four functions you will always need to
        define when your class contains pointers: all necessary ordinary constructors, the
        copy-constructor, operator= (either define it or disallow it), and a destructor. The
        operator= checks for self-assignment as a matter of course, even though it's not
        strictly necessary here. This virtually eliminates the possibility that you'll forget to
        check for self-assignment if you do change the code so that it matters.
        -->
	<para>
	  Una <classname>DogHouse</classname> contiene un
	  <varname>Dog*</varname> y explica las cuatro funciones que
	  siempre necesitará definir cuando sus clases contengan
	  punteros:todos los constructores necesarios usuales, el
	  constructor de copia, <oper>operator=</oper> (se define o se
	  deshabilita) y un destructor. <oper>Operator=</oper> comprueba la auto
	  asignación como una cuestión de estilo, incluso aunque no es
	  estrictamente necesario aquí. Esto virtualmente elimina la
	  posibilidad de que olvide comprobar la auto asignación si
	  cambia el código.
	</para>
      </sect3>

      <sect3>
        <!-- : Reference Counting -->
	<title>Contabilidad de referencias</title>

        <!--
        In the example above, the copy-constructor and operator= make a new copy of what the
        pointer points to, and the destructor deletes it. However, if your object requires a lot
        of memory or a high initialization overhead, you may want to avoid this copying. A
        common approach to this problem is called reference counting. You give intelligence to
        the object that's being pointed to so it knows how many objects are pointing to it. Then
        copy-construction or assignment means attaching another pointer to an existing object
        and incrementing the reference count. Destruction means reducing the reference count and
        destroying the object if the reference count goes to zero.
        -->
	<para>
	  En el ejemplo de arriba, el constructor de copia y el operador
	  <oper>=</oper> realizan una copia de lo
	  que apunta el puntero, y el destructor lo borra. Sin embargo,
	  si su objeto requiere una gran cantidad de memoria o una gran
	  inicialización fija, a lo mejor puede querer evitar esta
	  copia. Una aproximación común a este problema se llama
	  <emphasis>contabilidad de referencias</emphasis>. Se le da
	  inteligencia al objeto que esta siendo apuntado de tal manera
	  que sabe cuantos objetos le están apuntado. Entonces la
	  construcción por copia o la asignación consiste en añadir otro
	  puntero a un objeto existente e incrementar la cuenta de
	  referencias. La destrucción consiste en reducir esta cuenta de
	  referencias y destruir el objeto si la cuenta llega a cero.
	</para>

        <!--
        But what if you want to write to the object (the Dog in the example above)? More than
        one object may be using this Dog, so you'd be modifying someone else's Dog as well as
        yours, which doesn't seem very neighborly. To solve this "aliasing" problem, an
        additional technique called copy-on-write is used. Before writing to a block of memory,
        you make sure no one else is using it. If the reference count is greater than one, you
        must make yourself a personal copy of that block before writing it, so you don't disturb
        someone else's turf. Here's a simple example of reference counting and copy-on-write:
        -->
	<para>
	  ¿Pero que pasa si quiere escribir el
	  objeto(<varname>Dog</varname> en el ejemplo anterior)?. Más de
	  un objeto puede estar usando este <varname>Dog</varname> luego
	  podría estar modificando el perro de alguien más a la vez que
	  el suyo, lo cual no parece ser muy amigable. Para resolver
	  este problema de <quote>solapamiento</quote> se usa una
	  técnica adicional llamada <emphasis>copia para
	  escritura</emphasis>. Antes de escribir un bloque de memoria,
	  debe asegurarse que nadie más lo está usando. Si la cuenta de
	  referencia es superior a uno, debe realizar una copia personal
	  del bloque antes de escribirlo, de tal manera que no moleste
	  el espacio de otro. He aquí un ejemplo simple de contabilidad
	  de referencias y de copia para escritura:
	</para>



//: V1C12:ReferenceCounting.cpp


        <!--
        The class Dog is the object pointed to by a DogHouse. It contains a reference count and
        functions to control and read the reference count. There's a copy-constructor so you can
        make a new Dog from an existing one.
        -->
	<para>
	  La clase <classname>Dog</classname> es el objeto apuntado por
	  <classname>DogHouse</classname>. Contiene una cuenta de
	  referencia y funciones para controlar y leer la cuenta de
	  referencias. Hay un constructor de copia luego puede crear un
	  nuevo <classname>Dog</classname> de uno existente.
	</para>

        <!--
        The attach( ) function increments the reference count of a Dog to indicate there's
        another object using it. detach( ) decrements the reference count. If the reference
        count goes to zero, then no one is using it anymore, so the member function destroys its
        own object by saying delete this.
        -->
	<para>
	  La función <function>attach()</function> incrementa la cuenta
	  de referencia de un <classname>Dog</classname> para indicar
	  que hay otro objeto usandolo. La función
	  <function>detach()</function> decrementa la cuenta de
	  referencia. Si llega a cero, entonces nadie más lo esta
	  usando, así que la función miembro destruye su propio objeto
	  llamando a <function>delete this</function>.
	</para>

       <!--
        Before you make any modifications (such as renaming a Dog), you should ensure that you
        aren't changing a Dog that some other object is using. You do this by calling
        DogHouse::unalias( ), which in turn calls Dog::unalias( ). The latter function will
        return the existing Dog pointer if the reference count is one (meaning no one else is
        pointing to that Dog), but will duplicate the Dog if the reference count is more than
        one.
        -->
	<para>
	  Antes de que haga cualquier modificación(como renombrar un
	  perro), debería asegurarse de que no está cambiando un
	  <classname>Dog</classname> que algón otro objeto está
	  usando. Hace esto llamando a <function>DogHouse::unalias()
	  </function>, la cual llama a
	  <function>Dog::unalias()</function>. Esta última función
	  devolverá el puntero a <classname>Dog</classname> existente si
	  la cuenta de referencia es uno (lo que significa que nadie mas
	  está usando ese <classname>Dog</classname>), pero duplicará
	  <classname>Dog</classname> si esa cuenta es mayor que uno.
	</para>

        <!--
        The copy-constructor, instead of creating its own memory, assigns Dog to the Dog of the
        source object. Then, because there's now an additional object using that block of
        memory, it increments the reference count by calling Dog::attach( ).
        -->
	<para>
	  El constructor de copia, además de crear su propia memoria,
	  asigna un <classname>Dog</classname> al
	  <classname>Dog</classname> del objeto fuente. Entonces, dado
	  que ahora hay un objeto más usando ese bloque de memoria,
	  incrementa la cuenta de referencia llamando a
	  <function>Dog::attach()</function>.
	</para>

        <!--
        The operator= deals with an object that has already been created on the left side of the
        =, so it must first clean that up by calling detach( ) for that Dog, which will destroy
        the old Dog if no one else is using it. Then operator= repeats the behavior of the
        copy-constructor. Notice that it first checks to detect whether you're assigning the
        same object to itself.
        -->
	<para>
	  El operador <oper>=</oper> trata con un
	  objeto que ha sido creado en la parte izquierda del
	  <oper>=</oper>, así que debe primero debe limpiarlo
	  llamando a <function>detach()</function> para ese perro, el
	  cual destruirá el viejo perro si nadie más lo está
	  usando. Entonces <oper>operator=</oper>
	  repite el comportamiento del constructor de copia. Advierta
	  que primero realiza comprobaciones para detectar cuando está
	  asignando el objeto a sí mismo.
	</para>

        <!-- The destructor calls detach( ) to conditionally destroy the Dog. -->
	<para>
	  El destructor llama a <function>detach()</function> para
	  destruir condicionalmente a <classname>Dog</classname>.
	</para>

        <!--
        To implement copy-on-write, you must control all the actions that write to your block of
        memory. For example, the renameDog( ) member function allows you to change the values in
        the block of memory. But first, it uses unalias( ) to prevent the modification of an
        aliased Dog (a Dog with more than one DogHouse object pointing to it). And if you need
        to produce a pointer to a Dog from within a DogHouse, you unalias( ) that pointer first.
        -->
	<para>
	  Para implementar la copia para escritura, debe controlar todas
	  las operaciones que escriben en su bloque de memoria. Por
	  ejemplo, la función miembro <function>renameDog()</function>
	  le permite cambiar valores en el bloque de memoria. Pero
	  primero, usa <function>unalias()</function> para prevenir la
	  modiciación de un <classname>Dog</classname> solapado (un
	  <classname>Dog</classname> con más de un objeto
	  <classname>DogHouse</classname> apuntándole). Y si necesita
	  crear un puntero a <classname>Dog</classname> desde un
	  <classname>DogHouse</classname> debe evitar el solapamiento
	  del puntero primero.
	</para>

        <!--
        main( ) tests the various functions that must work correctly to implement reference
        counting: the constructor, copy-constructor, operator=, and destructor. It also tests
        the copy-on-write by calling renameDog( ).
        -->
	<para>
	  La función <function>main()</function> comprueba las numerosas
	  funciones que deben funcionar correctamente para implementar
	  la cuenta de referencia:el constructor, el constructor de
	  copia, <oper>operator=</oper> y el
	  destructor. También comprueba la copia para escritura llamando
	  a <function>renameDog()</function>.
	</para>

        <!-- Here's the output (after a little reformatting): -->
	<para>
	  He aquí la salida (después de un poco de reformateo):
	</para>


<programlisting>
    Creando Dog: [Fido],  rc = 1
    CreadoDogHouse: [FidoHouse]
    contiene [Fido],  rc = 1
    Creando Dog: [Spot],  rc = 1
    CreadoDogHouse: [SpotHouse]
    contiene [Spot],  rc = 1
    Entrando en el constructor de copia
    Dog añadido:[Fido],  rc = 2
    DogHouse constructor de copia
    [construido por copia FidoHouse]
    contiene [Fido],  rc = 2
    Despues de la construcción por copia de Bobs
    fidos:[FidoHouse] contiene [Fido],  rc = 2
    spots:[SpotHouse] contiene [Spot],  rc = 1
    bobs:[construido por copia FidoHouse]
    contiene[Fido],  rc = 2
    Entrando spots = fidos
    Eliminando perro: [Spot],  rc = 1
    Borrando Perro: [Spot],  rc = 0
    Añadido Dog: [Fido],  rc = 3
    DogHouse operador= : [FidoHouse asignado]
    contiene[Fido],  rc = 3
    Despues de  spots = fidos
    spots:[FidoHouse asignado] contiene [Fido], rc = 3
    Entrando en la auto asignación
    DogHouse operador= : [construido por copia FidoHouse]
    contiene [Fido],  rc = 3
    Despues de la auto asignación
    bobs:[construido por copia FidoHouse]
    contiene [Fido],  rc = 3
    Entando rename("Bob")
    Despues de rename("Bob")
    DogHouse destructor: [construido por copia FidoHouse]
    contiene [Fido],  rc = 3
    Eliminando perro: [Fido],  rc = 3
    DogHouse destructor: [FidoHouse asignado]
    contiene [Fido],  rc = 2
    Eliminando perro: [Fido],  rc = 2
    DogHouse destructor: [FidoHouse]
    contiene [Fido],  rc = 1
    Eliminando perro: [Fido],  rc = 1
    Borrando perro: [Fido],  rc = 0
</programlisting>

        <!--
        By studying the output, tracing through the source code, and experimenting with the
        program, you'll deepen your understanding of these techniques.
        -->
	<para>
	  Estudiando la salida, rastreando el código fuente y
	  experimentando con el programa, podrá ahondar en la
	  comprensión de estas técnicas.
	</para>
      </sect3>

      <sect3>
        <!-- : Automatic operator= creation -->
	<title>Creación automática del operador =</title>

        <!--
        Because assigning an object to another object of the same type is an activity most
        people expect to be possible, the compiler will automatically create a type::operator=
        (type) if you don't make one. The behavior of this operator mimics that of the
        automatically created copy-constructor; if the class contains objects (or is inherited
        from another class), the operator= for those objects is called recursively. This is
        called memberwise assignment. For example,
        -->
	<para>
	  Dado que asignar un objeto a otro <emphasis>del mismo tipo
	  </emphasis> es una operación que la mayoría de la gente espera
	  que sea posible, el compilador automaticamente creará un
	  <code>type::operator=(type)</code> si usted no hace
	  uno. El comportamiento de este operador imita el del
	  constructor de copia creado automáticamente; si la clase
	  contiene objetos(o se deriva de otra clase), se llama
	  recursivamente a <oper>operator=</oper>
	  para esos objetos. A esto se le llama <emphasis>asignación
	  guiada por miembros</emphasis>. Por ejemplo
	</para>



//: V1C12:AutomaticOperatorEquals.cpp


        <!-- The automatically generated operator= for Truck calls Cargo::operator=. -->
	<para>
	  El operador <oper>=</oper> generador automáticamente
	  para <classname>Truck</classname> llama a
	  <literal>Cargo::operator=</literal>.
	</para>

        <!--
        In general, you don't want to let the compiler do this for you. With classes of any
        sophistication (especially if they contain pointers!) you want to explicitly create an
        operator=. If you really don't want people to perform assignment, declare operator= as a
        private function. (You don't need to define it unless you're using it inside the class.)
        -->
	<para>
	  En general, no querrá dejar al compilador que haga esto por
	  usted. Con clases de cualquier sofisticación (¡Especialmente
	  si contienen punteros!)querrá crear de forma explicita un
	  <oper>operator=</oper>. Si realmente no quiere que la gente
	  realice asignaciones, declare <oper>operator=</oper> como una
	  función <kw>private</kw>. (No necesita definirla a menos que
	  la esté usando dentro de la clase).
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <!-- : Automatic type conversion -->
    <title>Conversión automática de tipos</title>

    <!--
    In C and C++, if the compiler sees an expression or function call using a type that
    isn't quite the one it needs, it can often perform an automatic type conversion from the
    type it has to the type it wants. In C++, you can achieve this same effect for
    user-defined types by defining automatic type conversion functions. These functions come
    in two flavors: a particular type of constructor and an overloaded operator.
    -->
    <para>
      En C y C++, si el compilador encuentra una expresión o una llamada
      a función que usa un tipo que no es el que requiere, puede
      usualmente realizar una conversión automática de tipos desde el
      tipo que tiene hasta el tipo que necesita. En C++, puede conseguir
      este mismo efecto para los tipos definidos por el usuario creando
      funciones de conversión de tipos automática. Estas funciones se
      pueden ver en dos versiones:un tipo particular de constructores y
      un operador sobrecargado.
    </para>

    <sect2>
      <!-- : Constructor conversion -->
      <title>Conversión por constructor</title>

      <!--
      If you define a constructor that takes as its single argument an object (or reference)
      of another type, that constructor allows the compiler to perform an automatic type
      conversion. For example,
      -->
      <para>
	Si define un constructor que toma como su ónico argumento un
	objeto(o referencia) de otro tipo, ese constructor permite al
	compilador realizar una conversión automática de tipos. Por
	ejemplo:
      </para>



//: V1C12:AutomaticTypeConversion.cpp


      <!--
      When the compiler sees f( ) called with a One object, it looks at the declaration for f
      ( ) and notices it wants a Two. Then it looks to see if there's any way to get a Two
      from a One, and it finds the constructor Two::Two(One), which it quietly calls. The
      resulting Two object is handed to f( ).
      -->
      <para>
	Cuando el compilador ve <function>f()</function> llamada con un
	objeto <varname>One</varname>, mira en la declaración de
	<function>f()</function> y nota que requiere un
	<varname>Two</varname>. Entonces busca si hay alguna manera de
	conseguir un <varname>Two</varname> de un
	<varname>One</varname>, y encuentra el constructor
	<function>Two::Two(One)</function> al cual llama. El objeto
	resultante <varname>Two</varname> es pasado a
	<function>f()</function>.
      </para>

      <!--
      In this case, automatic type conversion has saved you from the trouble of defining two
      overloaded versions of f( ). However, the cost is the hidden constructor call to Two,
      which may matter if you're concerned about the efficiency of calls to f( ).
      -->
      <para>
	En este caso, la conversión automática de tipos le ha salvado
	del problema de definir dos versiones sobrecargadas de
	<function>f()</function>. Sin embargo el coste es la llamada
	oculta al constructor de <varname>Two</varname> lo cual puede
	importar si está preocupado por la eficiencia de las llamadas a
	<function>f()</function>,
      </para>

      <sect3>
        <!-- : Preventing constructor conversion -->
	<title>Evitar la conversión por constructor</title>

        <!--
        There are times when automatic type conversion via the constructor can cause problems.
        To turn it off, you modify the constructor by prefacing with the keyword explicit (which
        only works with constructors). Used to modify the constructor of class Two in the
        example above:
        -->
	<para>
	  Hay veces que la conversión automática de tipos via
	  constructor puede ocasionar problemas. Para desactivarlo,
	  modifique el constructor anteponiéndole la palabra reservada
	  <kw>explicit</kw>(que sólo funciona
	  con constructores). Así se ha hecho para modificar el
	  constructor de la clase <classname>Two</classname> en el
	  ejemplo anterior:
	</para>



//: V1C12:ExplicitKeyword.cpp


        <!--
        By making Two's constructor explicit, the compiler is told not to perform any automatic
        conversion using that particular constructor (other non-explicit constructors in that
        class can still perform automatic conversions). If the user wants to make the conversion
        happen, the code must be written out. In the code above, f(Two(one)) creates a temporary
        object of type Two from one, just like the compiler did in the previous version.
        -->
	<para>
	  Haciendo el constructor de <varname>Two</varname> explicito,
	  se le dice al compilador que no realice ninguna conversión
	  automática de tipos usando ese constructor en particular(otros
	  constructores no explicitos en esa clase pueden todavia
	  realizar conversiones automáticas). Si el usuario quiere que
	  ocurra esa conversión, debe escribir el codigo necesario. En
	  el codigo de arriba, <function>f(Two(one))</function> crea un
	  objeto temporal de tipo <varname>Two</varname> desde
	  <varname>one</varname>, justo como el compilador hizo en la
	  versión previa.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <!-- : Operator conversion -->
      <title>Conversión por operador</title>

      <!--
      The second way to produce automatic type conversion is through operator overloading. You
      can create a member function that takes the current type and converts it to the desired
      type using the operator keyword followed by the type you want to convert to. This form
      of operator overloading is unique because you don't appear to specify a return type -
      the return type is the name of the operator you're overloading. Here's an example:
      -->
      <para>
	La segunda manera de producir conversiones automáticas de tipos
	es a través de la sobrecarga de operadores. Puede crear una
	función miembro que tome el tipo actual y lo convierta en el
	tipo deseado usando la palabras reservada <oper>operator</oper> seguida del tipo al que
	quiere convertir. Esta forma de sobrecarga de operadores es
	ónica porque parece que no se especifica un tipo de retorno - el
	tipo de retorno es el nombre del operador que está
	sobrecargando. He aquí un ejemplo:
      </para>



//: V1C12:OperatorOverloadingConversion.cpp


      <!--
      With the constructor technique, the destination class is performing the conversion, but
      with operators, the source class performs the conversion. The value of the constructor
      technique is that you can add a new conversion path to an existing system as you're
      creating a new class. However, creating a single-argument constructor always defines an
      automatic type conversion (even if it's got more than one argument, if the rest of the
      arguments are defaulted), which may not be what you want (in which case you can turn it
      off using explicit). In addition, there's no way to use a constructor conversion from a
      user-defined type to a built-in type; this is possible only with operator overloading.
      -->
      <para>
	Con la técnica del constructor, la clase destino realiza la
	conversión, pero con los operadores, la realiza la clase
	origen. Lo valioso dela técnica del constructor es que puede
	añadir una nueva ruta de conversión a un sistema existente
	mientras está creando una nueva clase. Sin embargo, creando un
	constructor con un ónico argumento siempre define una conversión
	automática de tipos(incluso si requiere más de un argumento si
	el resto de los argumentos tiene un valor por defecto), que
	puede no ser lo que desea(en cuyo caso puede desactivarlo usando
	<kw>explicit</kw>). Además, no hay
	ninguna manera de usar una conversión por constructor desde un
	tipo definido por el usuario a un tipo incorporado;esto es
	posible solo con la sobrecarga de operadores.
      </para>


      <sect3>
        <!-- : Reflexivity -->
	<title>Reflexividad</title>

        <!--
        One of the most convenient reasons to use global overloaded operators instead of member
        operators is that in the global versions, automatic type conversion may be applied to
        either operand, whereas with member objects, the left-hand operand must already be the
        proper type. If you want both operands to be converted, the global versions can save a
        lot of coding. Here's a small example:
	-->
	<para>
	  Una de las razones mas normales para usar operadores
	  sobrecargados globales en lugar de operadores miembros es que
	  en la versión global, la conversión automática de tipos puede
	  aplicarse a cualquiera de los operandos, mientras que con
	  objetos miembro, el operando de la parte izquierda debe ser
	  del tipo apropiado. Si quiere que ambos operandos sean
	  convertidos, la versión global puede ahorrarle un montón de
	  código. He aquí un pequeño ejemplo:
	</para>



//: V1C12:ReflexivityInOverloading.cpp


        <!--
        Class Number has both a member operator+ and a friend operator-. Because there's a
        constructor that takes a single int argument, an int can be automatically converted to a
        Number, but only under the right conditions. In main( ), you can see that adding a
        Number to another Number works fine because it's an exact match to the overloaded
        operator. Also, when the compiler sees a Number followed by a + and an int, it can match
        to the member function Number::operator+ and convert the int argument to a Number using
        the constructor. But when it sees an int, a +, and a Number, it doesn't know what to do
        because all it has is Number::operator+, which requires that the left operand already be
        a Number object. Thus, the compiler issues an error.
        -->
	<para>
	  La clase <classname>Number</classname> tiene tanto un miembro
	  <oper>operator+</oper> como un <oper>firiend
	  operator-</oper>. Dado que hay un constructor que acepta un
	  argumento <type>int</type> simple, un <type>int</type> puede
	  ser convertido automáticamente a un <type>Number</type>, pero
	  sólo bajo las condiciones adecuadas. En
	  <function>main()</function>, puede ver que añadir un
	  <type>Number</type> a otro <type>Number</type> funciona bien
	  dado que tiene una correspondencia exacta con el operador
	  sobrecargado. Además, cuando el compilador ve un
	  <type>Number</type> seguido de un <oper>+</oper> y de un
	  <type>int</type>, puede emparejarlo a la función miembro
	  <function>Number::operator+</function> y convertir el
	  argumento<type>int</type> a un <type>Number</type> usando el
	  constructor. Pero cuando ve un <type>int</type>, un
	  <oper>+</oper> y un <type>Number</type>, no sabe que hacer
	  porque todo lo que tiene es <oper>Number::operator+</oper> el
	  cual requiere que el operando de la izquierda sea ya un objeto
	  <type>Number</type>. Así que, el compilador emite un error.
	</para>

        <!--
        With the friend operator-, things are different. The compiler needs to fill in both its
        arguments however it can; it isn't restricted to having a Number as the left-hand
        argument. Thus, if it sees
        -->
	<para>
	  Con <oper>friend operator-</oper> las
	  cosas son diferentes. El compilador necesita rellenar ambos
	  argumentos como quiera que pueda; no está restringido a tener
	  un <type>Number</type> como argumento de la parte
	  izquierda. así que si ve:
	</para>


<programlisting>
    1 - a
</programlisting>

        <!-- it can convert the first argument to a Number using the constructor. -->
	<para>
	  puede convertir el primer argumento a un <type>Number</type>
	  usando el constructor.
	</para>

       <!--
        Sometimes you want to be able to restrict the use of your operators by making them
        members. For example, when multiplying a matrix by a vector, the vector must go on the
        right. But if you want your operators to be able to convert either argument, make the
        operator a friend function.
        -->
	<para>
	  A veces querrá ser capaz de restringir el uso de sus
	  operadores haciéndolos miembros. Por ejemplo, cuando
	  multiplique una matriz por un vector, el vector debe ir en la
	  derecha. Pero si quiere que sus operadores sean capaces de
	  convertir cualquier argumento, haga el operador una función
	  <kw>friend</kw>.
	</para>

        <!--
        Fortunately, the compiler will not take 1 - 1 and convert both arguments to Number
        objects and then call operator-. That would mean that existing C code might suddenly
        start to work differently. The compiler matches the "simplest" possibility first, which
        is the built-in operator for the expression 1 - 1.
        -->
	<para>
	  Afortunadamente, el compilador cogerá la expresión
	  <code>1-1</code> y convertirá ambos
	  argumentos a objetos <classname>Number</classname> y despues
	  llamará a <oper>operator-</oper>. Eso
	  significaría que el código C existente pudiera empezar a
	  funcionar de forma diferente. El compilador encaja la
	  posibilidad mas simple primero, la cual es el operador
	  incorporado para la expresión
	  <code>1-1</code>.
	</para>
      </sect3>
    </sect2>


    <sect2>
      <!-- : Type conversion example -->
      <title>Ejemplo de conversión de tipos</title>

      <!--
      An example in which automatic type conversion is extremely helpful occurs with any class
      that encapsulates character strings (in this case, we will just implement the class
      using the Standard C++ string class because it's simple). Without automatic type
      conversion, if you want to use all the existing string functions from the Standard C
      library, you have to create a member function for each one, like this:
      -->
      <para>
	Un ejemplo en el que la conversión automática de tipos es
	extremadamente útil es con cualquier clase que encapsule una
	cadena de caracteres(en este caso, simplemente implementaremos
	la clase usando la clase estándar de C++ <type>string</type>
	dado que es simple). Sin la conversión automática de tipos, si
	quiere usar todas las funciones existentes de string de la
	librería estándar de C, tiene que crear una función miembro para
	cada una, así:
      </para>



//: V1C12:Strings1.cpp


      <!--
      Here, only the strcmp( ) function is created, but you'd have to create a corresponding
      function for every one in <cstring> that might be needed. Fortunately, you can provide
      an automatic type conversion allowing access to all the functions in <cstring>:
      -->
      <para>
	Aquí, sólo se crea la función <function>strcmp()</function>,
	pero tendría que crear las correspondientes funciones para cada
	una de <filename>&#60;cstring></filename> que
	necesitará. Afortunadamente, puede proporcionar una conversión
	automática de tipos permitiendo el acceso a todas las funciones
	de <classname>cstring</classname>.
      </para>



//: V1C12:Strings2.cpp


      <!--
      Now any function that takes a char* argument can also take a Stringc argument because
      the compiler knows how to make a char* from a Stringc.
      -->
      <para>
	Ahora cualquier función que tome un argumento <type>char*</type>
	puede tomar también un argumento <classname>Stringc</classname>
	porque el compilador sabe como crear un <type>char*</type> de un
	<classname>Stringc</classname>.
      </para>
    </sect2>


    <sect2>
      <!-- : Pitfalls in automatic type conversion -->
      <title>Las trampas de la  conversión automática de tipos</title>

      <!--
      Because the compiler must choose how to quietly perform a type conversion, it can get
      into trouble if you don't design your conversions correctly. A simple and obvious
      situation occurs with a class X that can convert itself to an object of class Y with an
      operator Y( ). If class Y has a constructor that takes a single argument of type X, this
      represents the identical type conversion. The compiler now has two ways to go from X to
      Y, so it will generate an ambiguity error when that conversion occurs:
      -->
      <para>
	Dado que el compilador debe elegir como realizar una conversión
	de tipos, puede meterse en problemas si no usted no diseña las
	conversiones correctamente. Una situación obvia y simple sucede
	cuando una clase <classname>X</classname> que puede convertirse
	a sí misma en una clase <classname>Y</classname> con un
	<oper>operator Y()</oper>. Si la clase <classname>Y</classname>
	tiene un constructor que toma un argumento simple de tipo
	<classname>X</classname>, esto representa la conversión de tipos
	por identidad. El compilador ahora tiene dos formas de ir de
	<classname>X</classname> a <classname>Y</classname>, así que se
	generará una error de ambigüedad cuando esa conversión ocurra:
      </para>



//: V1C12:TypeConversionAmbiguity.cpp


      <!--
      The obvious solution to this problem is not to do it. Just provide a single path for
      automatic conversion from one type to another.
      -->
      <para>
	La solución obvia a este problema es no hacerla. Simplemente
	proporcione una ruta ónica para la conversión automática de un
	tipo a otro.
      </para>

      <!--
      A more difficult problem to spot occurs when you provide automatic conversion to more
      than one type. This is sometimes called fan-out:
      -->
      <para>
	Un problema más difícil de eliminar sucede cuando proporciona
	conversiones automáticas a más de un tipo. Esto se llama a veces
	<emphasis>acomodamiento</emphasis>:
      </para>



//: V1C12:TypeConversionFanout.cpp


      <!--
      Class Apple has automatic conversions to both Orange and Pear. The insidious thing about
      this is that there's no problem until someone innocently comes along and creates two
      overloaded versions of eat( ). (With only one version, the code in main( ) works fine.)
      -->
      <para>
	La clase <classname>Apple</classname> tiene conversiones
	automáticas a <classname>Orange</classname> y a
	<classname>Pear</classname>. El elemento capcioso sobre esto es
	que no hay problema hasta que alguien inocentemente crea dos
	versiones sobrecargadas de <function>eat()</function>. (Con sólo
	una versión el codigo en <function>main()</function> funciona
	correctamente).
      </para>

      <!--
      Again, the solution - and the general watchword with automatic type conversion - is to
      provide only a single automatic conversion from one type to another. You can have
      conversions to other types; they just shouldn't be automatic. You can create explicit
      function calls with names like makeA( ) and makeB( ).
      -->
      <para>
	De nuevo la solución - y el lema general de la conversión
	automática de tipos- es proveer solo una ónica conversión
	automática de un tipo a otro. Puede tener conversiones a otros
	tipos, sólo que no deberían ser
	<emphasis>automaticas</emphasis>. Puede crear llamadas a
	funciones explicitas con nombres como
	<function>makeA()</function> y <function>makeB()</function>.
      </para>

      <sect3>
        <!-- : Hidden activities -->
	<title>Actividades ocultas</title>

        <!--
        Automatic type conversion can introduce more underlying activities than you may expect.
        As a little brain teaser, look at this modification of CopyingVsInitialization.cpp:
        -->
	<para>
	  La conversión automática de tipos puede producir mas actividad
	  subyacente de la que podría esperar. Mire esta modificación de
	  <filename>CopyingVsInitialization.cpp</filename> como un juego
	  de inteligencia:
	</para>



//: V1C12:CopyingVsInitialization2.cpp


        <!--
        There is no constructor to create the Fee fee from a Fo object. However, Fo has an
        automatic type conversion to a Fee. There's no copy-constructor to create a Fee from a
        Fee, but this is one of the special functions the compiler can create for you. (The
        default constructor, copy-constructor, operator=, and destructor can be synthesized
        automatically by the compiler.) So for the relatively innocuous statement
        -->
	<para>
	  No hay un constructor para crear <varname>Fee fee</varname> de
	  un objeto <classname>Fo</classname>. Sin embargo,
	  <classname>Fo</classname> tiene una conversión automática de
	  tipos a <classname>Fee</classname>. No hay un constructor de
	  copia para crear un <classname>Fee</classname> de un
	  <classname>Fee</classname>, pero esta es una de las funciones
	  especiales que el compilador puede crear por usted. (El
	  constructor por defecto, el constructor de copia y
	  <oper>operator=</oper>) y el destructor puede sintetizarse
	  automáticamente por el compilador. Así que para la
	  relativamente inocua expresión:
	</para>


<programlisting>
Fee fee = fo;
</programlisting>


        <!-- the automatic type conversion operator is called, and a copy-constructor is created. -->
	<para>
	  el operador de conversión automática es llamado, y se crea un
	  constructor de copia.
	</para>

        <!--
        Use automatic type conversion carefully. As with all operator overloading, it's
        excellent when it significantly reduces a coding task, but it's usually not worth using
        gratuitously.
        -->
	<para>
	  Use la conversión automática de tipos con precaución. Como con
	  toda la sobrecarga de operadores, es excelente cuando reduce
	  la tarea de codificación significativamente, pero no vale la
	  pena usarla de forma gratuita.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>

    <!--
    The whole reason for the existence of operator overloading is for those situations when
    it makes life easier. There's nothing particularly magical about it; the overloaded
    operators are just functions with funny names, and the function calls happen to be made
    for you by the compiler when it spots the right pattern. But if operator overloading
    doesn't provide a significant benefit to you (the creator of the class) or the user of
    the class, don't confuse the issue by adding it.
    -->
    <para>
      La completa razón para la existencia de la sobrecarga de
      operadores es para aquellas situaciones cuando simplifica la
      vida. No hay nada particularmente mágico sobre ello;los operadores
      sobrecargados son solo funciones con nombres divertidos, y las
      llamadas a función son llamadas por el compilador para usted
      cuando se satisface el patrón adecuado. Pero si la sobrecarga de
      operadores no proporciona un beneficio significativo para usted(el
      creador de la clase) o para el usuario de la clase, no complique
      el asunto añadiéndolo.
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>
	<!-- Create a simple class with an overloaded operator++. Try
	calling this operator in both pre- and postfix form and see
	what kind of compiler warning you get.  -->
	<para>
	  Cree una clase sencilla con un operador sobrecargado
	  <oper>++</oper>. Intente llamar a este operador en la forma
	  prefija y posfija y vea que clase de advertencia del
	  compilador obtiene.
	</para>
      </listitem>
      <listitem>
	<!-- Create a simple class containing an int and overload the
	operator+ as a member function. Also provide a print( ) member
	function that takes an ostream& as an argument and prints to
	that ostream&. Test your class to show that it works
	correctly.  -->
	<para>
	  Cree una clase sencilla que contenga un <type>int</type> y
	  sobrecargue el operador <oper>+</oper>
	  como una función miembro. También cree una función miembro
	  <function>print()</function> que tome un
	  <classname>ostream&amp;</classname> como un argumento y lo
	  imprima a un
	  <classname>ostream&amp;</classname>. Experimente con su
	  clase para comprobar que funciona correctamente.
	</para>
      </listitem>
      <listitem>

	<!-- Add a binary operator- to Exercise 2 as a member
	function. Demonstrate that you can use your objects in complex
	expressions like --><para> Añada un operador binario
	<oper>-</oper> al ejercicio 2 como una función
	miembro. Demuestre que puede usar sus objetos in expresiones
	complejas como <literal>a + b -c</literal>.
	</para>
      </listitem>
      <listitem>
	<!-- Add a binary operator- to Exercise 2 as a member
	function. Demonstrate that you can use your objects in complex
	expressions like -->
	<para>
	  Añada un operador <oper>++</oper> y
	  otro <oper>--</oper> al ejercicio 2,
	  ambos con las versiones prefijas y postfijas, tales que
	  devuelvan el objeto incrementado o decrementado. Asegurese
	  que la versión posfija devuelve el valor adecuado.
	</para>
      </listitem>
      <listitem>
	<!-- Add an operator++ and operator -.- to Exercise 2, both the
	prefix and the postfix versions, such that they return the
	incremented or decremented object. Make sure that the postfix
	versions return the correct value.  -->
	<para>
	  Modifique los operadores de incremento y de decremento del
	  ejercicio 4 para que la versión prefija devuelva a
	  referencia no <kw>const</kw> y la
	  posfija devuelva un objeto <kw>const</kw>. Muestre que funcionan
	  correctamente y explique por qué esto se puede hacer en la
	  práctica.
	</para>
      </listitem>
      <listitem>
	<!-- Change the print( ) function in Exercise 2 so that it is
	the overloaded operator<< as in
	IostreamOperatorOverloading.cpp.  -->

	<para>
	  Cambie la función <function>print()</function> del
	  ejercicio2 para que use el operador sobrecargado <oper>&#60;&#60;</oper> como en
	  <filename>IostreamOperatorOverloading.cpp</filename>.
	</para>
      </listitem>
      <listitem>
	<!-- Modify Exercise 3 so that the operator+ and operator- are
	non-member functions. Demonstrate that they still work
	correctly.  -->
	<para>
	  Modifique el ejercicio 3 para que los operadores
	  <oper>+</oper> y <oper>-</oper> sean funciones no
	  miembro. Demuestre que todavía funcionan correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- Add the unary operator- to Exercise 2 and demonstrate
	that it works correctly.  -->
	<para>
	  Añada el operador unario <oper>-</oper> al ejercicio 2 y demuestre que
	  funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class that contains a single private
	char. Overload the iostream operators << and >> (as in
	IostreamOperatorOverloading.cpp) and test them. You can test
	them with fstreams, stringstreams, and cin and cout.  -->
	<para>
	  Cree una clase que contenga un único <type>private
	    char</type>. Sobrecargue los operadores de flujos de
	  entrada/salida <oper>&#60;&#60;</oper> y
	  <oper>>></oper>(como en
	  <filename>IostreamOperatorOverloading.cpp</filename>) y
	  pruebelos. Puede probarlos con <literal>fstreams</literal>,
	  <literal>stringstreams</literal> y <literal>cin</literal> y
	  <literal>cout</literal> .
	</para>
      </listitem>
      <listitem>
	<!-- Determine the dummy constant value that your compiler
	passes for postfix operator++ and operator-.-.  -->
	<para>
	  Determine el valor constante ficticio que su compilador pasa
	  a los operadores posfijos <oper>++</oper> y
	  <oper>--</oper>.
	</para>
      </listitem>
      <listitem>
	<!-- Write a Number class that holds a double, and add
	overloaded operators for +, , *, /, and assignment. Choose the
	return values for these functions so that expressions can be
	chained together, and for efficiency. Write an automatic type
	conversion operator intdouble( ).  -->
	<para>
	  Escriba una clase <classname>Number</classname> que contenga
	  un <type>double</type> y añada operadores sobrecargados para
	  <oper>+</oper>, <oper>-</oper>, <oper>*</oper>, <oper>/</oper> y la asignación. Elija los
	  valores de retorno para estas funciones para que las
	  expresiones puedan ser encadenadas juntas y para que sea
	  eficiente.  Escriba una conversión automática de tipos
	  <type>operator int()</type>.
	</para>
      </listitem>
      <listitem>
	<!-- Modify Exercise 11 so that the return value optimization
	is used, if you have not already done so.  -->
	<para>
	  Modifique el ejercicio 11 para que use la
	  <emphasis>optimización del valor de retorno</emphasis>, si
	  todavía no lo ha hecho.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class that contains a pointer, and demonstrate
	that if you allow the compiler to synthesize the operator= the
	result of using that operator will be pointers that are
	aliased to the same storage. Now fix the problem by defining
	your own operator= and demonstrate that it corrects the
	aliasing. Make sure you check for self-assignment and handle
	that case properly.  -->
	<para>
	  Cree una clase que contenga un puntero, y demuestre que si
	  permite al compilador sintetizar el operador <oper>=</oper> el resultado de usar ese
	  operador serán punteros que estarán solapados en la misma
	  localización de memoria. Ahora arregle el problema
	  definiendo su propio operador <oper>=</oper> y demuestre que corrige el
	  solapamiento. Asegórese que comprueba la auto asignación y
	  que maneja el caso apropiadamente.
	</para>
      </listitem>
      <listitem>
	<!-- Write a class called Bird that contains a string member
	and a static int. In the default constructor, use the int to
	automatically generate an identifier that you build in the
	string, along with the name of the class (Bird #1, Bird #2,
	etc.). Add an operator<< for ostreams to print out the Bird
	objects. Write an assignment operator= and a
	copy-constructor. In main( ), verify that everything works
	correctly.  -->
	<para>
	  Escriba una clase llamada <classname>Bird</classname> que
	  contenga un miembro <type>string</type> y un <type>static
	    int</type>. El el constructor por defecto, use el
	  <type>int</type> para generar automáticamente un
	  identificador que usted construya en la <type>string</type>
	  junto con el nombre de la clase(<varname>Bird #1</varname>,
	  <varname>Bird #2</varname>, etc). Añada un operador <oper>&#60;&#60;</oper> para flujos de salida
	  para imprimir los objetos
	  <classname>Bird</classname>-Escriba un operador de
	  asignación <oper>=</oper> y un
	  constructor de copia. En <function>main()</function>
	  verifique que todo funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- Write a class called BirdHouse that contains an object, a
	pointer and a reference for class Bird from Exercise 14. The
	constructor should take the three Birds as arguments. Add an
	operator<< for ostreams for BirdHouse. Write anDisallow the
	assignment operator= and a copy-constructor. In main( ),
	verify that everything works correctly. Make sure that you can
	chain assignments for BirdHouse objects and build expressions
	involving multiple operators.  -->
	<para>
	  Escriba una clase llamada <classname>BirdHouse</classname>
	  que contenga un objeto, un puntero y una referencia para la
	  clase <classname>Bird</classname> del ejercicio 14. El
	  constructor debería tomar 3 <classname>Birds</classname>
	  como argumentos. Añada un operador <oper>&#60;&#60;</oper> de flujo de salida para
	  <classname>BirdHouse</classname>. Deshabilite el operador de
	  asignación <oper>=</oper> y el
	  constructor de copia. En <function>main()</function>
	  verifique que todo funciona correctamente. Asegórese de que
	  puede encadenar asignaciones para objetos
	  <classname>BirdHouse </classname> y construya expresiones
	  que involucren a móltiples operadores.
	</para>
      </listitem>
      <listitem>
	<!-- Add an int data member to both Bird and BirdHouse in
	Exercise 15. Add member operators +, -, *, and / that use the
	int members to perform the operations on the respective
	members. Verify that these work.  -->
	<para>
	  Añada un miembro de datos <type>int</type> a
	  <classname>Bird</classname> y a
	  <classname>BirdHouse</classname> en el ejercicio 15. Añada
	  operadores miembros <oper>+</oper>,
	  <oper>-</oper>, <oper>*</oper> y <oper>/</oper> que usen el miembro
	  <type>int</type> para realizar las operaciones en los
	  respectivos miembros. Verifique ques estas funcionan.
	</para>
      </listitem>
      <listitem>
	<!-- Repeat Exercise 16 using non-member operators.  -->
	<para>
	  Repita el ejercicio 16 usando operadores no miembros.
	</para>
      </listitem>
      <listitem>

	<!-- Add an operator-.- to SmartPointer.cpp and
	NestedSmartPointer.cpp.  -->
	<para>
	  Añada un operador <oper>-</oper> a
	  <filename>SmartPointer.cpp</filename> y a
	  <filename>NestedSmartPointer.cpp</filename>.
	</para>
      </listitem>
      <listitem>

	<!-- Modify CopyingVsInitialization.cpp so that all of the
	constructors print a message that tells you what's going
	on. Now verify that the two forms of calls to the
	copy-constructor (the assignment form and the parenthesized
	form) are equivalent.  -->
	<para>
	  Modifique <filename>CopyingVsInitialization.cpp</filename>
	  para que todos los constructores impriman un mensaje que
	  cuente que está pasando. Ahora verifique que las dos maneras
	  de llamar al constructor de copia(la de asignación y la de
	  parentesis) son equivalentes.
	</para>
      </listitem>
      <listitem>

	<!-- Attempt to create a non-member operator= for a class and
	see what kind of compiler message you get.  -->
	<para>
	  Intente crear un operador no miembro <oper>=</oper> para una clase y vea que clase
	  de mensaje del compilador recibe.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class with an copy-constructor assignment
	operator that has a second argument, a string that has a
	default value that says CC op= call. Create a function that
	takes assigns an object of your class by value to another one
	and show that your copy-constructorassignment operator is
	called correctly.  -->
	<para>
	  Cree una clase con un operador de asignación que tenga un
	  segundo argumento, una <classname>string</classname> que
	  tenga un valor por defecto que diga <quote>op =
	    call</quote>. Cree una función que asigne un objeto de su
	  clase a otro y muestre que su operador de asignación es
	  llamado correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- In CopyingWithPointers.cpp, remove the operator= in
	DogHouse and show that the compiler-synthesized operator=
	correctly copies the string but simply aliases the Dog
	pointer.  -->
	<para>
	  En <filename>CopyingWithPointers.cpp</filename> elimine el
	  operador <oper>=</oper> en
	  <classname>DogHouse</classname> y muestre el el operador
	  <oper>=</oper> sintetizado por el
	  compilador copia correctamente <classname>string</classname>
	  pero simplemente solapa el puntero a
	  <classname>Dog</classname>.
	</para>
      </listitem>
      <listitem>
	<!-- In ReferenceCounting.cpp, add a static int and an
	ordinary int as data members to both Dog and DogHouse. In all
	constructors for both classes, increment the static int and
	assign the result to the ordinary int to keep track of the
	number of objects that have been created. Make the necessary
	modifications so that all the printing statements will say the
	int identifiers of the objects involved.  -->
	<para>
	  En <filename>ReferenceCounting.cpp</filename> añada un
	  <type>static int</type> y un <type>int</type> ordinario como
	  miembros de datos a <classname>Dog</classname> y a
	  <classname>DogHouse</classname>. En todos los constructores
	  para ambas clases, incremente el <type>static int</type> y
	  asigne el resultado al <type>int</type> ordinario para
	  mantener un seguimiento del nómero de objetos que están
	  siendo creados. Haga las modificaciones necesarias para que
	  todas las sentencias de impresin muestren los
	  identificadores <type>int</type> de los objetos
	  involucrados.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class containing a string as a data
	member. Initialize the string in the constructor, but do not
	create a copy-constructor or operator=. Make a second class
	that has a member object of your first class; do not create a
	copy-constructor or operator= for this class
	either. Demonstrate that the copy-constructor and operator=
	are properly synthesized by the compiler.  -->

	<para>
	  Cree una clase que contenga un <classname>string</classname>
	  como un mimebro de datos. Inicialice el
	  <classname>string</classname> en el constructor, pero no cree
	  un constructor de copia o un operador <oper>=</oper>. Haga una
	  segunda clase que tenga un objeto miembro de su primera
	  clase;no cree un constructor de copia o un operador
	  <oper>=</oper> para esta clase tampoco. Demuestre que el
	  constructor de copia y el operador <oper>=</oper> son
	  sintetizados correctamente por el compilador.
	</para>
      </listitem>
      <listitem>
	<!-- Combine the classes in OverloadingUnaryOperators.cpp and
	Integer.cpp.  -->
	<para>
	  Combine las clases en
	  <filename>OverloadingUnaryOperators.cpp</filename> y en
	  <filename>Integer.cpp</filename>.
	</para>
      </listitem>
      <listitem>
	<!-- Modify PointerToMemberOperator.cpp by adding two new
	member functions to Dog that take no arguments and return
	void. Create and test an overloaded operator->* that works
	with your two new functions.  -->
	<para>
	  Modifique <filename>PointerToMemmberOperator.cpp</filename>
	  añadiendo dos nuevas funciones miembro a
	  <classname>Dog</classname> que no tomen argumentos y
	  devuelvan <type>void</type>. Cree y compruebe un operador
	  sobrecargado <oper>->*</oper> que
	  funcione con sus dos nuevas funciones.
	</para>
      </listitem>
      <listitem>
	<!-- Add an operator->* to NestedSmartPointer.cpp.  -->
	<para>
	  Añada un operador <oper>->*</oper> a
	  <filename>NestedSmartPointer.cpp</filename>.
	</para>
      </listitem>
      <listitem>
	<!-- Create two classes, Apple and Orange. In Apple, create a
	constructor that takes an Orange as an argument. Create a
	function that takes an Apple and call that function with an
	Orange to show that it works. Now make the Apple constructor
	explicit to demonstrate that the automatic type conversion is
	thus prevented. Modify the call to your function so that the
	conversion is made explicitly and thus succeeds.  -->
	<para>
	  Cree dos clases, <classname>Apple</classname> y
	  <classname>Orange</classname>. En
	  <classname>Apple</classname>, cree un constructor que tome
	  una <classname>Orange</classname> como un argumento. Cree
	  una función que tome un <classname>Apple</classname> y llame
	  a esa función con una una <classname>Orange</classname> para
	  demostrar que funciona. Ahora haga explicito el constructor
	  de <classname>Apple</classname> para demostrar que la
	  conversión automática de tipos es prevenida así. Modifique
	  la llamada a su función para que la la conversión se haga
	  explicitamente y así funcione.
	</para>
      </listitem>
      <listitem>
	<!-- Add a global operator* to ReflexivityInOverloading.cpp
	and demonstrate that it is reflexive.  -->
	<para>
	  Añada un operador global <oper>*</oper> a
	  <filename>ReflexivityInOverloading.cpp</filename> y
	  demuestre que es reflexivo.
	</para>
      </listitem>
      <listitem>
	<!-- Create two classes and create an operator+ and the
	conversion functions such that addition is reflexive for the
	two classes.  -->
	<para>
	  Cree dos clases y un operador <oper>+</oper> y las funciones de conversión de
	  tal manera que la adicción sea reflexiva para las dos clases.
	</para>
      </listitem>
      <listitem>

	<!-- Fix TypeConversionFanout.cpp by creating an explicit
	function to call to perform the type conversion, instead of
	one of the automatic conversion operators.  -->
	<para>
	  Arregle <filename>TypeConversionFanout.cpp</filename> creando
	  una  función explicita para realizar la conversión de tipo,
	  en lugar de uno de los operadoes de conversión automáticos.
	</para>
      </listitem>
      <listitem>
	<!-- Write simple code that uses the +, -, *, and / operators
	for doubles. Figure out how your compiler generates assembly
	code and look at the assembly language that's generated to
	discover and explain what's going on under the hood.  -->
	<para>
	  Escriba un código simple que use los operadores
	  <oper>+</oper>, <oper>-</oper>, <oper>*</oper>, <oper>/</oper>
	  para <type>double</type>. Imaginese como el compilador genera
	  el codigo ensamblador y mire el ensamblador que se genera para
	  descubir y explicar que está ocurriendo bajo el envoltorio.
	</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>




<!-- Local Variables: -->
<!-- mode: flyspell -->
<!-- fill-column: 90 -->
<!-- End: -->
