<?xml  version="1.0" encoding="iso-8859-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: José María Requena López
                       (anterior a LuCaS)
  Formateado DocBook:  Miguel Ángel García Martínez
  1ª Revisión:         David Villa
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C12">

  <title>Sobrecarga de operadores</title>

  <highlights>
    <!-- Operator overloading is just "syntactic sugar", which means
    it is simply another way for you to make a function call.  -->
    <para>
      La sobrecarga de operadores es solamente <quote>azúcar
      sintáctico</quote>, lo que significa que es simplemente otra
      manera de invocar funciones.
    </para>
  </highlights>

  <para>
  <!--
  The difference is that the arguments for this function don't appear inside parentheses,
  but instead they surround or are next to characters you've always thought of as
  immutable operators.
  -->
    La diferencia es que los argumentos para estas funciones no
    aparecen entre paréntesis, sino que rodean o siguen a los
    caracteres que siempre pensó como operadores inalterables.
  </para>

  <para>
  <!--
  There are two differences between the use of an operator and an ordinary function call.
  The syntax is different; an operator is often "called" by placing it between or
  sometimes after the arguments. The second difference is that the compiler determines
  which "function" to call. For instance, if you are using the operator + with
  floating-point arguments, the compiler "calls" the function to perform floating-point
  addition (this "call" is typically the act of inserting in-line code, or a
  floating-point-processor instruction). If you use operator + with a floating-point
  number and an integer, the compiler "calls" a special function to turn the int into a
  float, and then "calls" the floating-point addition code.
  -->
    Hay dos diferencias entre el uso de un operador y el de una llamada
    a función normal. La sintaxis es diferente: un operador es a menudo
    <quote>llamado</quote> situándolo entre (o después de) los
    argumentos.  La segunda diferencia es que el compilador determina
    qué <quote>función</quote> llamar. Por ejemplo, si usted está usando
    el operador <oper>+</oper> con argumentos de punto flotante, el
    compilador <quote>llama</quote> a la función para realizar una suma
    de punto flotante (esta <quote>llamada</quote> es normalmente el
    acto de insertar código en linea, o una instrucción de punto
    flotante del procesador). Si usa el operador <oper>+</oper> con un
    nómero de punto flotante y un entero, el compilador
    <quote>llama</quote> a una función especial para convertir el
    <type>int</type> a un <type>float</type>,y entonces
    <quote>llama</quote> a la función de suma de punto flotante.
  </para>

  <para>
  <!--
  But in C++, it's possible to define new operators that work with classes. This
  definition is just like an ordinary function definition except that the name of the
  function consists of the keyword operator followed by the operator. That's the only
  difference, and it becomes a function like any other function, which the compiler calls
  when it sees the appropriate pattern.
  -->
    Sin embargo, en C++ es posible definir nuevos operadores que
    trabajen con clases. Esta definición es exactamente como la
    defición de una función ordinaria, excepto que el nombre de
    la función consiste en la palabra reservada <kw>operator</kw> seguida del
    operador. Siendo esta la única diferencia, el operador se
    convierte en una función como otra cualquiera que el
    compilador llama cuando ve el prototipo adecuado.
  </para>

  <sect1>
    <!-- : Warning & reassurance -->
    <title>Precaución y tranquilidad </title>

    <!--
    It's tempting to become overenthusiastic with operator overloading. It's a fun toy, at
    first. But remember it's only syntactic sugar, another way of calling a function.
    Looking at it this way, you have no reason to overload an operator except if it will
    make the code involving your class easier to write and especially easier to read.
    (Remember, code is read much more than it is written.) If this isn't the case, don't
    bother.
    -->
    <para>
      Es tentador convertirse en un super-entusiasta de la
      sobrecarga de operadores. Son un juguete divertido,
      inicialmente. Pero recuerde que es sólo un endulzamiento
      sintáctico, otra manera de llamar a una función. Mirándolo
      desde esa perspectiva, no hay razón para sobrecargar un
      operador excepto si eso hace al código implicado con la
      clase más sencillo e intuitivo de escribir y especialmente
      de leer. (Recuerde, el código se lee mucho más que se
      escribe). Si éste no es el caso no se moleste.
    </para>

    <!--
    Another common response to operator overloading is panic; suddenly, C operators have no
    familiar meaning anymore. "Everything's changed and all my C code will do different
    things!" This isn't true. All the operators used in expressions that contain only
    built-in data types cannot be changed. You can never overload operators such that
    -->
    <para>
      Otra reacción cmún frente al uso de la sobrecarga de
      operadores es el pánico: de repente, los operadores de C
      pierden su significado familiar.<quote>¡Todo ha cambiado y
      mi código C por completo hará cosas
      diferentes!</quote>. Esto no es verdad. Todos los
      operadores usados en expresiones que contienen solo tipos
      de datos incorporados no pueden ser cambiados. Nunca podrá
      sobrecargar operadores así
    </para>


<programlisting>
    1 &lt;&lt; 4;
</programlisting>

    <!-- behaves differently, or -->
    <para>
      para que se comporten de forman diferente, o
    </para>


<programlisting>
    1.414 &lt;&lt; 2;
</programlisting>

    <!--
    has meaning. Only an expression containing a user-defined type can have an overloaded
    operator.
    -->
    <para>
      que tengan significado. Sólo una expresión que contenga tipos de
      datos definidos por el usuario podrá tener operadores
      sobrecargados.
    </para>

  </sect1>


  <sect1>
    <!-- : Syntax -->
    <title>Sintaxis</title>

    <!--
    Defining an overloaded operator is like defining a function, but the name of that
    function is operator@, in which @ represents the operator that's being overloaded. The
    number of arguments in the overloaded operator's argument list depends on two factors:
    -->
    <para>
      Definir un operador sobrecargado es como definir una función, pero
      el nombre de esa función es <function>operator@</function> en la
      que <oper>arroba</oper> representa el
      operador que está siendo sobrecargado. El número de argumentos en
      la lista de argumentos del operador sobrecargado depende de dos
      factores:
    </para>

    <!--
    1. Whether it's a unary operator (one argument) or a binary operator (two arguments).
    2. Whether the operator is defined as a global function (one argument for unary, two
    for binary) or a member function (zero arguments for unary, one for binary - the
    object becomes the left-hand argument).
    -->
    <orderedlist>
      <listitem>
	<para>
	  Si es un operador unario (un argumento) o un operador
	binario (dos argumentos) </para>
      </listitem>
      <listitem>
	<para>
	  Si el operador es definido como una función global (un
	  argumento para los unarios, dos para los binarios) o
	  una función miembro (cero argumentos para los unarios y
	  uno para los binarios. En este último caso el objeto
	  (this) se convierte en el argumento del lado izquierdo
	  al operador).
	</para>
      </listitem>
    </orderedlist>

    <!-- Here's a small class that shows the syntax for operator overloading: -->
    <para>
      He aquí una pequeña clase que muestra la sintaxis de la
      sobrecarga de operadores:
    </para>



//: V1C12:OperatorOverloadingSyntax.cpp


    <!--
    The two overloaded operators are defined as inline member functions that announce when
    they are called. The single argument is what appears on the right-hand side of the
    operator for binary operators. Unary operators have no arguments when defined as member
    functions. The member function is called for the object on the left-hand side of the
    operator.
    -->
    <para>
      Los dos operadores sobrecargados son definidos como
      funciones miembros en línea que imprimen un mensaje al ser
      llamados. El único argumento de estas funciones miembro
      será el que aparezca del lado derecho del operador
      binario. Los operadores unarios no tienen argumentos cuando
      son definidos como funciones miembro. La función miembro es
      llamada por el objeto de la parte izquierda del operador.
    </para>

    <!--
    For non-conditional operators (conditionals usually return a Boolean value), you'll
    almost always want to return an object or reference of the same type you're operating on
    if the two arguments are the same type. (If they're not the same type, the
    interpretation of what it should produce is up to you.) This way, complicated
    expressions can be built up:
    -->
    <para>
      Para los operadores incondicionales (los condicionales
      generalmente devuelven un valor booleano), generalmente se
      deseará devolver un objeto o una referencia del mismo tipo
      que está operando, si los dos argumentos son del mismo
      tipo. (Si no son del mismo tipo, la interpretación de lo
      que debería pasar es responsabilidad nuestra). De esta
      manera, se pueden construir expresiones tan complicadas
      como la siguiente:
    </para>


<programlisting>
    kk += ii + jj ;
</programlisting>


    <!--
    The operator+ produces a new Integer (a temporary) that is used as the rv argument for
    the operator+=. This temporary is destroyed as soon as it is no longer needed.
    -->
    <para>
      La expresión <function>operator+</function> crea un nuevo
      objeto <classname>Integer</classname> (temporal) que se usa
      como el argumento <varname>rv</varname> para el operador
      <function>operator+=</function>. Este objeto temporal se
      destruye tan pronto como deja de necesitarse.
    </para>

  </sect1>


  <sect1>
    <!-- : Overloadable operators -->
    <title>Operadores sobrecargables </title>

    <!--
    Although you can overload almost all the operators available in C, the use of operator
    overloading is fairly restrictive. In particular, you cannot combine operators that
    currently have no meaning in C (such as ** to represent exponentiation), you cannot
    change the evaluation precedence of operators, and you cannot change the number of
    arguments required by an operator. This makes sense - all of these actions would produce
    operators that confuse meaning rather than clarify it.
    -->
    <para>
      Aunque usted puede sobrecargar casi todos los operadores
      disponibles en C, el uso de operadores sobrecargados es
      bastante restrictivo. En particular, usted no puede
      combinar operadores que actualmente no tienen significado
      en C (como <oper>**</oper> para
      representar la potencia), no puede cambiar la prioridad de
      evaluación de operadores, y tampoco el número de argumentos
      requeridos por un operador. Estas restricciones existen
      para prevenir que la creación de nuevos operadores ofusquen
      el significado más que clarificarlo.</para>

   <!--
    The next two subsections give examples of all the "regular" operators, overloaded in the
    form that you'll most likely use.
    -->
    <para>
      Las siguientes dos subsecciones muestran ejemplos de
      todos los operadores normales, sobrecargados en la forma
      que usted mas comúnmente usará.
    </para>

    <sect2>
      <!-- : Unary operators -->
      <title>Operadores unarios</title>

      <!--
      The following example shows the syntax to overload all the unary operators, in the form
      of both global functions (non-member friend functions) and as member functions. These
      will expand upon the Integer class shown previously and add a new byte class. The
      meaning of your particular operators will depend on the way you want to use them, but
      consider the client programmer before doing something unexpected.
      -->

      <!-- Here is a catalog of all the unary functions: -->
      <para>
	El ejemplo siguiente muestra la sintaxis para sobrecargar
	todos los operadores unarios, en ambas formas: como
	funciones globales (funciones <kw>friend</kw> que no son funciones
	miembro) y como funciones miembroenderá la clase
	<classname>Integer</classname> vista previamente y
	añadirá una nueva clase <classname>byte</classname>. El
	significado de sus operadores particulares dependerá de
	la forma en que los use, pero considere a los
	programadores del grupo antes de hacer algo inesperado.
	He aquí un catálogo de todas las funciones unarias:
      </para>



//: V1C12:OverloadingUnaryOperators.cpp


      <!--
      The functions are grouped according to the way their arguments are passed. Guidelines
      for how to pass and return arguments are given later. The forms above (and the ones that
      follow in the next section) are typically what you'll use, so start with them as a
      pattern when overloading your own operators.
      -->
      <para>
	Las funciones están agrupadas de acuerdo a la forma en que se
	pasan los argumentos.  Más tarde se darán unas cuantas
	directivas de cómo pasar y devolver argumentos. Las clases
	expuestas anteriormente (y las que siguen en la siguiente
	sección) son las típicas que usted usará, asi que empiece con
	ellas como un patrón cuando sobrecargue sus propios operadores.
      </para>

      <sect3>
        <!-- : Increment & decrement -->
	<title>Incremento y decremento</title>

        <!--
        The overloaded ++ and - - operators present a dilemma because you want to be able to
        call different functions depending on whether they appear before (prefix) or after
        (postfix) the object they're acting upon. The solution is simple, but people sometimes
        find it a bit confusing at first. When the compiler sees, for example, ++a (a
        pre-increment), it generates a call to operator++(a); but when it sees a++, it generates
        a call to operator++(a, int). That is, the compiler differentiates between the two forms
        by making calls to different overloaded functions. In OverloadingUnaryOperators.cpp for
        the member function versions, if the compiler sees ++b, it generates a call to
        B::operator++( ); if it sees b++ it calls B::operator++(int).
        -->


	<para>
	  Los operadores de incremento<oper>++</oper> y de decremento
	  <oper>--</oper> provocan un conflicto porque querrá ser capaz
	  de llamar diferentes funciones dependiendo de si aparecen
	  antes(prefijo) o después(posfija) del objeto sobre el que
	  actuan. La solución es simple, pero la gente a veces lo
	  encuentra un poco confuso inicialmente. Cuando el compilador
	  ve, por ejemplo, <code>++a</code> (un
	  preincremento), genera una llamada al
	  <function>operator++(a)</function> pero cuando ve
	  <literal>a++</literal>, genera una llamada a
	  <function>operator++(a, int)</function>. Asi es como el
	  compilador diferencia entre los dos tipos, generando llamadas
	  a funciones sobrecargadas diferentes. En
	  <filename>OverloadingUnaryOperators.cpp</filename> para la
	  versión de funciones miembro, si el compilador ve
	  <code>++b</code>, genera una llamada a
	  <function>B::operator++()</function>y si be
	  <code>b++</code>genera una llamada a
	  <function>B::operator++(int)</function>.
	</para>

	        <!--
        All the user sees is that a different function gets called for the prefix and postfix
        versions. Underneath, however, the two functions calls have different signatures, so
        they link to two different function bodies. The compiler passes a dummy constant value
        for the int argument (which is never given an identifier because the value is never
        used) to generate the different signature for the postfix version.
        -->
	<para>
  Todo lo que el
	  usuario ve es que una función diferente es llamada para las
	  versiones posfija y prefija. Ocultamente, sin embargo, las dos
	  llamadas de funciones tienen diferentes firmas, asi que
	  conectan con dos diferentes cuerpos. El compilador pasa un
	  valor constante ficticio para el argumento <type>int</type>(el
	  cual nunca es proporcionado por un identificador porque el
	  valor nunca se usa) para generar las diferentes firmas para la
	  versión posfija.
	</para>
      </sect3>
    </sect2>
    <sect2>

      <!-- : Binary operators -->
      <title>Operadores binarios</title>

      <!--
      The following listing repeats the example of OverloadingUnaryOperators.cpp for binary
      operators so you have an example of all the operators you might want to overload. Again,
      both global versions and member function versions are shown.
      -->
      <para>
	El listado siguiente repite el ejemplo de
	<filename>OverloadingUnaryOperators.cpp</filename> para los
	operadores binarios presentándole un ejemplo de todos los
	operadores que usted pueda querer sobrecargar. De nuevo se
	muestran ambas versiones, la global y la de función miembro.
      </para>



 //: V1C12:Integer.h

      <!--
      You can see that operator= is only allowed to be a member function. This is explained
      later.
      -->
      <para>

      </para>


 //: V1C12:Integer.cpp


      <para>

      </para>


 //: V1C12:IntegerTest.cpp




 //: V1C12:Byte.h




//: V1C12:ByteTest.cpp


      <!--
      Notice that all of the assignment operators have code to check for self-assignment; this
      is a general guideline. In some cases this is not necessary; for example, with operator+
      = you often want to say A+=A and have it add A to itself. The most important place to
      check for self-assignment is operator= because with complicated objects disastrous
      results may occur. (In some cases it's OK, but you should always keep it in mind when
      writing operator=.)
      -->
      <para>
	Puede ver como a <function>operator=</function> sólo se
	le permite ser una función miembro. Esto se explicará mas
	adelante.  Advierta que todos los operadores de
	asignación tienen codigo para comprobar la auto
	asignación; esta es una directiva general. En algunos
	casos esto no es necesario; por ejemplo, con
	<function>operator+=</function> a menudo usted querrá
	decir <literal>A+=A</literal> y sumar
	<varname>A</varname> a sí mismo. El lugar más importante
	para situar las comprobaciones para la auto asignación es
	<function>operator=</function> porque con objetos
	complicados pueden ocurrir resultados desastrosos. (En
	algunos casos es correcto, pero siempre se debería
	tenerlo en mente cuando escriba
	<function>operator=</function>).
      </para>

      <para>
	<!--
      All of the operators shown in the previous two examples are overloaded to handle a
      single type. It's also possible to overload operators to handle mixed types, so you can
      add apples to oranges, for example. Before you start on an exhaustive overloading of
      operators, however, you should look at the section on automatic type conversion later in
      this chapter. Often, a type conversion in the right place can save you a lot of
      overloaded operators.
      -->
	Todos los operadores mostrados en los dos ejemplos previos son
	sobrecargados para manejar un tipo simple. También es posible
	sobrecargar operadores para manejar tipos compuestos, de manera
	que pueda sumar manzanas a naranjas, por ejemplo. Antes de que
	empiece una sobrecarga exhaustiva de operadores, no obstante,
	deberia mirar la sección de conversión automática de tipos mas
	adelante en este capitulo. A menudo, una conversión de tipos en
	el lugar adecuado puede ahorrarle un montón de operadores
	sobrecargados
      </para>
    </sect2>


    <sect2>
      <!-- : Arguments & return values -->
      <title>Argumentos y valores de retorno</title>

      <!--
      It may seem a little confusing at first when you look at OverloadingUnaryOperators.cpp,
      Integer.h and Byte.h and see all the different ways that arguments are passed and
      returned. Although you can pass and return arguments any way you want to, the choices in
      these examples were not selected at random. They follow a logical pattern, the same one
      you'll want to use in most of your choices.
      -->
      <para>
	Puede parecer un poco confuso inicialmente cuando mira a los
	archivos <filename>OverloadingUnaryOperators.cpp</filename>,
	<filename>Integer.h</filename> y <filename>Byte.h</filename> y
	vea todas las diferentes maneras en que los argumentos son
	pasados y devueltos. Aunque usted pueda pasar y devolver
	argumentos de la forma que prefiera, las elecciones en estos
	ejemplos no se han realizado al azar. Siguen un patrón lógico,
	el mismo que usted usará en la mayoría de sus elecciones.
      </para>


      <!--
      1. As with any function argument, if you only need to read from the argument and not
      change it, default to passing it as a const reference. Ordinary arithmetic
      operations (like + and -, etc.) and Booleans will not change their arguments, so
      pass by const reference is predominantly what you'll use. When the function is a
      class member, this translates to making it a const member function. Only with the
      operator-assignments (like +=) and the operator=, which change the left-hand
      argument, is the left argument not a constant, but it's still passed in as an
      address because it will be changed.
      2. The type of return value you should select depends on the expected meaning of the
      operator. (Again, you can do anything you want with the arguments and return
      values.) If the effect of the operator is to produce a new value, you will need to
      generate a new object as the return value. For example, Integer::operator+ must
      produce an Integer object that is the sum of the operands. This object is returned
      by value as a const, so the result cannot be modified as an lvalue.
      3. All the assignment operators modify the lvalue. To allow the result of the
      assignment to be used in chained expressions, like a=b=c, it's expected that you
      will return a reference to that same lvalue that was just modified. But should this
      reference be a const or nonconst? Although you read a=b=c from left to right, the
      compiler parses it from right to left, so you're not forced to return a nonconst to
      support assignment chaining. However, people do sometimes expect to be able to
      perform an operation on the thing that was just assigned to, such as (a=b).func( );
      to call func( ) on a after assigning b to it. Thus, the return value for all of the
      assignment operators should be a nonconst reference to the lvalue.
      4. For the logical operators, everyone expects to get at worst an int back, and at best
      a bool. (Libraries developed before most compilers supported C++'s built-in bool
      will use int or an equivalent typedef.)
      -->
      <orderedlist>
	<listitem>
	  <para>
	    Como con cualquier argumento de función, si sólo
	    necesita leer el argumento y no cambiarlo, lo usual
	    es pasarlo como una referencia <kw>const</kw>. Normalmente
	    operaciones aritméticas (como <oper>+</oper> y <oper>-</oper>, etc.) y booleanas no
	    cambiarán sus argumentos, así que pasarlas como una
	    referencia <kw>const</kw> es
	    lo que usted vera mayoritariamente. Cuando la función
	    es un miembro de una clase, esto se traduce en hacer
	    una función miembro <kw>const</kw>. Sólo con los
	    operadores de asignación(como <oper>+=</oper>) y
	    <function>operator=</function>, que cambian el
	    argumento de la parte derecha, no es el argumento
	    derecho una constante, pero todavía se pasa en
	    dirección porque será cambiado.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    El tipo de valor de retorno que debe seleccionar depende del
	    significado esperado del operador. (Otra vez, puede hace
	    cualquier cosa que desee con los argumentos y con los
	    valores de retorno). Si el efecto del operador es producir
	    un nuevo valor, necesitará generar un nuevo objeto como el
	    valor de retorno. Por ejemplo,
	    <function>Integer::operator+</function> debe producir un
	    objeto <classname>Integer</classname> que es la suma de los
	    operandos. Este objeto se devuelve por valor como una
	    constante así que el resultado no puede ser modificado como
	    un valor izquierdo.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Todas las operadores de asignación modifican el valor
	    izquierdo. Para permitir al resultado de la asignación ser
	    usado en expresiones encadenadas, como
	    <literal>a=b=c</literal>, se espera que devuelva una
	    referencia al mismo valor izquierdo que acaba de ser
	    modificado. ¡Pero debería ser esta referencia <kw>const</kw> o no <kw>const</kw>?. Aunque lee
	    <kw>a=b=c</kw>de izquierda a derecha, el
	    compilador la analiza de derecha a izquierda, asi que no
	    esta obligado a devolver una referencia no <kw>const</kw> para soportar asignaciones
	    encadenadas. Sin embargo, la gente a veces espera ser capaz
	    de realizar una operación sobre el elemento de acaba de ser
	    asignado, como
	    <code>(a=b).func();</code> para llamar a
	    <function>func</function> de <varname>a</varname> después de
	    asignarle <varname>b</varname>. De ese modo, el valor de
	    retorno para todos los operadores de asignación debería ser
	    una referencia no <kw>const</kw>
	    para el valor izquierdo.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Para los operadores lógicos, todo el mundo espera obtener en
	    el peor de los casos un tipo <type>int</type>, y en el mejor
	    un tipo <type>bool</type>. (Las librerías desarrolladas
	    antes de que los compiladores de C++ soportaran el tipo
	    incorporado <type>bool</type>usaran un tipo <type>int</type>
	    o un <type>typedef</type> equivalente).
	  </para>
	</listitem>
      </orderedlist>
     <!--
      The increment and decrement operators present a dilemma because of the pre- and postfix
      versions. Both versions change the object and so cannot treat the object as a const. The
      prefix version returns the value of the object after it was changed, so you expect to
      get back the object that was changed. Thus, with prefix you can just return *this as a
      reference. The postfix version is supposed to return the value before the value is
      changed, so you're forced to create a separate object to represent that value and return
      it. So with postfix you must return by value if you want to preserve the expected
      meaning. (Note that you'll sometimes find the increment and decrement operators
      returning an int or bool to indicate, for example, whether an object designed to move
      through a list is at the end of that list.) Now the question is: Should these be
      returned as const or nonconst? If you allow the object to be modified and someone writes
      (++a).func( ), func( ) will be operating on a itself, but with (a++).func( ), func( )
      operates on the temporary object returned by the postfix operator++. Temporary objects
      are automatically const, so this would be flagged by the compiler, but for consistency's
      sake it may make more sense to make them both const, as was done here. Or you may choose
      to make the prefix version non-const and the postfix const. Because of the variety of
      meanings you may want to give the increment and decrement operators, they will need to
      be considered on a case-by-case basis.
      -->

      <para>
	Los operadores de incremento y de decremento presentan un dilema
	a causa de las versiones posfija y prefija. Ambas versiones
	cambian el objeto y por tanto no pueden tratar el objeto como un
	<kw>const</kw>. La versión prefija devuelve el valor del objeto
	después de que sea cambiado, asi que usted espera recuperar el
	objeto que fue cambiado. De este modo, con la versión prefija
	puede simplemente revolver <varname>*this</varname> como una
	referencia. La versión posfija se supone que devolverá el valor
	antes de que sea cambiado, luego está forzado a crear un objeto
	separado para representar el valor y devolverlo. Así que con la
	version posfija debe devolverlo por valor si quiere mantener el
	sifgnificado esperado. (Advierta que a veces usted encuentra los
	operadores de incremento y de decremento devolviendo un
	<type>int</type> o un <varname>bool</varname> para indicar, por
	ejemplo, cuando un objeto preparado para moverse a través de una
	lista esta al final de ella). Ahora la pregunta es:¿Debería éste
	ser devuelto como una referencia <kw>const</kw>o no
	<kw>const</kw>?. Si permite que el objeto sea modificado y
	alguien escribe <code>(a++).func()</code>,
	<function>func</function> operará en la propia
	<varname>a</varname>, pero con
	<code>(++a).func()</code>,
	<function>func</function>opera en el objeto temporal devuelto
	por el operador posfijo <function>operator++</function>. Los
	objetos temporales son automáticamente <kw>const</kw>,
	asi que esto podría ser rechazado por el compilador, pero en
	favor de la consistencia tendría más sentido hacerlos ambos
	<kw>const</kw> como hemos hecho aquí. O puede elegir
	hacer la versión prefija no <kw>const</kw> y la
	posfija <kw>const</kw>. Debido a la variedad de
	significados que puede darle a los operadores de incremento y de
	decremento, necesitarán ser considerados en términos del caso
	individual.
      </para>

      <sect3>
	<!-- : Return by value as const -->
	<title>Retorno por valor como constante</title>

        <!--
        Returning by value as a const can seem a bit subtle at first, so it deserves a bit more
        explanation. Consider the binary operator+. If you use it in an expression such as f
        (a+b), the result of a+b becomes a temporary object that is used in the call to f( ).
        Because it's a temporary, it's automatically const, so whether you explicitly make the
        return value const or not has no effect.
        -->
	<para>
	  La devolución por valor como una constante puede parecer un
	  poco sutil en principio, asi que es digna de un poco mas de
	  explicación. Considere el operador binario
	  <function>operator+</function>. Si lo ve en una expresión como
	  <code>f(a+b)</code>, el resultado de
	  <code>a+b</code> se convierte en un objeto
	  temporal que se usará en la llamada a
	  <function>f()</function>. Debido a que es temporal, es
	  automáticamente <kw>const</kw>, así
	  que aunque usted de, forma explicita, haga el valor de
	  retorno <kw>const</kw>o no, no tendrá
	  efecto.
	</para>

        <!--
        However, it's also possible for you to send a message to the return value of a+b, rather
        than just passing it to a function. For example, you can say (a+b).g( ), in which g( )
        is some member function of Integer, in this case. By making the return value const, you
        state that only a const member function can be called for that return value. This is
        const-correct, because it prevents you from storing potentially valuable information in
        an object that will most likely be lost.
        -->
	<para>
	  Sin embargo es también posible mandar un mensaje para devolver
	  el valor <code>a+b</code>, mejor que
	  simplemente pasarlo a la función. Por ejemplo, puede decir
	  <code>(a+b).g()</code> en la que
	  <function>g()</function> es alguna función miembro de
	  <classname>Integer</classname>, en este caso. Haciendo el
	  valor de retorno <kw>const</kw>,
	  declara que sólo una función miembro <kw>const</kw> puede ser llamada para ese
	  valor de retorno. Esto es correcto desde el punto de vista del
	  <kw>const</kw>, porque previene de
	  que almacene información potencialmente importante en un
	  objeto que será casi seguro destruido.
	</para>
      </sect3>

      <sect3>
        <!-- : The return optimization -->
	<title>Optimización del retorno</title>

        <!--
        When new objects are created to return by value, notice the form used. In operator+, for
        example:
        -->
	<para>
	  Advierta la manera que se usa cuando se crean nuevos objetos
	  para ser devueltos. En <function>operator+</function>, por
	  ejemplo:
	</para>


<programlisting>
    return Integer(left. i + right. i);
</programlisting>

        <!--
        This may look at first like a "function call to a constructor," but it's not. The syntax
        is that of a temporary object; the statement says "make a temporary Integer object and
        return it." Because of this, you might think that the result is the same as creating a
        named local object and returning that. However, it's quite different. If you were to say
        instead:
        -->
	<para>
	  Esto puede parecer en principio como una función de llamada de
	  a un constructor pero no lo es. La sintaxis es la de un objeto
	  temporal;la sentencia dice <quote>crea un objeto
	  <classname>Integer</classname> temporal y
	  desvuélvelo</quote>. A causa de esto, puede pensar que el
	  resultado es el mismo que crear un objeto local con nombre y
	  devolverle. Sin embargo, es algo diferente. Si quisiera decir
	  en cambio:
	</para>


<programlisting>
    Integer tmp(left. i + right. i);
    return tmp;
</programlisting>

        <!--
        three things will happen. First, the tmp object is created including its constructor
        call. Second, the copy-constructor copies the tmp to the location of the outside return
        value. Third, the destructor is called for tmp at the end of the scope.
        -->
	<para>
	  tres cosas sucederán. La primera, el objeto
	  <varname>tmp</varname> es creado incluyendo la llamada a su
	  constructor. La segunda, el constructor de copia duplica
	  <varname>tmp</varname> a la localización del valor de retorno
	  externo. La tercera, se llama al destructor para
	  <varname>tmp</varname> cuando sale del ámbito.
	</para>

        <!--
        In contrast, the "returning a temporary" approach works quite differently. When the
        compiler sees you do this, it knows that you have no other need for the object it's
        creating than to return it. The compiler takes advantage of this by building the object
        directly into the location of the outside return value. This requires only a single
        ordinary constructor call (no copy-constructor is necessary) and there's no destructor
        call because you never actually create a local object. Thus, while it doesn't cost
        anything but programmer awareness, it's significantly more efficient. This is often
        called the return value optimization.
        -->
	<para>
	  En contraste, la aproximación de <quote>devolver un objeto
	  temporal</quote> funciona de manera bastante diferente. Cuando
	  el compilador ve que usted hace esto, sabe que no tiene otra
	  razón para crearlo mas que para devolverlo. El compilador
	  aprovecha la ventaja que esto da para construir el objeto
	  directamente en la localización del valor de retorno externo a
	  la función. Esto necesita de una sola y ordinaria llamada al
	  constructor(la llamada al constructor de copia no es
	  necesaria) y no hay llamadas al destructor porque nunca se
	  crea un objeto local. De esta manera, mientras que no cuesta
	  nada mas que el conocimiento del programador, es
	  significativamente mas eficiente. Esto es llamado a menudo la
	  optimización del valor de retorno.
	</para>
      </sect3>
    </sect2>


    <sect2>
      <!-- : Unusual operators -->
      <title>Operadores poco usuales</title>

      <!-- Several additional operators have a slightly different
      syntax for overloading. -->

      <!--
      The subscript, operator[ ], must be a member function and it requires a single argument.
      Because operator[ ] implies that the object it's being called for acts like an array,
      you will often return a reference from this operator, so it can be conveniently used on
      the left-hand side of an equal sign. This operator is commonly overloaded; you'll see
      examples in the rest of the book.
      -->
      <para>
	Varios operadores adicionales tienen una forma ligeramente
	diferente de ser sobrecargados.  El subíndice,
	<function>operator[]</function> debe ser una función miembro y
	precisa de un argumento simple. Dado que
	<function>operator[]</function> implica que el objeto que está
	siendo utilizado como un array, usted a menudo devolverá una
	referencia de este operador, asi que puede ser convenientemente
	usado en la parte derecha de un signo de igualdad. Esto operador
	es muy comónmente sobrecargado;verá ejemplos en el resto del
	libro.
      </para>

      <!--
      The operators new and delete control dynamic storage allocation and can be overloaded in
      a number of different ways. This topic is covered in the Chapter 13.
      -->
      <para>
	Los operadores <kw>new</kw> y <kw>delete</kw> controlan la reserva dinámica
	de almacenamiento y pueden ser sobrecargados de muchas maneras
	diferentes. Este tema esta cubierto en el capitulo 13.
      </para>
<!-- FIXME referencia -->

      <sect3>
	<!-- : Operator comma -->
	<title>El operador coma</title>

        <!--
        The comma operator is called when it appears next to an object of the type the comma is
        defined for. However, "operator," is not called for function argument lists, only for
        objects that are out in the open, separated by commas. There doesn't seem to be a lot of
        practical uses for this operator; it's in the language for consistency. Here's an
        example showing how the comma function can be called when the comma appears before an
        object, as well as after:
        -->
	<para>
	  El operador coma es llamado cuando aparece siguiendo a un
	  objeto del tipo para el que está definido. Sin embargo,
	  <quote><function>operator,</function></quote> no se llama para
	  listas de argumentos de funciones, sólo para objetos fuera de
	  ese lugar separados por comas. No parece haber un montón de
	  usos prácticos para este operador, solo es por consistencia
	  del lenguaje. He aquí un ejemplo que muestra como la función
	  coma puede ser llamada cuando aparece antes de un objeto, así
	  como después:
	</para>



//: V1C12:OverloadingOperatorComma.cpp


        <!--
        The global function allows the comma to be placed before the object in question. The
        usage shown is fairly obscure and questionable. Although you would probably use a
        comma-separated list as part of a more complex expression, it's too subtle to use in
        most situations.
        -->
	<para>
	  Las funciones globales permiten a la coma ser situada antes
	  del objeto en cuestión. El uso mostrado es bastante oscuro y
	  cuestionable. Aunque usted podría probablemente usar una lista
	  separada por comas como parte de una expresión mas complicada,
	  es demasiado refinado en la mayoría de las ocasiones.
	</para>
      </sect3>
      <sect3>
        <!-- : Operator-> -->
	<title>El operador -></title>

        <!--
        The operator-> is generally used when you want to make an object appear to be a pointer.
        Since such an object has more "smarts" built into it than exist for a typical pointer,
        an object like this is often called a smart pointer. These are especially useful if you
        want to "wrap" a class around a pointer to make that pointer safe, or in the common
        usage of an iterator, which is an object that moves through a collection /container of
        other objects and selects them one at a time, without providing direct access to the
        implementation of the container. (You'll often find containers and iterators in class
        libraries, such as in the Standard C++ Library, described in Volume 2 of this book.)
        -->
	<para>
	  El operador <oper>-></oper> se usa
	  generalmente cuando quiera hacer que un objeto aparezca como
	  un puntero. Un objeto como este es llamado a menudo un
	  <emphasis>puntero inteligente</emphasis>. Estos son
	  especialmente utiles si usted quiere <quote>envolver</quote>
	  una clase con un puntero para hacer que ese puntero sea
	  seguro, o en la forma común de un
	  <classname>iterador</classname>, que es un objeto que se mueve
	  a través de una <classname>colección</classname> o
	  <classname>contenedor</classname> de otros objetos y los
	  selecciona de uno en uno cada vez, si proporcionar acceso
	  directo a la implementación del contenedor. (A menudo
	  encontrará iteradores y contenedores en las librerías de
	  clases, como en la Libreria Standar de C++, descrita en el
	  volumen 2 de este libro).
	</para>

        <!--
        A pointer dereference operator must be a member function. It has additional, atypical
        constraints: It must return an object (or reference to an object) that also has a
        pointer dereference operator, or it must return a pointer that can be used to select
        what the pointer dereference operator arrow is pointing at. Here's a simple example:
        -->
	<para>
	  El operador de indirección de punteros (*) debe ser una
	  función miembro. Tiene otras obligaciones atípicas: debe
	  devolver un objeto( o una referencia a un objeto) que también
	  tenga un operador de indirección de punteros, o debe devolver
	  un puntero que pueda ser usado para encontrar a lo que apunta
	  la flecha del operador de indireción de punteros. He aquí un
	  ejemplo simple:
	</para>



//: V1C12:SmartPointer.cpp


        <!--
        The class Obj defines the objects that are manipulated in this program. The functions f
        ( ) and g( ) simply print out interesting values using static data members. Pointers to
        these objects are stored inside containers of type ObjContainer using its add( )
        function. ObjContainer looks like an array of pointers, but you'll notice there's no way
        to get the pointers back out again. However, SmartPointer is declared as a friend class,
        so it has permission to look inside the container. The SmartPointer class looks very
        much like an intelligent pointer - you can move it forward using operator++ (you can
        also define an operator- -), it won't go past the end of the container it's pointing to,
        and it produces (via the pointer dereference operator) the value it's pointing to.
        Notice that the SmartPointer is a custom fit for the container it's created for; unlike
        an ordinary pointer, there isn't a "general purpose" smart pointer. You will learn more
        about the smart pointers called "iterators" in the last chapter of this book and in
        Volume 2 (downloadable from www.BruceEckel.com).
        -->
	<para>
	  La clase <classname>Obj</classname> define los objetos que son
	  manipulados en este programa. Las funciones
	  <function>f()</function> y <function>g()</function>
	  simplemente escriben en pantalla los valores interesantes
	  usando miembros de datos estáticos. Los punteros a estos
	  objetos son almacenados en el interior de los contenedores del
	  tipo <classname>ObjContainer</classname> usando su función
	  <function>add()</function>. <classname>ObjContanier</classname>
	  parece un array de punteros, pero advertirá que no hay forma
	  de traer de nuevo los punteros. Sin embargo,
	  <classname>SmartPointer</classname> se declara como una clase
	  <classname>friend</classname>, asi que tiene permiso para
	  mirar dentro del contenedor. La clase
	  <classname>SmartPointer</classname> parece mucho más un
	  puntero inteligente-usted puede moverlo hacia adelante usando
	  <function>operator++</function>(también puede definir un
	  <function>operator--</function>, no pasará del final del
	  contenedor al que apunta, y genera( a través del operador de
	  indireccion de punteros) el valor al que apunta. Advierta que
	  <classname>SmartPointer</classname> está hecho a medida sobre
	  el contenedor para el que se crea;a diferencia de un puntero
	  normal, no hay punteros inteligentes de "propósito
	  general". Aprenderá mas sobre los punteros inteligentes
	  llamados <quote>iteradores</quote> en el ultimo capitulo de
	  este libro y en el volumen 2(descargable desde
	  FIXME:url www. BruceEckel. com).
	</para>

        <!--
        In main( ), once the container oc is filled with Obj objects, a SmartPointer sp is
        created. The smart pointer calls happen in the expressions:
        -->
	<para>
	  En <function>main()</function>, una vez que el contenedor
	  <varname>oc</varname> se rellena con objetos
	  <classname>Obj</classname> un <varname>SmartPointer
	  sp</varname> se crea. La llamada al puntero inteligente sucede
	  en las expresiones:
	</para>


 <programlisting>
     sp->f();    // Llamada al puntero inteligente
     sp->g();
 </programlisting>

        <!--
        Here, even though sp doesn't actually have f( ) and g( ) member functions, the pointer
        dereference operator automatically calls those functions for the Obj* that is returned
        by SmartPointer::operator->. The compiler performs all the checking to make sure the
        function call works properly.
        -->
	<para>
	  Aquí, incluso aunque <varname>sp</varname> no tiene funciones
	  miembro <function>f()</function> y <function>g()</function>,
	  el operador de indirección de punteros automáticamente llama a
	  esas funciones para <type>Obj*</type> que es devuelto por
	  <function>SmartPointer::operator-></function>. El compilador
	  realiza todas las comprobaciones pertinentes para asegurar que
	  la llamada a función funciona de forma correcta.
	</para>

        <!--
        Although the underlying mechanics of the pointer dereference operator are more complex
        than the other operators, the goal is exactly the same: to provide a more convenient
        syntax for the users of your classes.
        -->
	<para>
	  Aunque la mecánica subyacente de los operadores de
	  indirección de punteros es más compleja que la de los otros
	  operadores, la meta es exactamente la misma:proporcionar una
	  sintaxis mas conveniente para los usuarios de sus clases.
	</para>
      </sect3>

      <sect3>
        <!-- : A nested iterator -->
	<title>Un operador anidado</title>

        <!--
        It's more common to see a "smart pointer" or "iterator" class nested within the class
        that it services. The previous example can be rewritten to nest SmartPointer inside
        ObjContainer like this:
        -->
	<para>
	  Es más común ver un puntero inteligente o un clase iteradora
	  anidada dentro de la clase a la que sirve. El ejemplo previo
	  puede ser reescrito para anidar
	  <classname>SmartPointer</classname> dentro de
	  <classname>ObjContainer</classname> así:
	</para>



//: V1C12:NestedSmartPointer.cpp


        <!--
        Besides the actual nesting of the class, there are only two differences here. The first
        is in the declaration of the class so that it can be a friend:
        -->
	<para>
	  Además del actual anidamiento de la clase, hay solo dos
	  diferencias aquí. La primera es la declaración de la clase
	  para que pueda ser <kw>friend</kw>:
	</para>


<programlisting>
    class SmartPointer;
    friend SmartPointer;
</programlisting>

        <!--
        The compiler must first know that the class exists before it can be told that it's a
        friend.
        -->
	<para>
	  El compilador debe saber primero que la clase existe, antes de
	  que se le diga que es <kw>amiga</kw>.
	</para>

        <!--
        The second difference is in the ObjContainer member function begin( ), which produces a
        SmartPointer that points to the beginning of the ObjContainer sequence. Although it's
        really only a convenience, it's valuable because it follows part of the form used in the
        Standard C++ Library.
        -->
	<para>
	  La segunda diferencia es en
	  <classname>ObjContainer</classname>donde la función miembro
	  <function>begin()</function> produce el
	  <classname>SmartPointer</classname> que apunta al principio de
	  la secuencia del <classname>ObjContainer</classname>. Aunque
	  realmente es sólo por conveniencia, es adecuado porque sigue
	  la manera habitual de la librería estándar de C++.
	</para>
      </sect3>

      <sect3>
        <!-- : Operator->* -->
	<title>Operador ->*</title>

        <!--
        The operator->* is a binary operator that behaves like all the other binary operators.
        It is provided for those situations when you want to mimic the behavior provided by the
        built-in pointer-to-member syntax, described in the previous chapter.
        -->
	<para>
	  El operador <oper>->*</oper> es un
	  operador binario que se comporta como todos los otros
	  operadores binarios. Se proporciona para aquellas situaciones
	  en las que quiera imitar el comportamiento producido por la
	  sintaxis incorporada <emphasis>puntero a miembro</emphasis>,
	  descrita en el capitulo anterior.
	</para>

        <!--
        Just like operator->, the pointer-to-member dereference operator is generally used with
        some kind of object that represents a "smart pointer," although the example shown here
        will be simpler so it's understandable. The trick when defining operator->* is that it
        must return an object for which the operator( ) can be called with the arguments for the
        member function you're calling.
        -->
	<para>
	  Igual que <oper>operator-></oper>, el
	  operador de indirección de puntero a miembro es usado
	  normalmente con alguna clase de objetos que representan un
	  <quote>puntero inteligente</quote>, aunque el ejemplo mostrado
	  aqui será más simple para que sea comprensible. El truco
	  cuando se define <oper>operator->*</oper> es que debe devolver un
	  objeto para el que <function>operator()</function> pueda ser
	  llamado con los argumentos para la función miembro que usted
	  llama.
	</para>

        <!--
        The function call operator( ) must be a member function, and it is unique in that it
        allows any number of arguments. It makes your object look like it's actually a function.
        Although you could define several overloaded operator( ) functions with different
        arguments, it's often used for types that only have a single operation, or at least an
        especially prominent one. You'll see in Volume 2 that the Standard C++ Library uses the
        function call operator in order to create "function objects."
        -->
	<para>
	  La llamada a función <function>operator()</function> debe ser
	  una función miembro, y es ónica en que permite cualquier
	  nómero de argumentos. Hace su objeto parecer como si fuera
	  realmente una función. Aunque usted prodría definir varias
	  funciones sobrecargadas <function>operator()</function> con
	  diferentes argumentos, a menudo se usa para tipos que solo
	  tienen una operación simple, o al menos una especialmente
	  destacada. Usted verá en el Volumen2 que la librería estándar
	  de C++ usa el operador de llamada a función para crear
	  <quote>objetos función</quote>.
	</para>

        <!--
        To create an operator->* you must first create a class with an operator( ) that is the
        type of object that operator->* will return. This class must somehow capture the
        necessary information so that when the operator( ) is called (which happens
        automatically), the pointer-to-member will be dereferenced for the object. In the
        following example, the FunctionObject constructor captures and stores both the pointer
        to the object and the pointer to the member function, and then the operator( ) uses
        those to make the actual pointer-to-member call:
        -->
	<para>
	  Para crear un <oper>operator->*</oper>
	  debe primero crear una clase con un
	  <function>operator()</function> que sea el tipo de objeto que
	  <oper>operator->*</oper> devolverá.
	</para>
	<para>
	  Esta clase debe, de algón modo, capturar la información
	  necesaria para que cuando <function>operator()</function> sea
	  llamada( lo que sucede automáticamente), el puntero a miembro
	  sea indireccionado para el objeto. En el ejemplo siguiente, el
	  constructor de <classname>FunctionObject</classname>captura y
	  almacena el puntero al objeto y el puntero a la función
	  miembro, y entonces <function>operator()</function> los usa
	  para hacer la actual llamada a "puntero a miembro":
	</para>



//: V1C12:PointerToMemberOperator.cpp


        <!--
        Dog has three member functions, all of which take an int argument and return an int. PMF
        is a typedef to simplify defining a pointer-to-member to Dog's member functions.
        -->
	<para>
	  <classname>Dog</classname> tiene tres funciones miembro, todas
	  las cuales toman un argumento entero y devuelven un
	  entero. <varname>PMC</varname> es un <type>typedef</type> para
	  simplificar el definir un puntero a miembro para las funciones
	  miembro de <classname>Dog</classname>.
	</para>

        <!--
        A FunctionObject is created and returned by operator->*. Notice that operator->* knows
        both the object that the pointer-to-member is being called for (this) and the
        pointer-to-member, and it passes those to the FunctionObject constructor that stores the
        values. When operator->* is called, the compiler immediately turns around and calls
        operator( ) for the return value of operator->*, passing in the arguments that were
        given to operator->*. The FunctionObject::operator( ) takes the arguments and then
        dereferences the "real" pointer-to-member using its stored object pointer and
        pointer-to-member.
        -->
	<para>
	  Una <function>FunctionObject</function> es creada y devuelta
	  por <oper>operator->*</oper>. Dese
	  cuenta que <oper>operator->*</oper>
	  conoce el objeto para el que puntero a miembro esta siendo
	  llamado(<varname>this</varname>) y el puntero a miembro, y los
	  pasa al constructor <function>FunctionObject</function> que
	  almacena sus valores. Cuando <oper>operator->*</oper> es llamado, el
	  compilador inmediatamente se revuelve y llama a
	  <function>operator()</function> para el valor de retorno de
	  <oper>operator->*</oper>, pasandole los
	  argumentos que le fueron pasados a <oper>operator->*</oper>.
	  <function>FunctionObject::operator()</function> toma los
	  argumentos y entonces indirecciona el puntero a miembro
	  <quote>real</quote> usando los punteros a objeto y a miembro
	  almacenados.
	</para>

        <!--
        Notice that what you are doing here, just as with operator->, is inserting yourself in
        the middle of the call to operator->*. This allows you to perform some extra operations
        if you need to.
        -->
	<para>
	  Percátese de que lo que está haciendo aquí, justo como con
	  <oper>operator-></oper>, es insertarse
	  en la mitad de la llamada a <oper>operator->*</oper>. Esto permite realizar
	  algunas operaciones adicionales si las necesitara.
	</para>

        <!--
        The operator->* mechanism implemented here only works for member functions that take an
        int argument and return an int. This is limiting, but if you try to create overloaded
        mechanisms for each different possibility, it seems like a prohibitive task.
        Fortunately, C++'s template mechanism (described in the last chapter of this book, and
        in Volume 2) is designed to handle just such a problem.
        -->
	<para>
	  El mecanismo <oper>operator->*</oper>
	  implementado aquí solo trabaja para funciones miembro que
	  toman un argumento entero y devuelven otro entero. Esto es una
	  limitación, pero si intenta crear mecanismos sobrecargados
	  para cada diferente posibilidad, verá que es una tarea
	  prohibitiva. Afortunadamente, el mecanismo de plantillas de
	  C++(descrito el el ultimo capitulo de este libro, y en el
	  volumen2) esta diseñado para manejar semejante problema.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <!-- : Operators you can't overload -->
      <title>Operadores que no puede sobrecargar</title>

      <!--
      There are certain operators in the available set that cannot be overloaded. The general
      reason for the restriction is safety. If these operators were overloadable, it would
      somehow jeopardize or break safety mechanisms, make things harder, or confuse existing
      practice.
      -->
      <para>
	Hay cierta clase de operadores en el conjunto disponible que no
	pueden ser sobrecargados. La razón general para esta restricción
	es la seguridad. Si estos operadores fuesen sobrecargabales,
	podría de algón modo arriesgar o romper los mecanismos de
	seguridad, hacer las cosas mas difíciles o confundir las
	costumbres existentes.
      </para>

      <!--
      * The member selection operator.. Currently, the dot has a meaning for any member in a
      class, but if you allow it to be overloaded, then you couldn't access members in the
      normal way; instead you'd have to use a pointer and the arrow operator->.
      * The pointer to member dereference operator.*, for the same reason as operator..
      * There's no exponentiation operator. The most popular choice for this was operator**
      from Fortran, but this raised difficult parsing questions. Also, C has no
      exponentiation operator, so C++ didn't seem to need one either because you can
      always perform a function call. An exponentiation operator would add a convenient
      notation, but no new language functionality to account for the added complexity of
      the compiler.
      * There are no user-defined operators. That is, you can't make up new operators that
      aren't currently in the set. Part of the problem is how to determine precedence, and
      part of the problem is an insufficient need to account for the necessary trouble.
      * You can't change the precedence rules. They're hard enough to remember as it is
      without letting people play with them.
      -->
      <orderedlist>
	<listitem>
	  <para>
	    El operador de selección de miembros <kw>operator</kw>. Actualmente, el punto
	    tiene significado para cualquier miembro de una clase, pero
	    si le permite ser sobrecargado, no podría acceder a miembros
	    de la forma normal;en lugar de eso debería usar un puntero y
	    la flecha <literal>operator-></literal>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    La indirección de punteros a miembros <literal>operator *</literal> por la misma razón que
	    <literal>operator</literal>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    No hay un operador de potencia. La elección mas popular para
	    este era <literal>operator**</literal> de
	    Fortram, pero provoca casos de análisis gramatical
	    dificiles. C tampoco tiene un operador de potencia, así que
	    C++ no parece tener necesidad de uno porque siempre puede
	    realizar una llamada a una función. Un operador de potencia
	    añadirá una notación adecuada, pero ninguna nueva
	    funcionalidad a cuenta de una mayor complejidad del
	    compilador.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    No hay operadores definidos por el usuario. Esto es, no
	    puede crear nuevos operadores que no estén ya en el actual
	    conjunto. Una parte del problema es como determinar la
	    prioridad, y otra parte es la falta de necesidad a costa del
	    problema inherente.
	  </para>
	</listitem>
	<listitem>
          <para>
            Usted no puede cambiar las reglas de prioridad. Son lo
            suficientemente difíciles de recordad como son sin dejar a
            la gente jugar con ellas.
          </para>
        </listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1>
    <!-- : Non-member operators -->
    <title>Operadores no miembros</title>

    <!--
    In some of the previous examples, the operators may be members or non-members, and it
    doesn't seem to make much difference. This usually raises the question, "Which should I
    choose?" In general, if it doesn't make any difference, they should be members, to
    emphasize the association between the operator and its class. When the left-hand operand
    is always an object of the current class, this works fine.
    -->
    <para>
      En algunos de los ejemplos anteriores, los operadores pueden ser
      miembros o no miembros, y no parece haber mucha diferencia. Esto
      normalmente provoca la pregunta, <quote>¿Cual debería
      elegir?</quote>. En general, si no hay ninguna diferencia
      deberían ser miembros, para enfatizar la asociación entre el
      operador y su clase. Cuando el operando de la izquierda es
      siempre un objeto de la clase actual funciona bien.
    </para>

    <!--
    However, sometimes you want the left-hand operand to be an object of some other class. A
    common place you'll see this is when the operators << and >> are overloaded for
    iostreams. Since iostreams is a fundamental C++ library, you'll probably want to
    overload these operators for most of your classes, so the process is worth memorizing:
    -->
    <para>
      Sin embargo, a veces querrá que el operando de la izquierda sea
      un objeto de alguna otra clase. Un caso típico en el que ocurre
      eso es cuando se sobrecargan los
      operadores <oper>&lt;&lt;</oper> y
      <oper>&gt;&gt;</oper> para los flujos de entrada/salida. Dado
      que estos flujos son una librería fundamental en C++,
      probablemente querrá sobrecargar estos operadores para la
      mayoría de sus clases, por eso el proceso es digno de tratarse:
    </para>



//: V1C12:IostreamOperatorOverloading.cpp

    <!--
    This class also contains an overloaded operator [ ], which returns a reference to a
    legitimate value in the array. Because a reference is returned, the expression
    -->
    <para>
      Esta clase contiene también un operador sobrecargado
      <oper>operator[]</oper> la cual devuelve una referencia a un valor
      a licito en el array. Dado que se devuelve una referencia, la
      expresión:
    </para>


<programlisting>
    I[4] = -1;
</programlisting>

    <!--
    not only looks much more civilized than if pointers were used, it also accomplishes the
    desired effect.
    -->
    <para>
      No sólo parece mucho más adecuada que si se usaran punteros,
      también causa el efecto deseado.
    </para>

    <!--
    It's important that the overloaded shift operators pass and return by reference, so the
    actions will affect the external objects. In the function definitions, expressions like
    -->
    <para>
      Es importante que los operadores de desplazamiento sobrecargados
      pasen y devuelvan por referencia, para que los cambios afecten a
      los objetos externos. En las definiciones de las funciones,
      expresiones como:
    </para>


<programlisting>
    os &#60;&#60; ia.i[j];
</programlisting>

    <!--
    cause the existing overloaded operator functions to be called (that is, those defined in
    because ia.i[j] resolves to an int.
    -->
    <para>
      provocan que sean llamadas las funciones de los operadores
      sobrecargados(esto es, aquellas definidas en
      <classname>iostream</classname>). En este caso, la función llamada
      es <function>ostream&amp; operator&#60;&#60;(ostream&amp;,
      int)</function> dado que <varname>ia[i].j</varname> se resuelve en
      un <type>int</type>.
    </para>

    <!--
    Once all the actions are performed on the istream or ostream, it is returned so it can
    be used in a more complicated expression.
    -->
    <para>
      Una vez que las operaciones se han realizado en
      <classname>istream</classname> o en <classname>ostream</classname>
      se devuelve para que pueda ser usado en expresiones mas complejas.
    </para>

    <!--
    In main( ), a new type of iostream is used: the stringstream (declared in <sstream>).
    This is a class that takes a string (which it can create from a char array, as shown
    here) and turns it into an iostream. In the example above, this means that the shift
    operators can be tested without opening a file or typing data in on the command line.
    -->
    <para>
      En <function>main()</function> se usa un nuevo tipo de
      <classname>iostream</classname>: el
      <type>stringstream</type>(declarado en
      <classname>&#60;sstream></classname>). Esta es una clase que toma
      una cadena(que se puede crear de un array de <type>char</type>,
      como se ve aquí) y lo convierte en un
      <classname>iostream</classname>. En el ejemplo de arriba, esto
      significa que los operadores de desplazamiento pueden ser
      comprobados sin abrir un archivo o sin escribir datos en la línea
      de comandos.
    </para>

    <!--
    The form shown in this example for the inserter and extractor is standard. If you want
    to create these operators for your own class, copy the function signatures and return
    types above and follow the form of the body.
    -->
    <para>
      La manera mostrada en este ejemplo para el extractor y el
      insertador es estándar. Si quiere crear estos operadores para su
      propia clase, copie el prototipo de la función y los tipos de
      retorno de arriba y siga el estilo del cuerpo.
    </para>

    <sect2>
     <!-- : Basic guidelines -->
      <title>Directrices básicas</title>

      <!-- Murray[49] suggests these guidelines for choosing between members and non-members: -->
      <para>
	Murray
	<footnote>
	  <para>
	  Rob Murray, <citetitle pubwork="book">
	      C++ Strategies &amp; Tactics
	    </citetitle>, Addison Wesley, 1993, pagina 47.
	  </para>
	</footnote> sugiere estas reglas
	de estilo para elegir entre miembros y no miembros:
      </para>


      <table>
	<!-- TABLA Guidelines for choosing between members and non-members -->
	<title>Directrices para elegir entre miembro y no-miembro</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Operador</entry>
	      <entry>Uso recomendado</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Todos los operadores unarios</entry>
	      <entry>miembro</entry>
	    </row>
	    <row>
	      <entry>= () [] -> ->*</entry>
	      <entry><emphasis>debe</emphasis> ser miembro</entry>
	    </row>
	    <row>
	      <entry>+= -= /= *= ^= &amp;= |= %= >>=
				  &lt;&lt;=</entry>
	      <entry>miembro</entry>
	    </row>
	    <row>
	      <entry>El resto de operadores binarios</entry>
	      <entry>no miembro</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>


  <sect1>
    <!-- : Overloading assignment -->
    <title>Sobrecargar la asignación</title>

    <!--
    A common source of confusion with new C++ programmers is assignment. This is no doubt
    because the = sign is such a fundamental operation in programming, right down to copying
    a register at the machine level. In addition, the copy-constructor (described in Chapter
    11) is also sometimes invoked when the = sign is used:
    -->
    <para>
      Una causa común de confusión para los nuevos programadores de C++
      es la asignación. De esto no hay duda dado que el signo
      <literal>=</literal> es una operación fundamental en la
      programación, directamente hasta copiar un registro al nivel
      maquina. Adicionalmente, el constructor de copia (descrito en el
      capítulo 11) es llamado a veces cuando el signo
      <literal>=</literal> se usa:
    </para>


<programlisting>
    MyType b;
    MyType a = b;
    a = b;
</programlisting>

    <!--
    In the second line, the object a is being defined. A new object is being created where
    one didn't exist before. Because you know by now how defensive the C++ compiler is about
    object initialization, you know that a constructor must always be called at the point
    where an object is defined. But which constructor? a is being created from an existing
    MyType object (b, on the right side of the equal sign), so there's only one choice: the
    copy-constructor. Even though an equal sign is involved, the copy-constructor is called.
    -->
    <para>
      En la segunda línea, se define el objeto <varname>a</varname>. Se
      crea un nuevo objeto donde no existía ninguno. Dado que por ahora
      conoce como de quisquilloso es el compilador de C++ respecto a la
      inicialización de objetos, sabrá que un constructor debe siempre
      ser llamado cuando se define un objeto.
    </para>


    <para>
      ¿Pero qué constructor?, <varname>a</varname> se crea desde un
      objeto existente <classname>MyType</classname>
      (<varname>b</varname>, en el lado derecho del signo de igualdad),
      asi que hay solo un elección: el constructor de copia. Incluso
      aunque el signo de igualdad está involucrado, se llama al
      constructor de copia.
    </para>

    <!--
    In the third line, things are different. On the left side of the equal sign, there's a
    previously initialized object. Clearly, you don't call a constructor for an object
    that's already been created. In this case MyType::operator= is called for a, taking as
    an argument whatever appears on the right-hand side. (You can have multiple operator=
    functions to take different types of right-hand arguments.)
    -->
    <para>
      En la tercera línea, las cosas son diferentes. En la parte
      izquierda del signo igual, hay un objeto previamente
      inicializado. Claramente, usted no llama a un constructor para un
      objeto que ya ha sido creado. En este caso
      <function>MyType::operator=</function> se llama para
      <varname>a</varname>, tomando como argumento lo que sea que
      aparezca en la parte derecha. (Puede tener varios funciones
      <function>operator=</function> que tomen diferentes argumentos en
      la parte derecha).
    </para>

    <!--
    This behavior is not restricted to the copy-constructor. Any time you're initializing an
    object using an = instead of the ordinary function-call form of the constructor, the
    compiler will look for a constructor that accepts whatever is on the right-hand side:
    -->
    <para>
      Este comportamiento no está restringido al constructor de
      copia. Cada vez que inicializa un objeto usando un signo
      <literal>=</literal> en lugar de la forma usual de llamada al
      constructor, el compilador buscará un constructor que acepte lo
      que sea que haya en la parte derecha:
    </para>



//: V1C12:CopyingVsInitialization.cpp


    <!--
    When dealing with the = sign, it's important to keep this distinction in mind: If the
    object hasn't been created yet, initialization is required; otherwise the assignment
    operator= is used.
    -->
    <para>
      Cuando se trata con el signo <oper>=</oper>, es importante
      mantener la diferencia en mente:Si el objeto ha sido creado ya, se
      requiere una inicialización;en otro caso el operador de asignación
      <oper>=</oper> se usa.
    </para>

    <!--
    It's even better to avoid writing code that uses the = for initialization; instead,
    always use the explicit constructor form. The two constructions with the equal sign then
    become:
    -->
    <para>
      Es incluso mejor el evitar escribir código que usa
      <oper>=</oper> para la inicialización; en cambio, use
      siempre la manera del constructor explícito. Las dos
      construcciones con el signo igual se convierten en:
    </para>

<programlisting>
    Fee fee(1);
    Fee fum(fi);
</programlisting>

    <!-- This way, you'll avoid confusing your readers. -->
    <para>
      De esta manera, evitará confundir a sus lectores.
    </para>


    <sect2>
      <!-- : Behavior of operator= -->
      <title>Comportamiento del operador =</title>

     <!--
      In Integer.h and Byte.h, you saw that operator= can be only a member function. It is
      intimately connected to the object on the left side of the '='. If it was possible to
      define operator= globally, then you might attempt to redefine the built-in '=' sign:
      -->
      <para>
	En <filename>Integer.h</filename> y en
	<filename>Byte.h</filename> usted vio que el operador
	<oper>=</oper> sólo puede ser una función miembro. Está
	íntimamente ligado al objeto que hay en la parte izquierda del
	<oper>=</oper>. Si fuese posible definir
	<function>operator=</function> de forma global, entonces podría
	intentar redefinir el signo incorporado <oper>=</oper>:
      </para>


<programlisting>
    int operator=(int, MyType);   // Global = !No permitido!
</programlisting>

      <!-- The compiler skirts this whole issue by forcing you to make operator= a member function. -->
      <para>
	El compilador evita esta situación obligandole a hacer una
	función miembro <function>operator=</function>.
      </para>

      <!--
      When you create an operator=, you must copy all of the necessary information from the
      right-hand object into the current object (that is, the object that operator= is being
      called for) to perform whatever you consider "assignment" for your class. For simple
      objects, this is obvious:
      -->
      <para>
	Cuando usted crea un <kw>operator=</kw>, debe copiar todo la
	información necesaria desde el objeto de la parte derecha al
	objeto actual(esto es, el objeto para el que <oper>operator=</oper> está siendo llamado) para
	realizar lo que sea que considere <quote>asignación</quote> para
	su clase. Para objetos simples, esto es trivial:
      </para>



//: V1C12:SimpleAssignment.cpp


      <!--
      Here, the object on the left side of the = copies all the elements of the object on the
      right, then returns a reference to itself, which allows a more complex expression to be
      created.
      -->
      <para>
	Aquí, el objeto de la parte izquierda del igual copia todos los
	elementos del objeto de la parte derecha, y entonces devuelve
	una referencia a sí mismo, lo que permite crear expresiones
	mas complejas.
      </para>

      <!--
      This example includes a common mistake. When you're assigning two objects of the same
      type, you should always check first for self-assignment: is the object being assigned to
      itself? In some cases, such as this one, it's harmless if you perform the assignment
      operations anyway, but if changes are made to the implementation of the class, it can
      make a difference, and if you don't do it as a matter of habit, you may forget and cause
      hard-to-find bugs.
      -->
      <para>
	Este ejemplo incluye un error comón. Cuando usted está asignando
	dos objetos del mismo tipo, siempre debería comprobar primero la
	auto asignación: ¿Está el objeto siendo asignado a sí mismo?. En
	algunos casos como éste, es inofensivo si realiza la operación
	de asignación, de todas formas, pero si se realizan cambios a la
	implementación de la clase, puede haber diferencias y si no lo
	toma con una cuestión de costumbre, puede olvidarlo y provocar
	errores difíciles de encontrar.
      </para>
      <sect3>

        <!-- : Pointers in classes -->
	<title>Punteros en clases</title>

        <!--
        What happens if the object is not so simple? For example, what if the object contains
        pointers to other objects? Simply copying a pointer means that you'll end up with two
        objects pointing to the same storage location. In situations like these, you need to do
        bookkeeping of your own.
        -->
	<para>
	  ¿Qué ocurre si el objeto no es tan simple?. Por ejemplo,
	  &iquest;qué pasa si el objeto contiene punteros a otros
	  objetos?. Simplemente copiar el puntero significa que usted
	  terminará con dos objetos apuntando a la misma localización de
	  memoria. En situaciones como ésta, necesita hacer algo de
	  contabilidad.
	</para>

        <!--
        There are two common approaches to this problem. The simplest technique is to copy
        whatever the pointer refers to when you do an assignment or a copy-construction. This is
        straightforward:
        -->
	<para>
	  Hay dos aproximaciones a este problema. La técnica mas simple
	  es copiar lo que quiera que apunta el puntero cuando realiza
	  una asignación o una construcción de copia. Es es
	  directamente:
	</para>



//: V1C12:CopyingWithPointers.cpp


        <!--
        Dog is a simple class that contains only a string that holds the name of the dog.
        However, you'll generally know when something happens to a Dog because the constructors
        and destructors print information when they are called. Notice that the second
        constructor is a bit like a copy-constructor except that it takes a pointer to a Dog
        instead of a reference, and it has a second argument that is a message that's
        concatenated to the argument Dog's name. This is used to help trace the behavior of the
        program.
        -->
	<para>
	  <classname>Dog</classname> es una clase simple que contiene
	  solo una cadena con el nombre del perro. Sin embargo,
	  generalmente sabrá cuando le sucede algo al perro dado que los
	  constructores y destructores imprimen información cuando son
	  llamados. Advierta que el segundo constructor es un poco como
	  un constructor de copia excepto que toma un puntero a
	  <classname>Dog</classname> en vez de una referencia, y tiene
	  un segundo argumento que es un mensaje a ser concatenado con
	  el nombre del perro. Esto se hace asi para ayudar a rastrear
	  el comportamiento del programa.
	</para>

        <!--
        You can see that whenever a member function prints information, it doesn't access that
        information directly but instead sends *this to cout. This in turn calls the ostream
        operator<<. It's valuable to do it this way because if you want to reformat the way that
        Dog information is displayed (as I did by adding the '[' and ']') you only need to do it
        in one place.
        -->
	<para>
	  Puede ver que cuando sea que una función miembro imprime
	  información, no accede a esa información directamente sino en
	  su lugar manda <varname>*this</varname> a
	  <function>cout</function>. Este a su vez llama a
	  <function>ostream operator&#60;&#60;</function>. Es
	  aconsejable hacer esto así dado que si quiere reformatear la
	  manera en la que información del perro es mostrada(como hice
	  añadiendo el <quote>[</quote> y el <quote>]</quote>) solo
	  necesita hacerlo en un lugar.
	</para>

        <!--
        A DogHouse contains a Dog* and demonstrates the four functions you will always need to
        define when your class contains pointers: all necessary ordinary constructors, the
        copy-constructor, operator= (either define it or disallow it), and a destructor. The
        operator= checks for self-assignment as a matter of course, even though it's not
        strictly necessary here. This virtually eliminates the possibility that you'll forget to
        check for self-assignment if you do change the code so that it matters.
        -->
	<para>
	  Una <classname>DogHouse</classname> contiene un
	  <varname>Dog*</varname> y explica las cuatro funciones que
	  siempre necesitará definir cuando sus clases contengan
	  punteros:todos los constructores necesarios usuales, el
	  constructor de copia, <oper>operator=</oper> (se define o se
	  deshabilita) y un destructor. <oper>Operator=</oper> comprueba la auto
	  asignación como una cuestión de estilo, incluso aunque no es
	  estrictamente necesario aquí. Esto virtualmente elimina la
	  posibilidad de que olvide comprobar la auto asignación si
	  cambia el código.
	</para>
      </sect3>

      <sect3>
        <!-- : Reference Counting -->
	<title>Contabilidad de referencias</title>

        <!--
        In the example above, the copy-constructor and operator= make a new copy of what the
        pointer points to, and the destructor deletes it. However, if your object requires a lot
        of memory or a high initialization overhead, you may want to avoid this copying. A
        common approach to this problem is called reference counting. You give intelligence to
        the object that's being pointed to so it knows how many objects are pointing to it. Then
        copy-construction or assignment means attaching another pointer to an existing object
        and incrementing the reference count. Destruction means reducing the reference count and
        destroying the object if the reference count goes to zero.
        -->
	<para>
	  En el ejemplo de arriba, el constructor de copia y el operador
	  <oper>=</oper> realizan una copia de lo
	  que apunta el puntero, y el destructor lo borra. Sin embargo,
	  si su objeto requiere una gran cantidad de memoria o una gran
	  inicialización fija, a lo mejor puede querer evitar esta
	  copia. Una aproximación común a este problema se llama
	  <emphasis>contabilidad de referencias</emphasis>. Se le da
	  inteligencia al objeto que esta siendo apuntado de tal manera
	  que sabe cuantos objetos le están apuntado. Entonces la
	  construcción por copia o la asignación consiste en añadir otro
	  puntero a un objeto existente e incrementar la cuenta de
	  referencias. La destrucción consiste en reducir esta cuenta de
	  referencias y destruir el objeto si la cuenta llega a cero.
	</para>

        <!--
        But what if you want to write to the object (the Dog in the example above)? More than
        one object may be using this Dog, so you'd be modifying someone else's Dog as well as
        yours, which doesn't seem very neighborly. To solve this "aliasing" problem, an
        additional technique called copy-on-write is used. Before writing to a block of memory,
        you make sure no one else is using it. If the reference count is greater than one, you
        must make yourself a personal copy of that block before writing it, so you don't disturb
        someone else's turf. Here's a simple example of reference counting and copy-on-write:
        -->
	<para>
	  ¿Pero que pasa si quiere escribir el
	  objeto(<varname>Dog</varname> en el ejemplo anterior)?. Más de
	  un objeto puede estar usando este <varname>Dog</varname> luego
	  podría estar modificando el perro de alguien más a la vez que
	  el suyo, lo cual no parece ser muy amigable. Para resolver
	  este problema de <quote>solapamiento</quote> se usa una
	  técnica adicional llamada <emphasis>copia para
	  escritura</emphasis>. Antes de escribir un bloque de memoria,
	  debe asegurarse que nadie más lo está usando. Si la cuenta de
	  referencia es superior a uno, debe realizar una copia personal
	  del bloque antes de escribirlo, de tal manera que no moleste
	  el espacio de otro. He aquí un ejemplo simple de contabilidad
	  de referencias y de copia para escritura:
	</para>



//: V1C12:ReferenceCounting.cpp


        <!--
        The class Dog is the object pointed to by a DogHouse. It contains a reference count and
        functions to control and read the reference count. There's a copy-constructor so you can
        make a new Dog from an existing one.
        -->
	<para>
	  La clase <classname>Dog</classname> es el objeto apuntado por
	  <classname>DogHouse</classname>. Contiene una cuenta de
	  referencia y funciones para controlar y leer la cuenta de
	  referencias. Hay un constructor de copia luego puede crear un
	  nuevo <classname>Dog</classname> de uno existente.
	</para>

        <!--
        The attach( ) function increments the reference count of a Dog to indicate there's
        another object using it. detach( ) decrements the reference count. If the reference
        count goes to zero, then no one is using it anymore, so the member function destroys its
        own object by saying delete this.
        -->
	<para>
	  La función <function>attach()</function> incrementa la cuenta
	  de referencia de un <classname>Dog</classname> para indicar
	  que hay otro objeto usandolo. La función
	  <function>detach()</function> decrementa la cuenta de
	  referencia. Si llega a cero, entonces nadie más lo esta
	  usando, así que la función miembro destruye su propio objeto
	  llamando a <function>delete this</function>.
	</para>

       <!--
        Before you make any modifications (such as renaming a Dog), you should ensure that you
        aren't changing a Dog that some other object is using. You do this by calling
        DogHouse::unalias( ), which in turn calls Dog::unalias( ). The latter function will
        return the existing Dog pointer if the reference count is one (meaning no one else is
        pointing to that Dog), but will duplicate the Dog if the reference count is more than
        one.
        -->
	<para>
	  Antes de que haga cualquier modificación(como renombrar un
	  perro), debería asegurarse de que no está cambiando un
	  <classname>Dog</classname> que algón otro objeto está
	  usando. Hace esto llamando a <function>DogHouse::unalias()
	  </function>, la cual llama a
	  <function>Dog::unalias()</function>. Esta última función
	  devolverá el puntero a <classname>Dog</classname> existente si
	  la cuenta de referencia es uno (lo que significa que nadie mas
	  está usando ese <classname>Dog</classname>), pero duplicará
	  <classname>Dog</classname> si esa cuenta es mayor que uno.
	</para>

        <!--
        The copy-constructor, instead of creating its own memory, assigns Dog to the Dog of the
        source object. Then, because there's now an additional object using that block of
        memory, it increments the reference count by calling Dog::attach( ).
        -->
	<para>
	  El constructor de copia, además de crear su propia memoria,
	  asigna un <classname>Dog</classname> al
	  <classname>Dog</classname> del objeto fuente. Entonces, dado
	  que ahora hay un objeto más usando ese bloque de memoria,
	  incrementa la cuenta de referencia llamando a
	  <function>Dog::attach()</function>.
	</para>

        <!--
        The operator= deals with an object that has already been created on the left side of the
        =, so it must first clean that up by calling detach( ) for that Dog, which will destroy
        the old Dog if no one else is using it. Then operator= repeats the behavior of the
        copy-constructor. Notice that it first checks to detect whether you're assigning the
        same object to itself.
        -->
	<para>
	  El operador <oper>=</oper> trata con un
	  objeto que ha sido creado en la parte izquierda del
	  <oper>=</oper>, así que debe primero debe limpiarlo
	  llamando a <function>detach()</function> para ese perro, el
	  cual destruirá el viejo perro si nadie más lo está
	  usando. Entonces <oper>operator=</oper>
	  repite el comportamiento del constructor de copia. Advierta
	  que primero realiza comprobaciones para detectar cuando está
	  asignando el objeto a sí mismo.
	</para>

        <!-- The destructor calls detach( ) to conditionally destroy the Dog. -->
	<para>
	  El destructor llama a <function>detach()</function> para
	  destruir condicionalmente a <classname>Dog</classname>.
	</para>

        <!--
        To implement copy-on-write, you must control all the actions that write to your block of
        memory. For example, the renameDog( ) member function allows you to change the values in
        the block of memory. But first, it uses unalias( ) to prevent the modification of an
        aliased Dog (a Dog with more than one DogHouse object pointing to it). And if you need
        to produce a pointer to a Dog from within a DogHouse, you unalias( ) that pointer first.
        -->
	<para>
	  Para implementar la copia para escritura, debe controlar todas
	  las operaciones que escriben en su bloque de memoria. Por
	  ejemplo, la función miembro <function>renameDog()</function>
	  le permite cambiar valores en el bloque de memoria. Pero
	  primero, usa <function>unalias()</function> para prevenir la
	  modiciación de un <classname>Dog</classname> solapado (un
	  <classname>Dog</classname> con más de un objeto
	  <classname>DogHouse</classname> apuntándole). Y si necesita
	  crear un puntero a <classname>Dog</classname> desde un
	  <classname>DogHouse</classname> debe evitar el solapamiento
	  del puntero primero.
	</para>

        <!--
        main( ) tests the various functions that must work correctly to implement reference
        counting: the constructor, copy-constructor, operator=, and destructor. It also tests
        the copy-on-write by calling renameDog( ).
        -->
	<para>
	  La función <function>main()</function> comprueba las numerosas
	  funciones que deben funcionar correctamente para implementar
	  la cuenta de referencia:el constructor, el constructor de
	  copia, <oper>operator=</oper> y el
	  destructor. También comprueba la copia para escritura llamando
	  a <function>renameDog()</function>.
	</para>

        <!-- Here's the output (after a little reformatting): -->
	<para>
	  He aquí la salida (después de un poco de reformateo):
	</para>


<programlisting>
    Creando Dog: [Fido],  rc = 1
    CreadoDogHouse: [FidoHouse]
    contiene [Fido],  rc = 1
    Creando Dog: [Spot],  rc = 1
    CreadoDogHouse: [SpotHouse]
    contiene [Spot],  rc = 1
    Entrando en el constructor de copia
    Dog añadido:[Fido],  rc = 2
    DogHouse constructor de copia
    [construido por copia FidoHouse]
    contiene [Fido],  rc = 2
    Despues de la construcción por copia de Bobs
    fidos:[FidoHouse] contiene [Fido],  rc = 2
    spots:[SpotHouse] contiene [Spot],  rc = 1
    bobs:[construido por copia FidoHouse]
    contiene[Fido],  rc = 2
    Entrando spots = fidos
    Eliminando perro: [Spot],  rc = 1
    Borrando Perro: [Spot],  rc = 0
    Añadido Dog: [Fido],  rc = 3
    DogHouse operador= : [FidoHouse asignado]
    contiene[Fido],  rc = 3
    Despues de  spots = fidos
    spots:[FidoHouse asignado] contiene [Fido], rc = 3
    Entrando en la auto asignación
    DogHouse operador= : [construido por copia FidoHouse]
    contiene [Fido],  rc = 3
    Despues de la auto asignación
    bobs:[construido por copia FidoHouse]
    contiene [Fido],  rc = 3
    Entando rename("Bob")
    Despues de rename("Bob")
    DogHouse destructor: [construido por copia FidoHouse]
    contiene [Fido],  rc = 3
    Eliminando perro: [Fido],  rc = 3
    DogHouse destructor: [FidoHouse asignado]
    contiene [Fido],  rc = 2
    Eliminando perro: [Fido],  rc = 2
    DogHouse destructor: [FidoHouse]
    contiene [Fido],  rc = 1
    Eliminando perro: [Fido],  rc = 1
    Borrando perro: [Fido],  rc = 0
</programlisting>

        <!--
        By studying the output, tracing through the source code, and experimenting with the
        program, you'll deepen your understanding of these techniques.
        -->
	<para>
	  Estudiando la salida, rastreando el código fuente y
	  experimentando con el programa, podrá ahondar en la
	  comprensión de estas técnicas.
	</para>
      </sect3>

      <sect3>
        <!-- : Automatic operator= creation -->
	<title>Creación automática del operador =</title>

        <!--
        Because assigning an object to another object of the same type is an activity most
        people expect to be possible, the compiler will automatically create a type::operator=
        (type) if you don't make one. The behavior of this operator mimics that of the
        automatically created copy-constructor; if the class contains objects (or is inherited
        from another class), the operator= for those objects is called recursively. This is
        called memberwise assignment. For example,
        -->
	<para>
	  Dado que asignar un objeto a otro <emphasis>del mismo tipo
	  </emphasis> es una operación que la mayoría de la gente espera
	  que sea posible, el compilador automaticamente creará un
	  <code>type::operator=(type)</code> si usted no hace
	  uno. El comportamiento de este operador imita el del
	  constructor de copia creado automáticamente; si la clase
	  contiene objetos(o se deriva de otra clase), se llama
	  recursivamente a <oper>operator=</oper>
	  para esos objetos. A esto se le llama <emphasis>asignación
	  guiada por miembros</emphasis>. Por ejemplo
	</para>



//: V1C12:AutomaticOperatorEquals.cpp


        <!-- The automatically generated operator= for Truck calls Cargo::operator=. -->
	<para>
	  El operador <oper>=</oper> generador automáticamente
	  para <classname>Truck</classname> llama a
	  <literal>Cargo::operator=</literal>.
	</para>

        <!--
        In general, you don't want to let the compiler do this for you. With classes of any
        sophistication (especially if they contain pointers!) you want to explicitly create an
        operator=. If you really don't want people to perform assignment, declare operator= as a
        private function. (You don't need to define it unless you're using it inside the class.)
        -->
	<para>
	  En general, no querrá dejar al compilador que haga esto por
	  usted. Con clases de cualquier sofisticación (¡Especialmente
	  si contienen punteros!)querrá crear de forma explicita un
	  <oper>operator=</oper>. Si realmente no quiere que la gente
	  realice asignaciones, declare <oper>operator=</oper> como una
	  función <kw>private</kw>. (No necesita definirla a menos que
	  la esté usando dentro de la clase).
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <!-- : Automatic type conversion -->
    <title>Conversión automática de tipos</title>

    <!--
    In C and C++, if the compiler sees an expression or function call using a type that
    isn't quite the one it needs, it can often perform an automatic type conversion from the
    type it has to the type it wants. In C++, you can achieve this same effect for
    user-defined types by defining automatic type conversion functions. These functions come
    in two flavors: a particular type of constructor and an overloaded operator.
    -->
    <para>
      En C y C++, si el compilador encuentra una expresión o una llamada
      a función que usa un tipo que no es el que requiere, puede
      usualmente realizar una conversión automática de tipos desde el
      tipo que tiene hasta el tipo que necesita. En C++, puede conseguir
      este mismo efecto para los tipos definidos por el usuario creando
      funciones de conversión de tipos automática. Estas funciones se
      pueden ver en dos versiones:un tipo particular de constructores y
      un operador sobrecargado.
    </para>

    <sect2>
      <!-- : Constructor conversion -->
      <title>Conversión por constructor</title>

      <!--
      If you define a constructor that takes as its single argument an object (or reference)
      of another type, that constructor allows the compiler to perform an automatic type
      conversion. For example,
      -->
      <para>
	Si define un constructor que toma como su ónico argumento un
	objeto(o referencia) de otro tipo, ese constructor permite al
	compilador realizar una conversión automática de tipos. Por
	ejemplo:
      </para>



//: V1C12:AutomaticTypeConversion.cpp


      <!--
      When the compiler sees f( ) called with a One object, it looks at the declaration for f
      ( ) and notices it wants a Two. Then it looks to see if there's any way to get a Two
      from a One, and it finds the constructor Two::Two(One), which it quietly calls. The
      resulting Two object is handed to f( ).
      -->
      <para>
	Cuando el compilador ve <function>f()</function> llamada con un
	objeto <varname>One</varname>, mira en la declaración de
	<function>f()</function> y nota que requiere un
	<varname>Two</varname>. Entonces busca si hay alguna manera de
	conseguir un <varname>Two</varname> de un
	<varname>One</varname>, y encuentra el constructor
	<function>Two::Two(One)</function> al cual llama. El objeto
	resultante <varname>Two</varname> es pasado a
	<function>f()</function>.
      </para>

      <!--
      In this case, automatic type conversion has saved you from the trouble of defining two
      overloaded versions of f( ). However, the cost is the hidden constructor call to Two,
      which may matter if you're concerned about the efficiency of calls to f( ).
      -->
      <para>
	En este caso, la conversión automática de tipos le ha salvado
	del problema de definir dos versiones sobrecargadas de
	<function>f()</function>. Sin embargo el coste es la llamada
	oculta al constructor de <varname>Two</varname> lo cual puede
	importar si está preocupado por la eficiencia de las llamadas a
	<function>f()</function>,
      </para>

      <sect3>
        <!-- : Preventing constructor conversion -->
	<title>Evitar la conversión por constructor</title>

        <!--
        There are times when automatic type conversion via the constructor can cause problems.
        To turn it off, you modify the constructor by prefacing with the keyword explicit (which
        only works with constructors). Used to modify the constructor of class Two in the
        example above:
        -->
	<para>
	  Hay veces que la conversión automática de tipos via
	  constructor puede ocasionar problemas. Para desactivarlo,
	  modifique el constructor anteponiéndole la palabra reservada
	  <kw>explicit</kw>(que sólo funciona
	  con constructores). Así se ha hecho para modificar el
	  constructor de la clase <classname>Two</classname> en el
	  ejemplo anterior:
	</para>



//: V1C12:ExplicitKeyword.cpp


        <!--
        By making Two's constructor explicit, the compiler is told not to perform any automatic
        conversion using that particular constructor (other non-explicit constructors in that
        class can still perform automatic conversions). If the user wants to make the conversion
        happen, the code must be written out. In the code above, f(Two(one)) creates a temporary
        object of type Two from one, just like the compiler did in the previous version.
        -->
	<para>
	  Haciendo el constructor de <varname>Two</varname> explicito,
	  se le dice al compilador que no realice ninguna conversión
	  automática de tipos usando ese constructor en particular(otros
	  constructores no explicitos en esa clase pueden todavia
	  realizar conversiones automáticas). Si el usuario quiere que
	  ocurra esa conversión, debe escribir el codigo necesario. En
	  el codigo de arriba, <function>f(Two(one))</function> crea un
	  objeto temporal de tipo <varname>Two</varname> desde
	  <varname>one</varname>, justo como el compilador hizo en la
	  versión previa.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <!-- : Operator conversion -->
      <title>Conversión por operador</title>

      <!--
      The second way to produce automatic type conversion is through operator overloading. You
      can create a member function that takes the current type and converts it to the desired
      type using the operator keyword followed by the type you want to convert to. This form
      of operator overloading is unique because you don't appear to specify a return type -
      the return type is the name of the operator you're overloading. Here's an example:
      -->
      <para>
	La segunda manera de producir conversiones automáticas de tipos
	es a través de la sobrecarga de operadores. Puede crear una
	función miembro que tome el tipo actual y lo convierta en el
	tipo deseado usando la palabras reservada <oper>operator</oper> seguida del tipo al que
	quiere convertir. Esta forma de sobrecarga de operadores es
	ónica porque parece que no se especifica un tipo de retorno - el
	tipo de retorno es el nombre del operador que está
	sobrecargando. He aquí un ejemplo:
      </para>



//: V1C12:OperatorOverloadingConversion.cpp


      <!--
      With the constructor technique, the destination class is performing the conversion, but
      with operators, the source class performs the conversion. The value of the constructor
      technique is that you can add a new conversion path to an existing system as you're
      creating a new class. However, creating a single-argument constructor always defines an
      automatic type conversion (even if it's got more than one argument, if the rest of the
      arguments are defaulted), which may not be what you want (in which case you can turn it
      off using explicit). In addition, there's no way to use a constructor conversion from a
      user-defined type to a built-in type; this is possible only with operator overloading.
      -->
      <para>
	Con la técnica del constructor, la clase destino realiza la
	conversión, pero con los operadores, la realiza la clase
	origen. Lo valioso dela técnica del constructor es que puede
	añadir una nueva ruta de conversión a un sistema existente
	mientras está creando una nueva clase. Sin embargo, creando un
	constructor con un ónico argumento siempre define una conversión
	automática de tipos(incluso si requiere más de un argumento si
	el resto de los argumentos tiene un valor por defecto), que
	puede no ser lo que desea(en cuyo caso puede desactivarlo usando
	<kw>explicit</kw>). Además, no hay
	ninguna manera de usar una conversión por constructor desde un
	tipo definido por el usuario a un tipo incorporado;esto es
	posible solo con la sobrecarga de operadores.
      </para>


      <sect3>
        <!-- : Reflexivity -->
	<title>Reflexividad</title>

        <!--
        One of the most convenient reasons to use global overloaded operators instead of member
        operators is that in the global versions, automatic type conversion may be applied to
        either operand, whereas with member objects, the left-hand operand must already be the
        proper type. If you want both operands to be converted, the global versions can save a
        lot of coding. Here's a small example:
	-->
	<para>
	  Una de las razones mas normales para usar operadores
	  sobrecargados globales en lugar de operadores miembros es que
	  en la versión global, la conversión automática de tipos puede
	  aplicarse a cualquiera de los operandos, mientras que con
	  objetos miembro, el operando de la parte izquierda debe ser
	  del tipo apropiado. Si quiere que ambos operandos sean
	  convertidos, la versión global puede ahorrarle un montón de
	  código. He aquí un pequeño ejemplo:
	</para>



//: V1C12:ReflexivityInOverloading.cpp


        <!--
        Class Number has both a member operator+ and a friend operator-. Because there's a
        constructor that takes a single int argument, an int can be automatically converted to a
        Number, but only under the right conditions. In main( ), you can see that adding a
        Number to another Number works fine because it's an exact match to the overloaded
        operator. Also, when the compiler sees a Number followed by a + and an int, it can match
        to the member function Number::operator+ and convert the int argument to a Number using
        the constructor. But when it sees an int, a +, and a Number, it doesn't know what to do
        because all it has is Number::operator+, which requires that the left operand already be
        a Number object. Thus, the compiler issues an error.
        -->
	<para>
	  La clase <classname>Number</classname> tiene tanto un miembro
	  <oper>operator+</oper> como un <oper>firiend
	  operator-</oper>. Dado que hay un constructor que acepta un
	  argumento <type>int</type> simple, un <type>int</type> puede
	  ser convertido automáticamente a un <type>Number</type>, pero
	  sólo bajo las condiciones adecuadas. En
	  <function>main()</function>, puede ver que añadir un
	  <type>Number</type> a otro <type>Number</type> funciona bien
	  dado que tiene una correspondencia exacta con el operador
	  sobrecargado. Además, cuando el compilador ve un
	  <type>Number</type> seguido de un <oper>+</oper> y de un
	  <type>int</type>, puede emparejarlo a la función miembro
	  <function>Number::operator+</function> y convertir el
	  argumento<type>int</type> a un <type>Number</type> usando el
	  constructor. Pero cuando ve un <type>int</type>, un
	  <oper>+</oper> y un <type>Number</type>, no sabe que hacer
	  porque todo lo que tiene es <oper>Number::operator+</oper> el
	  cual requiere que el operando de la izquierda sea ya un objeto
	  <type>Number</type>. Así que, el compilador emite un error.
	</para>

        <!--
        With the friend operator-, things are different. The compiler needs to fill in both its
        arguments however it can; it isn't restricted to having a Number as the left-hand
        argument. Thus, if it sees
        -->
	<para>
	  Con <oper>friend operator-</oper> las
	  cosas son diferentes. El compilador necesita rellenar ambos
	  argumentos como quiera que pueda; no está restringido a tener
	  un <type>Number</type> como argumento de la parte
	  izquierda. Asi que si ve:
	</para>


<programlisting>
    1 - a
</programlisting>

        <!-- it can convert the first argument to a Number using the constructor. -->
	<para>
	  puede convertir el primer argumento a un <type>Number</type>
	  usando el constructor.
	</para>

       <!--
        Sometimes you want to be able to restrict the use of your operators by making them
        members. For example, when multiplying a matrix by a vector, the vector must go on the
        right. But if you want your operators to be able to convert either argument, make the
        operator a friend function.
        -->
	<para>
	  A veces querrá ser capaz de restringir el uso de sus
	  operadores haciéndolos miembros. Por ejemplo, cuando
	  multiplique una matriz por un vector, el vector debe ir en la
	  derecha. Pero si quiere que sus operadores sean capaces de
	  convertir cualquier argumento, haga el operador una función
	  <kw>friend</kw>.
	</para>

        <!--
        Fortunately, the compiler will not take 1 - 1 and convert both arguments to Number
        objects and then call operator-. That would mean that existing C code might suddenly
        start to work differently. The compiler matches the "simplest" possibility first, which
        is the built-in operator for the expression 1 - 1.
        -->
	<para>
	  Afortunadamente, el compilador cogerá la expresión
	  <code>1-1</code> y convertirá ambos
	  argumentos a objetos <classname>Number</classname> y despues
	  llamará a <oper>operator-</oper>. Eso
	  significaría que el código C existente pudiera empezar a
	  funcionar de forma diferente. El compilador encaja la
	  posibilidad mas simple primero, la cual es el operador
	  incorporado para la expresión
	  <code>1-1</code>.
	</para>
      </sect3>
    </sect2>


    <sect2>
      <!-- : Type conversion example -->
      <title>Ejemplo de conversión de tipos</title>

      <!--
      An example in which automatic type conversion is extremely helpful occurs with any class
      that encapsulates character strings (in this case, we will just implement the class
      using the Standard C++ string class because it's simple). Without automatic type
      conversion, if you want to use all the existing string functions from the Standard C
      library, you have to create a member function for each one, like this:
      -->
      <para>
	Un ejemplo en el que la conversión automática de tipos es
	extremadamente útil es con cualquier clase que encapsule una
	cadena de caracteres(en este caso, simplemente implementaremos
	la clase usando la clase estándar de C++ <type>string</type>
	dado que es simple). Sin la conversión automática de tipos, si
	quiere usar todas las funciones existentes de string de la
	librería estándar de C, tiene que crear una función miembro para
	cada una, así:
      </para>



//: V1C12:Strings1.cpp


      <!--
      Here, only the strcmp( ) function is created, but you'd have to create a corresponding
      function for every one in <cstring> that might be needed. Fortunately, you can provide
      an automatic type conversion allowing access to all the functions in <cstring>:
      -->
      <para>
	Aquí, sólo se crea la función <function>strcmp()</function>,
	pero tendría que crear las correspondientes funciones para cada
	una de <filename>&#60;cstring></filename> que
	necesitará. Afortunadamente, puede proporcionar una conversión
	automática de tipos permitiendo el acceso a todas las funciones
	de <classname>cstring</classname>.
      </para>



//: V1C12:Strings2.cpp


      <!--
      Now any function that takes a char* argument can also take a Stringc argument because
      the compiler knows how to make a char* from a Stringc.
      -->
      <para>
	Ahora cualquier función que tome un argumento <type>char*</type>
	puede tomar también un argumento <classname>Stringc</classname>
	porque el compilador sabe como crear un <type>char*</type> de un
	<classname>Stringc</classname>.
      </para>
    </sect2>


    <sect2>
      <!-- : Pitfalls in automatic type conversion -->
      <title>Las trampas de la  conversión automática de tipos</title>

      <!--
      Because the compiler must choose how to quietly perform a type conversion, it can get
      into trouble if you don't design your conversions correctly. A simple and obvious
      situation occurs with a class X that can convert itself to an object of class Y with an
      operator Y( ). If class Y has a constructor that takes a single argument of type X, this
      represents the identical type conversion. The compiler now has two ways to go from X to
      Y, so it will generate an ambiguity error when that conversion occurs:
      -->
      <para>
	Dado que el compilador debe elegir como realizar una conversión
	de tipos, puede meterse en problemas si no usted no diseña las
	conversiones correctamente. Una situación obvia y simple sucede
	cuando una clase <classname>X</classname> que puede convertirse
	a sí misma en una clase <classname>Y</classname> con un
	<oper>operator Y()</oper>. Si la clase <classname>Y</classname>
	tiene un constructor que toma un argumento simple de tipo
	<classname>X</classname>, esto representa la conversión de tipos
	por identidad. El compilador ahora tiene dos formas de ir de
	<classname>X</classname> a <classname>Y</classname>, asi que se
	generará una error de ambigüedad cuando esa conversión ocurra:
      </para>



//: V1C12:TypeConversionAmbiguity.cpp


      <!--
      The obvious solution to this problem is not to do it. Just provide a single path for
      automatic conversion from one type to another.
      -->
      <para>
	La solución obvia a este problema es no hacerla. Simplemente
	proporcione una ruta ónica para la conversión automática de un
	tipo a otro.
      </para>

      <!--
      A more difficult problem to spot occurs when you provide automatic conversion to more
      than one type. This is sometimes called fan-out:
      -->
      <para>
	Un problema más difícil de eliminar sucede cuando proporciona
	conversiones automáticas a más de un tipo. Esto se llama a veces
	<emphasis>acomodamiento</emphasis>:
      </para>



//: V1C12:TypeConversionFanout.cpp


      <!--
      Class Apple has automatic conversions to both Orange and Pear. The insidious thing about
      this is that there's no problem until someone innocently comes along and creates two
      overloaded versions of eat( ). (With only one version, the code in main( ) works fine.)
      -->
      <para>
	La clase <classname>Apple</classname> tiene conversiones
	automáticas a <classname>Orange</classname> y a
	<classname>Pear</classname>. El elemento capcioso sobre esto es
	que no hay problema hasta que alguien inocentemente crea dos
	versiones sobrecargadas de <function>eat()</function>. (Con sólo
	una versión el codigo en <function>main()</function> funciona
	correctamente).
      </para>

      <!--
      Again, the solution - and the general watchword with automatic type conversion - is to
      provide only a single automatic conversion from one type to another. You can have
      conversions to other types; they just shouldn't be automatic. You can create explicit
      function calls with names like makeA( ) and makeB( ).
      -->
      <para>
	De nuevo la solución - y el lema general de la conversión
	automática de tipos- es proveer solo una ónica conversión
	automática de un tipo a otro. Puede tener conversiones a otros
	tipos, sólo que no deberían ser
	<emphasis>automaticas</emphasis>. Puede crear llamadas a
	funciones explicitas con nombres como
	<function>makeA()</function> y <function>makeB()</function>.
      </para>

      <sect3>
        <!-- : Hidden activities -->
	<title>Actividades ocultas</title>

        <!--
        Automatic type conversion can introduce more underlying activities than you may expect.
        As a little brain teaser, look at this modification of CopyingVsInitialization.cpp:
        -->
	<para>
	  La conversión automática de tipos puede producir mas actividad
	  subyacente de la que podría esperar. Mire esta modificación de
	  <filename>CopyingVsInitialization.cpp</filename> como un juego
	  de inteligencia:
	</para>



//: V1C12:CopyingVsInitialization2.cpp


        <!--
        There is no constructor to create the Fee fee from a Fo object. However, Fo has an
        automatic type conversion to a Fee. There's no copy-constructor to create a Fee from a
        Fee, but this is one of the special functions the compiler can create for you. (The
        default constructor, copy-constructor, operator=, and destructor can be synthesized
        automatically by the compiler.) So for the relatively innocuous statement
        -->
	<para>
	  No hay un constructor para crear <varname>Fee fee</varname> de
	  un objeto <classname>Fo</classname>. Sin embargo,
	  <classname>Fo</classname> tiene una conversión automática de
	  tipos a <classname>Fee</classname>. No hay un constructor de
	  copia para crear un <classname>Fee</classname> de un
	  <classname>Fee</classname>, pero esta es una de las funciones
	  especiales que el compilador puede crear por usted. (El
	  constructor por defecto, el constructor de copia y
	  <oper>operator=</oper>) y el destructor puede sintetizarse
	  automáticamente por el compilador. Asi que para la
	  relativamente inocua expresión:
	</para>


<programlisting>
Fee fee = fo;
</programlisting>


        <!-- the automatic type conversion operator is called, and a copy-constructor is created. -->
	<para>
	  el operador de conversión automática es llamado, y se crea un
	  constructor de copia.
	</para>

        <!--
        Use automatic type conversion carefully. As with all operator overloading, it's
        excellent when it significantly reduces a coding task, but it's usually not worth using
        gratuitously.
        -->
	<para>
	  Use la conversión automática de tipos con precaución. Como con
	  toda la sobrecarga de operadores, es excelente cuando reduce
	  la tarea de codificación significativamente, pero no vale la
	  pena usarla de forma gratuita.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Resumen</title>

    <!--
    The whole reason for the existence of operator overloading is for those situations when
    it makes life easier. There's nothing particularly magical about it; the overloaded
    operators are just functions with funny names, and the function calls happen to be made
    for you by the compiler when it spots the right pattern. But if operator overloading
    doesn't provide a significant benefit to you (the creator of the class) or the user of
    the class, don't confuse the issue by adding it.
    -->
    <para>
      La completa razón para la existencia de la sobrecarga de
      operadores es para aquellas situaciones cuando simplifica la
      vida. No hay nada particularmente mágico sobre ello;los operadores
      sobrecargados son solo funciones con nombres divertidos, y las
      llamadas a función son llamadas por el compilador para usted
      cuando se satisface el patrón adecuado. Pero si la sobrecarga de
      operadores no proporciona un beneficio significativo para usted(el
      creador de la clase) o para el usuario de la clase, no complique
      el asunto añadiéndolo.
    </para>
  </sect1>

  <sect1>
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>
	<!-- Create a simple class with an overloaded operator++. Try
	calling this operator in both pre- and postfix form and see
	what kind of compiler warning you get.  -->
	<para>
	  Cree una clase sencilla con un operador sobrecargado
	  <oper>++</oper>. Intente llamar a este operador en la forma
	  prefija y posfija y vea que clase de advertencia del
	  compilador obtiene.
	</para>
      </listitem>
      <listitem>
	<!-- Create a simple class containing an int and overload the
	operator+ as a member function. Also provide a print( ) member
	function that takes an ostream& as an argument and prints to
	that ostream&. Test your class to show that it works
	correctly.  -->
	<para>
	  Cree una clase sencilla que contenga un <type>int</type> y
	  sobrecargue el operador <oper>+</oper>
	  como una función miembro. También cree una función miembro
	  <function>print()</function> que tome un
	  <classname>ostream&amp;</classname> como un argumento y lo
	  imprima a un
	  <classname>ostream&amp;</classname>. Experimente con su
	  clase para comprobar que funciona correctamente.
	</para>
      </listitem>
      <listitem>

	<!-- Add a binary operator- to Exercise 2 as a member
	function. Demonstrate that you can use your objects in complex
	expressions like --><para> Añada un operador binario
	<oper>-</oper> al ejercicio 2 como una función
	miembro. Demuestre que puede usar sus objetos in expresiones
	complejas como <literal>a + b -c</literal>.
	</para>
      </listitem>
      <listitem>
	<!-- Add a binary operator- to Exercise 2 as a member
	function. Demonstrate that you can use your objects in complex
	expressions like -->
	<para>
	  Añada un operador <oper>++</oper> y
	  otro <oper>--</oper> al ejercicio 2,
	  ambos con las versiones prefijas y postfijas, tales que
	  devuelvan el objeto incrementado o decrementado. Asegurese
	  que la versión posfija devuelve el valor adecuado.
	</para>
      </listitem>
      <listitem>
	<!-- Add an operator++ and operator-- to Exercise 2, both the
	prefix and the postfix versions, such that they return the
	incremented or decremented object. Make sure that the postfix
	versions return the correct value.  -->
	<para>
	  Modifique los operadores de incremento y de decremento del
	  ejercicio 4 para que la versión prefija devuelva a
	  referencia no <kw>const</kw> y la
	  posfija devuelva un objeto <kw>const</kw>. Muestre que funcionan
	  correctamente y explique por qué esto se puede hacer en la
	  práctica.
	</para>
      </listitem>
      <listitem>
	<!-- Change the print( ) function in Exercise 2 so that it is
	the overloaded operator<< as in
	IostreamOperatorOverloading.cpp.  -->

	<para>
	  Cambie la función <function>print()</function> del
	  ejercicio2 para que use el operador sobrecargado <oper>&#60;&#60;</oper> como en
	  <filename>IostreamOperatorOverloading.cpp</filename>.
	</para>
      </listitem>
      <listitem>
	<!-- Modify Exercise 3 so that the operator+ and operator- are
	non-member functions. Demonstrate that they still work
	correctly.  -->
	<para>
	  Modifique el ejercicio 3 para que los operadores
	  <oper>+</oper> y <oper>-</oper> sean funciones no
	  miembro. Demuestre que todavía funcionan correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- Add the unary operator- to Exercise 2 and demonstrate
	that it works correctly.  -->
	<para>
	  Añada el operador unario <oper>-</oper> al ejercicio 2 y demuestre que
	  funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class that contains a single private
	char. Overload the iostream operators << and >> (as in
	IostreamOperatorOverloading.cpp) and test them. You can test
	them with fstreams, stringstreams, and cin and cout.  -->
	<para>
	  Cree una clase que contenga un único <type>private
	    char</type>. Sobrecargue los operadores de flujos de
	  entrada/salida <oper>&#60;&#60;</oper> y
	  <oper>>></oper>(como en
	  <filename>IostreamOperatorOverloading.cpp</filename>) y
	  pruebelos. Puede probarlos con <literal>fstreams</literal>,
	  <literal>stringstreams</literal> y <literal>cin</literal> y
	  <literal>cout</literal> .
	</para>
      </listitem>
      <listitem>
	<!-- Determine the dummy constant value that your compiler
	passes for postfix operator++ and operator--.  -->
	<para>
	  Determine el valor constante ficticio que su compilador pasa
	  a los operadores posfijos <oper>++</oper> y
	  <oper>--</oper>.
	</para>
      </listitem>
      <listitem>
	<!-- Write a Number class that holds a double, and add
	overloaded operators for +, , *, /, and assignment. Choose the
	return values for these functions so that expressions can be
	chained together, and for efficiency. Write an automatic type
	conversion operator intdouble( ).  -->
	<para>
	  Escriba una clase <classname>Number</classname> que contenga
	  un <type>double</type> y añada operadores sobrecargados para
	  <oper>+</oper>, <oper>-</oper>, <oper>*</oper>, <oper>/</oper> y la asignación. Elija los
	  valores de retorno para estas funciones para que las
	  expresiones puedan ser encadenadas juntas y para que sea
	  eficiente.  Escriba una conversión automática de tipos
	  <type>operator int()</type>.
	</para>
      </listitem>
      <listitem>
	<!-- Modify Exercise 11 so that the return value optimization
	is used, if you have not already done so.  -->
	<para>
	  Modifique el ejercicio 11 para que use la
	  <emphasis>optimización del valor de retorno</emphasis>, si
	  todavía no lo ha hecho.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class that contains a pointer, and demonstrate
	that if you allow the compiler to synthesize the operator= the
	result of using that operator will be pointers that are
	aliased to the same storage. Now fix the problem by defining
	your own operator= and demonstrate that it corrects the
	aliasing. Make sure you check for self-assignment and handle
	that case properly.  -->
	<para>
	  Cree una clase que contenga un puntero, y demuestre que si
	  permite al compilador sintetizar el operador <oper>=</oper> el resultado de usar ese
	  operador serán punteros que estarán solapados en la misma
	  localización de memoria. Ahora arregle el problema
	  definiendo su propio operador <oper>=</oper> y demuestre que corrige el
	  solapamiento. Asegórese que comprueba la auto asignación y
	  que maneja el caso apropiadamente.
	</para>
      </listitem>
      <listitem>
	<!-- Write a class called Bird that contains a string member
	and a static int. In the default constructor, use the int to
	automatically generate an identifier that you build in the
	string, along with the name of the class (Bird #1, Bird #2,
	etc.). Add an operator<< for ostreams to print out the Bird
	objects. Write an assignment operator= and a
	copy-constructor. In main( ), verify that everything works
	correctly.  -->
	<para>
	  Escriba una clase llamada <classname>Bird</classname> que
	  contenga un miembro <type>string</type> y un <type>static
	    int</type>. El el constructor por defecto, use el
	  <type>int</type> para generar automáticamente un
	  identificador que usted construya en la <type>string</type>
	  junto con el nombre de la clase(<varname>Bird #1</varname>,
	  <varname>Bird #2</varname>, etc). Añada un operador <oper>&#60;&#60;</oper> para flujos de salida
	  para imprimir los objetos
	  <classname>Bird</classname>-Escriba un operador de
	  asignación <oper>=</oper> y un
	  constructor de copia. En <function>main()</function>
	  verifique que todo funciona correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- Write a class called BirdHouse that contains an object, a
	pointer and a reference for class Bird from Exercise 14. The
	constructor should take the three Birds as arguments. Add an
	operator<< for ostreams for BirdHouse. Write anDisallow the
	assignment operator= and a copy-constructor. In main( ),
	verify that everything works correctly. Make sure that you can
	chain assignments for BirdHouse objects and build expressions
	involving multiple operators.  -->
	<para>
	  Escriba una clase llamada <classname>BirdHouse</classname>
	  que contenga un objeto, un puntero y una referencia para la
	  clase <classname>Bird</classname> del ejercicio 14. El
	  constructor debería tomar 3 <classname>Birds</classname>
	  como argumentos. Añada un operador <oper>&#60;&#60;</oper> de flujo de salida para
	  <classname>BirdHouse</classname>. Deshabilite el operador de
	  asignación <oper>=</oper> y el
	  constructor de copia. En <function>main()</function>
	  verifique que todo funciona correctamente. Asegórese de que
	  puede encadenar asignaciones para objetos
	  <classname>BirdHouse </classname> y construya expresiones
	  que involucren a móltiples operadores.
	</para>
      </listitem>
      <listitem>
	<!-- Add an int data member to both Bird and BirdHouse in
	Exercise 15. Add member operators +, -, *, and / that use the
	int members to perform the operations on the respective
	members. Verify that these work.  -->
	<para>
	  Añada un miembro de datos <type>int</type> a
	  <classname>Bird</classname> y a
	  <classname>BirdHouse</classname> en el ejercicio 15. Añada
	  operadores miembros <oper>+</oper>,
	  <oper>-</oper>, <oper>*</oper> y <oper>/</oper> que usen el miembro
	  <type>int</type> para realizar las operaciones en los
	  respectivos miembros. Verifique ques estas funcionan.
	</para>
      </listitem>
      <listitem>
	<!-- Repeat Exercise 16 using non-member operators.  -->
	<para>
	  Repita el ejercicio 16 usando operadores no miembros.
	</para>
      </listitem>
      <listitem>

	<!-- Add an operator-- to SmartPointer.cpp and
	NestedSmartPointer.cpp.  -->
	<para>
	  Añada un operador <oper>-</oper> a
	  <filename>SmartPointer.cpp</filename> y a
	  <filename>NestedSmartPointer.cpp</filename>.
	</para>
      </listitem>
      <listitem>

	<!-- Modify CopyingVsInitialization.cpp so that all of the
	constructors print a message that tells you what's going
	on. Now verify that the two forms of calls to the
	copy-constructor (the assignment form and the parenthesized
	form) are equivalent.  -->
	<para>
	  Modifique <filename>CopyingVsInitialization.cpp</filename>
	  para que todos los constructores impriman un mensaje que
	  cuente que está pasando. Ahora verifique que las dos maneras
	  de llamar al constructor de copia(la de asignación y la de
	  parentesis) son equivalentes.
	</para>
      </listitem>
      <listitem>

	<!-- Attempt to create a non-member operator= for a class and
	see what kind of compiler message you get.  -->
	<para>
	  Intente crear un operador no miembro <oper>=</oper> para una clase y vea que clase
	  de mensaje del compilador recibe.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class with an copy-constructor assignment
	operator that has a second argument, a string that has a
	default value that says CC op= call. Create a function that
	takes assigns an object of your class by value to another one
	and show that your copy-constructorassignment operator is
	called correctly.  -->
	<para>
	  Cree una clase con un operador de asignación que tenga un
	  segundo argumento, una <classname>string</classname> que
	  tenga un valor por defecto que diga <quote>op =
	    call</quote>. Cree una función que asigne un objeto de su
	  clase a otro y muestre que su operador de asignación es
	  llamado correctamente.
	</para>
      </listitem>
      <listitem>
	<!-- In CopyingWithPointers.cpp, remove the operator= in
	DogHouse and show that the compiler-synthesized operator=
	correctly copies the string but simply aliases the Dog
	pointer.  -->
	<para>
	  En <filename>CopyingWithPointers.cpp</filename> elimine el
	  operador <oper>=</oper> en
	  <classname>DogHouse</classname> y muestre el el operador
	  <oper>=</oper> sintetizado por el
	  compilador copia correctamente <classname>string</classname>
	  pero simplemente solapa el puntero a
	  <classname>Dog</classname>.
	</para>
      </listitem>
      <listitem>
	<!-- In ReferenceCounting.cpp, add a static int and an
	ordinary int as data members to both Dog and DogHouse. In all
	constructors for both classes, increment the static int and
	assign the result to the ordinary int to keep track of the
	number of objects that have been created. Make the necessary
	modifications so that all the printing statements will say the
	int identifiers of the objects involved.  -->
	<para>
	  En <filename>ReferenceCounting.cpp</filename> añada un
	  <type>static int</type> y un <type>int</type> ordinario como
	  miembros de datos a <classname>Dog</classname> y a
	  <classname>DogHouse</classname>. En todos los constructores
	  para ambas clases, incremente el <type>static int</type> y
	  asigne el resultado al <type>int</type> ordinario para
	  mantener un seguimiento del nómero de objetos que están
	  siendo creados. Haga las modificaciones necesarias para que
	  todas las sentencias de impresin muestren los
	  identificadores <type>int</type> de los objetos
	  involucrados.
	</para>
      </listitem>
      <listitem>
	<!-- Create a class containing a string as a data
	member. Initialize the string in the constructor, but do not
	create a copy-constructor or operator=. Make a second class
	that has a member object of your first class; do not create a
	copy-constructor or operator= for this class
	either. Demonstrate that the copy-constructor and operator=
	are properly synthesized by the compiler.  -->

	<para>
	  Cree una clase que contenga un <classname>string</classname>
	  como un mimebro de datos. Inicialice el
	  <classname>string</classname> en el constructor, pero no cree
	  un constructor de copia o un operador <oper>=</oper>. Haga una
	  segunda clase que tenga un objeto miembro de su primera
	  clase;no cree un constructor de copia o un operador
	  <oper>=</oper> para esta clase tampoco. Demuestre que el
	  constructor de copia y el operador <oper>=</oper> son
	  sintetizados correctamente por el compilador.
	</para>
      </listitem>
      <listitem>
	<!-- Combine the classes in OverloadingUnaryOperators.cpp and
	Integer.cpp.  -->
	<para>
	  Combine las clases en
	  <filename>OverloadingUnaryOperators.cpp</filename> y en
	  <filename>Integer.cpp</filename>.
	</para>
      </listitem>
      <listitem>
	<!-- Modify PointerToMemberOperator.cpp by adding two new
	member functions to Dog that take no arguments and return
	void. Create and test an overloaded operator->* that works
	with your two new functions.  -->
	<para>
	  Modifique <filename>PointerToMemmberOperator.cpp</filename>
	  añadiendo dos nuevas funciones miembro a
	  <classname>Dog</classname> que no tomen argumentos y
	  devuelvan <type>void</type>. Cree y compruebe un operador
	  sobrecargado <oper>->*</oper> que
	  funcione con sus dos nuevas funciones.
	</para>
      </listitem>
      <listitem>
	<!-- Add an operator->* to NestedSmartPointer.cpp.  -->
	<para>
	  Añada un operador <oper>->*</oper> a
	  <filename>NestedSmartPointer.cpp</filename>.
	</para>
      </listitem>
      <listitem>
	<!-- Create two classes, Apple and Orange. In Apple, create a
	constructor that takes an Orange as an argument. Create a
	function that takes an Apple and call that function with an
	Orange to show that it works. Now make the Apple constructor
	explicit to demonstrate that the automatic type conversion is
	thus prevented. Modify the call to your function so that the
	conversion is made explicitly and thus succeeds.  -->
	<para>
	  Cree dos clases, <classname>Apple</classname> y
	  <classname>Orange</classname>. En
	  <classname>Apple</classname>, cree un constructor que tome
	  una <classname>Orange</classname> como un argumento. Cree
	  una función que tome un <classname>Apple</classname> y llame
	  a esa función con una una <classname>Orange</classname> para
	  demostrar que funciona. Ahora haga explicito el constructor
	  de <classname>Apple</classname> para demostrar que la
	  conversión automática de tipos es prevenida así. Modifique
	  la llamada a su función para que la la conversión se haga
	  explicitamente y así funcione.
	</para>
      </listitem>
      <listitem>
	<!-- Add a global operator* to ReflexivityInOverloading.cpp
	and demonstrate that it is reflexive.  -->
	<para>
	  Añada un operador global <oper>*</oper> a
	  <filename>ReflexivityInOverloading.cpp</filename> y
	  demuestre que es reflexivo.
	</para>
      </listitem>
      <listitem>
	<!-- Create two classes and create an operator+ and the
	conversion functions such that addition is reflexive for the
	two classes.  -->
	<para>
	  Cree dos clases y un operador <oper>+</oper> y las funciones de conversión de
	  tal manera que la adicción sea reflexiva para las dos clases.
	</para>
      </listitem>
      <listitem>

	<!-- Fix TypeConversionFanout.cpp by creating an explicit
	function to call to perform the type conversion, instead of
	one of the automatic conversion operators.  -->
	<para>
	  Arregle <filename>TypeConversionFanout.cpp</filename> creando
	  una  función explicita para realizar la conversión de tipo,
	  en lugar de uno de los operadoes de conversión automáticos.
	</para>
      </listitem>
      <listitem>
	<!-- Write simple code that uses the +, -, *, and / operators
	for doubles. Figure out how your compiler generates assembly
	code and look at the assembly language that's generated to
	discover and explain what's going on under the hood.  -->
	<para>
	  Escriba un código simple que use los operadores
	  <oper>+</oper>, <oper>-</oper>, <oper>*</oper>, <oper>/</oper>
	  para <type>double</type>. Imaginese como el compilador genera
	  el codigo ensamblador y mire el ensamblador que se genera para
	  descubir y explicar que está ocurriendo bajo el envoltorio.
	</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>
