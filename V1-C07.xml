<?xml  version="1.0" encoding="latin-1"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: Javier Corrales García
  Formateado DocBook:  Javier Corrales García
  1ª Revisión:
  2ª Revisión
-->


<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<chapter
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="C7">

  <!-- Function Overloading & Default Arguments -->
  <title>Sobrecarga de funciones y argumentos por defecto</title>

  <!--
  One of the important features in any programming language is
  the convenient use of names.
  -->
  <highlights>
    <para>
      Una de las características más importantes en cualquier lenguaje
      de programación es la utilización adecuada de los nombres.
    </para>
  </highlights>


  <!--
  When you create an object (a variable), you give a name to a region of
  storage. A function is a name for an action. By making up names to
  describe the system at hand, you create a program that is easier for
  people to understand and change. It's a lot like writing prose - the
  goal is to communicate with your readers.
  -->
  <para>
    Cuando crea un objeto (una variable) le está asignando un nombre a
    una región de memoria. Una función es un nombre para una
    acción. El hecho de poner nombres adecuados a la hora de
    describir un sistema hace que un programa sea más fácil de
    entender y modificar. Es muy parecido a la prosa escrita, el
    objetivo es comunicarse con los lectores.
  </para>


  <!--
  A problem arises when mapping the concept of nuance in human language
  onto a programming language. Often, the same word expresses a number
  of different meanings, depending on context. That is, a single word
  has multiple meanings - it's overloaded. This is very useful,
  especially when it comes to trivial differences. You say "wash the
  shirt, wash the car. It would be silly to be forced to say,
  "shirt_wash the shirt, car_wash the car just so the listener doesn't
  have to make any distinction about the action performed. Human
  languages have built-in redundancy, so even if you miss a few words,
  you can still determine the meaning. We don't need unique identifiers
  - we can deduce meaning from context.
  -->
  <para>
    Cuando se trata de representar sutilezas del lenguaje humano en un
    lenguaje de programación aparecen los problemas. A menudo, la
    misma palabra expresa diversos significados dependiendo del
    contexto. Una palabra tiene múltiples significados, es decir, está
    sobrecargada (polisemia). Esto es muy útil, especialmente cuando
    las diferencias son obvias. Puede decir <quote>lave la camiseta,
    lave el coche.</quote> Sería estúpido forzar la expresión anterior
    para convertirla en <quote>lavar_camiseta la camiseta, lavar_coche
    el coche</quote> pues el oyente no tiene que hacer ninguna
    distinción sobre la acción realizada. Los lenguajes humanos son
    muy redundantes, así que incluso si pierde algunas palabras,
    todavía puede determinar el significado. Los identificadores
    únicos no son necesarios, pues se puede deducir el significado a
    través del contexto.
  </para>


  <!--
  Most programming languages, however, require that you have a unique
  identifier for each function. If you have three different types of
  data that you want to print: int, char, and float, you generally have
  to create three different function names, for example, print_int( ),
  print_char( ), and print_float( ). This loads extra work on you as you
  write the program, and on readers as they try to understand it.
  -->
  <para>
    Sin embargo, la mayoría de los lenguajes de programación requieren
    que se utilice un identificador único para cada función. Si tiene
    tres tipos diferentes de datos que desee imprimir en la salida:
    <emphasis>int</emphasis>, <emphasis>char</emphasis> y
    <emphasis>float</emphasis>, generalmente tiene que crear tres
    funciones diferentes, como por ejemplo
    <function>print_int()</function>,
    <function>print_char()</function> y
    <function>print_float()</function>. Esto constituye un trabajo
    extra tanto para el programador, al escribir el programa, como
    para el lector que trate de entenderlo.
  </para>


  <!--
  In C++, another factor forces the overloading of function names: the
  constructor. Because the constructor's name is predetermined by the
  name of the class, it would seem that there can be only one
  constructor. But what if you want to create an object in more than one
  way? For example, suppose you build a class that can initialize itself
  in a standard way and also by reading information from a file. You
  need two constructors, one that takes no arguments (the default
  constructor) and one that takes a string as an argument, which is the
  name of the file to initialize the object. Both are constructors, so
  they must have the same name: the name of the class. Thus, function
  overloading is essential to allow the same function name - the
  constructor in this case - to be used with different argument types.
  -->
  <para>
    En C++ hay otro factor que fuerza la sobrecarga de los nombres de
    función: el constructor. Como el nombre del constructor está
    predeterminado por el nombre de la clase, podría parecer que sólo
    puede haber un constructor.  Pero, ¿qué ocurre si desea crear un
    objeto de diferentes maneras? Por ejemplo, suponga que escribe una
    clase que puede inicializarse de una manera estándar o leyendo
    información de un fichero. Necesita dos constructores, uno que no
    tiene argumentos (el constructor por defecto) y otro que tiene un
    argumento de tipo <emphasis>string</emphasis>, que es el nombre
    del fichero que inicializa el objeto. Ambos son constructores, así
    pues deben tener el mismo nombre: el nombre de la clase. Así, la
    sobrecarga de funciones es esencial para permitir el mismo nombre
    de función (el constructor en este caso) se utilice con diferentes
    argumentos.
  </para>

  <!--
  Although function overloading is a must for constructors, it's a
  general convenience and can be used with any function, not just class
  member functions. In addition, function overloading means that if you
  have two libraries that contain functions of the same name, they won't
  conflict as long as the argument lists are different. We'll look at
  all these factors in detail throughout this chapter.
  -->
  <para>
    Aunque la sobrecarga de funciones es algo imprescindible para los
    constructores, es también una utilidad general para cualquier
    función, incluso aquéllas que no son métodos. Además, la
    sobrecarga de funciones significa que si tiene dos librerías que
    contienen funciones con el mismo nombre, no entrarán en conflicto
    siempre y cuando las listas de argumentos sean diferentes. A lo
    largo del capítulo se verán todos los detalles.
  </para>

  <!-- The theme of this chapter is convenient use of function
  names. Function overloading allows you to use the same name for
  different functions, but there's a second way to make
  calling a function more convenient. What if you'd like to
  call the same function in different ways? When functions have long
  argument lists, it can become tedious to write (and confusing to
  read) the function calls when most of the arguments are the same for
  all the calls. A commonly used feature in C++ is called default
  arguments. A default argument is one the compiler inserts if it
  isn't specified in the function call. Thus, the calls
  f("hello), f("hi, 1), and
  f("howdy, 2, 'c') can all be calls
  to the same function. They could also be calls to three overloaded
  functions, but when the argument lists are this similar,
  you'll usually want similar behavior, which calls for a
  single function.  -->
  <para>
    El tema de este capítulo es la elección adecuada de los nombres de
    la funciones. La sobrecarga de funciones permite utilizar el mismo
    nombre para funciones diferentes, pero hay otra forma más adecuada
    de llamar a una función. ¿Qué ocurriría si le gustara llamar a la
    misma función de formas diferentes? Cuando las funciones tienen una
    larga lista de argumentos, puede resultar tediosa la escritura (y
    confusa la lectura) de las llamadas a la función cuando la mayoría
    de los argumentos son lo mismos para todas las llamadas. Una
    característica de C++ comúnmente utilizada se llama
    <emphasis>argumento por defecto</emphasis>. Un argumento por defecto
    es aquél que el compilador inserta en caso de que no se especifique
    cuando se llama a la función. Así, las llamadas
    <function>f("hello")</function>, <function>f("hi", 1)</function> y
    <function>f("howdy", 2, 'c')</function> pueden ser llamadas a la
    misma función. También podrían ser llamadas a tres funciones
    sobrecargadas, pero cuando las listas de argumentos son tan
    similares, querrá que tengan un comportamiento similar, que le lleva
    a tener una sola función.
  </para>

  <!--
  Function overloading and default arguments really aren't very
  complicated. By the time you reach the end of this chapter, you'll
  understand when to use them and the underlying mechanisms that
  implement them during compiling and linking.
  -->
  <para>
    La sobrecarga de funciones y los argumentos por defecto no son muy
    complicados. En el momento en que termine este capítulo, sabrá
    cuándo utilizarlos y entenderá los mecanismos internos que el
    compilador utiliza en tiempo de compilación y enlace.
  </para>

  <sect1>
    <!-- : More name decoration -->
    <title>Más decoración de nombres</title>

    <!--
    In Chapter 4, the concept of name decoration was introduced. In the
    code
    -->
    <para>
      En el Capítulo 4 se presentó el concepto de <emphasis>decoración de
      nombres</emphasis>. En el código
    </para>


<programlisting>
void f();
class X { void f(); };
</programlisting>



    <!--
    the function f( ) inside the scope of class X does not clash with the
    global version of f( ). The compiler performs this scoping by
    manufacturing different internal names for the global version of f( )
    and X::f( ). In Chapter 4, it was suggested that the names are simply
    the class name "decorated together with the function name, so the
    internal names the compiler uses might be _f and _X_f. However, it
    turns out that function name decoration involves more than the class
    name.
    -->
    <para>
      La función <function>f()</function> dentro del ámbito de la
      <classname>clase X</classname> no entra en conflicto con la
      versión global de <function>f()</function>. El compilador
      resuelve los ámbitos generando diferentes nombres internos tanto
      para la versión global de <function>f()</function> como para
      <methodname>X::f()</methodname>.  En el Capítulo 4 se sugirió
      que los nombres son simplemente el nombre de la clase junto con
      el nombre de la función. Un ejemplo podría ser que el compilador
      utilizara como nombres <emphasis>_f</emphasis> y
      <emphasis>_X_f</emphasis>. Sin embargo ahora se ve que la
      decoración del nombre de la función involucra algo más que el
      nombre de la clase.
    </para>

    <!-- Here's why. Suppose you want to overload two function names -->
    <para>
      He aquí el porqué. Suponga que quiere sobrecargar dos funciones
    </para>


<programlisting>
void print(char);
void print(float);
</programlisting>

    <!--
    It doesn't matter whether they are both inside a class or at the
    global scope. The compiler can't generate unique internal identifiers
    if it uses only the scope of the function names. You'd end up with
    _print in both cases. The idea of an overloaded function is that you
    use the same function name, but different argument lists. Thus, for
    overloading to work the compiler must decorate the function name with
    the names of the argument types. The functions above, defined at
    global scope, produce internal names that might look something like
    _print_char and _print_float. It's worth noting there is no standard
    for the way names must be decorated by the compiler, so you will see
    very different results from one compiler to another. (You can see what
    it looks like by telling the compiler to generate assembly-language
    output.) This, of course, causes problems if you want to buy compiled
    libraries for a particular compiler and linker - but even if name
    decoration were standardized, there would be other roadblocks because
    of the way different compilers generate code.
    -->
    <para>
      No importa si son globales o están dentro de una clase. El
      compilador no puede generar identificadores internos únicos si
      sólo utiliza el ámbito de las funciones. Terminaría con
      <emphasis>_print</emphasis> en ambos casos. La idea de una
      función sobrecargada es que se utilice el mismo nombre de
      función, pero diferente lista de argumentos. Así pues, para que
      la sobrecarga funcione el compilador ha de decorar el nombre de
      la función con los nombres de los tipos de los argumentos.  Las
      funciones planteadas más arriba, definidas como globales,
      producen nombres internos que podrían parecerse a algo así como
      <emphasis>_print_char</emphasis> y
      <emphasis>_print_float</emphasis>.  Nótese que como no hay
      ningún estándar de decoración, podrá ver resultados diferentes
      de un compilador a otro. (Puede ver lo que saldría diciéndole al
      compilador que genere código fuente en ensamblador.) Esto, por
      supuesto, causa problemas si desea comprar unas librerías
      compiladas por un compilador y enlazador particulares, aunque si
      la decoración de nombres fuera estándar, habría otros obstáculos
      debido a las diferencias de generación de código máquina entre
      compiladores.
    </para>

    <!--
    That's really all there is to function overloading: you can use the
    same function name for different functions as long as the argument
    lists are different. The compiler decorates the name, the scope, and
    the argument lists to produce internal names for it and the linker to
    use.
    -->
    <para>
      Esto es todo lo que hay para la sobrecarga de funciones: puede
      utilizar el mismo nombre de función siempre y cuando la lista de
      argumentos sea diferente. El compilador utiliza el nombre, el
      ámbito y la lista de argumentos para generar un nombre interno
      que el enlazador pueda utilizar.
    </para>

    <sect2>
      <!-- : Overloading on return values -->
      <title>Sobrecarga en el valor de retorno</title>

      <!--
      It's common to wonder, "Why just scopes and argument lists? Why not
      return values? It seems at first that it would make sense to also
      decorate the return value with the internal function name. Then you
      could overload on return values, as well:
      -->
      <para>
	Es muy común la pregunta "¿Por qué solamente el ámbito y la
	lista de argumentos? ¿Por qué no también el valor de
	retorno?". A primera vista parece que tendría sentido utilizar
	también el valor de retorno para la decoración del nombre
	interno. De esta manera, también podría sobrecargar con los
	valores de retorno:
      </para>


<programlisting>
void f();
int f();
</programlisting>

      <!--
      This works fine when the compiler can unequivocally determine the
      meaning from the context, as in int x = f( );. However, in C you've
      always been able to call a function and ignore the return value (that
      is, you can call the function for its side effects). How can the
      compiler distinguish which call is meant in this case? Possibly worse
      is the difficulty the reader has in knowing which function call is
      meant. Overloading solely on return value is a bit too subtle, and
      thus isn't allowed in C++.
      -->
      <para>
	Esto funciona bien cuando el compilador puede determinar sin
	ambigÃ¼edades a qué tipo de valor de retorno se refiere, como
	en <emphasis>int x = f();</emphasis>. No obstante, en C se
	puede llamar a una función y hacer caso omiso del valor de
	retorno (esto es, puede querer llamar a la función debido a
	sus <emphasis>efectos laterales</emphasis>). ¿Cómo puede el compilador
	distinguir a qué función se refiere en este caso? Peor es la
	dificultad que tiene el lector del código fuente para
	dilucidar a qué función se refiere. La sobrecarga mediante el
	valor de retorno solamente es demasiado sutil, por lo que C++
	no lo permite.
      </para>
    </sect2>

    <sect2>
      <!-- : Type-safe linkage -->
      <title>Enlace con tipos seguros</title>

      <!--
      There is an added benefit to all of this name decoration. A
      particularly sticky problem in C occurs when the client programmer
      misdeclares a function, or, worse, a function is called without
      declaring it first, and the compiler infers the function declaration
      from the way it is called. Sometimes this function declaration is
      correct, but when it isn't, it can be a difficult bug to find.
      -->
      <para>
	Existe un beneficio añadido a la decoración de nombres. En C
	hay un problema particularmente fastidioso cuando un
	programador cliente declara mal una función o, aún peor, se
	llama a una función sin haber sido previamente declarada, y el
	compilador infiere la declaración de la función mediante la
	forma en que se llama. Algunas veces la declaración de la
	función es correcta, pero cuando no lo es, suele resultar en
	un fallo difícil de encontrar.
      </para>

      <!--
      Because all functions must be declared before they are used in C++,
      the opportunity for this problem to pop up is greatly diminished. The
      C++ compiler refuses to declare a function automatically for you, so
      it's likely that you will include the appropriate header
      file. However, if for some reason you still manage to misdeclare a
      function, either by declaring by hand or including the wrong header
      file (perhaps one that is out of date), the name decoration provides a
      safety net that is often referred to as type-safe linkage.
      -->
      <para>
	A causa de que en C++ se <emphasis>deben</emphasis> declarar todas las
	funciones antes de llamarlas, las probabilidades de que ocurra
	lo anteriormente expuesto se reducen drásticamente. El
	compilador de C++ rechaza declarar una función
	automáticamente, así que es probable que tenga que incluir la
	cabecera apropiada. Sin embargo, si por alguna razón se las
	apaña para declarar mal una función, o declararla a mano o
	incluir una cabecera incorrecta (quizá una que sea antigua),
	la decoración de nombres proporciona una seguridad que a
	menudo se denomina como <emphasis>enlace con tipos seguros</emphasis>.
      </para>

      <!--
      Consider the following scenario. In one file is the definition for a
      function:
      -->
      <para>
	Considere el siguiente escenario. En un fichero está la
	definición de una función:
      </para>


//: V1C07:Def.cpp {O}

      <!-- In the second file, the function is misdeclared and then called: -->
      <para>
	En el segundo fichero, la función está mal declarada y en
	<function>main</function> se le llama:
      </para>


//: V1C07:Use.cpp


      <!--
      Even though you can see that the function is actually f(int), the
      compiler doesn't know this because it was told - through an explicit
      declaration - that the function is f(char). Thus, the compilation is
      successful. In C, the linker would also be successful, but not in
      C++. Because the compiler decorates the names, the definition becomes
      something like f_int, whereas the use of the function is f_char. When
      the linker tries to resolve the reference to f_char, it can only find
      f_int, and it gives you an error message. This is type-safe
      linkage. Although the problem doesn't occur all that often, when it
      does it can be incredibly difficult to find, especially in a large
      project. This is one of the cases where you can easily find a
      difficult error in a C program simply by running it through the C++
      compiler.
      -->
      <para>
	Incluso aunque pueda ver que la función es realmente
	<function>f(int)</function>, el compilador no lo sabe porque se
	le dijo, a través de una declaración explícita, que la función
	es <function>f(char)</function>. Así pues, la compilación tiene
	éxito. En C, el enlazador podría tener también éxito, pero
	<emphasis>no</emphasis> en C++. Como el compilador decora los
	nombres, la definición se convierte en algo así como
	<emphasis>f_int</emphasis>, mientras que se trata de utilizar
	<emphasis>f_char</emphasis>. Cuando el enlazador intenta
	resolver la referencia a <emphasis>f_char</emphasis>, sólo puede
	encontrar <emphasis>f_int</emphasis>, y da un mensaje de
	error. Ãste es el enlace de tipos seguro. Aunque el problema no
	ocurre muy a menudo, cuando ocurre puede ser increíblemente
	difícil de encontrar, especialmente en proyectos grandes. Ãste
	método puede utilizarse para encontrar un error en C simplemente
	intentando compilarlo en C++.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <!-- : Overloading example -->
    <title>Ejemplo de sobrecarga</title>

    <!--
    We can now modify earlier examples to use function overloading. As
    stated before, an immediately useful place for overloading is in
    constructors. You can see this in the following version of the Stash
    class:
    -->
    <para>
      Ahora puede modificar ejemplos anteriores para utilizar la sobrecarga
      de funciones. Como ya se dijo, el lugar inmediatamente más útil para
      la sobrecarga es en los constructores. Puede ver esto en la siguiente
      versión de la clase <classname>Stash</classname>:
    </para>


//: V1C07:Stash3.h

    <!--
    The first Stash( ) constructor is the same as before, but the second
    one has a Quantity argument to indicate the initial number of storage
    places to be allocated. In the definition, you can see that the
    internal value of quantity is set to zero, along with the storage
    pointer. In the second constructor, the call to inflate(initQuantity)
    increases quantity to the allocated size:
    -->
    <para>
      El primer constructor de <classname>Stash</classname> es el
      mismo que antes, pero el segundo tiene un argumento
      <varname>Quantity</varname> que indica el número inicial de
      espacios de memoria que podrán ser asignados. En la
      definición, puede observar que el valor interno de
      <varname>quantity</varname> se pone a cero, al igual que el
      puntero <varname>storage</varname>.  En el segundo
      constructor, la llamada a
      <function>inflate(initQuantity)</function> incrementa
      <varname>quantity</varname> al tamaño asignado:
    </para>


//: V1C07:Stash3.cpp {O}

    <!--
    When you use the first constructor no memory is allocated for
    storage. The allocation happens the first time you try to add( ) an
    object and any time the current block of memory is exceeded inside
    add( ).
    -->
    <para>
      Cuando utiliza el primer constructor no se asigna memoria alguna para
      <varname>storage</varname>. La asignación ocurre la primera vez que
      trate de añadir (con <function>add()</function>) un objeto y en
      cualquier momento en el que el bloque de memoria actual se exceda
      en <function>add()</function>.
    </para>

    <!-- Both constructors are exercised in the test program: -->
    <para>
      Ambos constructores se prueban en este programa de prueba:
    </para>


//: V1C07:Stash3Test.cpp


    <!--
    The constructor call for stringStash uses a second argument;
    presumably you know something special about the specific problem
    you're solving that allows you to choose an initial size for the
    Stash.
    -->
      <para>
      La llamada al constructor para la variable
      <varname>stringStash</varname> utiliza un segundo argumento;
      se presume que conoce algo especial sobre el problema
      específico que usted está resolviendo que le permite elegir un
      tamaño inicial para el <emphasis>Stash</emphasis>.
    </para>
  </sect1>

  <sect1>
    <!-- :unions -->
    <title>Uniones</title>

    <!--
    As you've seen, the only difference between struct and class in C++ is
    that struct defaults to public and class defaults to private. A struct
    can also have constructors and destructors, as you might expect. But
    it turns out that a union can also have a constructor, destructor,
    member functions, and even access control. You can again see the use
    and benefit of overloading in the following example:
    -->
    <para>
      Como ya ha visto, la única diferencia en C++ entre
      <emphasis>struct</emphasis> y <emphasis>class</emphasis> es que
      <emphasis>struct</emphasis> pone todo por defecto a
      <emphasis>public</emphasis> y la clase pone todo por defecto a
      <emphasis>private</emphasis>. Una <emphasis>struct</emphasis>ura
      también puede tener constructores y destructores, como cabía esperar.
      Pero resulta que el tipo <emphasis>union</emphasis> también puede
      tener constructores, destructores, métodos e incluso controles de
      acceso. Puede ver de nuevo la utilización y las ventajas de la
      sobrecarga de funciones en el siguiente ejemplo:
    </para>


//: V1C07:UnionClass.cpp

    <!--
    You might think from the code above that the only difference between a
    union and a class is the way the data is stored (that is, the int and
    float are overlaid on the same piece of storage). However, a union
    cannot be used as a base class during inheritance, which is quite
    limiting from an object-oriented design standpoint (you'll learn about
    inheritance in Chapter 14).
    -->
    <para>
      Podría pensar sobre el código de más arriba que la única diferencia
      entre una unión y una clase es la forma en que los datos se almacenan
      en memoria (es decir, el <emphasis>int</emphasis> y el
      <emphasis>float</emphasis> están superpuestos). Sin embargo una unión
      no se puede utilizar como clase base durante la herencia, lo cual
      limita bastante desde el punto de vista del diseño orientado a
      objetos (aprenderá sobre la herencia en el Capítulo 14).
    </para>

    <!--
    Although the member functions civilize access to the union somewhat,
    there is still no way to prevent the client programmer from selecting
    the wrong element type once the union is initialized. In the example
    above, you could say X.read_float( ) even though it is
    inappropriate. However, a "safe union can be encapsulated in a
    class. In the following example, notice how the enum clarifies the
    code, and how overloading comes in handy with the constructors:
    -->
    <para>
      Aunque los métodos civilizan ligeramente el tratamiento de uniones,
      sigue sin haber manera alguna de prevenir que el programador cliente
      seleccione el tipo de elemento equivocado una vez que la unión se ha
      inicializado. En el ejemplo de más arriba, podría decir
      <methodname>X.read_float()</methodname> incluso aunque es inapropiado.
      Sin embargo, una unión "segura" se puede encapsular en una clase. En
      el siguiente ejemplo, vea cómo la enumeración clarifica el código, y
      cómo la sobrecarga viene como anillo al dedo con los constructores:
    </para>


//: V1C07:SuperVar.cpp

    <!--
    In the code above, the enum has no type name (it is an untagged
    enumeration). This is acceptable if you are going to immediately
    define instances of the enum, as is done here. There is no need to
    refer to the enum's type name in the future, so the type name is
    optional.
    -->
    <para>
      En el ejemplo de más arriba la enumeración no tiene nombre de tipo
      (es una enumeración sin etiqueta). Esto es aceptable si va a
      definir inmediatamente un ejemplar de la enumeración, tal como se
      hace aquí.  No hay necesidad de referir el nombre del tipo de la
      enumeración en el futuro, por lo que aquí el nombre de tipo es
      optativo.
    </para>

    <!--
    The union has no type name and no variable name. This is called an
    anonymous union, and creates space for the union but doesn't require
    accessing the union elements with a variable name and the dot
    operator. For instance, if your anonymous union is:
    -->
    <para>
      La unión no tiene nombre de tipo ni nombre de variable. Esto se
      denomina <emphasis>unión anónima</emphasis>, y crea espacio para
      la unión pero no requiere acceder a los elementos de la unión con
      el nombre de la variable y el operador punto. Por ejemplo, si su
      unión anónima es:
    </para>


//: V1C07:AnonymousUnion.cpp

    <!--
    Note that you access members of an anonymous union just as if they
    were ordinary variables. The only difference is that both variables
    occupy the same space. If the anonymous union is at file scope
    (outside all functions and classes) then it must be declared static so
    it has internal linkage.
    -->
      <para>
      Note que accede a los miembros de una unión anónima igual que si
      fueran variables normales. La única diferencia es que ambas
      variables ocupan el mismo espacio de memoria. Si la unión anónima
      está en el ámbito del fichero (fuera de todas las funciones y
      clases), entonces se ha de declarar estática para que tenga enlace
      interno.
    </para>

    <!--
    Although SuperVar is now safe, its usefulness is a bit dubious because
    the reason for using a union in the first place is to save space, and
    the addition of vartype takes up quite a bit of space relative to the
    data in the union, so the savings are effectively eliminated. There
    are a couple of alternatives to make this scheme workable. If the
    vartype controlled more than one union instance - if they were all the
    same type - then you'd only need one for the group and it wouldn't
    take up more space. A more useful approach is to have #ifdefs around
    all the vartype code, which can then guarantee things are being used
    correctly during development and testing. For shipping code, the extra
    space and time overhead can be eliminated.
    -->
    <para>
      Aunque <varname>SuperVar</varname> es ahora segura, su utilidad es
      un poco dudosa porque la razón de utilizar una unión principalmente
      es la de ahorrar memoria y la adición de <emphasis>vartype</emphasis>
      hace que ocupe bastante espacio en la unión (relativamente),
      por lo que la ventaja del ahorro se elimina. Hay un par de
      alternativas para que este esquema funcione. Si
      <emphasis>vartype</emphasis> controlara más de una unión (en el caso
      de que fueran del mismo tipo) entonces sólo necesitaría uno para el
      grupo y no ocuparía más memoria. Una aproximación más útil es tener
      <emphasis>#ifdef</emphasis>s alrededor del código de
      <emphasis>vartype</emphasis>, el cual puede entonces garantizar que
      las cosas se utilizan correctamente durante el desarrollo y las
      pruebas. Si el código ha de entregarse, antes puede
      eliminar las sobrecargas de tiempo y memoria.
    </para>
  </sect1>

  <sect1>
    <!-- : Default arguments -->
    <title>Argumentos por defecto</title>

    <!--
    In Stash3.h, examine the two constructors for Stash( ). They don't
    seem all that different, do they? In fact, the first constructor seems
    to be a special case of the second one with the initial size set to
    zero. It's a bit of a waste of effort to create and maintain two
    different versions of a similar function.
    -->
    <para>
      En <filename>Stash3.h</filename>, examine los dos constructores
      para <emphasis>Stash()</emphasis>. No parecen muy diferentes,
      ¿verdad?. De hecho el primer constructor parece ser un caso especial
      del segundo pero con <varname>size</varname> inicializado a cero. Es
      un poco una pérdida de tiempo y esfuerzo crear y mantener dos
      versiones diferentes de una función similar.
    </para>

    <!--
    C++ provides a remedy with default arguments. A default argument is a
    value given in the declaration that the compiler automatically inserts
    if you don't provide a value in the function call. In the Stash
    example, we can replace the two functions:
    -->
    <para>
      C++ proporciona un remedio mediante los <emphasis>argumentos por
      defecto</emphasis>. Un argumento por defecto es una valor que se
      da en la declaración para que el compilador lo inserte
      automáticamente en el caso de que no se proporcione ninguno en la
      llamada a la función. En el ejemplo de <emphasis>Stash</emphasis>,
      puede reemplazar las dos funciones:
    </para>


<programlisting>
Stash(int size); // Zero quantity
Stash(int size, int initQuantity);
</programlisting>


    <!-- with the single function: -->
    <para>
      por ésta otra:
    </para>


<programlisting>
Stash(int size, int initQuantity = 0);
</programlisting>


    <!--
    The Stash(int) definition is simply removed - all that is necessary is
    the single Stash(int, int) definition.
    -->
    <para>
      La definición de <function>Stash(int)</function> simplemente se
      quita; todo lo necesario está ahora en la definición de
      <function>Stash(int, int)</function>.
    </para>

    <!-- Now, the two object definitions -->
    <para>
      Ahora, las definiciones de los dos objetos
    </para>


<programlisting>
 Stash A(100), B(100, 0);
</programlisting>



    <!--
    will produce exactly the same results. The identical constructor is
    called in both cases, but for A, the second argument is automatically
    substituted by the compiler when it sees the first argument is an int
    and that there is no second argument. The compiler has seen the
    default argument, so it knows it can still make the function call if
    it substitutes this second argument, which is what you've told it to
    do by making it a default.
    -->
    <para>
      producirán exactamente los mismos resultados. En ambos casos se
      llama al mismo constructor, aunque el compilador substituye el
      segundo argumento de <varname>A</varname> automáticamente cuando
      ve que que el primer argumento es un entero y no hay un segundo
      argumento.  El compilador ha detectado un argumento por defecto,
      así que sabe que todavía puede llamar a la función si substituye
      este segundo argumento, lo cual es lo que usted le ha dicho que
      haga al no poner ese argumento.
    </para>

    <!--
    Default arguments are a convenience, as function overloading is a
    convenience. Both features allow you to use a single function name in
    different situations. The difference is that with default arguments
    the compiler is substituting arguments when you don't want to put them
    in yourself. The preceding example is a good place to use default
    arguments instead of function overloading; otherwise you end up with
    two or more functions that have similar signatures and similar
    behaviors. If the functions have very different behaviors, it doesn't
    usually make sense to use default arguments (for that matter, you
    might want to question whether two functions with very different
    behaviors should have the same name).
    -->
    <para>
      Los argumentos por defecto, al igual que la sobrecarga de funciones,
      son muy convenientes. Ambas características le permiten utilizar un
      único nombre para una función en situaciones diferentes. La
      diferencia está en que el compilador substituye los argumentos por
      defecto cuando usted no los pone. El ejemplo anterior en un buen
      ejemplo para utilizar argumentos por defecto en vez de la sobrecarga
      de funciones; de otra manera se encuentra con dos o más funciones
      que tienen firmas y comportamientos similares. Si las funciones
      tiene comportamientos muy diferentes, normalmente no tiene sentido
      utilizar argumentos por defecto (de hecho, podría querer preguntarse
      si dos funciones con comportamientos muy diferentes deberían
      llamarse igual).
    </para>

    <!--
    There are two rules you must be aware of when using default
    arguments. First, only trailing arguments may be defaulted. That is,
    you can't have a default argument followed by a non-default
    argument. Second, once you start using default arguments in a
    particular function call, all the subsequent arguments in that
    function's argument list must be defaulted (this follows from the
    first rule).
    -->
    <para>
      Hay dos reglas que se deben tener en cuenta cuando se utilizan
      argumentos por defecto. La primera es que sólo los últimos pueden
      ser por defecto, es decir, no puede poner un argumento por defecto
      seguido de otro que no lo es. La segunda es que una vez se empieza
      a utilizar los argumentos por defecto al realizar una llamada a
      una función, el resto de argumentos también serán por defecto (esto
      sigue a la primera regla).
    </para>

    <!--
    Default arguments are only placed in the declaration of a function
    (typically placed in a header file). The compiler must see the default
    value before it can use it. Sometimes people will place the commented
    values of the default arguments in the function definition, for
    documentation purposes
    -->
    <para>
      Los argumentos por defecto sólo se colocan en la declaración de la
      función (normalmente en el fichero de cabecera). El compilador
      debe conocer el valor por defecto antes de utilizarlo. Hay gente
      que pone los valores por defecto comentados en la definición por
      motivos de documentación.
    </para>


<programlisting>
void fn(int x /* = 0 */) { // ...
</programlisting>


    <sect2>
      <!-- : Placeholder arguments -->
      <title>Argumentos de relleno</title>

      <!--
      Arguments in a function declaration can be declared without
      identifiers. When these are used with default arguments, it can look a
      bit funny. You can end up with
      -->
      <para>
	Los argumentos de una función pueden declararse sin
	identificadores. Cuando esto se hace con argumentos por
	defecto, pueden parecer graciosos. Puede encontrarse con
      </para>


<programlisting>
void f(int x, int = 0, float = 1.1);
</programlisting>

      <!-- In C++ you don't need identifiers in the function definition, either: -->
      <para>
	En C++, la definición de la función tampoco necesita
	identificadores:
      </para>


<programlisting>
void f(int x, int, float flt) { /* ... */ }
</programlisting>

      <!--
      In the function body, x and flt can be referenced, but not the middle
      argument, because it has no name. Function calls must still provide a
      value for the placeholder, though: f(1) or f(1,2,3.0). This syntax
      allows you to put the argument in as a placeholder without using
      it. The idea is that you might want to change the function definition
      to use the placeholder later, without changing all the code where the
      function is called. Of course, you can accomplish the same thing by
      using a named argument, but if you define the argument for the
      function body without using it, most compilers will give you a warning
      message, assuming you've made a logical error. By intentionally
      leaving the argument name out, you suppress this warning.
      -->
      <para>
	En el cuerpo de la función, se puede hacer referencia a
	<parameter>x</parameter> y a <parameter>flt</parameter>,
	pero no al argumento de en medio puesto que no tiene
	nombre. A pesar de esto, las llamadas a función deben
	proporcionar un valor para este argumento de relleno :
	<function>f(1)</function> ó
	<function>f(1,2,3,0)</function>. Esta sintaxis le permite
	poner el argumento como un argumento de relleno sin
	utilizarlo. La idea es que podría querer cambiar la
	definición de la función para utilizar el argumento de
	relleno más tarde, sin cambiar todo el código en que ya se
	invoca la función. Por supuesto, puede obtener el mismo
	resultado utilizando un argumento con nombre, pero en ese
	caso está definiendo el argumento para el cuerpo de la
	función sin que éste lo utilice, y la mayoría de los
	compiladores darán un mensaje de aviso, suponiendo que usted
	ha cometido un error. Si deja el argumento sin nombre
	intencionadamente, evitará el aviso.
      </para>

      <!--
      More important, if you start out using a function argument and later
      decide that you don't need it, you can effectively remove it without
      generating warnings, and yet not disturb any client code that was
      calling the previous version of the function.
      -->
      <para>
	Más importante, si empieza utilizando un argumento que más
	tarde decide dejar de utilizar, puede quitarlo sin generar
	avisos ni fastidiar al código cliente que esté utilizando la
	versión anterior de la función.
      </para>

    </sect2>
  </sect1>

  <sect1>
    <!-- : Choosing overloading vs. default arguments -->
    <title>Elección entre sobrecarga y argumentos por defecto</title>

    <!--
    Both function overloading and default arguments provide a convenience
    for calling function names. However, it can seem confusing at times to
    know which technique to use. For example, consider the following tool
    that is designed to automatically manage blocks of memory for you:
    -->
    <para>
      Tanto la sobrecarga de funciones como los argumentos por defecto
      resultan útiles para ponerle nombre a las funciones. Sin embargo, a
      veces puede resultar confuso saber qué técnica utilizar. Por ejemplo,
      estudie la siguiente herramienta que está diseñada para tratar
      automáticamente bloques de memoria:
    </para>


//: V1C07:Mem.h

    <!--
    A Mem object holds a block of bytes and makes sure that you have
    enough storage. The default constructor doesn't allocate any storage,
    and the second constructor ensures that there is sz storage in the Mem
    object. The destructor releases the storage, msize( ) tells you how
    many bytes there are currently in the Mem object, and pointer( )
    produces a pointer to the starting address of the storage (Mem is a
    fairly low-level tool). There's an overloaded version of pointer( ) in
    which client programmers can say that they want a pointer to a block
    of bytes that is at least minSize large, and the member function
    ensures this.
    -->
    <para>
      El objeto <classname>Mem</classname> contiene un bloque de
      octetos y se asegura de que tiene suficiente memoria. El
      constructor por defecto no reserva memoria pero el segundo
      constructor se asegura de que hay <parameter>sz</parameter>
      octetos de memoria en el objeto <classname>Mem</classname>. El
      destructor libera la memoria, <methodname>msize()</methodname>
      le dice cuántos octetos hay actualmente en
      <classname>Mem</classname> y
      <methodname>pointer()</methodname> retorna un puntero al
      principio de la memoria reservada (<classname>Mem</classname>
      es una herramienta a bastante bajo nivel).  Hay una versión
      sobrecargada de <methodname>pointer()</methodname> que los
      programadores clientes pueden utilizar para obtener un puntero
      que apunta a un bloque de memoria con al menos el tamaño
      <varname>minSize</varname>, y el método lo asegura.
    </para>

    <!--
    Both the constructor and the pointer( ) member function use the
    private ensureMinSize( ) member function to increase the size of the
    memory block (notice that it's not safe to hold the result of pointer(
    ) if the memory is resized).
    -->
    <para>
      El constructor y el método <methodname>pointer()</methodname>
      utilizan el método privado
      <methodname>ensureMinSize()</methodname> para incrementar el
      tamaño del bloque de memoria (note que no es seguro mantener
      el valor de retorno de <methodname>pointer()</methodname> si
      se cambia el tamaño del bloque de memoria).
    </para>

    <!-- Here's the implementation of the class: -->
    <para>
      He aquí la implementación de la clase:
    </para>


//: V1C07:Mem.cpp {O}

    <!--
    You can see that ensureMinSize( ) is the only function responsible for
    allocating memory, and that it is used from the second constructor and
    the second overloaded form of pointer( ). Inside ensureMinSize( ),
    nothing needs to be done if the size is large enough. If new storage
    must be allocated in order to make the block bigger (which is also the
    case when the block is of size zero after default construction), the
    new "extra portion is set to zero using the Standard C library
    function memset( ), which was introduced in Chapter 5. The subsequent
    function call is to the Standard C library function memcpy( ), which
    in this case copies the existing bytes from mem to newmem (typically
    in an efficient fashion). Finally, the old memory is deleted and the
    new memory and sizes are assigned to the appropriate members.
    -->
      <para>
      Puede observar que <methodname>ensureMinSize()</methodname> es
      la única función responsable de reservar memoria y que la
      utilizan tanto el segundo constructor como la segunda versión
      sobrecargada de <methodname>pointer()</methodname>. Dentro de
      <methodname>ensureSize()</methodname> no se hace nada si el
      tamaño es lo suficientemente grande. Si se ha de reservar más
      memoria para que el bloque sea más grande (que es el mismo
      caso cuando el bloque tiene tamaño cero después del
      constructor por defecto), la nueva porción de más se pone a
      cero utilizando la función de la librería estándar de C
      <function>memset()</function>, que fue presentada en el
      Capítulo 5. La siguiente llamada es a la función de la
      librería estándar de C <function>memcpy()</function>, que en
      este caso copia los octetos existentes de
      <varname>mem</varname> a <varname>newmem</varname>
      (normalmente de una manera eficaz).  Finalmente, se libera la
      memoria antigua y se asignan a los atributos apropiados la
      nueva memoria y su tamaño.
    </para>

   <!--
    The Mem class is designed to be used as a tool within other classes to
    simplify their memory management (it could also be used to hide a more
    sophisticated memory-management system provided, for example, by the
    operating system). Appropriately, it is tested here by creating a
    simple "string class:
    -->
    <para>
      La clase <classname>Mem</classname> se ha diseñado para su
      utilización como herramienta dentro de otras clases para
      simplificar su gestión de la memoria (también se podría
      utilizar para ocultar un sistema de gestión de memoria más
      avanzada proporcionado, por ejemplo, por el el sistema
      operativo). Esta clase se comprueba aquí con una simple
      clase de tipo "string":
    </para>


//: V1C07:MemTest.cpp


    <!--
    All you can do with this class is to create a MyString, concatenate
    text, and print to an ostream. The class only contains a pointer to a
    Mem, but note the distinction between the default constructor, which
    sets the pointer to zero, and the second constructor, which creates a
    Mem and copies data into it. The advantage of the default constructor
    is that you can create, for example, a large array of empty MyString
    objects very cheaply, since the size of each object is only one
    pointer and the only overhead of the default constructor is that of
    assigning to zero. The cost of a MyString only begins to accrue when
    you concatenate data; at that point the Mem object is created if it
    hasn't been already. However, if you use the default constructor and
    never concatenate any data, the destructor call is still safe because
    calling delete for zero is defined such that it does not try to
    release storage or otherwise cause problems.
    -->
    <para>
      Todo lo que puede hacer con esta clase es crear un
      <classname>MyString</classname>, concatenar texto e imprimir a
      un <emphasis>ostream</emphasis>. La clase sólo contiene un
      puntero a un <classname>Mem</classname>, pero note la
      diferencia entre el constructor por defecto, que pone el
      puntero a cero, y el segundo constructor, que crea un
      <classname>Mem</classname> y copia los datos dentro del
      mismo. La ventaja del constructor por defecto es que puede
      crear, por ejemplo, un array grande de objetos
      <classname>MyString</classname> vacíos con pocos recursos,
      pues el tamaño de cada objeto es sólo un puntero y la única
      sobrecarga en el rendimiento del constructor por defecto es el
      de asignarlo a cero.  El coste de un
      <classname>MyString</classname> sólo empieza a aumentar cuando
      concatena datos; en ese momento el objeto
      <classname>Mem</classname> se crea si no ha sido creado todavía.
      Sin embargo, si utiliza el constructor por defecto y nunca
      concatena ningún dato, la llamada al destructor todavía es
      segura porque cuando se llama a <function>delete</function>
      con un puntero a cero, el compilador no hace nada para no
      causar problemas.
    </para>

    <!--
    If you look at these two constructors it might at first seem like this
    is a prime candidate for default arguments. However, if you drop the
    default constructor and write the remaining constructor with a default
    argument:
    -->
    <para>
      Si mira los dos constructores, en principio, podría parecer que
      son candidatos para utilizar argumentos por defecto. Sin embargo,
      si elimina el constructor por defecto y escribe el constructor que
      queda con un argumento por defecto:
    </para>


<programlisting>
MyString(char* str = "");
</programlisting>


    <!--
    everything will work correctly, but you'll lose the previous
    efficiency benefit since a Mem object will always be created. To get
    the efficiency back, you must modify the constructor:
    -->
    <para>
      todo funcionará correctamente, pero perderá la eficacia anterior
      pues siempre se creará el objeto <classname>Mem</classname>. Para
      volver a tener la misma eficacia de antes, ha de modificar el
      constructor:
    </para>


<programlisting>
MyString::MyString(char* str) {
  if(!*str) { // Apunta a un string vacío
    buf = 0;
    return;
  }
  buf = new Mem(strlen(str) + 1);
  strcpy((char*)buf-&gt;pointer(), str);
}
</programlisting>


    <!--
    This means, in effect, that the default value becomes a flag that
    causes a separate piece of code to be executed than if a non-default
    value is used. Although it seems innocent enough with a small
    constructor like this one, in general this practice can cause
    problems. If you have to look for the default rather than treating it
    as an ordinary value, that should be a clue that you will end up with
    effectively two different functions inside a single function body: one
    version for the normal case and one for the default. You might as well
    split it up into two distinct function bodies and let the compiler do
    the selection. This results in a slight (but usually invisible)
    increase in efficiency, because the extra argument isn't passed and
    the extra code for the conditional isn't executed. More importantly,
    you are keeping the code for two separate functions in two separate
    functions rather than combining them into one using default arguments,
    which will result in easier maintainability, especially if the
    functions are large.
    -->
    <para>
      Esto significa, en efecto, que el valor por defecto es un caso que
      ha de tratarse separadamente de un valor que no lo es. Aunque
      parece algo inocente con un pequeño constructor como éste, en
      general esta práctica puede causar problemas. Si tiene que hacer
      por separado el valor por defecto en vez de tratarlo como un valor
      ordinario, debería ser una pista para que al final se implementen
      dos funciones diferentes dentro de una función: una versión para
      el caso normal y otra para el caso por defecto. Podría partirlo en
      dos cuerpos de función diferentes y dejar que el compilador
      elija. Esto resulta en un ligero (pero normalmente invisible)
      incremento de la eficacia porque el argumento extra no se pasa y
      por tanto el código extra debido a la condición condición no se
      ejecuta. Más importante es que está manteniendo el código
      <emphasis>en</emphasis> dos funciones separadas en vez de
      combinarlas en una utilizando argumentos por defecto, lo que
      resultará en un mantenimiento más sencillo, sobre todo si las
      funciones son largas.
    </para>

    <!--
    On the other hand, consider the Mem class. If you look at the
    definitions of the two constructors and the two pointer( ) functions,
    you can see that using default arguments in both cases will not cause
    the member function definitions to change at all. Thus, the class
    could easily be:
    -->
    <para>
      Por otro lado, considere la clase
      <classname>Mem</classname>. Si mira las definiciones de los
      dos constructores y las dos funciones
      <methodname>pointer()</methodname>, puede ver que la utilización
      de argumentos por defecto en ambos casos no causará que los
      métodos cambien. Así, la clase podría ser fácilmente:
    </para>


//: V1C07:Mem2.h

    <!-- Notice that a call to ensureMinSize(0) will always be quite efficient. -->
    <para>
      Note que la llamada a <function>ensureMinSize(0)</function>
      siempre será bastante eficaz.
    </para>

    <!--
    Although in both of these cases I based some of the decision-making
    process on the issue of efficiency, you must be careful not to fall
    into the trap of thinking only about efficiency (fascinating as it
    is). The most important issue in class design is the interface of the
    class (its public members, which are available to the client
    programmer). If these produce a class that is easy to use and reuse,
    then you have a success; you can always tune for efficiency if
    necessary but the effect of a class that is designed badly because the
    programmer is over-focused on efficiency issues can be dire. Your
    primary concern should be that the interface makes sense to those who
    use it and who read the resulting code. Notice that in MemTest.cpp the
    usage of MyString does not change regardless of whether a default
    constructor is used or whether the efficiency is high or low.
    -->
    <para>
      Aunque ambos casos se basan en decisiones por motivos de
      eficacia, debe tener cuidado para no caer en la trampa de
      pensar sólo en la eficacia (siempre fascinante). Lo más
      importante en el diseño de una clase es la interfaz de la
      clase (sus miembros públicos, que son las que el programador
      cliente tiene a su disposición). Si se implementa una clase
      fácil de utilizar y reutilizar, entonces ha tenido éxito;
      siempre puede realizar ajustes para mejorar la eficacia en
      caso necesario, pero el efecto de una clase mal diseñada
      porque el programador está obsesionado con la eficacia puede
      resultar grave. Su primera preocupación debería ser que la
      interfaz tuviera sentido para aquéllos que la utilicen y para
      los que lean el código. Note que en
      <filename>MemTest.cpp</filename> el uso de
      <classname>MyString</classname> no cambia independientemente
      de si se utiliza el constructor por defecto o si la eficacia
      es buena o mala.
    </para>
  </sect1>

  <sect1>
 <!-- : Summary -->
    <title>Resumen</title>

    <!--
    As a guideline, you shouldn't use a default argument as a flag upon
    which to conditionally execute code. You should instead break the
    function into two or more overloaded functions if you can. A default
    argument should be a value you would ordinarily put in that
    position. It's a value that is more likely to occur than all the rest,
    so client programmers can generally ignore it or use it only if they
    want to change it from the default value.
    -->
    <para>
      Como norma, no debería utilizar argumentos por defecto si hay que
      incluir una condición en el código. En vez de eso debería partir la
      función en dos o más funciones sobrecargadas si puede. Un argumento
      por defecto debería ser un valor que normalmente pondría ahí. Es el
      valor que es más probable que ocurra, para que lo programadores
      clientes puedan hacer caso omiso de él o sólo lo pongan cuando no
      quieran utilizar el valor por defecto.
    </para>

    <!--
    The default argument is included to make function calls easier,
    especially when those functions have many arguments with typical
    values. Not only is it much easier to write the calls, it's easier to
    read them, especially if the class creator can order the arguments so
    the least-modified defaults appear latest in the list.
    -->
    <para>
      El argumento por defecto se incluye para hacer más fáciles las
      llamadas a función, especialmente cuando esas funciones tiene muchos
      argumentos con valores típicos. No sólo es mucho más sencillo
      escribir las llamadas, sino que además son más sencillas de leer,
      especialmente si el creador de la clase ordena los argumentos de tal
      manera que aquéllos que menos cambian se ponen al final del todo.
    </para>

    <!--
    An especially important use of default arguments is when you start out
    with a function with a set of arguments, and after it's been used for
    a while you discover you need to add arguments. By defaulting all the
    new arguments, you ensure that all client code using the previous
    interface is not disturbed.
    -->
    <para>
      Una utilización especialmente importante de los argumentos por
      defecto es cuando empieza con una función con un conjunto de
      argumentos, y después de utilizarla por un tiempo se da cuenta de
      que necesita añadir más argumentos. Si pone los nuevos argumentos
      como por defecto, se asegura de que no se rompe el código cliente
      que utiliza la interfaz anterior.
    </para>
  </sect1>

  <sect1>
    <!-- : Exercises -->
    <title>Ejercicios</title>

    <xi:include parse="xml" href="./ejercicios.xml"/>

    <orderedlist>
      <listitem>
    <!--
    1. Create a Text class that contains a string object to hold the
    text of a file. Give it two constructors: a default constructor and
    a constructor that takes a string argument that is the name of the
    file to open. When the second constructor is used, open the file
    and read the contents into the string member object. Add a member
    function contents( ) to return the string so (for example) it can
    be printed. In main( ), open a file using Text and print the
    contents.
    -->
	<para>
	  Cree una clase <emphasis>Text</emphasis> que
	  contenga un objeto <emphasis>string</emphasis> para que
	  guarde el texto de un fichero. Póngale dos constructores: un
	  constructor por defecto y un constructor que tome un
	  argumento de tipo <emphasis>string</emphasis> que sea el
	  nombre del fichero que se vaya a abrir. Cuando se utilice el
	  segundo constructor, abra el fichero y ponga su contenido en
	  el atributo <emphasis>string</emphasis>. Añada un método
	  llamado <emphasis>contents()</emphasis> que retorne el
	  <emphasis>string</emphasis> para que, por ejemplo, se pueda
	  imprimir. En <emphasis>main()</emphasis> abra un fichero
	  utilizando <emphasis>Text</emphasis> e imprima el contenido
	  a la pantalla.
	</para>
      </listitem>
      <listitem>
    <!--
    2. Create a Message class with a constructor that takes a single
    string with a default value. Create a private member string, and in
    the constructor simply assign the argument string to your internal
    string. Create two overloaded member functions called print( ): one
    that takes no arguments and simply prints the message stored in the
    object, and one that takes a string argument, which it prints in
    addition to the internal message. Does it make sense to use this
    approach instead of the one used for the constructor?
    -->
	<para>
	  Cree una clase <emphasis>Message</emphasis> con un
	  constructor que tome un sólo <emphasis>string</emphasis> con
	  un valor por defecto. Cree un atributo privado
	  <emphasis>string</emphasis> y asigne en el constructor el
	  argumento <emphasis>string</emphasis> al atributo
	  <emphasis>string</emphasis>.  Cree dos métodos sobrecargados
	  llamados <emphasis>print()</emphasis>: uno que no tome
	  argumentos y que imprima simplemente el mensaje guardado en
	  el objeto, y el otro que tome un argumento
	  <emphasis>string</emphasis>, que imprima el mensaje interno
	  además del argumento. ¿Tiene sentido utilizar esta
	  aproximación en vez del utilizado por el constructor?
	</para>
      </listitem>
      <listitem>
    <!--
    3. Determine how to generate assembly output with your compiler,
    and run experiments to deduce the name-decoration scheme.
    -->
	<para>
	  Descubra cómo generar código ensamblador con su compilador
	  y haga experimentos para deducir el esquema de decoración de
	  nombres.
	</para>
      </listitem>

      <listitem>
    <!--
    4. Create a class that contains four member functions, with 0, 1,
    2, and 3 int arguments, respectively. Create a main( ) that makes
    an object of your class and calls each of the member functions. Now
    modify the class so it has instead a single member function with
    all the arguments defaulted. Does this change your main( )?
    -->
	<para>
	  Cree una clase que contenga cuatro métodos con 0,
	  1, 2 y 3 argumentos de tipo <emphasis>int</emphasis>
	  respectivamente. Cree un <emphasis>main()</emphasis> que
	  haga un objeto de su clase y llame a cada método. Ahora
	  modifique la clase para que tenga sólo un método con todos
	  los argumentos por defecto. ¿Esto cambia su
	  <emphasis>main()</emphasis>?
	</para>
      </listitem>

      <listitem>
    <!--
    5. Create a function with two arguments and call it from main(
    ). Now make one of the arguments a "placeholder (no identifier)
    and see if your call in main( ) changes.
    -->
	<para>
	  Cree una función con dos argumentos y llámelo desde
	  <emphasis>main()</emphasis>. Ahora haga que uno de los argumentos
	  sea un argumento de relleno (sin identificador) y mire si el
	  <emphasis>main()</emphasis> necesita cambios.
	</para>
      </listitem>

      <listitem>
    <!--
    6. Modify Stash3.h and Stash3.cpp to use default arguments in the
    constructor. Test the constructor by making two different versions
    of a Stash object.
    -->
	<para>
	  Modifique <filename>Stash3.h</filename> y
	  <filename>Stash3.cpp</filename> para que el constructor
	  utilice argumentos por defecto. Pruebe el constructor
	  haciendo dos versiones diferentes de un objeto
	  <emphasis>Stash</emphasis>.
	</para>
      </listitem>

      <listitem>
    <!--
    7. Create a new version of the Stack class (from Chapter 6) that
    contains the default constructor as before, and a second
    constructor that takes as its arguments an array of pointers to
    objects and the size of that array. This constructor should move
    through the array and push each pointer onto the Stack. Test your
    class with an array of string.
    -->
	<para>
	  Cree una nueva versión de la clase <emphasis>Stack</emphasis>
	  (del Capítulo 6) que contenga el constructor por defecto al
	  igual que antes, y un segundo constructor que tome como
	  argumentos un array de punteros a objetos y el tamaño del
	  array. Este constructor debería recorrer el array y poner cada
	  puntero en la pila (<emphasis>Stack</emphasis>). Pruebe su
	  clase con un array de <emphasis>string</emphasis>'s.
	</para>
      </listitem>

      <listitem>
    <!--
    8. Modify SuperVar so that there are #ifdefs around all the vartype
    code as described in the section on enum. Make vartype a regular
    and public enumeration (with no instance) and modify print( ) so
    that it requires a vartype argument to tell it what to do.
    -->
	<para>
	  Modifique <emphasis>SuperVar</emphasis> para que haya
	  <emphasis>#ifdef</emphasis>'s que engloben el código de
	  <emphasis>vartype</emphasis> tal como se describe en la
	  sección sobre enumeraciones. Haga <emphasis>vartype</emphasis>
	  como una enumeración pública (sin ejemplares) y modifique
	  <emphasis>print()</emphasis> para que requiera un argumento
	  del tipo <emphasis>vartype</emphasis> que le indique qué tiene
	  que hacer.
	</para>
      </listitem>

      <listitem>
    <!--
    9. Implement Mem2.h and make sure that the modified class still
    works with MemTest.cpp.
    -->
	<para>
	  Implemente <emphasis>Mem2.h</emphasis> y asegúrese
	  de que la clase modificada todavía funcione con
	  <emphasis>MemTest.cpp</emphasis>.
	</para>
      </listitem>

      <listitem>
    <!--
    10. Use class Mem to implement Stash. Note that because the
    implementation is private and thus hidden from the client
    programmer, the test code does not need to be modified.
    -->
	<para>
	  Utilice la clase <emphasis>Mem</emphasis> para
	  implementar <emphasis>Stash</emphasis>. Note que debido a que la
	  implementación es privada y por tanto oculta al programador
	  cliente, no necesita modificar el código de prueba.
	</para>
      </listitem>

      <listitem>
    <!--
    11. In class Mem, add a bool moved( ) member function that takes the
    result of a call to pointer( ) and tells you whether the pointer has
    moved (due to reallocation). Write a main( ) that tests your moved(
    ) member function. Does it make more sense to use something like
    moved( ) or to simply call pointer( ) every time you need to access
    the memory in Mem?
    -->
	<para>
	  Añada un método <emphasis>bool moved()</emphasis> en la clase
	  <emphasis>Mem</emphasis> que tome el resultado de una llamada
	  a <emphasis>pointer()</emphasis> y le diga si el puntero ha
	  cambiado (debido a una reasignación). Escriba una función
	  <emphasis>main()</emphasis> que pruebe su método
	  <emphasis>moved()</emphasis>. ¿Tiene más sentido utilizar algo
	  como <emphasis>moved()</emphasis> o simplemente llamar
	  <emphasis>pointer()</emphasis> cada vez que necesite acceder a
	  la memoria de <emphasis>Mem</emphasis>?
	</para>
      </listitem>

    </orderedlist>
  </sect1>

</chapter>

<!--
% Local variables:
%   ispell-local-dictionary: "castellano8"
% End:
-->
