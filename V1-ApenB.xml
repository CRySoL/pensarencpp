<?xml  version="1.0" encoding="utf-8"?>
<!-- -*- sgml -*- -->
<!--
  Editor:              Emacs 21/PSGML
  Traducción original: David Villa Alises
  Formateado DocBook:  David Villa Alises
  1ª Revisión:
  2ª Revisión
-->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                 "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<appendix
  xmlns:xi="http://www.w3.org/2001/XInclude"
  id="ApendiceB">

  <!-- Programming Guidelines -->
  <title>Directrices de Programación</title>

  <highlights>
    <!--
    This appendix is a collection of suggestions for C++
    programming. They've been assembled over the course of my teaching
    and programming experience and
    -->
    <para>
      Este apéndice es una colección de sugerencias para programación
      con C++. Se han reunido a lo largo de mi experiencia en
      como docente y programador y
    </para>
  </highlights>

  <!--
  also from the insights of friends including Dan Saks (co-author with
  Tom Plum of C++ Programming Guidelines, Plum Hall, 1991), Scott Meyers
  (author of Effective C++, 2nd edition, Addison-Wesley, 1998), and Rob
  Murray (author of C++ Strategies & Tactics, Addison-Wesley,
  1993). Also, many of the tips are summarized from the pages of
  Thinking in C++.
  -->

  <para>
    también de las aportaciones de amigos incluyendo a Dan Saks
    (co-autor junto a Tom Plum de <citetitle>C++ Programming
      Guidelines</citetitle>, Plum Hall, 1991), Scott Meyers (autor de
    <citetitle>Effective C++</citetitle>, 2ª edición, Addison-Wesley,
    1998), and Rob Murray (autor de <citetitle>C++ Strategies &amp;
    Tactics</citetitle>, Addison-Wesley, 1993). También, muchos de los
    consejos están resumidos a partir del contenido de
    <citetitle>Thinking in C++</citetitle>.
  </para>

  <orderedlist>
    <listitem>
      <!--
      1. First make it work, then make it fast. This is true even if you
      are certain that a piece of code is really important and that it
      will be a principal bottleneck in your system. Don't do it. Get
      the system going first with as simple a design as possible. Then
      if it isn't going fast enough, profile it. You'll almost always
      discover that "your" bottleneck isn't the problem. Save your
      time for the really important stuff.
      -->

      <para>
	Primero haga que funcione, después hágalo rápido. Esto es cierto
	incluso si se está seguro de que una trozo de código es
	realmente importante y se sabe que será un cuello de botella es
	el sistema. No lo haga. Primero, consiga que el sistema tenga un
	diseño lo más simple posible. Entonces, si no es suficientemente
	rápido, optimícelo. Casi siempre descubrirá que
	<quote>su</quote> cuello de botella no es el problema. Guarde su
	tiempo para lo verdaderamente importante.
      </para>
    </listitem>
    <listitem>
      <!--
      2. Elegance always pays off. It's not a frivolous pursuit. Not only
    does it give you a program that's easier to build and debug, but it'
    s also easier to understand and maintain, and that's where the
    financial value lies. This point can take some experience to
    believe, because it can seem that while you're making a piece of
    code elegant, you're not being productive. The productivity comes
    when the code seamlessly integrates into your system, and even more
    so when the code or system is modified.
    -->

      <para>
	La elegancia siempre vale la pena. No es un pasatiempo
	frívolo. No sólo permite que un programa sea más fácil de
	construir y depurar, también es más fácil de comprender y
	mantener, y ahí es donde radica su valor económico. Esta
	cuestión puede requerir de alguna experiencia para creerselo,
	porque puede parecer que mientras se está haciendo un trozo de
	código elegante, no se es productivo. La productividad aparece
	cuando el código se integra sin problemas en el sistema, e
	incluso cuando se modifica el código o el sistema.
      </para>
    </listitem>
    <listitem>
      <!--
    3. Remember the "divide and conquer" principle. If the problem you'
      re looking at is too confusing, try to imagine what the basic
      operation of the program would be, given the existence of a magic
      "piece" that handles the hard parts. That "piece" is an object
      - write the code that uses the object, then look at the object and
      encapsulate its hard parts into other objects, etc.
    -->
      <para>
	Recuerde el principio <quote>divide y vencerás</quote>. Si el
	problema al que se enfrenta es desmasiado confuso, intente
	imaginar la operación básica del programa se puede hacer, debido
	a la existencia de una <quote>pieza</quote> mágica que hace el
	trabajo difícil. Esta <quote>pieza</quote> es un objeto -
	escriba el código que usa el objeto, después implemente ese
	objeto encapsulando las partes difíciles en otros objetos, etc.
      </para>
    </listitem>
    <listitem>
      <!--
    4. Don't automatically rewrite all your existing C code in C++
      unless you need to significantly change its functionality (that
      is, don't fix it if it isn't broken). Recompiling C in C++ is a
      valuable activity because it may reveal hidden bugs. However,
      taking C code that works fine and rewriting it in C++ may not be
      the best use of your time, unless the C++ version will provide a
      lot of opportunities for reuse as a class.
    -->
      <para>
	No reescriba automáticamente todo su código C a C++ a menos que
	necesite un cambiar significativamente su funcionalidad (es
	decir, no lo arregle si no está roto). <emphasis>Recompilar
	C</emphasis> en C++ es un positivo porque puede revelar errores
	ocultos. Sim embargo, tomar código C que funciona bien y
	reescribirlo en C++ no es la mejor forma de invertir el tiempo,
	a menos que la versión C++ le ofrezca más oportunidad de
	reutilizarlo como una clase.
      </para>
    </listitem>
    <listitem>
      <!--
    5. If you do have a large body of C code that needs changing, first
      isolate the parts of the code that will not be modified, possibly
      wrapping those functions in an "API class" as static member
      functions. Then focus on the code that will be changed,
      refactoring it into classes to facilitate easy modifications as
      your maintenance proceeds.
      -->
      <para>
	Si tiene un gran trozo de código C que necesite cambios, primero
	aisle las partes del código que no se modificará, posiblemente
	envolviendo esas funciones en una <quote>clase API</quote> como
	métodos estáticos. Después ponga aténción al código que va a
	cambiar, recolocandolo dentro de clases para facilitar las
	modificaciones en el proceso de mantenimiento.
      </para>
    </listitem>
    <listitem>
      <!--
    6. Separate the class creator from the class user (client
      programmer). The class user is the "customer" and doesn't need
      or want to know what's going on behind the scenes of the
      class. The class creator must be the expert in class design and
      write the class so that it can be used by the most novice
      programmer possible, yet still work robustly in the
      application. Library use will be easy only if it's transparent.
      -->
      <para>
	Separe al creador de la clase del usuario de la clase (el
	<emphasis>programador cliente</emphasis>). El usuario de la
	clase es el <quote>consumidor</quote> y no necesita o no quiere
	conocer que hay dentro de la clase. El creador de la clase debe
	ser un experto en diseño de clases y escribir la clase para que
	pueda ser usada por el programador más inexperto posible, y aún
	así funcionar de forma robusta en la aplicación. El uso de la
	librería será sencillo sólo is es transparente.
      </para>
    </listitem>
    <listitem>
      <!--
    7. When you create a class, make your names as clear as
      possible. Your goal should be to make the client programmer's
      interface conceptually simple. Attempt to make your names so clear
      that comments are unnecessary. To this end, use function
      overloading and default arguments to create an intuitive,
      easy-to-use interface.
      -->
      <para>
	Cuando cree una clase, utilice nombres tan claros como sea
	posible. Eo objetivo debería ser que la interface del
	programador cliente sea conceptualmente simple. Intente utilizar
	nombres tan claros que los comentarios sean innecesarios. Luego,
	use sobrecarga de funciones y argumentos por defecto para crear
	un interface intuitiva y fácil de usar.
      </para>
    </listitem>
    <listitem>
      <!--
    8. Access control allows you (the class creator) to change as much as
      possible in the future without damaging client code in which the
      class is used. In this light, keep everything as private as
      possible, and make only the class interface public, always using
      functions rather than data. Make data public only when forced. If
      class users don't need to access a function, make it private. If
      a part of your class must be exposed to inheritors as protected,
      provide a function interface rather than expose the actual
      data. In this way, implementation changes will have minimal impact
      on derived classes.
      -->
      <para>
	El control de acceso permite (al creador de la clase) cambiar
	tanto como sea posible en el futuro sin afectar al código del
	cliente en el que se usa la clase. FIXME:Is this light, mantenga
	todo tan privado como sea posible, y haga pública solamente la
	interfaz de la clase, usando siempre métodos en lugar de
	atributos. Ponga atributos públicos sólo cuando se vea
	obligado. Si una parte de su clase debe quedar expuesta a clases
	derivadas como protegida, proporcione una interface
	con funciones en lugar de exponer los datos reales. De este
	modo, los cambios en la implementación tendrán un impacto mínimo
	en las clases derivadas.
      </para>
    </listitem>
    <listitem>
      <!--
    9. Don't fall into analysis paralysis. There are some things that
      you don't learn until you start coding and get some kind of
      system working. C++ has built-in firewalls; let them work for
      you. Your mistakes in a class or set of classes won't destroy the
      integrity of the whole system.
      -->
      <para>
	FIXME
	No caiga en FIXME:analysis paralysis. Hay algunas cosas que no
	aprenderá hasta que empiece a codificar y consiga algún tipo de
	sistema. C++ tiene mecanimos de seguridad de fábrica, dejelos
	trabajar por usted. Sus errores en una clase o conjunto de
	clases no destruirá la integridad del sistema completo.
      </para>
    </listitem>
    <listitem>
      <!--
   10. Your analysis and design must produce, at minimum, the classes in
      your system, their public interfaces, and their relationships to
      other classes, especially base classes. If your design methodology
      produces more than that, ask yourself if all the pieces produced
      by that methodology have value over the lifetime of the
      program. If they do not, maintaining them will cost you. Members
      of development teams tend not to maintain anything that does not
      contribute to their productivity; this is a fact of life that many
      design methods don't account for.
      -->
      <para>
	El análisis y diseño debe producir, como mínimo, las clases del
	sistema, sus interfaces públicas, y las relaciones con otras
	clases, especialmente las clases base. Si su metodología de
	diseño produce más que eso, preguntese a si mismo si todas las
	piezas producidas por la metodología tiene valor respecto al
	tiempo de vide del programa. Si no lo tienen, no mantenga nada
	que no contribuya a su productividad, este es un FIXME:fact of
	life] que muchos métodos de diseño no tienen en cuenta.
      </para>
    </listitem>
    <listitem>
      <!--
   11. Write the test code first (before you write the class), and keep
      it with the class. Automate the running of your tests through a
      makefile or similar tool. This way, any changes can be
      automatically verified by running the test code, and you'll
      immediately discover errors. Because you know that you have the
      safety net of your test framework, you will be bolder about making
      sweeping changes when you discover the need. Remember that the
      greatest improvements in languages come from the built-in testing
      that type checking, exception handling, etc., provide, but those
      features take you only so far. You must go the rest of the way in
      creating a robust system by filling in the tests that verify
      features that are specific to your class or program.
      -->
      <para>
	Escriba primero el código de las pruebas (antes de escribir la
	clase), y guardelo junto a la clase. Automatice la ejecución de
	las pruebas con un <function>makefile</function> o herramienta
	similar. De este modo, cualquier cambio se puede verificar
	automáticamente ejecutando el código de prueba, lo que permite
	descubrir los errores inmediatamante. Como sabe que cuenta con
	esa red de seguridad, puede arriesgar haciendo cambios más
	grandes cuando descubra la necesidad. Recuerde que las mejoras
	más importantes en los lenguajes provienen de las pruebas que
	hace el compilador: chequeo de tipos, gestión de excepciones,
	etc., pero estas características no puede ir muy lejos. Debe
	hacer el resto del camino creando un sistema robusto rellenando
	las pruebas que verifican las características específicas de la
	clase o programa concreto.
      </para>
    </listitem>
    <listitem>
      <!--
    12. Write the test code first (before you write the class) in order to
      verify that your class design is complete. If you can't write
      test code, you don't know what your class looks like. In
      addition, the act of writing the test code will often flush out
      additional features or constraints that you need in the class -
      these features or constraints don't always appear during analysis
      and design.
      -->
      <para>
	Escriba primero el código de las pruebas (antes de escribir la
	clase) para verificar que el diseño de la clase está
	completo. Si no puede escribir el código de pruebas, significa
	que no sabe que aspecto tiene la clases. En resumen, el echo de
	escribir las pruebas a menudo desvela características
	adicionales o restricciones que necesita la clase - esas
	características o restricciones no siempre aparecen durante el
	análisis y diseño.
      </para>
    </listitem>
    <listitem>
      <!--
    13. Remember a fundamental rule of software engineering[65]: All
      software design problems can be simplified by introducing an extra
      level of conceptual indirection. This one idea is the basis of
      abstraction, the primary feature of object-oriented programming.
      -->
      <para>
	Recuerde una regla fundamental de la ingeniería del software
	<footnote>
	  <para>
	    Que me explicó Andrew Koening.
	  </para>
	</footnote>: <emphasis>Todos los problemas del diseño de
	software se puede simplificar introduciendo una nivel más de
	indirección conceptual</emphasis>. Esta única idea es la pase de
	la abstracción, la principal cualidad de la programación
	orientada a objetos.
      </para>
    </listitem>
    <listitem>
      <!--
    14. Make classes as atomic as possible; that is, give each class a
      single, clear purpose. If your classes or your system design grows
      too complicated, break complex classes into simpler ones. The most
      obvious indicator of this is sheer size: if a class is big,
      chances are it's doing too much and should be broken up.
      -->
      <para>
	Haga clases tan atómicas como sea posible: Es decir, dé a cada
	clase un propósito único y claro. Si el diseño de su clase o de
	su sistema crece hasta ser demasiado complicado, divida las
	clases complejas en otras más simples. El indicador más obvio es
	tamaño total: si una clase es grande, FIXME: chances are it's
	doing demasiado y debería dividirse.
      </para>
    </listitem>
    <listitem>
      <!--
    15. Watch for long member function definitions. A function that is
      long and complicated is difficult and expensive to maintain, and
      is probably trying to do too much all by itself. If you see such a
      function, it indicates that, at the least, it should be broken up
      into multiple functions. It may also suggest the creation of a new
      class.
      -->
      <para>
        Vigile las definiciones de métodos largos. Una función demasiado
        larga y complicada es dificil y cara de mantener, y es problema
        que esté intentado hacer demasiado trabajo por ella misma. Si ve
        una función así, indica que, al menos, debería dividirse en
        múltiples funciones. También puede sugerir la creación de una
        nueva clase.
      </para>
    </listitem>
    <listitem>
      <!--
    16. Watch for long argument lists. Function calls then become
      difficult to write, read and maintain. Instead, try to move the
      member function to a class where it is (more) appropriate, and/or
      pass objects in as arguments.
      -->
      <para>
	Vigile las listas de argumentos largas. Las llamadas a función
	se vuelven difíciles de escribir, leer y mantener. En su lugar,
	intente mover el método a una clase donde sea más apropiado, y/o
	pasele objetos como argumentos.
      </para>
    </listitem>
    <listitem>
      <!--
    17. Don't repeat yourself. If a piece of code is recurring in many
      functions in derived classes, put that code into a single function
      in the base class and call it from the derived-class
      functions. Not only do you save code space, you provide for easy
      propagation of changes. You can use an inline function for
      efficiency. Sometimes the discovery of this common code will add
      valuable functionality to your interface.
      -->
      <para>
	No se repita. Si un trozo de código se repite en muchos métodos
	de las clases derivadas, ponga el código en un método de la
	clase base e invóquelo desde las clases derivadas. No sólo
	ahorrará código, también facilita la propagación de los
	cambios. Puede usar una función inline si necesita eficiencia. A
	veces el descubrimiento de este código común añadirá
	funcionalidad valiosa a su interface.
      </para>
    </listitem>
    <listitem>
      <!--
    18. Watch for switch statements or chained if-else clauses. This is
      typically an indicator of type-check coding, which means you are
      choosing what code to execute based on some kind of type
      information (the exact type may not be obvious at first). You can
      usually replace this kind of code with inheritance and
      polymorphism; a polymorphic function call will perform the type
      checking for you, and allow for more reliable and easier
      extensibility.
      -->
      <para>
	Vigile las sentencias <kw>switch</kw> o cadenas de
	<kw>if-else</kw>. Son indicadores típicos de <emphasis>código
	dependiente del tipo</emphasis>, lo que significa que está
	decidiendo qué código ejecutar basándose en alguna información
	de tipo (el tipo exacto puede no ser obvio en
	principio). Normalemente puede reemplazar este tipo de código
	por herencia y polimorfismo; una llamada a una función
	polimórfica efectuará la comprobación de tipo por usted, y hará
	que el código sea más fiable y sencillo de extender.
      </para>
    </listitem>
    <listitem>
      <!--
    19. From a design standpoint, look for and separate things that change
      from things that stay the same. That is, search for the elements
      in a system that you might want to change without forcing a
      redesign, then encapsulate those elements in classes. You can
      learn significantly more about this concept in the Design Patterns
      chapter in Volume 2 of this book, available at www.BruceEckel.com.
      -->
      <para>
	Desde el punto de vista del diseño, busque y distinga cosas que
	cambian y cosas que no cambian. Es decir, busque elementos en un
	sistema que podrían cambiar sin forzar un rediseño, después
	encapsule esos elementos en clases. Puede aprender mucho más
	sobre este concepto en el capítulo <emphasis>Dessign
	Patterns</emphasis> del Volumen 2 de este libro, disponible en
	<ulink
	url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>
	<footnote>
	  <para>
	    (N. de T.) Está prevista la traducción del Volumen 2 por
	    parte del mismo equipo que ha traducido este volumen. Visite
	    <ulink url="FIXME">FIXME</ulink>
	  </para>
	</footnote>
      </para>
    </listitem>
    <listitem>
      <!--
    20. Watch out for variance. Two semantically different objects may
      have identical actions, or responsibilities, and there is a
      natural temptation to try to make one a subclass of the other just
      to benefit from inheritance. This is called variance, but there's
      no real justification to force a superclass/subclass relationship
      where it doesn't exist. A better solution is to create a general
      base class that produces an interface for both as derived classes
      - it requires a bit more space, but you still benefit from
      inheritance and will probably make an important discovery about
      the design.
      -->
      <para>
	Tenga cuidado con las FIXME
	<emphasis>discrepancia</emphasis>. Dos objetos semánticamente
	diferentes puede tener acciones idénticas, o responsabilidades,
	y hay una tendencia natural a intentar hacer que una sea
	subclase de la otra sólo como beneficio de la herencia. Ese se
	llama discrepancia, pero no hay una justificación real para
	forzar una relación superclase/subclase donde no existe. Un
	solución mejor es crear una clase base general que produce una
	herencia para las dos como clases derivadas - eso require un
	poco más de espacio, pero sigue beneficiandose de la herencia y
	probablemente hará un importante descubrimiento sobre el diseño.
      </para>
    </listitem>
    <listitem>
      <!--
    21. Watch out for limitation during inheritance. The clearest designs
      add new capabilities to inherited ones. A suspicious design
      removes old capabilities during inheritance without adding new
      ones. But rules are made to be broken, and if you are working from
      an old class library, it may be more efficient to restrict an
      existing class in its subclass than it would be to restructure the
      hierarchy so your new class fits in where it should, above the old
      class.
      -->
      <para>
	Tenga cuidado con la FIXME: <emphasis>limitación</emphasis> de la
	herencia. Los diseños más límpios añaden nuevas capacidades a
	las heredadas. Un diseño sospechoso elimina capacidades durante
	la herencia sin añadir otras nuevas. Pero las reglas están
	hechas para romperse, y si está trabajando con una librería
	antigua, puede ser más eficiente restringir una clase existente
	en sus subclases que restructurar la jerarquía de modo que la
	nueva clase encaje donde debería, sobre la clase antigua.
      </para>
    </listitem>
    <listitem>
      <!--
    22. Don't extend fundamental functionality by subclassing. If an
      interface element is essential to a class it should be in the base
      class, not added during derivation. If you're adding member
      functions by inheriting, perhaps you should rethink the design.
       -->
      <para>
	No extienda funcionalidad fundamental por medio de subclases. Si
	un elemento de la interfaz es esecial para una clase debería
	estár en la clase base, no añadido en una clase derivada. Si
	está añadiendo métodos por herencia, quizá debería repensar el
	diseño.
      </para>
    </listitem>
    <listitem>
      <!--
    23. Less is more. Start with a minimal interface to a class, as small
      and simple as you need to solve the problem at hand, but don't
      try to anticipate all the ways that your class might be used. As
      the class is used, you'll discover ways you must expand the
      interface. However, once a class is in use you cannot shrink the
      interface without disturbing client code. If you need to add more
      functions, that's fine; it won't disturb code, other than
      forcing recompiles. But even if new member functions replace the
      functionality of old ones, leave the existing interface alone (you
      can combine the functionality in the underlying implementation if
      you want). If you need to expand the interface of an existing
      function by adding more arguments, leave the existing arguments in
      their current order, and put default values on all of the new
      arguments; this way you won't disturb any existing calls to that
      function.
       -->
      <para>
	Menos es más. Empiece con una interfaz mínima a una clase, tan
	pequeña y simple como necesite para resolver el problema que
	está tratando, pero no intente anticipar todas las formas en las
	que se <emphasis>podría</emphasis> usar la clase. Cuando use la
	clase, descubrirá formas de usarla y deberá expandir la
	interface. Sin embargo, una vez que que la clase esté siendo
	usada, no podrá reducir la interfaz sin causar problemas al
	código cliente. Si necesita añadir más funciones, está bien; eso
	no molesta, únicamente obliga a recompilar. Pero incluso si los
	nuevos métodos reemplazan las funcionalidad de los antiguos,
	deje tranquila la interfaz existente (puede combinar la
	funcionalidad de la implementación subyacente si lo desea. Si
	necesita expandir la interfaz de un método existente añadiendo
	más argumentos, deje los argumentos existentes en el orden
	actual, y ponga valores por defecto a todos los argumentos
	nuevos; de este modo no perturbará ninguna de las llamadas
	antiguas a esa función.
      </para>
    </listitem>
    <listitem>
      <!--
    24. Read your classes aloud to make sure they're logical, referring
      to the relationship between a base class and derived class as
      "is-a" and member objects as "has-a."
      -->
      <para>
	Lea sus clases en voz alta para estar seguro que que suenan
	lógicas, refiriendose a las relación entre una clase base y una
	clase derivada com <quote>es-un</quote> y a los objetos miembro
	como <quote>tiene-un</quote>.
      </para>
    </listitem>
    <listitem>
      <!--
    25. When deciding between inheritance and composition, ask if you need
      to upcast to the base type. If not, prefer composition (member
      objects) to inheritance. This can eliminate the perceived need for
      multiple inheritance. If you inherit, users will think they are
      supposed to upcast.
      -->
      <para>
	Cuando tenga que decidir entre herencia y composición, pregunte
	si necesita hacer upcast al tipo base. Si la respuesta es no,
	elija composición (objetos miembro) en lugar de herencia. Esto
	puede eliminar la necesidad de herencia múltiple. Si hereda, los
	usuarios pensarán FIXME:they are supposed to upcast.
      </para>
    </listitem>
    <listitem>
      <!--
    26. Sometimes you need to inherit in order to access protected members
      of the base class. This can lead to a perceived need for multiple
      inheritance. If you don't need to upcast, first derive a new
      class to perform the protected access. Then make that new class a
      member object inside any class that needs to use it, rather than
      inheriting.
        -->
      <para>
	A veces, se necesita heredar para acceder a miembros protegidos
	de una clase base. Esto puede conducir a una necesidad de
	herencia múltiple. Si no necesita hacer upcast, primero derive
	una nueva clase para efectuar el acceso protegido. Entonces haga
	que la nueva clase sea un objeto miembro dentro de cualquier
	clase que necesite usarla, el lugar de heredar.
      </para>
    </listitem>
    <listitem>
      <!--
    27. Typically, a base class will be used primarily to create an
      interface to classes derived from it. Thus, when you create a base
      class, default to making the member functions pure virtual. The
      destructor can also be pure virtual (to force inheritors to
      explicitly override it), but remember to give the destructor a
      function body, because all destructors in a hierarchy are always
      called.
      -->
      <para>
	Típicamente, una clase base se usará principalmente para crear
	una interface a las clases que hereden de ella. De ese modo,
	cuando cree una clase base, haga que por defecto los métodos
	sean virtuales puros. El destructor puede ser también virtual
	puro (para forzar que los derivadas tengan que anularlo
	explicitamente), pero recuerde poner al destructor un cuerpo,
	porque todos destructores de la jerarquía se ejecutan siempre.
      </para>
    </listitem>
    <listitem>
      <!--
    28. When you put a virtual function in a class, make all functions in
      that class virtual, and put in a virtual destructor. This approach
      prevents surprises in the behavior of the interface. Only start
      removing the virtual keyword when you're tuning for efficiency
      and your profiler has pointed you in this direction.
         -->
      <para>
	Cuando pone un método virtual puro en una clase, haga que todos
	los métodos de la clase sean también viruales, y ponga un
	constructor virtual. Esta propuesta evita sorpresas en el
	comportamiento de la interfaz. Empiece a quitar la palabra
	<kw>virtual</kw> sólo cuando esté intentando optimizar y su
	perfilador haya apuntado en esta dirección.
      </para>
    </listitem>
    <listitem>
      <!--
    29. Use data members for variation in value and virtual functions for
      variation in behavior. That is, if you find a class that uses
      state variables along with member functions that switch behavior
      based on those variables, you should probably redesign it to
      express the differences in behavior within subclasses and
      overridden virtual functions.
      -->
      <para>
	Use atributos para variaciones en los valores y métodos
	virtuales para variaciones en el comportamiento. Es decir, si
	encuentra una clase que usa atributos estáticos con métodos que
	cambian de comportamiento basandose en esos atributos,
	probablemente deberia rediseñarla para expresar las diferencias
	de comportamiento con subclases y métodos virtuales anulados.
      </para>
    </listitem>
    <listitem>
      <!--
    30. If you must do something nonportable, make an abstraction for that
      service and localize it within a class. This extra level of
      indirection prevents the non-portability from being distributed
      throughout your program.
      -->
      <para>
	If debe hacer algo no portable, cree una abstracción para el
	servicio y póngalo en una clase. Este nivel extra de indirección
	facilita la portabilidad mejor que si se distribuyera por todo
	el programa.

      </para>
    </listitem>
    <listitem>
      <!--
    31. Avoid multiple inheritance. It's for getting you out of bad
      situations, especially repairing class interfaces in which you don'
      t have control of the broken class (see Volume 2). You should be
      an experienced programmer before designing multiple inheritance
      into your system.
        -->
      <para>
	Evite la herencia múltiple. Estará a salvo de malas situaciones,
	especialmente cuando repare las interfaces de clases que están
	fuera de su control (vea el Volumen 2). Debería ser un
	programador experimentado antes de poder diseñar con herencia
	múltiple.
      </para>
    </listitem>
    <listitem>
      <!--
    32. Don't use private inheritance. Although it's in the language and
      seems to have occasional functionality, it introduces significant
      ambiguities when combined with run-time type
      identification. Create a private member object instead of using
      private inheritance.
        -->
      <para>
	No use herencia privada. Aunque, está en el lenguaje y parece
	que tiene una funcionalidad ocasional, ello implica ambigüedades
	importantes cuando se combina con comprobación dinámica de
	tipo. Cree un objeto miembro privado en lugar de usar herencia
	privada.
      </para>
    </listitem>
    <listitem>
      <!--
    33. If two classes are associated with each other in some functional
      way (such as containers and iterators), try to make one a public
      nested friend class of the other, as the Standard C++ Library does
      with iterators inside containers (examples of this are shown in
      the latter part of Chapter 16). This not only emphasizes the
      association between the classes, but it allows the class name to
      be reused by nesting it within another class. The Standard C++
      Library does this by defining a nested iterator class inside each
      container class, thereby providing the containers with a common
      interface. The other reason you'll want to nest a class is as
      part of the private implementation. Here, nesting is beneficial
      for implementation hiding rather than the class association and
      prevention of namespace pollution noted above.
       -->
      <para>
	Si dos clases están asociadas entre si de algún modo (como los
	contenedores y los iteradores). intente hacer que una de ellas
	sea una clase amiga anidada de la otro, tal como la Librería
	Estándar C++ hace con los interadores dentro de los contenedores
	(En la última parte del Capítulo 16 se muestran ejemplos de
	esto). No solo pone de manifiesto la asociación entre las
	clases, también permite que el nombre de la clase se pueda
	reutilizar anidándola en otra clase. La Librería Estándar C++ lo
	hace definiendo un clase iterador anidada dentro de cada clase
	contenedor, de ese modo los contenedores tienen una interface
	común. La otra razón por la que querrá anidar una clase es como
	parte de la implementación privada. En ese caso, el anidamiento
	es beneficioso para ocultar la implementación más por la
	asociación de clases y la prevención de la contaminación del
	espacio de nombres citada arriba.
      </para>
    </listitem>
    <listitem>
      <!--
    34. Operator overloading is only "syntactic sugar:" a different way
      to make a function call. If overloading an operator doesn't make
      the class interface clearer and easier to use, don't do
      it. Create only one automatic type conversion operator for a
      class. In general, follow the guidelines and format given in
      Chapter 12 when overloading operators.
      -->
      <para>
	La sobrecarga de operadores en sólo <quote>azucar
	sintáctico:</quote> una manera diferente de hacer una llamada a
	función. Is sobrecarga un operador no está haciendo que la
	interfaz de la clase sea más clara o fácil de usar, no lo
	haga. Cree sólo un operador de conversión automática de tipo. En
	general, seguir las directrices y estilo indicados en el
	Capítulo 12 cuando sobrecargue operadores.
      </para>
    </listitem>
    <listitem>
      <!--
    35. Don't fall prey to premature optimization. That way lies
      madness. In particular, don't worry about writing (or avoiding)
      inline functions, making some functions nonvirtual, or tweaking
      code to be efficient when you are first constructing the
      system. Your primary goal should be to prove the design, unless
      the design requires a certain efficiency.
       -->
      <para>
	No sea una víctima de la optimización prematura. Ese camino
	lleva a la locura. In particular, no se preocupe de escribir (o
	evitar) funciones inline, hacer algunas funciones no virtuales,
	afinar el código para hacerlo más eficiente cuando esté en las
	primer fase de contrucción del sistema. El objetivo principal
	debería ser probar el diseño, a menos que el propio diseño
	requiera cierta eficiencia.
      </para>
    </listitem>
    <listitem>
      <!--
    36. Normally, don't let the compiler create the constructors,
      destructors, or the operator= for you. Class designers should
      always say exactly what the class should do and keep the class
      entirely under control. If you don't want a copy-constructor or
      operator=, declare them as private. Remember that if you create
      any constructor, it prevents the default constructor from being
      synthesized.
      -->
      <para>
	Normalmente, no deje que el compilador cree los constructores,
	destructores o el <oper>operator=</oper> por usted. Los
	diseñadores de clases siempre deberían decir qué debe hacer la
	clase exactamente y mantenerla enteramente bajo su control. Si
	no quiere costructor de copia u <oper>operator=</oper>,
	declarelos como privados. Recuerde que si crea algún
	constructor, el compilador un sintetizará un constructor por
	defecto.
      </para>
    </listitem>
    <listitem>
      <!--
    37. If your class contains pointers, you must create the
      copy-constructor, operator=, and destructor for the class to work
      properly.
      -->
      <para>
	Si su clase contiene punteros, debe crear el constructor de
	copia, el <oper>operator=</oper> y el destructor de la clase
	para que funcione adecuadamente.
      </para>
    </listitem>
    <listitem>
      <!--
    38. When you write a copy-constructor for a derived class, remember to
      call the base-class copy-constructor explicitly (also the
      member-object versions). (See Chapter 14.) If you don't, the
      default constructor will be called for the base class (or member
      object) and that probably isn't what you want. To call the
      base-class copy-constructor, pass it the derived object you're
      copying from:
      -->
      <para>
	Cuando escriba un constructor de copia para una clase
	derivada, recuerde llamar explícitamente al constructor de copia
	de la clase base (también cuando se usan objetos miembro). (Vea
	el Capítulo 14.) Si no lo hace, el constructor por defecto será
	invocado desde la case base (o el objeto miembro) y con mucha
	probabilidad no hará lo que usted espera. Para invocar el
	constructor de copia de la clase base, pásele el objeto derivado
	desde el que está copiando:
      </para>

<programlisting>
Derived(const Derived&amp; d) : Base(d) { // ...
</programlisting>

    </listitem>
    <listitem>
      <!--
    39. When you write an assignment operator for a derived class,
      remember to call the base-class version of the assignment operator
      explicitly. (See Chapter 14.) If you don't, then nothing will
      happen (the same is true for the member objects). To call the
      base-class assignment operator, use the base-class name and scope
      resolution:
      -->
      <para>
	Cuando escriba un operador de asignación para una clase
	derivada, recuerde llamar explícitamente al operador de
	asignación de la clase base. (Vea el Capítulo 14.) SI no lo
	hace, no ocurrirá nada (lo mismo es aplicable a los objetos
	miembro). Para invocar el operador de asignación de la clase
	base, use el nombre de la clase base y el operador de resolución
	de ámbito:
      </para>

      <programlisting>
    Derived&amp; operator=(const Derived&amp; d) {
    Base::operator=(d);
</programlisting>

    </listitem>
    <listitem>
      <!--
    40. If you need to minimize recompiles during development of a large
      project, use the handle class/Cheshire cat technique demonstrated
      in Chapter 5, and remove it only if runtime efficiency is a
      problem.
      -->
      <para>
	Si necesita minimizar las recompilaciones durante el desarrollo
	de un proyecto largo, use FIXME: demostrada en el Capítulo 5, y
	eliminela solo si la eficiencia en tiempo de ejecución es un
	problema.
      </para>
    </listitem>
    <listitem>
      <!--
    41. Avoid the preprocessor. Always use const for value substitution
      and inlines for macros.
        -->
      <para>
	Evite el preprocesador. Use siempre <kw>const</kw> para
	substitución de valores e inlines para las machos.
      </para>
    </listitem>
    <listitem>
      <!--
    42. Keep scopes as small as possible so the visibility and lifetime of
      your objects are as small as possible. This reduces the chance of
      using an object in the wrong context and hiding a
      difficult-to-find bug. For example, suppose you have a container
      and a piece of code that iterates through it. If you copy that
      code to use with a new container, you may accidentally end up
      using the size of the old container as the upper bound of the new
      one. If, however, the old container is out of scope, the error
      will be caught at compile time.
      -->
      <para>
	Mantenga los ámbitos tan pequeños como sea posible de modo que
	la visibilidad y el tiempo de vidad de los objetos sea lo más
	pequeño posible. Esto reduce el peligro de usar un objeto en el
	contexto equivocado y ello supone un bug dificil de
	encontrar. Por ejemplo, suponga que tiene un contenedor y un
	trozo de código que itera sobre él. Si copia el código para
	usarlo otro contenedor, puede que accidentalmente acabe usando
	el tamaño del primer contenedor como el límite superior del
	nuevo. Pero, si el primer contendor estuviese fuera del ámbito,
	podría detectar el error en tiempo de compilación.
      </para>
    </listitem>
    <listitem>
      <!--
    43. Avoid global variables. Always strive to put data inside
      classes. Global functions are more likely to occur naturally than
      global variables, although you may later discover that a global
      function may fit better as a static member of a class.
      -->
      <para>
	Evite las variables globales. Esfuercese en pones los datos
	dentro de clases. En más probable que aparezcan funciones
	globales de forma natural que variables globales, aunque puede
	que después descubra que una función global puede encajar como
	método estático de una clase.
      </para>
    </listitem>
    <listitem>
      <!--
    44. If you need to declare a class or function from a library, always
      do so by including a header file. For example, if you want to
      create a function to write to an ostream, never declare ostream
      yourself using an incomplete type specification like this,
      -->
      <para>
	Si necesita declara una clase o función de una librería, hágalo
	siempre incluyendo su fichero de cabecera. Por ejemplo, si
	quiere crear una función para escribir en un
	<classname>ostream</classname>, no declare nunca el
	<classname>ostream</classname> por usted mismo, usando una
	especificación de tipo incompleta como esta:
      </para>

<programlisting>
    class ostream;
</programlisting>

      <!--
    This approach leaves your code vulnerable to changes in
    representation. (For example, ostream could actually be a typedef.)
    Instead, always use the header file:
      -->
      <para>
	Este enfoque hace que su código sea vulnerabla a cambios en la
	representación. (Por ejmplo, <classname>ostream</classname>
	podrías ser en realidad un <kw>typedef</kw>.) En lugar de lo
	anterior, use siempre el ficheor de cabecera:
      </para>

      <programlisting>
    #include &lt;iostream>
</programlisting>

      <!--
    When creating your own classes, if a library is big, provide your
    users an abbreviated form of the header file with incomplete type
    specifications (that is, class name declarations) for cases in which
    they need to use only pointers. (It can speed compilations.)
      -->
      <para>
	Cuando cree sus propias clases, si una librería es grande,
	proporciones a sus usuarios una versión abreviada del fichero de
	cabecera con especificaciones de tipo incompletas (es decir,
	declaraciones de los nombres de las clases) para los casos en
	que ellos puedan necesitar usar únicamente punteros. (eso puede
	acelerar las compilaciones.)
      </para>
    </listitem>
    <listitem>
      <!--
   45. When choosing the return type of an overloaded operator, consider
    what will happen if expressions are chained together. Return a copy
    or reference to the lvalue (return *this) so it can be used in a
    chained expression (A = B = C). When defining operator=, remember
    x=x.
      -->
      <para>
	Cuando elija el tipo de retorno de una operador sobrecargado,
	considere que ocurrirá if se encadenan expresiones. Retorne una
	copia o referencia al valor (<code>return *this</code>) de modo
	que se pueda usar e una expresión encadenada (<code>A = B =
	C</code>). Cuando defina el <oper>operator=</oper>, recuerde que
	<code>x=x</code>.
      </para>
    </listitem>
    <listitem>
      <!--
   46. When writing a function, pass arguments by const reference as your
    first choice. As long as you don't need to modify the object being
    passed, this practice is best because it has the simplicity of
    pass-by-value syntax but doesn't require expensive constructions
    and destructions to create a local object, which occurs when passing
    by value. Normally you don't want to be worrying too much about
    efficiency issues when designing and building your system, but this
    habit is a sure win.
      -->
      <para>
	Cuando escriba una función, pase los argumentos por referencia
	constante como primera elección. Siempre que no necesite
	modificar el objeto que está pasando, esta es la mejor práctica
	porque es tan simple como si lo parasa por valor pero sin pagar el
	alto precio de construir y destruir un objeto local, que es lo
	que ocurre cuando se pasa por valor. Normalmente no se querrá
	preocupar demasiado de las cuestiones de eficiencia cuando esté
	diseñando y contruyendo su sistema, pero este hábito es una
	ganancia segura.
      </para>
    </listitem>
    <listitem>
      <!--
   47. Be aware of temporaries. When tuning for performance, watch out
    for temporary creation, especially with operator overloading. If
    your constructors and destructors are complicated, the cost of
    creating and destroying temporaries can be high. When returning a
    value from a function, always try to build the object "in place"
    with a constructor call in the return statement:
      -->
      <para>
	Tenga cuidado con los temporarios. Cuando esté optimizando,
	busque creaciones de temporarios, especialmente con sobrecarga
	de operadores. Si sus constructores y destructores son
	complicados, el coste de la creació y destrucción de temporarios
	puede ser muy alto. Cuando devuelva un valor en una función,
	intente siempre contruir el objeto <quote>en el sitio</quote>
	(<emphasis>in place</emphasis>) con una llamada al constructor
	en la sentencia de retorno:
      </para>

<programlisting>
return MyType(i, j);
      </programlisting>

  <!--
      rather than
      -->

      <para>mejor que</para>

<programlisting>
MyType x(i, j);
return x;
</programlisting>

    <!--
    The former return statement (the so-called return-value
    optimization) eliminates a copy-constructor call and destructor
    call.
    -->
      <para>
	La primera sentencia <kw>return</kw> (también llamada
	<emphasis>optimización de valor de retorno</emphasis>) evita una
	llamada al constructor de copia y al destructor.
      </para>
    </listitem>
    <listitem>
      <!--
   48.# When creating constructors, consider exceptions. In the best case,
    the constructor won't do anything that throws an exception. In the
    next-best scenario, the class will be composed and inherited from
    robust classes only, so they will automatically clean themselves up
    if an exception is thrown. If you must have naked pointers, you are
    responsible for catching your own exceptions and then deallocating
    any resources pointed to before you throw an exception in your
    constructor. If a constructor must fail, the appropriate action is
    to throw an exception.
      -->
      <para>
	Cuando escriba constructores, considere las excepciones. En el
	mejor caso, el constructor no hará nada que eleve un
	excepción. En ese escenario, la clasé será compuesta y heredará
	solo de clases robustas, de modo que ellas se limpiarán
	automáticamente si se eleva una excepción. Si requiere punteros,
	usted es responsable de capturar sus propias excepciones y de
	liberar los recursos antes de elevar una excepción en su
	constructor. Si un contructor tiene que fallar, la acción apropiada
	es elevar una excepción.
      </para>
    </listitem>
    <listitem>
      <!--
   49. Do only what is minimally necessary in your constructors. Not only
    does this produce a lower overhead for constructor calls (many of
    which may not be under your control) but your constructors are then
    less likely to throw exceptions or cause problems.
      -->
      <para>
	En los constructores, haga lo mínimo necesario. No solo
	producirá una sobrecarga menor al crear objetos (muchas de las
	cuales pueden quedar fuera del control del programador), además
	la probabilidad de que eleven excepciones o causen problemas
	será menor.
      </para>
    </listitem>
    <listitem>
      <!--
  50. The responsibility of the destructor is to release resources
    allocated during the lifetime of the object, not just during
    construction.
      -->
      <para>
	La responsabilidad del destructor es la de liberar los recursos
	solicitados durante la vida del objeto, no sólo durante la
	construcción.
      </para>
    </listitem>
    <listitem>
      <!--
   51. Use exception hierarchies, preferably derived from the Standard
    C++ exception hierarchy and nested as public classes within the
    class that throws the exceptions. The person catching the exceptions
    can then catch the specific types of exceptions, followed by the
    base type. If you add new derived exceptions, existing client code
    will still catch the exception through the base type.
      -->
      <para>
	Utilice jerarquías de excepciones, preferiblemente derivadas de
	la jerarquía de excepción estándar de C++ y anidelas como clases
	públicas con la clase que eleva la excepción. La persona que
	captue las excepciónes puede capturar los tipos específicos de
	excepciones, seguida del tipo base. Si añade una nueva excepción
	derivada, el código de cliente anterior seguirá capturando la
	excepción por medio del tipo base.
      </para>
    </listitem>
    <listitem>
      <!--
   52. Throw exceptions by value and catch exceptions by reference. Let
    the exception-handling mechanism handle memory management. If you
    throw pointers to exception objects that have been created on the
    heap, the catcher must know to destroy the exception, which is bad
    coupling. If you catch exceptions by value, you cause extra
    constructions and destructions; worse, the derived portions of your
    exception objects may be sliced during upcasting by value.
      -->
      <para>
	Eleve las excepciones por valor y capturelas por
	referencia. Deje que el mecanismo de gestión de excepciones
	haga la gestión de memoria. Si eleva punteros como objetos en la
	excepción que han sido creados en el montículo, el que capture
	la excepción debe saber como liberar la excepción, lo cual
	implica un acoplamiento perjudicial. Si captura las excepciones por
	valor, causará que se creen temporarios; peor, las partes
	derivadas de sus objetos-excepción se pueden partir al hacer
	upcasting por valor.
      </para>
    </listitem>
    <listitem>
      <!--
   53. Don't write your own class templates unless you must. Look first
    in the Standard C++ Library, then to vendors who create
    special-purpose tools. Become proficient with their use and you'll
    greatly increase your productivity.
      -->
      <para>
	No escriba sus propias clases plantilla a menos que debe. Mire
	primero en la Librería Estándar de C++, después en librerías de
	propósito específico. Adquiera habilidad en su uso y
	conseguirá incrementar mucho su productividad.
      </para>
    </listitem>
    <listitem>
      <!--
   54. When creating templates, watch for code that does not depend on
    type and put that code in a non-template base class to prevent
    needless code bloat. Using inheritance or composition, you can
    create templates in which the bulk of the code they contain is
    type-dependent and therefore essential.
      -->
      <para>
	Cuando cree plantillas, escriba código que no dependa del tipo y
	ponga ese código en una clase base no-plantilla para evitar que
	el código aumente de tamaño sin necesidad. Por medio de herencia
	o composición, puede crear plantillas en las que el volumen de
	código que contienen es dependiente del tipo y por tanto esencial.
      </para>
    </listitem>
    <listitem>
      <!--
   55. Don't use the &lt;cstdio> functions, such as printf( ). Learn to
    use iostreams instead; they are type-safe and type-extensible, and
    significantly more powerful. Your investment will be rewarded
    regularly. In general, always use C++ libraries in preference to C
    libraries.
      -->
      <para>
	No use las funciones de <filename>&lt;stdio></filename>, como
	por ejemplo <function>printf()</function>. Aprenda a usar
	iostreams en su lugar; son FIXME:type-safe y type-extensible, y
	mucho más potentes. El esfuerzo se verá recompensado con
	regularidad. En general, use siempre librerías C++ antes que
	librerías C.
      </para>
    </listitem>
    <listitem>
      <!--
   56. Avoid C's built-in types. They are supported in C++ for backward
    compatibility, but they are much less robust than C++ classes, so
    your bug-hunting time will increase.
      -->
      <para>
	Evite los tipos predefinidos de C. El soporte de C++ es por
	compatibilidad con C, pero son tipos mucho menos robustos que
	las clases C++, de modo que pueden complicar la depuración.
      </para>
    </listitem>
    <listitem>
      <!--
   57. Whenever you use built-in types as globals or automatics, don't
    define them until you can also initialize them. Define variables one
    per line along with their initialization. When defining pointers,
    put the  '*' next to the type name. You can safely do this if you
    define one variable per line. This style tends to be less confusing
    for the reader.
      -->
      <para>
	Siempre que use tipos predefinidos para variables globales o
	automáticas, no los defina hasta que pueda
	inicializarlos. Defina una variable por línea. Cuando defina
	punteros, ponga el '*' al lado del nombre del tipo. Puede
	hacerlo de forma segura si define una variable por línea. Este
	estilo suele resultar menos confuso para el lector.
      </para>
    </listitem>
    <listitem>
      <!--
   58. Guarantee that initialization occurs in all aspects of your
      code. Perform all member initialization in the constructor
      initializer list, even built-in types (using pseudo-constructor
      calls). Using the constructor initializer list is often more
      efficient when initializing subobjects; otherwise the default
      constructor is called, and you end up calling other member
      functions (probably operator=) on top of that in order to get the
      initialization you want.
      -->
      <para>
	Garantize que tiene lugar la inicialización en todos los
	aspectos de su programa. Inicialice todos los atributos en la
	lista de inicialización del constructor, incluso para los tipo
	predefinidos (usando los pseudo-constructores). Usar la lista de
	inicialización del constructor es normalmente más eficiente
	cuando se inicializan subobjetos; si no se hace se invocará el
	constructor por defecto, y acabará llamando a otros métodos
	(probablemnte el <oper>operator=</oper>) para conseguir la
	inicialización que desea.
      </para>
    </listitem>
    <listitem>
      <!--
    59. Don't use the form MyType a = b; to define an object. This one
      feature is a major source of confusion because it calls a
      constructor instead of the operator=. For clarity, always be
      specific and use the form MyType a(b); instead. The results are
      identical, but other programmers won't be confused.
      -->
      <para>
	No use la forma <code>MyType a = b;</code> para definir un
	objeto. Esta es una de la mayores fuentes de confusión porque
	llama a un contructor en lugar de al
	<oper>operator=</oper>. Por motivos de claridad, sea específico
	y use mejor la forma <code>MyType a(b);</code>. Los resultados
	son idénticos, pero el lector no se podrá confundir.
      </para>
    </listitem>
    <listitem>
      <!--
    60. Use the explicit casts described in Chapter 3. A cast overrides
      the normal typing system and is a potential error spot. Since the
      explicit casts divide C's one-cast-does-all into classes of
      well-marked casts, anyone debugging and maintaining the code can
      easily find all the places where logical errors are most likely to
      happen.
      -->
      <para>
	Use los moldes explícitos descritos en el Capítulo 3. Un molde
	reemplaza el sistema normal de tipado y es un punto de
	error. Como los moldes explícitos separan los un-molde-lo
	hace-todo de C en clases de moldes bien-marcados, cualquiera que
	depure o mantenga el código podrá encontrar fácilmente todo los
	sitios en los que es más probable que sucedan errores lógicos.
      </para>
    </listitem>
    <listitem>
      <!--
    61. For a program to be robust, each component must be robust. Use all
      the tools provided by C++: access control, exceptions,
      const-correctness, type checking, and so on in each class you
      create. That way you can safely move to the next level of
      abstraction when building your system.
      -->
      <para>
	Para que un programa sea robusto, cada componente debe ser
	robusto. Use todas las herramientas que proporciona C++: control
	de acceso, excepciones, constantes, comprobación de tipos, etc
	en cada clase que cree. De ese modo podrá pasar de una forma
	segura al siguiente nivel de abstracción cuando construya su
	sistema.
      </para>
    </listitem>
    <listitem>
      <!--
    62. Build in const-correctness. This allows the compiler to point out
      bugs that would otherwise be subtle and difficult to find. This
      practice takes a little discipline and must be used consistently
      throughout your classes, but it pays off.
      -->
      <para>
	Use las constantes con corrección. Esto permite que el
	compilador advierta de errores que de otro modo serían sutiles y
	difíciles de encontrar. Esta práctica requiere de cierta
	disciplina y se debe usar de modo consistente en todas sus
	clases, pero merece la pena.
      </para>
    </listitem>
    <listitem>
      <!--
    63. Use compiler error checking to your advantage. Perform all
      compiles with full warnings, and fix your code to remove all
      warnings. Write code that utilizes the compile-time errors and
      warnings rather than that which causes runtime errors (for
      example, don't use variadic argument lists, which disable all
      type checking). Use assert( ) for debugging, but use exceptions
      for runtime errors.
      -->
      <para>
	Use la comprobación de tipos del compilador en su
	beneficio. Haga todas las compilaciones con todos los avisos
	habilitados y arregle el código para eliminar todas las
	advertencias. Escriba código que utilice los errores y
	advertencias de compilación (por ejemplo, no use listas
	de argumentos variables, que eliminar todas los comprobaciones
	de tipos). Use <function>assert()</function> para depurar, pero
	use excepciones para los errores de ejecución.
      </para>
    </listitem>
    <listitem>
      <!--
    64. Prefer compile-time errors to runtime errors. Try to handle an
      error as close to the point of its occurrence as possible. Prefer
      dealing with the error at that point to throwing an
      exception. Catch any exceptions in the nearest handler that has
      enough information to deal with them. Do what you can with the
      exception at the current level; if that doesn't solve the
      problem, rethrow the exception. (See Volume 2 for more details.)
      -->
      <para>
	Son preferibles los errores de compilación que los de
	ejecución. Intente manejar un error tan cerca del punto donde
	ocurre como sea posible. Es mejor tratar el error en ese punto
	que elevar una excepción. Capture cualqueir excepción en el
	manejador más cercano que tenga suficiente información para
	tratarla. Haga lo que pueda con la excepción en el nivel actual;
	si no puede resolver el problema, relance la excepción. (Vea el
	Volumen 2 si necesita más detalles.)
      </para>
    </listitem>
    <listitem>
      <!--
    65. If you're using exception specifications (see Volume 2 of this
      book, downloadable from www.BruceEckel.com, to learn about
      exception handling), install your own unexpected( ) function using
      set_unexpected( ). Your unexpected( ) should log the error and
      rethrow the current exception. That way, if an existing function
      gets overridden and starts throwing exceptions, you will have a
      record of the culprit and can modify your calling code to handle
      the exception.
      -->
      <para>
	Si está usando las especificaciones de excepción (vea el Volumen
	2 de este libro, disponible en <ulink
	url="http://www.bruceeckel.com">www.BruceEckel.com</ulink>, para
	aprender sobre manejo de excepciones), instale su propia función
	<function>unexpected()</function> usando
	<function>set_unexpected()</function>. Su
	<function>unexpected()</function> debería registrar el error y
	relanzar la excepción actual. De ese modo, si una función
	existente es reemplazada y eleva excepciones, dispondrá de un
	registro de FIXME:culprint y podrá modificar el código que la
	invoca para manejar la excepción.
      </para>
    </listitem>
    <listitem>
      <!--
    66. Create a user-defined terminate( ) (indicating a programmer error)
      to log the error that caused the exception, then release system
      resources, and exit the program.
        -->
      <para>
	Cree un <function>terminate()</function> definida por el usuario
	(indicando un error del programador) para registrar el error que
	causó la excepción, después libere los recursos del sistema, y
	termine el programa.
      </para>
    </listitem>
    <listitem>
      <!--
    67. If a destructor calls any functions, those functions might throw
      exceptions. A destructor cannot throw an exception (this can
      result in a call to terminate( ), which indicates a programming
      error), so any destructor that calls functions must catch and
      manage its own exceptions.
       -->
      <para>
	Si un destructor llama a cualquier función, esas funciones
	podrían elevar excepciones. Un destructor no puede elevar una
	excepción (eso podría ocasionar una llamada a
	<function>terminate()</function>, lo que indica un error de
	programación), así que cualquier destructor que llame a otras
	funciones debe capturar y tratar sus propias excepciones.
      </para>
    </listitem>
    <listitem>
      <!--
    68. Don't create your own "decorated" private data member names
      (prepending underscores, Hungarian notation, etc.), unless you
      have a lot of pre-existing global values; otherwise, let classes
      and namespaces do the name scoping for you.
        -->
      <para>
	No <quote>decore</quote> los nombres de sus atributos privados
	(poniendo guiones bajos, notación húngara, etc.), a menos que
	tenga un montón de valores globales ya existentes; en cualquier
	otro caso, deje que las clases y los espacios de nombres definan
	el ámbito de los nombres por usted.
      </para>
    </listitem>
    <listitem>
      <!--
    69. Watch for overloading. A function should not conditionally execute
      code based on the value of an argument, default or not. In this
      case, you should create two or more overloaded functions instead.
      -->
      <para>
	Ponga atención a la sobrecarga. Una función no debería ejecutar
	código condicionalmente basandose en el valor de un argumento,
	sea por defecto o no. En su lugar, debería crear dos o más
	métodos sobrecargados.
      </para>
    </listitem>
    <listitem>
      <!--
    70. Hide your pointers inside container classes. Bring them out only
      when you are going to immediately perform operations on
      them. Pointers have always been a major source of bugs. When you
      use new, try to drop the resulting pointer into a
      container. Prefer that a container "own" its pointers so it's
      responsible for cleanup. Even better, wrap a pointer inside a
      class; if you still want it to look like a pointer, overload
      operator-> and operator*. If you must have a free-standing
      pointer, always initialize it, preferably to an object address,
      but to zero if necessary. Set it to zero when you delete it to
      prevent accidental multiple deletions.
      -->
      <para>
	Oculte sus punteros dentro de clases contenedor. Dejelos fuera
	sólo cuando vaya a realizar operaciones con ellos. Los punteros
	ha sido siempre la mayor fuente de errores. Cuando use
	<kw>new</kw>, intente colocar el puntero resultante en un
	contenedor. Es preferible que un contenedor <quote>posea</quote>
	sus punteros y sea responsable de la limpieza. Incluso mejor,
	envuelva un puntero dentro de una clase; si aún así quiere que
	parezca un puntero, sobrecargue <oper>operator-></oper> y
	<oper>operator*</oper>. Si necesita tener un puntero
	normal, inicialicelo siempre, preferiblemente con
	la dirección de un objeto, o cero si es necesario. Asignele un
	cero cuando le libere para evitar liberaciones múltiples.
      </para>
    </listitem>
    <listitem>
      <!--
    71. Don't overload global new and delete; always do this on a
      class-by-class basis. Overloading the global versions affects the
      entire client programmer project, something only the creators of a
      project should control. When overloading new and delete for
      classes, don't assume that you know the size of the object;
      someone may be inheriting from you. Use the provided argument. If
      you do anything special, consider the effect it could have on
      inheritors.
      -->
      <para>
	No sobrecargue los <kw>new</kw> y <kw>delete</kw>
	globales. Hágalo siempre en cada clase. Sobrecargar las
	versiones globales affecta la proyecto completo, algo que sólo
	los creadores del proyecto debería controlar. Cuando sobrecargue
	<kw>new</kw> y <kw>delete</kw> en las clases, no asume que
	conoce el tamaño del objeto; alguien puede heredar de esa
	clase. Use el argumento proporcionado. Si hace algo especial,
	considere el efecto que podría tener en las clases derivadas.
      </para>
    </listitem>
    <listitem>
      <!--
    72. Prevent object slicing. It virtually never makes sense to upcast
      an object by value. To prevent upcasting by value, put pure
      virtual functions in your base class.
      -->
      <para>
	Evite el troceado de objetos. Prácticamente nunca tiene sentido
	hacer upcast de un objeto por valor. Para evitar el upcast por
	valor, use métodos virtuales puros en su clase base.
      </para>
    </listitem>
    <listitem>
      <!--
    73. Sometimes simple aggregation does the job. A "passenger comfort
      system" on an airline consists of disconnected elements: seat,
      air conditioning, video, etc., and yet you need to create many of
      these in a plane. Do you make private members and build a whole
      new interface? No - in this case, the components are also part of
      the public interface, so you should create public member
      objects. Those objects have their own private implementations,
      which are still safe. Be aware that simple aggregation is not a
      solution to be used often, but it does happen.
      -->
      <para>
	A veces la agregación simple resuelve el problema. Un
	FIXME:<quote>sistema conforme al pasajero</quote> en una línea
	aérea consta en elementos desconectados: asiento, aire
	acondicionado, video, etc., y todavía necesita crear muchos más
	en un avión. ¿Debe crear miembros privados y construir una nueva
	interfaz completa? No - en este caso, los componentes también
	son parte de la interfaz pública, así que deberían ser objetos
	miembros públicos. Esos objetos tienen sus propias
	implementaciones privadas, que continúan seguras. Sea consciente
	de que la agregación simple no es una solución usan a menudo,
	pero que puede ocurrir.
      </para>
    </listitem>
  </orderedlist>
</appendix>
